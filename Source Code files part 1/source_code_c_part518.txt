s",
                "%B",
                fForceRefresh
                ));

    LockAutoProxy();

    if (! IsOnAsyncAutoProxyThread() )
    {
        AUTO_PROXY_ASYNC_MSG *pQueryForInfo;

        error = _Error;
        if ( error != ERROR_SUCCESS)
        {            
            goto quit; // obj is not initalized properly
        }

        if (!IsConfigValidForAutoProxyThread() )
        {
            goto quit; // disable & bail, we're not setup for this
        }

        pQueryForInfo = new AUTO_PROXY_ASYNC_MSG(PROXY_MSG_INIT);

        if (pQueryForInfo == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        //
        // Enabled a forced refresh if the user orders it through the UI,
        //   for unknown new connections we don't block the user on auto-detect,
        //   since he didn't really order it
        //

        pQueryForInfo->SetForceRefresh(fForceRefresh);

        if ( !fForceRefresh && IsStaticFallbackEnabled() ) {
            SetState(AUTO_PROXY_PENDING);
        } else {
            SetState(AUTO_PROXY_BLOCKED);
        }

        error = QueueAsyncAutoProxyRequest(
                &pQueryForInfo  // don't worry, this request won't block us.
                );
    }

quit:

    if ( error != ERROR_SUCCESS  && 
         error != ERROR_IO_PENDING )
    {
        SetState(AUTO_PROXY_DISABLED); // disable in case something critical happens
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}

DWORD
AUTO_PROXY_DLLS::StartBackroundDetectionIfNeeded(
    VOID
    )
{
    DWORD error = ERROR_SUCCESS;

    LockAutoProxy();
    if ( _hAutoProxyThread == NULL ) {
        error = RefreshProxySettings(FALSE);
    }
    UnlockAutoProxy();

    return error;
}

DWORD
AUTO_PROXY_DLLS::QueryProxySettings(
    IN OUT AUTO_PROXY_ASYNC_MSG **ppQueryForInfo
    )

/*++

Routine Description:

    Performs a query for proxy information using auto-proxy to anwser our query.

    Assumes this is not called from auto-proxy thread/

Arguments:

    ppQueryForInfo - Pointer to pointer to Message object that contains state information
                        used in the query.   If the object needs to be allocated on the heap
                        then the pointer will change to reflect the new object ptr.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    AUTO_PROXY_LIST_ENTRY * papleAutoProxy;
    DWORD error = ERROR_SUCCESS;
    BOOL fUnlocked = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::QueryProxySettings",
                "%x",
                ppQueryForInfo
                ));


    INET_ASSERT(ppQueryForInfo);
    INET_ASSERT(*ppQueryForInfo);
    INET_ASSERT((*ppQueryForInfo)->QueryForInfoMessage() == PROXY_MSG_GET_PROXY_INFO);
    //INET_ASSERT(!IsOnAsyncAutoProxyThread());

    LockAutoProxy();

    //
    // ALWAYS force this function to exec it auto-proxy calls on the
    //   async auto-proxy thread.
    //

    if ( IsAutoProxy() &&
        !IsOnAsyncAutoProxyThread() &&
         IsAutoProxyGetProxyInfoCallNeeded(*ppQueryForInfo))
    {
        if ( GetState() == AUTO_PROXY_PENDING )
        {

            //
            // If we're doing a pending detection, then
            //  fallback to standby settings, and if we fail
            //  with standby settings, we should get re-called to here
            //  and if we're then still detecting, then
            //  we'll block on the detection result
            //

            if ( ! (*ppQueryForInfo)->IsBackroundDetectionPending() )
            {
                error = StartBackroundDetectionIfNeeded();
                if (error != ERROR_SUCCESS ) {
                    goto quit;
                }
                (*ppQueryForInfo)->SetBackroundDetectionPending(TRUE);
                if ( ! (*ppQueryForInfo)->IsAlloced() )
                {
                    *ppQueryForInfo = new AUTO_PROXY_ASYNC_MSG(*ppQueryForInfo);

                    if ( *ppQueryForInfo == NULL ) {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                goto quit;
            }
        }
        else if (!(_ProxySettings.dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DONT_CACHE_PROXY_RESULT) &&
                   GlobalAutoProxyCacheEnable)
        {
            (*ppQueryForInfo)->SetCanCacheResult(TRUE);
        }

        //
        // If we need to show indication during detection,
        //   then do so now before we block
        //

        if ( (*ppQueryForInfo)->IsShowIndication() &&
                (GetState() == AUTO_PROXY_PENDING ||
                 GetState() == AUTO_PROXY_BLOCKED))
        {
            UnlockAutoProxy();
            fUnlocked = TRUE;

            InternetIndicateStatus(INTERNET_STATUS_DETECTING_PROXY, NULL, 0);
        }
        else
        {
            UnlockAutoProxy();
            fUnlocked = TRUE;
        }

        // always disable unless we're ready to renter on a failure
        (*ppQueryForInfo)->SetBackroundDetectionPending(FALSE);

        error = QueueAsyncAutoProxyRequest(ppQueryForInfo);
        goto quit;
    }

    // always disabled it unless we're ready to reenter on a failure
    (*ppQueryForInfo)->SetBackroundDetectionPending(FALSE);

quit:

    if ( !fUnlocked )
    {
        UnlockAutoProxy();
    }

    DEBUG_LEAVE(error);

    return error;
}

BOOL
AUTO_PROXY_DLLS::IsConfigValidForAutoProxyThread(
    VOID
    )
/*++

Routine Description:

    Decide if we need the auto-thread to either download auto-proxy ot
      go off and detect for auto-proxy on the network

Arguments:

    none.

Return Value:

    BOOL
        TRUE - if we have a valid proxy config

        FALSE - if we not valid

--*/

{
    LPINTERNET_PROXY_INFO_EX lpProxySettings = &_ProxySettings;

    if ( (lpProxySettings->dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
          lpProxySettings->lpszAutoconfigUrl != NULL &&
         *lpProxySettings->lpszAutoconfigUrl != '\0' )
    {
        return TRUE; // old behavior for auto-proxy URL config
    }

    if ( IsProxyAutoDetectEnabled(lpProxySettings))
    {
        return TRUE;
    }

    return FALSE; // do nothing
}

BOOL
AUTO_PROXY_DLLS::IsStaticFallbackEnabled(
    VOID
    )
/*++

Routine Description:

    Decide if we need to block on the auto-proxy information,
     or if we can fallback to static settings when auto-proxy is initalizing/detecting.

Arguments:

    none.

Return Value:

    BOOL
        TRUE - if we keep going with static settings

        FALSE - we'll need to block requests until auto-proxy is intialized

--*/

{

    if ( (_ProxySettings.dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
          _ProxySettings.lpszAutoconfigUrl != NULL &&
         *_ProxySettings.lpszAutoconfigUrl != '\0' )
    {
        return FALSE; // block, don't bypass, this is old behavior for Auto-proxy URLs
    }

    if (  IsProxyAutoDetectEnabled() )

    {
        if ( !(_ProxySettings.dwAutoDiscoveryFlags & (AUTO_PROXY_FLAG_DETECTION_RUN | AUTO_PROXY_FLAG_USER_SET)) ) {
            return TRUE; // detection SHOULD NOT BLOCK THE FIRST TIME, in case it doesn't work
        }

        if ( _ProxySettings.lpszConnectionName != NULL )
        {
            if ( _ProxySettings.lpszLastKnownGoodAutoConfigUrl == NULL ) 
            {
                return TRUE; // detection SHOULD NOT BE DEPENDED upon with Dialup, unless it has something
            }

            if ( _ProxySettings.dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_SUSPECT)
            {
                return TRUE; // detection should not block when we're in a hosed state.
            }
        }
    }



    return FALSE; // block
}

VOID
AUTO_PROXY_DLLS::SetExpiredUrl(
    LPCSTR lpszUrl
    )
/*++

Routine Description:

    Sets default expiry time on the if none is specified on the cached URL. 

Arguments:

    lpszUrl -

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/
{
    CACHE_ENTRY_INFOEX Cei;
    DWORD dwCeiSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);
    BOOL fRet;

    fRet = GetUrlCacheEntryInfoExA(
            lpszUrl,
            (INTERNET_CACHE_ENTRY_INFOA *) &Cei,
            &dwCeiSize,
            NULL,
            NULL,
            NULL,
            INTERNET_CACHE_FLAG_GET_STRUCT_ONLY
            );


    if ( fRet && 
         (FT2LL(Cei.ExpireTime) == LONGLONG_ZERO))
    {
        //
        // Set default expiry as: current time + some default expiry
        //

        GetCurrentGmtTime(&Cei.ExpireTime);

        *(LONGLONG *) &(Cei.ExpireTime) += (12 * (24 * ONE_HOUR_DELTA));

        //
        // Re-Save Cache entry with updated default expiry time for PAC/INS file.
        //

        SetUrlCacheEntryInfoA(
                lpszUrl,
                (INTERNET_CACHE_ENTRY_INFOA *) &Cei,
                CACHE_ENTRY_EXPTIME_FC
                );

    }

}

BOOL
AUTO_PROXY_DLLS::IsExpiredUrl(
    LPCSTR lpszUrl
    )
/*++

Routine Description:

    Is Url Expired?  If it isn't don't force a reload/update of data

Arguments:

    lpszUrl -

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/
{
    CACHE_ENTRY_INFOEX Cei;
    DWORD dwCeiSize = sizeof(INTERNET_CACHE_ENTRY_INFOA);
    BOOL fRet;

    fRet = GetUrlCacheEntryInfoExA(
            lpszUrl,
            (INTERNET_CACHE_ENTRY_INFOA *) &Cei,
            &dwCeiSize,
            NULL,
            NULL,
            NULL,
            INTERNET_CACHE_FLAG_GET_STRUCT_ONLY 
            );

    if (!fRet) {
        return TRUE; // expired, not in the cache
    }

    if ( IsExpired(&Cei, 0, &fRet) )
    {
        return TRUE; // expired, like really it is
    }

    return FALSE; // not expired
}


BOOL
AUTO_PROXY_DLLS::IsProxyAutoDetectNeeded(
    LPINTERNET_PROXY_INFO_EX lpProxySettings
    )

/*++

Routine Description:

  Detects whether we need to actually run a detection on the network,
    or whether we can resuse current results from previous runs

Arguments:

    lpProxySettings - structure to fill

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD addressCount;
    LPDWORD * addressList;
    LPHOSTENT lpHostent;
    BOOL fSuspectBadDetect = FALSE;

    INET_ASSERT(IsProxyAutoDetectEnabled(lpProxySettings));

    // we haven't detected before on this connection, so we need to do it.
    if ( !(lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_RUN) ) {
        return TRUE; // detect needed
    }

    // if we're flagged to ALWAYS force detection, then do this
    if (lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_ALWAYS_DETECT) {
        return TRUE; // detect needed
    }

    //
    // Check for an expired detected Url, detect it its expired
    //  Since this is RAS we can't rely on the host IP staying 
    //  the same everytime.
    //

    if (  lpProxySettings->lpszLastKnownGoodAutoConfigUrl && 
          lpProxySettings->lpszConnectionName &&          
        ! IsExpiredUrl(lpProxySettings->lpszLastKnownGoodAutoConfigUrl))
    {
        // if we're suspecting bad settings, make sure to redirect.
        if ( ! (lpProxySettings->dwAutoDiscoveryFlags & AUTO_PROXY_FLAG_DETECTION_SUSPECT) ) {
            return FALSE; 
        }

        //otherwise, we'll be careful
        fSuspectBadDetect = TRUE;
    }

    //
    // Check for IP addresses that no longer match, indicating a network change
    //

    __try
    {
        lpHostent = _I_gethostbyname(NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        g_fGetHostByNameNULLFails = TRUE;
        lpHostent = NULL;
    }
    ENDEXCEPT

    if (lpHostent &&
        lpProxySettings->pdwDetectedInterfaceIp == NULL)
    {
        return TRUE; // detect needed, no current IPs saved from last run
    }

    if ( lpHostent != NULL &&
         lpProxySettings->pdwDetectedInterfaceIp != NULL)
    {

        for ( addressCount = 0;
              lpHostent->h_addr_list[addressCount] != NULL;
              addressCount++ );  // gather count

        if ( addressCount != lpProxySettings->dwDetectedInterfaceIpCount ) {
            return TRUE; // detect needed, the IP count is different
        }

        if ( fSuspectBadDetect) {
            return FALSE; // detect NOT needed, because the IP addresses may change from dialup/to dialup
        }

        for (DWORD i = 0; i < addressCount; i++)
        {
            //dwAddress[iCount] = *((LPDWORD)(ph->h_addr_list[iCount]));

            if ( *((LPDWORD)(lpHostent->h_addr_list[i])) != lpProxySettings->pdwDetectedInterfaceIp[i] ) {
                return TRUE; // detect needed, mismatched values
            }
        }
    }


    return FALSE; // default, do not need to redetect
}


DWORD
AUTO_PROXY_DLLS::GetHostAddresses(
    DWORD ** ppdwDetectedInterfaceIp,
    DWORD *  pdwDetectedInterfaceIpCount
    )
/*++

Routine Description:

  Copies out the current host information into an
    a array/ProxyInfoStruct for later comparision.

Arguments:

    lpProxySettings - structure to fill

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD addressCount;
    LPDWORD * addressList;
    LPHOSTENT lpHostent;
    DWORD error = ERROR_SUCCESS;

    *pdwDetectedInterfaceIpCount = 0;

    if ( *ppdwDetectedInterfaceIp )
    {
        FREE_MEMORY(*ppdwDetectedInterfaceIp);
        *ppdwDetectedInterfaceIp = NULL;
    }

    //
    // Gather IP addresses and start copying them over
    //

    __try
    {
        lpHostent = _I_gethostbyname(NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        g_fGetHostByNameNULLFails = TRUE;
        lpHostent = NULL;
    }
    ENDEXCEPT

    if (lpHostent == NULL ) {
        goto quit;
    }

    for ( addressCount = 0;
          lpHostent->h_addr_list[addressCount] != NULL;
          addressCount++ );  // gather count

    *ppdwDetectedInterfaceIp = (LPDWORD)
        ALLOCATE_MEMORY(LMEM_FIXED, addressCount
                        * sizeof(DWORD));

    if ( *ppdwDetectedInterfaceIp == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    
    if ( *ppdwDetectedInterfaceIp != NULL)
    {
        *pdwDetectedInterfaceIpCount = addressCount;

        for (DWORD i = 0; i < addressCount; i++)
        {
            (*ppdwDetectedInterfaceIp)[i] =
                *((LPDWORD)(lpHostent->h_addr_list[i]));
        }
    }

quit:
    return error;
}


VOID
AUTO_PROXY_DLLS::FreeAutoProxyInfo(
    VOID
    )

/*++

Routine Description:

    Attempts to shutdown the auto-proxy thread (from outside of it), by first signalling
      it with an event and boolean, and then if that fails, forcibly forcing a shutdown
      with TerminateThread.

Arguments:

    none.

Return Value:

    none.

--*/

{
    DWORD dwError;

    LockAutoProxy();

    if ( _hAutoProxyThread != NULL &&
         ! IsOnAsyncAutoProxyThread() )
    {
        HANDLE hAutoProxyThread;
        BOOL fAlreadyInShutDown;

        fAlreadyInShutDown =
            InterlockedExchange((LPLONG)&_fInAutoProxyThreadShutDown, TRUE);

        INET_ASSERT ( ! fAlreadyInShutDown );

        SetEvent(_hAutoProxyThreadEvent);

        if ( _hInternetAbortHandle != NULL )
        {
            InternetCloseHandle(_hInternetAbortHandle);
        }

        hAutoProxyThread = _hAutoProxyThread;

        UnlockAutoProxy();

        //
        // Wait for shutdown of auto-proxy thread.
        //

        if ( hAutoProxyThread )
        {
            dwError = WaitForSingleObject(hAutoProxyThread,
                GlobalIsProcessNtService? INFINITE : 60000);

            if ( dwError != WAIT_OBJECT_0 )
            {
                INET_ASSERT(FALSE);
                // Whistler bug #124628: delete the autoproxy critical section
                // before terminating the autoproxy thread in case the thread
                // is holding the CS.
                SuspendThread(hAutoProxyThread);
                DeleteCriticalSection(&_CritSec);
                
                // reinitialize cs since it will be deleted in the destructor
                memset((LPVOID) &_CritSec, 0, sizeof(CRITICAL_SECTION));
                InitializeCriticalSection(&_CritSec);

                TerminateThread(hAutoProxyThread,ERROR_SUCCESS);

                _hAutoProxyThreadEvent = NULL;
                _hAutoProxyThread = NULL;

                InterlockedExchange((LPLONG)&_fInAutoProxyThreadShutDown, FALSE);
                return;
            }
        }

        LockAutoProxy();

        CloseHandle(_hAutoProxyThread);
        CloseHandle(_hAutoProxyThreadEvent);

        _hAutoProxyThreadEvent = NULL;
        _hAutoProxyThread = NULL;

        InterlockedExchange((LPLONG)&_fInAutoProxyThreadShutDown, FALSE);

        UnlockAutoProxy();
    }
    else
    {
        UnlockAutoProxy();
    }
}

BOOL
AUTO_PROXY_LIST_ENTRY::ProxyInfoInvalid(
    IN LPSTR lpszMime,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszProxyHostName,
    IN DWORD dwProxyHostNameLength
    )
{
    BOOL success = TRUE; // don't care if it doesn't succeed

    if ( ! _hAutoConfigDLL )
    {
        if ( LoadEntry() != ERROR_SUCCESS )
            return FALSE;
    }

    if ( ! _fInitializedSuccessfully )
    {
        return FALSE;
    }

    if ( _pProxyInfoInvalid )
    {

        INET_ASSERT(_hAutoConfigDLL);
        INET_ASSERT(!IsBadCodePtr((FARPROC)_pProxyInfoInvalid));

        success = (_pProxyInfoInvalid) ( lpszMime,
                                          lpszUrl,
                                          dwUrlLength,
                                          lpszProxyHostName,
                                          dwProxyHostNameLength
                                          );
    }

    return success;
}



BOOL
AUTO_PROXY_LIST_ENTRY::ProxyDllDeInit(
    IN LPSTR lpszMime,
    IN DWORD dwReserved
    )
{
    BOOL success = TRUE; // don't care if it doesn't succeed

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_LIST_ENTRY::ProxyDllDeInit",
                "%s, %u",
                lpszMime,
                dwReserved
                ));


    INET_ASSERT(_hAutoConfigDLL);

    if ( !_hAutoConfigDLL  )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    if ( ! _fInitializedSuccessfully )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    if ( _pProxyDllDeInit )
    {

        INET_ASSERT(_hAutoConfigDLL);
        INET_ASSERT(!IsBadCodePtr((FARPROC)_pProxyDllDeInit));
#ifdef INET_DEBUG
        INET_ASSERT(!_fUnInited);

        _fUnInited = TRUE;
#endif

        success = (_pProxyDllDeInit) ( lpszMime,
                                       dwReserved
                                       );
    }

    DEBUG_LEAVE(success);
    return success;
}



DWORD
AUTO_PROXY_LIST_ENTRY::GetProxyInfoEx(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )
{
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_LIST_ENTRY::GetProxyInfoEx",
                "%x [%s, %s, %u, %s, %d, %x, %x]",
                pQueryForProxyInfo,
                InternetMapScheme(pQueryForProxyInfo->_tUrlProtocol),
                pQueryForProxyInfo->_lpszUrl,
                pQueryForProxyInfo->_dwUrlLength,
                pQueryForProxyInfo->_lpszUrlHostName,
                pQueryForProxyInfo->_dwUrlHostNameLength,
                pQueryForProxyInfo->_lpszProxyHostName,
                &pQueryForProxyInfo->_dwProxyHostNameLength
                ));

    //if ( ! _hAutoConfigDLL )
    //{
    //    if ( LoadEntry() != ERROR_SUCCESS )
    //    {
    //        DEBUG_LEAVE(FALSE);
    //        return FALSE;
    //    }
    //}

    if ( ! _fInitializedSuccessfully )
    {
        DEBUG_LEAVE(FALSE);
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    INET_ASSERT(_hAutoConfigDLL);
    INET_ASSERT(_pGetProxyInfoEx);
    INET_ASSERT(!IsBadCodePtr((FARPROC)_pGetProxyInfoEx));

    success = (_pGetProxyInfoEx) ( pQueryForProxyInfo->_tUrlProtocol,
                                    pQueryForProxyInfo->_lpszUrl,
                                    pQueryForProxyInfo->_dwUrlLength,
                                    pQueryForProxyInfo->_lpszUrlHostName,
                                    pQueryForProxyInfo->_dwUrlHostNameLength,
                                    pQueryForProxyInfo->_nUrlPort,
                                    &(pQueryForProxyInfo->_tProxyScheme),
                                    &(pQueryForProxyInfo->_lpszProxyHostName),
                                    &(pQueryForProxyInfo->_dwProxyHostNameLength),
                                    &(pQueryForProxyInfo->_nProxyHostPort)
                                    );

quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) success;

    DEBUG_LEAVE(error);
    return error;

}



DWORD
AUTO_PROXY_LIST_ENTRY::GetProxyInfo(
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )
{
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;
    LPSTR lpszAutoProxyReturnInfo;
    DWORD dwAutoProxyReturnInfoSize;

    INET_ASSERT(pQueryForProxyInfo);

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_LIST_ENTRY::GetProxyInfo",
                "%x [%s, %u, %s, %d, %x, %x]",
                pQueryForProxyInfo,
                pQueryForProxyInfo->_lpszUrl,
                pQueryForProxyInfo->_dwUrlLength,
                pQueryForProxyInfo->_lpszUrlHostName,
                pQueryForProxyInfo->_dwUrlHostNameLength,
                pQueryForProxyInfo->_lpszProxyHostName,
                &pQueryForProxyInfo->_dwProxyHostNameLength
                ));

    //if ( ! _hAutoConfigDLL )
    //{
    //    if ( LoadEntry() != ERROR_SUCCESS )
    //    {
    //        DEBUG_LEAVE(FALSE);
    //        return FALSE;
    //    }
    //}

    if ( ! _fInitializedSuccessfully )
    {
        DEBUG_LEAVE(FALSE);
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    INET_ASSERT ( _pGetProxyInfo );
    INET_ASSERT(_hAutoConfigDLL);
    INET_ASSERT(!IsBadCodePtr((FARPROC)_pGetProxyInfo));

    success = (_pGetProxyInfo) (    pQueryForProxyInfo->_lpszUrl,
                                    pQueryForProxyInfo->_dwUrlLength,
                                    pQueryForProxyInfo->_lpszUrlHostName,
                                    pQueryForProxyInfo->_dwUrlHostNameLength,
                                    &lpszAutoProxyReturnInfo,
                                    &dwAutoProxyReturnInfoSize
                                    );


    if ( success )
    {
        if ( pQueryForProxyInfo->_tUrlProtocol == INTERNET_SCHEME_HTTPS )
        {
            pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTPS;
        }
        else
        {
            pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTP;
        }

        INET_ASSERT(pQueryForProxyInfo->_pProxyState == NULL);

        pQueryForProxyInfo->_pProxyState = new PROXY_STATE(lpszAutoProxyReturnInfo,
                                                          dwAutoProxyReturnInfoSize,
                                                          TRUE,  // parse netscape-style proxy list
                                                          pQueryForProxyInfo->_tProxyScheme,
                                                          pQueryForProxyInfo->_nProxyHostPort
                                                          );


        INET_ASSERT(lpszAutoProxyReturnInfo);
        GlobalFree(lpszAutoProxyReturnInfo);  // clean up jsproxy.dll return string

        if ( pQueryForProxyInfo->_pProxyState  == NULL )
        {
           error = ERROR_NOT_ENOUGH_MEMORY;
           goto quit;
        }

        error = pQueryForProxyInfo->_pProxyState->GetError();

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }


quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) success;

    DEBUG_LEAVE(error);
    return error;

}


BOOL
AUTO_PROXY_LIST_ENTRY::ProxyDllInit (
    IN DWORD                  dwVersion,
    IN LPSTR                  lpszDownloadedTempFile,
    IN LPSTR                  lpszMime,
    IN AUTO_PROXY_HELPER_APIS *pAutoProxyCallbacks,
    IN DWORD_PTR              dwReserved
    )
{
    BOOL success = FALSE;

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_LIST_ENTRY::ProxyDllInit",
                "%u, %s, %s, %x, %u",
                dwVersion,
                lpszDownloadedTempFile,
                lpszMime,
                pAutoProxyCallbacks,
                dwReserved
                ));


    INET_ASSERT ( _hAutoConfigDLL );

    if ( _pProxyDllInit )
    {

        INET_ASSERT(_hAutoConfigDLL);
        INET_ASSERT(!IsBadCodePtr((FARPROC)_pProxyDllInit));

        success = (_pProxyDllInit) ( dwVersion,
                                     lpszDownloadedTempFile,
                                     lpszMime,
                                     pAutoProxyCallbacks,
                                     dwReserved
                                     );

#ifdef INET_DEBUG
        _fUnInited = FALSE;
#endif
        _fInitializedSuccessfully = success;

    }

    DEBUG_LEAVE(success);
    return success;
}

VOID
AUTO_PROXY_LIST_ENTRY::UnloadEntry(
    VOID
    )

/*++

Routine Description:

    Unloads the DLL function entry points for an Auto-Proxy DLL.

    WARNING: Must be called only on Auto-proxy thread context!

Arguments:

    none.

Return Value:

    none.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "AUTO_PROXY_LIST_ENTRY::UnloadEntry",
                NULL
                ));


    if ( _fInitializedSuccessfully &&
         _pProxyDllDeInit )
    {
        ProxyDllDeInit(
            _lpszMimeType,
            0
            );
    }

    if ( _hAutoConfigDLL )
    {
        // HACK HACK This call will block an dll unload time because of the 
        // loader critical section. Ideally we should move this free to the 
        // main thread, but since we are in the midst of IE5 RC's we are doing
        // the least risky change i.e. leaking jsproxy.dll in the process. 
        if (!GlobalDynaUnload)
        {
            FreeLibrary(_hAutoConfigDLL);
        }

        _pGetProxyInfo      = NULL;
        _pGetProxyInfoEx    = NULL;
        _pProxyDllInit      = NULL;
        _pProxyDllDeInit    = NULL;
        _pProxyInfoInvalid  = NULL;
    }

    DEBUG_LEAVE(0);
}


DWORD
AUTO_PROXY_LIST_ENTRY::LoadEntry(
    VOID
    )

/*++

Routine Description:

    Loads the DLL function entry points for an Auto-Proxy DLL.

Arguments:

    none.

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_LIST_ENTRY::LoadEntry",
                ""
                ));

    if ( _lpszFileExtensions == NULL  ||
         _lpszDllFilePath == NULL )
    {
        error =  ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    _pGetProxyInfo      = NULL;
    _pProxyInfoInvalid  = NULL;
    _pProxyDllDeInit    = NULL;
    _pProxyDllInit      = NULL;
    _pGetProxyInfoEx    = NULL;

    if ( _hAutoConfigDLL )
    {
        FreeLibrary(_hAutoConfigDLL);
        _hAutoConfigDLL  = NULL;
    }

    _hAutoConfigDLL = LoadLibrary(_lpszDllFilePath);

    if ( _hAutoConfigDLL == NULL )
    {
        error = GetLastError();
        goto quit;
    }



    _pGetProxyInfo     = (GET_PROXY_INFO_FN)
                        GetProcAddress(_hAutoConfigDLL, GET_PROXY_INFO_FN_NAME);


    _pGetProxyInfoEx   = (GET_PROXY_INFO_EX_FN)
                        GetProcAddress(_hAutoConfigDLL, GET_PROXY_INFO_EX_FN_NAME);


    _pProxyInfoInvalid = (PROXY_INFO_INVALID_FN)
                        GetProcAddress(_hAutoConfigDLL, PROXY_INFO_INVALID_FN_NAME);


    _pProxyDllDeInit   = (PROXY_DLL_DEINIT_FN)
                        GetProcAddress(_hAutoConfigDLL, PROXY_DLL_DEINIT_FN_NAME);


    _pProxyDllInit     = (PROXY_DLL_INIT_FN)
                        GetProcAddress(_hAutoConfigDLL, PROXY_DLL_INIT_FN_NAME );


    if ( !_pProxyDllInit && !_pProxyDllDeInit && !_pProxyInfoInvalid && !_pGetProxyInfo && !_pGetProxyInfoEx)
    {
        error = GetLastError();
        goto quit;
    }

    if ( !_pProxyDllInit )
    {
        //
        // If they don't export this entry point, than we can't initialize them, so
        //  we pretend to have initialized them.
        //

        _fInitializedSuccessfully = TRUE;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


BOOL
AUTO_PROXY_DLLS::SelectAutoProxyByMime(
    IN LPSTR lpszMimeType
    )

/*++

Routine Description:

    Sets an internal pointer inside the object to point to a found auto-proxy DLL.
        The MIME type given is used to find the match.

Arguments:

    lpszMimeType - The Mime type to search on.

Return Value:

    BOOL
        TRUE    - success

        FALSE - failure

--*/


{

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::SelectAutoProxyByMime",
                "%s",
                lpszMimeType
                ));

    BOOL found = FALSE;
    AUTO_PROXY_LIST_ENTRY * info = NULL;

    LockAutoProxy();

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, AUTO_PROXY_LIST_ENTRY, _List);

        if (info->_lpszMimeType && lstrcmpi(lpszMimeType, info->_lpszMimeType) == 0 )
        {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    if ( found )
    {
        SelectAutoProxy(info);
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(found);

    return found;

}

BOOL
AUTO_PROXY_DLLS::SelectAutoProxyByDefault(
    VOID
    )
{

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::SelectAutoProxyByDefault",
                NULL
                ));

    BOOL found = FALSE;
    AUTO_PROXY_LIST_ENTRY * info = NULL;

    LockAutoProxy();

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, AUTO_PROXY_LIST_ENTRY, _List);

        if (info->IsDefault() )
        {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    if ( found )
    {
        SelectAutoProxy(info);
    }

    DEBUG_LEAVE(found);

    UnlockAutoProxy();

    return found;
}

BOOL
AUTO_PROXY_DLLS::SelectAutoProxyByFileExtension(
    LPCSTR lpszAutoProxyPath
    )
{

    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "AUTO_PROXY_DLLS::SelectAutoProxyByFileExtension",
                "%s",
                lpszAutoProxyPath
                ));

    BOOL found = FALSE;
    AUTO_PROXY_LIST_ENTRY * info = NULL;

    LockAutoProxy();

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, AUTO_PROXY_LIST_ENTRY, _List);

        if (info->_lpszFileExtensions &&
                MatchFileExtensionWithUrl(info->_lpszFileExtensions, lpszAutoProxyPath) )
        {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    if ( found )
    {
        SelectAutoProxy(info);
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(found);

    return found;
}

DWORD
AUTO_PROXY_DLLS::GetAutoProxyStringEntry(
    IN LPSTR lpszRegName,
    IN OUT LPSTR * lplpszAllocatedRegValue
    )
{
    DWORD dwcbNewValue = 0;
    DWORD error = ERROR_SUCCESS;

    if ( *lplpszAllocatedRegValue )
    {
        FREE_MEMORY(*lplpszAllocatedRegValue);
        *lplpszAllocatedRegValue = NULL;
    }

    error =
        InternetReadRegistryString(
            lpszRegName,
            NULL,
            &dwcbNewValue
            );

    if ( error == ERROR_SUCCESS )
    {
        dwcbNewValue++;
        *lplpszAllocatedRegValue = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, dwcbNewValue);

        if ( *lplpszAllocatedRegValue == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        error =
            InternetReadRegistryString(
                lpszRegName,
                *lplpszAllocatedRegValue,
                &dwcbNewValue
                );

        if ( error != ERROR_SUCCESS )
        {
            INET_ASSERT((error == ERROR_SUCCESS));
            FREE_MEMORY(*lplpszAllocatedRegValue);
            *lplpszAllocatedRegValue = NULL;
        }
    }

quit:

    return error;
}



DWORD
AUTO_PROXY_DLLS::ReadAutoProxyRegistrySettings(
    VOID
    )

/*++

Routine Description:

    Scans Registry for, and builds linked list of AutoProxy DLLs.

Return Value:

  Success - ERROR_SUCCESS

  Failure -

--*/

{
    HKEY hkSecurity = NULL; // main security key
    DWORD error = ERROR_SUCCESS;
    DWORD dwcbAutoConfigProxy = 0;
    HKEY hkSPMKey = NULL;
    const static CHAR cszMainSecKey[]
        = CSZMAINSECKEY;
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "AUTO_PROXY_DLLS::ReadAutoProxyRegistrySettings",
                ""
                ));

    LockAutoProxy();

    //
    // QFE 1169:  Use the HKCU value as the user agent string if told to do so.
    //            Yes this looks ugly, but it's just to prevent a whole bunch
    //            of ifs and handlers for failures.

    DWORD dwcbBufLen = 0;
    
    if (ERROR_SUCCESS == InternetReadRegistryDwordKey(
            HKEY_CURRENT_USER,
            "AutoConfigCustomUA",
            &dwcbBufLen) &&
        dwcbBufLen)
    {       
        if (NULL == _hInstUrlmon)
        {
            _hInstUrlmon = LoadLibrary("Urlmon.dll");
        }       
        if (_hInstUrlmon)
        {        
            typedef HRESULT (*PFNOBTAINUA)(DWORD, LPSTR, DWORD*);
            CHAR lpszUserAgent[MAX_PATH];
            DWORD cbSize = MAX_PATH;

            PFNOBTAINUA pfnUA = (PFNOBTAINUA)GetProcAddress(_hInstUrlmon,"ObtainUserAgentString");
            if (pfnUA)
            {
                HRESULT hr = (*pfnUA)(0, lpszUserAgent, &cbSize);
                if(S_OK == hr)
                {
                    if ( _lpszUserAgent && (lstrcmpi(_lpszUserAgent, lpszUserAgent) != 0) )
                    {
                        _lpszUserAgent = (LPSTR)
                            FREE_MEMORY(_lpszUserAgent);
                    }
                    if ( _lpszUserAgent == NULL )
                    {
                        _lpszUserAgent = NewString(lpszUserAgent);
                    }
                }
            }
        }
    }

    if (REGOPENKEY( HKEY_CLASSES_ROOT, cszMainSecKey, &hkSecurity ) != ERROR_SUCCESS)
    {
        error = GetLastError();
        goto quit;
    }


    DWORD dwIndex;
    dwIndex = 0;

    do
    {
        CHAR szMime[256];
#ifdef unix
        CHAR szUnixHackMime[256];
#endif /* unix */
        if ( hkSPMKey != NULL )
        {
            REGCLOSEKEY(hkSPMKey);
            hkSPMKey = NULL;
        }

        //
        // Enumerate a List of MIME types, that we accept for auto-proxy
        //

        if (RegEnumKey( hkSecurity, dwIndex, szMime, sizeof(szMime)) != ERROR_SUCCESS )
        {
            goto quit;
        }

        dwIndex++;

        //
        // Open a potential MIME type entry.
        //

        if (REGOPENKEY( hkSecurity, szMime, &hkSPMKey ) != ERROR_SUCCESS)
        {
            INET_ASSERT(0);
            continue;
        }

        //
        // Grab the DLL file name
        //

        DWORD dwType, cbBuf;

        char szDll[MAX_PATH];
        cbBuf = sizeof(szDll);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "DllFile", NULL, &dwType, (LPBYTE) szDll, &cbBuf)
            ||  ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) )
        {
            continue; // no DLL name
        }


        if ( dwType == REG_EXPAND_SZ )
        {
            DWORD dwSize;
            char szDllPathBeforeExpansion[MAX_PATH];

            lstrcpy(szDllPathBeforeExpansion, szDll);

            dwSize = ExpandEnvironmentStrings(szDllPathBeforeExpansion, szDll, ARRAY_ELEMENTS(szDll));

            if (dwSize > ARRAY_ELEMENTS(szDll) || dwSize == 0 )
            {
                INET_ASSERT(FALSE);
                continue;  // not enough room to expand vars?
            }
        }

        //
        // Grab the list of File extensions that are permitted for this Mime Type
        //


        char szFileExtensions[MAX_PATH];
        cbBuf = sizeof(szFileExtensions);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "FileExtensions", NULL, &dwType, (LPBYTE) szFileExtensions, &cbBuf)
            || (dwType != REG_SZ))
        {
            continue; // no DLL name
        }


        //
        // Determine whether its the defaut entry.
        //

        DWORD fIsDefault;
        cbBuf = sizeof(fIsDefault);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "Default", NULL, &dwType, (LPBYTE) &fIsDefault, &cbBuf)
            || ((dwType != REG_DWORD) && (dwType != REG_BINARY)))
        {
            INET_ASSERT (cbBuf == sizeof(DWORD));
            fIsDefault = 0;
        }

        //
        // Determine whether we have any Flags that need to be read
        //  from the registry.
        //

        DWORD dwFlags;

        cbBuf = sizeof(dwFlags);
        if (ERROR_SUCCESS != RegQueryValueEx
                (hkSPMKey, "Flags", NULL, &dwType, (LPBYTE) &dwFlags, &cbBuf)
            || ((dwType != REG_DWORD) && (dwType != REG_BINARY)))
        {
            dwFlags = 0;
        }


        //
        // Now build an entry for it, and add it to our list.
        //
#ifndef unix
        AUTO_PROXY_LIST_ENTRY *apleAutoProxy
             = new AUTO_PROXY_LIST_ENTRY(szDll, szFileExtensions, szMime, fIsDefault, dwFlags);
#else
        strcpy(szUnixHackMime,"application/");
        strcat(szUnixHackMime,szMime);
        AUTO_PROXY_LIST_ENTRY *apleAutoProxy
             = new AUTO_PROXY_LIST_ENTRY(szDll, szFileExtensions, szUnixHackMime, fIsDefault, dwFlags);
#endif /* unix */
        if (!apleAutoProxy)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        if (fIsDefault)
        {
            InsertAtTailOfSerializedList(&_List, &apleAutoProxy->_List);
        }
        else
        {
            InsertAtHeadOfSerializedList(&_List, &apleAutoProxy->_List);
        }

    } while (1);

    error = ERROR_SUCCESS;

quit:

    if ( hkSPMKey != NULL )
    {
        REGCLOSEKEY(hkSPMKey);
    }

    if ( hkSecurity != NULL )
    {
        REGCLOSEKEY(hkSecurity);
    }

    UnlockAutoProxy();

    DEBUG_LEAVE(error);

    return error;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{
    URL_COMPONENTS urlComponents;

    Initalize();

    if ( lpszUrl )
    {
        _lpszUrl      = lpszUrl;
        _dwUrlLength  = lstrlen(lpszUrl);
        _tUrlProtocol = isUrlScheme;
        _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
        _pmaAllocMode = MSG_ALLOC_STACK_ONLY;

        memset(&urlComponents, 0, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);
        urlComponents.lpszHostName = lpszUrlHostName;
        urlComponents.dwHostNameLength = dwUrlHostNameLength;

        //
        // parse out the host name and port. The host name will be decoded; the
        // original URL will not be modified
        //

        if (InternetCrackUrl(lpszUrl, 0, ICU_DECODE, &urlComponents))
        {
           _nUrlPort            = urlComponents.nPort;
           _lpszUrlHostName     = urlComponents.lpszHostName;
           _dwUrlHostNameLength = urlComponents.dwHostNameLength;

           if ( _tUrlProtocol == INTERNET_SCHEME_UNKNOWN )
           {
               _tUrlProtocol = urlComponents.nScheme;
           }

        }
        else
        {
            _Error = GetLastError();
        }
    }
    else
    {
        _Error = ERROR_NOT_ENOUGH_MEMORY;
    }
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{

    Initalize();

    _tUrlProtocol = isUrlScheme;
    _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode = MSG_ALLOC_STACK_ONLY;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    Initalize();

    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;

}

VOID
AUTO_PROXY_ASYNC_MSG::SetProxyMsg(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;
}


AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN PROXY_MESSAGE_TYPE pmProxyQuery
    )
{
    Initalize();

    _pmaAllocMode = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pmProxyQuery = pmProxyQuery;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN AUTO_PROXY_ASYNC_MSG *pStaticAutoProxy
    )
{
    Initalize();

    _tUrlProtocol          = pStaticAutoProxy->_tUrlProtocol;
    _lpszUrl               = (pStaticAutoProxy->_lpszUrl) ? NewString(pStaticAutoProxy->_lpszUrl) : NULL;
    _dwUrlLength           = pStaticAutoProxy->_dwUrlLength;
    _lpszUrlHostName       =
                (pStaticAutoProxy->_lpszUrlHostName ) ?
                NewString(pStaticAutoProxy->_lpszUrlHostName, pStaticAutoProxy->_dwUrlHostNameLength) :
                NULL;
    _dwUrlHostNameLength   = pStaticAutoProxy->_dwUrlHostNameLength;
    _nUrlPort              = pStaticAutoProxy->_nUrlPort;
    _tProxyScheme          = pStaticAutoProxy->_tProxyScheme;

    //
    // ProxyHostName is something that is generated by the request,
    //   therefore it should not be copied OR freed.
    //

    INET_ASSERT( pStaticAutoProxy->_lpszProxyHostName == NULL );
    //_lpszProxyHostName     = (pStaticAutoProxy->_lpszProxyHostName ) ? NewString(pStaticAutoProxy->_lpszProxyHostName) : NULL;


    _dwProxyHostNameLength = pStaticAutoProxy->_dwProxyHostNameLength;
    _nProxyHostPort        = pStaticAutoProxy->_nProxyHostPort;
    _pmProxyQuery          = pStaticAutoProxy->_pmProxyQuery;
    _pmaAllocMode          = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pProxyState           = pStaticAutoProxy->_pProxyState;

    INET_ASSERT(_pProxyState == NULL);

    _dwQueryResult         = pStaticAutoProxy->_dwQueryResult;
    _Error                 = pStaticAutoProxy->_Error;
    _MessageFlags.Dword    = pStaticAutoProxy->_MessageFlags.Dword;
    _dwProxyVersion        = pStaticAutoProxy->_dwProxyVersion;
}

AUTO_PROXY_ASYNC_MSG::~AUTO_PROXY_ASYNC_MSG(
    VOID
    )
{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~AUTO_PROXY_ASYNC_MSG",
                NULL
                ));

    if ( IsAlloced() )
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Freeing Allocated MSG ptr=%x\n",
                    this
                    ));


        if ( _lpszUrl )
        {
            //DEBUG_PRINT(OBJECTS,
            //            INFO,
            //            ("Url ptr=%x, %q\n",
            //            _lpszUrl,
            //            _lpszUrl
            //            ));

            FREE_MEMORY(_lpszUrl);
        }

        if ( _lpszUrlHostName )
        {
            FREE_MEMORY(_lpszUrlHostName);
        }


        if ( _pProxyState )
        {
            delete _pProxyState;
        }
    }
    if (_bFreeProxyHostName && (_lpszProxyHostName != NULL)) {
        FREE_MEMORY(_lpszProxyHostName);
    }

    DEBUG_LEAVE(0);
}



//
// functions
//


PRIVATE
BOOL
MatchFileExtensionWithUrl(
    IN LPCSTR lpszFileExtensionList,
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Matches a Url with a string of externsions (looks like ".ins;.jv").
    Confims the Url is using one the approved externsions.

Arguments:

    lpszFileExtensionList - the list of file extensions to check the Url against.

    lpszUrl  - the url to examine.

Return Value:

    BOOL
        TRUE    - success

        FALSE   - the Url does not contain any of the extensions.

--*/


{

    LPCSTR lpszExtension, lpszExtensionOffset;
    LPCSTR lpszQuestion;

    //
    // We need to be careful about checking for a period on the end of an URL
    //   Example: if we have: "http://auto-proxy-srv/fooboo.exe?autogenator.com.ex" ?
    //

    lpszQuestion = strchr( lpszUrl, '?' );

    lpszUrl = ( lpszQuestion ) ? lpszQuestion : lpszUrl;

    lpszExtension = strrchr( lpszUrl, '.' );


    if ( lpszExtension )
    {
        lpszExtensionOffset = lpszExtension;
        BOOL fMatching = FALSE;
        BOOL fCurrentMatch = FALSE;
        BOOL fFirstByte = TRUE;

        while ( *lpszFileExtensionList && *lpszExtensionOffset )
        {

            if ( toupper(*lpszFileExtensionList) == toupper(*lpszExtensionOffset) )
            {
                fCurrentMatch = TRUE;
            }
            else
            {
                fCurrentMatch = FALSE;
            }

            if ( *lpszFileExtensionList == ';')
            {
                lpszExtensionOffset = lpszExtension-1;
                fFirstByte = TRUE;

                if ( fMatching )
                {
                    return TRUE;
                }
            }
            else if ( fFirstByte || fMatching )
            {
                fMatching = fCurrentMatch;
                fFirstByte = FALSE;
            }

            lpszExtensionOffset++;
            lpszFileExtensionList++;

            if ( *lpszExtensionOffset == '\0' )
            {
                lpszExtensionOffset = lpszExtension;
            }
        }

        if ( fMatching )
        {
            return TRUE;
        }

    }

    return FALSE;
}

#ifdef unix
static BOOL fForceAutoProxSync = TRUE;
extern "C"
void unixForceAutoProxSync()
{
    if(fForceAutoProxSync)
    {
       if (!GlobalDataInitialized)
          GlobalDataInitialize();

       if (GlobalDataInitialized)
       {
          GlobalProxyInfo.SetRefreshDisabled(FALSE);
          FixProxySettingsForCurrentConnection(TRUE);
          GlobalProxyInfo.ReleaseQueuedRefresh();
          fForceAutoProxSync = FALSE;
       }
    }
}
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\proxysup.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    proxysup.cxx

Abstract:

    Contains class implementation for proxy server and proxy bypass list

    Contents:
        IsLocalMacro

        PROXY_SERVER_LIST_ENTRY::WriteEntry

        PROXY_SERVER_LIST::AddList
        PROXY_SERVER_LIST::Find
        PROXY_SERVER_LIST::Add
        PROXY_SERVER_LIST::ProxyScheme
        PROXY_SERVER_LIST::GetProxyHostName
        PROXY_SERVER_LIST::AddToBypassList
        PROXY_SERVER_LIST::GetList

        PROXY_BYPASS_LIST_ENTRY::WriteEntry

        PROXY_BYPASS_LIST::AddList
        PROXY_BYPASS_LIST::Find
        PROXY_BYPASS_LIST::Add
        PROXY_BYPASS_LIST::IsBypassed
        PROXY_BYPASS_LIST::IsHostInBypassList
        PROXY_BYPASS_LIST::GetList

        PROXY_INFO::GetProxyStringInfo
        PROXY_INFO::HostBypassesProxy
        PROXY_INFO::RedoSendRequest
        PROXY_INFO::Terminate
        PROXY_INFO::CleanOutLists

        PROXY_STATE::GetNextProxy

        (GetRegistryProxyParameter)

Author:

    Richard L Firth (rfirth) 03-Feb-1996

Revision History:

    03-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define DEFAULT_PROXY_BUFFER_LENGTH     (4 K)
#define MAX_IP_ADDRESS_STRING_LENGTH    (4 * 4 - 1) // ###.###.###.###
#define PROXY_REGISTRY_STRING_LENGTH    (4 K)

//
// private types
//

typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;


//
// private prototypes
//

PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    );





//
// functions
//


BOOL
IsLocalMacro(
    IN LPSTR lpszMetaName,
    IN DWORD dwMetaNameLength
    )

/*++

Routine Description:

    Checks for local macro name

Arguments:

    lpszMetaName        - name to check

    dwMetaNameLength    - length

Return Value:

    BOOL
        TRUE    - it is <local>

        FALSE   - not

--*/

{
    INET_ASSERT(lpszMetaName != NULL);

    static const char s_local[] = "<local>";

    return (strnicmp(s_local, lpszMetaName, dwMetaNameLength) == 0);
}


//PRIVATE
//BOOL
//IsNetscapeProxyListString(
//    IN LPSTR lpszProxyStr,
//    IN DWORD dwcbProxyStr
//    )
//
///*++
//
//Routine Description:
//
//    Determines if a string is part of a Netscape style multiple proxy list.
//
//Arguments:
//
//    lpszProxyStr - The string to examine
//
//    dwcbProxyStr - Size of the string to check.
//
//Return Value:
//
//    BOOL
//        TRUE    - if its a Netscape list of proxies.
//
//        FALSE   - its just a proxy name.
//
//--*/
//
//{
//    INET_ASSERT(lpszProxyStr);
//    INET_ASSERT(dwcbProxyStr > 0);
//
//    SKIPWS(lpszProxyStr);
//
//    //
//    // If it SOCKS, PROXY, or DIRECT (and) there is some delimiter
//    //  we accept it as a Netscape Proxy String.
//    //
//
//    if ( strncmp( lpszProxyStr, "DIRECT", min(dwcbProxyStr, sizeof("DIRECT")-1) ) == 0  )
//    {
//        return TRUE;
//    }
//
//    if ( strncmp( lpszProxyStr, "PROXY",  min(dwcbProxyStr, sizeof("PROXY")-1) )  == 0  ||
//         strncmp( lpszProxyStr, "SOCKS",  min(dwcbProxyStr, sizeof("SOCKS")-1) )  == 0   )
//    {
//        for ( DWORD i = 0; i < dwcbProxyStr; i++ )
//        {
//            if ( lpszProxyStr[i] == ':' || lpszProxyStr[i] == ';' )
//            {
//                return TRUE;
//            }
//        }
//    }
//
//    return FALSE;
//}


//
// member functions
//


BOOL
PROXY_SERVER_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy server list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR protocolName;
    DWORD protocolNameLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude;

    protocolName = MapUrlScheme(_Protocol, &protocolNameLength);
    if (protocolName != NULL) {
        requiredLength = protocolNameLength + 1;    // for '='
    } else {
        requiredLength = 0;
    }
    schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
    if (schemeName != NULL) {
        requiredLength += schemeNameLength + sizeof("://") - 1;
    }
    requiredLength += _ProxyName.StringLength();
    if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_ProxyPort / n) {
                requiredLength += i + 1;    // for ':'
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (protocolName != NULL) {
            memcpy(lpszBuffer, protocolName, protocolNameLength);
            lpszBuffer += protocolNameLength;
            *lpszBuffer++ = '=';
        }
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        _ProxyName.CopyTo(lpszBuffer);
        lpszBuffer += _ProxyName.StringLength();
        if (_ProxyPort != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _ProxyPort, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_SERVER_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy servers and creates a PROXY_SERVER_LIST_ENTRY for
    each one

Arguments:

    lpszList    - pointer to list of proxies of the form:

                    [<scheme>=][<scheme>"://"]<server>[":"<port>][";"*]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    At least one entry in lpszList is bogus

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR protocolName;
    DWORD protocolLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    protocolName = lpszList;
    protocolLength = 0;
    schemeName = NULL;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_PROTOCOL;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case '=':
            if ((state == STATE_PROTOCOL) && (entryLength != 0)) {
                protocolLength = entryLength;
                entryLength = 0;
                state = STATE_SCHEME;
                schemeName = lpszList;
            } else {

                //
                // '=' can't legally appear anywhere else
                //

                state = STATE_ERROR;
            }
            break;

        case ':':
            switch (state) {
            case STATE_PROTOCOL:
                if (*lpszList == '/') {
                    schemeName = protocolName;
                    protocolName = NULL;
                    schemeLength = entryLength;
                    protocolLength = 0;
                    state = STATE_SCHEME;
                } else if (*lpszList != '\0') {
                    serverName = protocolName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = (schemeName != NULL)
                        ? schemeName
                        : protocolName;
                }

                INET_ASSERT(serverName != NULL);

                INTERNET_SCHEME protocol;

                if (protocolLength != 0) {
                    protocol = MapUrlSchemeName(protocolName, protocolLength);
                } else {
                    protocol = INTERNET_SCHEME_DEFAULT;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((protocol != INTERNET_SCHEME_UNKNOWN)
                && (scheme != INTERNET_SCHEME_UNKNOWN)

                //
                // we can only currently handle CERN (secure or unsecure) and
                // FTP proxies, so kick out anything that wants to go via any
                // other proxy scheme
                //

                && ((scheme == INTERNET_SCHEME_DEFAULT)
                || (scheme == INTERNET_SCHEME_FTP)
                || (scheme == INTERNET_SCHEME_HTTP)
                || (scheme == INTERNET_SCHEME_HTTPS))) {
                    if (!Find(protocol)) {

                        //
                        // don't worry if Add() fails - we just continue
                        //

                        Add(protocol, scheme, serverName, serverLength, port);
                    }
                }
            }
            entryLength = 0;
            protocolName = lpszList;
            protocolLength = 0;
            schemeName = NULL;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_PROTOCOL;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_SERVER_LIST::Find(
    IN INTERNET_SCHEME tScheme
    )

/*++

Routine Description:

    Find a PROXY_SERVER_LIST_ENTRY based on the scheme

Arguments:

    tScheme - protocol scheme to find

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_SERVER_LIST::Find",
                "%s",
                InternetMapScheme(tScheme)
                ));

    BOOL found = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        if (info->_Protocol == tScheme) {
            found = TRUE;
            break;
        }
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::Add(
    IN INTERNET_SCHEME tProtocol,
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create an add a PROXY_SERVER_LIST_ENTRY to the PROXY_SERVER_LIST

Arguments:

    tProtocol           - protocol which uses the proxy

    tScheme             - scheme used to talk to the proxy

    lpszHostName        - proxy host name

    dwHostNameLength    - length of proxy host name

    nPort               - port at proxy host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_SERVER_LIST::Add",
                "%s, %s, %.*q, %d, %d",
                InternetMapScheme(tProtocol),
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_SERVER_LIST_ENTRY * entry;

    entry = new PROXY_SERVER_LIST_ENTRY(tProtocol,
                                        tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error;

    if (entry != NULL) {
        //error = entry->ResolveAddress();
        //if (error == ERROR_SUCCESS) {
        //    InsertAtTailOfSerializedList(&_List, &entry->_List);
        //}
        if (entry->_Protocol == INTERNET_SCHEME_DEFAULT) {
            InsertAtTailOfSerializedList(&_List, &entry->_List);
        } else {
            InsertAtHeadOfSerializedList(&_List, &entry->_List);
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNET_SCHEME
PROXY_SERVER_LIST::ProxyScheme(
    IN INTERNET_SCHEME tProtocol
    )

/*++

Routine Description:

    Determines protocol over which tScheme goes through proxy

Arguments:

    tProtocol   - protocol scheme used to retrieve data (e.g. FTP)

Return Value:

    INTERNET_SCHEME
        Success - scheme by which protocol goes via proxy

        Failure - INTERNET_SCHEME_UNKNOWN
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Int,
                "PROXY_SERVER_LIST::ProxyScheme",
                "%s",
                InternetMapScheme(tProtocol)
                ));

    INTERNET_SCHEME tScheme = INTERNET_SCHEME_UNKNOWN;

    LockSerializedList(&_List);

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //

        if ((info->_Protocol == tProtocol)
        || (info->_Protocol == INTERNET_SCHEME_DEFAULT)) {
            tScheme = info->_Scheme;

            //
            // the default scheme is HTTP (CERN proxy)
            //

            if (tScheme == INTERNET_SCHEME_DEFAULT) {
                tScheme = INTERNET_SCHEME_HTTP;
            }
            break;
        }
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(tScheme);

    return tScheme;
}


BOOL
PROXY_SERVER_LIST::GetProxyHostName(
    IN INTERNET_SCHEME tProtocol,
    IN OUT LPINTERNET_SCHEME lptScheme,
    OUT LPSTR * lplpszHostName,
    OUT LPBOOL lpbFreeHostName,
    OUT LPDWORD lpdwHostNameLength,
    OUT LPINTERNET_PORT lpHostPort
    )

/*++

Routine Description:

    Given a protocol, map it to the proxy we use to retrieve the data

Arguments:

    tProtocol           - protocol to map (e.g. find the proxy for FTP)

    lptScheme           - IN: preferred scheme if INTERNET_SCHEME_DEFAULT
                          OUT: returned scheme

    lplpszHostName      - pointer to returned pointer to host name

    lpbFreeHostName     - returned TRUE if *lplpszHostName allocated

    lpdwHostNameLength  - pointer to returned host name length

    lpHostPort          - pointer to returned host port

Return Value:

    BOOL
        TRUE    - requested info has been returned

        FALSE   - requested info was not found

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_SERVER_LIST::GetProxyHostName",
                 "%s, %#x, %#x, %#x, %#x, %#x",
                 InternetMapScheme(tProtocol),
                 lptScheme,
                 lplpszHostName,
                 lpbFreeHostName,
                 lpdwHostNameLength,
                 lpHostPort
                 ));

    INET_ASSERT(tProtocol != INTERNET_SCHEME_UNKNOWN);

    //
    // *lptScheme must now be one of the recognized schemes, or the default
    //

    INET_ASSERT((*lptScheme == INTERNET_SCHEME_DEFAULT)
                || (*lptScheme == INTERNET_SCHEME_FTP)
                || (*lptScheme == INTERNET_SCHEME_GOPHER)
                || (*lptScheme == INTERNET_SCHEME_HTTP)
                || (*lptScheme == INTERNET_SCHEME_HTTPS)
                || (*lptScheme == INTERNET_SCHEME_SOCKS)
                );

    BOOL found = FALSE;

    LockSerializedList(&_List);

    //
    // the list really shouldn't be empty if we're here
    //

    INET_ASSERT(!IsSerializedListEmpty(&_List));

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);

        //
        // if we find a match for the protocol, or this protocol is handled by
        // the default proxy entry then we are done
        //
        // Hack: But make sure its NOT socks since, socks must be
        //  an exact match !!! No defaults.
        //

        if ((info->_Protocol == tProtocol)
        || ((info->_Protocol == INTERNET_SCHEME_DEFAULT)
                && (tProtocol != INTERNET_SCHEME_SOCKS)  )) {

            INTERNET_SCHEME scheme = info->_Scheme;

            //
            // the returned scheme is the input preferred scheme unless it was
            // the default scheme in which case we return HTTP (CERN proxy)
            //

            if (scheme == INTERNET_SCHEME_DEFAULT) {
                scheme = (*lptScheme == INTERNET_SCHEME_DEFAULT)
                            ? INTERNET_SCHEME_HTTP
                            : *lptScheme;
            }
            *lptScheme = scheme;
            *lpbFreeHostName = FALSE;
            *lpdwHostNameLength = 0;
            *lplpszHostName = NewString(info->_ProxyName.StringAddress(),
                                        info->_ProxyName.StringLength()
                                        );
            if (*lplpszHostName != NULL) {
                *lpbFreeHostName = TRUE;
                *lpdwHostNameLength = info->_ProxyName.StringLength();
            }

            INTERNET_PORT port = info->_ProxyPort;

            //
            // map the default port value
            //

            if (port == INTERNET_INVALID_PORT_NUMBER) {
                switch (scheme) {
                case INTERNET_SCHEME_FTP:
                    port = INTERNET_DEFAULT_FTP_PORT;
                    break;

                case INTERNET_SCHEME_GOPHER:
                    port = INTERNET_DEFAULT_GOPHER_PORT;
                    break;

                case INTERNET_SCHEME_HTTP:
                    port = INTERNET_DEFAULT_HTTP_PORT;
                    break;

                case INTERNET_SCHEME_HTTPS:
                    port = INTERNET_DEFAULT_HTTPS_PORT;
                    break;

                case INTERNET_SCHEME_SOCKS:
                    port = INTERNET_DEFAULT_SOCKS_PORT;
                    break;
                }
            }
            *lpHostPort = port;
            found = TRUE;

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("proxy = %s://%s:%d\n",
                        MapUrlSchemeToName(scheme),
                        info->_ProxyName.StringAddress(),
                        port
                        ));

            break;
        }
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_SERVER_LIST::AddToBypassList(
    IN PROXY_BYPASS_LIST * lpBypassList
    )

/*++

Routine Description:

    For all proxy servers in the server list, we add the details to the bypass
    list. By default, an app mustn't send a request to the proxy via the proxy!
    Additionally, the app should not have to specifically nominate the proxy
    server(s) as bypassing the proxy

Arguments:

    lpBypassList    - pointer to bypass proxy list where proxy servers will be
                      added

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error = ERROR_SUCCESS;
    PLIST_ENTRY entry = HeadOfSerializedList(&_List);

    while ((entry != (PLIST_ENTRY)SlSelf(&_List)) && (error == ERROR_SUCCESS)) {

        PROXY_SERVER_LIST_ENTRY * info = (PROXY_SERVER_LIST_ENTRY *)entry;

        if (!lpBypassList->Find(info->_Scheme,
                                info->_ProxyName.StringAddress(),
                                info->_ProxyName.StringLength(),
                                info->_ProxyPort)) {
            error = lpBypassList->Add(info->_Scheme,
                                      info->_ProxyName.StringAddress(),
                                      info->_ProxyName.StringLength(),
                                      info->_ProxyPort
                                      );
        }
        entry = entry->Flink;
    }
    return error;
}


VOID
PROXY_SERVER_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy servers to a buffer, and/or returns the required
    buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.

--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_SERVER_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_SERVER_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;

    UnlockSerializedList(&_List);
}


BOOL
PROXY_BYPASS_LIST_ENTRY::WriteEntry(
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Writes this proxy bypass list entry as a string in the supplied buffer

Arguments:

    lpszBuffer          - pointer to buffer where string is written

    lpdwBufferLength    - IN: amount of space in buffer
                          OUT: number of bytes copied, or required size

Return Value:

    BOOL
        TRUE    - entry written to buffer

        FALSE   - entry not written to buffer - *lpdwBufferLength contains
                  required size

--*/

{
    DWORD requiredLength;
    LPSTR schemeName;
    DWORD schemeNameLength;
    INTERNET_PORT magnitude;

    if (_Scheme != INTERNET_SCHEME_DEFAULT) {
        schemeName = MapUrlScheme(_Scheme, &schemeNameLength);
        requiredLength = schemeNameLength + sizeof("://") - 1;
    } else {
        schemeName = NULL;
        requiredLength = 0;
    }
    if (IsLocal()) {
        requiredLength += sizeof("<local>") - 1;
    } else {
        requiredLength += _Name.StringLength();
    }
    if (_Port != INTERNET_INVALID_PORT_NUMBER) {
        for (INTERNET_PORT n = 10000, i = 5; n > 0; n /= 10, --i) {
            if (_Port / n) {
                requiredLength += i + 1;
                magnitude = n;
                break;
            }
        }
    }

    BOOL success;

    if (*lpdwBufferLength > requiredLength) {
        if (schemeName != NULL) {
            memcpy(lpszBuffer, schemeName, schemeNameLength);
            lpszBuffer += schemeNameLength;
            memcpy(lpszBuffer, "://", sizeof("://") - 1);
            lpszBuffer += sizeof("://") - 1;
        }
        if (IsLocal()) {
            memcpy(lpszBuffer, "<local>", sizeof("<local>") - 1);
            lpszBuffer += sizeof("<local>") - 1;
        } else {
            _Name.CopyTo(lpszBuffer);
            lpszBuffer += _Name.StringLength();
        }
        if (_Port != INTERNET_INVALID_PORT_NUMBER) {
            *lpszBuffer++ = ':';
            for (INTERNET_PORT n = _Port, i = magnitude; i; i /= 10) {
                *lpszBuffer++ = (char)(n / i) + '0';
                n %= i;
            }
        }
        success = TRUE;
    } else {
        success = FALSE;
    }
    *lpdwBufferLength = requiredLength;
    return success;
}


DWORD
PROXY_BYPASS_LIST::AddList(
    IN LPSTR lpszList
    )

/*++

Routine Description:

    Parses a list of proxy bypass specifiers and adds them to the list

Arguments:

    lpszList    - pointer to string containing list of proxy bypass specifiers.
                  The format is:

                    [<scheme>"://"][<server>][":"<port>"]

                  The list can be NULL, in which case we read it from the
                  registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::AddList",
                "%.80q",
                lpszList
                ));

    DWORD entryLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;

    entryLength = 0;
    schemeName = lpszList;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_SCHEME;
    nSlashes = 0;
    port = 0;
    done = FALSE;

    //
    // walk the list, pulling out the various scheme parts
    //

    do {

        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/')) {
            state = STATE_ERROR;
            break;
        }

        switch (ch) {
        case ':':
            switch (state) {
            case STATE_SCHEME:
                if (*lpszList == '/') {
                    schemeLength = entryLength;
                } else if (*lpszList != '\0') {
                    serverName = schemeName;
                    serverLength = entryLength;
                    if (serverLength == 0) {
                        serverLength = 1;
                        serverName = "*";
                    }
                    state = STATE_PORT;
                } else {
                    state = STATE_ERROR;
                }
                entryLength = 0;
                break;

            case STATE_SERVER:
                serverLength = entryLength;
                state = STATE_PORT;
                entryLength = 0;
                break;

            default:
                state = STATE_ERROR;
                break;
            }
            break;

        case '/':
            if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0)) {
                if (++nSlashes == 2) {
                    state = STATE_SERVER;
                    serverName = lpszList;
                }
            } else {
                state = STATE_ERROR;
            }
            break;

        default:
            if (state != STATE_PORT) {
                ++entryLength;
            } else if (isdigit(ch)) {

                //
                // BUGBUG - we will overflow if >65535
                //

                port = port * 10 + (ch - '0');
            } else {

                //
                // STATE_PORT && non-digit character - error
                //

                state = STATE_ERROR;
            }
            break;

        case '\0':
            done = TRUE;

            //
            // fall through
            //

        case '\t':
        case '\n':
        case '\v':  // vertical tab, 0x0b
        case '\f':  // form feed, 0x0c
        case '\r':
        case ' ':
        case ';':
        case ',':
            if (serverLength == 0) {
                serverLength = entryLength;
                if ((serverLength == 0)
                && ((state == STATE_SERVER) || (state == STATE_PORT))) {

                    //
                    // we found e.g. "http://" or "http://:80". We allow this as
                    // "http://*" or "http://*:80"
                    //

                    serverLength = 1;
                    serverName = "*";
                }
            }
            if (serverLength != 0) {
                if (serverName == NULL) {
                    serverName = schemeName;
                }

                INTERNET_SCHEME scheme;

                if (schemeLength != 0) {
                    scheme = MapUrlSchemeName(schemeName, schemeLength);
                } else {
                    scheme = INTERNET_SCHEME_DEFAULT;
                }

                //
                // add an entry if this is a protocol we handle and we don't
                // already have an entry for it
                //

                if ((scheme != INTERNET_SCHEME_UNKNOWN)
                && !Find(scheme, serverName, serverLength, port)) {

                    //
                    // don't worry if Add() fails - we just continue
                    //

                    Add(scheme, serverName, serverLength, port);
                }
            }
            entryLength = 0;
            schemeName = lpszList;
            schemeLength = 0;
            serverName = NULL;
            serverLength = 0;
            nSlashes = 0;
            port = 0;
            state = STATE_SCHEME;
            break;
        }
        if (state == STATE_ERROR) {
            break;
        }
    } while (!done);

    DWORD error;

    if (state == STATE_ERROR) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::Find(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName OPTIONAL,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a proxy bypass entry matches the criteria.

    Currently, name matching is simplistic: e.g. "*.com" and "**.com" are
    treated as 2 separate strings, where we should collapse multiple wildcard
    specifiers, etc. Also: "w*" should replace "ww*", etc.

Arguments:

    tScheme             - scheme for this entry

    lpszHostName        - host name or address. May contain wildcards (*)

    dwHostNameLength    - length of host name or address

    nPort               - port

Return Value:

    BOOL
        TRUE    - an entry corresponding to the arguments was found

        FALSE   - didn't find entry

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::Find",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    BOOL isLocal = IsLocalMacro(lpszHostName, dwHostNameLength);
    BOOL found = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check for name match
        //

        if (info->_LocalSemantics) {
            if (isLocal) {
                found = TRUE;
                break;
            } else {
                continue;
            }
        }

        //
        // not local semantics, have to match target
        //

        //
        // BUGBUG - we only do simplistic matching. If the strings don't match
        //          exactly, except for case, they are deemed to be different
        //

        if (info->_Name.Strnicmp(lpszHostName, (int)dwHostNameLength) != 0) {
            continue;
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    info->_Name.StringAddress()
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


DWORD
PROXY_BYPASS_LIST::Add(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Create and add a PROXY_BYPASS_LIST_ENTRY to the PROXY_BYPASS_LIST

Arguments:

    tScheme             - scheme to bypass. May be 0 meaning any protocol

    lpszHostName        - name of host to bypass. May be name or IP address and
                          may contain wildcard characters

    dwHostNameLength    - length of bypass name string

    nPort               - port to bypass. May be 0, meaning any port

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_BYPASS_LIST::Add",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    PROXY_BYPASS_LIST_ENTRY * entry;

    entry = new PROXY_BYPASS_LIST_ENTRY(tScheme,
                                        lpszHostName,
                                        dwHostNameLength,
                                        nPort
                                        );

    DWORD error;

    if (entry != NULL) {

        //
        // if the bypass entry uses local name matching semantics, then we add
        // it to the end of the list, else the head. The reason we do this is
        // to allow <local> to be a default after all other (possibly also
        // local) entries are checked
        //

        if (entry->IsLocal()) {
            InsertAtTailOfSerializedList(&_List, &entry->_List);
        } else {
            InsertAtHeadOfSerializedList(&_List, &entry->_List);
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_BYPASS_LIST::IsBypassed(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort
    )

/*++

Routine Description:

    Determines if a scheme/name/port is bypassed

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    dwHostNameLength    - length of name/address part. May be 0, meaning match
                          any name/address

    nPort               - can be 0, meaning match any port

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Bool,
                "PROXY_BYPASS_LIST::IsBypassed",
                "%s, %.*q, %d, %d",
                InternetMapScheme(tScheme),
                dwHostNameLength,
                lpszHostName,
                dwHostNameLength,
                nPort
                ));

    INET_ASSERT(lpszHostName != NULL);
    INET_ASSERT(dwHostNameLength != 0);

    //
    // determine if what we were given is an address, in which case we don't
    // perform <local> semantics matching
    //

    BOOL isAddress = FALSE;
    LPSTR mappedName = NULL;
    LPSTR allocedName = NULL;

    if (dwHostNameLength <= MAX_IP_ADDRESS_STRING_LENGTH) {

        char addressBuffer[MAX_IP_ADDRESS_STRING_LENGTH + 1];

        //
        // make the host name/address an ASCIIZ string
        //

        memcpy((LPVOID)addressBuffer, (LPVOID)lpszHostName, dwHostNameLength);
        addressBuffer[dwHostNameLength] = '\0';
        if (_I_inet_addr(addressBuffer) != INADDR_NONE) {

            //
            // looks like we were given an IP address
            //

            //
            // maybe this is the IP address of a known server (in cache)
            //

            mappedName = MapNetAddressToName(addressBuffer, &allocedName);
            if (mappedName == addressBuffer) {

                //
                // BUGBUG - transport independence?
                //

                isAddress = TRUE;
            } else {
                lpszHostName = mappedName;
                dwHostNameLength = lstrlen(lpszHostName);
            }
        }
    }

    BOOL found;
    found = IsHostInBypassList (
                tScheme,
                lpszHostName,
                dwHostNameLength,
                nPort,
                isAddress);

    if (allocedName != NULL) {

        allocedName = (LPSTR)FREE_MEMORY(allocedName);
        INET_ASSERT(allocedName == NULL);
    }

    DEBUG_LEAVE(found);
    return found;
}


BOOL
PROXY_BYPASS_LIST::IsHostInBypassList(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR lpszHostName,
    IN DWORD dwHostNameLength,
    IN INTERNET_PORT nPort,
    IN BOOL isAddress
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    tScheme             -
    lpszHostName        -
    dwHostNameLength    -
    nPort               -
    isAddress           -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_BYPASS_LIST::IsHostInBypassList",
                 "%d (%s), %.*q, %d, %d, %B",
                 tScheme,
                 InternetMapScheme(tScheme),
                 dwHostNameLength,
                 lpszHostName,
                 dwHostNameLength,
                 nPort,
                 isAddress
                 ));

    BOOL found = FALSE;

    //
    // if not an address, determine if the name contains at least one dot
    //

    BOOL isDot;

    if (!isAddress) {
        isDot = FALSE;
        for (DWORD i = 0; i < dwHostNameLength; ++i) {
            if (lpszHostName[i] == '.') {
                isDot = TRUE;
                break;
            }
        }
    } else {

        //
        // addresses have dots
        //

        isDot = TRUE;
    }

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);

        //
        // do the easy bits first
        //

        if (!((info->_Scheme == tScheme)
        || (info->_Scheme == INTERNET_SCHEME_DEFAULT))) {
            continue;
        }
        if (!((info->_Port == nPort)
        || (info->_Port == INTERNET_INVALID_PORT_NUMBER))) {
            continue;
        }

        //
        // check local semantics
        //

        if (info->_LocalSemantics) {
            if (!isDot) {

                DEBUG_PRINT(PROXY,
                            INFO,
                            ("%q matched by <local>\n",
                            lpszHostName
                            ));

                found = TRUE;

                //
                // <local> is in the bypass list and the name does not contain a
                // dot. It bypasses the proxy
                //

                break;
            } else {

                //
                // the name contains a dot, but it may be matched by another
                // proxy bypass entry
                //

                continue;
            }
        }

        //
        // check for name match. Note that we take no special action if the host
        // name contains wildcard characters
        //

        LPSTR target = info->_Name.StringAddress();

        //
        // NULL target name matches any server name/address
        //

        if (target != NULL) {

            DEBUG_PRINT(PROXY,
                        INFO,
                        ("trying to match %q with %q\n",
                        lpszHostName,
                        target
                        ));

            DWORD i = 0;
            DWORD j = 0;
            DWORD i_back = (DWORD)-1;

            while ((target[i] != '\0') && (j < dwHostNameLength)) {
                if (target[i] == tolower(lpszHostName[j])) {
                    ++i;
                    ++j;
                } else if (target[i] == '*') {
                    while (target[i + 1] == '*') {
                        ++i;
                    }
                    i_back = i;
                    ++i;
                    while ((tolower(lpszHostName[j]) != target[i])
                    && (j < dwHostNameLength)) {
                        ++j;
                    }
                } else if (i_back != (DWORD)-1) {

                    //
                    // '*' is greedy closure. We already saw a '*' but later we
                    // discovered a mismatch. We will go back and try to eat as
                    // many characters as we can till the next match, or we hit
                    // the end of the string
                    //

                    i = i_back;
                } else {

                    //
                    // no match; quit
                    //

                    j = 0;
                    break;
                }

                //
                // if we reached the end of the target, but not the host name
                // AND we already met a '*' then back up
                //

                if ((target[i] == '\0')
                && (j != dwHostNameLength)
                && (i_back != (DWORD)-1)) {
                    i = i_back;
                }
            }

            //
            // if we hit the end of the host name while matching any character,
            // bump the target to the next non-star character
            //

            while (target[i] == '*') {
                ++i;
            }

            //
            // the host name matched if we reached the end of the target and end
            // of the host name
            //

            if (!((target[i] == '\0') && (j == dwHostNameLength))) {
                continue;
            }
        }

        //
        // any path that didn't continue, or has not already broken out has
        // succeeded in finding a match
        //

        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Matched: %q, %q\n",
                    lpszHostName,
                    target
                    ));

        found = TRUE;
        break;
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(found);

    return found;
}


VOID
PROXY_BYPASS_LIST::GetList(
    OUT LPSTR * lplpszList,
    IN DWORD dwBufferLength,
    IN OUT LPDWORD lpdwRequiredLength
    )

/*++

Routine Description:

    Writes the list of proxy bypass servers to a buffer, and/or returns the
    required buffer length

Arguments:

    lplpszList          - pointer to pointer to buffer where list is written, if
                          sufficient space

    dwBufferLength      - amount of space in *lplpszList

    lpdwRequiredLength  - OUT: cumulative size of data

Return Value:

    None.
--*/

{
    LPSTR lpszList = *lplpszList;
    BOOL firstTime = TRUE;
    BOOL outOfBuffer = FALSE;

    LockSerializedList(&_List);

    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink) {

        PROXY_BYPASS_LIST_ENTRY * info;

        info = CONTAINING_RECORD(entry, PROXY_BYPASS_LIST_ENTRY, _List);
        if (!firstTime) {

            //
            // write delimiter if enough space
            //

            if (dwBufferLength >= 1) {
                *lpszList++ = ' ';
                --dwBufferLength;
            }
            ++*lpdwRequiredLength;
        } else {
            firstTime = FALSE;
        }

        //
        // find the length of the current entry & write it to the buffer if
        // enough space
        //

        DWORD length = dwBufferLength;

        info->WriteEntry(lpszList, &length);
        if (dwBufferLength >= length) {

            //
            // we wrote it
            //

            dwBufferLength -= length;
        } else {

            //
            // no buffer left
            //

            dwBufferLength = 0;
            outOfBuffer = TRUE;
        }
        *lpdwRequiredLength += length;
        lpszList += length;
    }

    if (!outOfBuffer) {
        if (dwBufferLength > 0) {
            *lpszList++ = '\0';
            *lplpszList = lpszList;
        }
    }

    //
    // add 1 for the terminating NUL
    //

    ++*lpdwRequiredLength;
    UnlockSerializedList(&_List);
}

//
// PROXY_INFO - methods are defined below
//

VOID 
PROXY_INFO::InitializeProxySettings(
    VOID
    )    

/*++

Routine Description:

    Initalizes Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    _ProxyServerList    = NULL;
    _ProxyBypassList    = NULL;
    _fDisableDirect     = FALSE;
    _fModifiedInProcess = FALSE;

    _Lock.Initialize();
    _Error = _Lock.IsInitialized()
                ? ERROR_SUCCESS
                : ERROR_INTERNET_INTERNAL_ERROR;
}


BOOL PROXY_INFO_GLOBAL::IsAutoProxyDownloaded(VOID)
{
    return !(IsGlobal() &&
        _AutoProxyList &&
        _AutoProxyList->IsAutoProxy() &&
        !_AutoProxyList->IsOnAsyncAutoProxyThread() &&
        GlobalAutoProxyNeedsInit);
}


VOID 
PROXY_INFO::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Cleans up and destroys Proxy_Info objects

Arguments:

    None.

Return Value:

    None. 

--*/

{
    //DEBUG_ENTER((DBG_OBJECTS,
    //             None,
    //             "PROXY_INFO::TerminateProxySettings",
    //             NULL
    //             ));

    Lock(TRUE);
    CleanOutLists();
    Unlock();

    //DEBUG_LEAVE(0);
}




DWORD
PROXY_INFO::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info. Either creates new proxy server and bypass lists, or
    removes them (proxy to direct)

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE, if this object keeps a seperate set of values from those
                            stored in the registry store



Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    //
    // parameters should already be validated by caller
    //

    BOOL newList;
    BOOL possibleNewAutoProxy;
    LPCTSTR serverList;
    LPCTSTR bypassList;

    DWORD error = ERROR_SUCCESS;

    serverList = NULL;
    bypassList = NULL;
    newList = FALSE;
    _fModifiedInProcess = fModifiedInProcess;
    _dwSettingsVersion  = lpProxySettings->dwCurrentSettingsVersion;

    UPDATE_GLOBAL_PROXY_VERSION();

    if ( lpProxySettings->dwFlags & PROXY_TYPE_PROXY ) 
    {        
        serverList = lpProxySettings->lpszProxy;
        bypassList = lpProxySettings->lpszProxyBypass;

        if (serverList != NULL) {            
            newList = TRUE;
        }
    }

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    // remember disable direct flag...
    SetDisableDirect( (lpProxySettings->dwFlags & PROXY_TYPE_DIRECT) ? FALSE : TRUE  );

    //
    // clear out current contents,
    //

    CleanOutLists();

    //
    // Set the Static Proxy Lists
    //
        
    if (newList) 
    {

        INET_ASSERT((serverList != NULL) && (*serverList != 0));

        _ProxyServerList = new PROXY_SERVER_LIST(serverList);
        _ProxyBypassList = new PROXY_BYPASS_LIST(bypassList);

        if ((_ProxyServerList != NULL) && (_ProxyBypassList != NULL)) {
            _Error = _ProxyServerList->GetError();
            if (_Error == ERROR_SUCCESS) {
                _Error = _ProxyBypassList->GetError();
                if (_Error == ERROR_SUCCESS) {

                    //
                    // add all proxy servers to bypass list
                    //

                    _ProxyServerList->AddToBypassList(_ProxyBypassList);
                }
            }
        } else {
            _Error = ERROR_NOT_ENOUGH_MEMORY;
            CleanOutLists();
        }
        error = _Error;
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::GetProxySettings(
    OUT LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gets the proxy info. 

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:

    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - ignored 


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    DWORD error = ERROR_SUCCESS;

    if ( fCheckVersion == TRUE )
    {
        INET_ASSERT(FALSE);
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    if ( ! IsDisableDirect() ) {
        lpProxySettings->dwFlags |= PROXY_TYPE_DIRECT;
    }

    if ( IsProxySettingsConfigured() ) 
    {   
        lpProxySettings->dwFlags |= PROXY_TYPE_PROXY;

        lpProxySettings->lpszProxy       = _ProxyServerList->CopyString();
        lpProxySettings->lpszProxyBypass = _ProxyBypassList->CopyString();

        if ( lpProxySettings->lpszProxy == NULL || 
             lpProxySettings->lpszProxyBypass == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO::RefreshProxySettings(
    IN BOOL fForceRefresh
    )
/*++

Routine Description:

    Refreshes the Proxy Information

    This doesn't make sense on PROXY_INFO, nothing done

Arguments:

    fForceRefresh - forces a resync of all settings, turning this on slows things down

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - 

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));


    DEBUG_LEAVE(ERROR_SUCCESS);
 
    return ERROR_SUCCESS;
}


DWORD
PROXY_INFO::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Determines what proxy type, proxy name, and port the caller should use
    given an Url, its length, a target host, a target port, and output space
    to store the result.

    The result may be a complete string containing a Netscape style string with
    a delimited set of proxies, and access methods.  An example of this may
    look like:
    "PROXY itgproxy:80; PROXY proxy:80; PROXY 192.168.100.2:1080; SOCKS 192.168.100.2; DIRECT"
    This means we must try itgproxy, if this proxy fails we go on to proxy, and on to 192.168.100.2, etc.
    Note that if itgproxy, proxy, and 192.168.100.2 all fail we can try a SOCKS proxy, and if this fails we
    can try a direct connection.

    OR

    The result can be a simply IE 3.0 proxyname.  Ex: "proxy".  You can figure out
    which by calling IsNetscapeProxyListString() on the returned proxy hostname.

    If there is an external proxy DLL registered and valid, we defer to it to decide
    what proxy to use, and thus ignore internal proxy information.

    Note this function can also be used to retrive mapping of protocol to proxy.  For example,
    if tUrlProtocol == INTERNET_SCHEME_FTP, the result *lptProxyScheme == INTERNET_SCHEME_SOCKS
    which means we should use a socks proxy/firewall for FTP accesss.

Arguments:

    tScheme             - can be 0, meaning match any scheme

    lpszHostName        - can contain wildcards. May be name or IP address

    nPort               - can be 0, meaning match any port

    pfAutoProxy         - TRUE if an auto-proxy is being used.

Return Value:

    BOOL
        TRUE    - an entry on the bypass list matched the criteria

        FALSE   - the host identified by the parameters is not on this bypass
                  list

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO::QueryProxySettings",
                 "%#X",
                 ppQueryForProxyInfo
                 ));

    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;
    INTERNET_SCHEME tProxyScheme = pQueryForProxyInfo->_tUrlProtocol;
    BOOL fIsByPassed = FALSE;
    BOOL fProxyConnect = FALSE;
    
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    if (!IsProxySettingsConfigured())  // virtual func, perhaps replace with faster internal?
    {
        fProxyConnect = FALSE;
        goto quit;
    }

    //
    // Ok, if we're here we are NOT using the Auto-Proxy DLL.
    //  1. Determine if we are Bypassed ( and thus prevented from using a proxy )
    //  2. Map the Protocol to a Proxy type.
    //  3. Grab the hostname of the proxy we wish to use.
    //

    if ( pQueryForProxyInfo->_lpszUrlHostName && pQueryForProxyInfo->_dwUrlHostNameLength > 0 )
    {
        fIsByPassed = IsBypassed(
                        pQueryForProxyInfo->_tUrlProtocol,
                        pQueryForProxyInfo->_lpszUrlHostName,
                        pQueryForProxyInfo->_dwUrlHostNameLength,
                        pQueryForProxyInfo->_nUrlPort
                        );

        if ( fIsByPassed )
        {
            goto quit;
        }
    }

    pQueryForProxyInfo->_tProxyScheme = ProxyScheme(pQueryForProxyInfo->_tUrlProtocol);

    if ( pQueryForProxyInfo->_tProxyScheme == INTERNET_SCHEME_UNKNOWN )
    {
       pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_SOCKS;
       pQueryForProxyInfo->_tUrlProtocol = INTERNET_SCHEME_SOCKS;
    }
    if (pQueryForProxyInfo->_bFreeProxyHostName
        && (pQueryForProxyInfo->_lpszProxyHostName != NULL)) {
        FREE_MEMORY(pQueryForProxyInfo->_lpszProxyHostName);
    }

    fProxyConnect = GetProxyHostName(
                        pQueryForProxyInfo->_tUrlProtocol,
                        &(pQueryForProxyInfo->_tProxyScheme),
                        &(pQueryForProxyInfo->_lpszProxyHostName),
                        &(pQueryForProxyInfo->_bFreeProxyHostName),
                        &(pQueryForProxyInfo->_dwProxyHostNameLength),
                        &(pQueryForProxyInfo->_nProxyHostPort)
                        );

quit:

    pQueryForProxyInfo->_dwQueryResult = (DWORD) fProxyConnect;

    //
    // If we've disabled direct connections, then fail
    //  when there is no proxy
    //

    if ( !fProxyConnect && IsDisableDirect() ) {         
        error = ERROR_INTERNET_CANNOT_CONNECT;
    }

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}



DWORD
PROXY_INFO::GetProxyStringInfo(
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    IMPORTANT PLEASE READ: LEGACY FUNCTION, this does not support all the new
      proxy behaviors, left here for Wininet compat with older programs

    Returns the proxy server and bypass lists in an INTERNET_PROXY_INFO. Called
    by InternetQueryOption(INTERNET_OPTION_PROXY)

    Assumes: Access to this is serialized while we are getting this info

Arguments:

    lpBuffer            - pointer to buffer where information will be returned

    lpdwBufferLength    - IN: size of lpBuffer in BYTEs
                          OUT: number of BYTEs returned in lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the required buffer length
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                Dword,
                "PROXY_INFO::GetProxyStringInfo",
                "%#x, %#x [%d]",
                lpBuffer,
                lpdwBufferLength,
                *lpdwBufferLength
                ));

    DEBUG_PRINT(PROXY,
                INFO,
                ("Calling Legacy GetProxyStringInfo, NEW CODE SHOULD AVOID THIS CODE PATH\n"
                ));

    DWORD requiredSize = sizeof(INTERNET_PROXY_INFO);
    LPSTR lpVariable = (LPSTR)(((LPINTERNET_PROXY_INFO)lpBuffer) + 1);
    LPSTR lpszProxy;

    Lock(FALSE);

    if (_ProxyServerList != NULL) {
        lpszProxy = lpVariable;
        _ProxyServerList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
    } else {
        lpszProxy = NULL;
    }

    LPSTR lpszProxyBypass;

    if (_ProxyBypassList != NULL) {

        DWORD size = requiredSize;

        lpszProxyBypass = lpVariable;
        _ProxyBypassList->GetList(&lpVariable,
                                  (*lpdwBufferLength > requiredSize)
                                    ? (*lpdwBufferLength - requiredSize)
                                    : 0,
                                  &requiredSize
                                  );
        if (requiredSize == size) {
            lpszProxyBypass = NULL;
        }
    } else {
        lpszProxyBypass = NULL;
    }

    DWORD error;

    if (*lpdwBufferLength >= requiredSize) {

        LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

        lpInfo->dwAccessType = (lpszProxy == NULL)
                                    ? INTERNET_OPEN_TYPE_DIRECT
                                    : INTERNET_OPEN_TYPE_PROXY;
        lpInfo->lpszProxy = lpszProxy;
        lpInfo->lpszProxyBypass = lpszProxyBypass;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredSize;

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO::RedoSendRequest(
    IN OUT LPDWORD lpdwError,
    IN AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo,
    IN CServerInfo *pOriginServer,
    IN CServerInfo *pProxyServer
    )
/*++

Routine Description:

    Determines whether a connection needs to be retried do to a failed proxy.

Arguments:


    lpdwError   - Error code of connection.

    pProxyState - Pointer to proxy_state returned when acquiring the proxy information.


Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "PROXY_INFO::RedoSendRequest",
                 "%#x [%d], %#x",
                 lpdwError,
                 lpdwError ? *lpdwError : 0,
                 pQueryForProxyInfo
                 ));

    BOOL fReturn = FALSE;
    PROXY_STATE *pProxyState = NULL;
    DWORD dwVersion;
    LPSTR lpszConnection;
    BOOL fCanCache = FALSE;

    if ( pQueryForProxyInfo )
    {
        pProxyState = pQueryForProxyInfo->_pProxyState;

        //
        // On success,
        //

        if ( *lpdwError == ERROR_SUCCESS )
        {
            if ( pQueryForProxyInfo->IsCanCacheResult() && 
                 pProxyState &&                  
                 pOriginServer &&
                 pProxyServer )
            {
                
                pOriginServer->SetCachedProxyServerInfo(
                    pProxyServer,                    
                    pQueryForProxyInfo->GetVersion(),
                    pQueryForProxyInfo->IsUseProxy(),
                    pQueryForProxyInfo->_tUrlProtocol,
                    pQueryForProxyInfo->_nUrlPort,
                    pQueryForProxyInfo->_tProxyScheme,
                    pQueryForProxyInfo->_nProxyHostPort
                    );
            }
        }
        else if ( *lpdwError != ERROR_SUCCESS &&
                  *lpdwError != ERROR_INTERNET_OPERATION_CANCELLED &&
                  *lpdwError != ERROR_INTERNET_SEC_CERT_ERRORS &&
                  *lpdwError != ERROR_INTERNET_SECURITY_CHANNEL_ERROR &&
                  *lpdwError != ERROR_INTERNET_SEC_CERT_REVOKED &&
                  *lpdwError != ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED )
        {
            //
            // For backround detection, we need to retry
            //  waiting for the backround results to complete
            //
            // Otherwise, If we have additional proxies, 
            //  we need to retry them as well.
            //

            if ( pQueryForProxyInfo->IsBackroundDetectionPending() )
            {
                *lpdwError = ERROR_SUCCESS;
                fReturn = TRUE;
            }
            else if ( pProxyState &&
                     !pProxyState->IsEmpty() &&
                      pProxyState->IsAnotherProxyAvail() )               
            {
                INTERNET_PORT LastProxyUsedPort; 
                LPSTR lpszLastProxyUsed = pProxyState->GetLastProxyUsed(&LastProxyUsedPort);

                Lock(FALSE);

                if ( ( lpszLastProxyUsed == NULL ) ||
                     _BadProxyList.AddEntry(lpszLastProxyUsed, LastProxyUsedPort) != ERROR_SUCCESS )
                {
                    fReturn = FALSE;                    
                }
                else
                {
                    *lpdwError = ERROR_SUCCESS;
                    fReturn = TRUE;
                }

                Unlock();
            }
        }
    }

    DEBUG_LEAVE(fReturn);

    return fReturn;
}


VOID
PROXY_INFO::CleanOutLists(
    VOID
    )

/*++

Routine Description:

    Delete proxy server and bypass lists if not empty

    N.B. Exclusive lock MUST be acquired before calling this method

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "PROXY_INFO::CleanOutLists",
                 NULL
                 ));

    if (_ProxyServerList != NULL) {
        delete _ProxyServerList;
        _ProxyServerList = NULL;
    }
    if (_ProxyBypassList != NULL) {
        delete _ProxyBypassList;
        _ProxyBypassList = NULL;
    }

    DEBUG_LEAVE(0);
}

//
// PROXY_INFO_GLOBAL - Global Object thats inherits and expands the basic functionality 
//   of basic PROXY_INFO behavior.  The new functionality includes wrapping Auto-Proxy
///  and Auto-detection routines
//


VOID
PROXY_INFO_GLOBAL::TerminateProxySettings(
    VOID
    )

/*++

Routine Description:

    Destroy PROXY_INFO_GLOBAL object

Arguments:

    None.

Return Value:

    None.

--*/

{
    //DEBUG_ENTER((DBG_OBJECTS,
    //             None,
    //             "PROXY_INFO_GLOBAL::TerminateProxySettings",
    //             NULL
    //             ));

    Lock(TRUE);    
    if (_AutoProxyList != NULL) {
        _AutoProxyList->FreeAutoProxyInfo(); // free async component of object
        delete _AutoProxyList;
        _AutoProxyList = NULL;
    }
    Unlock();
    PROXY_INFO::TerminateProxySettings();

    //DEBUG_LEAVE(0);
}

DWORD
PROXY_INFO_GLOBAL::SetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fModifiedInProcess
    )

/*++

Routine Description:

    Sets the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

    Assumes: 1. The parameters have already been validated in the API that calls
                this method (i.e. InternetOpen(), InternetSetOption())

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fModifiedInProcess  - TRUE if this object is not from the registry, but 
                           a modifed setting for this process (that overrides reg values)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::SetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fModifiedInProcess
                 ));

    DWORD error = ERROR_SUCCESS;

    //
    // about to start changing contents - acquire lock
    //

    Lock(TRUE);

    //
    // Once we're set to Modified, we're modified for the lifetime of the
    //   the process, and thus we no longer accept Registry settings
    //

    if ( IsModifiedInProcess() && 
         !fModifiedInProcess )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    if ( _lpszConnectionName != NULL ) {
        FREE_MEMORY(_lpszConnectionName);
    }

    _lpszConnectionName = lpProxySettings->lpszConnectionName ? 
                            NewString(lpProxySettings->lpszConnectionName) : 
                            NULL;

    _dwProxyFlags = lpProxySettings->dwFlags;

    //
    // Allocate Auto-Proxy/Auto-Detect Object, and reset its settings
    //

    if ( ((lpProxySettings->dwFlags & PROXY_TYPE_AUTO_PROXY_URL) ||
          (lpProxySettings->dwFlags & PROXY_TYPE_AUTO_DETECT)) &&
         IsGlobal() &&
         !( _AutoProxyList &&
            _AutoProxyList->IsOnAsyncAutoProxyThread()) )
    {        
        if (_AutoProxyList == NULL)
        {
            //
            // Create a new Auto-Proxy List, this will pull down registry
            //   info (for the DLLs) at initialization
            //

            _AutoProxyList = new AUTO_PROXY_DLLS();

            if ( _AutoProxyList == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            error =  _AutoProxyList->GetError();

            if ( error != ERROR_SUCCESS ) {
                goto quit;
            }
        }

        error = _AutoProxyList->SetProxySettings(
                    lpProxySettings,
                    fModifiedInProcess,
                    TRUE     // fAllowOverwrite
                    );
        if ( error != ERROR_SUCCESS ) { 
            goto quit;
        }
    }

    //
    // Set the Static Proxy Lists
    //
        
    error = PROXY_INFO::SetProxySettings(lpProxySettings, fModifiedInProcess);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::GetProxySettings(
    IN LPINTERNET_PROXY_INFO_EX  lpProxySettings,
    IN BOOL fCheckVersion = FALSE
    )

/*++

Routine Description:

    Gather the proxy info.  Mainly handles Auto-Config, its decendent will handle static stuff

Arguments:
    
    lpProxySettings     - a set of relevent fields describing proxy settings

    fCheckVersion       - 

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::GetProxySettings",
                 "%x, %B",
                 lpProxySettings,
                 fCheckVersion
                 ));

    //
    // about to start reading contents - acquire lock
    //

    Lock(FALSE);

    DWORD error = ERROR_SUCCESS;

    lpProxySettings->lpszConnectionName =
                        _lpszConnectionName ? 
                            NewString(_lpszConnectionName) : 
                            NULL;

    lpProxySettings->dwFlags = _dwProxyFlags;

    //
    // Check Auto-Proxy/Auto-Detect Object, and read its settings
    //

    if ( IsGlobal() &&
         _AutoProxyList)
    {        
        error = _AutoProxyList->GetProxySettings(
                    lpProxySettings,
                    fCheckVersion   
                    );

        if ( error != ERROR_SUCCESS ) { 
            goto quit;
        }
    }

    //
    // Get the Static Proxy Lists
    //
        
    error = PROXY_INFO::GetProxySettings(lpProxySettings, fCheckVersion);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
PROXY_INFO_GLOBAL::RefreshProxySettings(
    IN BOOL fForceRefresh
    )

/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect

Arguments:
    
    fForceRefresh - Forces a hard refresh

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The lpszProxy or lpszProxyBypass list was bad

                  ERROR_NOT_ENOUGH_MEMORY
                    Failed to create an object or allocate space for a list,
                    etc.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::RefreshProxySettings",
                 "%B",
                 fForceRefresh
                 ));

    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    //
    // Force reload of registry settings and download of auto-proxy file from server
    //

    if ( IsRefreshDisabled())
    {
        QueueRefresh();
        goto quit;
    }

    //
    // Check Auto-Proxy/Auto-Detect Object, and read its settings
    //

    if ( IsGlobal() &&
         _AutoProxyList &&
         !(_AutoProxyList->IsOnAsyncAutoProxyThread()) )
    {                
        error = _AutoProxyList->RefreshProxySettings(
                    fForceRefresh
                    );

        if ( error != ERROR_SUCCESS ) { 
            goto quit;
        }
    }

    //
    // Get the Static Proxy Lists
    //
        
    //error = PROXY_INFO::RefreshProxySettings(fForceRefresh);

quit:

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();

    DEBUG_LEAVE(error);

    return error;
}

VOID
PROXY_INFO_GLOBAL::ReleaseQueuedRefresh(
    VOID
    )
/*++

Routine Description:

    Force a refresh of automatic settings, such as auto-proxy, auto-detect,
     When InternetOpen is called, allowing async threads.

Arguments:
    
    None.

Return Value:

    None.

--*/

{
    DWORD error = ERROR_SUCCESS;

    Lock(FALSE);

    SetRefreshDisabled(FALSE);

    if ( _fQueuedRefresh ) 
    {
        error = RefreshProxySettings(
                    FALSE
                    );

    }

    _fQueuedRefresh = FALSE;

    //
    // other threads free to access this PROXY_INFO again
    //

    Unlock();
}




DWORD
PROXY_INFO_GLOBAL::QueryProxySettings(
    IN AUTO_PROXY_ASYNC_MSG **ppQueryForProxyInfo
    )

/*++

Routine Description:

    Aquries Proxy Information.

    Note: if ppProxyState returns a non-NULL pointer than the Proxy
    strings can be assumed to be allocated pointers to strings.  Freeing
    the ppProxyState object will result in the pointers being freed as well.
    Otherwise the pointers will be to global string data that will not be
    freed unexpectedly.



Arguments:

    tUrlProtocol -  Scheme type, protocol that is being used.

    lpszUrl      -  Url being accessed.

    dwUrlLength  -  size of Url.

    lpszUrlHostName - Host name of site to connect to.

    dwUrlHostNameLength - Host name length.

    nUrlPort      - Port of server to connect to.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "PROXY_INFO_GLOBAL::QueryProxySettings",
                 "%#x",
                 ppQueryForProxyInfo
                 ));

    INET_ASSERT(ppQueryForProxyInfo);

    BOOL fReturn = FALSE;
    DWORD error = ERROR_SUCCESS;
    BOOL fNeedsGetNextProxy = FALSE;
    BOOL fLocked = FALSE;
    AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo = *ppQueryForProxyInfo;

    //
    // If we're dealing with a list of Proxies, we may have already tried one
    //  proxy and failed.  So go to the next proxy in the list
    //  and see if another one is availble to try.
    //

    if ( pQueryForProxyInfo->IsProxyEnumeration() )
    {
        fNeedsGetNextProxy = TRUE;
        goto quit;
    }

    if ( pQueryForProxyInfo->IsQueryOnCallback() &&
         ! pQueryForProxyInfo->IsAvoidAsyncCall())
    {
        goto quit;
    }

    Lock(FALSE);
    fLocked = TRUE;

    //
    // Determine if we're dealing with an Auto-Proxy DLL,
    //  that needs a call into its own implimentation of GetProxyInfo
    //

    if ( _AutoProxyList &&
         ((_dwProxyFlags & PROXY_TYPE_AUTO_PROXY_URL) ||
          (_dwProxyFlags & PROXY_TYPE_AUTO_DETECT))
          )
    {
        AUTO_PROXY_DLLS  *pAutoProxyList = _AutoProxyList;

        Unlock();
        fLocked = FALSE;

        error = pAutoProxyList->QueryProxySettings(ppQueryForProxyInfo);
        if ( error == ERROR_IO_PENDING ) {
            goto fastquit;
        }

        pQueryForProxyInfo = *ppQueryForProxyInfo;
        if ( error != ERROR_SUCCESS || 
             pQueryForProxyInfo->IsUseProxy()) 
        {
           goto quit;
        }

        Lock(FALSE);
        fLocked = TRUE;
    }

    //
    // BUGBUG [arthurbi] I am NOT happy with this outragously bad logic
    //  and feel this is getting way out of hand.  This code below is to
    //  simply catch a case where we have auto-proxy and InternetOpenUrl
    //  needs to detect whether to use HTTP over proxy for {gopher, ftp}
    //  OR direct gopher, ftp.
    //

    if ( pQueryForProxyInfo->IsAvoidAsyncCall() &&
         pQueryForProxyInfo->IsDontWantProxyStrings() &&
         _AutoProxyList &&
         _AutoProxyList->IsAutoProxy() &&
         _AutoProxyList->IsAutoProxyEnabled() )
    {
       pQueryForProxyInfo->SetUseProxy(TRUE);

       //if ( pQueryForProxyInfo->_tUrlProtocol == INTERNET_SCHEME_HTTPS )
       //{
       //    pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTPS;
       //}
       //else
       //{
            pQueryForProxyInfo->_tProxyScheme = INTERNET_SCHEME_HTTP;

       //}

       goto quit;
    }


    //
    // Use normal Proxy infomation stored in the registry
    //

    error = PROXY_INFO::QueryProxySettings(&pQueryForProxyInfo);

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

quit:

    if ( error == ERROR_SUCCESS &&
          ( fNeedsGetNextProxy ||
            pQueryForProxyInfo->IsProxyEnumeration())  )
    {
        error = pQueryForProxyInfo->GetNextProxy(_BadProxyList);
    }

    if ( fLocked )
    {
        Unlock();
    }

fastquit:

    DEBUG_LEAVE(error);

    return error;
}


BOOL
PROXY_INFO_GLOBAL::HostBypassesProxy(
    IN INTERNET_SCHEME tScheme,
    IN LPSTR           lpszHostName,
    IN DWORD           cchHostName
    )

/*++

Routine Description:

    Determine if request should bypass proxy for host

Arguments:

    tScheme         -
    lpszHostName    -
    cchHostName     -

Return Value:

    BOOL

--*/

{
    BOOL bReturn = FALSE;
    DWORD dwServiceType;
    BOOL bTryByPassList = TRUE;

    // Only do this if it is for a scheme wininet supports.
    if (tScheme == INTERNET_SCHEME_HTTP ||
        tScheme == INTERNET_SCHEME_HTTPS ||
        tScheme == INTERNET_SCHEME_DEFAULT)
    {
        dwServiceType = INTERNET_SERVICE_HTTP;
    }
    else if (tScheme == INTERNET_SCHEME_FTP)
    {
        dwServiceType = INTERNET_SERVICE_FTP;
    }
    else if (tScheme == INTERNET_SCHEME_GOPHER)
    {
        dwServiceType = INTERNET_SERVICE_GOPHER;
    }
    else
    {
        return bReturn;
    }

    // LOCK
    Lock(FALSE);

    if (IsAutoProxy() && 
        _AutoProxyList->IsAutoProxyEnabled() &&
        _AutoProxyList->IsAutoProxyThreadReadyForRequests() &&
        ((_dwProxyFlags & PROXY_TYPE_AUTO_PROXY_URL) ||
         (_dwProxyFlags & PROXY_TYPE_AUTO_DETECT))
         )
    {
        CServerInfo * pServerInfo = NULL;

        DWORD error = ::GetServerInfo(lpszHostName,
                                      dwServiceType,
                                      FALSE,
                                      &pServerInfo
                                      );

        if (pServerInfo != NULL)
        {
            bTryByPassList = FALSE;

            if (pServerInfo->IsProxyByPassSet())
            {
                bReturn = pServerInfo->WasProxyByPassed();
            }
            else
            {
                // We have to know call the autoproxy code to determine if
                // the proxy is being bypassed.

                // First create an URL which corresponds to
                // scheme://hostname

                ICSTRING urlName;
                char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

                DWORD dwSchemeLength;
                LPSTR schemeName = MapUrlScheme(tScheme, &dwSchemeLength);

                int bufLength = dwSchemeLength
                             + 3              // For the ://
                             + cchHostName
                             + 1 ;            // Trailing NULL.

                urlName.CreateStringBuffer((LPVOID)schemeName, dwSchemeLength, bufLength);

                if (dwSchemeLength != 0)
                {
                    urlName += "://" ;
                }
                urlName.Strncat(lpszHostName, cchHostName);


                AUTO_PROXY_ASYNC_MSG proxyInfoQuery(tScheme,
                                               urlName.StringAddress(),
                                               hostName,
                                               sizeof(hostName));

                AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery = &proxyInfoQuery;

                if ( _AutoProxyList->IsAutoProxyThreadReadyForRequests() ) {
                    proxyInfoQuery.SetBlockUntilCompletetion(TRUE);
                } else {
                    proxyInfoQuery.SetAvoidAsyncCall(TRUE);
                }

                Unlock();
                
                START_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL; // Make sure corresponding END is in codepath !!!
                
                error = QueryProxySettings(&pProxyInfoQuery);

                INET_ASSERT(error != ERROR_IO_PENDING);

                END_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL;
                
                // LOCK AGAIN
                Lock(FALSE);
                if (error == ERROR_SUCCESS)
                {
                    bReturn = !pProxyInfoQuery->IsUseProxy();
                    pServerInfo->SetProxyByPassed(bReturn);
                    if (pProxyInfoQuery && pProxyInfoQuery->IsAlloced())
                    {
                        delete pProxyInfoQuery;
                    }
                }
            }
            ::ReleaseServerInfo(pServerInfo);
        }
    }

    if (bTryByPassList) {        
        bReturn = IsHostInBypassList(lpszHostName, cchHostName);
    }

    Unlock();
    return bReturn;
}

//
// PROXY_STATE - an abstraction object used to provice simple string enumeration
//   given a list of proxies that need to be tested 
// 



BOOL
PROXY_STATE::GetNextProxy(
    IN  INTERNET_SCHEME   tUrlScheme,
    IN  BAD_PROXY_LIST &  BadProxyList,
    OUT LPINTERNET_SCHEME lptProxyScheme,
    OUT LPSTR * lplpszProxyHostName,
    OUT LPBOOL lpbFreeProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyHostPort
    )

/*++

Routine Description:

    Parses the current Proxy State information to acquire the
        proxy name, port, type to use.


Arguments:

    tUrlScheme   -  Scheme type, protocol that is being used.

    BadProxyList -  Reference to array of bad proxies that we can add/remove/check
                        from.

    lptProxyScheme - On output contains the correct proxy server type to use.
                        ex: if a SOCKS proxy is to be used to handle the FTP protocol,
                            this will be a INTERNET_SCHEME_SOCKS.

    lplpszProxyHostName - Pointer to allocated memory containing the address of
                           the proxy host name.

    lpbFreeProxyHostName - TRUE if *lplpszProxyHostName was allocated

    lpdwProxyHostNameLength - length of lplpszProxyHostName.

    lpProxyHostPort    - Host Port of Proxy.



Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR lpszDelimiter = NULL;
    BOOL  fReturn       = FALSE;
    LPSTR lpszPortDelim = NULL;
    LPSTR lpszPort      = NULL;


    if ( !_fIsMultiProxyList )
    {
        *lptProxyScheme = _tProxyScheme;
        *lplpszProxyHostName = _lpszAutoProxyList;
        *lpbFreeProxyHostName = FALSE;
        *lpdwProxyHostNameLength = _dwcbAutoProxyList;
        *lpProxyHostPort  = _proxyHostPort;
    }

    _fIsAnotherProxyAvail = FALSE;

    while ( *_lpszOffset != '\0' )
    {
        LPSTR lpszNewOffset ;

        //
        // Remove the delimiter so we can see the next token.
        //  ex: PROXY foo:80; DIRECT
        //  we would find DIRECT first with strstr, if we didn't
        //  delimit first.
        //

        lpszDelimiter = strchr(_lpszOffset, ';' );

        if ( lpszDelimiter == NULL )
        {
            lpszDelimiter = strchr(_lpszOffset, ',' );
        }

        if ( lpszDelimiter )
        {
            *lpszDelimiter = '\0';
        }

        lpszNewOffset=
            strstr(_lpszOffset, "DIRECT");

        if ( lpszNewOffset )
        {
            lpszNewOffset += sizeof("DIRECT");
            _lpszOffset    = lpszNewOffset;

            //
            // FALSE means direct.
            //

            fReturn = FALSE;
            goto quit;
        }

        //
        // Its not direct, try PROXY or SOCKS.
        //

        lpszNewOffset =
            strstr(_lpszOffset, "PROXY");


        if ( lpszNewOffset)
        {
            lpszNewOffset += sizeof("PROXY");
            *lpProxyHostPort = INTERNET_DEFAULT_HTTP_PORT;

            if ( tUrlScheme == INTERNET_SCHEME_HTTPS )
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTPS;
            }
            else
            {
                *lptProxyScheme = INTERNET_SCHEME_HTTP;

            }
        }
        else
        {
            lpszNewOffset =
                strstr(_lpszOffset, "SOCKS");

            if ( lpszNewOffset )
            {
                lpszNewOffset   += sizeof("SOCKS");
                *lptProxyScheme  = INTERNET_SCHEME_SOCKS;
                *lpProxyHostPort = INTERNET_DEFAULT_SOCKS_PORT;
            }
        }

        //
        // Now do the generic common things for SOCKS, or PROXY
        // entries, ie: get port, hostname, and hostname size.
        //

        if ( lpszNewOffset )
        {
            _lpszOffset    = lpszNewOffset;

            SKIPWS(_lpszOffset);

            *lplpszProxyHostName = _lpszOffset;
            *lpbFreeProxyHostName = FALSE;

            lpszPortDelim = strchr(_lpszOffset, ':');

            if ( lpszPortDelim )
            {
                *lpszPortDelim = '\0';
                lpszPort  = lpszPortDelim+1;

                *lpProxyHostPort = (INTERNET_PORT)
                    atoi(lpszPort);
            }

            *lpdwProxyHostNameLength = lstrlen(_lpszOffset);

            if (BadProxyList.IsBadProxyName(*lplpszProxyHostName, *lpProxyHostPort))
            {
                if ( lpszDelimiter )
                {
                    _lpszOffset = (lpszDelimiter+1);
                }
                else
                {
                    _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
                }

                continue;
            }

            fReturn = TRUE;
        }

        break;
    }

quit:

    //if ( lpszPortDelim )
    //{
    //    *lpszPortDelim = ':';
    //}

    if ( lpszDelimiter )
    {
        *lpszDelimiter = ';';

        _lpszOffset = (lpszDelimiter+1);
    }
    else
    {
        _lpszOffset = _lpszAutoProxyList + _dwcbAutoProxyList;
    }

    if ( fReturn )
    {
        _lpszLastProxyUsed = *lplpszProxyHostName;
        _LastProxyUsedPort = *lpProxyHostPort;

        //
        // If theres another possible proxy in this list,
        //   then we'll need to remember that
        //

        if ( _lpszOffset &&
             *_lpszOffset &&
                (strstr(_lpszOffset, "PROXY") ||
                 strstr(_lpszOffset, "DIRECT") ||  
                 strstr(_lpszOffset, "SOCKS"))
            )
        {
            _fIsAnotherProxyAvail = TRUE;
        }
    }

    return fReturn;
}




PRIVATE
LPSTR
GetRegistryProxyParameter(
    IN LPSTR lpszParameterName
    )

/*++

Routine Description:

    Reads a string from the registry into a buffer, then shrinks the buffer

Arguments:

    lpszParameterName   - name of string to retrieve

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    LPSTR buffer = NULL;
    DWORD length = PROXY_REGISTRY_STRING_LENGTH;
    BOOL done = FALSE;

    do {
        buffer = (LPSTR)ResizeBuffer(buffer, length, FALSE);
        if (done || (buffer == NULL)) {
            break;
        }

        DWORD error;

        error = InternetReadRegistryString(lpszParameterName, buffer, &length);
        length = (error == ERROR_SUCCESS) ? ((length == 0) ? 0 : (length + 1)) : 0;
        done = TRUE;
    } while (TRUE);

    return buffer;
}



//
// wrapper function for urlzones.
//

BOOLAPI IsHostInProxyBypassList (INTERNET_SCHEME tScheme, LPCSTR pszHost, DWORD cchHost)
{
    BOOL    fRet = FALSE;

    if (!GlobalDataInitialized) {
        GlobalDataInitialize();
    }

    if(ERROR_SUCCESS == LoadWinsock())
    {
        fRet = GlobalProxyInfo.HostBypassesProxy(tScheme, (LPSTR)pszHost, cchHost);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\hutil.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    hutil.cxx

Abstract:

    contains outdated c-c++ interface functions

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle,
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    )
{
    BOOL fLocalHandle;
    DWORD Error;
    HANDLE_OBJECT *HandleObj;
    HINTERNET InternetHandle;

    HandleObj = (HANDLE_OBJECT *)Handle;

    Error = HandleObj->IsValid(ExpectedHandleType);
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    InternetHandle = HandleObj->GetInternetHandle();

#if 0
    if( InternetHandle == INET_INVALID_HANDLE_VALUE ) {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }
#endif // 0

    if( InternetHandle == LOCAL_INET_HANDLE ) {
        fLocalHandle = TRUE;
    }
    else {

        //
        // is a remote handle.
        //

        fLocalHandle = FALSE;
    }

    *IsLocalHandle = fLocalHandle;
    *IsAsyncHandle = ((INTERNET_HANDLE_OBJECT *)Handle)->IsAsyncHandle();
    Error = ERROR_SUCCESS;

Cleanup:

    return( Error );
}

DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // find the handle type.
        //

        *HandleType = HandleObj->GetHandleType();
    }
    return error;
}

DWORD
RSetHtmlHandleType(
    HINTERNET Handle
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    HINTERNET_HANDLE_TYPE handleType;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // find the handle type.
    //

    handleType = HandleObj->GetHandleType();

    //
    // if the handle type is one of those that can be accessed as RAW data or
    // HTML, then set the HTML flag. HTTP requests are HTML by default. Setting
    // HTML data for any other handle type is an error.
    //
    // Originally, we allowed File and Find handles to be HTML-ised, but we now
    // only allow Find handles: files are returned via the normal mechanism
    //

    if ((handleType == TypeFtpFindHandle)
    || (handleType == TypeGopherFindHandle)) {
        HandleObj->SetHtml();
        return ERROR_SUCCESS;
    } else if (handleType == TypeHttpRequestHandle) {
        return ERROR_SUCCESS;
    } else {
        return ERROR_INTERNET_INVALID_OPERATION;
    }
}

DWORD
RSetHtmlState(
    HINTERNET Handle,
    HTML_STATE State
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        HandleObj->SetHtmlState(State);
    }
    return error;
}

DWORD
RGetHtmlState(
    HINTERNET Handle,
    LPHTML_STATE lpState
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpState = HandleObj->GetHtmlState();
    }
    return error;
}

DWORD
RSetUrl(
    HINTERNET Handle,
    LPSTR lpszUrl
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        LPSTR url;

        url = HandleObj->GetUrl();
        if (url != NULL) {
            DEL_STRING(url);
        }
        if (lpszUrl != NULL) {
            url = NEW_STRING(lpszUrl);
            if (url == NULL) {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            url = NULL;
        }
        if (error == ERROR_SUCCESS) {
            HandleObj->SetUrl(url);
        }
    }
    return error;
}

DWORD
RGetUrl(
    HINTERNET Handle,
    LPSTR* lpszUrl
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpszUrl = HandleObj->GetUrl();
    }
    return error;
}

DWORD
RSetDirEntry(
    HINTERNET Handle,
    LPSTR lpszDirEntry
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    LPSTR dirEntry;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error != ERROR_SUCCESS ) {
        return error;
    }

    dirEntry = HandleObj->GetDirEntry();

    if (dirEntry != NULL) {

        //
        // we should not be replacing one non-NULL dir entry with another
        //

        INET_ASSERT(lpszDirEntry == NULL);

        DEL_STRING(dirEntry);
    }

    //
    // make a copy of the string and add it to the object
    //

    if (lpszDirEntry != NULL) {
        dirEntry = NEW_STRING(lpszDirEntry);
        if (dirEntry == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        dirEntry = NULL;
    }
    HandleObj->SetDirEntry(dirEntry);
    return ERROR_SUCCESS;
}

DWORD
RGetDirEntry(
    HINTERNET Handle,
    LPSTR* lpszDirEntry
    )
{
    HANDLE_OBJECT *HandleObj = (HANDLE_OBJECT *)Handle;
    DWORD error;

    //
    // validate handle before we use it.
    //

    error = HandleObj->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpszDirEntry = HandleObj->GetDirEntry();
    }
    return error;
}

DWORD
RSetParentHandle(
    HINTERNET hChild,
    HINTERNET hParent,
    BOOL DeleteWithChild
    )
{
    DWORD error;

    //
    // ensure the child handle is valid
    //

    error = ((HANDLE_OBJECT*)hChild)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // and so too the parent
        //

        error = ((HANDLE_OBJECT*)hParent)->IsValid(TypeWildHandle);
        if (error == ERROR_SUCCESS) {

            //
            // make the association
            //

            ((HANDLE_OBJECT*)hChild)->SetParent(hParent, DeleteWithChild);
        }
    }
    return error;
}

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpdwContext = ((INTERNET_HANDLE_OBJECT*)hInternet)->GetContext();
    }
    return error;
}

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT*)hInternet)->SetContext(dwContext);
    }
    return error;
}

DWORD
RGetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    LPDWORD lpdwTimeoutValue
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        *lpdwTimeoutValue = ((INTERNET_HANDLE_OBJECT*)hInternet)->GetTimeout(dwTimeoutOption);
    }
    return error;
}

DWORD
RSetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    DWORD dwTimeoutValue
    )
{
    DWORD error;

    //
    // ensure the handle is valid
    //

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT*)hInternet)->SetTimeout(dwTimeoutOption, dwTimeoutValue);
    }
    return error;
}

DWORD
RGetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    LPDWORD lpdwBufferSize
    )
{
    DWORD error;

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // BUGBUG - this handle must be a connect handle, or object derived from
        //          connect handle
        //

        *lpdwBufferSize = ((INTERNET_CONNECT_HANDLE_OBJECT*)hInternet)
            ->GetBufferSize(dwBufferSizeOption);
    }
    return error;
}

DWORD
RSetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    DWORD dwBufferSize
    )
{
    DWORD error;

    error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {

        //
        // BUGBUG - this handle must be a connect handle, or object derived from
        //          connect handle
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT*)hInternet)->SetBufferSize(
            dwBufferSizeOption,
            dwBufferSize
            );
    }
    return error;
}

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback
    )
{
    //
    // NULL handle should have been caught before we got here
    // (its in InternetQueryOption())
    //

    INET_ASSERT(Handle != NULL);

    *lpStatusCallback = ((INTERNET_HANDLE_OBJECT *)Handle)->GetStatusCallback();
    return ERROR_SUCCESS;
}

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType)
{
    DWORD error;

    //
    // NULL handle value should have been caught already
    // (in InternetSetStatusCallback())
    //

    INET_ASSERT(Handle != NULL);

    error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
    if (error == ERROR_SUCCESS) {
        error = ((INTERNET_HANDLE_OBJECT *)Handle)->
                                ExchangeStatusCallback(lpStatusCallback, fType);
    }
    return error;
}

//DWORD
//RAddAsyncRequest(
//    IN HINTERNET Handle,
//    BOOL fNoCallbackOK
//    )
//{
//    DWORD error;
//
//    if (Handle != NULL) {
//        error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
//        if (error == ERROR_SUCCESS) {
//            error = ((INTERNET_HANDLE_OBJECT *)Handle)->AddAsyncRequest(fNoCallbackOK);
//        }
//    } else {
//        error = ERROR_INVALID_HANDLE;
//    }
//    return error;
//}
//
//DWORD
//RRemoveAsyncRequest(
//    IN HINTERNET Handle
//    )
//{
//    DWORD error;
//
//    if (Handle != NULL) {
//        error = ((HANDLE_OBJECT *)Handle)->IsValid(TypeWildHandle);
//        if (error == ERROR_SUCCESS) {
//            ((INTERNET_HANDLE_OBJECT *)Handle)->RemoveAsyncRequest();
//        }
//    } else {
//        error = ERROR_INVALID_HANDLE;
//    }
//    return error;
//}

DWORD
RGetLocalHandle(
    HINTERNET Handle,
    HINTERNET *LocalHandle
    )
{
    DWORD Error;
    HANDLE_OBJECT *ObjectHandle = (HANDLE_OBJECT *)Handle;

#if 1
    Error = ObjectHandle->IsValid(TypeWildHandle);
    if (Error != ERROR_SUCCESS) {
        goto Cleanup;
    }
#endif // DBG

    Error = ObjectHandle->GetStatus();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    *LocalHandle = ObjectHandle->GetHandle();

Cleanup:

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\chunk.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    chunk.cxx

Abstract:

    Contains a generic chunked transfer implimentation

Author:

    Arthur L Bierer (arthurbi) 03-May-1997

Revision History:

    03-May-1997 arthurbi
        Created

--*/


#include <wininetp.h>


inline
CHUNK_TOKEN
CHUNK_TRANSFER::GetToken(
    IN OUT LPSTR *lplpInputBuffer,
    IN LPSTR     lpEndOfInputBuffer,
    OUT LPDWORD  lpdwValue,
    IN DWORD     dwExpectedTokenSize,
    OUT LPDWORD  lpdwBytesTokenized
    )

/*++

Routine Description:

    Lexes through a byte stream, seperating data into tokens.  Data is special cased for efficency.


Arguments:

    lplpInputBuffer - Pointer to Pointer of Buffer that should be lexed, on return contains
        an offset where the next character to lex is.

    lpEndofInputBuffer - Pointer to last character to passed in Buffer.

    lpdwValue   - On return, MAY contain numerical conversion of a text number (digit) token

    dwExpectedTokenSize - Expected size of token, in all cases except for data should be 1

    lpdwBytesTokenized - On return, contains size of token


Return Value:

    CHUNK_TOKEN
    Success - The Correct token.

    Failure - CHUNK_TOKEN_INVALID

--*/

{
    BOOL fFirstIteration = TRUE;
    CHUNK_TOKEN ctToken = CHUNK_TOKEN_INVALID;

    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "CHUNK_TRANSFER::GetToken",
                "%x [%x, %.10q], %x, %x, %u, %x",
                lplpInputBuffer,
                *lplpInputBuffer,
                *lplpInputBuffer,
                lpEndOfInputBuffer,
                lpdwValue,
                dwExpectedTokenSize,
                lpdwBytesTokenized
                ));

    *lpdwBytesTokenized = 0;

    while ( *lplpInputBuffer    < lpEndOfInputBuffer
            && *lpdwBytesTokenized < dwExpectedTokenSize )
    {
        //
        // Set Default Token type
        //

        ctToken = CHUNK_TOKEN_DATA;

        //
        // Handle Other, "special" tokens, only if asked for by the parser.
        //

        if ( dwExpectedTokenSize == 1 )
        {

            if ( **lplpInputBuffer == '\r' )
            {
                ctToken = CHUNK_TOKEN_CR;
                goto quit;
            }

            if ( **lplpInputBuffer == '\n' )
            {
                ctToken = CHUNK_TOKEN_LF;
                goto quit;
            }

            if ( **lplpInputBuffer == ':' )
            {
                ctToken = CHUNK_TOKEN_COLON;
                goto quit;
            }

            if ( **lplpInputBuffer >= '0' && **lplpInputBuffer <= '9' )
            {
                *lpdwValue = (DWORD) (**lplpInputBuffer - '0');
                ctToken = CHUNK_TOKEN_DIGIT;
                goto quit;
            }


            if ( **lplpInputBuffer >= 'A' && **lplpInputBuffer <= 'F' )
            {
                *lpdwValue = (DWORD) (**lplpInputBuffer - 'A') + 10;
                ctToken = CHUNK_TOKEN_DIGIT;
                goto quit;
            }

            if ( **lplpInputBuffer >= 'a' && **lplpInputBuffer <= 'f' )
            {
                *lpdwValue = (DWORD) (**lplpInputBuffer - 'a') + 10;
                ctToken = CHUNK_TOKEN_DIGIT;
                goto quit;
            }
        }

        fFirstIteration = FALSE;
        (*lplpInputBuffer)++;
        (*lpdwBytesTokenized)++;
    }


quit:

    if (ctToken != CHUNK_TOKEN_DATA && ctToken != CHUNK_TOKEN_INVALID)
    {
        if ( !fFirstIteration)
        {
            ctToken = CHUNK_TOKEN_DATA;
        }
        else
        {
            //
            // Advance past this token, since we've only
            //  lexed one token
            //

            (*lplpInputBuffer)++;
            (*lpdwBytesTokenized)++;
        }
    }

    DEBUG_PRINT(HTTP,
                INFO,
                ("GetToken: %q, expected=%u, actual=%u\n",
                InternetMapChunkToken(ctToken),
                dwExpectedTokenSize,
                *lpdwBytesTokenized
                ));

    DEBUG_LEAVE((DWORD)ctToken);

    return ctToken;
}



DWORD
CHUNK_TRANSFER::ParseChunkInput(
    LPSTR lpInputBuffer,
    DWORD dwInputBufferSize,
    LPSTR *lplpInputBufferNew,
    LPDWORD lpdwInputBufferNewSize
    )

/*++

Routine Description:

    Parses a buffer of an assumed chunked encoding byte stream.  Seperates out data from header information.


Arguments:

    lpInputBuffer - Pointer to buffer containing a stream of bytes to parse

    dwInputBufferSize - size of byte lpInputBuffer

    lplpInputBufferNew - Offset into passed in lpInputBuffer, (not used, yet)

    lpdwInputBufferNewSize - On Return, cotains the size of lpInputBuffer ( data is compressed )

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure -

--*/


{
    CHUNK_TOKEN ctToken;
    DWORD dwValue;
    DWORD dwExpectedTokenSize = 1;
    DWORD dwActualTokenSize   = 0;
    LPSTR lpszEndOfInputBuffer = (LPSTR) (lpInputBuffer + dwInputBufferSize);
    LPSTR lpszStartOfFirstDataBuffer = NULL;
    DWORD dwFirstDataBufferSize = 0;
    LPSTR lpszStartOfNextDataBuffer = NULL;
    DWORD error = ERROR_SUCCESS;

    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "CHUNK_TRANSFER::ParseChunkInput",
                "%x [%.10q], %u, %x, %x",
                lpInputBuffer,
                lpInputBuffer,
                dwInputBufferSize,
                lplpInputBufferNew,
                lpdwInputBufferNewSize
                ));

    *lplpInputBufferNew = lpInputBuffer;

    while ( *lplpInputBufferNew < lpszEndOfInputBuffer)
    {

        //
        // Calculate the max size of the token can be, only
        //  relevant for data, since all other tokens are assumed
        //  to be size of 1.
        //

        if (_csState == CHUNK_STATE_DATA_PARSE)
        {
            dwExpectedTokenSize = (_dwChunkDataSize - _dwChunkDataRead);
            lpszStartOfNextDataBuffer = *lplpInputBufferNew;
        }
        else
        {
            dwExpectedTokenSize = 1;
        }

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("ParseChunk: %q, %u/%u\n",
                    InternetMapChunkState(_csState),
                    _dwChunkDataRead,
                    _dwChunkDataSize
                    ));


        //
        //  Lex through the byte stream looking for our next token.
        //

        ctToken = GetToken( lplpInputBufferNew,
                            lpszEndOfInputBuffer,
                            &dwValue,
                            dwExpectedTokenSize,
                            &dwActualTokenSize
                            );

        if ( ctToken == CHUNK_TOKEN_INVALID )
        {
            //
            // Need more data to parse...
            //

            error = ERROR_SUCCESS;
            goto quit;
        }

        //
        // Based on our current state, evalulate the token,
        //  and figure out what to do next.
        //

        switch ( _csState )
        {
            case CHUNK_STATE_START:

                ResetSubStateInfo();

                if ( ctToken != CHUNK_TOKEN_DIGIT )
                {
                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("-->CHUNK err: Got %q, while looking for NOT %q\n",
                                InternetMapChunkToken(ctToken),
                                InternetMapChunkToken(CHUNK_TOKEN_DIGIT)
                                ));

                    error = ERROR_INTERNET_INTERNAL_ERROR;
                    goto quit;
                }

                SetState(CHUNK_STATE_SIZE_PARSE);
                // otherwise fall through

            case CHUNK_STATE_SIZE_PARSE:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_DIGIT:
                        _dwCalculatedChunkSize *= BASE_HEX;
                        _dwCalculatedChunkSize += dwValue;
                        break;

                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        // fall through

                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_COLON:


                        _dwChunkDataSize = _dwCalculatedChunkSize;
                        _dwChunkDataRead = 0;


                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("ChunkParse-GotChunksize: size=%u, %x\n",
                                    _dwCalculatedChunkSize,
                                    _dwCalculatedChunkSize
                                    ));

                        if (ctToken == CHUNK_TOKEN_CR)
                        {
                            SetState(CHUNK_STATE_SIZE_CRLF);
                        }
                        else
                        {
                            SetState(CHUNK_STATE_EXT_PARSE);
                        }

                        break;

                    default:
                        // ERROR
                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_EXT_PARSE:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        SetState(CHUNK_STATE_SIZE_CRLF);
                        break;

                    case CHUNK_TOKEN_DIGIT:
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_COLON:

                        break;

                    default:
                        // ERROR
                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_SIZE_CRLF:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_LF:

                        _dwLf++;

                        if ( IsCrLf() )
                        {
                            ClearCrLf();
                            if ( _dwCalculatedChunkSize == 0 )
                            {
                                SetState(CHUNK_STATE_ZERO_FOOTER);
                            }
                            else
                            {
                                SetState(CHUNK_STATE_DATA_PARSE);
                            }
                        }
                        else
                        {
                            DEBUG_PRINT(HTTP,
                                        INFO,
                                        ("-->CHUNK err: Got %q, But CRLF not matched, CR=%u, LF=%u\n",
                                        InternetMapChunkToken(ctToken),
                                        _dwCr,
                                        _dwLf
                                        ));

                            error = ERROR_INTERNET_INTERNAL_ERROR;
                            goto quit;
                        }

                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for %q\n",
                                    InternetMapChunkToken(ctToken),
                                    InternetMapChunkToken(CHUNK_TOKEN_LF)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_DATA_PARSE:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_CR:
                    case CHUNK_TOKEN_LF:
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                    case CHUNK_TOKEN_COLON:

                        //
                        // If this is the first piece of data we receive
                        //  than save it off, so we know the start of the
                        //  buffer we are returning as data.
                        //

                        if ( lpszStartOfFirstDataBuffer == NULL )
                        {
                            lpszStartOfFirstDataBuffer = lpInputBuffer;
                        }

                        //
                        // If this is not the first block of data in the passed in buffer,
                        //  we must move the block of data OVER any Chunked-tranfer header
                        //  information.
                        //

                        if ( (lpszStartOfFirstDataBuffer+dwFirstDataBufferSize) != lpszStartOfNextDataBuffer )
                        {
                            MoveMemory((LPVOID) (lpszStartOfFirstDataBuffer+dwFirstDataBufferSize), // Dest
                                       (LPVOID) lpszStartOfNextDataBuffer,                          // Source
                                       dwActualTokenSize                                            // size
                                       );
                        }

                        //
                        // Update the size of data we've parsed out, and
                        //  check to see if we've completely received all data.
                        //

                        dwFirstDataBufferSize += dwActualTokenSize;
                        _dwChunkDataRead += dwActualTokenSize;

                        if ( _dwChunkDataRead == _dwChunkDataSize )
                        {
                            SetState(CHUNK_STATE_DATA_CRLF);
                        }

                        INET_ASSERT(_dwChunkDataRead <= _dwChunkDataSize);

                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for CR,LF,DATA,DIGIT,COLON\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;

                }

                break;

            case CHUNK_STATE_DATA_CRLF:

                switch (ctToken)
                {
                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        break;

                    case CHUNK_TOKEN_LF:
                        _dwLf++;

                        if ( IsCrLf() )
                        {
                            ClearCrLf();
                            SetState(CHUNK_STATE_START);
                        }
                        else
                        {
                            DEBUG_PRINT(HTTP,
                                        INFO,
                                        ("-->CHUNK err: Got %q, BUT CRLF not matched, CR=%u, LF=%u\n",
                                        InternetMapChunkToken(ctToken),
                                        _dwCr,
                                        _dwLf
                                        ));

                            error = ERROR_INTERNET_INTERNAL_ERROR;
                            goto quit;
                        }

                        break;

                    default:
                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for CR or LF (CHUNK DATA SIZE INCORRECT??)\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER:

                switch (ctToken)
                {
                    case CHUNK_TOKEN_CR:

                        _dwCr++;
                        SetState(CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF);
                        break;

                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                    case CHUNK_TOKEN_COLON:

                        SetState(CHUNK_STATE_ZERO_FOOTER_NAME);
                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for DATA or CR\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER_NAME:

                switch (ctToken)
                {
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                        break;

                    case CHUNK_TOKEN_COLON:
                        SetState(CHUNK_STATE_ZERO_FOOTER_VALUE);
                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for DATA, DIGIT, COLON\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER_VALUE:
                switch (ctToken)
                {
                    case CHUNK_TOKEN_DATA:
                    case CHUNK_TOKEN_DIGIT:
                        break;

                    case CHUNK_TOKEN_CR:
                        _dwCr++;
                        SetState(CHUNK_STATE_ZERO_FOOTER_CRLF);
                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for DATA, DIGIT, CR\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_ZERO_FOOTER_CRLF:
            case CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF:

                switch ( ctToken )
                {
                    case CHUNK_TOKEN_LF:

                        _dwLf++;

                        if ( IsCrLf() )
                        {
                            ClearCrLf();

                            if ( _csState == CHUNK_STATE_ZERO_FOOTER_CRLF)
                            {
                                SetState(CHUNK_STATE_ZERO_FOOTER);
                            }
                            else
                            {
                                INET_ASSERT( _csState == CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF);
                                //Done?
                                SetState(CHUNK_STATE_FINISHED);

                                DEBUG_PRINT(HTTP,
                                            INFO,
                                            ("EOF chunk\n"
                                            ));

                                error = ERROR_SUCCESS;
                                goto quit;
                            }
                        }
                        else
                        {
                            DEBUG_PRINT(HTTP,
                                        INFO,
                                        ("-->CHUNK err: Got %q, But CRLF not matched, CR=%u, LF=%u\n",
                                        InternetMapChunkToken(ctToken),
                                        _dwCr,
                                        _dwLf
                                        ));

                            error = ERROR_INTERNET_INTERNAL_ERROR;
                            goto quit;
                        }

                        break;

                    default:

                        DEBUG_PRINT(HTTP,
                                    INFO,
                                    ("-->CHUNK err: Got %q, while looking for LF\n",
                                    InternetMapChunkToken(ctToken)
                                    ));

                        error = ERROR_INTERNET_INTERNAL_ERROR;
                        goto quit;
                }

                break;

            case CHUNK_STATE_FINISHED:
                INET_ASSERT(FALSE);
                error = ERROR_SUCCESS;
                goto quit;

            default:
                INET_ASSERT(FALSE);
                error = ERROR_INTERNET_INTERNAL_ERROR;
                goto quit;

        }
    }

quit:

    if ( error == ERROR_SUCCESS)
    {
        if ( dwFirstDataBufferSize > 0 )
        {
            INET_ASSERT(lpInputBuffer == lpszStartOfFirstDataBuffer);
        }

        *lplpInputBufferNew     = lpInputBuffer;
        *lpdwInputBufferNewSize = dwFirstDataBufferSize;
    }


    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\add.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    add.cxx

Abstract:

    This file contains the implementation of the HttpAddRequestHeadersA API.

    The following functions are exported by this module:

        HttpAddRequestHeadersA
        HttpAddRequestHeadersW

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpAddRequestHeadersA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private manifests
//

#define VALID_ADD_FLAGS (HTTP_ADDREQ_FLAG_ADD_IF_NEW \
                        | HTTP_ADDREQ_FLAG_ADD \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA \
                        | HTTP_ADDREQ_FLAG_REPLACE \
                        | HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON \
                        )

//
// functions
//


INTERNETAPI_(BOOL) HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle

Arguments:

    hRequest        - An open HTTP request handle returned by HttpOpenRequest()

    lpszHeaders     - The headers to append to the request. Each header must be
                      terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is -1L
                      then lpszHeaders is assumed to be zero terminated (ASCIIZ)

    dwModifiers     - flags controlling operation. Can be one or more of:

                        HTTP_ADDREQ_FLAG_ADD_IF_NEW
                            - add the header, but only if it does not already
                              exist. Index must be zero

                        HTTP_ADDREQ_FLAG_ADD
                            - if HTTP_ADDREQ_FLAG_REPLACE is set, but the header
                              is not found and this flag is set then the header
                              is added, so long as there is a valid header-value

                        HTTP_ADDREQ_FLAG_COALESCE
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
                        HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
                            - concatenate headers of same name. E.g. if we
                              already have "Accept: text/html" then adding
                              "Accept: text/*" will create
                              "Accept: text/html, text/*"

                        HTTP_ADDREQ_FLAG_REPLACE
                            - replaces the named header. Only one header can be
                              supplied. If header-value is empty then the header
                              is removed

Return Value:

    Success - TRUE
                The header was appended successfully

    Failure - FALSE
                The operation failed. Error status is available by calling
                GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpAddRequestHeadersA",
                     "%#x, %.80q, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD error;
    HINTERNET hRequestMapped = NULL;
    DWORD nestingLevel = 0;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    if ((lpszHeaders == NULL)
    || (*lpszHeaders == '\0')
    || (dwHeadersLength == 0)
    || (dwModifiers & (HTTP_ADDREQ_FLAGS_MASK & ~VALID_ADD_FLAGS))) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // BUGBUG - we should determine whether the app is trying to give us a bogus
    //          header, and whether the header conforms to the format:
    //
    //                          "<header>[:[ <value>]]"
    //

    __try {
        if (dwHeadersLength == (DWORD)-1) {
            dwHeadersLength = (DWORD)lstrlen(lpszHeaders);
        } else {

            //
            // perform our own IsBadStringPtr() - don't have to call another
            // function or register extra exception handlers
            //

            for (DWORD i = 0; i < dwHeadersLength; ++i) {

                char ch = *((char volatile *)&lpszHeaders[i]);
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }
    ENDEXCEPT
    if (error == ERROR_SUCCESS) {
        error = wHttpAddRequestHeaders(hRequestMapped,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwModifiers
                                       );
    }

quit:

    _InternetDecNestingCount(nestingLevel);

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);

    return error == ERROR_SUCCESS;
}


INTERNETAPI_(BOOL) HttpAddRequestHeadersW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Appends additional header(s) to an HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    lpszHeaders - The headers to append to the request. Each header must be
        terminated by a CR/LF pair.

    dwHeadersLength - The length (in characters) of the headers. If this is
        -1L, then lpszHeaders is assumed to be zero terminated (ASCIIZ).

    dwModifiers     -

Return Value:

    TRUE - The header was appended successfully.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpAddRequestHeadersW",
                     "%#x, %.80wq, %d, %#x",
                     hRequest,
                     lpszHeaders,
                     dwHeadersLength,
                     dwModifiers
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!lpszHeaders || *lpszHeaders==L'\0' || !dwHeadersLength
        || IsBadStringPtrW(lpszHeaders, dwHeadersLength))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        MEMORYPACKET mpHeaders;
        ALLOC_MB(lpszHeaders, (dwHeadersLength==-1L ? 0 : dwHeadersLength), mpHeaders);
        if (mpHeaders.psStr)
        {
            UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
            fResult = HttpAddRequestHeadersA(hRequest, mpHeaders.psStr, mpHeaders.dwSize, dwModifiers);
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Worker function to append additional header(s) to an HTTP request handle

Arguents:

    hRequest        - handle of HTTP request

    lpszHeaders     - pointer to buffer containing one or more headers

    dwHeadersLength - length of lpszHeaders. Cannot be -1 at this stage

    dwModifiers     - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    The header string(s) was bad after all

                  ERROR_INTERNET_INCORRECT_HANDLE_STATE
                    We can't add headers to this object at this time

                  ERROR_HTTP_HEADER_NOT_FOUND
                    We were asked to replace a header, but couldn't find it

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    We were asked to add a header, only if one of the same name
                    doesn't already exist. It does

--*/

{
    //
    // dwHeadersLength cannot be -1 or 0 at this stage. Nor can lpszHeaders be
    // NULL
    //

    INET_ASSERT(lpszHeaders != NULL);
    INET_ASSERT(dwHeadersLength != (DWORD)-1);
    INET_ASSERT(dwHeadersLength != 0);

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "wHttpAddRequestHeaders",
                 "%#x, %#x [%.80q], %d, %#x",
                 hRequest,
                 lpszHeaders,
                 lpszHeaders,
                 dwHeadersLength,
                 dwModifiers
                 ));

    //
    // get the underlying object and check that we can add headers
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    DWORD error;

    if (!IS_VALID_HTTP_STATE(pRequest, ADD, TRUE)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    DWORD offset;
    LPSTR header;

    offset = 0;
    header = (LPSTR)lpszHeaders;

    do {

        //
        // first time: ignore any empty strings; subsequent time: clean off any
        // trailing line termination
        //

        while ((offset < dwHeadersLength)
        && ((lpszHeaders[offset] == '\r') || (lpszHeaders[offset] == '\n'))) {
            ++offset;
        }
        if (offset == dwHeadersLength) {

            //
            // even if app tried adding empty line(s), we return success
            //

            error = ERROR_SUCCESS;
            break;
        }

        DWORD length;
        DWORD nameLength;
        DWORD valueLength;
        LPSTR value;
        BOOL done;

        nameLength = 0;
        valueLength = 0;
        value = NULL;

        //
        // break the header into header-name, header-value pairs. Exclude CR-LF
        // from the header-value (if present)
        //

        for (length = 0, header = (LPSTR)&lpszHeaders[offset];
            offset < dwHeadersLength;
            ++length, ++offset) {

            char ch = header[length];

            if ((ch == '\r') || (ch == '\n')) {

                //
                // end of this particular header
                //

                break;
            } else if (ch == ':') {
                if (nameLength == 0) {

                    //
                    // found end of header name
                    //

                    nameLength = length;
                    value = &header[length];
                }
            }
        }
        if (length == 0) {

            //
            // empty string
            //

            continue;
        } else if (nameLength == 0) {

            //
            // entry consists of just header-name (e.g. "Accept[\r\n]")
            //

            nameLength = length;
        } else {

            //
            // find the start of the header-value
            //

            valueLength = (DWORD) (header + length - value);

            //
            // N.B. We are allowing any mixture of ':' and ' ' between header
            // name and value, but this is probably not a big deal...
            //

            while ((*value == ':') || (*value == ' ') && (valueLength != 0)) {
                ++value;
                --valueLength;
            }
        }
        if (dwModifiers
            & (HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD_IF_NEW)) {

            //
            // replace or remove the header
            //

            error = pRequest->ReplaceRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else if (valueLength != 0) {

            //
            // add a single, unterminated header string to the request headers.
            // Since these headers came from the app, we don't trust it to get
            // the header termination right (number & type of line terminators)
            // so we add it ourselves
            //

            error = pRequest->AddRequestHeader(
                                header,
                                nameLength,
                                value,
                                valueLength,
                                dwModifiers & HTTP_ADDREQ_INDEX_MASK,
                                dwModifiers & HTTP_ADDREQ_FLAGS_MASK
                                );
        } else {

            //
            // BUGBUG - we are adding headers, but the header-value is not
            //          present. This is a somewhat tricky situation because we
            //          we may have already added some headers, resulting in
            //          the app not really knowing which headers were good and
            //          which failed; additionally, one or more of the headers
            //          may have been added, increasing the apps confusion. The
            //          best way to handle this (if necessary) is to check the
            //          header name/value pairs w.r.t. the dwModifiers flags.
            //          HOWEVER, even then we can get into a state down here
            //          where we add a couple of headers, then fail...
            //

            error = ERROR_INVALID_PARAMETER;
        }
    } while (error == ERROR_SUCCESS);

quit:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cookie.cxx ===
//---------------------------------------------------------------------------
//
// COOKIE.CXX
//
//     Cookie Jar
//
//     This file implements cookies as defined by Navigator 4 behavior and the
//     specification at http://www.netscape.com/newsref/std/cookie_spec.html.
//     If Navigator 4 and the specification are not in agreement, we try to
//     match the Navigator 4 behavior.
//
//     The following describes some interesting aspects of cookie behavior.
//
// SYNTAX
//
//    Syntax for cookie is
//
//          [[name]=] value [; options]
//
//    The name is everything before "=" with leading and  trailing whitespace
//    removed.  The value is everything after "=" and before ";" with leading
//    and trailing whitespace removed.  The name and value can contain spaces,
//    quotes or any other character except ";" and "=".  The name and equal
//    sign are optional.
//
//    Example:  =foo  ->  name: <blank> value: foo
//              foo   ->  name: <blank> value: foo
//              foo=  ->  name: foo     value: <blank>
//              ;     ->  name: <blank> value: <blank>
//
// ORDER
//
//    Cookies with a more specific path are sent before cookies with
//    a less specific path mapping.  The domain does not contibute
//    to the ordering of cookies.
//
//    If the path length of two cookies are equal, then the cookies
//    are ordered by time of creation.  Navigator maintains this
//    ordering across domain and path boundaries.  IE maintains this
//    ordering for a specific domain and path. It is difficult to match
//    the Navigator behavior and there are no known bugs because of
//    this difference.
//
// MATCHING
//
//    Path matches are done at the character level.  Any
//    directory structure in the path is ignored.
//
//    Navigator matches domains at the character level and ignores
//    the structure of the domain name.
//
//    Previous versions of IE tossed the leading "." on a domain name.
//    With out this information, character by character compares are
//    can produce incorrect results.  For backwards compatibilty with
//    old cookie we continue to match on a component by component basis.
//
//    Some examples of the difference are:
//
//       Cookie domain   Document domain  Navigator match  IE match
//       .foo.com        foo.com          no               yes
//       bar.x.com       foobar.x.com     yes              no
//
// ACCEPTING COOKIES
//
//    A cookie is rejected if the path specified in the set cookie
//    header is not a prefix of document's path.
//
//    Navigator rejects a cookie if the domain specified in the
//    set cookie header does not contain at least two periods
//    or the domain is not a suffix of the document's domain.
//    The suffix match is done on a character by character basis.
//
//    Navigator ignores all the stuff in the specification about
//    three period matching and the seven special top level domains.
//
//    IE rejects a cookie if the domain specified by the cookie
//    header does not contain at least one embedded period or the
//    domain is not a suffix of the documents domain.
//
//    Cookies are accepted if the path specified in the set cookie
//    header is a prefix of the document's path and the domain
//    specified in the set cookie header.
//
//    The difference in behavior is a result of the matching rules
//    described in the previous section.
//
//---------------------------------------------------------------------------

#include <wininetp.h>
#include "httpp.h"

#include "cookiepolicy.h"
#include "cookieprompt.h"


extern DWORD ConfirmCookie(HWND hwnd, HTTP_REQUEST_HANDLE_OBJECT *lpRequest, DWORD dwFlags, LPVOID *lppvData, LPDWORD pdwStopWarning);

#define CCH_COOKIE_MAX  (5 * 1024)

CRITICAL_SECTION s_csCookieJar;

static class CCookieJar *s_pJar;
static char s_achEmpty[] = "";
static char s_cCacheModify;
static const char s_achCookieScheme[] = "Cookie:";
static DWORD s_dwCacheVersion;
static BOOL s_fFirstTime = TRUE;

// Registry path for prompt-history
static const char  regpathPromptHistory[] = INTERNET_SETTINGS_KEY "\\P3P\\History";

// Prompt history-- persists user decisions about cookies
CCookiePromptHistory cookieUIhistory(regpathPromptHistory);

// Hard-coded list of special domains. If any of these are present between the
// second-to-last and last dot we will require 2 embedded dots.
// The domain strings are reversed to make the compares easier

static const char *s_pachSpecialRestrictedDomains[] =
    {"MOC", "UDE", "TEN", "GRO", "VOG", "LIM", "TNI" };

static const char s_chSpecialAllowedDomains[] = "vt.";  // domains ending with ".tv" always only need one dot

/* Non-scriptable cookies */
#define COOKIE_NONSCRIPTABLE    0x00002000

const char gcszNoScriptField[] = "httponly";

#if INET_DEBUG
DWORD s_dwThreadID;
#endif

// values returned from cookie UI
#define COOKIE_DONT_ALLOW   1
#define COOKIE_ALLOW        2
#define COOKIE_ALLOW_ALL    4
#define COOKIE_DONT_ALLOW_ALL 8

// Function declaration
BOOL EvaluateCookiePolicy(const char *pszURL, BOOL f3rdParty, BOOL fRestricted,
                          P3PCookieState *pState,
                          const char *pszHostName=NULL);

DWORD getImpliedCookieFlags(P3PCookieState *pState);

DWORD   GetCookieMainSwitch(DWORD dwZone);
DWORD   GetCookieMainSwitch(LPCSTR pszURL);

#define     IsLegacyCookie(pc)  ((pc->_dwFlags & INTERNET_COOKIE_IE6) == 0)

//---------------------------------------------------------------------------
//
// CACHE_ENTRY_INFO_BUFFER
//
//---------------------------------------------------------------------------

class CACHE_ENTRY_INFO_BUFFER : public INTERNET_CACHE_ENTRY_INFO
{
    BYTE _ab[5 * 1024];
};

//---------------------------------------------------------------------------
//
// CCookieCriticalSection
//
// Enter / Exit critical section.
//
//---------------------------------------------------------------------------

class CCookieCriticalSection
{
private:
    int Dummy; // Variable needed to force compiler to generate code for const/dest.
public:
    CCookieCriticalSection()
        {
            EnterCriticalSection(&s_csCookieJar);
            #if INET_DEBUG
                s_dwThreadID = GetCurrentThreadId();
            #endif
        }
    ~CCookieCriticalSection()
        {
            #if INET_DEBUG
                s_dwThreadID = 0;
            #endif
            LeaveCriticalSection(&s_csCookieJar);
        }
};

#define ASSERT_CRITSEC() INET_ASSERT(GetCurrentThreadId() == s_dwThreadID)

//---------------------------------------------------------------------------
//
// CCookieBase
//
// Provides operator new which allocates extra memory
// after object and initializes the memory to zero.
//
//---------------------------------------------------------------------------

class CCookieBase
{
public:

    void * operator new(size_t cb, size_t cbExtra);
    void operator delete(void *pv);
};

//---------------------------------------------------------------------------
//
// CCookie
//
// Holds a single cookie value.
//
//---------------------------------------------------------------------------


class CCookie : public CCookieBase
{
public:

    ~CCookie();
    static CCookie *Construct(const char *pchName);

    BOOL            SetValue(const char *pchValue);
    BOOL            WriteCacheFile(HANDLE hFile, char *pchRDomain, char *pchPath);
    BOOL            CanSend(FILETIME *pftCurrent, BOOL fSecure);
    BOOL            IsPersistent() { return (_dwFlags & COOKIE_SESSION) == 0; }
    BOOL            IsRestricted() { return (_dwFlags & COOKIE_RESTRICT)!= 0; }
    BOOL            IsLegacy()     { return (_dwFlags & INTERNET_COOKIE_IS_LEGACY) != 0; }

    BOOL            PurgePersistent(void *);
    BOOL            PurgeSession(void *);
    BOOL            PurgeAll(void *);
    BOOL            PurgeByName(void *);
    BOOL            PurgeThis(void *);
    BOOL            PurgeExpired(void *);

    FILETIME        _ftExpire;
    FILETIME        _ftLastModified;
    DWORD           _dwFlags;
    CCookie *       _pCookieNext;
    char *          _pchName;
    char *          _pchValue;
    DWORD           _dwPromptMask;      // never persisted, only used in session

};

//---------------------------------------------------------------------------
//
// CCookieLocation
//
// Holds all cookies for a given domain and path.
//
//---------------------------------------------------------------------------

class CCookieLocation : public CCookieBase
{
public:

    ~CCookieLocation();
    static CCookieLocation *Construct(const char *pchRDomain, const char *pchPath);

    CCookie *       GetCookie(const char *pchName, BOOL fCreate);
    BOOL            WriteCacheFile();
    BOOL            ReadCacheFile();
    BOOL            ReadCacheFileIfNeeded();
    BOOL            Purge(BOOL (CCookie::*)(void *), void *);
    BOOL            Purge(FILETIME *pftCurrent, BOOL fSession);
    BOOL            IsMatch(char *pchRDomain, char *pchPath);
    char *          GetCacheURL();

    FILETIME        _ftCacheFileLastModified;
    CCookie *       _pCookieKids;
    CCookieLocation*_pLocationNext;
    char *          _pchRDomain;
    char *          _pchPath;
    int             _cchPath;
    BYTE            _fCacheFileExists;
    BYTE            _fReadFromCacheFileNeeded;
};


//---------------------------------------------------------------------------
//
// CCookieJar
//
// Maintains fixed size hash table of cookie location objects.
//
//---------------------------------------------------------------------------
enum COOKIE_RESULT
{
    COOKIE_FAIL     = 0,
    COOKIE_SUCCESS  = 1,
    COOKIE_DISALLOW = 2,
    COOKIE_PENDING  = 3
};

class CCookieJar : public CCookieBase
{
public:

    static CCookieJar * Construct();
    ~CCookieJar();

    struct CookieInfo {

        const char *pchURL;
        char *pchRDomain;
        char *pchPath;
        char *pchName;
        char *pchValue;
        DWORD dwFlags;
        FILETIME ftExpire;

        P3PCookieState *pP3PState;
    };

    DWORD
    CheckCookiePolicy(
        HTTP_REQUEST_HANDLE_OBJECT *pRequest,
        CookieInfo *pInfo,
        DWORD dwOperation
        );

    void              EnforceCookieLimits(CCookieLocation *pLocation, char *pchName, BOOL *pfWriteCacheFileNeeded);
    DWORD             SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader,
                                DWORD &dwFlags, P3PCookieState *pState, LPDWORD pdwAction);
    void              Purge(FILETIME *pftCurrent, BOOL fSession);
    BOOL              SyncWithCache();
    BOOL              SyncWithCacheIfNeeded();
    void              CacheFilesModified();
    CCookieLocation** GetBucket(const char *pchRDomain);
    CCookieLocation * GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate);

    CCookieLocation * _apLocation[128];
};

//---------------------------------------------------------------------------
//
// Track cache modificaitons.
//
//---------------------------------------------------------------------------

inline void
MarkCacheModified()
{
    IncrementUrlCacheHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &s_dwCacheVersion);
}

inline BOOL
IsCacheModified()
{
    DWORD dwCacheVersion;

    if (s_fFirstTime)
    {
        s_fFirstTime = FALSE;
        GetUrlCacheHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &s_dwCacheVersion);
        return TRUE;
    }
    else
    {
        dwCacheVersion = s_dwCacheVersion;
        GetUrlCacheHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &s_dwCacheVersion);

        return dwCacheVersion != s_dwCacheVersion;
    }
}

//---------------------------------------------------------------------------
//
// String utilities
//
//---------------------------------------------------------------------------

static BOOL
IsZero(FILETIME *pft)
{
    return pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0;
}

static char *
StrnDup(const char *pch, int cch)
{
    char *pchAlloc = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cch + 1);
    if (!pchAlloc)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memcpy(pchAlloc, pch, cch);
    pchAlloc[cch] = 0;

    return pchAlloc;
}

static BOOL
IsPathMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0;
}

static BOOL
IsDomainMatch(const char *pchPrefix, const char *pchStr)
{
    while (*pchPrefix == *pchStr && *pchStr)
    {
        pchPrefix += 1;
        pchStr += 1;
    }

    return *pchPrefix == 0 && (*pchStr == 0 || *pchStr == '.');
}

static BOOL
IsPathLegal(const char *pchHeader, const char *pchDocument)
{
    return TRUE;

    /*

    We attempted to implement the specification here.
    It looks like Navigator does not reject cookies
    based on the path attribute.  We now consider
    all path attributes to be legal.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    if (*pchDocument == 0)
    {
        while (*pchHeader && *pchHeader != '/' && *pchHeader != '\\')
        {
            pchHeader += 1;
        }
    }
    return *pchHeader == 0;
    */
}

//
// DarrenMi: No longer need IsVerySpecialDomain


extern PTSTR GlobalSpecialDomains;
extern PTSTR *GlobalSDOffsets;

static BOOL
IsVerySpecialDomain(const char *pch, int nTopLevel, int nSecond)
{
    if (!GlobalSpecialDomains)
    {
        HKEY hk;
        if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0"),
                                        0,
                                        KEY_READ,
                                        &hk))
        {
            DWORD dwType, dwSize;

            if ((ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, NULL, &dwSize))
                && (REG_SZ==dwType))
            {
                GlobalSpecialDomains = new TCHAR[dwSize];
                if (GlobalSpecialDomains
                    && (ERROR_SUCCESS==RegQueryValueEx(hk, "SpecialDomains", NULL, &dwType, (LPBYTE)GlobalSpecialDomains, &dwSize)))
                {

                    // We're going to scan a string stored in the registry to gather the domains we should
                    // allow. Format:
                    // [domain] [domain] [domain]
                    // The delimiter is a space character.

                    PTSTR psz = GlobalSpecialDomains;
                    DWORD dwDomains = 0;
                    BOOL fWord = FALSE;
                    while (*psz)
                    {
                        if (*psz==TEXT(' '))
                        {
                            if (fWord)
                            {
                                fWord = FALSE;
                                dwDomains++;
                            }
                        }
                        else
                        {
                            fWord = TRUE;
                        }
                        psz++;
                    }
                    if (fWord)
                    {
                        dwDomains++;
                    }
                    GlobalSDOffsets = (PTSTR*)new PTSTR[dwDomains+1];
                    if (GlobalSDOffsets)
                    {
                        psz = GlobalSpecialDomains;
                        for (DWORD dw = 0; dw < dwDomains; dw++)
                        {
                            INET_ASSERT(*psz);

                            while (*psz==TEXT(' '))
                                psz++;

                            INET_ASSERT(*psz);
                            GlobalSDOffsets[dw] = psz;

                            while (*psz && *psz!=TEXT(' '))
                            {
                                psz++;
                            }
                            if (*psz)
                            {
                                *psz = TEXT('\0');
                                psz++;
                            }
                        }
                        GlobalSDOffsets[dwDomains] = NULL;
                    }
                }
            }
            RegCloseKey(hk);
        }
    }

    // WARNING: The following lines of code make it possible for cookies to be set for *.uk,
    // (for example) if "ku." is in the registry
    BOOL fRet = FALSE;
    if (GlobalSDOffsets)
    {
        for (DWORD i = 0; GlobalSDOffsets[i]; i++)
        {
            if (!StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel)
                || !StrCmpNI(pch, GlobalSDOffsets[i], nTopLevel+nSecond+1))
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}


static BOOL
IsSpecialDomain(const char *pch, int nCount)
{
    for (int i = 0 ; i < ARRAY_ELEMENTS(s_pachSpecialRestrictedDomains) ; i++ )
    {
        if (StrCmpNIC(pch, s_pachSpecialRestrictedDomains[i], nCount) == 0)
            return TRUE;
    }

    return FALSE;
}

static BOOL
IsDomainLegal(const char *pchHeader, const char *pchDocument)
{
    const char *pchCurrent = pchHeader;
    int nSegment = 0;
    int dwCharCount = 0;
    int rgcch[2] = { 0, 0 };  // How many characters between dots

    // Must have at least one period in name.
    // and contains nothing but '.' is illegal

    int dwSegmentLength = 0;
    const char * pchSecondPart = NULL; // for a domain string such as
    BOOL fIPAddress = TRUE;
    for (; *pchCurrent; pchCurrent++)
    {
        if (isalpha(*pchCurrent))
        {
            fIPAddress = FALSE;
        }

        if (*pchCurrent == '.')
        {
            if (nSegment < 2)
            {
                // Remember how many characters we have between the last two dots
                // For example if domain header is .microsoft.com
                // rgcch[0] should be 3 for "com"
                // rgcch[1] should be 9 for "microsoft"
                rgcch[nSegment] = dwSegmentLength;

                if (nSegment == 1)
                {
                    pchSecondPart = pchCurrent - dwSegmentLength;
                }
            }
            dwSegmentLength = 0;
            nSegment += 1;
        }
        else
        {
            dwSegmentLength++;
        }
        dwCharCount++;
    }

    // The code below depends on the leading dot being removed from the domain header.
    // The parse code does that, but an assert here just in case something changes in the
    // parse code.
    INET_ASSERT(*(pchCurrent - 1) != '.');

    if (fIPAddress)
    {
        // If we're given an IP address, we must match the entire IP address, not just a part
        while (*pchHeader == *pchDocument && *pchDocument)
        {
            pchHeader++;
            pchDocument++;
        }
        return !(*pchHeader || *pchDocument);
    }

    // Remember the count of the characters between the begining of the header and
    // the first dot. So for domain=abc.com this will set rgch[1] = 3.
    // Note that this assumes that if domain=.abc.com the leading dot has been stripped
    // out in the parse code. See assert above.
    if (nSegment < 2 )
    {
        rgcch[nSegment] = dwSegmentLength;
        if (nSegment==1)
        {
            pchSecondPart = pchCurrent - dwSegmentLength;
        }
    }

    // If the domain name is of the form abc.xx.yy where the number of characters between the last two dots is less than
    // 2 we require a minimum of two embedded dots. This is so you are not allowed to set cookies readable by all of .co.nz for
    // example. However this rule is not sufficient and we special case things like .edu.nz as well.

    // darrenmi:  new semantics:  if segment 0 is less than or equal to 2, you need 2 embedded dots if segment 1 is a
    // "well known" string including edu, com, etc. and co.

    // fschwiet:  An exception is now being made so that domains of the form "??.tv" are allowed.

    int cEmbeddedDotsNeeded = 1;
    BOOL fIsVerySpecialDomain = FALSE;

    if (rgcch[0] <= 2 && rgcch[1] <= 2)
    {
        fIsVerySpecialDomain = IsVerySpecialDomain(pchHeader, rgcch[0], rgcch[1]);
    }


    if(!fIsVerySpecialDomain
       && rgcch[0] <= 2
       && 0 != StrCmpNIC( pchHeader, s_chSpecialAllowedDomains, sizeof( s_chSpecialAllowedDomains) - 1)
       && (rgcch[1] <= 2
           || IsSpecialDomain(pchSecondPart, rgcch[1])))
    {
        cEmbeddedDotsNeeded = 2;
    }

    if (nSegment < cEmbeddedDotsNeeded || dwCharCount == nSegment)
        return FALSE;

    // Mismatch between header and document not allowed.
    // Must match full components of domain name.

    while (*pchHeader == *pchDocument && *pchDocument)
    {
        pchHeader += 1;
        pchDocument += 1;
    }

    return *pchHeader == 0 && (*pchDocument == 0 || *pchDocument == '.' );
}


void
LowerCaseString(char *pch)
{
    for (; *pch; pch++)
    {
        if (*pch >= 'A' && *pch <= 'Z')
            *pch += 'a' - 'A';
    }
}

static void
ReverseString(char *pchFront)
{
    char *pchBack;
    char  ch;
    int   cch;

    cch = strlen(pchFront);

    pchBack = pchFront + cch - 1;

    cch = cch / 2;
    while (--cch >= 0)
    {
        ch = tolower(*pchFront);
        *pchFront = tolower(*pchBack);
        *pchBack = ch;

        pchFront += 1;
        pchBack -= 1;
    }
}

static BOOL
PathAndRDomainFromURL(const char *pchURL, char **ppchRDomain, char **ppchPath, BOOL *pfSecure, BOOL bStrip = TRUE)
{
    char *pchDomainBuf;
    char *pchRDomain = NULL;
    char *pchPathBuf;
    char *pchPath = NULL;
    char *pchExtra;
    DWORD cchDomain;
    DWORD cchPath;
    DWORD cchExtra;
    BOOL  fSuccess = FALSE;
    DWORD dwError;
    INTERNET_SCHEME ustScheme;
    char *pchURLCopy = NULL;

    pchURLCopy = NewString(pchURL);
    if (!pchURLCopy)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    dwError = CrackUrl((char *)pchURLCopy,
             0,
             FALSE,
             &ustScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Lenth
             &pchDomainBuf,
             &cchDomain,
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             &pchPathBuf,
             &cchPath,
             &pchExtra,     //  Extra
             &cchExtra,     //  Extra Length
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        goto Cleanup;
    }

    if ( ustScheme != INTERNET_SCHEME_HTTP &&
         ustScheme != INTERNET_SCHEME_HTTPS &&
         ustScheme != INTERNET_SCHEME_FILE)
    {
        //
        // known scheme should be supported
        // e.g. 3rd party pluggable protocol should be able to
        // call cookie api to setup cookies...
        //

        //a-thkesa.  Allowing all of the pluggable protocols to setcookie creates security concerns.
        //So we only allow this "hcp" to qualify to setup cookie apart from 'file', Http, Https.
        //WinSE BUG: 24011 . In The windows help system they are setting cookie on a HCP protocol!.
        //we don't expect any protocol other then HTTP, HTTPS ,and File setting cookie here. But
        //we also have to allow the pluggable protocols to set cookie. Since allowing that causes security
        //problem, we only allow HCP which is a pluggable protocol used in windows Help and Support.
        //In future, we have to make sure to allow all of the pluggable protocol to set cookie, or 
        //document only http, https and file can set cookies!
        //pluggable protocols returns INTERNET_SCHEME_UNKNOWN.
        //If so check if it returns INTERNET_SCHEME_UNKNOWN and check the protocols is a HCP protocol. If it is HCP
        // then do not set error.
        if( INTERNET_SCHEME_UNKNOWN == ustScheme ) // HCP returns INTERNET_SCHEME_UNKNOWN
        {
          char szProtocolU[]= "HCP:"; 
          char szProtocolL[]= "hcp:";
          short ilen = 0;
          while(4 > ilen) // check only the first four char.
          {
            if(*(pchURLCopy+ilen) != *(szProtocolU+ilen) && 
            *(pchURLCopy+ilen) != *(szProtocolL+ilen) )
             {
              SetLastError(ERROR_INVALID_PARAMETER);
              goto Cleanup;
             }
            ilen++;
          }
        }
        else
        {
         SetLastError(ERROR_INVALID_PARAMETER);
         goto Cleanup;
        }
    }

    *pfSecure = ustScheme == INTERNET_SCHEME_HTTPS;

    if (ustScheme == INTERNET_SCHEME_FILE)
    {
        pchDomainBuf = "~~local~~";
        cchDomain = sizeof("~~local~~") - 1;
    }
    else
    {
        // SECURITY:  It's possible for us to navigate to a carefully
        //            constructed URL such as http://server%3F.microsoft.com.
        //            This results in a cracked hostname of server?.microsoft.com.
        //            Given the current architecture, it would probably be best to
        //            make CrackUrl smarter.  However, the minimal fix below prevents
        //            the x-domain security violation without breaking escaped cases
        //            that work today that customers may expect to be allowed.
        DWORD n;
        for (n = 0; n < cchDomain; n++)
        {
            // RFC 952 as amended by RFC 1123: the only valid chars are
            // a-z, A-Z, 0-9, '-', and '.'.  The last two are delimiters
            // which cannot start or end the name, but this detail doesn't
            // matter for the security fix.
            if (!((pchDomainBuf[n] >= 'a' && pchDomainBuf[n] <= 'z') ||
                  (pchDomainBuf[n] >= 'A' && pchDomainBuf[n] <= 'Z') ||
                  (pchDomainBuf[n] >= '0' && pchDomainBuf[n] <= '9') ||
                  (pchDomainBuf[n] == '-') ||
                  (pchDomainBuf[n] == '.')))
            {
                // Since we're incorrectly cracking the URL, don't worry
                // about fixing up the path.
                fSuccess = FALSE;
                goto Cleanup;
            }
        }
    }

    if(bStrip)
    {
        while (cchPath > 0)
        {
            if (pchPathBuf[cchPath - 1] == '/' || pchPathBuf[cchPath - 1] == '\\')
            {
                break;
            }
        cchPath -= 1;
        }
    }

    pchRDomain = StrnDup(pchDomainBuf, cchDomain);
    if (!pchRDomain)
        goto Cleanup;

    LowerCaseString(pchRDomain);
    ReverseString(pchRDomain);

    pchPath = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchPath + 2);
    if (!pchPath)
        goto Cleanup;

    if (*pchPathBuf != '/')
    {
        *pchPath = '/';
        memcpy(pchPath + 1, pchPathBuf, cchPath);
        pchPath[cchPath + 1] = TEXT('\0');
    }
    else
    {
        memcpy(pchPath, pchPathBuf, cchPath);
        pchPath[cchPath] = TEXT('\0');
    }

    fSuccess = TRUE;

Cleanup:
    if (!fSuccess)
    {
        if (pchRDomain)
            FREE_MEMORY(pchRDomain);
        if (pchPath)
            FREE_MEMORY(pchPath);
    }
    else
    {
        *ppchRDomain = pchRDomain;
        *ppchPath = pchPath;
    }

    if (pchURLCopy)
        FREE_MEMORY(pchURLCopy);

    return fSuccess;
}

//---------------------------------------------------------------------------
//
// CCookieBase implementation
//
//---------------------------------------------------------------------------

void *
CCookieBase::operator new(size_t cb, size_t cbExtra)
{
    void *pv = ALLOCATE_MEMORY(LMEM_FIXED, cb + cbExtra);
    if (!pv)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    memset(pv, 0, cb);
    return pv;
}

inline void
CCookieBase::operator delete(void *pv)
{
    FREE_MEMORY(pv);
}

//---------------------------------------------------------------------------
//
// CCookie implementation
//
//---------------------------------------------------------------------------

CCookie *
CCookie::Construct(const char *pchName)
{
    CCookie *pCookie = new(strlen(pchName) + 1) CCookie();
    if (!pCookie)
        return NULL;

    pCookie->_pchName = (char *)(pCookie + 1);
    pCookie->_pchValue = s_achEmpty;
    strcpy(pCookie->_pchName, pchName);

    pCookie->_dwFlags = COOKIE_SESSION;
    pCookie->_dwPromptMask = 0;

    return pCookie;
}

CCookie::~CCookie()
{
    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);
}

BOOL
CCookie::SetValue(const char *pchValue)
{
    int   cchValue;

    if (_pchValue != s_achEmpty)
        FREE_MEMORY(_pchValue);

    if (!pchValue || !*pchValue)
    {
        _pchValue = s_achEmpty;
    }
    else
    {
        cchValue = strlen(pchValue) + 1;
        _pchValue = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchValue);
        if (!_pchValue)
        {
            _pchValue = s_achEmpty;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        memcpy(_pchValue, pchValue, cchValue);
    }
    return TRUE;
}

BOOL
CCookie::CanSend(FILETIME *pftCurrent, BOOL fSecure)
{
    return (fSecure || !(_dwFlags & COOKIE_SECURE)) &&
            (CompareFileTime(_ftExpire, *pftCurrent) >= 0);
}

BOOL CCookie::PurgePersistent(void *)
{
    return IsPersistent();
}

BOOL CCookie::PurgeAll(void *)
{
    return TRUE;
}

BOOL CCookie::PurgeByName(void *pvName)
{
    return strcmp((char *)pvName, _pchName) == 0;
}

BOOL CCookie::PurgeThis(void *pvThis)
{
    return this == (CCookie *)pvThis;
}

BOOL CCookie::PurgeExpired(void *pvCurrent)
{
    return CompareFileTime(_ftExpire, *(FILETIME *)pvCurrent) < 0;
}

static BOOL
WriteString(HANDLE hFile, const char *pch)
{
    DWORD cb;
    return pch && *pch ? WriteFile(hFile, pch, strlen(pch), &cb, NULL) : TRUE;
}

static BOOL
WriteStringLF(HANDLE hFile, const char *pch)
{
    DWORD cb;

    if (!WriteString(hFile, pch)) return FALSE;
    return WriteFile(hFile, "\n", 1, &cb, NULL);
}

BOOL
CCookie::WriteCacheFile(HANDLE hFile, char *pchRDomain, char *pchPath)
{
    BOOL fSuccess = FALSE;
    char achBuf[128];

    ReverseString(pchRDomain);

    if (!WriteStringLF(hFile, _pchName)) goto Cleanup;
    if (!WriteStringLF(hFile, _pchValue)) goto Cleanup;
    if (!WriteString(hFile, pchRDomain)) goto Cleanup;
    if (!WriteStringLF(hFile, pchPath)) goto Cleanup;

    wsprintf(achBuf, "%u\n%u\n%u\n%u\n%u\n*\n",
            _dwFlags,
            _ftExpire.dwLowDateTime,
            _ftExpire.dwHighDateTime,
            _ftLastModified.dwLowDateTime,
            _ftLastModified.dwHighDateTime);

    if (!WriteString(hFile, achBuf)) goto Cleanup;

    fSuccess = TRUE;

Cleanup:
    ReverseString(pchRDomain);
    return fSuccess;
}

//---------------------------------------------------------------------------
//
// CCookieLocation implementation
//
//---------------------------------------------------------------------------

CCookieLocation *
CCookieLocation::Construct(const char *pchRDomain, const char *pchPath)
{
    int cchPath = strlen(pchPath);

    CCookieLocation *pLocation = new(strlen(pchRDomain) + cchPath + 2) CCookieLocation();
    if (!pLocation)
        return NULL;

    pLocation->_cchPath = cchPath;
    pLocation->_pchPath = (char *)(pLocation + 1);
    pLocation->_pchRDomain = pLocation->_pchPath + cchPath + 1;

    strcpy(pLocation->_pchRDomain, pchRDomain);
    strcpy(pLocation->_pchPath, pchPath);

    return pLocation;
}

CCookieLocation::~CCookieLocation()
{
    Purge(CCookie::PurgeAll, NULL);
}

CCookie *
CCookieLocation::GetCookie(const char *pchName, BOOL fCreate)
{
    CCookie *pCookie;

    CCookie **ppCookie = &_pCookieKids;

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (strcmp(pchName, pCookie->_pchName) == 0)
            return pCookie;
        ppCookie = &pCookie->_pCookieNext;
    }

    if (!fCreate)
        return NULL;

    pCookie = CCookie::Construct(pchName);
    if (!pCookie)
        return NULL;

    //
    // Insert cookie at end of list to match Navigator's behavior.
    //

    pCookie->_pCookieNext = NULL;
    *ppCookie = pCookie;

    return pCookie;
}

BOOL
CCookieLocation::Purge(BOOL (CCookie::*pfnPurge)(void *), void *pv)
{
    CCookie **ppCookie = &_pCookieKids;
    CCookie *pCookie;
    BOOL     fPersistentDeleted = FALSE;

    while ((pCookie = *ppCookie) != NULL)
    {
        if ((pCookie->*pfnPurge)(pv))
        {
            *ppCookie = pCookie->_pCookieNext;
            fPersistentDeleted |= pCookie->IsPersistent();
            delete pCookie;
        }
        else
        {
            ppCookie = &pCookie->_pCookieNext;
        }
    }

    return fPersistentDeleted;
}

BOOL
CCookieLocation::Purge(FILETIME *pftCurrent, BOOL fSession)
{
    if (!_fCacheFileExists)
    {
        // If cache file is gone, then delete all persistent
        // cookies. If there's no cache file, then it's certainly
        // the case that we do not need to read the cache file.

        Purge(CCookie::PurgePersistent, NULL);
        _fReadFromCacheFileNeeded = FALSE;
    }

    // This is a good time to check for expired persistent cookies.

    if (!_fReadFromCacheFileNeeded && Purge(CCookie::PurgeExpired, pftCurrent))
    {
        WriteCacheFile();
    }

    if (fSession)
    {
        // If we are purging because a session ended, nuke
        // everything in sight.  If we deleted a persistent
        // cookie, note that we need to read the cache file
        // on next access.

        _fReadFromCacheFileNeeded |= Purge(CCookie::PurgeAll, NULL);
    }

    return !_fReadFromCacheFileNeeded && _pCookieKids == NULL;
}

char *
CCookieLocation::GetCacheURL()
{
    char *pchURL;
    char *pch;
    int cchScheme = sizeof(s_achCookieScheme) - 1;

    int cchUser = vdwCurrentUserLen;
    int cchAt = 1;
    int cchDomain = strlen(_pchRDomain);
    int cchPath = strlen(_pchPath);

    pchURL = (char *)ALLOCATE_MEMORY(LMEM_FIXED, cchScheme + cchUser + cchAt + cchDomain + cchPath + 1);
    if (!pchURL)
        return NULL;

    pch = pchURL;

    memcpy(pch, s_achCookieScheme, cchScheme);
    pch += cchScheme;

    memcpy(pch, vszCurrentUser, cchUser);
    pch += cchUser;

    memcpy(pch, "@", cchAt);
    pch += cchAt;

    ReverseString(_pchRDomain);
    memcpy(pch, _pchRDomain, cchDomain);
    ReverseString(_pchRDomain);
    pch += cchDomain;

    strcpy(pch, _pchPath);

    return pchURL;
}

BOOL
CCookieLocation::WriteCacheFile()
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    char        achFile[MAX_PATH];
    char *      pchURL = NULL;
    BOOL        fSuccess = FALSE;
    CCookie *   pCookie;
    FILETIME    ftLastExpire =  { 0, 0 };

    achFile[0] = 0;

    GetCurrentGmtTime(&_ftCacheFileLastModified);

    //
    // Determine the latest expiry time and if we have something to write.
    //

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (pCookie->IsPersistent() && CompareFileTime(pCookie->_ftExpire, ftLastExpire) > 0)
        {
            ftLastExpire = pCookie->_ftExpire;
        }
    }

    pchURL = GetCacheURL();
    if (!pchURL)
        goto Cleanup;

    if (CompareFileTime(ftLastExpire, _ftCacheFileLastModified) < 0)
    {
        fSuccess = TRUE;
        DeleteUrlCacheEntry(pchURL);
        _fCacheFileExists = FALSE;
        goto Cleanup;
    }

    _fCacheFileExists = TRUE;

    if (!CreateUrlCacheEntry(pchURL,
            0,              // Estimated size
            "txt",          // File extension
            achFile,
            0))
        goto Cleanup;

    hFile = CreateFile(
            achFile,
            GENERIC_WRITE,
            0, // no sharing.
            NULL,
            TRUNCATE_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL );
    if (hFile == INVALID_HANDLE_VALUE)
        goto Cleanup;

    for (pCookie = _pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
    {
        if (pCookie->IsPersistent() && CompareFileTime(pCookie->_ftExpire, _ftCacheFileLastModified) >= 0)
        {
            if (!pCookie->WriteCacheFile(hFile, _pchRDomain, _pchPath))
                goto Cleanup;
        }
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    if (!CommitUrlCacheEntry(pchURL,
            achFile,
            ftLastExpire,
            _ftCacheFileLastModified,
            NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY,
            NULL,
            0,
            NULL,
            0 ))
        goto Cleanup;

    MarkCacheModified();

    fSuccess = TRUE;

Cleanup:

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (!fSuccess)
    {
        if (achFile[0])
            DeleteFile(achFile);

        if (pchURL)
            DeleteUrlCacheEntry(pchURL);
    }

    if (pchURL)
        FREE_MEMORY(pchURL);

    return fSuccess;
}

static char *
ScanString(char *pch, char **pchStr)
{
    *pchStr = pch;

    for (; *pch; *pch++)
    {
        if (*pch == '\n')
        {
            *pch = 0;
            pch += 1;
            break;
        }
    }

    return pch;
}

static char *
ScanNumber(char *pch, DWORD *pdw)
{
    DWORD dw = 0;
    char *pchJunk;

    for (; *pch >= '0' && *pch <= '9'; *pch++)
    {
        dw = (dw * 10) + *pch - '0';
    }

    *pdw = dw;

    return ScanString(pch, &pchJunk);
}

BOOL
CCookieLocation::ReadCacheFile()
{
    char *      pchURL = NULL;
    char *      pch;
    DWORD       cbCEI;
    HANDLE      hCacheStream = NULL;
    char *      pchBuffer = NULL;
    CCookie *   pCookie;
    CACHE_ENTRY_INFO_BUFFER *pcei = new CACHE_ENTRY_INFO_BUFFER;

    if (pcei == NULL)
        goto Cleanup;

    _fReadFromCacheFileNeeded = FALSE;

    pchURL = GetCacheURL();
    if (!pchURL)
        goto Cleanup;

    cbCEI = sizeof(*pcei);

    hCacheStream = RetrieveUrlCacheEntryStream(
            pchURL,
            pcei,
            &cbCEI,
            FALSE, // sequential access
            0);

    if (!hCacheStream)
    {
        // If we failed to get the entry, try to nuke it so it does not
        // bother us in the future.

        DeleteUrlCacheEntry(pchURL);
        goto Cleanup;
    }

    // Old cache files to not have last modified time set.
    // Bump the time up so that we can use file times to determine
    // if we need to resync a file.

    if (IsZero(&(pcei->LastModifiedTime)))
    {
        pcei->LastModifiedTime.dwLowDateTime = 1;
    }

    _ftCacheFileLastModified = pcei->LastModifiedTime;

    // Read cache file into a null terminated buffer.

    pchBuffer = (char *)ALLOCATE_MEMORY(LMEM_FIXED, pcei->dwSizeLow + 1 * sizeof(char));
    if (!pchBuffer)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    if (!ReadUrlCacheEntryStream(hCacheStream, 0, pchBuffer, &pcei->dwSizeLow, 0))
        goto Cleanup;

    pchBuffer[pcei->dwSizeLow] = 0;

    // Blow away all existing persistent cookies.

    Purge(CCookie::PurgePersistent, NULL);

    // Parse cookies from the buffer;

    for (pch = pchBuffer; *pch; )
    {
        char *pchName;
        char *pchValue;
        char *pchLocation;
        char *pchStar;
        DWORD dwFlags;
        FILETIME ftExpire;
        FILETIME ftLast;

        pch = ScanString(pch, &pchName);
        pch = ScanString(pch, &pchValue);
        pch = ScanString(pch, &pchLocation);

        pch = ScanNumber(pch, &dwFlags);
        pch = ScanNumber(pch, &ftExpire.dwLowDateTime);
        pch = ScanNumber(pch, &ftExpire.dwHighDateTime);
        pch = ScanNumber(pch, &ftLast.dwLowDateTime);
        pch = ScanNumber(pch, &ftLast.dwHighDateTime);

        pch = ScanString(pch, &pchStar);

        if (strcmp(pchStar, "*"))
        {
            goto Cleanup;
        }

        pCookie = GetCookie(pchName, TRUE);
        if (!pCookie)
            goto Cleanup;

        // Initialize the cookie.

        pCookie->SetValue(pchValue);
        pCookie->_ftExpire = ftExpire;
        pCookie->_ftLastModified = ftLast;
        pCookie->_dwFlags = dwFlags;
    }

Cleanup:
    if (pcei)
        delete pcei;

    if (hCacheStream)
        UnlockUrlCacheEntryStream(hCacheStream, 0);

    if (pchURL)
        FREE_MEMORY(pchURL);

    if (pchBuffer)
        FREE_MEMORY(pchBuffer);

    return TRUE;
}

BOOL
CCookieLocation::IsMatch(char *pchRDomain, char *pchPath)
{
    return IsDomainMatch(_pchRDomain, pchRDomain) &&
        IsPathMatch(_pchPath, pchPath);
}

BOOL
CCookieLocation::ReadCacheFileIfNeeded()
{
    return _fReadFromCacheFileNeeded ? ReadCacheFile() : TRUE;
}


//---------------------------------------------------------------------------
//
// CCookieJar implementation
//
//---------------------------------------------------------------------------


CCookieJar *
CCookieJar::Construct()
{
    CCookieJar *s_pJar = new(0) CCookieJar();
    if (!s_pJar)
        return NULL;

    return s_pJar;
}

CCookieJar::~CCookieJar()
{
    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        CCookieLocation *pLocation = _apLocation[i];
        while (pLocation)
        {
            CCookieLocation *pLocationT = pLocation->_pLocationNext;
            delete pLocation;
            pLocation = pLocationT;
        }
    }
}

CCookieLocation **
CCookieJar::GetBucket(const char *pchRDomain)
{
    int ch;
    int cPeriod = 0;
    unsigned int hash = 0;

    ASSERT_CRITSEC();

    for (; (ch = *pchRDomain) != 0; pchRDomain++)
    {
        if (ch == '.')
        {
            cPeriod += 1;
            if (cPeriod >= 2)
                break;
        }
        hash = (hash * 29) + ch;
    }

    hash = hash % ARRAY_ELEMENTS(_apLocation);

    return &_apLocation[hash];
}

CCookieLocation *
CCookieJar::GetLocation(const char *pchRDomain, const char *pchPath, BOOL fCreate)
{
    ASSERT_CRITSEC();

    int cchPath = strlen(pchPath);
    CCookieLocation *pLocation = NULL;
    CCookieLocation **ppLocation = GetBucket(pchRDomain);

    // To support sending more specific cookies before less specific,
    // we keep list sorted by path length.

    while ((pLocation = *ppLocation) != NULL)
    {
        if (pLocation->_cchPath < cchPath)
            break;

        if (strcmp(pLocation->_pchPath, pchPath) == 0 &&
            strcmp(pLocation->_pchRDomain, pchRDomain) == 0)
            return pLocation;

        ppLocation = &pLocation->_pLocationNext;
    }

    if (!fCreate)
        goto Cleanup;

    pLocation = CCookieLocation::Construct(pchRDomain, pchPath);
    if (!pLocation)
        goto Cleanup;

    pLocation->_pLocationNext = *ppLocation;
    *ppLocation = pLocation;

Cleanup:
    return pLocation;
}

void
CCookieJar::Purge(FILETIME *pftCurrent, BOOL fSession)
{
    ASSERT_CRITSEC();

    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        CCookieLocation **ppLocation = &_apLocation[i];
        CCookieLocation *pLocation;

        while ((pLocation = *ppLocation) != NULL)
        {
            if (pLocation->Purge(pftCurrent, fSession))
            {
                *ppLocation = pLocation->_pLocationNext;
                delete pLocation;
            }
            else
            {
                ppLocation = &pLocation->_pLocationNext;
            }
        }
    }
}

BOOL
CCookieJar::SyncWithCache()
{
    DWORD       dwBufferSize;
    HANDLE      hEnum = NULL;
    int         cchUserNameAt;
    char        achUserNameAt[MAX_PATH + 2];
    FILETIME    ftCurrent;
    char *      pchRDomain;
    char *      pchPath;
    char *      pch;
    CACHE_ENTRY_INFO_BUFFER *pcei;
    CCookieLocation *pLocation;

    ASSERT_CRITSEC();

    pcei = new CACHE_ENTRY_INFO_BUFFER;
    if (pcei == NULL)
        goto Cleanup;

    if (!vdwCurrentUserLen)
        GetWininetUserName();

    strcpy(achUserNameAt, vszCurrentUser);
    strcat(achUserNameAt, "@");
    cchUserNameAt = vdwCurrentUserLen+1;

    dwBufferSize = sizeof(*pcei);
    hEnum = FindFirstUrlCacheEntry(s_achCookieScheme, pcei, &dwBufferSize);

    for (int i = ARRAY_ELEMENTS(_apLocation); --i >= 0; )
    {
        for (pLocation = _apLocation[i];
                pLocation;
                pLocation = pLocation->_pLocationNext)
        {
            pLocation->_fCacheFileExists = FALSE;
        }
    }

    if (hEnum)
    {
        do
        {
            if ( pcei->lpszSourceUrlName &&
                (strnicmp(pcei->lpszSourceUrlName, s_achCookieScheme, sizeof(s_achCookieScheme) - 1 ) == 0) &&
                (strnicmp(pcei->lpszSourceUrlName+sizeof(s_achCookieScheme) - 1,achUserNameAt, cchUserNameAt) == 0))
            {

                // Split domain name from path in buffer.
                // Slide domain name down to make space for null terminator
                // between domain and path.

                pchRDomain = pcei->lpszSourceUrlName+sizeof(s_achCookieScheme) - 1 + cchUserNameAt - 1;

                for (pch = pchRDomain + 1; *pch && *pch != '/'; pch++)
                {
                    pch[-1] = pch[0];
                }
                pch[-1] = 0;

                pchPath = pch;

                ReverseString(pchRDomain);

                pLocation = GetLocation(pchRDomain, pchPath, TRUE);
                if (!pLocation)
                {
                    continue;
                }

                // Old cache files to not have last modified time set.
                // Bump the time up so that we can use file times to determine
                // if we need to resync a file.

                if (IsZero(&pcei->LastModifiedTime))
                {
                    pcei->LastModifiedTime.dwLowDateTime = 1;
                }

                if (CompareFileTime(pLocation->_ftCacheFileLastModified, pcei->LastModifiedTime) < 0)
                {
                    pLocation->_fReadFromCacheFileNeeded = TRUE;
                }

                pLocation->_fCacheFileExists = TRUE;

            }

            dwBufferSize = sizeof(*pcei);

        } while (FindNextUrlCacheEntryA(hEnum, pcei, &dwBufferSize));

        FindCloseUrlCache(hEnum);
    }

    // Now purge everthing we didn't get .

    GetCurrentGmtTime(&ftCurrent);
    Purge(&ftCurrent, FALSE);

Cleanup:
    if (pcei)
        delete pcei;

    return TRUE;
}

BOOL
CCookieJar::SyncWithCacheIfNeeded()
{
    return IsCacheModified() ? SyncWithCache() : TRUE;
}

struct PARSE
{
    char *pchBuffer;
    char *pchToken;
    BOOL fEqualFound;
};

static char *
SkipWS(char *pch)
{
    while (*pch == ' ' || *pch == '\t')
        pch += 1;

    return pch;
}

static BOOL
ParseToken(PARSE *pParse, BOOL fBreakOnSpecialTokens, BOOL fBreakOnEqual)
{
    char ch;
    char *pch;
    char *pchEndToken;

    pParse->fEqualFound = FALSE;

    pch = SkipWS(pParse->pchBuffer);
    if (*pch == 0)
    {
        pParse->pchToken = pch;
        return FALSE;
    }

    pParse->pchToken = pch;
    pchEndToken = pch;

    while ((ch = *pch) != 0)
    {
        pch += 1;
        if (ch == ';')
        {
            break;
        }
        else if (fBreakOnEqual && ch == '=')
        {
            pParse->fEqualFound = TRUE;
            break;
        }
        else if (ch == ' ' || ch == '\t')
        {
            if (fBreakOnSpecialTokens)
            {
                if ((strnicmp(pch, "expires", sizeof("expires") - 1) == 0) ||
                    (strnicmp(pch, "path", sizeof("path") - 1) == 0) ||
                    (strnicmp(pch, "domain", sizeof("domain") - 1) == 0) ||
                    (strnicmp(pch, "secure", sizeof("secure") - 1) == 0)    ||
                    (strnicmp(pch, gcszNoScriptField, sizeof(gcszNoScriptField) - 1) == 0))
                {
                    break;
                }
            }
        }
        else
        {
            pchEndToken = pch;
        }
    }

    *pchEndToken = 0;
    pParse->pchBuffer = pch;
    return TRUE;
}


static void
ParseHeader(
    char *pchHeader,
    char **ppchName,
    char **ppchValue,
    char **ppchPath,
    char **ppchRDomain,
    DWORD *pdwFlags,
    FILETIME *pftExpire)
{
    PARSE parse;

    parse.pchBuffer = pchHeader;

    *ppchName = NULL;
    *ppchValue = NULL;
    *ppchPath = NULL;
    *ppchRDomain = NULL;
    *pdwFlags = COOKIE_SESSION;

    // If only one of name or value is specified, Navigator
    // uses name=<blank> and value as what ever was specified.
    // Example:  =foo  ->  name: <blank> value: foo
    //           foo   ->  name: <blank> value: foo
    //           foo=  ->  name: foo     value: <blank>

    if (ParseToken(&parse, FALSE, TRUE))
    {
        *ppchName = parse.pchToken;
        if (parse.fEqualFound)
        {
            if (ParseToken(&parse, FALSE, FALSE))
            {
                *ppchValue = parse.pchToken;
            }
            else
            {
                *ppchValue = s_achEmpty;
            }
        }
        else
        {
            *ppchValue = *ppchName;
            *ppchName = s_achEmpty;
        }
    }

    while (ParseToken(&parse, FALSE, TRUE))
    {
        if (stricmp(parse.pchToken, "expires") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                if (FParseHttpDate(pftExpire, parse.pchToken))
                {
                    // Don't make the cookie persistent if the parsing fails
                    *pdwFlags &= ~COOKIE_SESSION;
                }
            }
        }
        else if (stricmp(parse.pchToken, "domain") == 0)
        {
            if (parse.fEqualFound )
            {
                if( ParseToken(&parse, TRUE, FALSE))
                {
                    // Previous versions of IE tossed the leading
                    // "." on domain names.  We continue this behavior
                    // to maintain compatiblity with old cookie files.
                    // See comments at the top of this file for more
                    // information.

                    if (*parse.pchToken == '.') parse.pchToken += 1;
                    ReverseString(parse.pchToken);
                    *ppchRDomain = parse.pchToken;
                }
                else
                {
                    *ppchRDomain = parse.pchToken;
                }
            }
        }
        else if (stricmp(parse.pchToken, "path") == 0)
        {
            if (parse.fEqualFound && ParseToken(&parse, TRUE, FALSE))
            {
                *ppchPath = parse.pchToken;
            }
            else
            {
                *ppchPath = s_achEmpty;
            }
        }
        else if (stricmp(parse.pchToken, "secure") == 0)
        {
            *pdwFlags |= COOKIE_SECURE;

            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
        else if (stricmp(parse.pchToken, gcszNoScriptField) == 0)
        {
            *pdwFlags |= COOKIE_NONSCRIPTABLE;

            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
        else
        {
            if (parse.fEqualFound)
            {
                ParseToken(&parse, TRUE, FALSE);
            }
        }
    }

    if (!*ppchName)
    {
        *ppchName = *ppchValue = s_achEmpty;
    }

    if (*pdwFlags & COOKIE_SESSION)
    {
        pftExpire->dwLowDateTime = 0xFFFFFFFF;
        pftExpire->dwHighDateTime = 0x7FFFFFFF;
    }
}

/* Replace non-printable characters in a string with given char
   This is used to enforce the RFC requirement that cookie header
   tokens can only contain chars in the range 0x20-0x7F.

   DCR: For compatability reasons we only replace control characters
   in the range 0x00 - 0x1F inclusive.
   There are international websites which depend on being able to
   set cookies with DBCS characters in name and value.
   (That assumption is wishful thinking and a violation of RFC2965.)
*/
void replaceControlChars(char *pszstr, char chReplace='_') {

    if (!pszstr)
        return;

    while (*pszstr) {
        if (*pszstr>=0x00 && *pszstr<=0x1F)
            *pszstr = chReplace;
        pszstr++;
    }
}

// free's an INTERNET_COOKIE structure
static VOID
DestroyInternetCookie(INTERNET_COOKIE *pic)
{
    if ( pic != NULL )
    {
        if ( pic->pszDomain ) {
            FREE_MEMORY(pic->pszDomain);
        }
        if ( pic->pszPath ) {
            FREE_MEMORY(pic->pszPath);
        }
        if ( pic->pszName ) {
            FREE_MEMORY(pic->pszName);
        }
        if ( pic->pszData ) {
            FREE_MEMORY(pic->pszData);
        }
        if ( pic->pszUrl ) {
            FREE_MEMORY(pic->pszUrl);
        }
        if( pic->pftExpires ) {
            delete pic->pftExpires;
            pic->pftExpires = NULL;
        }
        if (pic->pszP3PPolicy)
            FREE_MEMORY(pic->pszP3PPolicy);

        FREE_MEMORY(pic);
    }
}

// allocate's an INTERNET_COOKIE structure
static INTERNET_COOKIE *
MakeInternetCookie(
    const char *pchURL,
    char *pchRDomain,
    char *pchPath,
    char *pchName,
    char *pchValue,
    DWORD dwFlags,
    FILETIME ftExpire,
    const char *pchPolicy
    )
{
    INTERNET_COOKIE *pic = NULL;

    pic = (INTERNET_COOKIE *) ALLOCATE_MEMORY(LMEM_ZEROINIT, sizeof(INTERNET_COOKIE));

    if ( pic == NULL ) {
        return NULL;
    }

    pic->cbSize = sizeof(INTERNET_COOKIE);

    pic->pszDomain = pchRDomain ? NewString(pchRDomain) : NULL;
    if (pic->pszDomain) {
        ReverseString(pic->pszDomain);
    }
    pic->pszPath = pchPath ? NewString(pchPath) : NULL;
    pic->pszName = pchName ? NewString(pchName) : NULL;
    pic->pszData = pchValue ? NewString(pchValue) : NULL;
    pic->pszUrl = pchURL ? NewString(pchURL) : NULL;
    pic->pszP3PPolicy = pchPolicy? NewString(pchPolicy) : NULL;

#if COOKIE_SECURE != INTERNET_COOKIE_IS_SECURE
#error MakeInternetCookie depends on cookie flags to remain the same
#endif
    pic->dwFlags = dwFlags;

    if( dwFlags & COOKIE_SESSION )
    {
        pic->pftExpires = NULL;
    }
    else
    {
        pic->pftExpires = new FILETIME;
        if( pic->pftExpires )
        {
            memcpy(pic->pftExpires, &ftExpire, sizeof(FILETIME));
        }
    }

    return pic;
}

DWORD
GetPromptMask(BOOL fIsSessionCookie, BOOL fIs3rdPartyCookie)
{
    DWORD   dwMask = 0x01;      // prompted bit

    if(fIsSessionCookie)
        dwMask |= 0x02;

    if(fIs3rdPartyCookie)
        dwMask |= 0x04;

    return dwMask;
}


void
SetCookiePromptMask(
    LPSTR  pchRDomain,
    LPSTR  pchPath,
    BOOL    fSecure,
    BOOL    f3rdParty
    )
{
    CCookieLocation *pLocation;
    CCookie     *pCookie;
    FILETIME    ftCurrent;

    GetCurrentGmtTime(&ftCurrent);

    CCookieCriticalSection cs;

    if(s_pJar->SyncWithCacheIfNeeded())
    {
        for (pLocation = *s_pJar->GetBucket(pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
        {
            if (pLocation->IsMatch(pchRDomain, pchPath))
            {
                pLocation->ReadCacheFileIfNeeded();

                for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
                {
                    if (pCookie->CanSend(&ftCurrent, fSecure))
                    {
                        DWORD dwMask = GetPromptMask(!pCookie->IsPersistent(), f3rdParty);
                        DEBUG_PRINT(HTTP, INFO, ("[MASK] SetCookiePromptMask: Domain=%s, pCookie=%#x, dwMask=%#x\n", pchRDomain, pCookie, dwMask));
                        pCookie->_dwPromptMask = dwMask;
                    }
                }
            }
        }
    }
}


BOOL IsCookieIdentical(CCookie *pCookie, char *pchValue, DWORD dwFlags, FILETIME ftExpire)
{
    //
    // Decide if we need to prompt for a cookie when one already exists.  Basic idea is
    // if the cookie is identical, nothing is happening, so we don't need to prompt.
    // Change of value or expiry time (inc. session <-> persistent) means we need to
    // prompt again based on the new cookie type.
    //

    // no existing cookie ==> different
    if(NULL == pCookie)
    {
        return FALSE;
    }

    // if existing cookie has non-empty value and new value is NULL ==> different
    if(NULL == pchValue && pCookie->_pchValue != s_achEmpty)
    {
        return FALSE;
    }

    // different values ==> different (catches new non-empty value and existing empty value)
    if(pchValue && lstrcmp(pCookie->_pchValue, pchValue))
    {
        return FALSE;
    }

    // different flags ==> different
    if(dwFlags != pCookie->_dwFlags)
    {
        return FALSE;
    }

    // if persistant, different expires ==> different
    if(memcmp(&ftExpire, &pCookie->_ftExpire, sizeof(FILETIME)))
    {
        return FALSE;
    }

    return TRUE;
}

DWORD
CCookieJar::CheckCookiePolicy(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    CookieInfo *pInfo,
    DWORD dwOperation
    )
{
    /* Assumption: policy is checked at time of accepting cookies.
       Existing cookies are sent without prompt after that point */
    if (dwOperation & COOKIE_OP_GET)
        return COOKIE_SUCCESS;

    DWORD dwError;
    DWORD dwCookiesPolicy;
    BOOL fCleanupPcdi = FALSE;
    COOKIE_DLG_INFO *pcdi = NULL, *pcdi_result = NULL;

    SetLastError(ERROR_SUCCESS);

    //
    // Deal first with the basic quick cases to determine if we need UI here.
    //  they are:
    ///  - Do we allow UI for this given request?
    //
    if (pInfo->pchURL == NULL)
    {
        return COOKIE_FAIL;
    }

    if (pRequest && (pRequest->GetOpenFlags() & INTERNET_FLAG_NO_UI))
    {
        return COOKIE_FAIL;
    }

    //
    // Now look up the cookie and confirm that it hasn't just been added,
    //  if its already added to the Cookie list, then we don't show UI,
    //  since once the user has chosen to add a given Cookie, we don't repeatly re-prompt
    //

    if(dwOperation & COOKIE_OP_SET)
    {
        CCookieCriticalSection cs;
        CCookieLocation *pLocation;

        if (!SyncWithCacheIfNeeded())
            return COOKIE_FAIL;

        pLocation = GetLocation(pInfo->pchRDomain, pInfo->pchPath, FALSE /* no creation*/);

        if (pLocation)
        {
            CCookie *pCookie;

            pLocation->ReadCacheFileIfNeeded();
            pCookie = pLocation->GetCookie(pInfo->pchName, FALSE /* no creation */);
            if(IsCookieIdentical(pCookie, pInfo->pchValue, pInfo->dwFlags, pInfo->ftExpire))
            {
                return COOKIE_SUCCESS;
            }
        }
    }

    //
    // Now make the async request, to see if we can put up UI
    //

    {
        DWORD dwAction;
        DWORD dwResult;
        DWORD dwDialogToShow;
        LPVOID *ppParams;

        pcdi = new COOKIE_DLG_INFO;
        if(NULL == pcdi)
        {
            return COOKIE_FAIL;
        }

        memset(pcdi, 0, sizeof(*pcdi));

        pcdi->dwOperation = dwOperation;

        fCleanupPcdi = TRUE;

        if(dwOperation & COOKIE_OP_SESSION)
        {
            // make sure flags have session so it shows up right in the UI
            pInfo->dwFlags |= COOKIE_SESSION;
        }

        // create data to pass to dialog
        pcdi->pic = MakeInternetCookie(pInfo->pchURL,
                                       pInfo->pchRDomain,
                                       pInfo->pchPath,
                                       pInfo->pchName,
                                       pInfo->pchValue,
                                       pInfo->dwFlags,
                                       pInfo->ftExpire,
                                       pInfo->pP3PState ? pInfo->pP3PState->pszP3PHeader : NULL
                                       );

        if(pcdi->pic == NULL)
        {
            delete pcdi;
            return COOKIE_FAIL;
        }

        pcdi_result = pcdi;

        dwError = ChangeUIBlockingState(
                    (HINTERNET) pRequest,
                    ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION_EX,
                    &dwAction,
                    &dwResult,
                    (LPVOID *)&pcdi_result
                    );

        if(dwError != ERROR_IO_PENDING && dwError != ERROR_SUCCESS)
        {
            goto quit;
        }

        switch (dwAction)
        {
            case UI_ACTION_CODE_NONE_TAKEN:
            {
                // fallback to old behavior
                const int MaxConcurrentDialogs = 10;
                static HANDLE hUIsemaphore = CreateSemaphore(NULL, MaxConcurrentDialogs, MaxConcurrentDialogs, NULL);

                // restrict number of concurrent dialogs
                // NOTE: this is a *temporary* solution for #13393
                // revisit the problem of serializing dialogs when prompting behavior
                // for script is finalized.
                if (WAIT_TIMEOUT==WaitForSingleObject(hUIsemaphore, 0))
                {
                    dwError = ERROR_INTERNET_NEED_UI;
                    break;
                }

                dwError = ConfirmCookie(NULL, pRequest, pcdi);

                ReleaseSemaphore(hUIsemaphore, 1, NULL);

                // If user requested decision to persist, save prompt result in history
                // "dwStopWarning" may contain 0 (no policy change) or COOKIE_ALLOW_ALL
                // or COOKIE_DONT_ALLOW_ALL
                if(pcdi->dwStopWarning)
                {
                    int decision = (pcdi->dwStopWarning == COOKIE_ALLOW_ALL) ?
                                   COOKIE_STATE_ACCEPT :
                                   COOKIE_STATE_REJECT;

                    ReverseString(pInfo->pchRDomain);
                    cookieUIhistory.saveDecision(pInfo->pchRDomain, NULL, decision);
                    ReverseString(pInfo->pchRDomain);
                }

                break;
            }

            case UI_ACTION_CODE_USER_ACTION_COMPLETED:

                // If user requested decision to persist, save prompt result in history
                // "dwStopWarning" may contain 0 (no policy change) or COOKIE_ALLOW_ALL
                // or COOKIE_DONT_ALLOW_ALL
                if(pcdi_result->dwStopWarning)
                {
                    int decision = (pcdi_result->dwStopWarning == COOKIE_ALLOW_ALL) ?
                                   COOKIE_STATE_ACCEPT :
                                   COOKIE_STATE_REJECT;

                    ReverseString(pInfo->pchRDomain);
                    cookieUIhistory.saveDecision(pInfo->pchRDomain, NULL, decision);
                    ReverseString(pInfo->pchRDomain);
                }

                if (pcdi != pcdi_result)
                {
                    // got an old pcdi back, clean it
                    if(pcdi_result->pic)
                    {
                        DestroyInternetCookie(pcdi_result->pic);
                    }
                    delete pcdi_result;
                }

                // make sure we clean current, too
                INET_ASSERT(fCleanupPcdi);

                dwError = dwResult;
                break;

            case UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT:

                //
                // Go pending while we wait for the UI to be shown
                //
                INET_ASSERT(pcdi == pcdi_result);
                fCleanupPcdi = FALSE; // the UI needs this info, don't delete

                // fall through ...

            case UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE:

                INET_ASSERT(dwError == ERROR_IO_PENDING);
                break;
        }
    }

quit:
    if ( fCleanupPcdi )
    {
        if(pcdi->pic)
        {
            DestroyInternetCookie(pcdi->pic);
        }
        delete pcdi;
    }

    SetLastError(dwError);

    if (dwError != ERROR_SUCCESS)
    {
        if ( dwError == ERROR_IO_PENDING ) {
            return COOKIE_PENDING;
        } else {
            return COOKIE_FAIL;
        }
    }
    else
    {
        return COOKIE_SUCCESS;
    }

}


DWORD
CCookieJar::SetCookie(HTTP_REQUEST_HANDLE_OBJECT *pRequest, const char *pchURL, char *pchHeader,
                      DWORD &dwFlags, P3PCookieState *pState = NULL, LPDWORD pdwAction = NULL)
{
    FILETIME ftExpire;
    FILETIME ftCurrent;
    char *pchName;
    char *pchValue;
    char *pchHeaderPath;
    char *pchHeaderRDomain;
    char *pchDocumentRDomain = NULL;
    char *pchDocumentPath = NULL;
    DWORD dwFlagsFromParse;
    BOOL  fDocumentSecure;
    BOOL  fDelete;
    DWORD dwRet = COOKIE_FAIL;
    BOOL  fWriteToCacheFileNeeded;
    CCookieLocation *pLocation;
    DWORD dwOperation = COOKIE_OP_SET;
    DWORD dwReqAction = COOKIE_STATE_UNKNOWN;

    ParseHeader(pchHeader, &pchName, &pchValue, &pchHeaderPath, &pchHeaderRDomain, &dwFlagsFromParse, &ftExpire);
    // merge flags given with those found by the parser.
    dwFlags |= dwFlagsFromParse;

    if (!PathAndRDomainFromURL(pchURL, &pchDocumentRDomain, &pchDocumentPath, &fDocumentSecure))
        goto Cleanup;

    //
    // Verify domain and path
    //

    if ((pchHeaderRDomain && !IsDomainLegal(pchHeaderRDomain, pchDocumentRDomain)) ||
        (pchHeaderPath && !IsPathLegal(pchHeaderPath, pchDocumentPath)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    // Remove control-characters and other non-ASCII symbols
    replaceControlChars(pchName);
    replaceControlChars(pchValue);
    replaceControlChars(pchHeaderPath);
    replaceControlChars(pchHeaderRDomain);

    if (!pchHeaderRDomain)
        pchHeaderRDomain = pchDocumentRDomain;

    if (!pchHeaderPath)
        pchHeaderPath = pchDocumentPath;

    // We need to discard any extra info (i.e. query strings and fragments)
    // from the url.
    if (pchHeaderPath)
    {
        PTSTR psz = pchHeaderPath;
        while (*psz)
        {
            if (*psz==TEXT('?') || *psz==TEXT('#'))
            {
                *psz = TEXT('\0');
                break;
            }
            psz++;
        }
    }

    //
    // Delete the cookie?
    //

    GetCurrentGmtTime(&ftCurrent);
    fDelete = CompareFileTime(ftCurrent, ftExpire) > 0;

    // get 3rd part flag
    BOOL f3rdParty = (pRequest && pRequest->Is3rdPartyCookies())    ||
                     (dwFlags & INTERNET_COOKIE_THIRD_PARTY);

    if (f3rdParty)
    {
        dwOperation |= COOKIE_OP_3RD_PARTY;
    }

    // check session vs. persistent
    if(dwFlagsFromParse & COOKIE_SESSION)
    {
        dwOperation |= COOKIE_OP_SESSION;
    }
    else
    {
        dwOperation |= COOKIE_OP_PERSISTENT;
    }


    BOOL fSessionCookie = dwFlags & COOKIE_SESSION;

    /* DELETE operations are not subject to P3P, except for leashed cookies */
    BOOL fP3PApplies = !fDelete && pState && (!fSessionCookie || pState->fIncSession);

    /* Check for the "anything-goes" mode */
    BOOL fAllowAll = pState && (pState->dwEvalMode==URLPOLICY_ALLOW);

    /* if cookie operations are disabled, fail the operation */
    if (pState && pState->dwEvalMode==URLPOLICY_DISALLOW)
        dwReqAction = COOKIE_STATE_REJECT;
    else if (fP3PApplies && !fAllowAll) {

        /* Since downgrading a session cookie is a NOOP,
           report the action as ACCEPT in that case */
        if (fSessionCookie && pState->dwPolicyState==COOKIE_STATE_DOWNGRADE)
            dwReqAction = COOKIE_STATE_ACCEPT;
        dwFlags |= getImpliedCookieFlags(pState);
        dwReqAction = pState->dwPolicyState;
    }
    else
        dwReqAction = COOKIE_STATE_ACCEPT;

    // If prompt is required, show UI
    if((dwFlags & INTERNET_COOKIE_PROMPT_REQUIRED) ||
        dwReqAction==COOKIE_STATE_PROMPT)
    {
        CookieInfo ckInfo =
        {
            pchURL,
            pchHeaderRDomain, pchHeaderPath,
            pchName, pchValue,
            dwFlags
        };

        ckInfo.ftExpire = ftExpire;
        ckInfo.pP3PState = pState;

        dwRet = CheckCookiePolicy(pRequest, &ckInfo, dwOperation);

        if (dwRet != COOKIE_SUCCESS) {
            dwReqAction = COOKIE_STATE_REJECT;
            goto Cleanup;
        }
        else
            dwReqAction = COOKIE_STATE_ACCEPT;
    }

    if (dwReqAction==COOKIE_STATE_REJECT) {
        dwRet = COOKIE_FAIL;
        goto Cleanup;
    }

    //
    // Finally, we can add the cookie!
    //

    {
        CCookieCriticalSection cs;

        if (!SyncWithCacheIfNeeded())
            goto Cleanup;

        pLocation = GetLocation(pchHeaderRDomain, pchHeaderPath, !fDelete);

        if (pLocation)
        {
            pLocation->ReadCacheFileIfNeeded();
            fWriteToCacheFileNeeded = FALSE;

            if (fDelete)
            {
                CCookie *pCookie = pLocation->GetCookie(pchName, FALSE);

                // If the cookie we are attempting to delete does not exist,
                // return success code
                if (!pCookie) {
                    dwRet = COOKIE_SUCCESS;
                    goto Cleanup;
                }

                /* Leashed cookies cannot be deleted from 3rd party context
                   unless P3P is disabled completely eg when "fAllowAll" is true.
                   EXCEPTION: allow *legacy* leashed cookies to be deleted from 3rd party */
                if (pCookie->IsRestricted()
                    && f3rdParty
                    && !(fAllowAll || pCookie->IsLegacy()))
                {
                    dwReqAction = COOKIE_STATE_REJECT;
                    goto Cleanup;
                }

                fWriteToCacheFileNeeded |= pLocation->Purge(CCookie::PurgeByName, pchName);
            }
            else
            {
                CCookie *pCookie;

                EnforceCookieLimits(pLocation, pchName, &fWriteToCacheFileNeeded);

                pCookie = pLocation->GetCookie(pchName, TRUE);

                if (!pCookie)
                    goto Cleanup;

                pCookie->_ftLastModified = ftCurrent;

                if (memcmp(&ftExpire, &pCookie->_ftExpire, sizeof(FILETIME)) ||
                    strcmp(pchValue, pCookie->_pchValue) ||
                    dwFlags != pCookie->_dwFlags)
                {
                    fWriteToCacheFileNeeded |= pCookie->IsPersistent();

                    pCookie->_ftExpire = ftExpire;
                    pCookie->_dwFlags = dwFlags;
                    pCookie->SetValue(pchValue);
                    pCookie->_dwPromptMask = GetPromptMask(dwOperation & COOKIE_OP_SESSION, dwOperation & COOKIE_OP_3RD_PARTY);

                    DEBUG_PRINT(HTTP, INFO, ("[MASK] SetCookie: Domain=%s, Updating cookie mask, pCookie=%#x, new mask=%#x\n", pchHeaderRDomain, pCookie, pCookie->_dwPromptMask));

                    fWriteToCacheFileNeeded |= pCookie->IsPersistent();
                }
            }

            if (fWriteToCacheFileNeeded)
            {
                if (!pLocation->WriteCacheFile())
                    goto Cleanup;
            }
        }
    }

    dwRet = COOKIE_SUCCESS;

Cleanup:
    if (pchDocumentRDomain)
        FREE_MEMORY(pchDocumentRDomain);
    if (pchDocumentPath)
        FREE_MEMORY(pchDocumentPath);

    if (pdwAction)
        *pdwAction = dwReqAction;

    return dwRet;
}

void
CCookieJar::EnforceCookieLimits(CCookieLocation *pLocationNew, char *pchNameNew, BOOL *fWriteToCacheFileNeeded)
{
    CCookieLocation *pLocation;
    CCookieLocation *pLocationVictim;
    CCookie *pCookie;
    CCookie *pCookieVictim = NULL;
    int nCookie = 0;

    for (pLocation = *GetBucket(pLocationNew->_pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
    {
        // Same domain?

        if (stricmp(pLocationNew->_pchRDomain, pLocation->_pchRDomain) == 0)
        {
            pLocation->ReadCacheFileIfNeeded();
            for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
            {
                nCookie += 1;

                if (pLocation == pLocationNew && strcmp(pCookie->_pchName, pchNameNew) == 0)
                {
                    // No need to enforce limits when resetting existing cookie value.
                    return;
                }

                if (!pCookieVictim ||
                    CompareFileTime(pCookie->_ftLastModified, pCookieVictim->_ftLastModified) < 0)
                {
                    pCookieVictim = pCookie;
                    pLocationVictim = pLocation;
                }
            }
        }
    }

    if (nCookie >= 20)
    {
        INET_ASSERT(pCookieVictim != NULL && pLocationVictim != NULL);

        if (pLocationVictim->Purge(CCookie::PurgeThis, pCookieVictim))
        {
            pLocationVictim->WriteCacheFile();
        }
    }
}

//---------------------------------------------------------------------------
//
// External APIs
//
//---------------------------------------------------------------------------

BOOL
OpenTheCookieJar()
{
    if (s_pJar)
        return TRUE;

    s_pJar = CCookieJar::Construct();
    if (!s_pJar)
        return FALSE;

    InitializeCriticalSection(&s_csCookieJar);

    return TRUE;
}

void
CloseTheCookieJar()
{
    if (s_pJar)
    {
        DeleteCriticalSection(&s_csCookieJar);
        delete s_pJar;
    }

    s_fFirstTime = TRUE;
    s_pJar = NULL;
}

void
PurgeCookieJarOfStaleCookies()
{
    FILETIME ftCurrent;

    if (s_pJar)
    {
        CCookieCriticalSection cs;
        GetCurrentGmtTime(&ftCurrent);
        s_pJar->Purge(&ftCurrent, TRUE);
    }
}

INTERNETAPI_(BOOL) InternetGetCookieW(
    LPCWSTR  lpszUrl,
    LPCWSTR  lpszCookieName,
    LPWSTR   lpszCookieData,
    LPDWORD lpdwSize
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetGetCookieW",
                     "%wq, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     lpdwSize
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData;

    ALLOC_MB(lpszUrl,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrl,mpUrl);
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        mpCookieData.dwAlloc = mpCookieData.dwSize = *lpdwSize;
        mpCookieData.psStr = (LPSTR)ALLOC_BYTES(*lpdwSize);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = InternetGetCookieA(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr, &mpCookieData.dwSize);

    *lpdwSize = mpCookieData.dwSize*sizeof(WCHAR);
    if (lpszCookieData)
    {
        if (mpCookieData.dwSize <= mpCookieData.dwAlloc)
        {
            //Bug 2110: InternetGetCookieA already considered '\0' at the end of URL. MAYBE_COPY_ANSI does it again.
            //We don't want to change MAYBE_COPY_ANSI, so we mpCookieData.dwSize -= 1 here. Otherwise we will overflow the heap
            mpCookieData.dwSize -= 1;
            MAYBE_COPY_ANSI(mpCookieData,lpszCookieData,*lpdwSize);
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            fResult = FALSE;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

void    convertLegacyCookie(CCookie *pCookie, CCookieLocation *pLocation) {

    const char* gasz_OptOutName[] = {"ID", "AA002", "id", "CyberGlobalAnonymous"};
    const char* gasz_OptOutValue[] = {"OPT_OUT", "optout", "OPT_OUT", "optout"};

    if (GlobalLeashLegacyCookies)
        pCookie->_dwFlags |= INTERNET_COOKIE_IS_RESTRICTED;

    /* special-case opt-out cookies-- these will never get leashed */
    for( int i = 0;
         i < sizeof( gasz_OptOutName)/sizeof(gasz_OptOutName[0]);
         i++)
    {
        if (!strcmp(pCookie->_pchName, gasz_OptOutName[i])
            && !strcmp(pCookie->_pchValue, gasz_OptOutValue[i]))
        {
            pCookie->_dwFlags &= ~INTERNET_COOKIE_IS_RESTRICTED;
            break;
        }
    }

    // Legacy cookies are special-cased for one time only
    // After that they are subject to P3P.
    pCookie->_dwFlags |= INTERNET_COOKIE_IE6;

    /* we need to remember which cookies are genuine IE6 vs. upgraded legacy... */
    pCookie->_dwFlags |= INTERNET_COOKIE_IS_LEGACY;

    pLocation->WriteCacheFile();
}


//
//  InternetGetCookieEx only returns those cookies within domain pchURL
//with a name that maches pchCookieName
//

INTERNETAPI_(BOOL) InternetGetCookieEx(
    IN LPCSTR pchURL,
    IN LPCSTR pchCookieName OPTIONAL,
    IN LPSTR pchCookieData OPTIONAL,
    IN OUT LPDWORD pcchCookieData,
    IN DWORD dwFlags,
    IN LPVOID lpReserved)
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetGetCookieA",
                     "%q, %#x, %#x, %#x",
                     pchURL,
                     pchCookieName,
                     pchCookieData,
                     pcchCookieData
                     ));

    //  force everyone to not give anything in lpReserved
    INET_ASSERT( lpReserved == NULL);
    if( lpReserved != NULL)
    {
        DEBUG_LEAVE_API(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    /*
    //  force everyone to not give anything in dwFlags
    INET_ASSERT( dwFlags == 0);
    if( dwFlags != 0)
    {
        DEBUG_LEAVE_API(FALSE);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    */


    BOOL    fSuccess = FALSE;
    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    BOOL    fSecure;
    DWORD   cch = 0;
    BOOL    fFirst;
    int     cchName;
    int     cchValue;
    FILETIME ftCurrent;
    CCookieLocation *pLocation;
    CCookie *pCookie;
    DWORD dwErr = ERROR_SUCCESS;

    if (!pcchCookieData || !pchURL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (!GlobalDataInitialized) {

        dwErr = GlobalDataInitialize();
        if (dwErr!= ERROR_SUCCESS) {
            goto done;
        }
    }

    // NOTE THIS SEEMS TO BE A BUG BUG BUG
    if (!PathAndRDomainFromURL(pchURL, &pchRDomain, &pchPath, &fSecure))
        goto Cleanup;

    DWORD dwMainSwitch = (dwFlags & INTERNET_FLAG_RESTRICTED_ZONE) ?
                         GetCookieMainSwitch(URLZONE_UNTRUSTED) :
                         GetCookieMainSwitch(pchURL);

    fFirst = TRUE;
    GetCurrentGmtTime(&ftCurrent);

    {
        CCookieCriticalSection cs;

        if (!s_pJar->SyncWithCacheIfNeeded())
            goto Cleanup;

        for (pLocation = *s_pJar->GetBucket(pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
        {
            if (pLocation->IsMatch(pchRDomain, pchPath))
            {
                pLocation->ReadCacheFileIfNeeded();

                for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
                {
                    if (IsLegacyCookie(pCookie))
                        convertLegacyCookie(pCookie, pLocation);

                    BOOL fAllow;

                    if (dwMainSwitch==URLPOLICY_ALLOW)              /* replay all cookies-- even leashed ones */
                        fAllow = TRUE;
                    else if (dwMainSwitch==URLPOLICY_DISALLOW)      /* suppress everything */
                        fAllow = FALSE;
                    else
                    {
                        /* default behavior: replay the cookie, provided its not leashed
                                             or we are in 1st party context */
                        fAllow = !pCookie->IsRestricted() ||
                                 (dwFlags & INTERNET_COOKIE_THIRD_PARTY) == 0;
                    }

                    BOOL fNonScriptable = (pCookie->_dwFlags & COOKIE_NONSCRIPTABLE);

                    if (fAllow
                        && !fNonScriptable  // Check for non-scriptable cookies
                        && pCookie->CanSend(&ftCurrent, fSecure)
                        && (pchCookieName == NULL
                            || StrCmp( pCookie->_pchName, pchCookieName) == 0))

                    {
                        if (!fFirst) cch += 2; // for ; <space>
                        cch += cchName = strlen(pCookie->_pchName);
                        cch += cchValue = strlen(pCookie->_pchValue);
                        if (cchName && cchValue) cch += 1; // for equal sign

                        if (pchCookieData && cch < *pcchCookieData)
                        {
                            if (!fFirst)
                            {
                                *pchCookieData++ = ';';
                                *pchCookieData++ = ' ';
                            }

                            if (cchName > 0)
                            {
                                memcpy(pchCookieData, pCookie->_pchName, cchName);
                                pchCookieData += cchName;

                                if (cchValue > 0)
                                {
                                    *pchCookieData++ = '=';
                                }
                            }

                            if (cchValue > 0)
                            {
                                memcpy(pchCookieData, pCookie->_pchValue, cchValue);
                                pchCookieData += cchValue;
                            }
                        }

                        fFirst = FALSE;
                    }
                }
            }
        }
    }

//TerminateBuffer:

    cch += 1;

    if (pchCookieData)
    {
        if (cch > *pcchCookieData)
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            *pchCookieData = 0;
            fSuccess = TRUE;
        }
    }
    else
    {
        fSuccess = TRUE;
    }

    if (cch == 1)
    {
        dwErr = ERROR_NO_MORE_ITEMS;
        fSuccess = FALSE;
        cch = 0;
    }

    *pcchCookieData = cch;

Cleanup:

    if (pchRDomain)
        FREE_MEMORY(pchRDomain);
    if (pchPath)
        FREE_MEMORY(pchPath);

done:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fSuccess);
    return fSuccess;
}

/*
 UNICODE version for InternetGetCookieEx
 Difference from the standard InternetGetCookie* function is
 addition of two parameters.
 Supported flags: third-party, prompt-required.
 */
INTERNETAPI_(BOOL) InternetGetCookieExW(
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszCookieName OPTIONAL,
    IN LPWSTR lpszCookieData OPTIONAL,
    IN OUT LPDWORD lpdwSize,
    IN DWORD dwFlags,
    IN LPVOID lpReserved)
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetGetCookieExW",
                     "%wq, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     lpdwSize
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData;

    ALLOC_MB(lpszUrl,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrl,mpUrl);
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        mpCookieData.dwAlloc = mpCookieData.dwSize = *lpdwSize;
        mpCookieData.psStr = (LPSTR)ALLOC_BYTES(*lpdwSize);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    fResult = InternetGetCookieExA(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr, &mpCookieData.dwSize, dwFlags, lpReserved);

    *lpdwSize = mpCookieData.dwSize*sizeof(WCHAR);
    if (lpszCookieData)
    {
        if (mpCookieData.dwSize <= mpCookieData.dwAlloc)
        {
            MAYBE_COPY_ANSI(mpCookieData,lpszCookieData,*lpdwSize);
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            fResult = FALSE;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;

    return FALSE;
}

INTERNETAPI_(BOOL) InternetGetCookieA(
    IN LPCSTR pchURL,
    IN LPCSTR pchCookieName OPTIONAL,
    IN LPSTR pchCookieData OPTIONAL,
    IN OUT LPDWORD pcchCookieData
    )
{
    //  Because the value in pchCookieName had no effect on
    //the previously exported API, Ex gets NULL to ensure
    //the behavior doesn't change.
    return InternetGetCookieEx( pchURL, NULL, pchCookieData,
                                pcchCookieData, 0, NULL);
}


INTERNETAPI_(BOOL) InternetSetCookieW(
    LPCWSTR  lpszUrl,
    LPCWSTR  lpszCookieName,
    LPCWSTR  lpszCookieData)
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieW",
                     "%wq, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData;

    if (lpszUrl)
    {
        ALLOC_MB(lpszUrl,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrl,mpUrl);
    }
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        ALLOC_MB(lpszCookieData,0,mpCookieData);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieData,mpCookieData);
    }

    fResult = InternetSetCookieA(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}



BOOL InternalInternetSetCookie(
    LPCSTR  pchURL,
    LPCSTR  pchCookieName,
    LPCSTR  pchCookieData,
    DWORD   dwFlags,
    LPVOID   lpReserved
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieA",
                     "%q, %#x, %#x",
                     pchURL,
                     pchCookieName,
                     pchCookieData
                     ));

    char *  pch      = NULL;
    char *  pchStart = NULL;

    int     cch;
    int     cchT;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fResult = FALSE;

    P3PCookieState CS;
    DWORD FlagsWithParam    = INTERNET_COOKIE_EVALUATE_P3P |
                              INTERNET_COOKIE_APPLY_P3P;

    BOOL fPolicy = (dwFlags & INTERNET_COOKIE_EVALUATE_P3P);
    BOOL fDecision = (dwFlags & INTERNET_COOKIE_APPLY_P3P);

    if (!pchURL || !pchCookieData || (fPolicy && fDecision))
    {
        fResult = FALSE;
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (!GlobalDataInitialized) {
        dwErr = GlobalDataInitialize();
        if (dwErr!= ERROR_SUCCESS) {
            fResult = FALSE;
            goto done;
        }
    }

    pch = (char *) ALLOCATE_FIXED_MEMORY(CCH_COOKIE_MAX);
    if (pch == NULL)
    {
        fResult = FALSE;
        dwErr   = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    pchStart = pch;

    /* The reserved parameter is used for passing in P3P header or decision */
    if (fPolicy) {

        CS.pszP3PHeader = (char*) lpReserved;

        EvaluateCookiePolicy(pchURL,
                             dwFlags & INTERNET_COOKIE_THIRD_PARTY,
                             dwFlags & INTERNET_FLAG_RESTRICTED_ZONE,
                             &CS);
    }
    else if (fDecision) {

        CookieDecision *pDecision = (CookieDecision*) lpReserved;

        CS.fEvaluated = TRUE;
        CS.dwPolicyState = pDecision->dwCookieState;
        CS.fIncSession = ! pDecision->fAllowSession;
        CS.dwEvalMode = GetCookieMainSwitch(pchURL);
    }

    cch = CCH_COOKIE_MAX - 2;  // one for null terminator, one for "="
    if (pchCookieName)
    {
        cchT = strlen(pchCookieName);
        if (cchT > cch)
            cchT = cch;
        memcpy(pch, pchCookieName, cchT);

        pch += cchT;
        cch -= cchT;

        memcpy(pch, "=", 1);
        pch += 1;
        cch -= 1;
    }

    // Ensure null termination upon overflow.
    if (cch <= 0)
        cch = 1;

    // Append the cookie data.
    lstrcpyn (pch, pchCookieData, cch);

    // All IE6 cookies are marked with this flag to distinguish
    // from legacy cookies inherited from past versions.
    if (fPolicy || fDecision)
        dwFlags |= INTERNET_COOKIE_IE6;

    DWORD dwAction = 0;

    if(s_pJar->SetCookie(NULL, pchURL, pchStart, dwFlags,
                         (fPolicy||fDecision) ? &CS : NULL,
                         &dwAction) == COOKIE_FAIL)
    {
        if( dwAction == COOKIE_STATE_REJECT)
            fResult = COOKIE_STATE_REJECT;
        else
            fResult = FALSE;
    }
    else
    {
        /* Return the action taken (accept, downgrade, etc.) */
        fResult = dwAction;
    }

done:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }

    if (pchStart)
        FREE_MEMORY(pchStart);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSetCookieA(
    LPCSTR  pchURL,
    LPCSTR  pchCookieName,
    LPCSTR  pchCookieData
    )
{
    DWORD dwResult = InternalInternetSetCookie( pchURL, pchCookieName, pchCookieData, 0, NULL);

    // For IE6 InternalInternetSetCookie returns the action taken.
    // When the API fails or cookie is rejected, that would be REJECT which is a positive value.
    // Convert this to FALSE to retain semantics compatible with IE5.5
    return (dwResult==COOKIE_STATE_REJECT) ? FALSE : dwResult;
}

BOOL  seekPolicyRef(const char *pszP3PHeader, char **pszPolicyRef, LPDWORD pdwLength) {

    static const char gszPolicyRefField[] = "policyref";

    *pszPolicyRef = FindNamedValue((char*)pszP3PHeader, gszPolicyRefField, pdwLength);

    return (*pszPolicyRef != NULL);
}

DWORD extractP3PHeader(HTTP_REQUEST_HANDLE_OBJECT *pRequest, char *pszHeader, DWORD *pdwHeaderSize)
{
    const char gszPolicyHeaderName[] = "P3P";
    const int  gszHeaderSize = sizeof(gszPolicyHeaderName)-1;

    DWORD dwIndex = 0;

    return  pRequest->QueryResponseHeader((LPSTR) gszPolicyHeaderName, gszHeaderSize,
                                           pszHeader, pdwHeaderSize, 0, &dwIndex);
}

DWORD getImpliedCookieFlags(P3PCookieState *pState) {

    if (!pState)
        return 0;

    DWORD dwImpliedFlags = 0;

    // "leash" means that the cookie will only be used in 1st party context
    if (pState->dwPolicyState==COOKIE_STATE_LEASH)
        dwImpliedFlags |= INTERNET_COOKIE_IS_RESTRICTED;

    // "downgrade" option forces cookies to session
    if (pState->dwPolicyState==COOKIE_STATE_DOWNGRADE)
        dwImpliedFlags |= INTERNET_COOKIE_IS_SESSION;

    return dwImpliedFlags;
}

BOOL EvaluateCookiePolicy(const char *pszURL, BOOL f3rdParty, BOOL fRestricted,
                          P3PCookieState *pState,
                          const char *pszHostName) {

    char achHostName[INTERNET_MAX_HOST_NAME_LENGTH];

    // If hostname is not given, it will be derived from the URL
    if (!pszHostName) {

        URL_COMPONENTS uc;

        memset(&uc, 0, sizeof(uc));
        uc.dwStructSize = sizeof(URL_COMPONENTS);
        uc.lpszHostName = achHostName;
        uc.dwHostNameLength = sizeof(achHostName);

        InternetCrackUrl(pszURL, 0, 0, &uc);
        pszHostName = achHostName;
    }

    /* For compatibility purposes--
       If registry settings are not available default behavior is:
       ACCEPT all cookies without restrictions */
    pState->dwPolicyState = COOKIE_STATE_ACCEPT;
    pState->fValidPolicy = FALSE;
    pState->fEvaluated = FALSE;
    pState->fIncSession = TRUE;
    pState->dwEvalMode = URLPOLICY_QUERY;

    DWORD dwMainSwitch = fRestricted ?
                           GetCookieMainSwitch(URLZONE_UNTRUSTED) :
                           GetCookieMainSwitch(pszURL);

    if (dwMainSwitch!=URLPOLICY_QUERY)
    {
        pState->dwEvalMode = dwMainSwitch;
        pState->dwPolicyState = (dwMainSwitch==URLPOLICY_ALLOW) ?
                                COOKIE_STATE_ACCEPT :
                                COOKIE_STATE_REJECT;
        return TRUE;
    }

    /* Check prompt history for past decisions made by the user about this website. */
    if (cookieUIhistory.lookupDecision(pszHostName, NULL, & pState->dwPolicyState))
    {
        pState->fValidPolicy = FALSE;
    }
    else
    {
        CCookieSettings *pSettings = NULL;
        CCookieSettings::GetSettings(&pSettings, pszURL, f3rdParty, fRestricted);

        if (pSettings)
        {
            pSettings->EvaluatePolicy(pState);
            pSettings->Release();
        }
    }

    return TRUE;
}

DWORD cacheFlagFromAction(DWORD dwAction) {

    switch (dwAction) {

    case COOKIE_STATE_ACCEPT:       return COOKIE_ACCEPTED_CACHE_ENTRY;
    case COOKIE_STATE_LEASH:        return COOKIE_LEASHED_CACHE_ENTRY;
    case COOKIE_STATE_DOWNGRADE:    return COOKIE_DOWNGRADED_CACHE_ENTRY;
    case COOKIE_STATE_REJECT:       return COOKIE_REJECTED_CACHE_ENTRY;
    }
    return 0;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::ExtractSetCookieHeaders(LPDWORD lpdwHeaderIndex)
{
    DWORD error = ERROR_HTTP_COOKIE_DECLINED;
    P3PCookieState CS;

    char  *pchP3PHeader = (char *) ALLOCATE_ZERO_MEMORY(CCH_COOKIE_MAX);
    char  *pchHeader    = (char *) ALLOCATE_ZERO_MEMORY(CCH_COOKIE_MAX);
    if (pchP3PHeader == NULL || pchHeader == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DWORD cbPolicy = CCH_COOKIE_MAX;

    if (ERROR_SUCCESS == extractP3PHeader(this, pchP3PHeader, &cbPolicy))
    {
        CS.pszP3PHeader = pchP3PHeader;
        InternetIndicateStatus(INTERNET_STATUS_P3P_HEADER,
                               (LPBYTE) CS.pszP3PHeader,
                               cbPolicy+1);
    }
    else
        CS.pszP3PHeader = NULL;

    if (!IsResponseHeaderPresent(HTTP_QUERY_SET_COOKIE))
    {
        error = ERROR_SUCCESS;
        goto CheckForPolicyRef;
    }

    BOOL fRestricted = GetOpenFlags() & INTERNET_FLAG_RESTRICTED_ZONE;

    EvaluateCookiePolicy(GetURL(),
                         Is3rdPartyCookies(),
                         fRestricted,
                         &CS,
                         GetHostName());

    /* NULL index pointer indicates that only P3P policy is evaluated,
       cookies are not processed */
    if (!lpdwHeaderIndex)
        goto SendNotification;

    DWORD iQuery = *lpdwHeaderIndex;
    DWORD cbHeader = CCH_COOKIE_MAX - 1;

    int cPersistent = 0;            /* # of persistent cookies */
    int cSession = 0;               /* # of session cookies */

    /* Array for storing # of cookies subject to each action */
    int cCount[COOKIE_STATE_MAX+1] = { 0 };

    _ResponseHeaders.LockHeaders();

    while ( QueryResponseHeader(
            HTTP_QUERY_SET_COOKIE,
            pchHeader,
            &cbHeader,
            0,
            &iQuery) == ERROR_SUCCESS)
    {
        // All IE6 cookies are marked with this flag to distinguish
        // from legacy cookies inherited from past versions.
        DWORD dwCookieFlags = INTERNET_COOKIE_IE6;

        if (_fBlockedOnPrompt)
            dwCookieFlags |= INTERNET_COOKIE_PROMPT_REQUIRED;

        pchHeader[cbHeader] = 0;

        DWORD dwAction;
        DWORD dwRet = s_pJar->SetCookie(this, GetURL(), pchHeader, dwCookieFlags, &CS, &dwAction);

        /* The cookie flags are passed by reference to the SetCookie() function.
           Upon return the requested flags will have been merged with flags from parsing */
        BOOL fSession = (dwCookieFlags & COOKIE_SESSION);
        fSession ? cSession++ : cPersistent++;

        INET_ASSERT(dwAction<=COOKIE_STATE_MAX);

        if (dwRet == COOKIE_SUCCESS)
        {
            *lpdwHeaderIndex = iQuery;
            error = ERROR_SUCCESS;
            cCount[dwAction]++;
            AddCacheEntryType(cacheFlagFromAction(dwAction));
        }
        else if (dwRet == COOKIE_PENDING)
        {
            error = ERROR_IO_PENDING;

            INET_ASSERT(iQuery != 0);
            *lpdwHeaderIndex = iQuery - 1; // back up and retry this cookie
            _fBlockedOnPrompt = TRUE;
            break;
        }
        else if (dwRet == COOKIE_FAIL)
        {
            /* Only consider cookies blocked because of privacy reasons.
               Other reasons for rejecting the cookie (syntax errors,
               incorrect domain/path etc.) are not reported */
            if (dwAction==COOKIE_STATE_REJECT)
            {
                cCount[dwAction]++;
                AddCacheEntryType(COOKIE_REJECTED_CACHE_ENTRY);
            }
        }

        cbHeader = CCH_COOKIE_MAX - 1;
        _fBlockedOnPrompt = FALSE;
    }

    _ResponseHeaders.UnlockHeaders();

SendNotification:
    // Postpone notifications if user has not answered the prompt yet
    if (error == ERROR_IO_PENDING)
        goto Cleanup;
    else
    {
        IncomingCookieState recvState = {0};

        recvState.cPersistent  = cPersistent;
        recvState.cSession = cSession;

        recvState.cAccepted     = cCount[COOKIE_STATE_ACCEPT];
        recvState.cLeashed      = cCount[COOKIE_STATE_LEASH];
        recvState.cDowngraded   = cCount[COOKIE_STATE_DOWNGRADE];
        recvState.cBlocked      = cCount[COOKIE_STATE_REJECT];

        // performance optimization-- same URL as the request
        recvState.pszLocation   = NULL;

        // Send notification about P3P state
        InternetIndicateStatus(INTERNET_STATUS_COOKIE_RECEIVED,
                               (LPBYTE) & recvState,
                               sizeof(recvState));
    }

CheckForPolicyRef:
    /* If P3P header contains URL of the policy-ref, this information
    must be communicated to WININET clients */
    char *pszPolicyRef = NULL;
    unsigned long dwLength = 0;

    if (CS.pszP3PHeader && seekPolicyRef(CS.pszP3PHeader, &pszPolicyRef, &dwLength))
    {
        pszPolicyRef[dwLength] = '\0';   // create nil-terminated string containing policy-ref URL
        InternetIndicateStatus(INTERNET_STATUS_P3P_POLICYREF,
                               (LPBYTE) pszPolicyRef,
                               dwLength+1);
    }

Cleanup:
    if (pchHeader)
        FREE_MEMORY(pchHeader);

    if (pchP3PHeader)
        FREE_MEMORY(pchP3PHeader);

    return error;
}

INTERNETAPI_(DWORD) InternetSetCookieExW(
    LPCWSTR     lpszUrl,
    LPCWSTR     lpszCookieName,
    LPCWSTR     lpszCookieData,
    DWORD       dwFlags,
    DWORD_PTR   dwReserved
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieExW",
                     "%wq, %#x, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     dwFlags,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwResult = FALSE;
    MEMORYPACKET mpUrl, mpCookieName, mpCookieData, mpP3PHeader;
    void *lpReserved = (void*) dwReserved;

    if (lpszUrl)
    {
        ALLOC_MB(lpszUrl,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrl,mpUrl);
    }
    if (lpszCookieName)
    {
        ALLOC_MB(lpszCookieName,0,mpCookieName);
        if (!mpCookieName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieName,mpCookieName);
    }
    if (lpszCookieData)
    {
        ALLOC_MB(lpszCookieData,0,mpCookieData);
        if (!mpCookieData.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszCookieData,mpCookieData);
    }

    /* Reserved parameter is used for passing in the P3P header */
    if (dwReserved && (dwFlags & INTERNET_COOKIE_EVALUATE_P3P))
    {
        LPWSTR pwszP3PHeader = (LPWSTR) dwReserved;

        ALLOC_MB(pwszP3PHeader, 0, mpP3PHeader);
        if (!mpP3PHeader.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszP3PHeader, mpP3PHeader);

        lpReserved = mpP3PHeader.psStr;
    }

    dwResult = InternalInternetSetCookie(mpUrl.psStr, mpCookieName.psStr, mpCookieData.psStr, dwFlags, lpReserved);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(dwResult);
    return dwResult;
}


INTERNETAPI_(DWORD) InternetSetCookieExA(
    LPCSTR      lpszUrl,
    LPCSTR      lpszCookieName,
    LPCSTR      lpszCookieData,
    DWORD       dwFlags,
    DWORD_PTR   dwReserved
    )
{
    DEBUG_ENTER_API((DBG_INET,
                     Bool,
                     "InternetSetCookieExA",
                     "%wq, %#x, %#x, %#x, %#x",
                     lpszUrl,
                     lpszCookieName,
                     lpszCookieData,
                     dwFlags,
                     dwReserved
                     ));

    DWORD dwResult = InternalInternetSetCookie(lpszUrl, lpszCookieName, lpszCookieData, dwFlags, (void*) dwReserved);

    DEBUG_LEAVE_API(dwResult);
    return dwResult;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::CreateCookieHeaderIfNeeded(int *pcCookie)
{
    char *  pchRDomain = NULL;
    char *  pchPath = NULL;
    DWORD   cch;
    int     cchName;
    int     cchValue;
    FILETIME ftCurrent, ftExpire;
    BOOL     fSecure;
    CCookieLocation *pLocation;
    CCookie *pCookie;
    DWORD   dwError = 0;

    DWORD dwMainSwitch =  GetCookieMainSwitch(GetSecurityZone());

    BOOL fNoReplay  = (dwMainSwitch==URLPOLICY_DISALLOW);
    BOOL fReplayAll = (dwMainSwitch==URLPOLICY_ALLOW);

    BOOL f3rdPartyRequest = Is3rdPartyCookies();

    int cCookie     = 0;    // # of cookies added
    int cSuppressed = 0;    // # of cookies suppressed

    char *  pchHeader = (char *) ALLOCATE_FIXED_MEMORY(CCH_COOKIE_MAX);
    if (pchHeader == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    char *pchHeaderStart = pchHeader;

    // remove cookie header if it exists
    // BUGBUG - we are overriding the app. Original cookie code has this.  Don't know why.

    ReplaceRequestHeader(HTTP_QUERY_COOKIE, NULL, 0, 0, 0);

    memset(&ftExpire, 0, sizeof(FILETIME));

    if (!PathAndRDomainFromURL(GetURL(), &pchRDomain, &pchPath, &fSecure, FALSE))
        goto Cleanup;

    fSecure = GetOpenFlags() & INTERNET_FLAG_SECURE;
    GetCurrentGmtTime(&ftCurrent);

    {
        CCookieCriticalSection cs;

        if (!s_pJar->SyncWithCacheIfNeeded())
            goto Cleanup;

        LockHeaders();

        for (pLocation = *s_pJar->GetBucket(pchRDomain); pLocation; pLocation = pLocation->_pLocationNext)
        {
            if (pLocation->IsMatch(pchRDomain, pchPath))
            {
                pLocation->ReadCacheFileIfNeeded();

                for (pCookie = pLocation->_pCookieKids; pCookie; pCookie = pCookie->_pCookieNext)
                {
                    if (IsLegacyCookie(pCookie))
                        convertLegacyCookie(pCookie, pLocation);

                    if (pCookie->CanSend(&ftCurrent, fSecure))
                    {
                        pchHeader = pchHeaderStart;
                        cch = 0;
                        cch += cchName = strlen(pCookie->_pchName);
                        cch += cchValue = strlen(pCookie->_pchValue);
                        if (cchName) cch += 1; // for equal sign

                        if (cch < CCH_COOKIE_MAX)
                        {
                            if (cchName > 0)
                            {
                                memcpy(pchHeader, pCookie->_pchName, cchName);
                                pchHeader += cchName;

                                *pchHeader++ = '=';
                            }

                            if (cchValue > 0)
                            {
                                memcpy(pchHeader, pCookie->_pchValue, cchValue);
                                pchHeader += cchValue;
                            }

                            /* IF the cookie is marked 1st party only,
                               OR cookie feature is not enabled for this zone,
                               suppress the cookie */
                            if (fNoReplay ||
                                (!fReplayAll && f3rdPartyRequest && pCookie->IsRestricted()))
                            {
                                cSuppressed++;
                                continue;
                            }

                            cCookie += 1;

                            AddRequestHeader(HTTP_QUERY_COOKIE,
                                pchHeaderStart,
                                cch,
                                0,
                                HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON);
                        }
                    } // if CanSend
                } // for pCookie
            } // if IsMatch
        } // for

        UnlockHeaders();
    }

Cleanup:

    // Send notification about sent/suppressed in this request
    if (cCookie || cSuppressed)
    {
        OutgoingCookieState sendState = { cCookie, cSuppressed };

        InternetIndicateStatus(INTERNET_STATUS_COOKIE_SENT, (LPBYTE) &sendState, sizeof(sendState));
    }

    if (pchHeaderStart)
        FREE_MEMORY(pchHeaderStart);
    if (pchRDomain)
        FREE_MEMORY(pchRDomain);
    if (pchPath)
        FREE_MEMORY(pchPath);

    if(pcCookie)
    {
        *pcCookie = cCookie;
    }

    return dwError;
}


//  IsDomainLegalCookieDomain  - exported in wininet.w for private use..
//
//  example:  ( "yahoo.com", "www.yahoo.com") -> TRUE
//            ( "com", "www.yahoo.com") -> FALSE
//            ( "0.255.192", "255.0.255.192") -> FALSE
//            ( "255.0.255.192", "255.0.255.192") -> TRUE
BOOLAPI IsDomainLegalCookieDomainA( IN LPCSTR pchDomain, IN LPCSTR pchFullDomain)
{
    BOOL returnValue = FALSE;
    DWORD dwError = ERROR_SUCCESS;

    LPSTR pchReversedDomain = NULL;
    LPSTR pchReversedFullDomain = NULL;
    long iDomainSize, iFullDomainSize;

    if(!pchDomain || IsBadStringPtr( pchDomain, INTERNET_MAX_URL_LENGTH))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto doneIsDomainLegalCookieDomainA;
    }

    if(!pchFullDomain || IsBadStringPtr( pchFullDomain, INTERNET_MAX_URL_LENGTH))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto doneIsDomainLegalCookieDomainA;
    }

    iDomainSize = strlen( pchDomain) + 1;
    iFullDomainSize = strlen( pchFullDomain) + 1;

    pchReversedDomain = new char[ iDomainSize];
    pchReversedFullDomain = new char[ iFullDomainSize];

    if( pchReversedDomain == NULL || pchReversedFullDomain == NULL)
        goto doneIsDomainLegalCookieDomainA;

    memcpy( pchReversedDomain, pchDomain, iDomainSize);
    memcpy( pchReversedFullDomain, pchFullDomain, iFullDomainSize);
    ReverseString( pchReversedDomain);
    ReverseString( pchReversedFullDomain);

    returnValue = IsDomainLegal( pchReversedDomain, pchReversedFullDomain);

doneIsDomainLegalCookieDomainA:
    if( dwError != ERROR_SUCCESS)
        SetLastError( dwError);

    if( pchReversedDomain != NULL)
        delete [] pchReversedDomain;

    if( pchReversedFullDomain != NULL)
        delete [] pchReversedFullDomain;

    return returnValue;
}


BOOLAPI IsDomainLegalCookieDomainW( IN LPCWSTR pwchDomain, IN LPCWSTR pwchFullDomain)
{
    MEMORYPACKET mpDomain;
    ALLOC_MB(pwchDomain,0,mpDomain);
    if (!mpDomain.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchDomain, mpDomain);

    MEMORYPACKET mpFullDomain;
    ALLOC_MB(pwchFullDomain,0,mpFullDomain);
    if (!mpFullDomain.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchFullDomain, mpFullDomain);

    return IsDomainLegalCookieDomainA( mpDomain.psStr, mpFullDomain.psStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cache.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cache.cxx

Abstract:

    Contains HTTP cache-related functions. Cache functions pulled out of
    read.cxx and send.cxx

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::FCanWriteToCache
        HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader
        HTTP_REQUEST_HANDLE_OBJECT::AddHeaderIfEtagFound
        HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheRetrieval
        HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite
        HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePreNetIO
        HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO
        HTTP_REQUEST_HANDLE_OBJECT::ResumePartialDownload
        HTTP_REQUEST_HANDLE_OBJECT::AddTimestampsFromCacheToResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::AddTimeHeader
        HTTP_REQUEST_HANDLE_OBJECT::IsPartialResponseCacheable
        HTTP_REQUEST_HANDLE_OBJECT::LocalEndCacheWrite
        HTTP_REQUEST_HANDLE_OBJECT::GetTimeStampsForCache
        (FExcludedMimeType)
        (FilterHeaders)

Author:

    Richard L Firth (rfirth) 05-Dec-1997

Environment:

    Win32 user-mode DLL

Revision History:

    05-Dec-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
BOOL
FExcludedMimeType(
    IN LPSTR lpszMimeType,
    IN DWORD dwMimeTypeSize
    );

PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwHeaderLen
    );

//
// static data
//

LPCSTR rgszExcludedMimeTypes[] = {
    "multipart/mixed",
    "multipart/x-mixed-replace"
    };

const DWORD rgdwExcludedMimeTypeSizes[] = {
    sizeof("multipart/mixed") - 1,
    sizeof("multipart/x-mixed-replace") - 1
    };

static const char szDefaultExtension[] = "txt";

LPSTR rgszExcludeHeaders[] = {
    HTTP_SET_COOKIE_SZ,
    HTTP_LAST_MODIFIED_SZ,
    HTTP_SERVER_SZ,
    HTTP_DATE_SZ,
    HTTP_EXPIRES_SZ,
    HTTP_CONNECTION_SZ,
    HTTP_PROXY_CONNECTION_SZ,
    HTTP_VIA_SZ,
    HTTP_VARY_SZ,
    HTTP_AGE_SZ,
    HTTP_CACHE_CONTROL_SZ,
    HTTP_ACCEPT_RANGES_SZ,
    HTTP_CONTENT_DISPOSITION_SZ
    };

const char vszUserNameHeader[4] = "~U:";

//
// HTTP Request Handle Object methods
//


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FCanWriteToCache(
    VOID
    )

/*++

Routine Description:

    Determines if we can write this file to the cache

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FCanWriteToCache",
                 NULL
                 ));

    PERF_LOG(PE_CACHE_WRITE_CHECK_START);

    BOOL ok = FALSE;

    BOOL fForceToCache = FALSE;
    BOOL fCheckNeedFile = FALSE;

    BOOL fVary = FALSE;
    BOOL fContentEnc = FALSE;

    //
    // Set fNoCache if there is pragma: no-cache
    //

    BOOL fNoCache = FALSE;
    DWORD length, index;
    LPSTR lpszBuf;

    _ResponseHeaders.LockHeaders();

    if (GetOpenFlags() & INTERNET_FLAG_SECURE)
    {
        SetPerUserItem(TRUE);

        //
        // Determine if there are any Pragma: no-cache headers.
        //

        index = 0;

        while ( FastQueryResponseHeader(HTTP_QUERY_PRAGMA,
                                        (LPVOID *) &lpszBuf,
                                        &length,
                                        index) == ERROR_SUCCESS )
        {
            if (length == NO_CACHE_LEN &&
                strnicmp(NO_CACHE_SZ, lpszBuf, NO_CACHE_LEN) == 0)
            {
                fNoCache = TRUE;
                break;
            }

            index++;
        }

        if (fNoCache)
        {
            if(GlobalBypassSSLNoCacheCheck)
            {
                goto check_need_file;
            }

            // If server disabled caching over SSL, don't even create
            // a file, let alone commit it to the cache.  Game over.
            BETA_LOG (DOWNLOAD_NO_FILE);
            goto quit;
        }
    
        //
        // If we've disabled caching for SSL servers, consider creating
        // a download file if the client insists upon it.
        //

        if (GlobalDisableSslCaching)
        {
            goto check_need_file;
        }
    }

    //
    // Also set fNoCache if there is Cache-Control: no-cache or no-store header,
    // if there is a Cache-Control: private header and we're *not* on NT with user profiles,
    // or any Vary: headers. These are only checked for HTTP 1.1 servers.
    //

    if (IsResponseHttp1_1())
    {
        CHAR *ptr, *pToken;
        index = 0;

        // Scan for Cache-Control header.
        while (FastQueryResponseHeader(HTTP_QUERY_CACHE_CONTROL,
                                    (LPVOID *) &lpszBuf,
                                    &length,
                                    index) == ERROR_SUCCESS)
        {
            // Check for no-cache or no-store or private.
            CHAR chTemp = lpszBuf[length];

            lpszBuf[length] = '\0';
            pToken = ptr = lpszBuf;
            // Parse a token from the string; test for sub headers.
            while (*pToken != '\0')
            {
                SKIPWS(pToken);

                // no-cache, no-store.
                if (strnicmp(NO_CACHE_SZ, pToken, NO_CACHE_LEN) == 0)
                {
                    fNoCache = TRUE;
                    break;
                }
                if( strnicmp(NO_STORE_SZ, pToken, NO_STORE_LEN) == 0) 
                {
                    fNoCache = TRUE;
                    fCheckNeedFile = TRUE;
                }

                // private.
                if (strnicmp(PRIVATE_SZ, pToken, PRIVATE_LEN) == 0)
                {
                    SetPerUserItem(TRUE);
                }

                while (*pToken != '\0')
                {
                    if ( *pToken == ',')
                    {
                        pToken++;
                        break;
                    }

                    pToken++;
                }

            } // while (*pToken != '\0')

            //
            // We've finished parsing it, now return our terminator back to its proper place
            //

            lpszBuf[length] = chTemp;

            // If fNoCache, we're done. Break out of switch.
            if (fNoCache)
                break;

            index++;

        } // while FastQueryResponseHeader == ERROR_SUCCESS

        if (fNoCache)
        {
            if( fCheckNeedFile ) 
            {
                // cache-control: no store
                goto check_need_file;
            }
            else 
            if ((GetOpenFlags() & INTERNET_FLAG_SECURE) && !GlobalBypassSSLNoCacheCheck)
            {
                // If server disabled caching over SSL, don't even create
                // a file, let alone commit it to the cache.  Game over.
                BETA_LOG (DOWNLOAD_NO_FILE);
                goto quit;
            }
            else
            {
                //
                // This is not SSL/PCT, so don't cache but consider creating a
                // download file if one was requested.
                //

                goto check_need_file;
            }
        }

        // Finally, check if any Vary: headers exist, EXCEPT "Vary: User-Agent"

        index = 0;
        if (FastQueryResponseHeader(HTTP_QUERY_VARY,
                                    (LPVOID *) &lpszBuf,
                                    &length,
                                    index) == ERROR_SUCCESS
            && !(length == USER_AGENT_LEN
               && !strnicmp (lpszBuf, USER_AGENT_SZ, length)) )
        {
            // content-encoding? 
            if (FastQueryResponseHeader(HTTP_QUERY_CONTENT_ENCODING,
                                    (LPVOID *) &lpszBuf,
                                    &length,
                                    index) == ERROR_SUCCESS ) 
            {
                fContentEnc = TRUE;
            }
            fVary = TRUE;
            goto check_need_file;
        }
    }

    if (GetCacheFlags() & INTERNET_FLAG_NO_CACHE_WRITE)
    {
        goto check_need_file;
    }

    //
    // accept HTTP/1.0 or downlevel server responses
    //

    if ((GetStatusCode() == HTTP_STATUS_OK) || (GetStatusCode() == 0))
    {
        if (FastQueryResponseHeader(HTTP_QUERY_CONTENT_TYPE, (LPVOID *) &lpszBuf, &length, 0) == ERROR_SUCCESS)
        {
            if (FExcludedMimeType(lpszBuf, length))
            {

                DEBUG_PRINT(CACHE,
                            INFO,
                            ("%s Mime Excluded from caching\n",
                            lpszBuf
                            ));

                goto check_need_file;
            }
        }

        //
        // BUGBUG should we also check for size and keep an upper bound?
        //

        ok = TRUE;
        goto quit;

    }
    else
    {
        INTERNET_SCHEME schemeType = GetSchemeType();

        if ((schemeType == INTERNET_SCHEME_FTP)
        || (schemeType == INTERNET_SCHEME_GOPHER))
        {
            ok = TRUE;
            goto quit;
        }
    }

check_need_file:

    INET_ASSERT (!ok);

    if (GetCacheFlags() & INTERNET_FLAG_NEED_FILE
        || GetCacheFlags () & INTERNET_FLAG_HYPERLINK
        || (GlobalBypassSSLNoCacheCheck && fNoCache))
    {
        //
        // Create a download file but don't commit it to the cache.
        //

        BETA_LOG (DOWNLOAD_FILE_NEEDED);

        fForceToCache = !ok;
        ok = TRUE;
        if( !fContentEnc )
        {
            // if content-enc, the client will write to cache...
            // so we should not delete the data file
            SetDeleteDataFile();
        }

        DEBUG_PRINT(CACHE, INFO, ("don't commit file\n"));
    }
    else
    {
        BETA_LOG (DOWNLOAD_FILE_NOT_NEEDED);
    }

quit:

    if ((!ok || fForceToCache) && !fVary)
    {
        SetCacheWriteDisabled();

        // Deleting originally cached files if (& only if) the server sends cache-control headers.
        // Bugs 98644 and 101578
        if (fNoCache)
        {
            _RequestHeaders.LockHeaders();

            // In 5.0, Rosebud worked like this:

            // 1. A call to CommitUrlCacheEntry with a file size of about 11 bytes.
            // 2. A call to HttpSendRequest. 
            // 3. A call to DeleteUrlCacheEntry that succeeds.
            // 4. Another call to CommitUrlCacheEntry for the same file, except it's grown.
            // 5. Repeat 3 and 4 until file is downloaded.

            // However, we made a change so that if the server sends "no-cache", we'll
            // delete any cache entry during the call in (2). This caused Rosebud to break
            // We don't want to go back to the original behaviour, since that would introduce
            // IE 94486. So we look for a Translate: F header to guide us.

            DWORD dwIndex = 0;
            BOOL fFound = FALSE;
            TCHAR szValue[MAX_PATH];
            DWORD ccValue = ARRAY_ELEMENTS(szValue);
            while (ERROR_SUCCESS==QueryRequestHeader(
                                       "Translate",
                                       ARRAY_ELEMENTS("Translate")-1,
                                       (LPVOID)szValue,
                                       &ccValue,
                                       0,
                                       &dwIndex))
            {
                if (!StrCmpI(szValue, "F"))
                {
                    fFound = TRUE;
                    break;
                }
                ccValue = ARRAY_ELEMENTS(szValue);
            }

            _RequestHeaders.UnlockHeaders();
            if (!fFound)
            {
                DeleteUrlCacheEntry(GetOriginalUrl());
            }
        }
    }
    
    _ResponseHeaders.UnlockHeaders();

    PERF_LOG(PE_CACHE_WRITE_CHECK_END);

    DEBUG_LEAVE(ok);

    return ok;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader(
    IN LPCACHE_ENTRY_INFO lpCEI
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpCEI   -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FAddIfModifiedSinceHeader",
                 "%#x",
                 lpCEI
                 ));

    PERF_ENTER(FAddIfModifiedSinceHeader);

    char buff[64], buffh[256];
    DWORD dwLen, error;
    BOOL success = FALSE;

    INET_ASSERT (FT2LL(lpCEI->LastModifiedTime));

    dwLen = sizeof(buff);

    if (FFileTimetoHttpDateTime(&(lpCEI->LastModifiedTime), buff, &dwLen))
    {
        LPSTR pszBuf;

        if (lpCEI->CacheEntryType & HTTP_1_1_CACHE_ENTRY)
        {
            INET_ASSERT (dwLen);
            pszBuf = buff;
        }
        else
        {
            dwLen = wsprintf(buffh, "%s; length=%d", buff, lpCEI->dwSizeLow);
            pszBuf = buffh;
        }

        DEBUG_PRINT(CACHE,
                    INFO,
                    ("%s %s - empty\n",
                    GlobalKnownHeaders[HTTP_QUERY_IF_MODIFIED_SINCE].Text,
                    buffh
                    ));

        error = ReplaceRequestHeader(HTTP_QUERY_IF_MODIFIED_SINCE,
                                     pszBuf,
                                     dwLen,
                                     0,                 // no index
                                     ADD_HEADER_IF_NEW
                                     );
        if ((error == ERROR_SUCCESS) || (error == ERROR_HTTP_HEADER_ALREADY_EXISTS))
        {
            if (error == ERROR_SUCCESS)
            {
                // we added the header on behalf of the app. This is equivalent
                // to the app having specified INTERNET_FLAG_RESYNCHRONIZE

                SetAutoSync();
            }
            success = TRUE;
        }
    }

    PERF_LEAVE(FAddIfModifiedSinceHeader);
    DEBUG_LEAVE(success);
    return success;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::AddHeaderIfEtagFound(
    IN LPCACHE_ENTRY_INFO lpCEI
    )

/*++

Routine Description:

    Adds if-modified-since header if an etag was present in the cache entry headers.

Arguments:

    lpCEI   -

Return Value:

    BOOL

--*/

{
    if (!(lpCEI->CacheEntryType & HTTP_1_1_CACHE_ENTRY))
        return TRUE;

    // BUGBUG - always parsing, use flag.
    CHAR buf[512];

    DWORD nIndex = 0, cbBuf = 512, dwError = ERROR_SUCCESS;

    HTTP_HEADER_PARSER hp((CHAR*) lpCEI->lpHeaderInfo, lpCEI->dwHeaderInfoSize);

    if (hp.FindHeader((CHAR*) lpCEI->lpHeaderInfo, HTTP_QUERY_ETAG,
            0, buf, &cbBuf, &nIndex) == ERROR_SUCCESS)
    {
        DWORD dwQueryIndex;

        if (lpCEI->CacheEntryType & SPARSE_CACHE_ENTRY)
        {
            dwQueryIndex = HTTP_QUERY_IF_RANGE;
        }
        else
        {
            dwQueryIndex = HTTP_QUERY_IF_NONE_MATCH;
        }

        dwError = ReplaceRequestHeader(dwQueryIndex,
                                       buf,
                                       cbBuf,
                                       0,
                                       ADD_HEADER_IF_NEW
                                       );
    }

    if ((dwError == ERROR_SUCCESS) || (dwError == ERROR_HTTP_HEADER_ALREADY_EXISTS))
        return TRUE;

    return FALSE;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheRetrieval(
    IN BOOL bReset,
    IN BOOL bOffline,
    IN BOOL bNoRetrieveIfExist
    )

/*++

Routine Description:

    Starts retrieving data for this object from the cache

Arguments:

    bReset  - if TRUE, forcefully reset the (keep-alive) connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheRetrieval",
                 "%B, %B",
                 bReset,
                 bOffline
                 ));

    PERF_LOG(PE_CACHE_RETRIEVE_START);

    DWORD error;
    LPSTR lpHeaders = NULL;

    if (bOffline)
    {
        if (!IsOffline() && IsCacheReadDisabled())
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }

        if( !bNoRetrieveIfExist )
            error = UrlCacheRetrieve (TRUE);
        else
            error = ERROR_SUCCESS;

        if (error != ERROR_SUCCESS)
            goto quit2;
    }

    INET_ASSERT(_hCacheStream && _pCacheEntryInfo);

    //
    // RecordCacheRetrieval() will set end-of-file if it succeeds
    //

    error = RecordCacheRetrieval (_pCacheEntryInfo);
    if (error != ERROR_SUCCESS)
    {
        UrlCacheUnlock();
        goto quit2;
    }


    if (bOffline && lstrcmp(_pCacheEntryInfo->lpszSourceUrlName, GetCacheKey()))
    {
        // Simulate a redirect to the client.
        InternetIndicateStatusString
            (INTERNET_STATUS_REDIRECT, _pCacheEntryInfo->lpszSourceUrlName);

        // The cache translated through a redirect.
        FreeSecondaryCacheKey (); // POST redirects must be to GET
        SetURL (_pCacheEntryInfo->lpszSourceUrlName);
    }

    if (bOffline &&
        (_pCacheEntryInfo->CacheEntryType & MUST_REVALIDATE_CACHE_ENTRY))
    {
        INET_ASSERT (_pCacheEntryInfo->CacheEntryType & HTTP_1_1_CACHE_ENTRY);
        
        // Offline mode. Check for a Cache-Control: must-revalidate header.
        // If so, allow cache data to be retrieved only if not expired.
        FILETIME ftCurrentTime;
        GetCurrentGmtTime(&ftCurrentTime);

        LONGLONG qwExpire = FT2LL(_pCacheEntryInfo->ExpireTime);
        LONGLONG qwCurrent = FT2LL(ftCurrentTime);

        if (qwCurrent > qwExpire)
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }
        else
        {
            goto check_if_modified_since;
        }
    }

check_if_modified_since:

    if (!IsOffline() && IsCacheReadDisabled())
    {
        //
        // We are in offline mode.  (Really should assert this.)
        // Allow cache data to be retrieved only if last-modified time is
        // STRICTLY greater than if-modified-since time added by client.
        //

        LONGLONG qwLastModified = FT2LL(_pCacheEntryInfo->LastModifiedTime);

        LONGLONG qwIfModifiedSince;
        SYSTEMTIME stIfModifiedSince;
        DWORD length = sizeof(stIfModifiedSince);
        DWORD index = 0;

        _RequestHeaders.LockHeaders();

        error = QueryRequestHeader(HTTP_QUERY_IF_MODIFIED_SINCE,
                                   &stIfModifiedSince,
                                   &length,
                                   HTTP_QUERY_FLAG_SYSTEMTIME,
                                   &index
                                   );

        _RequestHeaders.UnlockHeaders();

        if (error != ERROR_SUCCESS)
        {
            // It's theoretically possible the client was redirected,
            // removed i-m-s on redirect callback, then went offline.
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }

        if (!SystemTimeToFileTime(&stIfModifiedSince,
                                  (FILETIME*)&qwIfModifiedSince))
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }

        if (qwLastModified <= qwIfModifiedSince)
        {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }
    }

    // allocate buffer for headers

    lpHeaders = (LPSTR)ALLOCATE_FIXED_MEMORY(_pCacheEntryInfo->dwHeaderInfoSize);
    if (!lpHeaders)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    memcpy(lpHeaders, _pCacheEntryInfo->lpHeaderInfo, _pCacheEntryInfo->dwHeaderInfoSize);

    // we are hijacking the HTTP request object. If there is already
    // a pending network operation (we started a network transaction
    // but realised that we have the same data in cache (i.e. the
    // data has not expired since we last wrote it to cache)) then
    // we need to kill it

    if (bReset)
    {   
        // if we have a keep-alive connection AND the server returned
        // 304 then the parameter can be FALSE so that we don't kill
        // the connection, just release it
        //
        // ResetObject() will reset end-of-file if it succeeds
        //
        // We DO NOT clear out the request headers so that the app can still
        // query them if necessary

//dprintf(">>> resetting %s\n", GetURL());
        error = ResetObject(!(IsKeepAlive() && (GetBytesInSocket() == 0)), FALSE);
        if (error != ERROR_SUCCESS)
            goto quit;
    }

    error = CreateResponseHeaders(&lpHeaders, _pCacheEntryInfo->dwHeaderInfoSize);
    if (error != ERROR_SUCCESS)
        goto quit;

    error = AddTimestampsFromCacheToResponseHeaders(_pCacheEntryInfo);
    if (error != ERROR_SUCCESS) 
        goto quit;

    /* Send notification about past cookie-events on this URL */
    InternetCookieHistory history;
    DWORD dwEntryType = _pCacheEntryInfo->CacheEntryType;

    history.fAccepted   = (dwEntryType & COOKIE_ACCEPTED_CACHE_ENTRY);
    history.fLeashed    = (dwEntryType & COOKIE_LEASHED_CACHE_ENTRY);
    history.fDowngraded = (dwEntryType & COOKIE_DOWNGRADED_CACHE_ENTRY);
    history.fRejected   = (dwEntryType & COOKIE_REJECTED_CACHE_ENTRY);    

    if (history.fAccepted   || 
        history.fLeashed    ||
        history.fDowngraded ||
        history.fRejected)
        InternetIndicateStatus (INTERNET_STATUS_COOKIE_HISTORY, 
                                (void*) &history, 
                                sizeof(history));

    /* Reevaluate P3P policy to generate policy notifications */ 
    ExtractSetCookieHeaders(NULL);

    // we have to set end-of-file again: RecordCacheRetrieval() set
    // it, then we wiped it out in ResetObject()
    // FYI: We set end-of-file because we have all the data in the
    // stream available locally; it doesn't mean that our virtual
    // stream pointer is positioned at the end of the file

    DEBUG_PRINT(CACHE, INFO, ("Found in the cache\n"));

    SetState(HttpRequestStateObjectData);
    SetFromCache();
    SetEndOfFile();
    SetHaveContentLength(TRUE);
    _VirtualCacheFileSize =
        _RealCacheFileSize =
            _BytesRemaining =
                _ContentLength = _pCacheEntryInfo->dwSizeLow;

    INET_ASSERT (error == ERROR_SUCCESS);

quit:
    if (error != ERROR_SUCCESS)
        EndCacheRetrieval();
    if (lpHeaders)
        FREE_MEMORY(lpHeaders);

quit2:

    PERF_LOG(PE_CACHE_RETRIEVE_END);
    DEBUG_LEAVE(error);
    return error;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite(
    VOID
    )

/*++

Routine Description:

    Preps the cache for writing. Sets up the cache filename with an extension
    based on the MIME type and optionally writes the headers to the cache data
    stream

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - Success

        FALSE   - Failure

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FHttpBeginCacheWrite",
                 NULL
                 ));

    PERF_ENTER(FHttpBeginCacheWrite);

    INET_ASSERT(!IsCacheReadInProgress());
    INET_ASSERT(!IsCacheWriteInProgress());

    PERF_TRACE(FHttpBeginCacheWrite, 1);

    _ResponseHeaders.LockHeaders();

    LPSTR lpszFileExtension = NULL;
    BOOL fIsUncertainMime = FALSE;
    char cExt[DEFAULT_MAX_EXTENSION_LENGTH + 1];
    char buf[256];

    DWORD dwLen, cbFileName, dwIndex;
    CHAR *ptr, *pToken, *pszFileName = NULL;
    CHAR szFileName[MAX_PATH];
    LPSTR lpszBuf;

    // Create a temp local cache file.

    // If we find a Content-Disposition header, parse out any filename and use it.
    if (QueryResponseHeader (HTTP_QUERY_CONTENT_DISPOSITION,
        buf, &(dwLen = sizeof(buf)), 0, &(dwIndex = 0) ) == ERROR_SUCCESS)
    {
        // Could have multiple tokens in it. Scan for the "filename" token.
        ptr = pToken = buf;
        while (ptr = StrTokEx2(&pToken, ";"))
        {
            // Skip any leading ws in token.
            SKIPWS(ptr);

            // Compare against "filename".
            if (!strnicmp(ptr, FILENAME_SZ, FILENAME_LEN))
            {
                // Found it.
                ptr += FILENAME_LEN;

                // Skip ws before '='.
                SKIPWS(ptr);

                // Must have '='
                if (*ptr == '=')
                {
                    // Skip any ws after '=' and point
                    // to beginning of the file name
                    ptr++;
                    SKIPWS(ptr);

                    // Skip past any quotes
                    if (*ptr == '\"')
                        ptr++;

                    SKIPWS(ptr);

                    cbFileName = strlen(ptr);

                    if (cbFileName)
                    {
                        // Ignore any trailing quote.
                        if (ptr[cbFileName-1] == '\"')
                            cbFileName--;
                            
                        memcpy(szFileName, ptr, cbFileName);
                        szFileName[cbFileName] = '\0';
                        pszFileName = szFileName;
                    }
                }
                break;
            }
        }
    }

    // Either no Content-disposition header or filename not parsed.
    if (!pszFileName)
    {
        DWORD dwMimeLen;
        if ((FastQueryResponseHeader(HTTP_QUERY_CONTENT_ENCODING, (LPVOID *) &lpszBuf, &dwMimeLen, 0) == ERROR_SUCCESS) && 
            StrCmpNI(lpszBuf,"binary",6) )
        {
            // if there is content encoding, we should not use
            // content-type for file extension

            //Modifying this for bug 98611.
            //For 'binary' encoding use the Content-Type to find extension
            lpszFileExtension = NULL;
        }

        else if (FastQueryResponseHeader(HTTP_QUERY_CONTENT_TYPE, (LPVOID *) &lpszBuf, &dwMimeLen, 0) == ERROR_SUCCESS)
        {
            dwLen = sizeof(cExt);
            fIsUncertainMime = strnicmp(lpszBuf, "text/plain", dwMimeLen)==0;

            PERF_TRACE(FHttpBeginCacheWrite, 2);

            if (!fIsUncertainMime &&
                GetFileExtensionFromMimeType(lpszBuf, dwMimeLen, cExt, &dwLen))
            {

                //
                // get past the '.' because the cache expects it that way
                //

                lpszFileExtension = &cExt[1];
            }
        }

        //
        // if we couldn't get the MIME type or failed to map it then try to get
        // the file extension from the object name requested
        //

        if (lpszFileExtension == NULL)
        {
            dwLen = sizeof(cExt);

            PERF_TRACE(FHttpBeginCacheWrite, 3);

            lpszFileExtension = GetFileExtensionFromUrl(GetURL(), &dwLen);
            if (lpszFileExtension != NULL)
            {
                memcpy(cExt, lpszFileExtension, dwLen);
                cExt[dwLen] = '\0';
                lpszFileExtension = cExt;
            }

            PERF_TRACE(FHttpBeginCacheWrite, 4);

        }

        if ((lpszFileExtension == NULL) && fIsUncertainMime)
        {

            INET_ASSERT(sizeof(szDefaultExtension) < DEFAULT_MAX_EXTENSION_LENGTH);

            strcpy(cExt, szDefaultExtension);
            lpszFileExtension = cExt;
        }
    }

    //
    // BUGBUG - BeginCacheWrite() wants the estimated file size, but we just
    //          give it 0 for now
    //

    //dwError = pRequest->BeginCacheWrite(dwLen, lpszFileExtension);

    PERF_TRACE(FHttpBeginCacheWrite, 5);

    DWORD dwError = BeginCacheWrite(0, lpszFileExtension, pszFileName);

    PERF_TRACE(FHttpBeginCacheWrite, 6);

    _ResponseHeaders.UnlockHeaders();

    PERF_LEAVE(FHttpBeginCacheWrite);

    BOOL success = (dwError == ERROR_SUCCESS);

    DEBUG_LEAVE(success);

    return success;
}


/*============================================================================
IsExpired (...)

4/17/00 (RajeevD) Corrected back arrow behavior and wrote detailed comment.
 
We have a cache entry for the URL.  This routine determines whether we should
synchronize, i.e. do an if-modified-since request.  This answer depends on 3
factors: navigation mode, expiry on cache entry if any, and syncmode setting.

1. There are two navigation modes:
a. hyperlinking - clicking on a link, typing a URL, starting browser etc.
b. back/forward - using the back or forward buttons in the browser.

In b/f case we generally want to display what was previously shown.  Ideally
wininet would cache multiple versions of a given URL and trident would specify
which one to use when hitting back arrow.  For now, the best we can do is use
the latest (only) cache entry or resync with the server.

EXCEPTION: if the cache entry sets http/1.1 cache-control: must-revalidate,
we treat as if we were always hyperlinking to the cache entry.  This is 
normally used during offline mode to suppress using a cache entry after
expiry.  This overloaded usage gives sites a workaround if they dislike our
new back button behavior.

2. Expiry may fall into one of 3 buckets:
a. no expiry information
b. expiry in past of current time (hyperlink) or last-access time (back/fwd)
c. expiry in future of current time (hyperlink) or-last access time (back/fwd)

3. Syncmode may have 3 settings
a. always - err on side of freshest data at expense of net perf.
b. never - err on side of best net perf at expense of stale data.
c. once-per-session - middle-of-the-road setting
d. automatic - slight variation of once-per-session where we decay frequency
of i-m-s for images that appear to be static.  This is the default.

Based on these factors, there are 5 possible result values in matrices below:
1   synchronize
0   don't synchronize
?   synchronize if last-sync time was before start of the current session, 
?-  Like per-session except if URL is marked static and has a delay interval.
0+  Don't sync if URL is marked static, else fall back to per-session


HYPERLINKING

When hyperlinking, expiry takes precedence, then we look at syncmode.

                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Current Time     of Current Time
                               
   Always           1                   0                   1  


   Never            0                   0                   1


   Per-Session      ?                   0                   1


   Automatic        ?-                  0                   1

   
BACK/FORWARD

When going back or forward, we generally don't sync.  The exception is if
we should have sync'ed the URL on the previous navigate but didn't.  We
deduce this by looking at the last-sync time of the entry.


                No Expiry       Expiry in Future    Expiry in Past
Syncmode                        of Last-Access Time of Last-Access Time
    
   Always           ?                   0                   ?


   Never            0                   0                   ?


   Per-Session      ?                   0                   ?


   Automatic        0+                  0                   ?


When considering what might have happened when hyperlinking to this URL,
the decision tree has 5 outcomes:
1. We might have had no cache entry and downloaded to cache for the first time
2. Else we might have had a cache entry and used it w/o i-m-s
3. Else we did i-m-s but the download was aborted
4. Or the i-m-s returned not modified
5. Or the i-m-s returned new content
Only in case 3 do we want to resync the cache entry.

============================================================================*/

BOOL IsExpired (
        CACHE_ENTRY_INFOEX* pInfo, 
        DWORD dwCacheFlags, 
        BOOL* pfLazyUpdate )
{
    BOOL fExpired;
    FILETIME ftCurrentTime;
    GetCurrentGmtTime (&ftCurrentTime);

    if ((dwCacheFlags & INTERNET_FLAG_FWD_BACK)
        && !(pInfo->CacheEntryType & MUST_REVALIDATE_CACHE_ENTRY))
    {
        // BACK/FORWARD CASE

        if (FT2LL (pInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // We have an expires time.
            if (FT2LL (pInfo->ExpireTime) > FT2LL(pInfo->LastAccessTime))
            {
                // Expiry was in future of last access time, so don't resync.
                fExpired = FALSE;
            }                
            else
            {
                // Entry was originally expired.  Make sure it was sync'ed once.
                fExpired = (FT2LL(pInfo->LastSyncTime) < dwdwSessionStartTime);
            }
        }
        else switch (GlobalUrlCacheSyncMode)
        {
            default:
            case WININET_SYNC_MODE_AUTOMATIC:
                if (pInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    fExpired = FALSE;
                    break;
                }
            // else intentional fall-through...
        
            case WININET_SYNC_MODE_ALWAYS:
            case WININET_SYNC_MODE_ONCE_PER_SESSION:
                fExpired = (FT2LL(pInfo->LastSyncTime) < dwdwSessionStartTime);
                break;

            case WININET_SYNC_MODE_NEVER:
                fExpired = FALSE;
                break;
                
        } // end switch
    }
    else
    {
        // HYPERLINKING CASE

        // Always strictly honor expire time from the server.
        INET_ASSERT(pfLazyUpdate);
        *pfLazyUpdate = FALSE;
        
        if(   (pInfo->CacheEntryType & POST_CHECK_CACHE_ENTRY ) &&
             !(dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
        {
            //
            // this is the (instlled) post check cache entry, so we will do
            // post check on this ietm
            //
            fExpired = FALSE;
            *pfLazyUpdate = TRUE;
            
        }
        else if (FT2LL(pInfo->ExpireTime) != LONGLONG_ZERO)
        {
            // do we have postCheck time?
            //
            //           ftPostCheck                   ftExpire
            //               |                            |
            // --------------|----------------------------|-----------> time
            //               |                            | 
            //   not expired |   not expired (bg update)  |   expired
            //
            //               
            LONGLONG qwPostCheck = FT2LL(pInfo->ftPostCheck);
            if( qwPostCheck != LONGLONG_ZERO )
            {
                LONGLONG qwCurrent = FT2LL(ftCurrentTime);

                if( qwCurrent < qwPostCheck )
                {
                    fExpired = FALSE;
                }
                else
                if( qwCurrent < FT2LL(pInfo->ExpireTime) ) 
                {
                    fExpired = FALSE;

                    // set background update flag  
                    // (only if we are not doing lazy updating ourselfs)
                    if ( !(dwCacheFlags & INTERNET_FLAG_BGUPDATE) )
                    {
                        *pfLazyUpdate = TRUE;
                    }
                }
                else
                {
                    fExpired = TRUE;
                }
            }
            else 
                fExpired = FT2LL(pInfo->ExpireTime) <= FT2LL(ftCurrentTime);
        }
        else switch (GlobalUrlCacheSyncMode)
        {

            case WININET_SYNC_MODE_NEVER:
                // Never check, unless the page has expired
                fExpired = FALSE;
                break;

            case WININET_SYNC_MODE_ALWAYS:
                fExpired = TRUE;
                break;

            default:
            case WININET_SYNC_MODE_AUTOMATIC:

                if (pInfo->CacheEntryType & STATIC_CACHE_ENTRY)
                {
                    // We believe this entry never actually changes.
                    // Check the entry if interval since last checked
                    // is less than 25% of the time we had it cached.
                    LONGLONG qwTimeSinceLastCheck = FT2LL (ftCurrentTime)
                        - FT2LL(pInfo->LastSyncTime);
                    LONGLONG qwTimeSinceDownload = FT2LL (ftCurrentTime)
                        - FT2LL (pInfo->ftDownload);
                    fExpired = qwTimeSinceLastCheck > qwTimeSinceDownload/4;
                    break;
                }
                // else intentional fall through to once-per-session rules.

            case WININET_SYNC_MODE_ONCE_PER_SESSION:

                fExpired = TRUE;

                // Huh. We don't have an expires, so we'll improvise
                // but wait! if we are hyperlinking then there is added
                // complication. This semantic has been figured out
                // on Netscape after studying various sites
                // if the server didn't send us expiry time or lastmodifiedtime
                // then this entry expires when hyperlinking
                // this happens on queries

                if (dwCacheFlags & INTERNET_FLAG_HYPERLINK
                    && !FT2LL(pInfo->LastModifiedTime))
                {
                    // shouldn't need the hyperlink test anymore
                    DEBUG_PRINT(UTIL, INFO, ("Hyperlink semantics\n"));
                    INET_ASSERT(fExpired==TRUE);
                    break;
                }

                // We'll assume the data could change within a day of the last time
                // we sync'ed.
                // We want to refresh UNLESS we've seen the page this session
                // AND the session's upper bound hasn't been exceeded.
                if      ((dwdwSessionStartTime < FT2LL(pInfo->LastSyncTime))
                    &&
                        (FT2LL(ftCurrentTime) < FT2LL(pInfo->LastSyncTime) + 
                            dwdwHttpDefaultExpiryDelta))
                {                    
                    fExpired = FALSE;
                }            
                break;

        } // end switch
        
    } // end else for hyperlinking case
        

#ifdef DBG
        char buff[64];
        PrintFileTimeInInternetFormat(&ftCurrentTime, buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Current Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->ExpireTime), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Expiry Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->ftPostCheck), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("PostCheck Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->LastSyncTime), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Last Sync Time: %s\n", buff));
        PrintFileTimeInInternetFormat(&(pInfo->ftDownload), buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Last Download Time: %s\n", buff));
        PrintFileTimeInInternetFormat((FILETIME *)&dwdwSessionStartTime, buff, sizeof(buff));
        DEBUG_PRINT(UTIL, INFO, ("Session start Time: %s\n", buff));
        DEBUG_PRINT(UTIL, INFO, ("CacheFlags=%x\n", dwCacheFlags));
        DEBUG_PRINT(HTTP, INFO,
            ("CheckExpired: Url %s Expired \n", (fExpired ? "" : "Not")));
#endif //DBG
        
    return fExpired;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePreNetIO(
    VOID
    )

/*++

Routine Description:

    Check if in the cache. If so, check for expired, if expired do if-modified
    -since, else get from the cache.

Arguments:

    None.

Return Value:

    DWORD   Windows Error Code
        ERROR_SUCCESS: started retrieval from the cache
        ERROR_FILE_NOT_FOUND: go to the wire

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePreNetIO",
                 NULL
                 ));

    PERF_LOG(PE_CACHE_EXPIRY_CHECK_START);

    DWORD error = ERROR_FILE_NOT_FOUND;

    if (_pCacheEntryInfo || IsCacheReadDisabled())
    {
        INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
        goto done;
    }

    PERF_LOG(PE_TRACE, 0x91);

    //
    // See if we have a cache entry and if so lock it.
    //

    // Check for the cdrom insertion case Set error to
    // ERROR_INTERNET_INSERT_CDROM ONLY only in this
    // case, since this will be handled. Otherwise,
    // error defaults to ERROR_FILE_NOT_FOUND.
    DWORD dwError;
    dwError = UrlCacheRetrieve(FALSE);
    if (dwError != ERROR_SUCCESS)
    {
        if (dwError == ERROR_INTERNET_INSERT_CDROM)
            error = dwError;
        else
            BETA_LOG (CACHE_MISS);
        goto done;
    }

    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
    {

        //
        // Open the file so it can't be deleted.
        //

        _CacheFileHandle =
            CreateFile
            (
                _pCacheEntryInfo->lpszLocalFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

        //
        // Check the file size.
        //

        if (_CacheFileHandle == INVALID_HANDLE_VALUE
            || (_pCacheEntryInfo->dwSizeLow !=
               SetFilePointer (_CacheFileHandle, 0, NULL, FILE_END)))
        {

            FREE_MEMORY (_pCacheEntryInfo);
            _pCacheEntryInfo = NULL;
            INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
            goto done;
        }

        // We have a partial cache entry for this URL.  No need to check
        // for expiry or correct user.  Add a Range: header to get the
        // rest of the data.

        char szBuf[64];
        DWORD cbBuf =
            wsprintf (szBuf, "bytes=%d-", _pCacheEntryInfo->dwSizeLow);
        if (ERROR_SUCCESS != ReplaceRequestHeader
            (HTTP_QUERY_RANGE, szBuf, cbBuf, 0, ADD_HEADER))
        {
            goto done;
        }

        //
        // If there was Last-Modified-Time, add Unless-Modified-Since header,
        // which assures coherency in the event the URL data changed since
        // the partial download.
        //
        if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
        {
            cbBuf = sizeof(szBuf);
            FFileTimetoHttpDateTime(&(_pCacheEntryInfo->LastModifiedTime),
                szBuf, &cbBuf);

            ReplaceRequestHeader (
                HTTP_QUERY_UNLESS_MODIFIED_SINCE,
                szBuf, cbBuf, 0, ADD_HEADER
            );
        }

        //
        // Similarly, if the entry has a 1.1 ETag, add the If-Range header.
        //

        AddHeaderIfEtagFound(_pCacheEntryInfo);

    }
    else
    {
        PERF_LOG(PE_TRACE, 0x93);

        BOOL fIsExpired = IsExpired 
            (_pCacheEntryInfo, GetCacheFlags(), &_fLazyUpdate);


        PERF_LOG(PE_TRACE, 0x94);

        //
        // found the cache entry
        // if it is expired, or we are asked to do if-modified-since
        // then we do it. However, if the entry is an Installed entry,
        // we skip netio unless the entry is also marked EDITED_CACHE_ENTRY
        // and the client has specifically asked for
        // INTERNET_OPTION_BYPASS_EDITED_ENTRY.

        if ((!(_pCacheEntryInfo->CacheEntryType & INSTALLED_CACHE_ENTRY)
            || ((_pCacheEntryInfo->CacheEntryType & EDITED_CACHE_ENTRY)
            && GlobalBypassEditedEntry))
             && (fIsExpired || (GetCacheFlags() & INTERNET_FLAG_RESYNCHRONIZE)
             ))
        {

            //
            // add if-modified-since only if there is lastmodifiedtime
            // sent back by the site. This way you never get into trouble
            // where the sitedoesn't send you an lastmodtime and you
            // send if-modified-since based on a clock which might be ahead
            // of the site. So the site might say nothing is modified even though
            // something might be. www.microsoft.com is one such example
            //
            if (FT2LL(_pCacheEntryInfo->LastModifiedTime) != LONGLONG_ZERO)
            {
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("%s expired, doing IF-MODIFIED-SINCE\n",
                            GetURL()
                            ));

                PERF_LOG(PE_TRACE, 0x97);
                FAddIfModifiedSinceHeader(_pCacheEntryInfo);
                PERF_LOG(PE_TRACE, 0x98);
            }

            // If this is an HTTP 1.1 then check to see if an Etag:
            // header is present and add an If-None-Match header.
            AddHeaderIfEtagFound(_pCacheEntryInfo);

            INET_ASSERT(error == ERROR_FILE_NOT_FOUND);

        }
        else
        {

            //
            // The cache entry is not expired, so we don't hit the net.
            //

            BETA_LOG (CACHE_NOT_EXPIRED);
            PERF_LOG(PE_TRACE, 0x99);
            ReuseObject();
            error = FHttpBeginCacheRetrieval(FALSE, FALSE);
            INET_ASSERT (error == ERROR_SUCCESS);
        }
    }

done:
    PERF_LOG(PE_CACHE_EXPIRY_CHECK_END);
    DEBUG_LEAVE(error);
    return (error);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO(
    IN DWORD dwStatusCode,
    IN BOOL fVariation
    )

/*++

Routine Description:

    Check if this response needs to be cached or pulled from the cache
    after we have received the response from the net. Here we check for
    if-modified-since.

Arguments:

    dwStatusCode    - HTTP status code

Return Value:

    DWORD   Windows Error Code

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetFromCachePostNetIO",
                 "%d",
                 dwStatusCode
                 ));

    DWORD error = ERROR_FILE_NOT_FOUND;
    BOOL fLastModTimeFromServer = FALSE;
    BOOL fExpireTimeFromServer = FALSE;
    BOOL fPostCheckTimeFromServer = FALSE;

    //
    // check if
    // we can actually read the data from the cache after all. The idea here is
    // to improve efficiency by returning data from the cache if it hasn't
    // changed at the server. We determine this by the server returning a 304
    // response, or by determining that the date on the response is less than or
    // equal to the expires timestamp on the data we already wrote to cache
    //

    INET_ASSERT((dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
                || (dwStatusCode == HTTP_STATUS_PRECOND_FAILED)
                || (dwStatusCode == HTTP_STATUS_OK)
                || (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (dwStatusCode == 0));

    GetTimeStampsForCache(&_ftExpires,
                          &_ftLastModified,
                          &_ftPostCheck,
                          &fExpireTimeFromServer,
                          &fLastModTimeFromServer,
                          &fPostCheckTimeFromServer
                          );

    if (IsCacheReadDisabled())
    {
        INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
        goto quit;
    }

    //
    // we may have no cache entry info, so no point in continuing - this file
    // was not in the cache when we started. (We could try to retrieve again
    // in case another download has put it in the cache)
    //

    if (_pCacheEntryInfo == NULL)
    {
        if (fVariation)
        {
            error = UrlCacheRetrieve(TRUE);
        }
        if (error!=ERROR_SUCCESS)
        {
            goto quit;
        }
    }

    if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
    {

        if (dwStatusCode == HTTP_STATUS_PARTIAL_CONTENT)
        {
            BETA_LOG (CACHE_RESUMED);
            error = ResumePartialDownload();
        }
        else
        {
            BETA_LOG (CACHE_NOT_RESUMED);
            INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
        }

        goto quit;
    }

    //
    // we are optimizing further here
    // if the return status is OK and the server sent us a
    // last modified time and this time is the same as
    // what we got earlier then we use the entry from the cache
    //

    if ((dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
        || ((fLastModTimeFromServer)
            && (FT2LL(_ftLastModified)
                == FT2LL(_pCacheEntryInfo->LastModifiedTime))
            && GetMethodType() == HTTP_METHOD_TYPE_GET))
    {
        BETA_LOG (CACHE_NOT_MODIFIED);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("response code=%d %s, using cache entry\n",
                    GetStatusCode(),
                    GetURL()
                    ));

        DWORD dwAction = CACHE_ENTRY_SYNCTIME_FC;
        GetCurrentGmtTime(&(_pCacheEntryInfo->LastSyncTime));

        if (fExpireTimeFromServer)
        {
            (_pCacheEntryInfo->ExpireTime).dwLowDateTime = _ftExpires.dwLowDateTime;
            (_pCacheEntryInfo->ExpireTime).dwHighDateTime = _ftExpires.dwHighDateTime;
            dwAction |= CACHE_ENTRY_EXPTIME_FC;
        }

        // update the cache entry type if needed
        DWORD dwType;
        dwType = GetCacheEntryType();
        if (dwType)
            _pCacheEntryInfo->CacheEntryType |= dwType;
        dwAction |= CACHE_ENTRY_TYPE_FC;

        //
        // Update the last sync time to the current time
        // so we can do once_per_session logic
        //
        if (!SetUrlCacheEntryInfoA(_pCacheEntryInfo->lpszSourceUrlName, _pCacheEntryInfo, dwAction))
        {
            // NB if this call fails, the worst that could happen is
            // that next time around we will do an if-modified-since
            // again
            INET_ASSERT(FALSE);
        }
        
        error = FHttpBeginCacheRetrieval(TRUE, FALSE);
        
        if (error != ERROR_SUCCESS)
        {
            //
            // if we failed to abort the transaction, or to retrieve the
            // data from the cache, then return the error only if the
            // response if not OK. Otherwise we can continue and
            // get the data
            //

            if (dwStatusCode != HTTP_STATUS_OK)
            {
                // this should never happen to us

                INET_ASSERT(FALSE);

                error = ERROR_FILE_NOT_FOUND;
            }
        }

    }
    else // We could not use the cache entry so release it.
    {
        BETA_LOG (CACHE_MODIFIED);
        INET_ASSERT (error == ERROR_FILE_NOT_FOUND);
    }

quit:

    if (error != ERROR_SUCCESS)
        UrlCacheUnlock();
    DEBUG_LEAVE(error);
    return error;
}


DWORD HTTP_REQUEST_HANDLE_OBJECT::ResumePartialDownload(void)

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ResumePartialDownload",
                 NULL));

    _ResponseHeaders.LockHeaders();

    const static char sz200[] = "200";

    INET_ASSERT (!_CacheWriteInProgress);

    LPSTR pszHeader;
    DWORD cbHeader;

    // Retrieve the start and end of Content-Range header
    if (!_iSlotContentRange)
        goto quit;
    pszHeader = _ResponseHeaders.GetHeaderPointer
        (_ResponseBuffer, _iSlotContentRange);
    INET_ASSERT (pszHeader);
    PSTR pszLimit;
    pszLimit = StrChr (pszHeader, '\n');
    INET_ASSERT (pszLimit);
    *pszLimit = 0;

    // Extract the document length as a string and number.
    // The http 1.1 spec is very explicit that we MUST parse
    // the header and return an error if invalid.  We expect
    // it to be of the form Content-Range: bytes xxx-yyy/zzz.
    PSTR pszStart, pszEnd, pszLength;
    DWORD dwStart, dwEnd, dwLength;

    // Ensure that value is prefixed with "bytes"
    PSTR pszBytes;
    pszBytes = pszHeader + (GlobalKnownHeaders[HTTP_QUERY_CONTENT_RANGE].Length+1); // +1 for the ':'
    SKIPWS (pszBytes);
    if (strnicmp (pszBytes, BYTES_SZ, BYTES_LEN))
        goto quit;

    // Parse and validate start of range.
    pszStart = pszBytes + BYTES_LEN;
    SKIPWS (pszStart);
    dwStart = StrToInt (pszStart);
    if (dwStart != _pCacheEntryInfo->dwSizeLow)
        goto quit;

    // Parse and validate end of range.
    pszEnd = StrChr (pszStart, '-');
    if (!pszEnd++)
        goto quit;
    dwEnd = StrToInt (pszEnd);
    if (dwStart > dwEnd)
        goto quit;

    // Parse and validate length.
    pszLength = StrChr (pszEnd, '/');
    if (!pszLength)
        goto quit;
    pszLength++;
    dwLength = StrToInt (pszLength);
    if (dwEnd + 1 != dwLength)
        goto quit;

    // The Content-Length header is the amount transmitted, however
    // as far as the client is concerned only the total amount of
    // data matters, so we fix it up from the Content-Range header.
    // Use the Content-Range buffer for the new Content-Length.
    // We know the buffer is big enough because the last number
    // in the Content-Range header is the new Content-Length value.
    _ContentLength = dwLength;

    // Remove the old Content-Length header, if any.
    if (_iSlotContentLength)
    {
        _ResponseHeaders.RemoveAllByIndex(HTTP_QUERY_CONTENT_LENGTH);
        //_ResponseHeaders.RemoveHeader (_iSlotContentLength, HTTP_QUERY_CONTENT_LENGTH, &_bKnownHeaders[dwQueryIndex]);
    }
    
    cbHeader = wsprintf (pszHeader, "%s: %d", GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Text,
            dwLength);
    _ResponseHeaders.ShrinkHeader
            (_ResponseBuffer, _iSlotContentRange, HTTP_QUERY_CONTENT_RANGE, HTTP_QUERY_CONTENT_LENGTH, cbHeader);

    // Fix up the response headers to appear same as a 200 response.
    // Revise the status line from 206 to 200.  The status code
    // starts after the first space, e.g. "HTTP/1.0 206 Partial Content"
    pszHeader = _ResponseHeaders.GetHeaderPointer (_ResponseBuffer, 0);
    INET_ASSERT (pszHeader);
    LPSTR pszStatus;
    pszStatus = StrChr (pszHeader, ' ');
    SKIPWS (pszStatus);
    INET_ASSERT (!memcmp(pszStatus, "206", 3));
    memcpy (pszStatus, sz200, sizeof(sz200));
    _ResponseHeaders.ShrinkHeader (_ResponseBuffer, 0,
            HTTP_QUERY_STATUS_TEXT, HTTP_QUERY_STATUS_TEXT,
            (DWORD) (pszStatus - pszHeader) + sizeof(sz200) - 1);
    _StatusCode = HTTP_STATUS_OK;

    // Some servers omit "Accept-Ranges: bytes" since it is implicit
    // in a 206 response.  This is important to Adobe Amber ActiveX
    // control and other clients that may issue their own range
    // requests. Add the header if not present.
    if (!IsResponseHeaderPresent(HTTP_QUERY_ACCEPT_RANGES))
    {
        const static char szAccept[] = "Accept-Ranges: bytes";
        DWORD dwErr = AddInternalResponseHeader
            (HTTP_QUERY_ACCEPT_RANGES, (LPSTR) szAccept, CSTRLEN(szAccept));
        INET_ASSERT (dwErr == ERROR_SUCCESS);
    }    

    // Adjust the handle values for socket read and file write positions.
    if (IsKeepAlive())
        _BytesRemaining = _ContentLength;
    _VirtualCacheFileSize = dwStart;
    _RealCacheFileSize    = dwStart;
    SetAvailableDataLength (dwStart);

    // Save the cache file path.
    INET_ASSERT(!_CacheFileName);
    _CacheFileName = NewString(_pCacheEntryInfo->lpszLocalFileName);
    if (!_CacheFileName)
        goto quit;

    // Open the file for read (should already be open for write)
    INET_ASSERT (_CacheFileHandle != INVALID_HANDLE_VALUE);

    _CacheFileHandleRead = CreateFile (_CacheFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, NULL);
    if (_CacheFileHandleRead == INVALID_HANDLE_VALUE)
        goto quit;

    // We can discard the partial cache entry info.
    FREE_MEMORY (_pCacheEntryInfo);
    _pCacheEntryInfo = NULL;

    _CacheWriteInProgress = TRUE;

quit:

    _ResponseHeaders.UnlockHeaders();

    DWORD dwErr;

    if (_CacheWriteInProgress)
    {
        dwErr = ERROR_SUCCESS;
    }
    else
    {
        INET_ASSERT (FALSE);

        dwErr = ERROR_HTTP_INVALID_SERVER_RESPONSE;

        if (_CacheFileName)
        {
            FREE_MEMORY (_CacheFileName);
            _CacheFileName = NULL;
        }
        if (_CacheFileHandleRead != INVALID_HANDLE_VALUE)
        {
            CloseHandle (_CacheFileHandleRead);
            _CacheFileHandleRead = INVALID_HANDLE_VALUE;
        }
    }

    DEBUG_LEAVE (dwErr);
    return dwErr;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddTimestampsFromCacheToResponseHeaders(
    IN LPCACHE_ENTRY_INFO lpCacheEntryInfo
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpCacheEntryInfo    -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::AddTimestampsFromCacheToResponseHeaders",
                 "%#x",
                 lpCacheEntryInfo
                 ));

    PERF_LOG(PE_TRACE, 0x701);

    _ResponseHeaders.LockHeaders();

    DWORD error = AddTimeHeader(lpCacheEntryInfo->ExpireTime,
                                HTTP_QUERY_EXPIRES
                                );

    if (error == ERROR_SUCCESS) {
        error = AddTimeHeader(lpCacheEntryInfo->LastModifiedTime,
                              HTTP_QUERY_LAST_MODIFIED
                              );
    }

    if (error == ERROR_INVALID_PARAMETER) {
        error = ERROR_SUCCESS;
    }

    _ResponseHeaders.UnlockHeaders();

    PERF_LOG(PE_TRACE, 0x702);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddTimeHeader(
    IN FILETIME fTime,
    IN DWORD dwHeaderIndex
    )

/*++

Routine Description:

    Adds a time header to this object

Arguments:

    fTime               - FILETIME value to add as header value

    dwHeaderIndex       - contains an index into a global array of Header strings.

    NOTE: Must be called under Header Critical Section!!!

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER
                    Couldn't convert fTime

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::AddTimeHeader",
                 "%#x:%#x, %u [%q]",
                 fTime.dwLowDateTime,
                 fTime.dwHighDateTime,
                 dwHeaderIndex,
                 GlobalKnownHeaders[dwHeaderIndex].Text
                 ));

    char buf[MAX_PATH];
    SYSTEMTIME systemTime;
    DWORD error = ERROR_SUCCESS;

    if (FT2LL(fTime) != LONGLONG_ZERO) {
        if (FileTimeToSystemTime((CONST FILETIME *)&fTime, &systemTime)) {
            memcpy(buf, GlobalKnownHeaders[dwHeaderIndex].Text, GlobalKnownHeaders[dwHeaderIndex].Length);
            buf[GlobalKnownHeaders[dwHeaderIndex].Length]   = ':';
            buf[GlobalKnownHeaders[dwHeaderIndex].Length+1] = ' ';
            if (InternetTimeFromSystemTime((CONST SYSTEMTIME *)&systemTime,
                                           INTERNET_RFC1123_FORMAT,
                                           buf + (GlobalKnownHeaders[dwHeaderIndex].Length+2),
                                           sizeof(buf) - (GlobalKnownHeaders[dwHeaderIndex].Length+2)
                                           )) {
                error = AddInternalResponseHeader(dwHeaderIndex, buf, lstrlen(buf));

                INET_ASSERT(error == ERROR_SUCCESS);

                //
                // if it came upto here and all went well, only then would
                // the error be set to ERROR_SUCCESS
                //

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Cache: Adding header %s, errorcode=%d\n",
                            buf,
                            error
                            ));

            } else {

                INET_ASSERT(FALSE);

                error = ERROR_INVALID_PARAMETER;
            }
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_INVALID_PARAMETER;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL HTTP_REQUEST_HANDLE_OBJECT::IsPartialResponseCacheable(void)

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    LPSTR lpszHeader;
    DWORD cbHeader;
    DWORD dwIndex;

    BOOL fRet = FALSE;
    DWORD err;

    _ResponseHeaders.LockHeaders();

    if (GlobalDisableReadRange || GetMethodType() != HTTP_METHOD_TYPE_GET)
    {
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    if (_RealCacheFileSize >= _ContentLength)
    {
        // We don't handle chunked transfer upon resuming a partial
        // download, so we require a Content-Length header.  Also,
        // if download file is actually complete, yet not committed
        // to cache (possibly because the client didn't read to eof)
        // then we don't want to save a partial download.  Otherwise
        // we might later start a range request for the file starting
        // one byte beyond eof.  MS Proxy 1.0 will return an invalid
        // 206 response containing the last byte of the file.  Other
        // servers or proxies that follow the latest http spec might
        // return a 416 response which is equally useless to us.
        
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    // For HTTP/1.0, must have last-modified time, otherwise we
    // don't have a way to tell if the partial downloads are coherent.
    if (!IsResponseHttp1_1() && (FT2LL(_ftLastModified) == 0))
    {
        INET_ASSERT(fRet == FALSE);
        goto quit;
    }

    if (!_iSlotContentRange)
    {
        // We didn't get a Content-Range header which implies the server
        // supports byte range for this URL, so we must look for the
        // explicit invitation of "Accept-Ranges: bytes" response header.

        dwIndex = 0;
        err = FastQueryResponseHeader (HTTP_QUERY_ACCEPT_RANGES,
            (LPVOID *) &lpszHeader,&cbHeader, dwIndex);
        if (err != ERROR_SUCCESS || !(cbHeader == BYTES_LEN && !strnicmp(lpszHeader, BYTES_SZ, cbHeader)) )
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    if (!IsResponseHttp1_1())
    {
        // For HTTP/1.0, only cache responses from Server: Microsoft-???/*
        // Microsoft-PWS-95/*.* will respond with a single range but
        // with incorrect Content-Length and Content-Range headers.
        // Other 1.0 servers may return single range in multipart response.

        const static char szPrefix[] = "Microsoft-";
        const static DWORD ibSlashOffset = sizeof(szPrefix)-1 + 3;

        dwIndex = 0;
        if (    ERROR_SUCCESS != FastQueryResponseHeader (HTTP_QUERY_SERVER,
                    (LPVOID *) &lpszHeader, &cbHeader, dwIndex)
            ||  cbHeader <= ibSlashOffset
            ||  lpszHeader[ibSlashOffset] != '/'
            ||  memcmp (lpszHeader, szPrefix, sizeof(szPrefix) - 1)
           )
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    else // if (IsResponseHttp1_1())
    {
        // For http 1.1, must have strong etag.  A weak etag starts with
        // a character other than a quote mark and cannot be used as a 
        // coherency validator.  IIS returns a weak etag when content is
        // modified within a single file system time quantum.
        
        if (ERROR_SUCCESS != FastQueryResponseHeader (HTTP_QUERY_ETAG,
                (LPVOID *) &lpszHeader, &cbHeader, 0)
            || *lpszHeader != '\"')
        {
            INET_ASSERT(fRet == FALSE);
            goto quit;
        }
    }

    fRet = TRUE;

quit:

    _ResponseHeaders.UnlockHeaders();

    return fRet;
 }


DWORD
HTTP_REQUEST_HANDLE_OBJECT::LocalEndCacheWrite(
    IN BOOL fNormal
    )

/*++

Routine Description:

    Finishes up the cache-write operation, either committing the cache entry or
    deleting it (because we failed)

Arguments:

    fNormal - TRUE if normal end-cache-write operation (i.e. FALSE if error)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                  ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::LocalEndCacheWrite",
                 "%B",
                 fNormal
                 ));

    PERF_LOG(PE_TRACE, 0x2001);

    LPSTR lpszBuf = NULL;
    char buff[256];
    DWORD dwBuffLen;
    DWORD dwError;
    DWORD dwUserNameHeader = 0;
    LPSTR lpszHeaderInfo = NULL;

    DWORD dwEntryType = GetCacheEntryType();

    if (!fNormal)
    {
        if (!IsPartialResponseCacheable())
        {
            BETA_LOG (DOWNLOAD_ABORTED);
        }
        else
        {
            //
            // Flush any buffered data to disk.
            // BUGBUG: doesn't work with chunked transfer
            // WriteResponseBufferToCache();
            // WriteQueryBufferToCache();
            //

            // dprintf ("wininet: partial cached %s\n", GetURL());

            BETA_LOG (DOWNLOAD_PARTIAL);

            fNormal = TRUE;
            dwEntryType = SPARSE_CACHE_ENTRY;

            //
            // Disable InternetUnlockRequest
            //

            LOCK_REQUEST_INFO* pLock =
                (LOCK_REQUEST_INFO*) GetLockRequestHandle();
            if (pLock)
                pLock->fNoDelete = TRUE;
        }
    }

    if (fNormal)
    {
        if (GetCacheFlags() & INTERNET_FLAG_MAKE_PERSISTENT)
            dwEntryType |= STICKY_CACHE_ENTRY;

        if (GetSecondaryCacheKey())
            dwEntryType |= POST_RESPONSE_CACHE_ENTRY;

        if (IsResponseHttp1_1())
        {
            dwEntryType |= HTTP_1_1_CACHE_ENTRY;
            if (IsMustRevalidate())
                dwEntryType |= MUST_REVALIDATE_CACHE_ENTRY;
        }                
        
        if (IsPerUserItem())
        {
            //
            // create per-user header, e.g. "~U:JoeBlow\r\n", if it fits in the
            // buffer
            //

            INET_ASSERT(vdwCurrentUserLen);

            dwUserNameHeader = sizeof(vszUserNameHeader) - 1
                             + vdwCurrentUserLen
                             + sizeof("\r\n");
            if (sizeof(buff) >= dwUserNameHeader)
            {
                memcpy(buff, vszUserNameHeader, sizeof(vszUserNameHeader) - 1);

                DWORD dwSize = lstrlen(vszCurrentUser);

                memcpy(&buff[sizeof(vszUserNameHeader) - 1],
                       vszCurrentUser,
                       dwSize);
                dwSize += sizeof(vszUserNameHeader) - 1;
                memcpy(&buff[dwSize], "\r\n", sizeof("\r\n"));
            }
            else
            {
                // if it failed, mark it as expired

                dwUserNameHeader = 0;
                GetCurrentGmtTime(&_ftExpires);
                AddLongLongToFT(&_ftExpires, (-1)*(ONE_HOUR_DELTA));
            }
        }

        //
        // start off with 512 byte buffer (used to be 256, but headers are
        // getting larger)
        //

        dwBuffLen = 512;

        do
        {
            DWORD dwPreviousLength;

            lpszBuf = (LPSTR)ResizeBuffer(lpszBuf, dwBuffLen, FALSE);
            if (lpszBuf == NULL)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            dwBuffLen -= dwUserNameHeader;

            dwPreviousLength = dwBuffLen;
            lpszHeaderInfo = lpszBuf;
            lpszBuf[0] = '\0';

            dwError = QueryRawResponseHeaders(TRUE,
                                              (LPVOID)lpszHeaderInfo,
                                              &dwBuffLen
                                              );
            if (dwError == ERROR_SUCCESS)
            {

                FilterHeaders(lpszHeaderInfo, &dwBuffLen);
                if (dwUserNameHeader)
                {
                    lstrcat(lpszHeaderInfo, buff);
                    dwBuffLen += dwUserNameHeader;
                }
                break; // get out
            }

            //
            // we have the right error and we haven't allocated more memory yet
            //

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                if (dwBuffLen <= dwPreviousLength)
                {
                    dwError = ERROR_INTERNET_INTERNAL_ERROR;
                    break;
                }

                dwBuffLen += dwUserNameHeader;
            }
            else
            {
                //
                // if HttpQueryInfo() returned ERROR_HTTP_DOWNLEVEL_SERVER
                // or we are making CERN proxy requests for FTP or gopher, then
                // there are no headers from the origin server, but the
                // operation succeeded
                //

                if (dwError == ERROR_HTTP_DOWNLEVEL_SERVER)
                    dwError = ERROR_SUCCESS;

                //
                // either allready tried once with allocation or
                // we got some error other than ERROR_INSUFFICIENT_BUFFER
                //

                INET_ASSERT(*lpszHeaderInfo == '\0');

                lpszHeaderInfo = NULL;
                dwBuffLen = 0;
                break;
            }

        } while (TRUE);

        fNormal = (dwError == ERROR_SUCCESS);
    }

    if (!fNormal)
    {
        dwEntryType = 0xffffffff;
        lpszHeaderInfo = NULL;
    }

    //
    // Simulate a redirect if the original object was the root
    // ("" or "/") and we did not otherwise get a redirect.
    //

    if (IsObjectRoot() && _OriginalUrl && !lstrcmpi (_OriginalUrl, GetURL()))
    {
        DWORD dwLen = lstrlen (_OriginalUrl);
        INET_ASSERT (_OriginalUrl[dwLen - 1] == '/');
        _OriginalUrl[dwLen - 1] = 0;
    }

    //
    // Let the cache know if the item is likely to be a static image.
    // 1. No expire time.
    // 2. Has last-modified time.
    // 3. The content-type is image/*
    // 4. No '?' in the URL.
    //

    LPSTR lpszHeader;
    DWORD cbHeader;
    BOOL fImage =
        (  !FT2LL(_ftExpires)
        && FT2LL(_ftLastModified)
        && (ERROR_SUCCESS == FastQueryResponseHeader (HTTP_QUERY_CONTENT_TYPE,
                (LPVOID *) &lpszHeader, &cbHeader, 0))
        && (StrCmpNI (lpszHeader, "image/", sizeof("image/")-1) == 0)
        && (!StrChr (GetURL(), '?'))
        );

    DEBUG_PRINT(CACHE,
                INFO,
                ("Cache write EntryType = %x\r\n",
                dwEntryType
                ));

    dwError = EndCacheWrite(&_ftExpires,
                            &_ftLastModified,
                            &_ftPostCheck,
                            dwEntryType,
                            dwBuffLen,
                            lpszHeaderInfo,
                            NULL,
                            fImage
                            );

    if (fNormal && !(dwEntryType & SPARSE_CACHE_ENTRY))
    {
        if (dwError == ERROR_SUCCESS)
        {
            BETA_LOG (DOWNLOAD_CACHED);
        }
        else
        {
            BETA_LOG (DOWNLOAD_NOT_CACHED);
        }
    }

    if (lpszBuf != NULL) {

        lpszBuf = (LPSTR)FREE_MEMORY(lpszBuf);

        INET_ASSERT(lpszBuf == NULL);

    }

    PERF_LOG(PE_TRACE, 0x2002);

    DEBUG_LEAVE(dwError);

    return dwError;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::GetTimeStampsForCache(
    OUT LPFILETIME lpftExpiryTime,
    OUT LPFILETIME lpftLastModTime,
    OUT LPFILETIME lpftPostCheckTime,
    OUT LPBOOL lpfHasExpiry,
    OUT LPBOOL lpfHasLastModTime,
    OUT LPBOOL lpfHasPostCheck
    )

/*++

Routine Description:

    extracts timestamps from the http response. If the timestamps don't exist,
    does the default thing. has additional goodies like checking for expiry etc.

Arguments:

    lpftExpiryTime      - returned expiry time

    lpftLatsModTime     - returned last-modified time

    lpfHasExpiry        - returned TRUE if the response header contains an expiry
                          timestamp. This patameter can be NULL

    lpfHasLastModTime   - returned TRUE if the response header contains a
                          last-modified timestamp. This patameter can be NULL


Return Value:

    None.

Comment:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetTimeStampsForCache",
                 "%#x, %#x, %#x, %#x",
                 lpftExpiryTime,
                 lpftLastModTime,
                 lpfHasExpiry,
                 lpfHasLastModTime
                 ));

    PERF_LOG(PE_TRACE, 0x9001);

    char buf[512];
    LPSTR lpszBuf;
    BOOL fRet;

    DWORD length, index = 0;
    BOOL fPostCheck = FALSE;
    BOOL fPreCheck = FALSE;
    FILETIME ftPreCheckTime;
    FILETIME ftPostCheckTime;

    fRet = FALSE;

    _ResponseHeaders.LockHeaders();

    // Determine if a Cache-Control: max-age header exists. If so, calculate expires
    // time from current time + max-age minus any delta indicated by Age:

    //
    // we really want all the post-fetch stuff works with 1.0 proxy
    // so we loose our grip a little bit here: enable all Cache-Control
    // max-age work with 1.0 response.
    //
    //if (IsResponseHttp1_1())
    {
        CHAR  *ptr, *pToken;
        INT nDeltaSecsPostCheck = 0;
        INT nDeltaSecsPreCheck = 0;

        while (1)
        {
            // Scan headers for Cache-Control: max-age header.
            length = sizeof(buf);
            switch (QueryResponseHeader(HTTP_QUERY_CACHE_CONTROL,
                buf,
                &length,
                0,
                &index))
            {
                case ERROR_SUCCESS:

                    buf[length] = '\0';
                    pToken = ptr = buf;

                    // Parse a token from the string; test for sub headers.
                    while (pToken = StrTokEx(&ptr, ","))
                    {
                        SKIPWS(pToken);

                        if (strnicmp(POSTCHECK_SZ, pToken, POSTCHECK_LEN) == 0)
                        {
                            pToken += POSTCHECK_LEN;

                            SKIPWS(pToken);

                            if (*pToken != '=')
                                break;

                            pToken++;

                            SKIPWS(pToken);

                            nDeltaSecsPostCheck = atoi(pToken);

                            // Calculate post fetch time 
                            GetCurrentGmtTime(&ftPostCheckTime);
                            AddLongLongToFT(&ftPostCheckTime, (nDeltaSecsPostCheck * (LONGLONG) 10000000));
                
                            fPostCheck = TRUE;
                        }

                        else if (strnicmp(PRECHECK_SZ, pToken, PRECHECK_LEN) == 0)
                        {
                            // found
                            pToken += PRECHECK_LEN;

                            SKIPWS(pToken);

                            if (*pToken != '=')
                                break;

                            pToken++;

                            SKIPWS(pToken);

                            nDeltaSecsPreCheck = atoi(pToken);

                            // Calculate pre fetch time (overwrites ftExpire ) 
                            GetCurrentGmtTime(&ftPreCheckTime);
                            AddLongLongToFT(&ftPreCheckTime, (nDeltaSecsPreCheck * (LONGLONG) 10000000));

                            fPreCheck = TRUE;
                        }

                        else if (strnicmp(MAX_AGE_SZ, pToken, MAX_AGE_LEN) == 0)
                        {
                            // Found max-age. Convert to integer form.
                            // Parse out time in seconds, text and convert.
                            pToken += MAX_AGE_LEN;

                            SKIPWS(pToken);

                            if (*pToken != '=')
                                break;

                            pToken++;

                            SKIPWS(pToken);

                            INT nDeltaSecs = atoi(pToken);
                            INT nAge;

                            // See if an Age: header exists.

							// Using a local index variable:
                            DWORD indexAge = 0;
                            length = sizeof(INT)+1;

                            if (QueryResponseHeader(HTTP_QUERY_AGE,
                                &nAge,
                                &length,
                                HTTP_QUERY_FLAG_NUMBER,
                                &indexAge) == ERROR_SUCCESS)

                            {
                                // Found Age header. Convert and subtact from max-age.
                                // If less or = 0, attempt to get expires header.
                                nAge = ((nAge < 0) ? 0 : nAge);

                                nDeltaSecs -= nAge;
                                if (nDeltaSecs <= 0)
									// The server (or some caching intermediary) possibly sent an incorrectly
									// calculated header. Use "Expires", if no "max-age" directives at higher indexes.
									// Note: This behaviour could cause a situation where the "pre-check"
									// and "post-check" are picked up from the current index, and "max-age" is
									// picked up from a higher index. "pre-check" and "post-check" are IE 5.x 
									// extensions, and generally not bunched together with "max-age", so this
									// should work fine. More info on "pre-check" and "post-check":
									// <http://msdn.microsoft.com/workshop/author/perf/perftips.asp#Use_Cache-Control_Extensions>
                                    continue;
                            }

                            // Calculate expires time from max age.
                            GetCurrentGmtTime(lpftExpiryTime);
                            //*((LONGLONG *)lpftExpiryTime) += (nDeltaSecs * (LONGLONG) 10000000);
                            AddLongLongToFT(lpftExpiryTime, (nDeltaSecs * (LONGLONG) 10000000));
                            fRet = TRUE;
                        }

                        else if (strnicmp(MUST_REVALIDATE_SZ, pToken, MUST_REVALIDATE_LEN) == 0)
                        {
                            pToken += MUST_REVALIDATE_LEN;
                            SKIPWS(pToken);
                            if (*pToken == 0 || *pToken == ',')
                                SetMustRevalidate();
                        }
                    }

                    // If an expires time has been found, break switch.
                    if (fRet)
                        break;
					
					// Need to bump up index to prevent possibility of never-ending outer while(1) loop.
					// Otherwise, on exit from inner while, we could be stuck here reading the 
					// Cache-Control at the same index.
					// QueryResponseHeader(HTTP_QUERY_CACHE_CONTROL, ...) will return either the next index,
					// or an error, and we'll be good to go:
					index++;
                    continue;

                case ERROR_INSUFFICIENT_BUFFER:
                    index++;
                    continue;

                default:
                    break; // no more Cache-Control headers.
            }

            //
            // pre-post fetch headers must come in pair, also
            // pre fetch header overwrites the expire 
            // and make sure postcheck < precheck
            //
            if( fPreCheck && fPostCheck && 
                ( nDeltaSecsPostCheck < nDeltaSecsPreCheck ) ) 
            {
                fRet = TRUE;
                *lpftPostCheckTime  = ftPostCheckTime;
                *lpftExpiryTime     = ftPreCheckTime;
                if( lpfHasPostCheck )
                    *lpfHasPostCheck = TRUE;

                if( nDeltaSecsPostCheck == 0 && 
                    !(GetCacheFlags() & INTERNET_FLAG_BGUPDATE) )
                {
                    //
                    // "post-check = 0"
                    // this page has already passed the lazy update time
                    // this means server wants us to do background update 
                    // after the first download  
                    //
                    // (bg fsm will be created at the end of the cache write)
                    //
                    _fLazyUpdate = TRUE;
                }

            }
            else
            {
                fPreCheck = FALSE;
                fPostCheck = FALSE;
            }

            break; // no more Cache-Control headers.
        }

    } // Is http 1.1


    // If no expires time is calculated from max-age, check for expires header.
    if (!fRet)
    {
        length = sizeof(buf) - 1;
        index = 0;
        if (QueryResponseHeader(HTTP_QUERY_EXPIRES, buf, &length, 0, &index) == ERROR_SUCCESS)
        {
            fRet = FParseHttpDate(lpftExpiryTime, buf);

            //
            // as per HTTP spec, if the expiry time is incorrect, then the page is
            // considered to have expired
            //

            if (!fRet)
            {
                GetCurrentGmtTime(lpftExpiryTime);
                AddLongLongToFT(lpftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
                fRet = TRUE;
            }
        }
    }

    // We found or calculated a valid expiry time, let us check it against the
    // server date if possible
    FILETIME ft;
    length = sizeof(buf) - 1;
    index = 0;

    if (QueryResponseHeader(HTTP_QUERY_DATE, buf, &length, 0, &index) == ERROR_SUCCESS
        && FParseHttpDate(&ft, buf))
    {

        // we found a valid Data: header

        // if the expires: date is less than or equal to the Date: header
        // then we put an expired timestamp on this item.
        // Otherwise we let it be the same as was returned by the server.
        // This may cause problems due to mismatched clocks between
        // the client and the server, but this is the best that can be done.

        // Calulating an expires offset from server date causes pages
        // coming from proxy cache to expire later, because proxies
        // do not change the date: field even if the reponse has been
        // sitting the proxy cache for days.

        // This behaviour is as-per the HTTP spec.


        if (FT2LL(*lpftExpiryTime) <= FT2LL(ft))
        {
            GetCurrentGmtTime(lpftExpiryTime);
            AddLongLongToFT(lpftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
        }
    }

    if (lpfHasExpiry)
    {
        *lpfHasExpiry = fRet;
    }

    if (!fRet)
    {
        lpftExpiryTime->dwLowDateTime = 0;
        lpftExpiryTime->dwHighDateTime = 0;
    }

    fRet = FALSE;
    length = sizeof(buf) - 1;
    index = 0;

    if (QueryResponseHeader(HTTP_QUERY_LAST_MODIFIED, buf, &length, 0, &index) == ERROR_SUCCESS)
    {
        DEBUG_PRINT(CACHE,
                    INFO,
                    ("Last Modified date is: %q\n",
                    buf
                    ));

        fRet = FParseHttpDate(lpftLastModTime, buf);

        if (!fRet)
        {
            DEBUG_PRINT(CACHE,
                        ERROR,
                        ("FParseHttpDate() returns FALSE\n"
                        ));
        }
    }

    if (lpfHasLastModTime)
    {
        *lpfHasLastModTime = fRet;
    }

    if (!fRet)
    {
        lpftLastModTime->dwLowDateTime = 0;
        lpftLastModTime->dwHighDateTime = 0;
    }

    _ResponseHeaders.UnlockHeaders();

    PERF_LOG(PE_TRACE, 0x9002);

    DEBUG_LEAVE(0);
}

//
// private functions
//


PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwHeaderLen
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpszHeaderInfo  -
    lpdwHeaderLen   -

Return Value:

    None.

--*/

{
    PERF_LOG(PE_TRACE, 0x3001);

    DWORD i, len, lenT, reduced = 0, dwHeaderTableCount;
    LPSTR lpT, lpMark, lpNext, *lprgszHeaderExcludeTable;

    //
    // skip over the status line
    // NB this assumes that the raw buffer is nullterminated
    //

    if (lpvrgszHeaderExclusionTable) {
        lprgszHeaderExcludeTable = lpvrgszHeaderExclusionTable;
        dwHeaderTableCount = vdwHeaderExclusionTableCount;
    } else {
        lprgszHeaderExcludeTable = rgszExcludeHeaders;
        dwHeaderTableCount = sizeof(rgszExcludeHeaders) / sizeof(LPSTR);
    }

    lpT = strchr(lpszHeaderInfo, '\r');
    if (!lpT) {

        PERF_LOG(PE_TRACE, 0x3002);

        return;
    }

    INET_ASSERT(*(lpT + 1) == '\n');

    lpT += 2;

    do {

        //
        // find the header portion
        //

        lpMark = strchr(lpT, ':');
        if (!lpMark) {
            break;
        }

        //
        // get the end of the header line
        //

        lpNext = strchr(lpMark, '\r');

        if (!lpNext)
        {
            INET_ASSERT(FALSE);
            // A properly formed header _should_ terminate with \r\n, but sometimes
            // that just doesn't happen
            lpNext = lpMark;
            while (*lpNext)
            {
                lpNext++;
            }
        }
        else
        {
            INET_ASSERT(*(lpNext + 1) == '\n');
            lpNext += 2;
        }


        len = (DWORD) PtrDifference(lpMark, lpT) + 1; 
        lenT = *lpdwHeaderLen;  // doing all this to see it properly in debugger

        BOOL bFound = FALSE;

        for (i = 0; i < dwHeaderTableCount; ++i) {
            if (!strnicmp(lpT, lprgszHeaderExcludeTable[i], len)) {
                bFound = TRUE;
                break;
            }
        }
        if (bFound) {

            //
            // nuke this header
            //

            len = lenT - (DWORD)PtrDifference(lpNext, lpszHeaderInfo) + 1; // for NULL character

            //
            // ACHTUNG memove because of overlapped copies
            //

            memmove(lpT, lpNext, len);

            //
            // keep count of how much we reduced the header by
            //

            reduced += (DWORD) PtrDifference(lpNext, lpT);

            //
            // lpT is already properly positioned because of the move
            //

        } else {
            lpT = lpNext;
        }
    } while (TRUE);
    *lpdwHeaderLen -= reduced;

    PERF_LOG(PE_TRACE, 0x3003);
}


PRIVATE
BOOL
FExcludedMimeType(
    IN LPSTR lpszMimeType,
    IN DWORD dwMimeTypeSize
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpszMimeType    -

Return Value:

    BOOL

--*/

{
    PERF_LOG(PE_TRACE, 0x501);

    DWORD i;
    LPCSTR * lprgszMimeExcludeTable = rgszExcludedMimeTypes;
    DWORD dwMimeExcludeCount = (sizeof(rgszExcludedMimeTypes)/sizeof(LPSTR));
    const DWORD *lprgdwMimeExcludeTableOfSizes = rgdwExcludedMimeTypeSizes;

    if (lpvrgszMimeExclusionTable) {
        lprgszMimeExcludeTable = (LPCSTR *)lpvrgszMimeExclusionTable;
        dwMimeExcludeCount = vdwMimeExclusionTableCount;
        lprgdwMimeExcludeTableOfSizes = lpvrgdwMimeExclusionTableOfSizes;
    }
    for (i = 0; i < dwMimeExcludeCount; ++i) {
        if ((dwMimeTypeSize == lprgdwMimeExcludeTableOfSizes[i]) &&
            !strnicmp(lpszMimeType,
                      lprgszMimeExcludeTable[i],
                      lprgdwMimeExcludeTableOfSizes[i])) {

            PERF_LOG(PE_TRACE, 0x502);

            return TRUE;
        }
    }

    PERF_LOG(PE_TRACE, 0x503);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\handles\http.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    http.cxx

Abstract:

    Contains methods for HTTP_REQUEST_HANDLE_OBJECT class

    Contents:
        RMakeHttpReqObjectHandle
        HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT
        HTTP_REQUEST_HANDLE_OBJECT::GetHandle
        HTTP_REQUEST_HANDLE_OBJECT::SetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::GetProxyName
        HTTP_REQUEST_HANDLE_OBJECT::ReuseObject
        HTTP_REQUEST_HANDLE_OBJECT::ResetObject
        HTTP_REQUEST_HANDLE_OBJECT::UrlCacheUnlock
        HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated
        HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

   Sophia Chung (sophiac) 14-Feb-1995 (added FTP and Archie class impl.)
   (code adopted from madana)

--*/

#include <wininetp.h>

//
// functions
//


DWORD
RMakeHttpReqObjectHandle(
    IN HINTERNET ParentHandle,
    IN OUT HINTERNET * ChildHandle,
    IN CLOSE_HANDLE_FUNC wCloseFunc,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    C-callable wrapper for creating an HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    ParentHandle    - mapped address of parent (connect) handle

    ChildHandle     - IN: protocol-specific handle value associated with object
                        *** NOT USED FOR HTTP ***
                      OUT: mapped address of HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc      - address of protocol-specific function to be called when
                      object is closed
                        *** NOT USED FOR HTTP ***

    dwFlags         - app-supplied flags

    dwContext       - app-supplied context value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * hHttp;

    hHttp = new HTTP_REQUEST_HANDLE_OBJECT(
                    (INTERNET_CONNECT_HANDLE_OBJECT *)ParentHandle,
                    *ChildHandle,
                    wCloseFunc,
                    dwFlags,
                    dwContext
                    );
    if (hHttp != NULL) {
        error = hHttp->GetStatus();
        if (error == ERROR_SUCCESS) {

            //
            // inform the app of the new handle
            //

            error = InternetIndicateStatusNewHandle((LPVOID)hHttp);

            //
            // ERROR_INTERNET_OPERATION_CANCELLED is the only error that we are
            // expecting here. If we get this error then the app has cancelled
            // the operation. Either way, the handle we just generated will be
            // already deleted
            //

            if (error != ERROR_SUCCESS) {

                INET_ASSERT(error == ERROR_INTERNET_OPERATION_CANCELLED);

                hHttp = NULL;
            }
        } else {
            delete hHttp;
            hHttp = NULL;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ChildHandle = (HINTERNET)hHttp;
    if(hHttp)
    {
        hHttp->Dereference();
    }

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT class implementation
//


HTTP_REQUEST_HANDLE_OBJECT::HTTP_REQUEST_HANDLE_OBJECT(
    INTERNET_CONNECT_HANDLE_OBJECT * Parent,
    HINTERNET Child,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    ) : INTERNET_CONNECT_HANDLE_OBJECT(Parent)

/*++

Routine Description:

    Constructor for direct-to-net HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    Parent      - parent object

    Child       - IN: HTTPREQ structure pointer
                  OUT: pointer to created HTTP_REQUEST_HANDLE_OBJECT

    wCloseFunc  - address of function that closes/destroys HTTPREQ structure

    dwFlags     - open flags (e.g. INTERNET_FLAG_RELOAD)

    dwContext   - caller-supplied request context value

Return Value:

    None.

--*/

{
    Reference();
    _Context = dwContext;
    _Socket = NULL;
    _QueryBuffer = NULL;
    _QueryBufferLength = 0;
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;
    _OpenFlags = dwFlags;
    _State = HttpRequestStateCreating;
    _RequestMethod = HTTP_METHOD_TYPE_UNKNOWN;
    _dwOptionalSaved = 0;
    _lpOptionalSaved = NULL;
    _fOptionalSaved = FALSE;
        _ResponseBuffer = NULL;
    _ResponseBufferLength = 0;
    ResetResponseVariables();
    _RequestHeaders.SetIsRequestHeaders(TRUE);
    _ResponseHeaders.SetIsRequestHeaders(FALSE);
    _fTalkingToSecureServerViaProxy = FALSE;
    _fRequestUsingProxy = FALSE;
    _bWantKeepAlive = FALSE;
    _bRefresh = FALSE;
    _RefreshHeader = NULL;
    _redirectCount = GlobalMaxHttpRedirects;
    _redirectCountedOut = FALSE;
    _fIgnoreOffline = FALSE;
    _f3rdPartyCookies = FALSE;
    _fBlockedOnPrompt = FALSE;


    SetObjectType(TypeHttpRequestHandle);

    _pCacheEntryInfo = NULL;
    _dwCacheEntryType = 0;

    _pAuthCtx         = NULL;
    _pTunnelAuthCtx   = NULL;
    _pPWC             = NULL;
    _lpBlockingFilter = NULL;
    _dwCredPolicy     = 0xFFFFFFFF;

    _NoResetBits.Dword = 0;  // only here are we ever allowed to assign to Dword.

    SetDisableNTLMPreauth(GlobalDisableNTLMPreAuth);
    
    _ProxyHostName = NULL;
    _ProxyHostNameLength = NULL;
    _ProxyPort = INTERNET_INVALID_PORT_NUMBER;

    _SocksProxyHostName = NULL;
    _SocksProxyHostNameLength = NULL;
    _SocksProxyPort = INTERNET_INVALID_PORT_NUMBER;

    HttpFiltOpen(); // enumerate http filters if not already active

    _HaveReadFileExData = FALSE;
    memset(&_BuffersOut, 0, sizeof(_BuffersOut));
    _BuffersOut.dwStructSize = sizeof(_BuffersOut);
    _BuffersOut.lpvBuffer = (LPVOID)&_ReadFileExData;

    _fAutoProxyChecked = FALSE;

    m_pSecurityInfo = NULL;
    m_AuthFlag = 0x00000000;

    m_fPPAbortSend = FALSE;

    _fSendUTF8ServerNameToProxy = FALSE;

    SetPriority(0);

    _dwSecurityZone = 0xffffffff; /* initialize to invalid zone value */

#ifdef RLF_TEST_CODE

    static long l = 0;
    SetPriority(l++);

#endif

    _RTT = 0;
    _CP = CP_ACP;

    if (_Status == ERROR_SUCCESS) {
        _Status = _RequestHeaders.GetError();
        if (_Status == ERROR_SUCCESS) {
            _Status = _ResponseHeaders.GetError();
        }
    }

    _dwSocketSendBufferLength = -1;

    if ((_OpenFlags & INTERNET_FLAG_SECURE) &&
        (_Status = LoadSecurity()) == ERROR_SUCCESS)
    {
        m_pSecurityInfo = GlobalCertCache.Find(GetHostName());
        if (NULL == m_pSecurityInfo)
        {
            m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
            // Force a net hit, since this hasn't been fully validated.
            SetCacheReadDisabled();
        }
    }
    else
    {
        m_pSecurityInfo = NULL;
    }
}


HTTP_REQUEST_HANDLE_OBJECT::~HTTP_REQUEST_HANDLE_OBJECT(
    VOID
    )

/*++

Routine Description:

    Destructor for HTTP_REQUEST_HANDLE_OBJECT

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~HTTP_REQUEST_HANDLE_OBJECT",
                "%#x",
                this
                ));

    //
    // close the socket (or free it to the pool if keep-alive)
    //

    //
    // Authentication Note:
    // The CloseConnection parameter to force the connection closed
    // is set if we received a challenge but didn't respond, otherwise
    // IIS will get confused when a subsequent request recycles the
    // socket from the keep-alive pool.
    //

    CloseConnection(GetAuthState() == AUTHSTATE_CHALLENGE);

    if (IsCacheWriteInProgress()) {
        LocalEndCacheWrite(IsEndOfFile());
    }

    if (IsCacheReadInProgress()) {

        INET_ASSERT (_pCacheEntryInfo);
        FREE_MEMORY (_pCacheEntryInfo);

        // Rest is cleaned up in INTERNET_CONNECT_HANDLE_OBJECT::EndCacheWrite

    } else {
        UrlCacheUnlock();
    }

    //
    // If there's an authentication context, unload the provider.
    //

    if (_pAuthCtx) {
        delete _pAuthCtx;
    }
    if (_pTunnelAuthCtx) {
        delete _pTunnelAuthCtx;
    }

    //
    // free the various buffers
    //

    FreeResponseBuffer();
    FreeQueryBuffer();
    SetProxyName(NULL,NULL,0);

    if (m_pSecurityInfo != NULL) {
        m_pSecurityInfo->Release();
    }

    DEBUG_LEAVE(0);
}


HINTERNET
HTTP_REQUEST_HANDLE_OBJECT::GetHandle(
    VOID
    )

/*++

Routine Description:

    Returns child handle value. NULL for HTTP

Arguments:

    None.

Return Value:

    HINTERNET
        NULL

--*/

{
    return NULL;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetProxyName(
    IN LPSTR lpszProxyHostName,
    IN DWORD dwProxyHostNameLength,
    IN INTERNET_PORT ProxyPort
    )

/*++

Routine Description:

    Set proxy name in object. If already have name, free it. Don't set name if
    current pointer is input

Arguments:

    lpszProxyHostName       - pointer to proxy name to add

    dwProxyHostNameLength   - length of proxy name

    ProxyPort               - port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetProxyName",
                 "{%q, %d, %d}%q, %d, %d",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lpszProxyHostName,
                 dwProxyHostNameLength,
                 ProxyPort
                 ));

    if (lpszProxyHostName != _ProxyHostName) {
        if (_ProxyHostName != NULL) {
            _ProxyHostName = (LPSTR)FREE_MEMORY(_ProxyHostName);

            INET_ASSERT(_ProxyHostName == NULL);

            SetOverrideProxyMode(FALSE);
        }
        if (lpszProxyHostName != NULL) {
            _ProxyHostName = NEW_STRING(lpszProxyHostName);
            if (_ProxyHostName == NULL) {
                dwProxyHostNameLength = 0;
            }
        }
        _ProxyHostNameLength = dwProxyHostNameLength;
        _ProxyPort = ProxyPort;
    } else if (lpszProxyHostName != NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("!!! lpszProxyHostName == _ProxyHostName (%#x)\n",
                    lpszProxyHostName
                    ));

        INET_ASSERT(dwProxyHostNameLength == _ProxyHostNameLength);
        INET_ASSERT(ProxyPort == _ProxyPort);

    }

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::GetProxyName(
    OUT LPSTR* lplpszProxyHostName,
    OUT LPDWORD lpdwProxyHostNameLength,
    OUT LPINTERNET_PORT lpProxyPort
    )

/*++

Routine Description:

    Return address & length of proxy name plus proxy port

Arguments:

    lplpszProxyHostName     - returned address of name

    lpdwProxyHostNameLength - returned length of name

    lpProxyPort             - returned port

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::GetProxyName",
                 "{%q, %d, %d}%#x, %#x, %#x",
                 _ProxyHostName,
                 _ProxyHostNameLength,
                 _ProxyPort,
                 lplpszProxyHostName,
                 lpdwProxyHostNameLength,
                 lpProxyPort
                 ));

    *lplpszProxyHostName = _ProxyHostName;
    *lpdwProxyHostNameLength = _ProxyHostNameLength;
    *lpProxyPort = _ProxyPort;

    DEBUG_LEAVE(0);
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReuseObject(
    VOID
    )

/*++

Routine Description:

    Make the object re-usable: clear out any received data and headers and
    reset the state to open

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReuseObject",
                 NULL
                 ));

    _ResponseHeaders.FreeHeaders();
    FreeResponseBuffer();
    ResetResponseVariables();
    _ResponseHeaders.Initialize();
    _dwCurrentStreamPosition = 0;
    SetState(HttpRequestStateOpen);
    ResetEndOfFile();
    _ctChunkInfo.Reset();
    _QueryOffset = 0;
    _QueryBytesAvailable = 0;
    _dwQuerySetCookieHeader = 0;
    if (m_pSecurityInfo) {
        m_pSecurityInfo->Release();
    }
    m_pSecurityInfo = NULL;

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ResetObject(
    IN BOOL bForce,
    IN BOOL bFreeRequestHeaders
    )

/*++

Routine Description:

    This method is called when we we are clearing out a partially completed
    transaction, mainly for when we have determined that an if-modified-since
    request, or a response that has not invalidated the cache entry can be
    retrieved from cache (this is a speed issue)

    Abort the connection and clear out the response headers and response
    buffer; clear the response variables (all done by AbortConnection()).

    If bFreeRequestHeaders, clear out the request headers.

    Reinitialize the response headers. We do not reset the object state, but we
    do reset the end-of-file status

Arguments:

    bForce              - TRUE if connection is forced closed

    bFreeRequestHeaders - TRUE if request headers should be freed

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ResetObject",
                 "%B, %B",
                 bForce,
                 bFreeRequestHeaders
                 ));

    DWORD error;

    error = AbortConnection(bForce);
    if (error == ERROR_SUCCESS) {
        if (bFreeRequestHeaders) {
            _RequestHeaders.FreeHeaders();
        }
        _ResponseHeaders.Initialize();
        ResetEndOfFile();
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::UrlCacheUnlock(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    INET_ASSERT (!_CacheReadInProgress);

    if (_hCacheStream)
    {
        UnlockUrlCacheEntryStream (_hCacheStream, 0);
        _hCacheStream = NULL;
    }

    if (_pCacheEntryInfo)
    {

        if (_pCacheEntryInfo->CacheEntryType & SPARSE_CACHE_ENTRY)
        {

            //
            // We can't use the partial cache entry because it is
            // stale, so delete the data file we got from cache.
            //

            INET_ASSERT (_CacheFileHandle != INVALID_HANDLE_VALUE);
            CloseHandle (_CacheFileHandle);
            _CacheFileHandle = INVALID_HANDLE_VALUE;
            DeleteFile (_pCacheEntryInfo->lpszLocalFileName);
        }

        FREE_MEMORY (_pCacheEntryInfo);
        _pCacheEntryInfo = NULL;
    }
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    SetAuthenticated    -

Return Value:

    None.

--*/

{
    if (!_Socket)
    {
        INET_ASSERT(FALSE);
    }
    else
    {
        _Socket->SetAuthenticated();
    }
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::IsAuthenticated(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    IsAuthenticated -

Return Value:

    BOOL

--*/

{
    return (_Socket ? _Socket->IsAuthenticated() : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cookiepolicy.cxx ===
#include <wininetp.h>

#include "cookiepolicy.h"
#include "urlmon.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) ((sizeof(x)/sizeof(x[0])))
#endif

extern IInternetSecurityManager* g_pSecMgr;
extern "C" DWORD GetZoneFromUrl(LPCSTR pszUrl);

GUID guidCookieSettings = {0xaeba21fa, 0x782a, 0x4a90, 0x97, 0x8d, 
                           0xb7, 0x21, 0x64, 0xc8, 0x01, 0x20};

GUID guid3rdPartySettings = {0xa8a88c49, 0x5eb2, 0x4990,
                             0xa1, 0xa2, 0x08, 0x76, 0x02, 0x2c, 0x85, 0x4f};

const wchar_t *SettingTemplate[];

/* static member definition */
CP3PSettingsCache  CCookieSettings::cookiePrefsCache;

/* settings signature strings */
const char gszP3PV1Signature[] = "IE6-P3PV1/settings:";
const wchar_t gszUnicodeSignature[] = L"IE6-P3PV1/settings:";

BOOL IsNoCookies(DWORD dwZone);
void SetNoCookies(DWORD dwZone, DWORD dwNewPolicy);

struct P3PSymbol {

    const char *pszAcronym;
    unsigned long dwSymIndex;
    unsigned long dwHashCode;
};

/* Macro for determining precedence of cookie actions.
   In IE6 the COOKIE_STATE_* enumeration is arranged such that higher values 
   take precedence. For example, downgrade overrides prompt.
   If one rule evaluates to "downgrade" while others evaluate to "prompt",
   the final decision is "downgrade". */
#define precedence(d)       (d)


 /* special symbols used for defining settings */
const char 
    SymNoPolicy[]       = "###",        /* No-policy */
    SymMissingCP[]      = "nopolicy",   /* Same as "no-policy" */
    SymConstDecision[]  = "%%%",        /* Constant settings */
    SymApplyAll[]       = "always",     /* Same as constant settings */
    SymSession[]        = "session";    /* exclude P3P from session-cookies */

const char *acronymSet[] = {

 /* purposes */
"CURa", "CURi", "CURo",
"ADMa", "ADMi", "ADMo",
"DEVa", "DEVi", "DEVo",
"CUSa", "CUSi", "CUSo",
"TAIa", "TAIi", "TAIo",
"PSAa", "PSAi", "PSAo",
"PSDa", "PSDi", "PSDo",
"IVAa", "IVAi", "IVAo",
"IVDa", "IVDi", "IVDo",
"CONa", "CONi", "CONo",
"HISa", "HISi", "HISo",
"TELa", "TELi", "TELo",
"OTPa", "OTPi", "OTPo",
 
 /* recipients */
"OURa", "OURi", "OURo",
"DELa", "DELi", "DELo",
"SAMa", "SAMi", "SAMo",
"OTRa", "OTRi", "OTRo",
"UNRa", "UNRi", "UNRo",
"PUBa", "PUBi", "PUBo",

 /* retention */
 "NOR", "STP", "LEG", "BUS", "IND", 

 /* categories */
 "PHY", "ONL", "UNI", "PUR", "FIN", "COM", "NAV", "INT", 
 "DEM", "CNT", "STA", "POL", "HEA", "PRE", "GOV", "OTC", 

 /* non-identifiable */
 "NID",

 /* disputes section */
 "DSP", 

 /* access */
 "NOI", "ALL", "CAO", "IDC", "OTI", "NON", 
 
 /* dispute resolution */
 "COR", "MON", "LAW",

 /* TST: token for indicating that a policy is test-version */
 "TST",
};


const int symbolCount = sizeof(acronymSet)/sizeof(char*);

P3PSymbol symbolIndex[symbolCount];

/* 537 is the smallest modulus number which makes the function 1-1 */
const int   HashModulus = 537;
unsigned char lookupArray[HashModulus];

/* This hash function is designed to be collision-free on the P3P 
compact-policy tokens. If new tokens are introduced, MUST
verify that the hash-values remain unique. */
unsigned int hashP3PSymbol(const char *symbol) {

    unsigned long ulValue = (symbol[0]<<24)  |
                            (symbol[1]<<16)  |
                            (symbol[2]<<8)   |
                            (symbol[3]);
    return (ulValue%HashModulus);
}

bool buildSymbolTable(void) {

    memset(lookupArray, 0xFF, sizeof(lookupArray));

    for (int si=0; si<symbolCount; si++) {

        const char *pstr = acronymSet[si];

        symbolIndex[si].pszAcronym = pstr;
        symbolIndex[si].dwSymIndex = si;

        /* Compute unique hash-code from first 3 letters, used for fast comparison */
        symbolIndex[si].dwHashCode = (pstr[0]<<16) | (pstr[1]<<8) | (pstr[2]);

        unsigned int hashIndex = hashP3PSymbol(pstr);
        lookupArray[hashIndex] = (unsigned char) si;
    }
    return true;
}

/* Search the symbol set used in P3P compact-policy declarations
   This function correctly deals with the optional "a" extension
   which can be added to some of the symbols.
   Returns index into the symbol-table or negative value for failure */
int findSymbol(const char *pstr) {

    static bool fReady = buildSymbolTable();

    /* all symbols recognized in P3P-V1 have 3 or 4 characters */
    int symlen = strlen(pstr);
    if (symlen<3 || symlen>4)
        return -1;

    /* compute hash-code for first 3 letters */
    unsigned long dwHashCode = (pstr[0]<<16) | (pstr[1]<<8) | (pstr[2]);

    for (int i=0; i<symbolCount; i++) {

        const char *pSymbol = acronymSet[i];

        /* first three letters MUST match exactly-- otherwise move to next symbol */
        if (symbolIndex[i].dwHashCode != dwHashCode)
            continue;

        /* if no extension is given "a" is implied */
        if (pSymbol[3]==pstr[3] || (pSymbol[3]=='a' && pstr[3]==0))
           return i;
    }

    return -1;
}

/* Semi-public version of the above function (exported by ordinal) */
INTERNETAPI_(int)   FindP3PPolicySymbol(const char *pszSymbol) {
    
    if (pszSymbol)
    {
        return findSymbol(pszSymbol);
    }
    else
    {
        return -1;
    }
}

int mapCookieAction(char ch) {

    int iAction = COOKIE_STATE_UNKNOWN;

    switch (ch) {

    case 'a': iAction = COOKIE_STATE_ACCEPT;      break;
    case 'p': iAction = COOKIE_STATE_PROMPT;      break;
    case 'l': iAction = COOKIE_STATE_LEASH;       break;
    case 'd': iAction = COOKIE_STATE_DOWNGRADE;   break;
    case 'r': iAction = COOKIE_STATE_REJECT;      break;

    default:
        break;
    };

    return iAction;
}

const char *getNextToken(const char *pch, char *pszToken, int cbToken, bool fWhiteSpc, int *pLength) {

    if (pch==NULL || pszToken==NULL || cbToken==0)
        return NULL;

    /* clear token and set optional length to zero */
    *pszToken = '\0';
    if (pLength)
        *pLength = 0;

    /* locate beginning of next token by skipping over white space */
    while (*pch && isspace(*pch))
        pch++;

    int tksize = 0;
    char chStart = *pch;

    if (fWhiteSpc) {    
        /* copy whole token to the space provided */
        while (*pch && !isspace(*pch) && tksize<cbToken)
            pszToken[tksize++] = *pch++;
    }
    else if (ispunct(*pch))
        pszToken[tksize++] = *pch++;
    else {
        /* copy alphanumeric token-- other characters are not included */
        while (*pch && isalnum(*pch) && tksize<cbToken)
            pszToken[tksize++] = *pch++;        
    }

    pszToken[tksize] = '\0';    /* zero-terminate string */

    /* store size of token in optional parameter */
    if (pLength)
        *pLength = tksize;

    /* Return the current position after token last-scanned */
    return pch;
}

void RefreshP3PSettings() {

    CCookieSettings::RefreshP3PSettings();
}

void CCookieSettings::RefreshP3PSettings() {

    cookiePrefsCache.evictAll();
}

bool CCookieSettings::extractCompactPolicy(const char *pszP3PHeader, char *pszPolicy, DWORD *pPolicyLen)
{
    static const char gszPolicyFieldName[] = "CP";

    unsigned long dwFieldLen = 0;
    char *pszValue = FindNamedValue((char*) pszP3PHeader, gszPolicyFieldName, &dwFieldLen);

    if (pszValue && dwFieldLen<*pPolicyLen) {

        *pPolicyLen = dwFieldLen;
        strncpy(pszPolicy, pszValue, dwFieldLen+1);
        pszPolicy[dwFieldLen] = '\0';
        return true;
    }

    /* Reaching this point implies header was incorrectly formatted or
       there is insufficient space to copy the policy */
    *pPolicyLen = dwFieldLen;
    return false;
}

/*
 * Converts a Unicode representation of P3P-V1 settings to ASCII.
 * The settings format is guaranteed to contain only ASCII characters,
 * which allows for the more efficient conversion below instead of
 * calling WideCharToMultiByte()
 */
void CCookieSettings::convertToASCII(char *pszSettings, int cbBytes) {

    wchar_t *pwszUC = (wchar_t*) pszSettings;

    for (int i=0; i<cbBytes/2; i++)
        *pszSettings++ = (char) *pwszUC++;

    *pszSettings = '\0'; // nil-terminate the string
}

/* 
 * Input: pointer to P3P header (contained in the struct P3PCookieState)
 * This functions parses the policy header, extracts and evaluates the
 * compact policy. Eval results are stored in the struct.
 */
int CCookieSettings::EvaluatePolicy(P3PCookieState *pState) {
    int nResult = dwNoPolicyDecision;
    char *pchCompactPolicy = NULL;
    unsigned long dwPolicySize = 2048;
    CompactPolicy sitePolicy;

    if (!pState)
        goto Cleanup;

    pState->fEvaluated = FALSE;

    pchCompactPolicy = (char *) ALLOCATE_FIXED_MEMORY(dwPolicySize);
    if (pchCompactPolicy == NULL)
        goto Cleanup;

    pState->fValidPolicy = pState->pszP3PHeader && 
                           extractCompactPolicy(pState->pszP3PHeader, pchCompactPolicy, &dwPolicySize);

    pState->fIncSession = fApplyToSC ? TRUE : FALSE;

    /* Are the settings independent of policy? */
    if (fConstant) {
        pState->fEvaluated = TRUE;  /* set privacy-eval flag */
        nResult = (pState->dwPolicyState = dwFixedDecision);
        goto Cleanup;
    }

    /* If there is no compact policy in the P3P header return
       the decision which would apply in the case of missing policy */
    if (! pState->fValidPolicy) {
        nResult = (pState->dwPolicyState = dwNoPolicyDecision);
        goto Cleanup;
    }

    /* Otherwise: found compact policy with valid syntax in P3P: header */
    pState->fEvaluated = TRUE;

    const char *pszCompactPolicy = pchCompactPolicy;

    int numTokens = 0;
    int finalDecision = COOKIE_STATE_ACCEPT;
    char achToken[128];

    while (*pszCompactPolicy) {

        pszCompactPolicy = getNextToken(pszCompactPolicy, achToken, sizeof(achToken));

        /* An empty token means we reached end of the header */
        if (!achToken[0])
            break;

        numTokens++;

        int symindex = findSymbol(achToken);

        if (symindex<0)     /* Unrecognized token? */
            continue;       /* Ignore-- equivalent to ACCEPT decision for that token */
        
        /* Update binary representation of compact-policy */
        sitePolicy.addToken(symindex);

        int tokenDecision = MPactions[symindex];

        if (precedence(tokenDecision) > precedence(finalDecision))
            finalDecision = tokenDecision;

        /* REJECT decisions are irreversible: no other value can override this */
        if (finalDecision==COOKIE_STATE_REJECT)
            break;
    }

    /* If there were no tokens in the policy, it is considered invalid.
       Note that unrecognized tokens also count towards the tally. */
    if (numTokens==0) {
        finalDecision = dwNoPolicyDecision;
        pState->fValidPolicy = FALSE;
    }
    else  {
        /* Additional evaluation rules */
        for (CPEvalRule *pRule = pRuleSet;
             pRule; 
             pRule=pRule->pNext) {

            int outcome = pRule->evaluate(sitePolicy);
    
            if (outcome != COOKIE_STATE_UNKNOWN) {
                finalDecision = outcome;
                break;
            }
        }
    }

    pState->cpSitePolicy = sitePolicy;

    nResult = (pState->dwPolicyState = finalDecision);

Cleanup:
    if (pchCompactPolicy)
        FREE_MEMORY(pchCompactPolicy);

    return nResult;
}

bool CCookieSettings::GetSettings(CCookieSettings **ppCookiePref, DWORD dwZone, BOOL f3rdParty) {

    /* symbolic value for corrupt settings */
    static CCookieSettings InvalidSettings(NULL, 0);

    bool fSuccess = false;

    *ppCookiePref = NULL;

    CCookieSettings *pCachedPref = cookiePrefsCache.lookupCookieSettings(dwZone, f3rdParty);

    if (pCachedPref && pCachedPref != &InvalidSettings) {
        *ppCookiePref = pCachedPref;
        fSuccess = true;
        goto ExitPoint;
    }
    else if (pCachedPref==&InvalidSettings)
        goto ExitPoint;

    if(WCHAR *pszSettings = new WCHAR[MaxPrivacySettings])
    {
        DWORD   dwSize = MaxPrivacySettings;

        if(ERROR_SUCCESS == PrivacyGetZonePreferenceW(
                                dwZone,
                                f3rdParty ? PRIVACY_TYPE_THIRD_PARTY : PRIVACY_TYPE_FIRST_PARTY,
                                NULL,
                                pszSettings,
                                &dwSize)
            && *pszSettings)
        {
            *ppCookiePref = new CCookieSettings((BYTE *)pszSettings, sizeof(WCHAR) * lstrlenW(pszSettings));
            cookiePrefsCache.saveCookieSettings(dwZone, f3rdParty, *ppCookiePref);
            fSuccess = true;
        }
        else {
            InvalidSettings.AddRef();
            cookiePrefsCache.saveCookieSettings(dwZone, f3rdParty, &InvalidSettings);
        }

        delete [] pszSettings;
    }

ExitPoint:
    return fSuccess;
}

bool CCookieSettings::GetSettings(CCookieSettings **pCookiePref, const char *pszURL, BOOL f3rdParty, BOOL fRestricted) {

    INET_ASSERT(pszURL);
    INET_ASSERT(pCookiePref);

    DWORD dwZone;

    if (fRestricted)
        dwZone = URLZONE_UNTRUSTED;
    else
        dwZone = GetZoneFromUrl(pszURL);

    return GetSettings(pCookiePref, dwZone, f3rdParty);
}

/* Constructor for interpreting settings in binary format */
CCookieSettings::CCookieSettings(unsigned char *pBinaryRep, int cb) {

    const int siglen = sizeof(gszP3PV1Signature)/sizeof(char);
   
    MPactions = NULL;
    pRuleSet = NULL;
    ppLast = &pRuleSet;

    iRefCount = 1;
    dwNoPolicyDecision = COOKIE_STATE_REJECT;
    fConstant = false;
    fApplyToSC = true;

    if (!pBinaryRep || cb<=0) {

        fConstant = true;
        dwFixedDecision = COOKIE_STATE_ACCEPT;
        return;
    }

    /* Create new zero-terminated copy of the settings which
       can be modified for parsing steps below */
    char *pszBuffer = new char[cb+2];
    
    memcpy(pszBuffer, pBinaryRep, cb);

    pszBuffer[cb] = pszBuffer[cb+1] = '\0';

    /* create and initialize array for token-settings
       default behavior for tokens not listed is ACCEPT */
    MPactions = new unsigned char[symbolCount];
    memset(MPactions, COOKIE_STATE_ACCEPT, sizeof(unsigned char)*symbolCount);

    wchar_t *pwszSettings = (wchar_t*) pszBuffer;
    
    /* convert Unicode representation to ASCII */
    convertToASCII(pszBuffer, cb);

    char *pszSettings = pszBuffer;

    /* check for signature at the beginning of the string */
    if (pszSettings == strstr(pszSettings, gszP3PV1Signature)) {

        /* signature found: advance to first token */
        pszSettings += siglen;

        /* loop over the string, examining individual tokens */
        while (*pszSettings) {

            char achToken[1024], *pEqSign;

            pszSettings = (char*) getNextToken(pszSettings, achToken, sizeof(achToken));

            if (!achToken[0])
                break;

            /* logical-expression rules are enclosed in forward slashes */
            if (achToken[0]=='/') {
                
                if (CPEvalRule *pRule = parseEvalRule(achToken+1))
                    addEvalRule(pRule);
                continue;
            }

            /* each setting has the format:  <acronym>[a|i|o]=[a|p|l|d|r] */
            pEqSign = strchr(achToken, '=');

            /* skip badly formatted settings */
            if (!pEqSign)
                continue;

            *pEqSign = '\0';

            /* determine cookie state for current token.
               its given by the character after the equal sign */
            int iTokenSetting = mapCookieAction(pEqSign[1]);

            if (iTokenSetting == COOKIE_STATE_UNKNOWN)
                continue;

            int symIndex = findSymbol(achToken);

            if (symIndex<0) { /* not one of standard compact-policy tokens? */
                /* meta-symbols are handled in a separate function */
                parseSpecialSymbol(achToken, iTokenSetting);
                continue;             /* otherwise ignore */
            }

            MPactions[symIndex] = (unsigned char) iTokenSetting;
        }
    }

    delete [] pszBuffer;
}

bool CCookieSettings::parseSpecialSymbol(char *pszToken, int iSetting) {

    if (!strcmp(pszToken, SymNoPolicy)  ||
        !strcmp(pszToken, SymMissingCP))
        dwNoPolicyDecision = iSetting;
    else if (!strcmp(pszToken, SymConstDecision) ||
             !strcmp(pszToken, SymApplyAll)) {
        fConstant = true;
        dwFixedDecision = iSetting;
    }
    else if (!strcmp(pszToken, SymSession) && iSetting==COOKIE_STATE_ACCEPT)
        fApplyToSC = false;
    else
        return false;

    return true;
}

void CCookieSettings::addEvalRule(CPEvalRule *pRule) {

    /* add evaluation rule at end of linked list */
    *ppLast = pRule;
    pRule->pNext = NULL;
    ppLast = & (pRule->pNext);    
}

void CCookieSettings::Release() {
    
    if (! --iRefCount)
        delete this;
}

CCookieSettings::~CCookieSettings() {

    /* Free array of token decisions */
    if (MPactions)
        delete [] MPactions;

    /* Free linked-list of evaluation rules */
    while (pRuleSet) {
        CPEvalRule *pNext = pRuleSet->pNext;
        delete pRuleSet;
        pRuleSet = pNext;
    }
}

/*
Implementation of CP3PSettingsCache
*/
CP3PSettingsCache::CP3PSettingsCache() {

    memset (stdCookiePref, 0 ,sizeof(stdCookiePref));
    memset (std3rdPartyPref, 0, sizeof(std3rdPartyPref));

    InitializeCriticalSection(&csCache);
}

CP3PSettingsCache::~CP3PSettingsCache() {

    DeleteCriticalSection(&csCache);
}

CCookieSettings *CP3PSettingsCache::lookupCookieSettings(DWORD dwZone, BOOL f3rdParty) {

    if (dwZone>MaxKnownZone)
        return NULL;

    CriticalSectOwner csOwner(&csCache);

    CCookieSettings **ppStore;

    // Choose storage based on whether cookie is 3rd-party
    if (f3rdParty)
        ppStore = std3rdPartyPref;
    else
        ppStore = stdCookiePref;

    // Increase reference count before returning pointer
    if (ppStore[dwZone])
        ppStore[dwZone]->AddRef();

    return ppStore[dwZone];
}

void    CP3PSettingsCache::saveCookieSettings(DWORD dwZone, BOOL f3rdParty, CCookieSettings *pSettings) {

    if (dwZone>MaxKnownZone)
        return;

    CriticalSectOwner csOwner(&csCache);

    CCookieSettings **ppStore;

    // Choose storage based on whether cookie is 3rd-party
    if (f3rdParty)
        ppStore = std3rdPartyPref;
    else
        ppStore = stdCookiePref;

    pSettings->AddRef();

    ppStore[dwZone] = pSettings;
}


void CP3PSettingsCache::evictAll() {

    CriticalSectOwner csOwner(&csCache);

    /* Release all settings.
       Destructors are not invoked if there are outstanding
       references left. (eg the settings are being used for evaluation)
       Object will be freed when all references are gone. */

    for (int i=0; i<MaxKnownZone; i++) {

        if (stdCookiePref[i])
            stdCookiePref[i]->Release();

        if (std3rdPartyPref[i])
            std3rdPartyPref[i]->Release();
    }

    /* zero-out the arrays */
    memset (stdCookiePref, 0 ,sizeof(stdCookiePref));
    memset (std3rdPartyPref, 0, sizeof(std3rdPartyPref));
}


/*
Implementation of CompactPolicy structure
*/
CompactPolicy CompactPolicy::operator & (const CompactPolicy &ps)   const {

    CompactPolicy result;

    result.qwLow = qwLow & ps.qwLow;
    result.qwHigh = qwHigh & ps.qwHigh;
    return result;
}

bool CompactPolicy::operator == (const CompactPolicy &ps)  const {

    return (qwLow==ps.qwLow)    &&
           (qwHigh==ps.qwHigh);
}

bool CompactPolicy::operator != (const CompactPolicy &ps)  const {

    return (qwLow!=ps.qwLow)    ||
           (qwHigh!=ps.qwHigh);
}

void CompactPolicy::addToken(int index) {

    const quadword mask = 1;

    if (index<64)
        qwLow |= mask << index;
    else if (index<128)
        qwHigh |= mask << (index-64);
}

int CompactPolicy::contains(int index) {

    quadword mask = 1 << (index%64);

    if (index<64)
        mask &= qwLow;
    else
        mask &= qwHigh;

    return (mask!=0);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Privacy settings API and helper functions
//
//////////////////////////////////////////////////////////////////////////////////////////////////

#define REGSTR_PATH_ZONE        L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones"
#define REGSTR_VAL_FIRST_PARTY  L"{AEBA21FA-782A-4A90-978D-B72164C80120}"
#define REGSTR_VAL_THIRD_PARTY  L"{A8A88C49-5EB2-4990-A1A2-0876022C854F}"

#define SIGNATURE_NONE          0
#define SIGNATURE_UNICODE       1
#define SIGNATURE_MULTIBYTE     2

#define MIN(a,b) (((DWORD_PTR)a) < ((DWORD_PTR)b) ? (a) : (b))

DWORD IsSignaturePresent(BYTE *pbBuffer, DWORD dwBufferBytes)
{
    if(dwBufferBytes && 0 == StrCmpNIW(
                (LPCWSTR)pbBuffer,
                gszUnicodeSignature,
                MIN(dwBufferBytes / sizeof(WCHAR), lstrlenW(gszUnicodeSignature))
                ))
    {
        return SIGNATURE_UNICODE;
    }

    if(dwBufferBytes && 0 == StrCmpNI(
                (LPCSTR)pbBuffer,
                gszP3PV1Signature,
                MIN(dwBufferBytes / sizeof(CHAR), lstrlenA(gszP3PV1Signature))
                ))
    {
        return SIGNATURE_MULTIBYTE;
    }

    return SIGNATURE_NONE;
}

void AddHardeningPrivacyDefaults()
{
    // Internet to Medium
    PrivacySetZonePreferenceW(URLZONE_TRUSTED, PRIVACY_TYPE_FIRST_PARTY, PRIVACY_TEMPLATE_MEDIUM, NULL);
    PrivacySetZonePreferenceW(URLZONE_TRUSTED, PRIVACY_TYPE_THIRD_PARTY, PRIVACY_TEMPLATE_MEDIUM, NULL);
}

void RemoveHardeningPrivacyDefaults()
{
    WCHAR   szRegPath[MAX_PATH];
    // build reg path
    wnsprintfW(szRegPath, MAX_PATH, L"%ws\\2", REGSTR_PATH_ZONE);

    SHDeleteValueW(HKEY_CURRENT_USER,
                    szRegPath,
                    REGSTR_VAL_FIRST_PARTY);

    SHDeleteValueW(
                    HKEY_CURRENT_USER,
                    szRegPath,
                    REGSTR_VAL_THIRD_PARTY);

}

void
CheckPrivacyDefaults(void)
{
    WCHAR   szRegPath[MAX_PATH], szValue[MAX_PATH];
    BOOL    fWriteSettings = TRUE;
    DWORD   dwError, dwLen = MAX_PATH;

    // build reg path
    wnsprintfW(szRegPath, MAX_PATH, L"%ws\\3", REGSTR_PATH_ZONE);

    dwError = SHGetValueW(
                    HKEY_CURRENT_USER,
                    szRegPath,
                    REGSTR_VAL_FIRST_PARTY,
                    NULL,
                    szValue,
                    &dwLen);

    switch(dwError)
    {
    case ERROR_SUCCESS:
        // check to see if the plaintext signature is present
        if(SIGNATURE_NONE == IsSignaturePresent((BYTE *)szValue, dwLen))
        {
            // plaintext signature not present, don't overwrite.
            fWriteSettings = FALSE;
        }
        break;
    case ERROR_FILE_NOT_FOUND:
        // no existing settings, write defaults
        break;
    case ERROR_MORE_DATA:
        // longer than max_path... not an old setting, so leave it alone
        fWriteSettings = FALSE;
        break;
    default:
        // unknown error, write defaults
        break;
    }

    if(fWriteSettings)
    {
        // Internet to Medium
        PrivacySetZonePreferenceW(URLZONE_INTERNET, PRIVACY_TYPE_FIRST_PARTY, PRIVACY_TEMPLATE_MEDIUM, NULL);
        PrivacySetZonePreferenceW(URLZONE_INTERNET, PRIVACY_TYPE_THIRD_PARTY, PRIVACY_TEMPLATE_MEDIUM, NULL);

        // Restriced to High
        PrivacySetZonePreferenceW(URLZONE_UNTRUSTED, PRIVACY_TYPE_FIRST_PARTY, PRIVACY_TEMPLATE_NO_COOKIES, NULL);
        PrivacySetZonePreferenceW(URLZONE_UNTRUSTED, PRIVACY_TYPE_THIRD_PARTY, PRIVACY_TEMPLATE_NO_COOKIES, NULL);
    }
}


//
// Obfuscation of settings string
//
// GetNextObsByte takes an OBS struct detailing the current placement.  4 bits of each value in bCode are
// taken to compute the substring length to contribute to the entire code.  The following bytes give
// the following contributions:
//
// 53 71 59 69 77 6a 63 51 43 67 51 78 72 45 67 4f
// 0b 0a 0d 05 0b 04 03 0b 02 04 08 0b 0b 04 04 08
//
// Total length: 119
//
// GetNextObsByte returns the 11 bytes of the array followed by the first 10,
// then 13, etc.


BYTE bCode[16] = {0x53, 0x71, 0x59, 0x69, 0x77, 0x6a, 0x63, 0x51, 0x43, 0x67, 0x51, 0x78, 0x72, 0x45, 0x67, 0x4f};

typedef struct _obs {
    INT     iCurNode;
    INT     iCurIndex;
} OBS, *POBS;

BYTE GetNextObsByte(POBS pobs)
{
    BYTE    bTarget = bCode[pobs->iCurIndex];

    pobs->iCurIndex++;
    if(pobs->iCurIndex > ((bCode[pobs->iCurNode] & 0x1e) >> 1))
    {
        // move to next node
        pobs->iCurIndex = 0;
        pobs->iCurNode++;

        // move back to beginning if all done
        if(pobs->iCurNode > 15)
        {
            pobs->iCurNode = 0;
        }
    }

    return bTarget;
}

//
// Obfuscate a string in place and collapse out 0-bytes in unicode string
//
void ObfuscateString(LPWSTR pszString, int iLen)
{
    OBS     obs = {0};
    INT     iCur = 0;
    BYTE    *pbStream;
    INT     iIndex;

    pbStream = (BYTE *)pszString;

    while(iCur < iLen)
    {
        iIndex = obs.iCurIndex;
        pbStream[iCur] = (((BYTE)(pszString[iCur]) + iIndex) ^ GetNextObsByte(&obs));
        iCur++;
    }
}

//
// Unobfuscate a string - undo what obfuscate does
//
void UnobfuscateString(BYTE *pbStream, LPWSTR pszString, int iLen)
{
    OBS     obs = {0};
    INT     iIndex;
    INT     iCur = 0;

    while(iCur < iLen)
    {
        iIndex = obs.iCurIndex;
        pszString[iCur] = (pbStream[iCur] ^ GetNextObsByte(&obs)) - iIndex;
        iCur++;
    }

    // null terminate string
    pszString[iCur] = 0;
}

//
// Set and query advanced mode
//
#define REGSTR_VAL_PRIVADV      TEXT("PrivacyAdvanced")

BOOL IsAdvanced(void)
{
    DWORD   dwValue = 0;
    BOOL    fAdvanced = FALSE;

    InternetReadRegistryDword(REGSTR_VAL_PRIVADV, &dwValue);

    if(dwValue)
    {
        fAdvanced = TRUE;
    }

    return fAdvanced;
}

void SetAdvancedMode(BOOL fAdvanced)
{
    DWORD   dwAdvanced = fAdvanced? 1 : 0;

    // save advanced flag
    InternetWriteRegistryDword(REGSTR_VAL_PRIVADV, dwAdvanced);
}

//
// Public APIs
//

INTERNETAPI_(DWORD)
PrivacySetZonePreferenceW(
    DWORD       dwZone, 
    DWORD       dwType,
    DWORD       dwTemplate,
    LPCWSTR     pszPreference
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "PrivacySetZonePreferenceW",
                "%#x, %#x, %#x, %#x (%q)",
                dwZone,
                dwType,
                dwTemplate,
                pszPreference
                ));

    DWORD dwError = ERROR_INVALID_PARAMETER;

    //
    // validate parameters
    //
    if(dwZone > URLZONE_UNTRUSTED && (dwZone < URLZONE_USER_MIN || dwZone > URLZONE_USER_MAX))
    {
        goto exit;
    }

    if(dwType > PRIVACY_TYPE_THIRD_PARTY)
    {
        goto exit;
    }

    if( dwTemplate > PRIVACY_TEMPLATE_MAX
        && (dwTemplate < PRIVACY_TEMPLATE_CUSTOM || dwTemplate > PRIVACY_TEMPLATE_ADVANCED))
    {
        goto exit;
    }

    if(pszPreference && IsBadStringPtrW(pszPreference, MaxPrivacySettings))  
    // in debug, verifies string is readable up to '\0' or pszPreference[MaxPrivacySettings].
    {
        goto exit;
    }

    if(pszPreference && (dwTemplate != PRIVACY_TEMPLATE_CUSTOM && dwTemplate != PRIVACY_TEMPLATE_ADVANCED))
    {
        goto exit;
    }

    if(NULL == pszPreference && dwTemplate == PRIVACY_TEMPLATE_CUSTOM)
    {
        // custom needs a preference string
        goto exit;
    }

    //
    // Make buffer with new preference
    //
    WCHAR   *pszRegPref;
    LPCWSTR pszCopyStr;
    DWORD   dwPrefLen;

    if(dwTemplate < PRIVACY_TEMPLATE_CUSTOM)
    {
        // figure out appropriate template string
        // Strings are organized as follows:
        //
        // high first
        // high third
        // med-hi first
        // med-hi third
        // ...
        pszCopyStr = SettingTemplate[2 * dwTemplate + dwType];
    }
    else
    {
        // copy passed pref string to new buffer
        pszCopyStr = pszPreference;
    }

    //
    // alloc buffer, copy appropriate string
    //
    dwPrefLen = lstrlenW(pszCopyStr);
    pszRegPref = new WCHAR[dwPrefLen + 1];
    if(pszRegPref == NULL)
    {
        goto exit;
    }
    StrCpyNW(pszRegPref, pszCopyStr, dwPrefLen + 1);

    //
    // Obfuscate string in place, dwPrefLen *BYTES* (NOT unicode chars) left afterwards
    //
    dwPrefLen = lstrlenW(pszRegPref);
    ObfuscateString(pszRegPref, dwPrefLen);

    //
    // Build reg path for appropriate setting
    //
    WCHAR   *pszRegPath = new WCHAR[MAX_PATH];

    if(pszRegPath)
    {
        wnsprintfW(pszRegPath, MAX_PATH, L"%ws\\%d", REGSTR_PATH_ZONE, dwZone);

        //
        // Stuff it in the registry
        //
        dwError = SHSetValueW(
                    HKEY_CURRENT_USER,
                    pszRegPath,
                    (dwType == PRIVACY_TYPE_FIRST_PARTY) ? REGSTR_VAL_FIRST_PARTY : REGSTR_VAL_THIRD_PARTY,
                    REG_BINARY,
                    pszRegPref,
                    dwPrefLen);     // write out dwPrefLen *BYTES*

        delete [] pszRegPath;

        // update advanced and no cookies settings
        BOOL fAdvanced = FALSE;
        DWORD dwPolicy = URLPOLICY_QUERY;

        if(URLZONE_INTERNET == dwZone && PRIVACY_TEMPLATE_ADVANCED == dwTemplate)
        {
            fAdvanced = TRUE;
        }

        if(PRIVACY_TEMPLATE_NO_COOKIES == dwTemplate)
        {
            dwPolicy = URLPOLICY_DISALLOW;
        }

        if(PRIVACY_TEMPLATE_LOW == dwTemplate)
        {
            dwPolicy = URLPOLICY_ALLOW;
        }

        SetAdvancedMode(fAdvanced);
        SetNoCookies(dwZone, dwPolicy);
    }
    else
    {
        dwError = ERROR_OUTOFMEMORY;
    }

    delete [] pszRegPref;

exit:
    DEBUG_LEAVE_API(dwError);
    return dwError;
}


INTERNETAPI_(DWORD)
PrivacyGetZonePreferenceW(
    DWORD       dwZone,
    DWORD       dwType,
    LPDWORD     pdwTemplate,
    LPWSTR      pszBuffer,
    LPDWORD     pdwBufferLength
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "PrivacyGetZonePreferenceW",
                "%#x, %#x, %#x, %#x, %#x",
                dwZone,
                dwType,
                pdwTemplate,
                pszBuffer,
                pdwBufferLength
                ));

    DWORD dwError = ERROR_INVALID_PARAMETER;

    //
    // validate parameters
    //
    if(dwZone > URLZONE_UNTRUSTED && (dwZone < URLZONE_USER_MIN || dwZone > URLZONE_USER_MAX))
    {
        goto exit;
    }

    if(dwType > PRIVACY_TYPE_THIRD_PARTY)
    {
        goto exit;
    }

    if(pdwTemplate && IsBadWritePtr(pdwTemplate, sizeof(DWORD)))
    {
        goto exit;
    }

    // both pszBuffer and pdwBufferLength must be non-null and valid or both much be null
    if(pszBuffer || pdwBufferLength)
    {
        if(IsBadWritePtr(pdwBufferLength, sizeof(DWORD)) || IsBadWritePtr(pszBuffer, *pdwBufferLength))
        {
            goto exit;
        }
    }

    //
    // Allocate buffers for registry read and build path
    //
    WCHAR   *pszRegPath = new WCHAR[MAX_PATH];
    WCHAR   *pszRegPref;
    DWORD   dwRegPrefLen = MaxPrivacySettings;      // BYTES
    BYTE    *pbRegReadLoc;
    
    if(NULL == pszRegPath)
    {
        dwError = ERROR_OUTOFMEMORY;
        goto exit;
    }

    pszRegPref = new WCHAR[MaxPrivacySettings];
    if(NULL == pszRegPref)
    {
        delete [] pszRegPath;
        dwError = ERROR_OUTOFMEMORY;
        goto exit;
    }

    wnsprintfW(pszRegPath, MAX_PATH, L"%ws\\%d", REGSTR_PATH_ZONE, dwZone);

    //
    // Read registry value.
    //
    // Since the written value (assuming it's valid) is at most MaxPrivacySettings BYTES, read
    // it in to the second half of the buffer so it can be expanded to unicode chars in place.
    //
    // Note buffer is allocated to hold MaxPrivacySettings WCHARs
    //
    pbRegReadLoc = (BYTE *)(pszRegPref + (MaxPrivacySettings / sizeof(WCHAR)));

    dwError = SHGetValueW(
        HKEY_CURRENT_USER,
        pszRegPath,
        (dwType == PRIVACY_TYPE_FIRST_PARTY) ? REGSTR_VAL_FIRST_PARTY : REGSTR_VAL_THIRD_PARTY,
        NULL,
        pbRegReadLoc,
        &dwRegPrefLen);

    if( ERROR_SUCCESS != dwError
        || IsSignaturePresent(pbRegReadLoc, dwRegPrefLen)
        )
    {
        // no reg setting => not fatal
        // buffer too small => invalid settings string
        // any other reg error => opps
        // found plaintext signature => someone bogarting registry
        // in any case, return empty string
        dwRegPrefLen = 0;
        dwError = ERROR_SUCCESS;
    }

    delete [] pszRegPath;

    //
    // Unobfuscate it
    //
    UnobfuscateString(pbRegReadLoc, pszRegPref, dwRegPrefLen);
    if(SIGNATURE_NONE == IsSignaturePresent((BYTE *)pszRegPref, dwRegPrefLen * sizeof(WCHAR)))
    {
        // internal error.. never expect this to happen
        *pszRegPref = 0;
        dwRegPrefLen = 0;
        dwError = ERROR_SUCCESS;
    }

    //
    // Try to copy to callers buffer if necessary
    //
    if(pszBuffer)
    {
        if(dwRegPrefLen < *pdwBufferLength)
        {
            StrCpyNW(pszBuffer, pszRegPref, *pdwBufferLength);
        }
        else
        {
            dwError = ERROR_MORE_DATA;
        }

        *pdwBufferLength = dwRegPrefLen + 1;
    }

    //
    // Try to match it to a template if necessary
    //
    if(pdwTemplate)
    {
        *pdwTemplate = PRIVACY_TEMPLATE_CUSTOM;

        if(URLZONE_INTERNET == dwZone && IsAdvanced())
        {
            *pdwTemplate = PRIVACY_TEMPLATE_ADVANCED;
        }
        else if(IsNoCookies(dwZone))
        {
            *pdwTemplate = PRIVACY_TEMPLATE_NO_COOKIES;
        }
        else if(*pszRegPref)
        {
            DWORD   dwTemplate;
            DWORD   dwTemplateId;
            
            for(dwTemplate = 0; dwTemplate <= PRIVACY_TEMPLATE_MAX; dwTemplate++)
            {
                dwTemplateId = 2 * dwTemplate + dwType;

                if(0 == StrCmpIW(SettingTemplate[dwTemplateId], pszRegPref))
                {
                    *pdwTemplate = dwTemplate;
                    break;
                }
            }
        }
    }

    delete [] pszRegPref;

exit:
    DEBUG_LEAVE_API(dwError);
    return dwError;
}


/* 
templates for default cookie settings 
Consistency condition: decision for TST token == decision for no-policy
In other words, presence of "TST" token invalidates the entire policy 
*/

/*
** WARNING:  Settings code assumes all the first party templates are distinct and all the third party
**           templates are distinct.  If you're changing a template, ensure this is true.  You can simply
**           swap clauses if necessary.
**
** Contact darrenmi for more info.
*/

/*
BEGIN low -- see warning above before changing
*/

const wchar_t achLow1stParty[] =

L"IE6-P3PV1/settings: always=a";

const wchar_t achLow3rdParty[] =

L"IE6-P3PV1/settings: always=a";

/*
END low
*/


/* BEGIN medium-low -- see warning above before changing */

const wchar_t achMedLow1stParty[] =

L"IE6-P3PV1/settings: nopolicy=l session=a /TST=l/ /=a/"
;


const wchar_t achMedLow3rdParty[] =

L"IE6-P3PV1/settings: nopolicy=d /TST=d/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=d/ /PHY&OTR=d/ /PHY&UNR=d/ /PHY&PUB=d/ /PHY&CUS=d/ /PHY&IVA=d/ /PHY&IVD=d/"
L" /PHY&CON=d/ /PHY&TEL=d/ /PHY&OTP=d/ /ONL&SAM=d/ /ONL&OTR=d/ /ONL&UNR=d/ /ONL&PUB=d/"
L" /ONL&CUS=d/ /ONL&IVA=d/ /ONL&IVD=d/ /ONL&CON=d/ /ONL&TEL=d/ /ONL&OTP=d/ /GOV&SAM=d/"
L" /GOV&OTR=d/ /GOV&UNR=d/ /GOV&PUB=d/ /GOV&CUS=d/ /GOV&IVA=d/ /GOV&IVD=d/ /GOV&CON=d/ /GOV&TEL=d/"
L" /GOV&OTP=d/ /FIN&SAM=d/ /FIN&OTR=d/ /FIN&UNR=d/ /FIN&PUB=d/ /FIN&CUS=d/ /FIN&IVA=d/"
L" /FIN&IVD=d/ /FIN&CON=d/ /FIN&TEL=d/ /FIN&OTP=d/ /=a/"
;

/* END medium-low */

/* BEGIN medium -- see warning above before changing */

const wchar_t achMedium1stParty[] =

L"IE6-P3PV1/settings: nopolicy=l session=a /TST=l/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=d/ /PHY&OTR=d/ /PHY&UNR=d/ /PHY&PUB=d/ /PHY&CUS=d/ /PHY&IVA=d/ /PHY&IVD=d/"
L" /PHY&CON=d/ /PHY&TEL=d/ /PHY&OTP=d/ /ONL&SAM=d/ /ONL&OTR=d/ /ONL&UNR=d/ /ONL&PUB=d/"
L" /ONL&CUS=d/ /ONL&IVA=d/ /ONL&IVD=d/ /ONL&CON=d/ /ONL&TEL=d/ /ONL&OTP=d/ /GOV&SAM=d/"
L" /GOV&OTR=d/ /GOV&UNR=d/ /GOV&PUB=d/ /GOV&CUS=d/ /GOV&IVA=d/ /GOV&IVD=d/ /GOV&CON=d/ /GOV&TEL=d/"
L" /GOV&OTP=d/ /FIN&SAM=d/ /FIN&OTR=d/ /FIN&UNR=d/ /FIN&PUB=d/ /FIN&CUS=d/ /FIN&IVA=d/"
L" /FIN&IVD=d/ /FIN&CON=d/ /FIN&TEL=d/ /FIN&OTP=d/ /=a/"
;

const wchar_t achMedium3rdParty[] =

L"IE6-P3PV1/settings: nopolicy=r /TST=r/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/"
L" /PHY&CON=r/ /PHY&TEL=r/ /PHY&OTP=r/ /ONL&SAM=r/ /ONL&OTR=r/ /ONL&UNR=r/ /ONL&PUB=r/"
L" /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/ /GOV&SAM=r/"
L" /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/ /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/"
L" /GOV&OTP=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /=a/"
;

/* END medium */


/* BEGIN medium-high -- see warning above before changing */

const wchar_t achMedHigh1stParty[] = 

L"IE6-P3PV1/settings: nopolicy=l session=a /TST=l/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/ /PHY&CON=r/"
L" /PHY&TEL=r/ /PHY&OTP=r/ /ONL&SAM=r/ /ONL&OTR=r/ /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/"
L" /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /FIN&SAM=r/ /FIN&OTR=r/"
L" /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/ /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /=a/"
;

const wchar_t achMedHigh3rdParty[] = 

/* CAUTION: this setting is identical to 3rd party HIGH.
   We need a cosmetic change to the string to distinguish template levels. */
L"IE6-P3PV1/settings: /TST=r/ nopolicy=r"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/ /PHY&CON=r/"
L" /PHY&TEL=r/ /PHY&OTP=r/ /PHY&SAMo=r/ /PHY&OTRo=r/ /PHY&UNRo=r/ /PHY&PUBo=r/ /PHY&CUSo=r/"
L" /PHY&IVAo=r/ /PHY&IVDo=r/ /PHY&CONo=r/ /PHY&TELo=r/ /PHY&OTPo=r/ /ONL&SAM=r/ /ONL&OTR=r/"
L" /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/"
L" /ONL&SAMo=r/ /ONL&OTRo=r/ /ONL&UNRo=r/ /ONL&PUBo=r/ /ONL&CUSo=r/ /ONL&IVAo=r/ /ONL&IVDo=r/"
L" /ONL&CONo=r/ /ONL&TELo=r/ /ONL&OTPo=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /GOV&SAMo=r/"
L" /GOV&OTRo=r/ /GOV&UNRo=r/ /GOV&PUBo=r/ /GOV&CUSo=r/ /GOV&IVAo=r/ /GOV&IVDo=r/ /GOV&CONo=r/ /GOV&TELo=r/"
L" /GOV&OTPo=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /FIN&SAMo=r/ /FIN&OTRo=r/ /FIN&UNRo=r/"
L" /FIN&PUBo=r/ /FIN&CUSo=r/ /FIN&IVAo=r/ /FIN&IVDo=r/ /FIN&CONo=r/ /FIN&TELo=r/ /FIN&OTPo=r/ /=a/"
;

/* END medium-high */


/* BEGIN high -- see warning above before changing */

const wchar_t achHigh1stParty[] =

L"IE6-P3PV1/settings: nopolicy=r /TST=r/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/"
L" /PHY&CON=r/ /PHY&TEL=r/ /PHY&OTP=r/ /PHY&SAMo=r/ /PHY&OTRo=r/ /PHY&UNRo=r/ /PHY&PUBo=r/"
L" /PHY&CUSo=r/ /PHY&IVAo=r/ /PHY&IVDo=r/ /PHY&CONo=r/ /PHY&TELo=r/ /PHY&OTPo=r/ /ONL&SAM=r/ "
L" /ONL&OTR=r/ /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/"
L" /ONL&SAMo=r/ /ONL&OTRo=r/ /ONL&UNRo=r/ /ONL&PUBo=r/ /ONL&CUSo=r/ /ONL&IVAo=r/ /ONL&IVDo=r/"
L" /ONL&CONo=r/ /ONL&TELo=r/ /ONL&OTPo=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /GOV&SAMo=r/ "
L" /GOV&OTRo=r/ /GOV&UNRo=r/ /GOV&PUBo=r/ /GOV&CUSo=r/ /GOV&IVAo=r/ /GOV&IVDo=r/ /GOV&CONo=r/ /GOV&TELo=r/"
L" /GOV&OTPo=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /FIN&SAMo=r/ /FIN&OTRo=r/ /FIN&UNRo=r/"
L" /FIN&PUBo=r/ /FIN&CUSo=r/ /FIN&IVAo=r/ /FIN&IVDo=r/ /FIN&CONo=r/ /FIN&TELo=r/ /FIN&OTPo=r/ /=a/"
;

const wchar_t achHigh3rdParty[] =

L"IE6-P3PV1/settings: nopolicy=r /TST=r/"
L" /PHY&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /ONL&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /GOV&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /FIN&!CUR&!ADM&!DEV&!CUS&!TAI&!PSA&!PSD&!IVA&!IVD&!CON&!HIS&!TEL&!OTP&!CURi&!ADMi&!DEVi&!CUSi&!TAIi&!PSAi&!PSDi&!IVAi&!IVDi&!CONi&!HISi&!TELi&!OTPi&!CURo&!ADMo&!DEVo&!CUSo&!TAIo&!PSAo&!PSDo&!IVAo&!IVDo&!CONo&!HISo&!TELo&!OTPo=r/"
L" /PHY&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /ONL&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /GOV&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /FIN&!DEL&!SAM&!UNR&!PUB&!OTR&!OUR&!DELi&!SAMi&!UNRi&!PUBi&!OTRi&!DELo&!SAMo&!UNRo&!PUBo&!OTRo=r/"
L" /PHY&SAM=r/ /PHY&OTR=r/ /PHY&UNR=r/ /PHY&PUB=r/ /PHY&CUS=r/ /PHY&IVA=r/ /PHY&IVD=r/ /PHY&CON=r/"
L" /PHY&TEL=r/ /PHY&OTP=r/ /PHY&SAMo=r/ /PHY&OTRo=r/ /PHY&UNRo=r/ /PHY&PUBo=r/ /PHY&CUSo=r/"
L" /PHY&IVAo=r/ /PHY&IVDo=r/ /PHY&CONo=r/ /PHY&TELo=r/ /PHY&OTPo=r/ /ONL&SAM=r/ /ONL&OTR=r/"
L" /ONL&UNR=r/ /ONL&PUB=r/ /ONL&CUS=r/ /ONL&IVA=r/ /ONL&IVD=r/ /ONL&CON=r/ /ONL&TEL=r/ /ONL&OTP=r/"
L" /ONL&SAMo=r/ /ONL&OTRo=r/ /ONL&UNRo=r/ /ONL&PUBo=r/ /ONL&CUSo=r/ /ONL&IVAo=r/ /ONL&IVDo=r/"
L" /ONL&CONo=r/ /ONL&TELo=r/ /ONL&OTPo=r/ /GOV&SAM=r/ /GOV&OTR=r/ /GOV&UNR=r/ /GOV&PUB=r/"
L" /GOV&CUS=r/ /GOV&IVA=r/ /GOV&IVD=r/ /GOV&CON=r/ /GOV&TEL=r/ /GOV&OTP=r/ /GOV&SAMo=r/ "
L" /GOV&OTRo=r/ /GOV&UNRo=r/ /GOV&PUBo=r/ /GOV&CUSo=r/ /GOV&IVAo=r/ /GOV&IVDo=r/ /GOV&CONo=r/ /GOV&TELo=r/"
L" /GOV&OTPo=r/ /FIN&SAM=r/ /FIN&OTR=r/ /FIN&UNR=r/ /FIN&PUB=r/ /FIN&CUS=r/ /FIN&IVA=r/"
L" /FIN&IVD=r/ /FIN&CON=r/ /FIN&TEL=r/ /FIN&OTP=r/ /FIN&SAMo=r/ /FIN&OTRo=r/ /FIN&UNRo=r/"
L" /FIN&PUBo=r/ /FIN&CUSo=r/ /FIN&IVAo=r/ /FIN&IVDo=r/ /FIN&CONo=r/ /FIN&TELo=r/ /FIN&OTPo=r/ /=a/"
;

/* END high */

/* BEGIN NO COOKIES -- see warning above before changing */

const wchar_t achNoCookies1stParty[] =

L"IE6-P3PV1/settings: always=r";

const wchar_t achNoCookies3rdParty[] =

L"IE6-P3PV1/settings: always=r";

/* END NO COOKIES */


const wchar_t *SettingTemplate[] = {

    achNoCookies1stParty,
    achNoCookies3rdParty,
    achHigh1stParty,
    achHigh3rdParty,
    achMedHigh1stParty,
    achMedHigh3rdParty,
    achMedium1stParty,
    achMedium3rdParty,
    achMedLow1stParty,
    achMedLow3rdParty,
    achLow1stParty,
    achLow3rdParty,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cookieprompt.h ===
#include <wininetp.h>

/* 
 * Object for persisting cookie-decisions made by the user at prompt
 * Current implementation uses the registry for storage.
 */
class CCookiePromptHistory {

public:
    CCookiePromptHistory(const char *pchRegistryPath, bool fUseHKLM=false);
    ~CCookiePromptHistory();
    
    BOOL    lookupDecision(const char *pchHostName, 
                           const char *pchPolicyID, 
                           unsigned long *pdwDecision);

    BOOL    saveDecision(const char *pchHostName, 
                         const char *pchPolicyID, 
                         unsigned long dwDecision);

    BOOL    clearDecision(const char *pchHostName,
                          const char *pchPolicyID);

    BOOL    clearAll();

    /* Enumerate decisions in the prompt history.
       Only supports enumerating the default decision (eg policyID=empty) */
    unsigned long enumerateDecisions(char *pchSiteName, 
                                     unsigned long *pcbName, 
                                     unsigned long *pdwDecision,
                                     unsigned long dwIndex);

private:
    HKEY    OpenRootKey();
    BOOL    CloseRootKey(HKEY hkeyRoot);
    HKEY    lookupSiteKey(HKEY hkHistoryRoot, const char *pchName, bool fCreate=false);

    BOOL    _fUseHKLM;
    char    _szRootKeyName[MAX_PATH];
    HKEY    _hkHistoryRoot;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cpevalrule.cxx ===
#include <wininetp.h>
#include "cpevalrule.h"

/*
Evaluation-rule parser
For IE6 the only type of rules accepted are include-exclude rules.
These rules have the format FOO&BAR&!XYZ=r
This translates to "if policy has FOO and BAR but not XYZ, then reject"
Important points:
- Logical rules are enclosed in forward slashes.
- No white spaces allowed in a rule.
*/
CPEvalRule *parseEvalRule(char *pszRule, char **ppEndRule) {

    const char *pch = pszRule;

    /* skip over white space */
    while (isspace(*pch))
        pch++;

    IncludeExcludeRule *pRule = new IncludeExcludeRule();

    /* If no explicit decision is given, we will assume REJECT */
    pRule->setDecision(COOKIE_STATE_REJECT);

    /* This flag keeps track of whether the next symbol is in the
       include-set or exclude-set */
    bool fNegate = false;
    
    do {
        int symindex;
        char achToken[64];

        /* when parsing rules, the tokens are not always seperated by
           white space-- instead the character class (eg. alphabetic,
           numeric, punctuation, etc.) is significant */
        pch = getNextToken(pch, achToken, sizeof(achToken), false);

        char ch = achToken[0];

        if (ch=='!')
            fNegate = true;
        else if (ch=='&')
            fNegate = false;
        else if (ch=='=') {

            int outcome = mapCookieAction(*pch);

            if (outcome==COOKIE_STATE_UNKNOWN) {
                delete pRule;
                pRule = NULL;
            }
            else
                pRule->setDecision(outcome);
            pch++;
            break;
        }
        else if ( (symindex=findSymbol(achToken)) >= 0) {

            /* this is a recognized P3P compact-policy symbol--
               depending on existence of preceding NOT operator,
               modify rule to include or exclude the token */
            if (fNegate)
                pRule->exclude(symindex);
            else
                pRule->include(symindex);
        }
    }
    while (*pch);

    /* indicate end of the rule in optional out parameter */
    if (ppEndRule)
        *ppEndRule = (char*) pch;

    return pRule;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cookiepolicy.h ===
#include <wininetp.h>

/* Forward declarations */
class CP3PSettingsCache;
struct P3PCookieState;
struct CompactPolicy;
class CPEvalRule;



/* Abstract base class for representing evaluation rules */
class CPEvalRule {

public:
    /* virtual destructor is necessary... */
    virtual ~CPEvalRule() { } 

    /* Derived class MUST provide an implementation */
    virtual int evaluate(const CompactPolicy &sitePolicy) = 0;

protected:
    CPEvalRule *pNext;  /* used for keeping linked list of rules */

    friend  class CCookieSettings;
};


/* User-settings for handling cookies */
class CCookieSettings {

public:
    int    EvaluatePolicy(P3PCookieState *pState);
    
    void   AddRef() { iRefCount++; }
    void   Release();

  /* Externally used function for clearing memory cache.
     Called when internet options are changed */    
    static void RefreshP3PSettings();
    
    static bool GetSettings(CCookieSettings **pSettings, const char *pszURL, BOOL fis3rdParty, BOOL fRestricted=FALSE);

    static bool GetSettings(CCookieSettings **pSettings, DWORD dwSecZone, BOOL fis3rdParty);

    static bool extractCompactPolicy(const char *pszP3PHeader, char *pszPolicy, DWORD *pPolicyLen);

protected:
    CCookieSettings(unsigned char *pBinaryRep, int cb);
    ~CCookieSettings();

    bool   parseSpecialSymbol(char *pszToken, int iSetting);
    int    evaluateToken(const char *pszToken);

    void   addEvalRule(CPEvalRule *pRule);

    static void convertToASCII(char *pstrSettings, int cbBytes);

private:
    int     iRefCount;

    /* The flag determines if the settings always make the
       same decision regardless of policy.
       In that case the decision is stored in the next field */
    bool    fConstant;
    unsigned long dwFixedDecision;

    /* Decision in the absence of compact-policy */
    unsigned long dwNoPolicyDecision;

    /* Does the evaluation result apply to session cookies? */
    bool    fApplyToSC;

    unsigned char *MPactions;
    CPEvalRule    *pRuleSet, **ppLast;

    static  CP3PSettingsCache  cookiePrefsCache;
};

/*
 * Utility class that controls ownership of a critical section 
 * through its lifetime.
 * constructor invoked --> enter CS
 * destructor invoked --> leave CS
 */
class CriticalSectOwner {

public:
    CriticalSectOwner(CRITICAL_SECTION *pcs)
        { EnterCriticalSection(pSection=pcs); }

    ~CriticalSectOwner()    
        { LeaveCriticalSection(pSection); }

private:
    CRITICAL_SECTION *pSection;    
};


class CP3PSettingsCache {

public:
    CP3PSettingsCache();
    ~CP3PSettingsCache();

    CCookieSettings *lookupCookieSettings(DWORD dwZone, BOOL f3rdParty);
    void saveCookieSettings(DWORD dwZone, BOOL f3rdParty, CCookieSettings *pSettings);

    void evictAll();

private:

    enum { MaxKnownZone = 5 };

    CCookieSettings *stdCookiePref[MaxKnownZone+1];
    CCookieSettings *std3rdPartyPref[MaxKnownZone+1];

    CRITICAL_SECTION csCache;
};

/* 
 Data type for binary representation of compact-policies
 Since compact policy in V1 spec is simply a set of predefined
 tokens, we use a bit-set representation.
 */
struct CompactPolicy {

    typedef unsigned __int64 quadword;

    CompactPolicy()    { qwLow = qwHigh = 0; }

    CompactPolicy(quadword high, quadword low) : qwLow(low), qwHigh(high) { }

    CompactPolicy operator & (const CompactPolicy &ps)   const;
    bool   operator == (const CompactPolicy &ps)  const;
    bool   operator != (const CompactPolicy &ps)  const;

    void   addToken(int index);
    int    contains(int index);

    /* Two quadwords are sufficient provided # of tokens <= 128 */
    quadword qwLow;
    quadword qwHigh;
};

/* structure used for communicating with CCookieSettings::Evaluate */
struct P3PCookieState {

    const char     *pszP3PHeader;
    unsigned long   dwPolicyState;

    int fValidPolicy      : 1;  /* is there a syntactically valid policy? */
    int fEvaluated        : 1;  /* was the compact-policy evaluated? */
    int fIncSession       : 1;  /* does the outcome apply to session-cookies? */

    unsigned long   dwEvalMode; /* {accept, evaluate, reject} */

    CompactPolicy   cpSitePolicy;
};

/* Utility functions */
const char *getNextToken(const char *pch, char *pszToken, int cbToken, bool fWhiteSpc=true, int *pLength=NULL);
int mapCookieAction(char ch);
int findSymbol(const char *pstr);
CPEvalRule *parseEvalRule(char *pszRule, char **ppEndRule=NULL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cookieprompt.cxx ===
#include <wininetp.h>

#include "cookieprompt.h"


//  checks a string to see if its a domain
BOOL IsStringADomain( LPCSTR pszString)
{
    int iLength = 0;
    bool fLastCharWasDot = false;

    while( pszString[iLength] != '\0')
    {
        if( fLastCharWasDot && pszString[iLength] == '.')
            return FALSE;
        
        fLastCharWasDot = pszString[iLength] == '.';

        if( !(IsCharAlphaNumericA( pszString[iLength])
              || pszString[iLength] == '.'
              || pszString[iLength] == '-'))
        {
            return FALSE;
        }

        iLength++;
    }

    return iLength > 0 ? TRUE : FALSE;
}


LPCSTR FindMinimizedCookieDomainInDomain( LPCSTR pszDomain)
{
    LPCSTR pMinimizedDomain = pszDomain + strlen( pszDomain);

    do
    {
        pMinimizedDomain--;
        while( pszDomain < pMinimizedDomain
               && *(pMinimizedDomain-1) != L'.')
        {
            pMinimizedDomain--;
        }
    } while( !IsDomainLegalCookieDomainA( pMinimizedDomain, pszDomain)
             && pszDomain < pMinimizedDomain);

    return pMinimizedDomain;
}


CCookiePromptHistory::CCookiePromptHistory(const char *pchRegistryPath, bool fUseHKLM) {

    _fUseHKLM = fUseHKLM;    
    lstrcpyn(_szRootKeyName, pchRegistryPath, sizeof(_szRootKeyName)/sizeof(_szRootKeyName[0]));
    _hkHistoryRoot = NULL;
}

CCookiePromptHistory::~CCookiePromptHistory() {

    if (_hkHistoryRoot)
    {
        RegCloseKey(_hkHistoryRoot);
        _hkHistoryRoot = NULL;
    }
}

HKEY    CCookiePromptHistory::OpenRootKey()
{
    HKEY hkey;

    if (_hkHistoryRoot == NULL)
    {
        if (RegCreateKeyEx(_fUseHKLM ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                           _szRootKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                           NULL,
                           &hkey,
                           NULL) == ERROR_SUCCESS)
        {
            // if we aren't running in a service, we can cache the key
            if (!GlobalIsProcessNtService)
            {
                if (InterlockedCompareExchangePointer((void**)&_hkHistoryRoot, (void*)hkey, NULL))
                {
                    // someone beat us in the race to fill in _hkHistoryRoot, close ours since we
                    // failed to set it into _hkHistoryRoot
                    RegCloseKey(hkey);
                    hkey = _hkHistoryRoot;
                }
            }
        }
        else
        {
            hkey = NULL;
        }
    }
    else
    {
        // use the cached value
        hkey = _hkHistoryRoot;
    }

    return hkey;
}

BOOL    CCookiePromptHistory::CloseRootKey(HKEY hkeyRoot)
{
    BOOL bClosedKey = FALSE;

    if (hkeyRoot)
    {
        if (GlobalIsProcessNtService)
        {
            // we never cache the key when runnint in a service!
            INET_ASSERT(_hkHistoryRoot == NULL);

            RegCloseKey(hkeyRoot);
            bClosedKey = TRUE;
        }
        else
        {
            INET_ASSERT(_hkHistoryRoot == hkeyRoot);
        }
    }

    return bClosedKey;
}

/* 
 Lookup user-decision for given host+policy combination.
 If "pchPolicyID" is NULL the decision applies regardless of policy.
 */
BOOL    CCookiePromptHistory::lookupDecision(const char *pchHostName, 
                                             const char *pchPolicyID,
                                             unsigned long *pdwDecision) {

    BOOL fRet = FALSE;
    HKEY hSiteKey;
    CHAR szBuffer[ INTERNET_MAX_URL_LENGTH];
    DWORD dwBufferSize = INTERNET_MAX_URL_LENGTH;


    if (SUCCEEDED( UrlUnescape( (LPSTR)pchHostName, szBuffer, &dwBufferSize, 0))  // forced LPSTR conv necessary because COULD be inplace unescape
        && IsStringADomain( szBuffer))
    {
        HKEY hkHistoryRoot = OpenRootKey();

        if (hSiteKey = lookupSiteKey(hkHistoryRoot, FindMinimizedCookieDomainInDomain(szBuffer)))
        {

            DWORD dwType, dwCookieState;
            DWORD dwSize = sizeof(dwCookieState);

            if (ERROR_SUCCESS == RegQueryValueEx(hSiteKey, pchPolicyID, 0, &dwType, (LPBYTE) &dwCookieState, &dwSize)
                && (dwType==REG_DWORD)) {

                *pdwDecision =  dwCookieState;
                fRet = TRUE;
            }

            RegCloseKey(hSiteKey);
        }

        CloseRootKey(hkHistoryRoot);
    }

//commented code - legacy design where we allowed rules on a non-minimized domain
//    while (pchHostName && !fRet)
//    {
//        if (hSiteKey=lookupSiteKey(pchHostName)) {
//
//            DWORD dwType, dwCookieState;
//            DWORD dwSize = sizeof(dwCookieState);
//
//            if (ERROR_SUCCESS == RegQueryValueEx(hSiteKey, pchPolicyID, 0, &dwType, (LPBYTE) &dwCookieState, &dwSize)
//                && (dwType==REG_DWORD)) {
//
//                *pdwDecision =  dwCookieState;
//                fRet = TRUE;
//            }
//
//            RegCloseKey(hSiteKey);
//        }
//
//        /* Find and skip over next dot if there is one */
//        if (pchHostName = strchr(pchHostName, '.'))
//            pchHostName++;
//    }

    return fRet;
}

/* 
 Save user-decision for given host+policy combination.
 If "pchPolicyID" is NULL the decision applies to all policies
 */
BOOL    CCookiePromptHistory::saveDecision(const char *pchHostName,
                                           const char *pszPolicyID,
                                           unsigned long dwDecision) {

    BOOL fRet = FALSE;
    HKEY hSiteKey;
    CHAR szBuffer[ INTERNET_MAX_URL_LENGTH];
    DWORD dwBufferSize = INTERNET_MAX_URL_LENGTH;


    if (SUCCEEDED( UrlUnescape( (LPSTR)pchHostName, szBuffer, &dwBufferSize, 0))  // forced LPSTR conv necessary because COULD be inplace unescape
        && IsStringADomain( szBuffer))
    {
        HKEY hkHistoryRoot = OpenRootKey();

        if (hSiteKey = lookupSiteKey(hkHistoryRoot, FindMinimizedCookieDomainInDomain( szBuffer), true))
        {
            if (ERROR_SUCCESS == RegSetValueEx(hSiteKey, pszPolicyID, 0, REG_DWORD, 
                                               (LPBYTE) &dwDecision, sizeof(dwDecision)))
                fRet = TRUE;

            RegCloseKey(hSiteKey);
        }

        CloseRootKey(hkHistoryRoot);
    }

    return fRet;
}

/*
Clear previously saved decision for given hostname+policy combination.
If the policy-ID is "*" all decisions about the site are cleared.
*/
BOOL   CCookiePromptHistory::clearDecision(const char *pchHostName, const char *pchPolicyID) {

    BOOL fRet = FALSE;
    int error = ERROR_SUCCESS;
    HKEY hkHistoryRoot = OpenRootKey();

    if ( pchPolicyID != NULL && !strcmp(pchPolicyID, "*")) {
        
        error = SHDeleteKey(hkHistoryRoot, pchHostName);
    }
    else if (HKEY hSiteKey = lookupSiteKey(hkHistoryRoot, pchHostName, false)) {

        error = RegDeleteValue(hSiteKey, pchPolicyID);
        RegCloseKey(hSiteKey);
    }

    CloseRootKey(hkHistoryRoot);

    /* If neither of the previous conditionals were TRUE, then there is
       no decision corresponding to that hostname */
    return (error==ERROR_SUCCESS);
}

HKEY    CCookiePromptHistory::lookupSiteKey(HKEY hkHistoryRoot, const char *pchHostName, bool fCreate) {

    HKEY hSiteKey = NULL;

    if (hkHistoryRoot)
    {
        LONG error;

        if (fCreate)
        {
            RegCreateKeyEx(hkHistoryRoot,
                           pchHostName,
                           0,
                           NULL,
                           0,
                           KEY_QUERY_VALUE | KEY_SET_VALUE,
                           NULL,
                           &hSiteKey,
                           NULL);
        }
        else
        {
            RegOpenKeyEx(hkHistoryRoot,
                         pchHostName,
                         0,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         &hSiteKey);
        }
    }

    return hSiteKey;
}

BOOL   CCookiePromptHistory::clearAll() {

    DWORD dwIndex = 0;
    DWORD dwRet;
    HKEY hkHistoryRoot = OpenRootKey();

    do {

        FILETIME ft;
        char  achHostName[INTERNET_MAX_HOST_NAME_LENGTH];
        DWORD dwNameLen = sizeof(achHostName);

        dwRet = RegEnumKeyEx(hkHistoryRoot,
                             dwIndex,
                             achHostName,
                             & dwNameLen,
                             NULL, NULL, NULL,
                             &ft);

        if (dwRet == ERROR_SUCCESS)
        {
            if (SHDeleteKey(hkHistoryRoot, achHostName) != ERROR_SUCCESS)
            {
                dwIndex++;
            }
        }
    }
    while (dwRet == ERROR_SUCCESS);

    CloseRootKey(hkHistoryRoot);

    return TRUE;
}

unsigned long CCookiePromptHistory::enumerateDecisions(char *pchSiteName, unsigned long *pcbName, 
                                                       unsigned long *pdwDecision, 
                                                       unsigned long dwIndex) {

    FILETIME ft;
    HKEY hkHistoryRoot = OpenRootKey();

    DWORD dwRet = RegEnumKeyEx(hkHistoryRoot, dwIndex, pchSiteName, pcbName, NULL, NULL, NULL, &ft);

    if (dwRet==ERROR_SUCCESS) {

        if (HKEY hSiteKey = lookupSiteKey(hkHistoryRoot, pchSiteName, false)) {

            DWORD dwType;
            DWORD dwSize = sizeof(DWORD);

            dwRet = RegQueryValueEx(hSiteKey, NULL, 0, &dwType, (LPBYTE) pdwDecision, &dwSize);
            RegCloseKey(hSiteKey);
        }
        else
        {
            dwRet = ERROR_NO_DATA;
        }
    }
    
    CloseRootKey(hkHistoryRoot);

    return dwRet;
}


/*
Exported APIs for manipulating per-site cookie settings
*/
extern CCookiePromptHistory cookieUIhistory;

BOOL DeletePersistentCookies(const char *pszDomainSuffix);


INTERNETAPI_(BOOL) InternetSetPerSiteCookieDecisionA( IN LPCSTR pchHostName, DWORD dwDecision)
{
    BOOL retVal = FALSE;
    
    if( !pchHostName 
        || IsBadStringPtr(pchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    

    if( dwDecision == COOKIE_STATE_UNKNOWN)
    {
        retVal = cookieUIhistory.clearDecision( pchHostName, "*");
    }
    else if ( (dwDecision == COOKIE_STATE_ACCEPT) || (dwDecision == COOKIE_STATE_REJECT))
    {
        retVal = cookieUIhistory.saveDecision( pchHostName, NULL, dwDecision);

        /* side-effect: choosing to reject all future cookies for a given website 
           implicitly deletes existing cache cookies from that site*/
        if (dwDecision==COOKIE_STATE_REJECT)
            DeletePersistentCookies(pchHostName);
    }

    return retVal;
}

INTERNETAPI_(BOOL) InternetSetPerSiteCookieDecisionW( IN LPCWSTR pwchHostName, DWORD dwDecision)
{
    if( !pwchHostName || IsBadStringPtrW( pwchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    MEMORYPACKET mpHostName;
    ALLOC_MB(pwchHostName,0,mpHostName);
    if (!mpHostName.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchHostName, mpHostName);

    return InternetSetPerSiteCookieDecisionA( mpHostName.psStr, dwDecision);
}

INTERNETAPI_(BOOL) InternetGetPerSiteCookieDecisionA( IN LPCSTR pchHostName, unsigned long* pResult)
{
    if( IsBadWritePtr( pResult, sizeof(unsigned long))
        || !pchHostName
        || IsBadStringPtr(pchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return cookieUIhistory.lookupDecision( pchHostName, NULL, pResult);
}

INTERNETAPI_(BOOL) InternetGetPerSiteCookieDecisionW( IN LPCWSTR pwchHostName, unsigned long* pResult)
{
    if( IsBadWritePtr( pResult, sizeof(unsigned long))
        || !pwchHostName
        || IsBadStringPtrW(pwchHostName, INTERNET_MAX_URL_LENGTH))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    MEMORYPACKET mpHostName;
    ALLOC_MB(pwchHostName,0,mpHostName);
    if (!mpHostName.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(pwchHostName, mpHostName);

    return InternetGetPerSiteCookieDecisionA( mpHostName.psStr, pResult);
}

INTERNETAPI_(BOOL) InternetEnumPerSiteCookieDecisionA(OUT LPSTR pszSiteName, IN OUT unsigned long *pcSiteNameSize, OUT unsigned long *pdwDecision, IN unsigned long dwIndex) {

    int error = ERROR_INVALID_PARAMETER;

    if( !pcSiteNameSize || IsBadWritePtr( pcSiteNameSize, sizeof(DWORD)))
    {
        goto doneInternetEnumPerSiteCookieDecisionA;
    }

    if( !pszSiteName || IsBadWritePtr( pszSiteName, *pcSiteNameSize))
    {
        goto doneInternetEnumPerSiteCookieDecisionA;
    }

    if( !pdwDecision || IsBadWritePtr(pdwDecision, sizeof(DWORD)))
    {
        goto doneInternetEnumPerSiteCookieDecisionA;
    }

    error = cookieUIhistory.enumerateDecisions(pszSiteName, pcSiteNameSize, pdwDecision, dwIndex);

    if( error == ERROR_SUCCESS)
        *pcSiteNameSize += 1;  //  reg function doesn't count null terminator in size, it should

doneInternetEnumPerSiteCookieDecisionA:
    if (error!=ERROR_SUCCESS)
        SetLastError(error);

    return (error==ERROR_SUCCESS);
}

INTERNETAPI_(BOOL) InternetEnumPerSiteCookieDecisionW(LPWSTR pwszSiteName, unsigned long *pcSiteNameSize, unsigned long *pdwDecision, unsigned long dwIndex) {

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    BOOL fRet = FALSE;
    LPSTR pszSiteName = NULL;

    if( !pcSiteNameSize || IsBadWritePtr( pcSiteNameSize, sizeof(DWORD)))
        goto cleanup;

    if( !pwszSiteName || IsBadWritePtr( pwszSiteName, *pcSiteNameSize * sizeof(WCHAR)))
        goto cleanup;

    if( !pdwDecision || IsBadWritePtr( pdwDecision, sizeof(DWORD)))
        goto cleanup;

    pszSiteName = new char[*pcSiteNameSize];
    if( !pszSiteName)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    fRet = InternetEnumPerSiteCookieDecisionA( pszSiteName, pcSiteNameSize, pdwDecision, dwIndex);

    if (fRet)
    {
        SHAnsiToUnicode( pszSiteName, pwszSiteName, *pcSiteNameSize);
    }

    dwErr = ERROR_SUCCESS;

cleanup:
    if (dwErr!=ERROR_SUCCESS)
        SetLastError(dwErr);
    if ( pszSiteName != NULL)
        delete [] pszSiteName;

    return fRet;
}

INTERNETAPI_(BOOL) InternetClearAllPerSiteCookieDecisions()
{
    return cookieUIhistory.clearAll();
}

BOOL DeletePersistentCookies(const char *pszDomainSuffix)
{
    BOOL bRetval = TRUE;
    DWORD dwEntrySize, dwLastEntrySize;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntry;
    
    HANDLE hCacheDir = NULL;
    dwEntrySize = dwLastEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) new BYTE[dwEntrySize];
    if( lpCacheEntry == NULL)
    {
        bRetval = FALSE;
        goto Exit;
    }
    lpCacheEntry->dwStructSize = dwEntrySize;

Again:
    if (!(hCacheDir = FindFirstUrlCacheEntryA("cookie:",lpCacheEntry,&dwEntrySize)))
    {
        delete [] lpCacheEntry;
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS:
                goto Exit;
            case ERROR_INSUFFICIENT_BUFFER:
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                new BYTE[dwEntrySize];
                if( lpCacheEntry == NULL)
                {
                    bRetval = FALSE;
                    goto Exit;
                }
                lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                goto Again;
            default:
                bRetval = FALSE;
                goto Exit;
        }
    }

    do 
    {
        if (lpCacheEntry->CacheEntryType & COOKIE_CACHE_ENTRY) {

            const char achEmpty[] = "";
            const char *pszFind = NULL;
            const char *pszAtSign = strchr(lpCacheEntry->lpszSourceUrlName, '@');

            /* 
            The source URL for a cookie has the format:
            cookie:username@domain/path
            The logic for determining whether to delete the cookie checks for
            the following conditions on source URL:
                1. presence of the @ sign
                2. presence of argument passed in "pszDomainSuffix" as substring
                3. the substring must occur after a dot or the @ sign
                   (this avoids partial name matching on domains)
                4. substring must occur as suffix, eg only at the end
                   this happens IFF the match is followed by forward slash 
            */
            if (pszDomainSuffix==NULL ||    /* null argument means "delete all cookies" */
                  (pszAtSign &&
                  (pszFind=strstr(pszAtSign+1, pszDomainSuffix)) &&
                  (pszFind[-1]=='.' || pszFind[-1]=='@') &&
                   pszFind[strlen(pszDomainSuffix)]=='/'))
                DeleteUrlCacheEntryA(lpCacheEntry->lpszSourceUrlName);
        }

        dwEntrySize = dwLastEntrySize;
Retry:
        if (!FindNextUrlCacheEntryA(hCacheDir,lpCacheEntry, &dwEntrySize))
        {
            delete [] lpCacheEntry;
            switch(GetLastError())
            {
                case ERROR_NO_MORE_ITEMS:
                    goto Exit;
                case ERROR_INSUFFICIENT_BUFFER:
                    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                    new BYTE[dwEntrySize];
                    if( lpCacheEntry == NULL)
                    {
                        bRetval = FALSE;
                        goto Exit;
                    }
                    lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                    goto Retry;
                default:
                    bRetval = FALSE;
                    goto Exit;
            }
        }
    }
    while (TRUE);

Exit:
    if (hCacheDir)
        FindCloseUrlCache(hCacheDir);
    return bRetval;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\cpevalrule.h ===
#include "cookiepolicy.h"

/* 
Logical conjunction eval-rule
This evaluation rule is capable of expressing statements such as
"if all of the tokens {X, Y, Z} appear in the policy and none of
the tokens {A, B, C} appear, then prompt"
 */
class IncludeExcludeRule : public CPEvalRule {

public:
    virtual int evaluate(const CompactPolicy &sitePolicy) {

        static const CompactPolicy empty;

        // This rule is triggered IFF:
        // 1. Site policy contains all tokens from the include set, AND
        // 2. Site policy contains no tokens from exclude set
        bool fApplies = (cpInclude & sitePolicy) == cpInclude &&
                        (cpExclude & sitePolicy) == empty;

        // By convention, if the rule does not apply evaluate()
        // function returns the UNKNOWN state
        return fApplies ? decision : COOKIE_STATE_UNKNOWN;
    }

    // These two functions are used to build up the set of tokens
    // that MUST be included/excluded for the rule to apply
    inline void include(int symindex) { cpInclude.addToken(symindex); }
    inline void exclude(int symindex) { cpExclude.addToken(symindex); }

    inline void setDecision(int decision)   { this->decision = decision; }
    inline int  getDecision(void)           { return decision; }

protected:
    CompactPolicy cpInclude;
    CompactPolicy cpExclude;
    unsigned long decision;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\httptime.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httptime.h

Abstract:

    This file contains the numerical defines for the date/parsing routines located
    in the httptime.cxx file.

Author:

    Arthur Bierer (arthurbi) 12-Dec-1997

Revision History:

--*/


#ifndef _HTTPTIME_H_
#define _HTTPTIME_H_

#define BASE_DEC 10 // base 10

//
// Date indicies used to figure out what each entry is.
//


#define DATE_INDEX_DAY_OF_WEEK     0

#define DATE_1123_INDEX_DAY        1
#define DATE_1123_INDEX_MONTH      2
#define DATE_1123_INDEX_YEAR       3
#define DATE_1123_INDEX_HRS        4
#define DATE_1123_INDEX_MINS       5
#define DATE_1123_INDEX_SECS       6

#define DATE_ANSI_INDEX_MONTH      1
#define DATE_ANSI_INDEX_DAY        2
#define DATE_ANSI_INDEX_HRS        3
#define DATE_ANSI_INDEX_MINS       4
#define DATE_ANSI_INDEX_SECS       5
#define DATE_ANSI_INDEX_YEAR       6

#define DATE_INDEX_TZ              7

#define DATE_INDEX_LAST            DATE_INDEX_TZ
#define MAX_DATE_ENTRIES           (DATE_INDEX_LAST+1)




//
// DATE_TOKEN's DWORD values used to determine what day/month we're on
//

#define DATE_TOKEN_JANUARY      1
#define DATE_TOKEN_FEBRUARY     2
#define DATE_TOKEN_MARCH        3
#define DATE_TOKEN_APRIL        4
#define DATE_TOKEN_MAY          5
#define DATE_TOKEN_JUNE         6
#define DATE_TOKEN_JULY         7
#define DATE_TOKEN_AUGUST       8
#define DATE_TOKEN_SEPTEMBER    9
#define DATE_TOKEN_OCTOBER      10
#define DATE_TOKEN_NOVEMBER     11
#define DATE_TOKEN_DECEMBER     12       

#define DATE_TOKEN_LAST_MONTH   (DATE_TOKEN_DECEMBER+1)

#define DATE_TOKEN_SUNDAY       0
#define DATE_TOKEN_MONDAY       1
#define DATE_TOKEN_TUESDAY      2                  
#define DATE_TOKEN_WEDNESDAY    3
#define DATE_TOKEN_THURSDAY     4
#define DATE_TOKEN_FRIDAY       5
#define DATE_TOKEN_SATURDAY     6

#define DATE_TOKEN_LAST_DAY     (DATE_TOKEN_SATURDAY+1)
 
#define DATE_TOKEN_GMT          0xFFFFFFFD

#define DATE_TOKEN_LAST         DATE_TOKEN_GMT

#define DATE_TOKEN_ERROR        (DATE_TOKEN_LAST+1)

                            
#endif  // _HTTPTIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\dav.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dav.cxx

Abstract:

    This file contains the implementations of 
        HttpCheckDavCompliance
        HttpCheckDavCollection
        HttpCheckCachedDavStatus
        
    The following functions are exported by this module:

        HttpCheckDavComplianceA
        HttpCheckDavCollectionA
        HttpCheckCachedDavStatusA
        HttpCheckDavComplianceW
        HttpCheckDavCollectionW
        HttpCheckCachedDavStatusW

Author:

    Mead Himelstein (Meadh) 01-Jun-1998

Revision History:


--*/


#include <wininetp.h>
#include "httpp.h"

#undef DAVCACHING //IE5 bug 15696, removing unused code but may add back in later

INTERNETAPI_(BOOL) HttpCheckDavComplianceA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )

/*++

Routine Description:

    Determines if the resource identified by lpszUrl is DAV compliant (level determined by lpszComplianceToken).
    Returns TRUE in lpfFound if detected. Furthermore, if the token is "1" we also cache todays date
    and whether or not we found the server to be DAV level 1 compliant in the visited links cache.
    
Arguments:

    lpszUrl             - URL to the resource to check for DAV compliance, i.e. "http://webdav/davfood/"

    lpszComplianceToken - DAV compliance class identifier (i.e. "1") BUGBUG MUST NOT CONTAIN INTERNAL WHITE SPACE "foo bar" = bad, "  foo  " = ok
    
    lpfFound            - address of a BOOL to receive TRUE if DAV compliance is found or FALSE otherwise.

    hWnd                - Handle to window for displaying authentication dialog if needed. May be NULL indicating
                          no UI is to be displayed and authentication failures should be quietly handled.
                          
    lpvReserved         - Reserved, must be NULL
    
Return Value:

    TRUE - Success, check lpfFound for results.
    FALSE - failure, GetLastError returns the error code

--*/

{
    BOOL            fRet = TRUE;


    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckDavComplianceA",
                 "%sq, %sq, %#x, %#x, %#x",
                 lpszUrl,
                 lpszComplianceToken,
                 lpfFound,
                 hWnd,
                 lpvReserved
                 ));


    DWORD           dwStatusCode, dwHeaderLength, dwIndex = 0;
    DWORD           dwError = ERROR_SUCCESS, dwStatusLength = sizeof(DWORD);
    HINTERNET       hSession = NULL, hConnection = NULL, hHTTPReq = NULL;
    LPSTR           lpszDavHeader = NULL, lpszRead = NULL, lpszWrite = NULL, lpszVisitedUrl=NULL;
   	LPCACHE_ENTRY_INFO lpCEI = NULL;
    FILETIME        ftNow;
    WORD            wDate, wTime;
    URL_COMPONENTS  ucUrl;

    #define CEI_BUFFER_SIZE 512
    #define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)

    // Debug param checking
    INET_ASSERT(lpszUrl && lpszComplianceToken && lpfFound && !lpvReserved);

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpCheckDavComplianceA",
                     "%s %s %x %x %x",
                     (lpszUrl)?lpszUrl :"NULL Url",
                     (lpszComplianceToken)?lpszComplianceToken :"NULL ComplianceToken",
                     hWnd,
                     lpfFound, lpvReserved
                     ));

    // non-debug param checking
    if (!lpszUrl || !lpszComplianceToken || !lpfFound || lpvReserved) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    *lpfFound = FALSE;
    
    // Build the URL_COMPONENTS struct
	memset(&ucUrl, 0, sizeof(ucUrl));
    ucUrl.dwStructSize = sizeof(ucUrl);
    // non-zero length enables retrieval during CrackUrl
    ucUrl.dwSchemeLength = 1;
	ucUrl.dwHostNameLength = 1;
	ucUrl.dwUrlPathLength = 1;
	if (!InternetCrackUrl(lpszUrl, 0, 0, &ucUrl))
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
    }

    DEBUG_PRINT_API(API,
                    INFO,
                    ("URL Cracked. Host = %q Path = %q\n ",
                    ucUrl.lpszHostName, ucUrl.lpszUrlPath
                    ));

    // Ensures the global vszCurrentUser is set
    GetWininetUserName();   
    INET_ASSERT(vszCurrentUser);
    
    // Perform an OPTIONS call on the server and check for a DAV header
	hSession = InternetOpen(NULL,
						  INTERNET_OPEN_TYPE_PRECONFIG,
						  NULL,
						  NULL,
						  NULL);
	if(!hSession)
	{
		dwError = GetLastError();
	    fRet = FALSE;
		goto cleanup;
	}
	
	hConnection = InternetConnect(hSession,
								   ucUrl.lpszHostName,
								   INTERNET_DEFAULT_HTTP_PORT,
								   (LPCSTR) vszCurrentUser,
								   NULL,
								   INTERNET_SERVICE_HTTP,
								   NULL,
								   NULL);

	if(!hConnection)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	hHTTPReq = HttpOpenRequest(hConnection,
							   "OPTIONS",
							   ucUrl.lpszUrlPath,
							   "HTTP/1.0",
							   NULL,
							   NULL,
							   INTERNET_FLAG_PRAGMA_NOCACHE,NULL);

	if(!hHTTPReq)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	if (!HttpSendRequest(hHTTPReq,NULL, 0L, NULL, NULL))
	{
		dwError = GetLastError();
		fRet = FALSE;
		goto cleanup;
	}
        

    // Authentication handling
	if (HttpQueryInfo(hHTTPReq,
					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
					  &dwStatusCode,
					  &dwStatusLength,
					  &dwIndex))
	{
        // fRet = TRUE at this point  
        // If request was denied or proxy auth required and callee has said
        // we can display UI, we put up the InternetErrorDlg and ask for
        // credentials. Otherwise, if dwStatus != success we cache that
        // this resource is not DAV compliant
        if ((hWnd) && ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ)))
        {
            DWORD dwRetval;
            DWORD dwAuthTries = 0;
            BOOL fDone;
            fDone = FALSE;
            while ((!fDone) && (dwAuthTries < 3))
            {
                dwRetval = InternetErrorDlg(hWnd,
                                            hHTTPReq,
                                            ERROR_INTERNET_INCORRECT_PASSWORD,
                                            0L,
                                            NULL);
                if (dwRetval == ERROR_INTERNET_FORCE_RETRY) // User pressed ok on credentials dialog
                {   // Resend request, new credentials are cached and will be replayed by HSR()
                	if (!HttpSendRequest(hHTTPReq,NULL, 0L, NULL, NULL))
                	{
                		dwError = GetLastError();
                		fRet = FALSE;
                		goto cleanup;
                	}

                    dwStatusCode = 0;

                	if (!HttpQueryInfo(hHTTPReq,
                					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                					  &dwStatusCode,
                					  &dwStatusLength,
                					  &dwIndex))
                	{
                		dwError = GetLastError();
                	    fRet = FALSE;
                	    goto cleanup;
                	}

                    if ((dwStatusCode != HTTP_STATUS_DENIED) && (dwStatusCode != HTTP_STATUS_PROXY_AUTH_REQ))
                    {
                        fDone = TRUE;
                    }
                }
                else    // User pressed cancel from dialog (note ERROR_SUCCESS == ERROR_CANCELLED from IED())
                {
                    fDone = TRUE;
                }
                dwAuthTries++;
            }
        }

        if ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ))
        {   // Don't want to cache this (user might have forgotten password or we may not
            // be able to show credential UI)
            goto cleanup;
        }
        else if (dwStatusCode != HTTP_STATUS_OK)
        {   // Either initial request failed for non-auth issue, cache as not compliant
            goto update_cache; //note update_cache NOT cleanup, want to cache this as non compliant
        }
	}
	else
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

    // If we received a DAV header, snag it and check for compliance level
    dwHeaderLength = INTERNET_MAX_URL_LENGTH;
    lpszDavHeader = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, dwHeaderLength);
    if (!lpszDavHeader) 
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    lstrcpy(lpszDavHeader,"DAV");
	if (!HttpQueryInfo(hHTTPReq,
					  HTTP_QUERY_CUSTOM,
					  lpszDavHeader,
					  &dwHeaderLength,
					  &dwIndex))
	{
   		dwError = GetLastError();
	    fRet = FALSE;
	    goto update_cache; //note update_cache NOT cleanup, want to cache this as non compliant

    }
    INET_ASSERT(fRet); // sb TRUE if it made it this far
    
    // Walk the DAV header looking for the token by itself, indicating DAV compliance
    // Note: DAV header is comma delimited, but otherwise we can make no assumptions on formatting.
    // BUGBUG Currently will not work for tokens with internal white space i.e. "foo bar" = bad, " foobar " = good

    lpszRead = lpszDavHeader;
    lpszWrite = lpszDavHeader;
    INET_ASSERT(!*lpfFound);
    INET_ASSERT(fRet);
    while(*lpszRead && !*lpfFound) 
    {
        if (IsWhite(*lpszRead)) 
        {
            while ((*(++lpszRead))&&(IsWhite(*lpszRead)));
        }
        if (*lpszRead) 
        {
            if(*lpszRead == ',') 
            {
                *(lpszRead++) = '\0';
                if (*lpfFound = (lstrcmp(lpszDavHeader, lpszComplianceToken) == 0) ? TRUE:FALSE)
                {   
                    goto update_cache;
                }
                lpszWrite = lpszRead;
                lpszDavHeader = lpszRead;
            }
            else *(lpszWrite++) = *(lpszRead++);    
        }
    }
    *lpszWrite = *lpszRead; // copy the terminator
    INET_ASSERT(!*lpfFound);
    *lpfFound = (lstrcmp(lpszDavHeader, lpszComplianceToken) == 0) ? TRUE:FALSE;    //Final compare on last fragment

update_cache :
#ifdef DAVCACHING //  Commenting out as per bug 15696

    if (lstrcmp("1", lpszComplianceToken) == 0) 
    // Cache if this is a known DAV level 1 server or atleast the last time we tried
    {

        // Update visited links cache
        // We store the cached info as:
        //  CacheEntryInfo.dwExemptDelta(HiWord) = Date DAV discovery was last run
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_LEVEL1_STATUS = Is DAV server (*lpfFound)
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_COLLECTION_STATUS = Is DAV collection (set in HttpCheckDavCollection)

        // Assemble the URL to the visited links container "VISITED: username@URL"
        DWORD cbNeededBuf = lstrlen("Visited: ") + lstrlen(vszCurrentUser) + lstrlen(lpszUrl) + 32;
        lpszVisitedUrl = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, cbNeededBuf);
    	if (!lpszVisitedUrl)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        lstrcpy(lpszVisitedUrl, "Visited: "); // For compatibility with urlhist.c visited URLs
        lstrcat(lpszVisitedUrl, vszCurrentUser);
        lstrcat(lpszVisitedUrl, "@");
        lstrcat(lpszVisitedUrl, lpszUrl);

        lpCEI = (LPCACHE_ENTRY_INFO) ALLOCATE_MEMORY(LMEM_FIXED, CEI_BUFFER_SIZE);
    	if (!lpCEI)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        GetSystemTimeAsFileTime(&ftNow);
        if (!FileTimeToDosDateTime(&ftNow,
                                   &wDate,
                                   &wTime
                                   ))
        {                          
            INET_ASSERT(FALSE); // Should "never" hit this
            goto cleanup;                              
        }

        // Stuff our 16-bit Date into the upper 16-bits of dwExemptDelta
        lpCEI->dwExemptDelta = (DWORD)wDate <<16;

        // Set the DAV_LEVEL1_STATUS_BIT if the resource was found compliant above
        if (*lpfFound)
        {
            lpCEI->dwExemptDelta |= (DWORD) DAV_LEVEL1_STATUS;
        }
    

        if (!SetUrlCacheEntryInfo (lpszVisitedUrl, 
	  	    					   lpCEI,
		        				   CACHE_ENTRY_EXEMPT_DELTA_FC
			        				))
        {
	       	if (GetLastError() == ERROR_FILE_NOT_FOUND)
	   	    // No existing cache entry, so create one and try again
    	    {
	            FILETIME ftNone;
                if (CommitUrlCacheEntry (lpszVisitedUrl,
                                         NULL,
                                         ftNone,
                                         ftNone,
                                         0,
                                         NULL,
                                         0,
                                         NULL,
                                         0
                                         ))
                {
                    // Entry is now created, so try one more time
                    SetUrlCacheEntryInfo (lpszVisitedUrl, 
	       			    			      lpCEI,
                		    			  CACHE_ENTRY_EXEMPT_DELTA_FC
			               	    		 );
                }
  	    	}
        }
    }

#endif //DAVCACHING
    
cleanup:    
    // Free memory
    if (lpCEI) FREE_MEMORY (lpCEI);
    if (lpszVisitedUrl) FREE_MEMORY (lpszVisitedUrl);
    if (lpszDavHeader != NULL) FREE_MEMORY(lpszDavHeader);

    // Close the handles
	if (hHTTPReq) InternetCloseHandle(hHTTPReq);
	if (hConnection) InternetCloseHandle(hConnection);

    SetLastError(dwError);


    DEBUG_LEAVE_API(fRet);
	return fRet;
}


INTERNETAPI_(BOOL) HttpCheckDavCollectionA(
    IN LPCSTR lpszUrl,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )

/*++

Routine Description:

    Checks the resource at lpszUrl to see if it is a DAV collection. Typically, callee has 
    already called HttpCheckDavCompliance or HttpCheckCachedDavStatus to determine 
    the resource supports DAV level 1, although it is not necessary to do so. Note this method
    will blindly attempt either way.
    
Arguments:

    lpszUrl             - URL of the resource to check

    lpfFound            - address of a BOOL to receive TRUE if DAV compliance is found or FALSE otherwise.

    hWnd                - Handle to window for displaying authentication dialog if needed. May be NULL indicating
                          no UI is to be displayed and authentication failures should be quietly handled.
                          
    lpvReserved         - Reserved, must be NULL
    
Return Value:

    TRUE - Success, check lpfFound for results.
    FALSE - failure, GetLastError returns the error code

--*/

{
    #define CEI_BUFFER_SIZE 512
    #define READ_BUFFER_SIZE 4096
    #define READ_BUFFER_AVAILABLE  (READ_BUFFER_SIZE - sizeof(LPSTR))
    BOOL            fRet = TRUE, fDone=FALSE;

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckDavCollectionA",
                 "%sq, %#x, %#x, %#x",
                 lpszUrl,
                 lpfFound,
                 hWnd,
                 lpvReserved
                 ));


    DWORD           dwRead=0, dwBuffers =1;
    DWORD           dwStatusCode, dwIndex = 0;
    DWORD           dwError = ERROR_SUCCESS, dwStatusLength = sizeof(DWORD);
    HINTERNET       hSession = NULL, hConnection = NULL, hHTTPReq = NULL;
    LPSTR           lpszVisitedUrl=NULL, lpszXmlResponse=NULL, lpszBufferHead=NULL;
   	LPCACHE_ENTRY_INFO lpCEI = NULL;
    FILETIME        ftNow;
    WORD            wDate, wTime;
    URL_COMPONENTS  ucUrl;
    char lpszHeaders[] = "Depth:0\r\n";

    // Debug param checking
    INET_ASSERT(lpszUrl && lpfFound && !lpvReserved);

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpCheckDavCollectionA",
                     "%s %x %x",
                     (lpszUrl)?lpszUrl :"NULL Url",
                     lpfFound, lpvReserved
                     ));

    // non-debug param checking
    if (!lpszUrl || !lpfFound || lpvReserved) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    *lpfFound = FALSE;
    
    // Build the URL_COMPONENTS struct
	memset(&ucUrl, 0, sizeof(ucUrl));
    ucUrl.dwStructSize = sizeof(ucUrl);
    // non-zero length enables retrieval during CrackUrl
    ucUrl.dwSchemeLength = 1;
	ucUrl.dwHostNameLength = 1;
	ucUrl.dwUrlPathLength = 1;
	if (!InternetCrackUrl(lpszUrl, 0, 0, &ucUrl))
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
    }

    INET_ASSERT(ucUrl.lpszHostName && ucUrl.lpszUrlPath);
    DEBUG_PRINT_API(API,
                    INFO,
                    ("URL Cracked. Host = %q Path = %q\n ",
                    ucUrl.lpszHostName, ucUrl.lpszUrlPath
                    ));

    // Ensures the global vszCurrentUser is set
    GetWininetUserName();   
    INET_ASSERT(vszCurrentUser);
    
    // Build the XML request body for a PROPFIND
    //<?xml version='1.0' ?>
    //<?xml:namespace ns='DAV:' prefix='D' ?>
    //<D:propfind>
    //  <D:prop>
    //    <D:resourcetype/>
    //  </D:prop>
    //</D:propfind>    
    
    #define REQUEST_RESOURCE_TYPE   "\
                                    <?xml version='1.0' ?>\r\n \
                                    <?xml:namespace ns='DAV:' prefix='D' ?>\r\n \
                                    <D:propfind>\r\n \
                                        <D:prop>\r\n \
                                            <D:resourcetype/>\r\n \
                                        </D:prop>\r\n \
                                    </D:propfind>\r\n"
    DWORD cbReqSize;
    cbReqSize = lstrlen(REQUEST_RESOURCE_TYPE);
                                    
    LPCSTR lpszXmlRequest;
    lpszXmlRequest = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, cbReqSize);
    
    // Perform a PROPFIND call, looking for resourcetype = DAV:collection
    hSession = InternetOpen(NULL,
						  INTERNET_OPEN_TYPE_PRECONFIG,
						  NULL,
						  NULL,
						  NULL);
	if(!hSession)
	{
		dwError = GetLastError();
	    fRet = FALSE;
		goto cleanup;
	}
	
	hConnection = InternetConnect(hSession,
								   ucUrl.lpszHostName,
								   INTERNET_DEFAULT_HTTP_PORT,
								   (LPCSTR) vszCurrentUser,
								   NULL,
								   INTERNET_SERVICE_HTTP,
								   NULL,
								   NULL);

	if(!hConnection)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	hHTTPReq = HttpOpenRequest(hConnection,
							   "PROPFIND",
							   ucUrl.lpszUrlPath,
							   "HTTP/1.0",
							   NULL,
							   NULL,
							   INTERNET_FLAG_PRAGMA_NOCACHE,NULL);

	if(!hHTTPReq)
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

	if (!HttpAddRequestHeaders(hHTTPReq, lpszHeaders, -1L, HTTP_ADDREQ_FLAG_ADD))
	{
		dwError = GetLastError();
		fRet = FALSE;
		goto cleanup;
	}

	if (!HttpSendRequest(hHTTPReq,NULL, 0L, (LPVOID)lpszXmlRequest, cbReqSize))
	{
		dwError = GetLastError();
		fRet = FALSE;
		goto cleanup;
	}
        
	if (HttpQueryInfo(hHTTPReq,
					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
					  &dwStatusCode,
					  &dwStatusLength,
					  &dwIndex))
	{
        // fRet = TRUE at this point  
        // If request was denied or proxy auth required and callee has said
        // we can display UI, we put up the InternetErrorDlg and ask for
        // credentials. Otherwise, if dwStatus != success we cache that
        // this resource is not DAV compliant
        if ((hWnd) && ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ)))
        {
            DWORD dwRetval;
            BOOL fDone;
            fDone = FALSE;
            while (!fDone)
            {
                dwRetval = InternetErrorDlg(hWnd,
                                            hHTTPReq,
                                            ERROR_INTERNET_INCORRECT_PASSWORD,
                                            0L,
                                            NULL);
                if (dwRetval == ERROR_INTERNET_FORCE_RETRY) // User pressed ok on credentials dialog
                {   // Resend request, new credentials are cached and will be replayed by HSR()
                	if (!HttpSendRequest(hHTTPReq,NULL, 0L, NULL, NULL))
                	{
                		dwError = GetLastError();
                		fRet = FALSE;
                		goto cleanup;
                	}

                    dwStatusCode = 0;

                	if (!HttpQueryInfo(hHTTPReq,
                					  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                					  &dwStatusCode,
                					  &dwStatusLength,
                					  &dwIndex))
                	{
                		dwError = GetLastError();
                	    fRet = FALSE;
                	    goto cleanup;
                	}

                    if ((dwStatusCode != HTTP_STATUS_DENIED) && (dwStatusCode != HTTP_STATUS_PROXY_AUTH_REQ))
                    {
                        fDone = TRUE;
                    }
                }
                else    // User pressed cancel from dialog (note ERROR_SUCCESS == ERROR_CANCELLED from IED())
                {
                    fDone = TRUE;
                }
            }
        }

        if ((dwStatusCode == HTTP_STATUS_DENIED) || (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ))
        {   // Don't want to cache this (user might have forgotten password or we may not
            // be able to show credential UI)
            goto cleanup;
        }
        else if (dwStatusCode != HTTP_STATUS_OK)
        {   // Either initial request failed for non-auth issue, cache as not compliant
            goto update_cache; //note update_cache NOT cleanup, want to cache this as non compliant
        }
	}
	else
	{
		dwError = GetLastError();
	    fRet = FALSE;
	    goto cleanup;
	}

    // Note, what we are doing here is allocating a single page of memory and reserving
    // the first sizeof(LPSTR) bytes to point to the next buffer fragment if required,
    // and so on until the last buffer fragment has NULL at the dwPtrOffset

    lpszBufferHead = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, READ_BUFFER_SIZE);
    if (!lpszBufferHead)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

	memset(lpszBufferHead, 0, READ_BUFFER_SIZE);
	LPSTR lpNext;
    lpNext=lpszBufferHead+sizeof(LPSTR); // Jump over the next buffer ptr space when writing data
    while(!fDone)
    {
        if (!InternetReadFile(hHTTPReq,
                              lpNext,
                              READ_BUFFER_AVAILABLE,
                              &dwRead))
    	{
    		dwError = GetLastError();
    	    fRet = FALSE;
    	    goto cleanup;
    	}
        else 
        {
            if (dwRead < READ_BUFFER_AVAILABLE)
            {
                fDone = TRUE;
            }
            else 
            {
                dwBuffers++;
                *((LPSTR*)lpNext+READ_BUFFER_AVAILABLE) = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, READ_BUFFER_SIZE);
                lpNext = *((LPSTR*)lpNext+READ_BUFFER_AVAILABLE);
                if (!lpNext) 
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }
            	memset(lpNext, 0, READ_BUFFER_SIZE);
            }
            
        }
                          
    }

    // Done reading response, time to parse it
    
    
update_cache :

#ifdef DAVCACHING // commenting out as per bug 15696

    if (TRUE) 
    // Cache if this is a known DAV level 1 server or atleast the last time we tried
    {

        // Update visited links cache
        // We store the cached info as:
        //  CacheEntryInfo.dwExemptDelta(HiWord) = Date DAV discovery was last run
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_LEVEL1_STATUS = Is DAV server (*lpfFound)
        //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_COLLECTION_STATUS = Is DAV collection (set in HttpCheckDavCollection)

        // Assemble the URL to the visited links container "VISITED: username@URL"
        DWORD cbNeededBuf = lstrlen("Visited: ") + lstrlen(vszCurrentUser) + lstrlen(lpszUrl) + 32;
        lpszVisitedUrl = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, cbNeededBuf);
    	if (!lpszVisitedUrl)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        lstrcpy(lpszVisitedUrl, "Visited: "); // For compatibility with urlhist.c visited URLs
        lstrcat(lpszVisitedUrl, vszCurrentUser);
        lstrcat(lpszVisitedUrl, "@");
        lstrcat(lpszVisitedUrl, lpszUrl);

        lpCEI = (LPCACHE_ENTRY_INFO) ALLOCATE_MEMORY(LMEM_FIXED, CEI_BUFFER_SIZE);
    	if (!lpCEI)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        GetSystemTimeAsFileTime(&ftNow);
        if (!FileTimeToDosDateTime(&ftNow,
                                   &wDate,
                                   &wTime
                                   ))
        {                                   
            INET_ASSERT(FALSE); // Should "never" hit this
            goto cleanup;                              
        }

        // Stuff our 16-bit Date into the upper 16-bits of dwExemptDelta
        lpCEI->dwExemptDelta = (DWORD)wDate <<16;

        // Set the DAV_LEVEL1_STATUS_BIT if the resource was found compliant above
        if (*lpfFound) 
        {
            lpCEI->dwExemptDelta |= (DWORD) DAV_LEVEL1_STATUS;
        }
    

        if (!SetUrlCacheEntryInfo (lpszVisitedUrl, 
	  	    					   lpCEI,
		        				   CACHE_ENTRY_EXEMPT_DELTA_FC
			        				))
        {
	       	if (GetLastError() == ERROR_FILE_NOT_FOUND)
	   	    // No existing cache entry, so create one and try again
    	    {
	            FILETIME ftNone;
                if (CommitUrlCacheEntry (lpszVisitedUrl,
                                         NULL,
                                         ftNone,
                                         ftNone,
                                         0,
                                         NULL,
                                         0,
                                         NULL,
                                         0
                                         ))
                {
                    // Entry is now created, so try one more time
                    SetUrlCacheEntryInfo (lpszVisitedUrl, 
	       			    			      lpCEI,
                		    			  CACHE_ENTRY_EXEMPT_DELTA_FC
			               	    		 );
                }
  	    	}
        }
    }
#endif //DAVCACHING
    
cleanup:    
    // Free memory
    // Walk buffer chain
    if (lpszBufferHead)
    {
        lpNext = (LPSTR)*(lpszBufferHead+READ_BUFFER_AVAILABLE);
        FREE_MEMORY(lpszBufferHead);
        while (lpNext)
        {
            lpszBufferHead = lpNext;
            lpNext = (LPSTR)*(lpszBufferHead+READ_BUFFER_AVAILABLE);
            FREE_MEMORY(lpszBufferHead);
        }
    }
    if (lpszXmlRequest) FREE_MEMORY(lpszXmlRequest);
    if (lpCEI) FREE_MEMORY (lpCEI);
    if (lpszVisitedUrl) FREE_MEMORY (lpszVisitedUrl);

    // Close the handles
	if (hHTTPReq) InternetCloseHandle(hHTTPReq);
	if (hConnection) InternetCloseHandle(hConnection);

    SetLastError(dwError);
    DEBUG_LEAVE_API(fRet);
	return fRet;
}

#ifdef DAVCACHING // commenting out as per bug 15696
INTERNETAPI_(BOOL) HttpCheckCachedDavStatusA(
    IN LPCSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    )

/*++

Routine Description:

    Checks if there is cached DAV information for this site or if detection is required, After a successfull call,
    *lpdwStatus will contain a bitfield as described in arguments below.

    Checks HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\DaysBetweenDavDetection for time in days
    to pass between performing detection. If this key is missing, a default of 10 is used.

Arguments:

    lpszUrl             - Url of the resource to check

    lpdwStatus          - address of a DWORD (which must contain zero initially!!) that on return may contain a
                          combination of the following staus bits:
        DAV_LEVEL1_STATUS       - If this bit is set, the site is known to support DAV level 1
        DAV_COLLECTION_STATUS   - If this bit is set, the resource is a collection.
        DAV_DETECTION_REQUIRED  - Either no information is available or information is stale and detection should be performed. 

                          
Return Value:

    TRUE - Success, check lpdwStatus for results.
    FALSE - failure, GetLastError returns the error code

--*/

{
    BOOL            fRet = TRUE;

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckCachedDavStatusA",
                 "%sq, %#x",
                 lpszUrl,
                 lpdwStatus
                 ));


    DWORD           dwError;
   	LPCACHE_ENTRY_INFO lpCEI = NULL;
    FILETIME        ftNow, ftNext, ftWork;
    WORD            wDate;
    LPSTR           lpszVisitedUrl=NULL;
    DWORD           cbCEI = 512, dwDays = 0;
    #define DEFAULT_DAV_DAYS 10
    #define FILE_SEC_TICKS (10000000)
    // SECS PER DAY
    #define DAY_SECS (24*60*60)
    // Debug param checking
    INET_ASSERT(lpszUrl && lpdwStatus && (*lpdwStatus==0));

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpCheckCachedDavStatusA",
                     "%s %x %x",
                     (lpszUrl)?lpszUrl :"NULL Url",
                     lpdwStatus,
                     *lpdwStatus
                     ));

    // non-debug param checking
    if (!lpszUrl || !lpdwStatus || (*lpdwStatus != 0)) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    // Ensures the global vszCurrentUser is set
    GetWininetUserName();   
    INET_ASSERT(vszCurrentUser);

    // Check visited links cache
    // We store the cached info as:
    //  CacheEntryInfo.dwExemptDelta(HiWord) = Date DAV discovery was last run
    //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_LEVEL1_STATUS = Is DAV server (*lpfFound)
    //  CacheEntryInfo.dwExemptDelta(LoWord) & DAV_COLLECTION_STATUS = Is DAV collection (set in HttpCheckDavCollection)

    // Assemble the URL to the visited links container "VISITED: username@URL"
    DWORD cbNeededBuf = lstrlen("Visited: ") + lstrlen(vszCurrentUser) + lstrlen(lpszUrl) + 32;
    lpszVisitedUrl = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, cbNeededBuf);
	if (!lpszVisitedUrl)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    lstrcpy(lpszVisitedUrl, "Visited: "); // For compatibility with urlhist.c visited URLs
    lstrcat(lpszVisitedUrl, vszCurrentUser);
    lstrcat(lpszVisitedUrl, "@");
    lstrcat(lpszVisitedUrl, lpszUrl);

    lpCEI = (LPCACHE_ENTRY_INFO) ALLOCATE_MEMORY(LMEM_FIXED, cbCEI);
	if (!lpCEI)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if (!GetUrlCacheEntryInfo (lpszVisitedUrl, 
  	    					   lpCEI,
	        				   &cbCEI
		        				))
    {
       	if (GetLastError() == ERROR_FILE_NOT_FOUND)
   	    // No existing cache entry, so return DAV_DETECTION_REQUIRED
	    {
            *lpdwStatus = DAV_DETECTION_REQUIRED;
            goto cleanup;
    
	    }
	    else
	    {
	        dwError = GetLastError();
	        fRet = FALSE;
	        goto cleanup;
	    }
    }

    // Get registry setting for # of days between detection or use default if not found
    if ((dwError = InternetReadRegistryDword("DaysBetweenDavDetection", &dwDays)) != ERROR_SUCCESS)
    {
        dwDays = DEFAULT_DAV_DAYS;
    }

    // Get the last date we checked this URL
    wDate = HIWORD(lpCEI->dwExemptDelta);
    DosDateTimeToFileTime(wDate, WORD(0), &ftWork);

    _int64 i64Base;

    i64Base = (((_int64)ftWork.dwHighDateTime) << 32) | ftWork.dwLowDateTime;
    i64Base /= FILE_SEC_TICKS;
    i64Base /= DAY_SECS;
    i64Base += dwDays;
    i64Base *= FILE_SEC_TICKS;
    i64Base *= DAY_SECS;
    ftNext.dwHighDateTime = (DWORD) ((i64Base >> 32) & 0xFFFFFFFF);
    ftNext.dwLowDateTime = (DWORD) (i64Base & 0xFFFFFFFF);

    GetSystemTimeAsFileTime(&ftNow);
    if (CompareFileTime(ftNow, ftNext) >= 0)    // If Now >= Next detect date
    {
        *lpdwStatus = DAV_DETECTION_REQUIRED;
    }

    *lpdwStatus |= LOWORD(lpCEI->dwExemptDelta);
    dwError = ERROR_SUCCESS;
    
cleanup:    
    // Free memory
    if (lpCEI) FREE_MEMORY (lpCEI);
    if (lpszVisitedUrl) FREE_MEMORY (lpszVisitedUrl);

    SetLastError(dwError);
    DEBUG_LEAVE_API(fRet);
	return fRet;
}

#endif //DAVCACHING


INTERNETAPI_(BOOL) HttpCheckDavComplianceW(
    IN LPCWSTR lpszUrlW,
    IN LPCWSTR lpszComplianceTokenW,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    )

/*++

Routine Description:

    Determines the level of DAV compliance of the server. Currently just checks for level 1
    compliance and returns TRUE in lpfFound if detected.
    
Arguments:

    lpszServer          - name of server to check

    lpszPath            - path to resource on the server to check

    lpszComplianceToken - DAV compliance class identifier (i.e. "1") BUGBUG MUST NOT CONTAIN INTERNAL WHITE SPACE "foo bar" = bad, "  foo  " = ok
    
    lpfFound            - address of a BOOL to receive TRUE if DAV compliance is found or FALSE otherwise.

    hWnd                - Handle to window for displaying authentication dialog if needed. May be NULL indicating
                          no UI is to be displayed and authentication failures should be quietly handled.
                          
    lpvReserved         - Reserved, must be NULL
    
Return Value:

    TRUE - Success, check lpfFound for results.
    FALSE - failure, GetLastError returns the error code

--*/

{

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckDavComplianceW",
                 "%wq, %wq, %#x, %#x, %#x",
                 lpszUrlW,
                 lpszComplianceTokenW,
                 lpfFound,
                 hWnd,
                 lpvReserved
                 ));

    MEMORYPACKET mpUrlA, mpComplianceTokenA;
    BOOL            fRet = TRUE;
    DWORD           dwError = ERROR_SUCCESS;
    
    // Debug param checking
    INET_ASSERT(lpszUrlW && lpszComplianceTokenW && lpfFound && !lpvReserved);

    // non-debug param checking
    if (!lpszUrlW || !lpszComplianceTokenW || !lpfFound || lpvReserved) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    ALLOC_MB(lpszUrlW, 0, mpUrlA);
    if (!mpUrlA.psStr)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
	    fRet = FALSE;
	    goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrlW, mpUrlA);

    //  MAKE_ANSI(lpszComplianceTokenW, 0, mpComplianceTokenA);
    ALLOC_MB(lpszComplianceTokenW, 0, mpComplianceTokenA);
    if (!mpComplianceTokenA.psStr)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
	    fRet = FALSE;
	    goto cleanup;
    }
    UNICODE_TO_ANSI(lpszComplianceTokenW, mpComplianceTokenA);

    fRet =  HttpCheckDavComplianceA(mpUrlA.psStr, mpComplianceTokenA.psStr, lpfFound, hWnd, lpvReserved);

cleanup:    
    DEBUG_LEAVE_API(fRet);
    return(fRet);


}


#ifdef DAVCACHING //commenting out as per bug 15696
INTERNETAPI_(BOOL) HttpCheckCachedDavStatusW(
    IN LPCWSTR lpszUrlW,
    IN OUT LPDWORD lpdwStatus
    )

/*++

Routine Description:

    Checks if there is cached DAV information for this site or if detection is required, 
Arguments:

    lpszUrl             - Url of the resource to check

    lpdwStatus          - address of a DWORD (which must contain zero initially!!) that on return may contain a
                          combination of the following staus bits:
        DAV_LEVEL1_STATUS       - If this bit is set, the site is known to support DAV level 1
        DAV_COLLECTION_STATUS   - If this bit is set, the resource is a collection.
        DAV_DETECTION_REQUIRED  - Either no information is available or information is stale and detection should be performed. 

                          
Return Value:

    TRUE - Success, check lpdwStatus for results.
    FALSE - failure, GetLastError returns the error code

--*/

{

    DEBUG_ENTER((DBG_API,
                 Bool,
                 "HttpCheckCachedDavStatusW",
                 "%wq, %#x",
                 lpszUrlW,
                 lpdwStatus
                 ));

    MEMORYPACKET mpUrlA;
    BOOL            fRet = TRUE;
    DWORD           dwError = ERROR_SUCCESS;
    // Debug param checking
    INET_ASSERT(lpszUrlW && lpdwStatus && (*lpdwStatus==0));

    // non-debug param checking
    if (!lpszUrlW || !lpdwStatus || (*lpdwStatus!=0)) 
    {
        dwError = ERROR_INVALID_PARAMETER;
	    fRet = FALSE;
	    goto cleanup;
    }

    ALLOC_MB(lpszUrlW, 0, mpUrlA);
    if (!mpUrlA.psStr)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
	    fRet = FALSE;
	    goto cleanup;
    }
    UNICODE_TO_ANSI(lpszUrlW, mpUrlA);

    fRet = HttpCheckCachedDavStatusA(mpUrlA.psStr, lpdwStatus);

cleanup:
    DEBUG_LEAVE_API(fRet);
    return(fRet);

}
#endif //DAVCACHING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\headers.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    headers.cxx

Abstract:

    Methods for HTTP_HEADERS (..\inc\http.hxx) classes

    Contents:

        HEADER_STRING::CreateHash
        HTTP_HEADERS::HeaderMatch
        HTTP_HEADERS::AllocateHeaders
        HTTP_HEADERS::FreeHeaders
        HTTP_HEADERS::CopyHeaders
        HTTP_HEADERS::FindFreeSlot
        HTTP_HEADERS::AddHeader
        HTTP_HEADERS::ReplaceHeader
        HTTP_HEADERS::FindHeader
        HTTP_HEADERS::QueryRawHeaders
        HTTP_HEADERS::AddRequest
        HTTP_HEADERS::ModifyRequest
        HTTP_HEADERS::SetRequestVersion
        HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer
        HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader
        HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader
        HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode
        HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText
        HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders
        HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName
        HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders
        MapHttpMethodType
        CreateEscapedUrlPath
        (CalculateHashNoCase)
Author:

    Richard L Firth (rfirth) 20-Dec-1995

Revision History:

    20-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private manifests
//

#define DATE_AND_TIME_STRING_BUFFER_LENGTH  128

#ifdef COMPRESSED_HEADERS

typedef struct tagHEADER_MAP {

    LPSTR   lpszLongHeader;
    DWORD   dwLenLongHeader;
    LPSTR   lpszShortHeader;
    DWORD   dwLenShortHeader;

}
HEADER_MAP;


// Sorted Compression map

HEADER_MAP rgsHeaderMap[] = {
{"",                    0,                                 "",    0              },
{"Accept",             sizeof("Accept")-1,               "#A", sizeof("#A")-1},
{"Accept-Charset",     sizeof("Accept-Charset")-1,       "#B", sizeof("#B")-1},
{"Accept-Encoding",    sizeof("Accept-Encoding")-1,      "#C", sizeof("#C")-1},
{"Accept-Language",    sizeof("Accept-Language")-1,      "#D", sizeof("#D")-1},
{"Accept-Ranges",      sizeof("Accept-Ranges")-1,        "#E", sizeof("#E")-1},
{"Age",                sizeof("Age")-1,                  "#F", sizeof("#F")-1},
{"Allow",              sizeof("Allow")-1,                "#G", sizeof("#G")-1},
{"Authorization",      sizeof("Authorization")-1,        "#H", sizeof("#H")-1},
{"Cache-Control",      sizeof("Cache-Control")-1,        "#I", sizeof("#I")-1},
{"Connection",         sizeof("Connection")-1,           "#J", sizeof("#J")-1},
{"Content-Base",       sizeof("Content-Base")-1,         "#K", sizeof("#K")-1},
{"Content-Encoding",   sizeof("Content-Encoding")-1,     "#L", sizeof("#L")-1},
{"Content-Language",   sizeof("Content-Language")-1,     "#M", sizeof("#M")-1},
{"Content-Length",     sizeof("Content-Length")-1,       "#N", sizeof("#N")-1},
{"Content-Location",   sizeof("Content-Location")-1,     "#O", sizeof("#O")-1},
{"Content-MD5",        sizeof("Content-MD5")-1,          "#P", sizeof("#P")-1},
{"Content-Range",      sizeof("Content-Range")-1,        "#Q", sizeof("#Q")-1},
{"Content-Type",       sizeof("Content-Type")-1,         "#R", sizeof("#R")-1},

{"Cookie",             sizeof("Cookie")-1,               "#5", sizeof("#5")-1},

{"Date",               sizeof("Date")-1,                 "#S", sizeof("#S")-1},
{"ETag",               sizeof("ETag")-1,                 "#T", sizeof("#T")-1},
{"Expires",            sizeof("Expires")-1,              "#U", sizeof("#U")-1},
{"From",               sizeof("From")-1,                 "#V", sizeof("#V")-1},
{"Host",               sizeof("Host")-1,                 "#W", sizeof("#W")-1},
{"If-Modified-Since",  sizeof("If-Modified-Since")-1,    "#X", sizeof("#X")-1},
{"If-Match",           sizeof("If-Match")-1,             "#Y", sizeof("#Y")-1},
{"If-None-Match",      sizeof("If-None-Match")-1,        "#Z", sizeof("#Z")-1},
{"If-Range",           sizeof("If-Range")-1,             "#a", sizeof("#a")-1},
{"If-Unmodified-Since",sizeof("If-Unmodified-Since")-1,  "#b", sizeof("#b")-1},
{"Last-Modified",      sizeof("Last-Modified")-1,        "#c", sizeof("#c")-1},
{"Location",           sizeof("Location")-1,             "#d", sizeof("#d")-1},
{"Max-Forwards",       sizeof("Max-Forwards")-1,         "#e", sizeof("#e")-1},
{"Pragma",             sizeof("Pragma")-1,               "#f", sizeof("#f")-1},
{"Proxy-Authenticate", sizeof("Proxy-Authenticate")-1,   "#g", sizeof("#g")-1},
{"Proxy-Authorization",sizeof("Proxy-Authorization")-1,  "#h", sizeof("#h")-1},
{"Public",             sizeof("Public")-1,               "#I", sizeof("#I")-1},
{"Range",              sizeof("Range")-1,                "#j", sizeof("#j")-1},
{"Referer",            sizeof("Referer")-1,              "#k", sizeof("#k")-1},
{"Retry-After",        sizeof("Retry-After")-1,          "#l", sizeof("#l")-1},
{"Server",             sizeof("Server")-1,               "#m", sizeof("#m")-1},
{"Transfer-Encoding",  sizeof("Transfer-Encoding")-1,    "#n", sizeof("#n")-1},

{"UA-color",           sizeof("UA-color")-1,             "#1", sizeof("#1")-1},
{"UA-cpu",             sizeof("UA-cpu")-1,               "#2", sizeof("#2")-1},
{"UA-OS",              sizeof("UA-OS")-1,                "#3", sizeof("#3")-1},
{"UA-pixels",          sizeof("UA-pixels")-1,            "#4", sizeof("#4")-1},

{"Upgrade",            sizeof("Upgrade")-1,              "#o", sizeof("#o")-1},
{"User-Agent",         sizeof("User-Agent")-1,           "#p", sizeof("#p")-1},
{"Vary",               sizeof("Vary")-1,                 "#q", sizeof("#q")-1},
{"Via",                sizeof("Via")-1,                  "#r", sizeof("#r")-1},
{"Warning",            sizeof("Warning")-1,              "#s", sizeof("#s")-1},
{"WWW-Authenticate",   sizeof("WWW-Authenticate")-1,     "#t", sizeof("#t")-1}
};


#endif //COMPRESSED_HEADERS





//
// Private functions
//

PRIVATE
BOOL
FMatchList(
    LPSTR *lplpList,
    DWORD cListLen,
    HEADER_STRING *lpHeader,
    LPSTR    lpBase
    );




//
// external functions
//

extern
BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    );

#ifdef COMPRESSED_HEADERS
DWORD
LookupHeadermap(
    LPSTR   lpszHeader
);

extern BOOL vfCompressedHeaders;
#endif //COMPRESSED_HEADERS


DWORD
FASTCALL
CalculateHashNoCase(
    IN LPSTR lpszString,
    IN DWORD dwStringLength
    )

/*++

Routine Description:

    Calculate a case-insensitive hash number given a string. Assumes input is
    7-bit ASCII

Arguments:

    lpszString      - string to hash

    dwStringLength  - length of lpszString, or -1 if we need to calculate

Return Value:

    DWORD - a generated hash value

--*/

{
    DWORD dwHash = HEADER_HASH_SEED;

    while (dwStringLength != 0) {
        CHAR ch = *lpszString;

        if ((ch >= 'A') && (ch <= 'Z')) {
            ch = MAKE_LOWER(ch);
        }
        dwHash += (DWORD)(dwHash << 5) + ch; /*+ *pszName++;*/

        ++lpszString;
        --dwStringLength;
    }
    return dwHash;
}

//
// methods
//

VOID
inline
HEADER_STRING::CreateHash(
    LPSTR lpszBase
    )
{
    DWORD i = 0;
    LPSTR string = StringAddress(lpszBase);

    while ((i < (DWORD)StringLength())
           && !((string[i] == ':')
                || (string[i] == ' ')
                || (string[i] == '\r')
                || (string[i] == '\n'))) {
        ++i;
    }
    m_Hash = CalculateHashNoCase(string, i);
}



DWORD
HTTP_HEADERS::AllocateHeaders(
    IN DWORD dwNumberOfHeaders
    )

/*++

Routine Description:

    Allocates or grows the array of header pointers (HEADER_STRING objects)

Arguments:

    dwNumberOfHeaders   - number of additional header slots to create

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AllocateHeaders",
                 "%d",
                 dwNumberOfHeaders
                 ));

    PERF_ENTER(AllocateHeaders);

    //
    // we really need to be able to realloc an array of HEADER_STRING objects
    // (see below)
    //

    DWORD error;
    DWORD slots = _TotalSlots;


    if ( (_TotalSlots + dwNumberOfHeaders) >  (INVALID_HEADER_INDEX-1))
    {
        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    _lpHeaders = (HEADER_STRING *)ResizeBuffer((HLOCAL)_lpHeaders,
                                               (_TotalSlots + dwNumberOfHeaders)
                                                    * sizeof(HEADER_STRING),
                                               FALSE // not moveable
                                               );
    if (_lpHeaders != NULL) {
        _NextOpenSlot = _TotalSlots;
        _TotalSlots += dwNumberOfHeaders;
        _FreeSlots += dwNumberOfHeaders;

        //
        // this is slightly ugly, but it seems there's no easy C++ way to
        // do this - we need to be able to realloc() an array of objects
        // created by new(), but so far, it can't be done
        //

        for (; slots < _TotalSlots; ++slots) {
            _lpHeaders[slots].Clear();
        }
        error = ERROR_SUCCESS;
    } else {

        INET_ASSERT(FALSE);
        _NextOpenSlot = 0;
        _TotalSlots = 0;
        _FreeSlots = 0;
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    INET_ASSERT(_FreeSlots <= _TotalSlots);

    PERF_LEAVE(AllocateHeaders);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::FreeHeaders(
    VOID
    )

/*++

Routine Description:

    Free the headers strings and the headers array

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "FreeHeaders",
                 NULL
                 ));

    LockHeaders();

    //
    // free up each individual entry (free string buffers)
    //

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        _lpHeaders[i] = (LPSTR)NULL;
    }

    //
    // followed by the array itself
    //

    if (_lpHeaders) {
        _lpHeaders = (HEADER_STRING *)FREE_MEMORY((HLOCAL)_lpHeaders);

        INET_ASSERT(_lpHeaders == NULL);
    }

    _TotalSlots = 0;
    _FreeSlots = 0;
    _HeadersLength = 0;
    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    UnlockHeaders();

    DEBUG_LEAVE(0);
}


VOID
HTTP_HEADERS::CopyHeaders(
    IN OUT LPSTR * lpBuffer,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength
    )

/*++

Routine Description:

    Copy the headers to the caller's buffer. Each header is terminated by CR-LF.
    This method is called to convert the request headers list to a buffer that
    we can send to the server

    N.B. This function MUST be called with the headers already locked

Arguments:

    lpBuffer            - pointer to pointer to buffer where headers are
                          written. We update the pointer

    lpszObjectName      - optional object name

    dwObjectNameLength  - optional object name length

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "CopyHeaders",
                 "%#x, %#x [%q], %d",
                 lpBuffer,
                 lpszObjectName,
                 lpszObjectName,
                 dwObjectNameLength
                 ));

    LockHeaders();

    DWORD i = 0;

    if (lpszObjectName != NULL) {
        memcpy(*lpBuffer, _lpszVerb, _dwVerbLength);
        *lpBuffer += _dwVerbLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, lpszObjectName, dwObjectNameLength);
        *lpBuffer += dwObjectNameLength;
        *(*lpBuffer)++ = ' ';
        memcpy(*lpBuffer, _lpszVersion, _dwVersionLength);
        *lpBuffer += _dwVersionLength;
        *(*lpBuffer)++ = '\r';
        *(*lpBuffer)++ = '\n';
        i = 1;
    }
    for (; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {
            _lpHeaders[i].CopyTo(*lpBuffer);
            *lpBuffer += _lpHeaders[i].StringLength();
            *(*lpBuffer)++ = '\r';
            *(*lpBuffer)++ = '\n';
        }
    }

    UnlockHeaders();

    DEBUG_LEAVE(0);
}

#ifdef COMPRESSED_HEADERS

VOID
HTTP_HEADERS::CopyCompressedHeaders(
    IN OUT LPSTR * lpBuffer
    )

/*++

Routine Description:

    Copy the headers to the caller's buffer. Each header is terminated by CR-LF.
    This method is called to convert the request headers list to a buffer that
    we can send to the server

    N.B. This function MUST be called with the headers already locked

Arguments:

    lpBuffer    - pointer to pointer to buffer where headers are written. We
                  update the pointer

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "CopyCompressedHeaders",
                 "%#x",
                 lpBuffer
                 ));
    LPSTR   lpszHeaderString;
    DWORD j;
    LockHeaders();

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {

            lpszHeaderString = _lpHeaders[i].StringAddress(NULL);

            j = LookupHeadermap(lpszHeaderString);

            if (j) {
                // copy the corresponding short header and bump the pointer
                // ahead


                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("Compressed:%s using %s\n",
                        lpszHeaderString,
                        rgsHeaderMap[j].lpszShortHeader
                    )
                );

                strcpy(*lpBuffer, rgsHeaderMap[j].lpszShortHeader);

                *lpBuffer += rgsHeaderMap[j].dwLenShortHeader;

                // then copy the value of the header
                // and bump the destination further by the right amount
                strncpy(*lpBuffer,
                        lpszHeaderString + rgsHeaderMap[j].dwLenLongHeader,
                        _lpHeaders[i].StringLength() - rgsHeaderMap[j].dwLenLongHeader
                );

                *lpBuffer += (_lpHeaders[i].StringLength() - rgsHeaderMap[j].dwLenLongHeader);

            }
            else {

                // No match found, must be a header we don't know about
                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("Couldn't compress header for %s\n",
                        lpszHeaderString
                    )
                );

                _lpHeaders[i].CopyTo(*lpBuffer);
                *lpBuffer += _lpHeaders[i].StringLength();

            }

            *(*lpBuffer)++ = '\r';
            *(*lpBuffer)++ = '\n';

        }
    }

    UnlockHeaders();

    DEBUG_LEAVE(0);
}
#endif //COMPRESSED_HEADERS


HEADER_STRING *
FASTCALL
HTTP_HEADERS::FindFreeSlot(
    DWORD* piSlot
    )

/*++

Routine Description:

    Finds the next free slot in the headers list, or adds some new slots

    N.B. This function MUST be called with the headers already locked

Arguments:

    piSlot: returns index of slot found

Return Value:

    HEADER_STRING *  - pointer to next free slot

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "FindFreeSlot",
                 NULL
                 ));

    PERF_ENTER(FindFreeSlot);

    DWORD i;
    DWORD error;
    HEADER_STRING * header = NULL;

    //
    // if there are no free slots, allocate some more
    //

    if (_FreeSlots == 0) {
        i = _TotalSlots;
        error = AllocateHeaders(HEADERS_INCREMENT);
    } else {
        i = 0;
        error = ERROR_SUCCESS;
        if (!_lpHeaders[_NextOpenSlot].HaveString())
        {
            --_FreeSlots;
            header = &_lpHeaders[_NextOpenSlot];
            *piSlot = _NextOpenSlot;
            _NextOpenSlot = (_NextOpenSlot == (_TotalSlots-1)) ? (_TotalSlots-1) : _NextOpenSlot++;
            goto quit;
        }
    }
    if (error == ERROR_SUCCESS) {
        for (; i < _TotalSlots; ++i) {
            if (!_lpHeaders[i].HaveString()) {
                --_FreeSlots;
                header = &_lpHeaders[i];
                *piSlot = i;
                _NextOpenSlot = (i == (_TotalSlots-1)) ? (_TotalSlots-1) : (i+1);
                break;
            }
        }
        if (header == NULL) {

            //
            // we would have just allocated extra slots if we didn't have
            // any, so we shouldn't be here
            //

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    }

quit:
    _Error = error;

    PERF_LEAVE(FindFreeSlot);

    DEBUG_LEAVE(header);

    return header;
}


VOID
HTTP_HEADERS::ShrinkHeader(
    IN LPBYTE pbBase,
    IN DWORD  iSlot,
    IN DWORD  dwOldQueryIndex,
    IN DWORD  dwNewQueryIndex,
    IN DWORD  cbNewSize
    )

/*++

Routine Description:

    Low level function that does a surgical replace of one header with another.
    This code updates internal structures such as bKnownHeaders and the stored
    hash value for the new Header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    None.

--*/

{
    HEADER_STRING* pHeader = _lpHeaders + iSlot;

    INET_ASSERT(_bKnownHeaders[dwOldQueryIndex] == (BYTE) iSlot ||
                dwNewQueryIndex == dwOldQueryIndex );

    //
    // Swap in the new header.  Update Length, Hash, and its cached position
    //  in the known header array.
    //

    _bKnownHeaders[dwOldQueryIndex] = INVALID_HEADER_INDEX;
    _bKnownHeaders[dwNewQueryIndex] = (BYTE) iSlot;

    pHeader->SetLength (cbNewSize);
    pHeader->SetHash (GlobalKnownHeaders[dwNewQueryIndex].HashVal);
}

DWORD
inline
HTTP_HEADERS::SlowFind(
    IN LPSTR lpBase,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwIndex,
    IN DWORD dwHash,
    OUT DWORD *lpdwQueryIndex,
    OUT BYTE  **lplpbPrevIndex
    )

/*++

Routine Description:

    Finds the next occurance of lpszHeaderName in the header array, uses
    a cached table of well known headers to accerlate the search if the
    string is a known header.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{

    //
    // Now see if this is a known header passed in as a string,
    //   If it is, we save ourselves the loop, and just map it right in to a known header
    //

    DWORD dwKnownQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    *lpdwQueryIndex = INVALID_HEADER_SLOT;

    if ( dwKnownQueryIndex != 0 )
    {
        dwKnownQueryIndex--;

        if ( ((int)dwHeaderNameLength >= GlobalKnownHeaders[dwKnownQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[dwKnownQueryIndex].Text,
                      GlobalKnownHeaders[dwKnownQueryIndex].Length) == 0)
        {
            *lpdwQueryIndex = dwKnownQueryIndex;

            INET_ASSERT((int)(dwHeaderNameLength) == GlobalKnownHeaders[dwKnownQueryIndex].Length);

            if ( lplpbPrevIndex )
            {
                return FastNukeFind(
                        dwKnownQueryIndex,
                        dwIndex,
                        lplpbPrevIndex
                        );
            }
            else
            {
                return FastFind(
                        dwKnownQueryIndex,
                        dwIndex
                        );
            }
        }
    }

    //
    // Otherwise we painfully enumerate the whole array of headers
    //

    for (DWORD i = 0; i < _TotalSlots; ++i)
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[i];

        if (!pString->HaveString()) {
            continue;
        }

        if (pString->HashStrnicmp(lpBase,
                                  lpszHeaderName,
                                  dwHeaderNameLength,
                                  dwHash) == 0)
        {

            //
            // if we haven't reached the required index yet, continue
            //

            if (dwIndex != 0) {
                --dwIndex;
                continue;
            }

            return i; // found index/slot
        }
    }

    return INVALID_HEADER_SLOT; // not found
}


DWORD
inline
HTTP_HEADERS::FastFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    DWORD dwSlot;

    dwSlot = _bKnownHeaders[dwQueryIndex];

    while ( (dwIndex > 0) && (dwSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[dwSlot];
        dwSlot  = pString->GetNextKnownIndex();

        dwIndex--;
    }

    if ( dwSlot >= INVALID_HEADER_INDEX)
    {
        return INVALID_HEADER_SLOT;
    }

    return dwSlot; // found it.
}


DWORD
inline
HTTP_HEADERS::FastNukeFind(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwIndex,
    OUT BYTE **lplpbPrevIndex
    )
/*++

Routine Description:

    Finds the next occurance of a known header string in the lpHeaders array.
    Since this is a known string, an index is used to refer to it.
    A cached table of well known headers is used to accerlate the search.
    Also provides a ptr to ptr to the slot which directs us to the one found.
    This is needed for deletion purposes.

    N.B. This function MUST be called with the headers already locked

Arguments:


Return Value:

    DWORD  - index to Slot in array, or INVALID_HEADER_SLOT if not found

--*/

{
    BYTE *lpbSlot;

    *lplpbPrevIndex = lpbSlot = &_bKnownHeaders[dwQueryIndex];
    dwIndex++;

    while ( (dwIndex > 0) && (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString = &_lpHeaders[*lpbSlot];
        *lplpbPrevIndex = lpbSlot;
        lpbSlot  = pString->GetNextKnownIndexPtr();

        dwIndex--;
    }

    if ( **lplpbPrevIndex >= INVALID_HEADER_INDEX ||
         dwIndex > 0 )
    {
        return INVALID_HEADER_SLOT;
    }

    return ((DWORD) **lplpbPrevIndex); // found it.
}

VOID
HTTP_HEADERS::RemoveAllByIndex(
    IN DWORD dwQueryIndex
    )
/*++

Routine Description:

    Removes all Known Headers found in the header array.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

Return Value:

    None.

--*/


{
    BYTE bSlot;
    BYTE bPrevSlot;

    bSlot = bPrevSlot  = _bKnownHeaders[dwQueryIndex];

    while (bSlot < INVALID_HEADER_INDEX)
    {
        HEADER_STRING * pString;

        bPrevSlot   = bSlot;
        pString     = &_lpHeaders[bSlot];
        bSlot       = (BYTE) pString->GetNextKnownIndex();

        RemoveHeader(bPrevSlot, dwQueryIndex, &_bKnownHeaders[dwQueryIndex]);
    }

    _bKnownHeaders[dwQueryIndex] = INVALID_HEADER_INDEX;

    return;
}


BOOL
inline
HTTP_HEADERS::HeaderMatch(
    IN DWORD dwHash,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    OUT DWORD *lpdwQueryIndex
    )

/*++

Routine Description:

    Looks up a Known HTTP header string using its Hash value and
     string contained the name of the header.

Arguments:

    dwHash              - Hash value of header name string

    lpszHeaderName      - name of header we are matching

    dwHeaderNameLength  - length of header name string

    lpdwQueryIndex      - If found, this is the HTTP_QUERY_* based index to the header.

Return Value:

    BOOL
        Success - The string and hash matched againsted a known header

        Failure - There is no known header for that hash & string pair.

--*/

{
    *lpdwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

    if ( *lpdwQueryIndex != 0 )
    {
        (*lpdwQueryIndex)--;

        if ( ((int)dwHeaderNameLength == GlobalKnownHeaders[*lpdwQueryIndex].Length) &&
             strnicmp(lpszHeaderName,
                      GlobalKnownHeaders[*lpdwQueryIndex].Text,
                      GlobalKnownHeaders[*lpdwQueryIndex].Length) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BYTE
inline
HTTP_HEADERS::FastAdd(
    IN DWORD  dwQueryIndex,
    IN DWORD  dwSlot
    )
/*++

Routine Description:

    Rapidly adds a known string to the header array, this function
     is used to matain coherency of the _bKnownHeaders which
     contained indexed offsets into the header array for known headers.

    Note that this function is used instead of latter listed below
     in order to maintain proper order in headers received.

    N.B. This function MUST be called with the headers already locked

Arguments:

    dwQueryIndex - index to known header string to remove from array.

    dwSlot - Slot in which this header is being added.

Return Value:

    None.

--*/


{
    BYTE *lpbSlot;

    lpbSlot = &_bKnownHeaders[dwQueryIndex];

    while ( (*lpbSlot < INVALID_HEADER_INDEX) )
    {
        HEADER_STRING * pString;

        pString  = &_lpHeaders[*lpbSlot];
        lpbSlot  = pString->GetNextKnownIndexPtr();
    }

    INET_ASSERT(*lpbSlot == INVALID_HEADER_INDEX);

    *lpbSlot = (BYTE) dwSlot;
    return INVALID_HEADER_INDEX;
}


//BYTE
//inline
//HTTP_HEADERS::FastAdd(
//    IN DWORD  dwQueryIndex,
//    IN DWORD  dwSlot
//    )
//{
//    BYTE bOldSlot;
//
//    bOldSlot = _bKnownHeaders[dwQueryIndex];
//    _bKnownHeaders[dwQueryIndex] = (BYTE) dwSlot;
//
//    return bOldSlot;
//}




DWORD
HTTP_HEADERS::AddHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    lpszHeaderName      - pointer to name of header to add, e.g. "Accept:"

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    LockHeaders();

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(*lpszHeaderName != '\0');
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    //
    // we may have been handed a header with a trailing colon. We don't care
    // for such nasty imagery
    //

    if (lpszHeaderName[dwHeaderNameLength - 1] == ':') {
        --dwHeaderNameLength;
    }

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    DWORD i = 0;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = SlowFind(
                    NULL,
                    lpszHeaderName,
                    dwHeaderNameLength,
                    dwIndex,
                    dwHash,
                    &dwQueryIndex,
                    NULL
                    );

        if (dwSlot != ((DWORD) -1))
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }
    else
    {

        //
        // Check to verify that the header we're adding is a known header,
        //   If its a known header we use dwQueryIndex to update the known header array
        //   otherwise, IF ITS NOT, we make sure to set dwQueryIndex to INVALID_...
        //

        if (! HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwQueryIndex) )
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }

        /*
        // Perhaps this more efficent ???
        dwQueryIndex = GlobalHeaderHashs[(dwHash % MAX_HEADER_HASH_SIZE)];

        if ( dwQueryIndex != 0 )
        {
            dwQueryIndex--;

            if ( ((int)dwHeaderNameLength < GlobalKnownHeaders[dwQueryIndex].Length) ||
                 strnicmp(lpszHeaderName,
                          GlobalKnownHeaders[dwQueryIndex].Text,
                          GlobalKnownHeaders[dwQueryIndex].Length) != 0)
            {
                dwQueryIndex = INVALID_HEADER_SLOT;
            }
        }
        else
        {
            dwQueryIndex = INVALID_HEADER_SLOT;
        }
        */
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);

        if ( dwQueryIndex != INVALID_HEADER_SLOT )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));
        }

        error = ERROR_SUCCESS;
    }

quit:

    UnlockHeaders();

    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::AddHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Adds a single header to the array of headers, given the header name and
    value. Called via HttpOpenRequest()

Arguments:

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lpszHeaderValue     - pointer to value of header to add, e.g. "text/html"

    dwHeaderValueLength - length of the header value

    dwIndex             - if coalescing headers, index of header to update

    dwFlags             - flags controlling function:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            CLEAN_HEADER
                                - header is supplied by user, so we must ensure
                                  it has correct format

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of memory allocating string

                  ERROR_INVALID_PARAMETER
                    The header value was bad

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(AddHeader);

    INET_ASSERT(dwQueryIndex <= HTTP_QUERY_MAX);
    INET_ASSERT(lpszHeaderValue != NULL);
    INET_ASSERT(*lpszHeaderValue != '\0');
    INET_ASSERT(dwHeaderValueLength != 0);
    INET_ASSERT(_FreeSlots <= _TotalSlots);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD i = 0;
    LPSTR lpszHeaderName;
    DWORD dwHeaderNameLength;
    DWORD dwHash;

    dwHash             = GlobalKnownHeaders[dwQueryIndex].HashVal;
    lpszHeaderName     = GlobalKnownHeaders[dwQueryIndex].Text;
    dwHeaderNameLength = GlobalKnownHeaders[dwQueryIndex].Length;

    //
    // if we are coalescing headers then find a header with the same name
    //

    if ((dwFlags & COALESCE_HEADER_WITH_COMMA) ||
        (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) )
    {
        DWORD dwSlot;

        dwSlot = FastFind(
                    dwQueryIndex,
                    dwIndex
                    );

        if (dwSlot != INVALID_HEADER_SLOT)
        {

            HEADER_STRING * pString;

            pString = &_lpHeaders[dwSlot];

            //
            // found what we are looking for. Coalesce it
            //

            pString->ResizeString((sizeof("; ")-1) + dwHeaderValueLength); // save us from multiple reallocs

            pString->Strncat(
                             (dwFlags & COALESCE_HEADER_WITH_SEMICOLON) ?
                                 "; " :
                                 ", ",
                              2);

            pString->Strncat(lpszHeaderValue, dwHeaderValueLength);
            _HeadersLength += 2 + dwHeaderValueLength;
            error = ERROR_SUCCESS;

        }
    }


    //
    // if we didn't find the header value or we are not coalescing then add the
    // header
    //

    if (error == ERROR_HTTP_HEADER_NOT_FOUND)
    {
        //
        // find the next slot for this header
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }


        freeHeader->CreateStringBuffer((LPVOID)lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwHeaderNameLength
                                       + sizeof(": ") - 1
                                       + dwHeaderValueLength
                                       + 1 // for extra NULL terminator
                                       );
        if (freeHeader->IsError()) {
            error = ::GetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            goto quit;
        }
        freeHeader->Strncat((LPVOID)": ", sizeof(": ") - 1);
        freeHeader->Strncat((LPVOID)lpszHeaderValue, dwHeaderValueLength);
        _HeadersLength += dwHeaderNameLength
                        + (sizeof(": ") - 1)
                        + dwHeaderValueLength
                        + (sizeof("\r\n") - 1)
                        ;
        freeHeader->SetHash(dwHash);
        freeHeader->SetNextKnownIndex(FastAdd(dwQueryIndex, iSlot));

        error = ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderName      - pointer to the header name

    dwHeaderNameLength  - length of the header name

    lpszHeaderValue     - pointer to the header value

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%.*q, %d, %.*q, %d, %d, %#x",
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    INET_ASSERT(lpszHeaderName != NULL);
    INET_ASSERT(dwHeaderNameLength != 0);
    INET_ASSERT(lpszHeaderName[dwHeaderNameLength - 1] != ':');

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);
    DWORD dwSlot;
    DWORD dwQueryIndex;
    BYTE *pbPrevByte;

    LockHeaders();

    dwSlot = SlowFind(
                NULL,
                lpszHeaderName,
                dwHeaderNameLength,
                dwIndex,
                dwHash,
                &dwQueryIndex,
                &pbPrevByte
                );

    if ( dwSlot != ((DWORD) -1))
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto quit;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            if ( dwQueryIndex != ((DWORD) -1) )
            {
                error = AddHeader(dwQueryIndex,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }
            else
            {
                error = AddHeader(lpszHeaderName,
                                  dwHeaderNameLength,
                                  lpszHeaderValue,
                                  dwHeaderValueLength,
                                  0,
                                  dwFlags
                                  );
            }


        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        if ( dwQueryIndex != ((DWORD) -1) )
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        }
        else
        {
            error = AddHeader(lpszHeaderName,
                              dwHeaderNameLength,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );

        }
    }

quit:

    UnlockHeaders();

    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::ReplaceHeader(
    IN DWORD dwQueryIndex,
    IN LPSTR lpszHeaderValue,
    IN DWORD dwHeaderValueLength,
    IN DWORD dwIndex,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Replaces a HTTP (request) header. The header can be replaced with a NULL
    value, meaning that the header is removed

Arguments:

    lpszHeaderValue     - pointer to the header value

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwHeaderValueLength - length of the header value

    dwIndex             - index of header to replace

    dwFlags             - flags controlling function. Allowed flags are:

                            COALESCE_HEADER_WITH_COMMA
                            COALESCE_HEADER_WITH_SEMICOLON
                                - headers of the same name can be combined

                            ADD_HEADER
                                - if the header-name is not found and there is
                                  a valid header-value, then the header is added

                            ADD_HEADER_IF_NEW
                                - if the header-name exists then we return an
                                  error, else we add the header-value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_HEADER_NOT_FOUND
                    The requested header wasn't found

                  ERROR_HTTP_HEADER_ALREADY_EXISTS
                    The header already exists, and was not added or replaced

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ReplaceHeader",
                 "%q, %u, %.*q, %d, %d, %#x",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex,
                 min(dwHeaderValueLength + 1, 80),
                 lpszHeaderValue,
                 dwHeaderValueLength,
                 dwIndex,
                 dwFlags
                 ));

    PERF_ENTER(ReplaceHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    BYTE *pbPrevByte;

    LockHeaders();

    dwSlot = FastNukeFind(
                dwQueryIndex,
                dwIndex,
                &pbPrevByte
                );

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // if ADD_HEADER_IF_NEW is set, then we already have the header
        //

        if (dwFlags & ADD_HEADER_IF_NEW) {
            error = ERROR_HTTP_HEADER_ALREADY_EXISTS;
            goto quit;
        }

        //
        // for both replace and remove operations, we are going to remove
        // the current header
        //

        RemoveHeader(dwSlot, dwQueryIndex, pbPrevByte);

        //
        // if replacing then add the new header value
        //

        if (dwHeaderValueLength != 0)
        {
            error = AddHeader(dwQueryIndex,
                              lpszHeaderValue,
                              dwHeaderValueLength,
                              0,
                              dwFlags
                              );
        } else {
            error = ERROR_SUCCESS;
        }
    }

    //
    // if we didn't find the header but ADD_HEADER is set then we simply add it
    // but only if the value length is not zero
    //

    if ((error == ERROR_HTTP_HEADER_NOT_FOUND)
    && (dwHeaderValueLength != 0)
    && (dwFlags & (ADD_HEADER | ADD_HEADER_IF_NEW)))
    {
        error = AddHeader(dwQueryIndex,
                          lpszHeaderValue,
                          dwHeaderValueLength,
                          0,
                          dwFlags
                          );
    }

quit:

    UnlockHeaders();

    PERF_LEAVE(ReplaceHeader);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Finds a request or response header

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FindHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));


    PERF_ENTER(FindHeader);



    INET_ASSERT(lpdwIndex != NULL);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;
    DWORD dwSlot;
    HEADER_STRING * pString;
    DWORD dwQueryIndex;
    DWORD dwHash = CalculateHashNoCase(lpszHeaderName, dwHeaderNameLength);

    LockHeaders();

    dwSlot = SlowFind(
                lpBase,
                lpszHeaderName,
                dwHeaderNameLength,
                *lpdwIndex,
                dwHash,
                &dwQueryIndex,
                NULL
                );

    if ( dwSlot != ((DWORD) -1) )
    {
        pString = &_lpHeaders[dwSlot];

        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        stringLen = pString->StringLength();

        INET_ASSERT(stringLen > dwHeaderNameLength);

        //
        // get a pointer to the value string
        //

        value = pString->StringAddress(lpBase) + dwHeaderNameLength;
        stringLen -= dwHeaderNameLength;

        //
        // the input string could be a substring of a different header
        //

        //INET_ASSERT(*value != ':');

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        do {
            ++value;
            --stringLen;
        } while ((stringLen > 0) && (*value == ' '));

        //
        // get the data in the format requested by the app
        //

        LPVOID lpData;
        DWORD dwDataSize;
        DWORD dwRequiredSize;
        SYSTEMTIME systemTime;
        DWORD number;

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME) {

            char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

            if (stringLen < sizeof(buf)) {

                //
                // value probably does not point at a zero-terminated string
                // which HttpDateToSystemTime() expects, so we make a copy
                // and terminate it
                //

                memcpy((LPVOID)buf, (LPVOID)value, stringLen);
                buf[stringLen] = '\0';
                if (HttpDateToSystemTime(buf, &systemTime)) {
                    lpData = (LPVOID)&systemTime;
                    dwRequiredSize = dwDataSize = sizeof(systemTime);
                } else {

                    //
                    // couldn't convert date/time. Presume header must be bogus
                    //

                    error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                    DEBUG_PRINT(HTTP,
                                ERROR,
                                ("cannot convert %.40q to SYSTEMTIME\n",
                                value
                                ));

                }
            } else {

                //
                // we would break the date/time buffer!
                //

                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        } else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
            if (isdigit(*value)) {
                number = 0;
                for (int i = 0;
                    (stringLen > 0) && isdigit(value[i]);
                    ++i, --stringLen) {

                    number = number * 10 + (DWORD)(value[i] - '0');
                }
                lpData = (LPVOID)&number;
                dwRequiredSize = dwDataSize = sizeof(number);
            } else {

                //
                // not a numeric field. Request must be bogus for this header
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.20q to NUMBER\n",
                            value
                            ));

            }
        } else {
            lpData = (LPVOID)value;
            dwDataSize = stringLen;
            dwRequiredSize = dwDataSize + 1;
        }

        //
        // if error == ERROR_SUCCESS then we can attempt to copy the data
        //

        if (error == ERROR_SUCCESS) {
            if (*lpdwBufferLength < dwRequiredSize) {
                *lpdwBufferLength = dwRequiredSize;
                error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                memcpy(lpBuffer, lpData, dwDataSize);
                *lpdwBufferLength = dwDataSize;

                //
                // if dwRequiredSize > dwDataSize, then this is a variable-
                // length item (i.e. a STRING!) so we add a terminating '\0'
                //

                if (dwRequiredSize > dwDataSize) {

                    INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                    ((LPSTR)lpBuffer)[dwDataSize] = '\0';
                }

                //
                // successfully retrieved the requested header - bump the
                // index
                //

                ++*lpdwIndex;
            }
        }
    }

    UnlockHeaders();

    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::FindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    IN DWORD dwModifiers,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )
/*++

Routine Description:

    Finds a request or response header, based on index to the header name we are searching for.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    dwQueryIndex        - a index into a array of known HTTP headers, see wininet.h HTTP_QUERY_* codes

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/
{

    DWORD error;
    LPSTR lpData;
    DWORD dwDataSize = 0;
    DWORD dwRequiredSize;
    SYSTEMTIME systemTime;
    DWORD number;

    error = FastFindHeader(
                lpBase,
                dwQueryIndex,
                (LPVOID *)&lpData,
                &dwDataSize,
                *lpdwIndex
                );

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    //
    // get the data in the format requested by the app
    //

    if (dwModifiers & HTTP_QUERY_FLAG_SYSTEMTIME)
    {
        char buf[DATE_AND_TIME_STRING_BUFFER_LENGTH];

        if (dwDataSize < sizeof(buf))
        {

            //
            // value probably does not point at a zero-terminated string
            // which HttpDateToSystemTime() expects, so we make a copy
            // and terminate it
            //

            memcpy((LPVOID)buf, (LPVOID)lpData, dwDataSize);
            buf[dwDataSize] = '\0';
            if (HttpDateToSystemTime(buf, &systemTime)) {
                lpData = (LPSTR)&systemTime;
                dwRequiredSize = dwDataSize = sizeof(systemTime);
            } else {

                //
                // couldn't convert date/time. Presume header must be bogus
                //

                error = ERROR_HTTP_INVALID_QUERY_REQUEST;

                DEBUG_PRINT(HTTP,
                            ERROR,
                            ("cannot convert %.40q to SYSTEMTIME\n",
                            lpData
                            ));

            }
        }
        else
        {

            //
            // we would break the date/time buffer!
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    }
    else if (dwModifiers & HTTP_QUERY_FLAG_NUMBER)
    {
        if (isdigit(*lpData)) {
            number = 0;
            for (int i = 0;
                (dwDataSize > 0) && isdigit(lpData[i]);
                ++i, --dwDataSize) {

                number = number * 10 + (DWORD)(lpData[i] - '0');
            }
            lpData = (LPSTR)&number;
            dwRequiredSize = dwDataSize = sizeof(number);
        } else {

            //
            // not a numeric field. Request must be bogus for this header
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("cannot convert %.20q to NUMBER\n",
                        lpData
                        ));

        }
    }
    else
    {
        dwRequiredSize = dwDataSize + 1;
    }

    //
    // if error == ERROR_SUCCESS then we can attempt to copy the data
    //

    if (error == ERROR_SUCCESS)
    {
        if (*lpdwBufferLength < dwRequiredSize)
        {
            *lpdwBufferLength = dwRequiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            memcpy(lpBuffer, lpData, dwDataSize);
            *lpdwBufferLength = dwDataSize;

            //
            // if dwRequiredSize > dwDataSize, then this is a variable-
            // length item (i.e. a STRING!) so we add a terminating '\0'
            //

            if (dwRequiredSize > dwDataSize)
            {
                INET_ASSERT(dwRequiredSize - dwDataSize == 1);

                ((LPSTR)lpBuffer)[dwDataSize] = '\0';
            }

            //
            // successfully retrieved the requested header - bump the
            // index
            //

            ++*lpdwIndex;
        }
    }
quit:

    return error;
}



DWORD
HTTP_HEADERS::FastFindHeader(
    IN LPSTR lpBase,
    IN DWORD dwQueryIndex,
    OUT LPVOID *lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Finds a request or response header slightly quicker than its higher level
     cousin, FindHeader.   Unlike FindHeader this function simply returns
     a pointer and length, and does not copy header data.


    lpBase              - base address of strings

    dwQueryIndex        - a index into a array known HTTP headers, see wininet.h HTTP_QUERY_* codes

    lplpBuffer          - pointer to pointer of the actual header to be returned in.

    lpdwBufferLength    - OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

    dwIndex             - a index of which header we're asking for, as there can be multiple headers
                          under the same name.

Arguments:

    lpBase              - base for offset HEADER_STRINGs

    lpszHeaderName      - pointer to header name

    dwHeaderNameLength  - length of header name

    dwModifiers         - flags which modify returned value

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of results, or required length of lpBuffer

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    *lpdwBufferLength contains the amount required

                  ERROR_HTTP_HEADER_NOT_FOUND
                    The specified header (or index of header) was not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_HEADERS::FastFindHeader",
                 "%q, %#x, %#x [%#x], %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwIndex
                 ));

    PERF_ENTER(FindHeader);

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    HEADER_STRING * curHeader;
    DWORD dwSlot;

    dwSlot = FastFind(dwQueryIndex, dwIndex);

    if ( dwSlot != INVALID_HEADER_SLOT)
    {
        //
        // found the header - get to the value
        //

        DWORD stringLen;
        LPSTR value;

        curHeader = GetSlot(dwSlot);

        //
        // get a pointer to the value string
        //

        value     = curHeader->StringAddress(lpBase) + (GlobalKnownHeaders[dwQueryIndex].Length+1);
        stringLen = curHeader->StringLength() - (GlobalKnownHeaders[dwQueryIndex].Length+1);

        //
        // find the first non-space character in the value.
        //
        // N.B.: Servers can return empty headers, so we may end up with a
        // zero length string
        //

        while ((stringLen > 0) && (*value == ' '))
        {
            ++value;
            --stringLen;
        }

        //
        // get the data in the format requested by the app
        //

        //
        // error is no longer ERROR_HTTP_HEADER_NOT_FOUND, but it might not
        // really be success either...
        //

        error = ERROR_SUCCESS;

        *lplpBuffer = (LPVOID)value;
        *lpdwBufferLength = stringLen;
    }

    PERF_LEAVE(FindHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_HEADERS::QueryRawHeaders(
    IN LPSTR lpBase,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryRawHeaders);

    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;

    LockHeaders();

    for (DWORD i = 0; i < _TotalSlots; ++i) {
        if (_lpHeaders[i].HaveString()) {

            DWORD length;

            length = _lpHeaders[i].StringLength();

            requiredLength += length + (bCrLfTerminated ? 2 : 1);
            if (*lpdwBufferLength > requiredLength) {
                _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                lpszBuffer += length;
                if (bCrLfTerminated) {
                    *lpszBuffer++ = '\r';
                    *lpszBuffer++ = '\n';
                } else {
                    *lpszBuffer++ = '\0';
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    UnlockHeaders();

    ++requiredLength;

    DWORD error;

    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
        error = ERROR_SUCCESS;
    }
    *lpdwBufferLength = requiredLength;

    PERF_LEAVE(QueryRawHeaders);

    return error;
}


DWORD
HTTP_HEADERS::QueryFilteredRawHeaders(
    IN LPSTR lpBase,
    IN LPSTR *lplpFilterList,
    IN DWORD cListElements,
    IN BOOL  fExclude,
    IN BOOL  fSkipVerb,
    IN BOOL bCrLfTerminated,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns all the request or response headers in a single buffer. The headers
    can be returned as ASCIIZ strings, or CR-LF terminated strings

Arguments:

    lpBase              - base address of strings

    bCrLfTerminated     - TRUE if each string is terminated with CR-LF

    lpBuffer            - pointer to buffer to write headers

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: if successful, length of output buffer, minus 1
                               for any trailing EOS, or if the buffer is not
                               large enough, the size required

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error = ERROR_NOT_SUPPORTED;

    DWORD requiredLength = 0;
    LPSTR lpszBuffer = (LPSTR)lpBuffer;
    BOOL fCopy;

    DWORD i = fSkipVerb ? 1 : 0;
    for (; i < _TotalSlots; ++i) {
       if (_lpHeaders[i].HaveString()) {
          fCopy = TRUE;
          if (lplpFilterList
             && FMatchList(lplpFilterList, cListElements, _lpHeaders+i, lpBase)) {
             fCopy = fExclude?FALSE:TRUE;
          }
          if (fCopy) {
              DWORD length;

              length = _lpHeaders[i].StringLength();
              requiredLength += length + (bCrLfTerminated ? 2 : 1);
              if (*lpdwBufferLength > requiredLength) {
                    _lpHeaders[i].CopyTo(lpBase, lpszBuffer);
                   lpszBuffer += length;
                   if (bCrLfTerminated) {
                       *lpszBuffer++ = '\r';
                       *lpszBuffer++ = '\n';
                    } else {
                       *lpszBuffer++ = '\0';
                   }
                }
            }
        }
    }

    if (bCrLfTerminated)
    {
        requiredLength += 2;
        if (*lpdwBufferLength > requiredLength)
        {
            *lpszBuffer++ = '\r';
            *lpszBuffer++ = '\n';
        }
    }

    ++requiredLength;


    if (*lpdwBufferLength < requiredLength) {
        error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *lpszBuffer = '\0';
        --requiredLength;   // remove 1 for trailing '\0'
        error = ERROR_SUCCESS;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
HTTP_HEADERS::AddRequest(
    IN LPSTR lpszVerb,
    IN LPSTR lpszObject,
    IN LPSTR lpszVersion
    )

/*++

Routine Description:

    Builds the request line from its constituent parts. The request line is the
    first (0th) header in the request headers

    Assumes:    1. This is the one-and-only call to this method
                2. lpszObject must already be escaped if necessary

Arguments:

    lpszVerb    - pointer to HTTP verb, e.g. "GET"

    lpszObject  - pointer to HTTP object name, e.g. "/users/albert/~emc2.htm".

    lpszVersion - pointer to HTTP version string, e.g. "HTTP/1.0"

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    PERF_ENTER(AddRequest);

    //
    // there must not be a header when this method is called
    //

    INET_ASSERT(_HeadersLength == 0);

    DWORD error = ERROR_SUCCESS;
    int verbLen = lstrlen(lpszVerb);
    int objectLen = lstrlen(lpszObject);
    int versionLen = lstrlen(lpszVersion);
    int len = verbLen       // "GET"
            + 1             //     ' '
            + objectLen     //        "/users/albert/~emc2.htm"
            + 1             //                                 ' '
            + versionLen    //                                    "HTTP/1.0"
            + 1             //                                              '\0'
            ;

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(!request.HaveString());

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    request.CreateStringBuffer((LPVOID)lpszVerb, verbLen, len);
    if (request.IsError()) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {
        request += ' ';
        request.Strncat((LPVOID)lpszObject, objectLen);
        request += ' ';
        request.Strncat((LPVOID)lpszVersion, versionLen);

        _HeadersLength = len - 1 + (sizeof("\r\n") - 1);

        //
        // we have used the first free slot in the headers array
        //

        --_FreeSlots;

        //
        // update the component variables in case of a ModifyRequest()
        //

        _lpszVerb = request.StringAddress();
        _dwVerbLength = verbLen;
        _lpszObjectName = _lpszVerb + verbLen + 1;
        _dwObjectNameLength = objectLen;
        _lpszVersion = _lpszObjectName + objectLen + 1;
        _dwVersionLength = versionLen;
        SetRequestVersion();
        error = request.IsError() ? ::GetLastError() : ERROR_SUCCESS;
    }

quit:

    PERF_LEAVE(AddRequest);

    return error;
}


DWORD
HTTP_HEADERS::ModifyRequest(
    IN HTTP_METHOD_TYPE tMethod,
    IN LPSTR lpszObjectName,
    IN DWORD dwObjectNameLength,
    IN LPSTR lpszVersion OPTIONAL,
    IN DWORD dwVersionLength
    )

/*++

Routine Description:

    Updates the request line. Used in redirection

Arguments:

    tMethod             - type of new method

    lpszObjectName      - pointer to new object name

    dwObjectNameLength  - length of new object name

    lpszVersion         - optional pointer to version string

    dwVersionLength     - length of lpszVersion string if present

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ModifyRequest",
                 "%s, %q, %d, %q, %d",
                 MapHttpMethodType(tMethod),
                 lpszObjectName,
                 dwObjectNameLength,
                 lpszVersion,
                 dwVersionLength
                 ));

    PERF_ENTER(ModifyRequest);

    INET_ASSERT(lpszObjectName != NULL);
    INET_ASSERT(dwObjectNameLength != 0);

    //
    // there must already be a header when this method is called
    //

    INET_ASSERT(_HeadersLength != 0);

    //
    // we are about to start updating the headers for the current
    // HTTP_REQUEST_HANDLE_OBJECT. Serialize access
    //

    //
    // BUGBUG [arthurbi] using two HEADER_STRINGs here causes an extra
    //  ReAlloc when use the Copy operator between the two.
    //

    HEADER_STRING * pRequest = GetFirstHeader();
    HEADER_STRING & request = *pRequest;
    HEADER_STRING newRequest;
    LPCSTR lpcszVerb;
    DWORD verbLength;
    DWORD error = ERROR_SUCCESS;
    DWORD length;

    //
    // there must already be a request line
    //

    if (pRequest == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    INET_ASSERT(request.HaveString());

    //
    // get the verb/method to use.
    //

    if (tMethod == HTTP_METHOD_TYPE_UNKNOWN) {

        //
        // the method is unknown, read the old one out of the string
        //  and save off, basically we're reusing the previous one.
        //

        lpcszVerb = request.StringAddress();

        for (DWORD i = 0; i < request.StringLength(); i++) {
            if (lpcszVerb[i] == ' ') {
                break;
            }
        }

        INET_ASSERT((i > 0) && (i < request.StringLength()));

        verbLength = i;
    } else {

        //
        // its one of the normal kind, just map it.
        //

        verbLength = MapHttpMethodType(tMethod, &lpcszVerb);
    }
    if (lpszVersion == NULL) {
        lpszVersion = _lpszVersion;
        dwVersionLength = _dwVersionLength;
    }

    _lpszVerb = NULL;
    _dwVerbLength = 0;
    _lpszObjectName = NULL;
    _dwObjectNameLength = 0;
    _lpszVersion = NULL;
    _dwVersionLength = 0;

    //
    // calculate the new length from the component lengths we originally set
    // in AddRequest(), and the new object name
    //

    length = verbLength + 1 + dwObjectNameLength + 1 + dwVersionLength + 1;

    //
    // create a new request line
    //

    newRequest.CreateStringBuffer((LPVOID)lpcszVerb, verbLength, length);
    if (newRequest.IsError()) {
        error = GetLastError();
    } else {
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszObjectName, dwObjectNameLength);
        newRequest += ' ';
        newRequest.Strncat((LPVOID)lpszVersion, dwVersionLength);

        //
        // remove the current request line length from the header buffer
        // aggregate
        //

        _HeadersLength -= request.StringLength();

        //
        // make the current request line the new one
        //

        request = newRequest.StringAddress();

        //
        // and update the address and length variables (version length is the
        // only thing that stays the same)
        //

        if (!request.IsError()) {
            _lpszVerb = request.StringAddress();
            _dwVerbLength = verbLength;
            _lpszObjectName = _lpszVerb + verbLength + 1;
            _dwObjectNameLength = dwObjectNameLength;
            _lpszVersion = _lpszObjectName + dwObjectNameLength + 1;
            _dwVersionLength = dwVersionLength;
            SetRequestVersion();

        //
        // and the new request line length to the aggregate header length
        //

            _HeadersLength += request.StringLength();
        } else {
            error = GetLastError();
        }
    }

quit:

    PERF_LEAVE(ModifyRequest);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_HEADERS::SetRequestVersion(
    VOID
    )

/*++

Routine Description:

    Set _RequestVersionMajor and _RequestVersionMinor based on the HTTP
    version string

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_HEADERS::SetRequestVersion",
                 NULL
                 ));

    INET_ASSERT(_lpszVersion != NULL);

    _RequestVersionMajor = 0;
    _RequestVersionMinor = 0;
    if (strncmp(_lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR pNum = _lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMajor);
        while (!isdigit(*pNum) && (*pNum != '\0')) {
            ++pNum;
        }
        ExtractInt(&pNum, 0, (LPINT)&_RequestVersionMinor);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("request version = %d.%d\n",
                    _RequestVersionMajor,
                    _RequestVersionMinor
                    ));

    } else {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("\"HTTP/\" not found in %q\n",
                    _lpszVersion
                    ));

    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_HEADERS::QueryRequestVersion(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Get HtttpVersion used in request.
    
Arguments:

    lpBuffer            - pointer to buffer to copy version string into

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: size of version string excluding terminating '\0'
                               if successful, else required buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_HEADERS::QueryRequestVersion",
                 NULL
                 ));

    DWORD error = ERROR_HTTP_HEADER_NOT_FOUND;

    LockHeaders();
    
    if (_lpszVersion != NULL)
    {
        DWORD dwLen = lstrlen(_lpszVersion);

        if (*lpdwBufferLength > dwLen) {
            memcpy(lpBuffer, _lpszVersion, dwLen);
            ((LPSTR)lpBuffer)[dwLen] = '\0';
            *lpdwBufferLength = dwLen;
            error = ERROR_SUCCESS;
        } else {
            *lpdwBufferLength = dwLen + 1;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    UnlockHeaders();

    DEBUG_LEAVE(0);
    return error;
}


LPSTR
HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer(
    OUT LPDWORD lpdwRequestLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN BOOL bExtraCrLf,
    IN DWORD dwMaxPacketLength,
    OUT LPBOOL lpbCombinedData
    )

/*++

Routine Description:

    Creates a request buffer from the HTTP request and headers

Arguments:

    lpdwRequestLength   - pointer to returned buffer length

    lpOptional          - pointer to optional data

    dwOptionalLength    - length of optional data

    bExtraCrLf          - TRUE if we need to add additional CR-LF to buffer

    dwMaxPacketLength   - maximum length of buffer

    lpbCombinedData     - output TRUE if data successfully combined into one

Return Value:

    LPSTR
        Success - pointer to allocated buffer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateRequestBuffer",
                 "%#x, %#x, %d, %B, %d, %#x",
                 lpdwRequestLength,
                 lpOptional,
                 dwOptionalLength,
                 bExtraCrLf,
                 dwMaxPacketLength,
                 lpbCombinedData
                 ));

    PERF_ENTER(CreateRequestBuffer);

    *lpbCombinedData = FALSE;

    _RequestHeaders.LockHeaders();

    DWORD headersLength;
    DWORD requestLength;
    DWORD optionalLength;
    HEADER_STRING * pRequest = _RequestHeaders.GetFirstHeader();
    HEADER_STRING & request = *pRequest;
    LPSTR requestBuffer = NULL;
/*
    WCHAR wszUrl[1024];
    LPWSTR pwszUrl = NULL;
    BYTE utf8Url[2048];
    LPBYTE pbUrl = NULL;
*/
    LPSTR pszObject = _RequestHeaders.ObjectName();
    DWORD dwObjectLength = _RequestHeaders.ObjectNameLength();

    if (pRequest == NULL) {
        goto quit;
    }

    INET_ASSERT(request.HaveString());

    headersLength = _RequestHeaders.HeadersLength();
    requestLength = headersLength + (sizeof("\r\n") - 1);

/*------------------------------------------------------------------
    GlobalEnableUtf8Encoding = FALSE;
    if (GlobalEnableUtf8Encoding
        && StringContainsHighAnsi(pszObject, dwObjectLength)) {

        pwszUrl = wszUrl;

        DWORD arrayElements = ARRAY_ELEMENTS(wszUrl);

        if (dwObjectLength > ARRAY_ELEMENTS(wszUrl)) {
            arrayElements = dwObjectLength;
            pwszUrl = (LPWSTR)ALLOCATE_FIXED_MEMORY(arrayElements * sizeof(*pwszUrl));
            if (pwszUrl == NULL) {
                goto utf8_cleanup;
            }
        }



        PFNINETMULTIBYTETOUNICODE pfnMBToUnicode;
        pfnMBToUnicode = GetInetMultiByteToUnicode( );
        if (pfnMBToUnicode == NULL) {
            goto utf8_cleanup;
        }

        HRESULT hr;
        DWORD dwMode;
        INT nMBChars;
        INT nWChars;

        nMBChars = dwObjectLength;
        nWChars = arrayElements;
        dwMode = 0;

        hr = pfnMBToUnicode(&dwMode,
                                GetCodePage(),
                                pszObject,
                                &nMBChars,
                                pwszUrl,
                                &nWChars
                               );
        if (hr != S_OK || nWChars == 0) {
            goto utf8_cleanup;
        }

        DWORD nBytes;

        nBytes = CountUnicodeToUtf8(pwszUrl, (DWORD)nWChars, TRUE);
        pbUrl = utf8Url;
        if (nBytes > ARRAY_ELEMENTS(utf8Url)) {
            pbUrl = (LPBYTE)ALLOCATE_FIXED_MEMORY(nBytes);
            if (pbUrl == NULL) {
                goto utf8_cleanup;
            }
        }

        DWORD error;

        error = ConvertUnicodeToUtf8(pwszUrl,
                                     (DWORD)nWChars,
                                     pbUrl,
                                     nBytes,
                                     TRUE
                                     );

        INET_ASSERT(error == ERROR_SUCCESS);

        if (error != ERROR_SUCCESS) {
            goto utf8_cleanup;
        }

        requestLength = requestLength - dwObjectLength + nBytes;
        headersLength = headersLength - dwObjectLength + nBytes;
        pszObject = (LPSTR)pbUrl;
        dwObjectLength = nBytes;
        goto after_utf8;

utf8_cleanup:

        if ((pwszUrl != wszUrl) && (pwszUrl != NULL)) {
            FREE_MEMORY(pwszUrl);
        }
        pwszUrl = NULL;
        if ((pbUrl != utf8Url) && (pbUrl != NULL)) {
            FREE_MEMORY(pbUrl);
        }
        pbUrl = NULL;
        pszObject = NULL;
        dwObjectLength = 0;
    }

after_utf8:
------------------------------------------------------------------*/

    optionalLength = (DWORD)(dwOptionalLength + (bExtraCrLf ? (sizeof("\r\n") - 1) : 0));
    if (requestLength + optionalLength <= dwMaxPacketLength) {
        requestLength += optionalLength;
    } else {
        optionalLength = 0;
        bExtraCrLf = FALSE;
    }

    requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    if (requestBuffer != NULL) {
        if (optionalLength != 0) {
            *lpbCombinedData = TRUE;
        }
    } else if (optionalLength != 0) {
        requestLength = headersLength + (sizeof("\r\n") - 1);
        optionalLength = 0;
        bExtraCrLf = FALSE;
        requestBuffer = (LPSTR)ResizeBuffer(NULL, requestLength, FALSE);
    }
    if (requestBuffer != NULL) {

        LPSTR buffer = requestBuffer;

        //
        // copy the headers. Remember: header 0 is the request
        //

//#ifdef COMPRESSED_HEADERS
//        if (vfCompressedHeaders) {
//            DEBUG_PRINT(HTTP,
//                        INFO,
//                        ("Compressing Headers")
//                        );
//            _RequestHeaders.CopyCompressedHeaders(&buffer);
//
//        }
//        else
//#endif //COMPRESSED_HEADERS
        {
            _RequestHeaders.CopyHeaders(&buffer, pszObject, dwObjectLength);
        }

        //
        // terminate the request
        //

        *buffer++ = '\r';
        *buffer++ = '\n';

//#ifdef COMPRESSED_HEADERS
//        if (vfCompressedHeaders) {
//
//            *lpdwRequestLength = ((DWORD)buffer - (DWORD)requestBuffer);
//
//            DEBUG_PRINT(HTTP,
//                        INFO,
//                        ("Compressed Headers: Old Length=%d, New Length = %d, Saved=%d\n",
//                        requestLength,
//                        *lpdwRequestLength,
//                        requestLength - *lpdwRequestLength
//                        )
//                        );
//        } else {
//#endif //COMPRESSED_HEADERS

        if (optionalLength != 0) {
            if (dwOptionalLength != 0) {
                memcpy(buffer, lpOptional, dwOptionalLength);
                buffer += dwOptionalLength;
            }
            if (bExtraCrLf) {
                *buffer++ = '\r';
                *buffer++ = '\n';
            }
        }

        INET_ASSERT((SIZE_T)(buffer-requestBuffer) == requestLength);

        *lpdwRequestLength = requestLength;

//#ifdef COMPRESSED_HEADERS
//        }
//#endif
    }

quit:

    _RequestHeaders.UnlockHeaders();

    DEBUG_PRINT(HTTP,
                INFO,
                ("request length = %d, combined = %B\n",
                *lpdwRequestLength,
                *lpbCombinedData
                ));

/*
    if ((pbUrl != NULL) && (pbUrl != utf8Url)) {
        FREE_MEMORY(pbUrl);
    }
    if ((pwszUrl != NULL) && (pwszUrl != wszUrl)) {
        FREE_MEMORY(pwszUrl);
    }
*/

    PERF_LEAVE(CreateRequestBuffer);

    DEBUG_LEAVE(requestBuffer);

    return requestBuffer;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN LPSTR lpszHeaderName,
    IN DWORD dwHeaderNameLength,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results

                  ERROR_INTERNET_INCORRECT_FORMAT
                    Can't convert the data to the requested format

                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%#x [%.*q], %d, %#x, %#x [%#x], %#x, %#x [%d]",
                 lpszHeaderName,
                 min(dwHeaderNameLength + 1, 80),
                 lpszHeaderName,
                 dwHeaderNameLength,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       lpszHeaderName,
                                       dwHeaderNameLength,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeader(
    IN DWORD dwQueryIndex,
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Searches for an arbitrary request header and if found, returns its value

Arguments:

    lpszHeaderName      - pointer to the name of the header to find

    dwHeaderNameLength  - length of the header

    lpBuffer            - pointer to buffer for results

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: length of the returned header value, or required
                               length of lpBuffer

    dwModifiers         - how to return the data: as number, as SYSTEMTIME
                          structure, etc.

    lpdwIndex           - IN: 0-based index of header to find
                          OUT: next header index if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    lpBuffer not large enough for results

                  ERROR_INTERNET_INCORRECT_FORMAT
                    Can't convert the data to the requested format

                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRequestHeader",
                 "%u, %#x [%#x], %#x, %#x [%d]",
                 dwQueryIndex,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 dwModifiers,
                 lpdwIndex,
                 *lpdwIndex
                 ));

    PERF_ENTER(QueryRequestHeader);

    DWORD error;

    error = _RequestHeaders.FindHeader(NULL,
                                       dwQueryIndex,
                                       dwModifiers,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       lpdwIndex
                                       );

    PERF_LEAVE(QueryRequestHeader);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::AddInternalResponseHeader(
    IN DWORD dwHeaderIndex,
    IN LPSTR lpszHeader,
    IN DWORD dwHeaderLength
    )

/*++

Routine Description:

    Adds a created response header to the response header array. Unlike normal
    response headers, this will be a pointer to an actual string, not an offset
    into the response buffer.

    Even if the address of the response buffer changes, created response headers
    will remain fixed

    N.B. The header MUST NOT have a CR-LF terminator
    N.B.-2 This function must be called under the header lock.

Arguments:

    dwHeaderIndex   - index into header value we are actually creating

    lpszHeader      - pointer to created (internal) header to add

    dwHeaderLength  - length of response header, or -1 if ASCIIZ

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AddInternalResponseHeader",
                 "%u [%q], %q, %d",
                 dwHeaderIndex,
                 GlobalKnownHeaders[dwHeaderIndex].Text,
                 lpszHeader,
                 dwHeaderLength
                 ));

    DWORD error;

    if (dwHeaderLength == (DWORD)-1) {
        dwHeaderLength = lstrlen(lpszHeader);
    }

    INET_ASSERT((lpszHeader[dwHeaderLength - 1] != '\r')
                && (lpszHeader[dwHeaderLength - 1] != '\n'));

    //
    // find the next slot for this header
    //

    HEADER_STRING * freeHeader;

    //
    // if we already have all the headers (the 'empty' header is the last one
    // in the array) then change the last header to be the one we are adding
    // and add a new empty header, else just add this one
    //

    DWORD iSlot;
    freeHeader = _ResponseHeaders.FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        error = _ResponseHeaders.GetError();

        INET_ASSERT(error != ERROR_SUCCESS);

    } else {

        HEADER_STRING * lastHeader;

        lastHeader = _ResponseHeaders.GetEmptyHeader();
        if (lastHeader != NULL) {

            //
            // make copy of last header - its an offset string
            //

            *freeHeader = *lastHeader;

            //
            // use what was last header as free header
            //

            freeHeader = lastHeader;
        }
        freeHeader->MakeCopy(lpszHeader, dwHeaderLength);
        freeHeader->SetNextKnownIndex(_ResponseHeaders.FastAdd(dwHeaderIndex, iSlot));
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders(
    IN OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Given the next chunk of the response, updates the response headers. The
    buffer pointer, buffer length and number of bytes received values are all
    maintained in this object (_ResponseBuffer, _ResponseBufferLength and
    _BytesReceived, resp.)

Arguments:

    lpbEof  - IN: TRUE if we have reached the end of the response
              OUT: TRUE if we have reached the end of the response or the end
                   of the headers

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateResponseHeaders",
                 "%#x [%.*q], %d, %d, %#x [%B]",
                 _ResponseBuffer + _ResponseScanned,
                 min(_ResponseBufferLength + 1, 80),
                 _ResponseBuffer + _ResponseScanned,
                 _ResponseBufferLength,
                 _BytesReceived,
                 lpbEof,
                 *lpbEof
                 ));

    PERF_ENTER(UpdateResponseHeaders);

    LPSTR lpszBuffer = (LPSTR)_ResponseBuffer + _ResponseScanned;
    DWORD dwBytesReceived = _BytesReceived - _ResponseScanned;
    DWORD error = ERROR_SUCCESS;
    BOOL  success = TRUE;
    HEADER_STRING * statusLine;

    //
    // if input EOF is set then the caller is telling us that the end of the
    // response has been reached at transport level (the server closed the
    // connectiion)
    //

    if (*lpbEof) {
        SetEof(TRUE);
    }

    //
    // lock down the response headers for the duration of this request. The only
    // way another thread is going to wait on this lock is if the reference on
    // the HTTP request object goes to zero, which *shouldn't* happen
    //

    _ResponseHeaders.LockHeaders();

    //
    // if input EOF is set then the caller is telling us that the end of the
    // response has been reached at transport level (the server closed the
    // connectiion)
    //

    if (*lpbEof) {
        SetEof(TRUE);
    }

    //
    // if we don't yet know whether we have a HTTP/1.0 (or greater) or HTTP/0.9
    // response yet, then try to find out.
    //
    // Only responses greater than HTTP/0.9 start with the "HTTP/#.#" string
    //

    if (!IsDownLevel() && !IsUpLevel()) {

#define MAKE_VERSION_ENTRY(string)  string, sizeof(string) - 1

        static struct {
            LPSTR Version;
            DWORD Length;
        } KnownVersionsStrings[] = {
            MAKE_VERSION_ENTRY("HTTP/"),
            MAKE_VERSION_ENTRY("S-HTTP/"),
            MAKE_VERSION_ENTRY("SHTTP/"),
            MAKE_VERSION_ENTRY("Secure-HTTP/"),

            //
            // allow for servers generating slightly off-the-wall responses
            //

            MAKE_VERSION_ENTRY("HTTP /")
        };

#define NUM_HTTP_VERSIONS   ARRAY_ELEMENTS(KnownVersionsStrings)

        //
        // We know this is the start of a HTTP response, but there may be some
        // noise at the start from bad HTML authoring, or bad content-length on
        // the previous response on a keep-alive connection. We will try to sync
        // up to the HTTP header (we will only look for this - I have never seen
        // any of the others, and I doubt its worth the increased complexity and
        // processing time)
        //

        //
        //  Due to possible DoS attacks outlined in RAID item 510295 we are to
        //be more stringent as to what sort of 'noise' is allowed before the start
        //of an HTTP response.  We now allow the noise to consist of at most
        //8 characters of whitespace or '\0'.  If the content-length is slightly
        //off because of a sloppy server, this should skip whatever terminators
        //the server expected us to use.
        //

        const DWORD c_dwSmallestAcceptableStatusLength = ARRAY_ELEMENTS("HTTP/1.1 100\r\n") - 1;
        const DWORD c_dwMaxNoiseAllowed = 8;
        const DWORD c_dwMaxPreHTTPLength = ARRAY_ELEMENTS("Secure-HTTP/")-1;

        LPSTR lpszBuf;
        DWORD bytesLeft;

        lpszBuf = lpszBuffer;
        bytesLeft = dwBytesReceived;

        //
        //  Check that we've read enough bytes for a status line to be ready.
        //
        if ((dwBytesReceived < c_dwSmallestAcceptableStatusLength) && !IsEof())
        {
            goto done;
        }

        //
        //  Allow up to c_dwMaxNoiseAllowed bytes worth of noise
        //
        int noiseBytesLeft = min(bytesLeft, c_dwMaxNoiseAllowed);
        int noiseBytesScanned = 0;
        while ((noiseBytesLeft > 0) 
               && (isspace((unsigned char)*lpszBuf)
                   || *lpszBuffer == '\0'))
        {
            ++lpszBuf;
            --bytesLeft;
            --noiseBytesLeft;
            ++noiseBytesScanned;
        }

        //
        // scan for the known version strings
        //

        for (int i = 0; i < NUM_HTTP_VERSIONS; ++i) {

            LPSTR version = KnownVersionsStrings[i].Version;
            DWORD length = KnownVersionsStrings[i].Length;

            if ((bytesLeft >= length)

            //
            // try the most common case as a direct comparison. memcmp()
            // should expand to cmpsd && cmpsb on x86 (most common platform
            // and one on which we are most interested in improving perf)
            //

            && (((i == 0)
                && (memcmp(lpszBuf, "HTTP/", sizeof("HTTP/") - 1) == 0))
                //&& (lpszBuf[0] == 'H')
                //&& (lpszBuf[1] == 'T')
                //&& (lpszBuf[2] == 'T')
                //&& (lpszBuf[3] == 'P')
                //&& (lpszBuf[4] == '/'))

                //
                //  "Clients should be tolerant in parsing the Status-Line"
                //  quote from HTTP/1.1 spec, therefore we perform a
                //  case-insensitive string comparison here
                //

                || (_strnicmp(lpszBuf, version, length) == 0))) {

                //
                // it starts with one of the recognized protocol version strings.
                // We assume its not a down-level server, although it could be,
                // sending back a plain text document that has e.g. "HTTP/1.0..."
                // at its start
                //
                // According to the HTTP "spec", though, it is mentioned that 0.9
                // servers typically only return HTML, hence we shouldn't see
                // even a 0.9 response start with non-HTML data
                //

                SetUpLevel(TRUE);
                _ResponseScanned += noiseBytesScanned;

                //
                // we have start of this response
                //

                lpszBuffer = lpszBuf;
                break;
            }
        }

        if (!IsUpLevel())
        {
            //
            // if we didn't find the start of a valid HTTP response and we have
            // not filled the response buffer sufficiently then allow
            // re-entry to retry.
            //
            // if we didn't find the start of a valid HTTP response and we
            //have filled the buffer sufficiently to expect the response,
            //report the response as invalid.
            //

            if ((bytesLeft < c_dwMaxPreHTTPLength ) && !IsEof())
            {
                goto done;
            }
            else
            {
                //
                // this may be a real down-level server, or it may be the response
                // from an FTP or gopher server via a proxy, in which case there
                // will be no headers. We will add some default headers to make
                // life easier for higher level software
                //

                AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                          "HTTP/1.0 200 OK",
                                          sizeof("HTTP/1.0 200 OK") - 1
                                          );
                _StatusCode = HTTP_STATUS_OK;
                //SetDownLevel(TRUE);

                //
                // we're now ready for the app to start reading data out
                //

                SetData(TRUE);

                //
                // down-level server: we're done
                //

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Server is down-level\n"
                            ));

                goto done;
            }
        }
    }

    //
    //  WinHTTP only accepts IsUpLevel() type responses.
    //

    INET_ASSERT(IsUpLevel());

    //
    // Note: at this point we can't store pointers into the response buffer
    // because it might move during a subsequent reallocation. We have to
    // maintain offsets into the buffer and convert to pointers when we come to
    // read the data out of the buffer (when the response is complete, or at
    // least we've finished receiving headers)
    //

    //
    // if we haven't checked the response yet, then the first thing to
    // get is the status line
    //

    statusLine = GetStatusLine();

    if (statusLine == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (!statusLine->HaveString())
    {
        BOOL fNeedMoreBuffer;
        int majorVersion = 0;
        int minorVersion = 0;
        BOOL fSupportsHttp1_1;

        _StatusCode = 0;

        //
        // Parse the status line.  It has already been checked up to the first '/'
        //

        error = _ResponseHeaders.ParseStatusLine(
            (LPSTR)_ResponseBuffer,
            _BytesReceived,
            IsEof(),
            &_ResponseScanned,
            &fNeedMoreBuffer,
            &_StatusCode,
            (LPDWORD)&majorVersion,
            (LPDWORD)&minorVersion
            );

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        if (fNeedMoreBuffer)
        {
            error = ERROR_SUCCESS;
            goto quit;
        }


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Version = %d.%d\n",
                    majorVersion,
                    minorVersion
                    ));

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_StatusCode = %d\n",
                    _StatusCode
                    ));

        fSupportsHttp1_1 = FALSE;

        if ( majorVersion > 1 )
        {
            //
            // for higher version servers, the 1.1 spec dictates
            //  that we return the highest version the client
            //  supports, and in our case that is 1.1.
            //

            fSupportsHttp1_1 = TRUE;
        }
        else if (majorVersion == 1
                 && minorVersion >= 1)
        {
            fSupportsHttp1_1 = TRUE;
        }

        SetResponseHttp1_1(fSupportsHttp1_1);

        //
        // record the server HTTP version in the server info object
        //

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo != NULL)
        {
            if (fSupportsHttp1_1)
            {
                pServerInfo->SetHttp1_1();

                //
                // Set the max connections per HTTP 1.1 server.
                //
                pServerInfo->SetNewLimit(GlobalMaxConnectionsPerServer);
            } else {
                pServerInfo->SetHttp1_0();

                //
                // up the connection limit from HTTP 1.1 (default 2) to
                // HTTP 1.0 (default 4)
                //

                pServerInfo->SetNewLimit(GlobalMaxConnectionsPer1_0Server);
            }
        }
    }

    //
    // continue scanning headers here until we have tested all the current
    // buffer, or we have found the start of the data
    //

    BOOL fFoundEndOfHeaders;

    error = _ResponseHeaders.ParseHeaders(
                (LPSTR)_ResponseBuffer,
                _BytesReceived,
                IsEof(),
                &_ResponseScanned,
                &success,
                &fFoundEndOfHeaders
                );

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }


    if ( fFoundEndOfHeaders )
    {
        //
        // we found the end of the headers
        //

        SetEof(TRUE);

        //
        // and the start of the data
        //

        SetData(TRUE);
        _DataOffset = _ResponseScanned;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of headers. _DataOffset = %d\n",
                    _DataOffset
                    ));

    }

done:

    //
    // if we have reached the end of the headers then we communicate this fact
    // to the caller
    //

    if (IsData() || IsEof()) {
        CheckWellKnownHeaders();
        if (ERROR_SUCCESS != error)
        {
            goto quit;
        }
        *lpbEof = TRUE;

        /*

        Set connection persistency based on these rules:

        persistent = (1.0Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.1Request && Con: K-A && 1.0Response && Con: K-A)
                     || (1.0Request && Con: K-A && 1.1Response && Con: K-A)
                     || (1.1Request && !Con: Close && 1.1Response && !Con: Close)

        therefore,

        persistent = 1.1Request && 1.1Response
                        ? (!Con: Close in request || response)
                        : Con: K-A in request && response

        */

        if (IsRequestHttp1_1() && IsResponseHttp1_1()) {

            BOOL bHaveConnCloseRequest;

            bHaveConnCloseRequest = FindConnCloseRequestHeader(
                                        IsRequestUsingProxy()
                                            ? HTTP_QUERY_PROXY_CONNECTION
                                            : HTTP_QUERY_CONNECTION
                                            );
            if (!(IsConnCloseResponse() || bHaveConnCloseRequest)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 persistent connection\n"
                            ));

                SetKeepAlive(TRUE);
                SetPersistentConnection(IsRequestUsingProxy()
                                        && !IsTalkingToSecureServerViaProxy()
                                        );
            } else {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("HTTP/1.1 non-persistent connection: close on: request: %B; response: %B\n",
                            bHaveConnCloseRequest,
                            IsConnCloseResponse()
                            ));

                SetKeepAlive(FALSE);
                SetNoLongerKeepAlive();
                ClearPersistentConnection();
            }
        }
    }

    error = ERROR_SUCCESS;

quit:

    //
    // we are finished updating the response headers (no other thread should be
    // waiting for this if the reference count and object state is correct)
    //

    _ResponseHeaders.UnlockHeaders();

    PERF_LEAVE(UpdateResponseHeaders);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders(
    IN OUT LPSTR* ppszBuffer,
    IN DWORD      dwBufferLength
    )

/*++

Routine Description:

    Create the response headers given a buffer containing concatenated headers.
    Called when we are creating this object from the cache

Arguments:

    lpszBuffer      - pointer to buffer containing headers

    dwBufferLength  - length of lpszBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create headers

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CreateResponseHeaders",
                 "%.32q, %d",
                 ppszBuffer,
                 dwBufferLength
                 ));

    //
    // there SHOULD NOT already be a response buffer if we're adding an
    // external buffer
    //

    INET_ASSERT(_ResponseBuffer == NULL);

    DWORD error;
    BOOL eof = FALSE;

    _ResponseBuffer = (LPBYTE) *ppszBuffer;
    _ResponseBufferLength = dwBufferLength;
    _BytesReceived = dwBufferLength;
    error = UpdateResponseHeaders(&eof);
    if (error != ERROR_SUCCESS) {

        //
        // if we failed, we will clean up our variables including clearing
        // out the response buffer address and length, but leave freeing
        // the buffer to the caller
        //

        _ResponseBuffer = NULL;
        _ResponseBufferLength = 0;
        ResetResponseVariables();

    } else {

        //
        // Success - the object owns the buffer so the caller should not free.
        //

        *ppszBuffer = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryResponseVersion(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the HTTP version string from the status line

Arguments:

    lpBuffer            - pointer to buffer to copy version string into

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: size of version string excluding terminating '\0'
                               if successful, else required buffer length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryResponseVersion);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR string;
    DWORD length;

    //
    // get a pointer into the response buffer where the status line starts
    // and its length
    //

    string = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    length = (DWORD)statusLine->StringLength();

    //
    // the version string is the first token on the line, delimited by spaces
    //

    DWORD index;

    for (index = 0; index < length; ++index) {

        //
        // we'll also check for CR and LF, although just space should be
        // sufficient
        //

        if ((string[index] == ' ')
        || (string[index] == '\r')
        || (string[index] == '\n')) {
            break;
        }
    }
    if (*lpdwBufferLength > index) {
        memcpy(lpBuffer, (LPVOID)string, index);
        ((LPSTR)lpBuffer)[index] = '\0';
        *lpdwBufferLength = index;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = index + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryResponseVersion);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusCode(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwModifiers
    )

/*++

Routine Description:

    Returns the status code as a string or a number

Arguments:

    lpBuffer            - pointer to buffer where results written

    lpdwBufferLength    - IN: length of buffer
                          OUT: size of returned information, or required size'
                               of buffer

    dwModifiers         - flags which modify returned value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusCode);

    DWORD error;
    DWORD requiredSize;

    if (dwModifiers & HTTP_QUERY_FLAG_NUMBER) {
        requiredSize = sizeof(_StatusCode);
        if (*lpdwBufferLength >= requiredSize) {
            *(LPDWORD)lpBuffer = _StatusCode;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        //
        // the number should always be only 3 characters long, but we'll be
        // flexible (just in case)
        //

        char numBuf[sizeof("4294967296")];

        requiredSize = wsprintf(numBuf, "%u", _StatusCode) + 1;

#ifdef DEBUG
        // Debug check to make sure everything is good because the above
        // used to be ultoa.
        char debugBuf[sizeof("4294967296")];
        ultoa(_StatusCode, debugBuf, 10);
        if (strcmp(debugBuf,numBuf))
        {
            INET_ASSERT(FALSE);
        }

        INET_ASSERT(requiredSize == lstrlen(numBuf) + 1);
#endif

        if (*lpdwBufferLength >= requiredSize) {
            memcpy(lpBuffer, (LPVOID)numBuf, requiredSize);
            *lpdwBufferLength = requiredSize - 1;
            error = ERROR_SUCCESS;
        } else {
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    PERF_LEAVE(QueryStatusCode);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryStatusText(
    IN LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the status text - if any - returned by the server in the status line

Arguments:

    lpBuffer            - pointer to buffer where status text is written

    lpdwBufferLength    - IN: size of lpBuffer
                          OUT: length of the status text string minus 1 for the
                               '\0', or the required buffer length if we return
                               ERROR_INSUFFICIENT_BUFFER

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    PERF_ENTER(QueryStatusText);

    DWORD error;

    HEADER_STRING * statusLine = GetStatusLine();

    if ((statusLine == NULL) || statusLine->IsError()) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    LPSTR str;
    DWORD len;

    //
    // find the third token on the status line. The status line has the form
    //
    //  "HTTP/1.0 302 Try again\r\n"
    //
    //   ^        ^   ^
    //   |        |   |
    //   |        |   +- status text
    //   |        +- status code
    //   +- version
    //

    str = statusLine->StringAddress((LPSTR)_ResponseBuffer);
    len = statusLine->StringLength();

    DWORD i;

    i = 0;

    int j;

    for (j = 0; j < 2; ++j) {
        while ((i < len) && (str[i] != ' ')) {
            ++i;
        }
        while ((i < len) && (str[i] == ' ')) {
            ++i;
        }
    }
    len -= i;
    if (*lpdwBufferLength > len) {
        memcpy(lpBuffer, (LPVOID)&str[i], len);
        ((LPSTR)lpBuffer)[len] = '\0';
        *lpdwBufferLength = len;
        error = ERROR_SUCCESS;
    } else {
        *lpdwBufferLength = len + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:

    PERF_LEAVE(QueryStatusText);

    return error;
}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRawResponseHeaders(
    IN BOOL bCrLfTerminated,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the raw response headers

Arguments:

    bCrLfTerminated     - TRUE if we want RAW_HEADERS_CRLF else RAW_HEADERS

    lpBuffer            - pointer to buffer where headers returned

    lpdwBufferLength    - IN: length of lpBuffer
                          OUT: returned length of lpBuffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryRawHeaders",
                 "%B, %#x, %#x [%d]",
                 bCrLfTerminated,
                 lpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength
                 ));

    PERF_ENTER(QueryRawHeaders);

    DWORD error = _ResponseHeaders.QueryRawHeaders(
                    (LPSTR)_ResponseBuffer,
                    bCrLfTerminated,
                    lpBuffer,
                    lpdwBufferLength
                    );

    IF_DEBUG_CODE() {
        if (error == ERROR_INSUFFICIENT_BUFFER) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        }
    }

    PERF_LEAVE(QueryRawHeaders);

    DEBUG_LEAVE(error);

    return error;

}


VOID
HTTP_REQUEST_HANDLE_OBJECT::RemoveAllRequestHeadersByName(
    IN DWORD dwQueryIndex
    )

/*++

Routine Description:

    Removes all headers of a particular type from the request object

Arguments:

    lpszHeaderName  - name of header to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "RemoveAllRequestHeadersByName",
                 "%q, %u",
                 GlobalKnownHeaders[dwQueryIndex].Text,
                 dwQueryIndex
                 ));

    PERF_ENTER(RemoveAllRequestHeadersByName);

    _RequestHeaders.RemoveAllByIndex(dwQueryIndex);

    PERF_LEAVE(RemoveAllRequestHeadersByName);

    DEBUG_LEAVE(0);
}

//
// private methods
//


PRIVATE
VOID
HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders(
    VOID
    )

/*++

Routine Description:

    Tests for a couple of well-known headers that are important to us as well as
    the app:

        "Connection: Keep-Alive"
        "Proxy-Connection: Keep-Alive"
        "Connection: Close"
        "Proxy-Connection: Close"
        "Transfer-Encoding: chunked"
        "Content-Length: ####"
        "Content-Range: bytes ####-####/####"

    The header DOES NOT contain CR-LF. That is, dwHeaderLength will not include
    any counts for line termination

    We need to know if the server honoured a request for a keep-alive connection
    so that we don't try to receive until we hit the end of the connection. The
    server will keep it open.

    We need to know the content length if we are talking over a persistent (keep
    alive) connection.

    If either header is found, we set the corresponding flag in the HTTP_HEADERS
    object, and in the case of "Content-Length:" we parse out the length.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::CheckWellKnownHeaders",
                 NULL
                 ));

    //
    // check for "Content-Length:" and "Content-Range"
    //

    if ( IsResponseHeaderPresent(HTTP_QUERY_CONTENT_RANGE) )
    {
        _iSlotContentRange = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONTENT_RANGE];
    }

    if ( IsResponseHeaderPresent(HTTP_QUERY_CONTENT_LENGTH) )
    {
        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;

        _iSlotContentLength = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONTENT_LENGTH];
        curHeader = _ResponseHeaders.GetSlot(_iSlotContentLength);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            --dwHeaderLength;
            ++lpszHeader;
        }
        while (dwHeaderLength && isdigit(*lpszHeader)) {
            _ContentLength = _ContentLength * 10 + (*lpszHeader - '0');
            --dwHeaderLength;
            ++lpszHeader;
        }

        //
        // once we have _ContentLength, we don't modify it (unless
        // we fix it up when using a 206 partial response to resume
        // a partial download.)  The header value should be returned
        // by HttpQueryInfo().  Instead, we keep account of the
        // amount of keep-alive data left to copy in _BytesRemaining
        //

        _BytesRemaining = _ContentLength;

        //
        // although we said we may be one past the end of the header, in
        // reality, if we received a buffer with "Content-Length:" then we
        // expect it to be terminated by CR-LF (or CR-CR-LF or just LF,
        // depending on the wackiness quotient of the server)
        //

        // darrenmi - commenting out because we're hitting it in stress.
        // headers coming from the cache have an extra space in them in
        // some circumstances.  Investigating seperately.
        // 2/25/00

        // INET_ASSERT((*lpszHeader == '\r') || (*lpszHeader == '\n'));


        SetHaveContentLength(TRUE);

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("_ContentLength = %d\n",
                    _ContentLength
                    ));

        _BytesInSocket = (_ContentLength != 0)
                ? (_ContentLength - (_BytesReceived - _DataOffset))
                : 0;

        //
        // we could have multiple responses in the same buffer. If
        // the amount received is greater than the content length
        // then we have all the data; there are no bytes left in
        // the socket for the current response
        //

        if ((int)_BytesInSocket < 0) {
            _BytesInSocket = 0;
        }

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("bytes left in socket = %d\n",
                    _BytesInSocket
                    ));

    }


    if ( IsResponseHeaderPresent(HTTP_QUERY_CONNECTION) ||
         IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION) )
    {
        //
        // check for "Connection: Keep-Alive" or "Proxy-Connection: Keep-Alive".
        // This test protects us against the unlikely
        // event of a server returning to us a keep-alive response header (because
        // that would cause problems for the proxy)
        //

        if (IsWantKeepAlive() && (!IsKeepAlive() || IsResponseHttp1_1()))
        {
            HEADER_STRING * curHeader;
            DWORD dwHeaderLength, headerNameLength;
            LPSTR lpszHeader;


            DWORD iSlot;

            char ch;

            if (IsRequestUsingProxy() &&
                IsResponseHeaderPresent(HTTP_QUERY_PROXY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
            }
            else if (IsResponseHeaderPresent(HTTP_QUERY_CONNECTION))
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Length+1;
            }
            else
            {
                iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_PROXY_CONNECTION];
                headerNameLength = GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Length+1;
                INET_ASSERT(FALSE);
            }

            curHeader      = _ResponseHeaders.GetSlot(iSlot);
            lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
            dwHeaderLength = curHeader->StringLength();

            dwHeaderLength -= headerNameLength;
            lpszHeader     += headerNameLength;

            while (dwHeaderLength && (*lpszHeader == ' ')) {
                ++lpszHeader;
                --dwHeaderLength;
            }

            //
            // both headers use "Keep-Alive" as header-value ONLY for HTTP 1.0 servers
            //

            if (((int)dwHeaderLength >= KEEP_ALIVE_LEN)
            && !strnicmp(lpszHeader, KEEP_ALIVE_SZ, KEEP_ALIVE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Keep-Alive\n"
                            ));

                //
                // BUGBUG - we are setting k-a when coming from cache!
                //

                SetKeepAlive(TRUE);
                SetPersistentConnection(headerNameLength == HTTP_PROXY_CONNECTION_LEN);
            }

            //
            // also check for "Close" as header-value ONLY for HTTP 1.1 servers
            //

            else if ((*lpszHeader == 'C' || *lpszHeader == 'c')
                     && ((int)dwHeaderLength >= CLOSE_LEN)
                     && IsResponseHttp1_1()
                     && !strnicmp(lpszHeader, CLOSE_SZ, CLOSE_LEN)) {

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("Connection: Close (HTTP/1.1)\n"
                            ));

                SetConnCloseResponse(TRUE);
            }
        }
    }

    //
    // check for "Refresh"
    //

    if ( IsResponseHeaderPresent(HTTP_QUERY_REFRESH)
        && !IsRefresh() )
    {

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("have \"Refresh:\" header\n"
                    ));

        SetRefresh(TRUE);
    }


    //
    // check for "Transfer-Encoding:"
    //

    if (IsResponseHeaderPresent(HTTP_QUERY_TRANSFER_ENCODING) &&
        IsResponseHttp1_1())
    {

        //
        // If Http 1.1, check for Chunked Transfer
        //

        HEADER_STRING * curHeader;
        DWORD dwHeaderLength;
        LPSTR lpszHeader;
        DWORD iSlot;

        iSlot = _ResponseHeaders._bKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING];
        curHeader = _ResponseHeaders.GetSlot(iSlot);

        lpszHeader     = curHeader->StringAddress((LPSTR)_ResponseBuffer);
        dwHeaderLength = curHeader->StringLength();

        dwHeaderLength -= GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;
        lpszHeader     += GlobalKnownHeaders[HTTP_QUERY_TRANSFER_ENCODING].Length+1;

        while (dwHeaderLength && (*lpszHeader == ' ')) {
            ++lpszHeader;
            --dwHeaderLength;
        }

        //
        // look for "chunked" entry that confirms that we're doing chunked transfer encoding
        //

        if (((int)dwHeaderLength >= CHUNKED_LEN)
        && !strnicmp(lpszHeader, CHUNKED_SZ, CHUNKED_LEN))
        {

            SetHaveChunkEncoding(TRUE);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("server is sending Chunked Transfer Encoding\n"
                        ));

            //
            // if both "transfer-encoding: chunked" and "content-length:"
            // were received then the chunking takes precedence
            //

            INET_ASSERT(!(IsChunkEncoding() && IsContentLength()));

            if (IsContentLength()) {
                SetHaveContentLength(FALSE);
            }

        }
    }

    SetBadNSServer(FALSE);

    if (IsResponseHttp1_1())
    {

        //
        // For IIS 4.0 Servers, and all other normal servers, if we make
        //  a HEAD request, we should ignore the Content-Length.
        //
        // IIS 3.0 servers send an illegal body, and this is a bug in the server.
        //  since they're not HTTP 1.1 we should be ok here.
        //

        if ( (GetMethodType() == HTTP_METHOD_TYPE_HEAD) &&
             (_ContentLength > 0) &&
             IsWantKeepAlive()
             )
        {

            //
            // set length to 0
            //

            _ContentLength = 0;

        }

        if ( IsRequestHttp1_1() )
        {


            //
            // check for NS servers that don't return correct HTTP/1.1 responses
            //

            LPSTR buffer;
            DWORD buflen;
            DWORD status = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                                   (LPVOID*)&buffer,
                                                   &buflen,
                                                   0
                                                   );

    #define NSEP    "Netscape-Enterprise/3"
    #define NSEPLEN (sizeof(NSEP) - 1)
    #define NSFT    "Netscape-FastTrack/3"
    #define NSFTLEN (sizeof(NSFT) - 1)
    #define NSCS    "Netscape-Commerce/3"
    #define NSCSLEN (sizeof(NSCS) - 1)

            if (status == ERROR_SUCCESS) {

                BOOL fIsBadServer = ((buflen > NSEPLEN) && !strnicmp(buffer, NSEP, NSEPLEN))
                                 || ((buflen > NSFTLEN) && !strnicmp(buffer, NSFT, NSFTLEN))
                                 || ((buflen > NSCSLEN) && !strnicmp(buffer, NSCS, NSCSLEN));

                if ( fIsBadServer )
                {
                    CServerInfo * pServerInfo = GetServerInfo();

                    SetBadNSServer(fIsBadServer);

                    if (pServerInfo != NULL)
                    {
                        //
                        // Note this Bad Server info in the server info obj,
                        //   as we they fail to do keep-alive with SSL properly
                        //

                        pServerInfo->SetBadNSServer();
                    }


                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("IsBadNSServer() == %B\n",
                                IsBadNSServer()
                                ));
                }
            }
        }

        //
        // BUGBUG - content-type: multipart/byteranges means we
        //          also have data
        //

        DWORD statusCode = GetStatusCode();

        if (!IsBadNSServer()
            && !IsContentLength()
            && !IsChunkEncoding()
            && (((statusCode >= HTTP_STATUS_CONTINUE)               // 100
                && (statusCode < HTTP_STATUS_OK))                   // 200
                || (statusCode == HTTP_STATUS_NO_CONTENT)           // 204
                || (statusCode == HTTP_STATUS_MOVED)                // 301
                || (statusCode == HTTP_STATUS_REDIRECT)             // 302
                || (statusCode == HTTP_STATUS_REDIRECT_METHOD)      // 303
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)         // 304
                || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB))  // 307
            || (GetMethodType() == HTTP_METHOD_TYPE_HEAD)) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("header-only HTTP/1.1 response\n"
                        ));

            SetData(FALSE);
        }
    }

    DEBUG_LEAVE(0);
}


//
// this array has the same order as the HTTP_METHOD_TYPE enum
//

#define MAKE_REQUEST_METHOD_TYPE(Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## Type

//
// darrenmi - need a new macro because *_M-POST isn't a valid enum member.
// we need a seperate enum type and string value.
//
// map HTTP_METHOD_TYPE_MPOST <=> "M-POST"
//

#define MAKE_REQUEST_METHOD_TYPE2(EnumType,Type) \
    sizeof(# Type) - 1, # Type, HTTP_METHOD_TYPE_ ## EnumType

static const struct _REQUEST_METHOD {
    int Length;
    LPSTR Name;
    HTTP_METHOD_TYPE MethodType;
} MethodNames[] = {
    MAKE_REQUEST_METHOD_TYPE(GET),
    MAKE_REQUEST_METHOD_TYPE(HEAD),
    MAKE_REQUEST_METHOD_TYPE(POST),
    MAKE_REQUEST_METHOD_TYPE(PUT),
    MAKE_REQUEST_METHOD_TYPE(PROPFIND),
    MAKE_REQUEST_METHOD_TYPE(PROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(LOCK),
    MAKE_REQUEST_METHOD_TYPE(UNLOCK),
    MAKE_REQUEST_METHOD_TYPE(COPY),
    MAKE_REQUEST_METHOD_TYPE(MOVE),
    MAKE_REQUEST_METHOD_TYPE(MKCOL),
    MAKE_REQUEST_METHOD_TYPE(CONNECT),
    MAKE_REQUEST_METHOD_TYPE(DELETE),
    MAKE_REQUEST_METHOD_TYPE(LINK),
    MAKE_REQUEST_METHOD_TYPE(UNLINK),
    MAKE_REQUEST_METHOD_TYPE(BMOVE),
    MAKE_REQUEST_METHOD_TYPE(BCOPY),
    MAKE_REQUEST_METHOD_TYPE(BPROPFIND),
    MAKE_REQUEST_METHOD_TYPE(BPROPPATCH),
    MAKE_REQUEST_METHOD_TYPE(BDELETE),
    MAKE_REQUEST_METHOD_TYPE(SUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(UNSUBSCRIBE),
    MAKE_REQUEST_METHOD_TYPE(NOTIFY),
    MAKE_REQUEST_METHOD_TYPE(POLL), 
    MAKE_REQUEST_METHOD_TYPE(CHECKIN),
    MAKE_REQUEST_METHOD_TYPE(CHECKOUT),
    MAKE_REQUEST_METHOD_TYPE(INVOKE),
    MAKE_REQUEST_METHOD_TYPE(SEARCH),
    MAKE_REQUEST_METHOD_TYPE(PIN),
    MAKE_REQUEST_METHOD_TYPE2(MPOST,M-POST)
};


HTTP_METHOD_TYPE
MapHttpRequestMethod(
    IN LPCSTR lpszVerb
    )

/*++

Routine Description:

    Maps request method string to type. Method names *are* case-sensitive

Arguments:

    lpszVerb    - method (verb) string

Return Value:

    HTTP_METHOD_TYPE

--*/

{
    int verbLen = strlen(lpszVerb);

    for (int i = 0; i < ARRAY_ELEMENTS(MethodNames); ++i) {
        if ((MethodNames[i].Length == verbLen)
        && (memcmp(lpszVerb, MethodNames[i].Name, verbLen) == 0)) {
            return MethodNames[i].MethodType;
        }
    }

    //
    // we now hande HTTP_METHOD_TYPE_UNKNOWN
    //

    return HTTP_METHOD_TYPE_UNKNOWN;
}


DWORD
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod,
    OUT LPCSTR * lplpcszName
    )

/*++

Routine Description:

    Map a method type to the corresponding name and length

Arguments:

    tMethod     - to map

    lplpcszName - pointer to pointer to returned name

Return Value:

    DWORD
        Success - length of method name

        Failure - (DWORD)-1

--*/

{
    DWORD length;

    if ((tMethod >= HTTP_METHOD_TYPE_FIRST) && (tMethod <= HTTP_METHOD_TYPE_LAST)) {
        *lplpcszName = MethodNames[tMethod].Name;
        length = MethodNames[tMethod].Length;
    } else {
        length = (DWORD)-1;
    }
    return length;
}

#if INET_DEBUG

LPSTR
MapHttpMethodType(
    IN HTTP_METHOD_TYPE tMethod
    )
{
    return (tMethod == HTTP_METHOD_TYPE_UNKNOWN)
        ? "Unknown"
        : MethodNames[tMethod].Name;
}

#endif

//
//DWORD
//CreateEscapedUrlPath(
//    IN LPSTR lpszUrlPath,
//    OUT LPSTR * lplpszEncodedUrlPath
//    )
//
///*++
//
//Routine Description:
//
//    Given an URL-path, encodes it into a new buffer
//
//Arguments:
//
//    lpszUrlPath             - URL-path to encode
//
//    lplpszEncodedUrlPath    - pointer to returned allocated buffer containing
//                              escaped URL-path
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    LPSTR lpszEncodedUrlPath = NULL;
//    DWORD urlPathLength;
//    DWORD encodedUrlPathLength;
//    DWORD error;
//
//    //
//    // we need to encode the URL-path into a separate buffer (it may grow)
//    //
//
//    urlPathLength = strlen(lpszUrlPath);
//    encodedUrlPathLength = INTERNET_MAX_PATH_LENGTH;
//
//    do {
//
//        //
//        // we allow ourselves to fail due to insufficient buffer (at least once)
//        //
//
//        lpszEncodedUrlPath = (LPSTR)ResizeBuffer(lpszEncodedUrlPath,
//                                                 encodedUrlPathLength,
//                                                 FALSE
//                                                 );
//        if (lpszEncodedUrlPath != NULL) {
//
//            DWORD previousLength = encodedUrlPathLength;
//
//            error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
//
//                                  //
//                                  // BUGBUG - assuming HTTP
//                                  //
//
//                                  SCHEME_HTTP,
//                                  lpszUrlPath,
//                                  urlPathLength,
//                                  lpszEncodedUrlPath,
//                                  &encodedUrlPathLength
//                                  );
//
//            if ((error == ERROR_INSUFFICIENT_BUFFER)
//            && (previousLength >= encodedUrlPathLength)) {
//
//                //
//                // this should never happen, but we will avoid a loop if it does
//                //
//
//                INET_ASSERT(FALSE);
//
//                error = ERROR_INTERNET_INTERNAL_ERROR;
//            }
//        } else {
//
//            //
//            // failed to (re)alloc
//            //
//
//            error = ERROR_NOT_ENOUGH_MEMORY;
//        }
//    } while (error == ERROR_INSUFFICIENT_BUFFER);
//
//    *lplpszEncodedUrlPath = lpszEncodedUrlPath;
//
//    return error;
//}

PRIVATE
BOOL
FMatchList(
    LPSTR *lplpList,
    DWORD cListLen,
    HEADER_STRING *lpHeader,
    LPSTR    lpBase
    )
{
    DWORD i;
    for (i=0; i < cListLen; ++i) {
       if (!lpHeader->Strnicmp(lpBase, lplpList[i], strlen(lplpList[i]))) {
          return (TRUE);
       }
    }
    return(FALSE);
}

#ifdef COMPRESSED_HEADERS
DWORD
LookupHeadermap(
    LPSTR   lpszHeader
)
{
    DWORD   top, mid, bottom, ret = 0;
    int cmp;
    LPSTR lpszColon;

    lpszColon = strchr(lpszHeader, ':');

    if (!lpszColon || (lpszColon == lpszHeader)) {
        return(ret);
    }

    // yuk
    *lpszColon = 0;

    top = 1;

    bottom = sizeof(rgsHeaderMap)/sizeof(HEADER_MAP);

    INET_ASSERT(bottom >= top);

    do {

        mid = (bottom+top)/2;
        if (!(cmp = stricmp(   rgsHeaderMap[mid].lpszLongHeader,
                                lpszHeader
                                ))) {
            // we found a matching header,
            ret = mid;
            break;
        }

        if (cmp > 0) {
            // the mid header is larger than the passed in header
            // so we must check at the upper end of the sorted array of headers
            bottom = mid-1;
        }
        else {
            // the mid header is smaller than the passed in header
            // so we must check at the lower end of the sorted array of headers
            top = mid+1;
        }
    } while (bottom >= top);

    *lpszColon = ':';
    return (ret);
}
#endif //COMPRESSED_HEADERS


//
// HTTP_HEADER_PARSER implementation
//

HTTP_HEADER_PARSER::HTTP_HEADER_PARSER(
    IN LPSTR szHeaders,
    IN DWORD cbHeaders
    ) : HTTP_HEADERS()

/*++

Routine Description:

    Constructor for the HTTP_HEADER_PARSER object.  Calls ParseHeaders to
      build a parsed version of the header string passed in.

Arguments:

    szHeaders      - pointer to the headers to parse

    cbHeaders      - length of the headers

Return Value:

    None.

--*/

{
    DWORD dwBytesScaned = 0;
    BOOL fFoundCompleteLine;
    BOOL fFoundEndOfHeaders;
    DWORD error;

    error = ParseHeaders(
        szHeaders,
        cbHeaders,
        TRUE, // Eof
        &dwBytesScaned,
        &fFoundCompleteLine,
        &fFoundEndOfHeaders
        );

    INET_ASSERT(error == ERROR_SUCCESS);
    INET_ASSERT(fFoundCompleteLine);
    INET_ASSERT(fFoundEndOfHeaders);
}


/*  //  some test cases which can be used to test ParseStatusLine()
char bad1[] = "HTTP1.1 200 Description yeah yeah\r\n";
char bad2[] = "HTTP/1234.1 200 Description yeah yeah\r\n";
char bad3[] = "HTTP/1.1234 200 Description yeah yeah\r\n";
char bad4[] = "HTTP/1.1 1234 Description yeah yeah\r\n";
char bad5[] = "HTTP/    1.1 200 Description yeah yeah\r\n";
char bad6[] = "HTTP/1.1    200 Description yeah yeah\r\n";
char bad7[] = "HTTP/1.1 200Description yeah yeah\r\n";
char bad8[3000] = "HTTP/1.1 200 Description yeah yeah";
char bad9[] = "HTTP/1 1.1 200 Description yeah yeah\r\n";
char good1[] = "HTTP/   123.123   200 Description yeah yeah\r\n";
*/


DWORD
HTTP_HEADER_PARSER::ParseStatusLine(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT BOOL *lpfNeedMoreBuffer,
    OUT DWORD *lpdwStatusCode,
    OUT DWORD *lpdwMajorVersion,
    OUT DWORD *lpdwMinorVersion
    )

/*++

Routine Description:

    Parses the Status line of an HTTP server response.  Takes care of adding the status
     line to HTTP header array.

    From HTTP v1.1. spec:
    {
      Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
      HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
      Status-Code = 1*DIGIT
      Reason-Phrase = *<TEXT, excluding CR LF>
      (1*DIGIT means at least one digit, maybe more)
    }

    WinHTTP strictly enforces the status line spec.  The only exception is that up to 3
    spaces are allowed before the Status-Code and major version number.

    To prevent malicious servers from hogging the channel, the integers are limited to
    3 digits and the Reason-Phrase is limited to GlobalMaxSizeStatusLineResultText characters.

    "HTTP" could be other things like "S-HTTP", this is checked by UpdateFromHeaders()
    before ParseStatusLine() is called.  The existence of the first '/' is verified before
    ParseStatusLine is called.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    BOOL  - TRUE if line was successively parsed and processed, FALSE otherwise

--*/

{

#define BEFORE_VERSION_NUMBERS 0
#define MAJOR_VERSION_NUMBER   1
#define MINOR_VERSION_NUMBER   2
#define STATUS_CODE_NUMBER     3
#define AFTER_STATUS_CODE      4
#define MAX_STATUS_INTS        4

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    DWORD dwStatusLineLength = 0;
    LPSTR lpszStatusLine = NULL;
    int ver_state = BEFORE_VERSION_NUMBERS;
    BOOL afStatusIntsFound[MAX_STATUS_INTS] = {0};
    DWORD adwStatusInts[MAX_STATUS_INTS] = {0};
    DWORD dwStatusPieceLength = 0;
    BOOL error = ERROR_INTERNET_INTERNAL_ERROR;

    lpszStatusLine = response;

    //
    // While walking the Status Line looking for terminating \r\n,
    //   we extract the Major.Minor Versions and Status Code in that order.
    //   text and spaces will lie between/before/after the three numbers
    //   but the idea is to remeber which number we're calculating based on a numeric state
    //   If all goes well the loop will churn out an array with the 3 numbers plugged in as DWORDs
    //

    while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
    {
        switch (ver_state)
        {
            case BEFORE_VERSION_NUMBERS:
                //
                //  We've already matched the status line with something
                //of the form "****/" in UpdateFromHeaders(), we can ignore everything
                //through the first '/'.
                //
                if (*response == '/')
                {
                    INET_ASSERT(ver_state == BEFORE_VERSION_NUMBERS);
                    ver_state++; // = MAJOR_VERSION_NUMBER
                    dwStatusPieceLength = 0;  // next piece is either spaces or an int
                }

                break;

            case MAJOR_VERSION_NUMBER:

                if (*response == '.' && ver_state == MAJOR_VERSION_NUMBER)
                {
                    ver_state++; // = MINOR_VERSION_NUMBER
                    dwStatusPieceLength = 0;  // next piece is an int
                    break;
                }
                // fall through

            case MINOR_VERSION_NUMBER:

                if (*response == ' ' && ver_state == MINOR_VERSION_NUMBER)
                {
                    ver_state++; // = STATUS_CODE_NUMBER
                    dwStatusPieceLength = 0;  // next piece is either spaces or an int.
                    break;
                }
                // fall through

            case STATUS_CODE_NUMBER:

                if (isdigit(*response))
                {
                    if (!afStatusIntsFound[ver_state])
                    {
                        //  transitioning from counting spaces
                        //to counting integers
                        dwStatusPieceLength = 0;
                    }

                    //  Allow up to 3 digits per integer.
                    if (++dwStatusPieceLength > 3)
                        goto doneInvalidStatusLine;
                    
                    int val = *response - '0';
                    afStatusIntsFound[ver_state] = TRUE;
                    adwStatusInts[ver_state] = adwStatusInts[ver_state] * 10 + val;
                }
                else if ( adwStatusInts[STATUS_CODE_NUMBER] > 0 )
                {
                    INET_ASSERT(ver_state == STATUS_CODE_NUMBER);
                    if (*response != ' ')
                        goto doneInvalidStatusLine;
                    ver_state++; // = AFTER_STATUS_CODE
                    dwStatusPieceLength = 0;  // next piece is the status line
                    break;
                }
                else if (*response == ' ' && !afStatusIntsFound[ver_state])
                {
                    //
                    //  Before processing MAJOR_VERSION_NUMBER or STATUS_CODE_NUMBER,
                    //allow up to 3 spaces.
                    //
                    //  Multiple spaces are being allowed here because it is
                    //legacy behavior and may therefore be necessary, and being non-strict
                    //about it doesn't put anything at risk.
                    //
                    if (++dwStatusPieceLength > 3)
                        goto doneInvalidStatusLine;
                }
                else
                {
                    //  We fail if anything outside the spec is found, except
                    //for allowing multiple spaces before the status code.
                    goto doneInvalidStatusLine;
                }

                break;

            case AFTER_STATUS_CODE:
                //
                //  This will advance to the next CR or LF..
                //
                //  We limit Reason-Phrase length to protect against malicious socket hogging
                //

                if (++dwStatusPieceLength > GlobalMaxSizeStatusLineResultText)
                {
                    goto doneInvalidStatusLine;
                }
                break;

        }

        ++response;
        ++dwBytesScanned;
    }

    //
    //  Verify there is enough reponse left to check for a CRLF..
    //
    if (response == lpszEnd
        || response + 1 == lpszEnd)
    {
        //
        //
        //  If we're at the end of the connection then the server sent us an
        //incorrectly formatted response, Invalid status line.
        //
        //  If more data may come, indicate to retry it.
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of short response in status line\n"
                    ));

        if (fEof)
            goto doneInvalidStatusLine;
        else
            goto doneNeedMoreData;
    }

    dwStatusLineLength = dwBytesScanned;

    //
    //  And to finish, verify the CRLF...
    //

    //CR
    // some servers may not send the CR so give them a pass for compatibility
    if ( *response == '\r')
    {
        ++response;  //  we know its safe to step since we checked if (respone == lpszEnd) above.
        ++dwBytesScanned;
    }

    //LF
    if ( *response != '\n')
        goto doneInvalidStatusLine;
    ++response;  //  we know its safe to step again since we checked if (respone+1 == lpszEnd) above.
    ++dwBytesScanned;

    //
    //  Some validation checking
    //
    //  All three status ints must have been found.
    //  I found some code that assumes that if the Status Code == 0, then
    //the status line hasn't been parsed yet.  To be sure this assumption
    //remains true, explicitly reject status lines with a 0 status code.
    //
    if (afStatusIntsFound[MAJOR_VERSION_NUMBER] != TRUE
        || afStatusIntsFound[MINOR_VERSION_NUMBER] != TRUE
        || afStatusIntsFound[STATUS_CODE_NUMBER] != TRUE
        || adwStatusInts[STATUS_CODE_NUMBER] == 0)
    {
        goto doneInvalidStatusLine;
    }

    //
    // Now we have our parsed header to add to the array
    //

    HEADER_STRING * freeHeader;
    DWORD iSlot;

    freeHeader = FindFreeSlot(&iSlot);
    if (freeHeader == NULL) {
        goto doneFailError;
    } else {
        INET_ASSERT(iSlot == 0); // status line should always be first
        freeHeader->CreateOffsetString((DWORD)(lpszStatusLine - lpHeaderBase), dwStatusLineLength);
        freeHeader->SetHash(0); // status line has no hash value.
    }

    //
    //  Success..  fill in the output params appropriately.
    //
    
    *lpfNeedMoreBuffer = FALSE;
    *lpdwStatusCode    = adwStatusInts[STATUS_CODE_NUMBER];
    *lpdwMajorVersion  = adwStatusInts[MAJOR_VERSION_NUMBER];
    *lpdwMinorVersion  = adwStatusInts[MINOR_VERSION_NUMBER];

    *lpdwBufferLengthScanned += dwBytesScanned;

    error = ERROR_SUCCESS;
    goto exitFinalReturn;

doneNeedMoreData:
    error = ERROR_SUCCESS;
    *lpfNeedMoreBuffer = TRUE;
    goto exitFinalReturn;

doneInvalidStatusLine:
    error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
    *lpfNeedMoreBuffer = FALSE;
    goto exitFinalReturn;

doneFailError:
    error = ERROR_INTERNET_INTERNAL_ERROR;
    *lpfNeedMoreBuffer = FALSE;
    goto exitFinalReturn;

exitFinalReturn:
    return error;
}

DWORD
HTTP_HEADER_PARSER::ParseHeaders(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT LPBOOL pfFoundCompleteLine,
    OUT LPBOOL pfFoundEndOfHeaders
    )

/*++

Routine Description:

    Loads headers into HTTP_HEADERS member for subsequent parsing.

    Parses string based headers and adds their parts to an internally stored
    array of HTTP_HEADERS.

    Input is assumed to be well formed Header Name/Value pairs, each deliminated
    by ':' and '\r\n'.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    None.

--*/


{

    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;

    *pfFoundEndOfHeaders  = FALSE;

    //
    // Each iteration of the following loop
    // walks an HTTP header line of the form:
    //  HeaderName: HeaderValue\r\n
    //

    do
    {
        DWORD dwHash = HEADER_HASH_SEED;
        LPSTR lpszHeaderName;
        DWORD dwHeaderNameLength = 0;
        DWORD dwHeaderLineLength = 0;
        DWORD dwPreviousAmountOfBytesScanned = dwBytesScanned;

        //
        // Remove leading whitespace from header
        //

        while ( (response < lpszEnd) && ((*response == ' ') || (*response == '\t')) )
        {
            ++response;
            ++dwBytesScanned;
        }

        //
        // Scan for HeaderName:
        //

        lpszHeaderName = response;
        dwPreviousAmountOfBytesScanned = dwBytesScanned;

        while ((response < lpszEnd) && (*response != ':') && (*response != '\r') && (*response != '\n'))
        {
            //
            // This code incapsulates CalculateHashNoCase as an optimization,
            //   we attempt to calculate the Hash value as we parse the header.
            //

            CHAR ch = *response;

            if ((ch >= 'A') && (ch <= 'Z')) {
                ch = MAKE_LOWER(ch);
            }
            dwHash += (DWORD)(dwHash << 5) + ch;

            ++response;
            ++dwBytesScanned;
        }

        dwHeaderNameLength = (DWORD) (response - lpszHeaderName);

        //
        // catch bogus responses: if we find what looks like one of a (very)
        // small set of HTML tags, then assume the previous header was the
        // last
        //

        if ((dwHeaderNameLength >= sizeof("<HTML>") - 1)
            && (*lpszHeaderName == '<')
            && (!strnicmp(lpszHeaderName, "<HTML>", sizeof("<HTML>") - 1)
                || !strnicmp(lpszHeaderName, "<HEAD>", sizeof("<HEAD>") - 1))) {
            *pfFoundEndOfHeaders  = TRUE;
            break;
        }

        //
        // Keep scanning till end of the line.
        //

        while ((response < lpszEnd) && (*response != '\r') && (*response != '\n'))
        {
            ++response;
            ++dwBytesScanned;
        }

        dwHeaderLineLength = (DWORD) (response - lpszHeaderName); // note: this headerLINElength

        if (response == lpszEnd) {

            //
            // response now points one past the end of the buffer. We may be looking
            // over the edge...
            //
            // if we're at the end of the connection then the server sent us an
            // incorrectly formatted response. Probably an error.
            //
            // Otherwise its a partial response. We need more
            //


            DEBUG_PRINT(HTTP,
                        INFO,
                        ("found end of short response\n"
                        ));

            success = fEof ? TRUE : FALSE;

            //
            // if we really hit the end of the response then update the amount of
            // headers scanned
            //

            if (!success) {
                dwBytesScanned = dwPreviousAmountOfBytesScanned;
            }

            break;

        }
        else
        {

            //
            // we reached a CR or LF. This is the end of this current header. Find
            // the start of the next one
            //

            //
            // first, strip off any trailing spaces from the current header. We do
            // this by simply reducing the string length. We only look for space
            // and tab characters. Only do this if we have a non-zero length header
            //

            if (dwHeaderLineLength != 0) {
                for (int i = -1; response[i] == ' ' || response[i] == '\t'; --i) {
                    --dwHeaderLineLength;
                }
            }

            INET_ASSERT((int)dwHeaderLineLength >= 0);

            //
            // some servers respond with "\r\r\n". Lame
            // A new twist: "\r \r\n". Lamer
            //

            while ((response < lpszEnd)
            && ((*response == '\r') || (*response == ' '))) {
                ++response;
                ++dwBytesScanned;
            }
            if (response == lpszEnd) {

                //
                // hit end of buffer without finding LF
                //

                success = FALSE;

                DEBUG_PRINT(HTTP,
                            WARNING,
                            ("hit end of buffer without finding LF\n"
                            ));

                //
                // get more data, reparse this line
                //

                dwBytesScanned = dwPreviousAmountOfBytesScanned;
                break;
            } else if (*response == '\n') {
                ++response;
                ++dwBytesScanned;

                //
                // if we found the empty line then we are done
                //

                if (dwHeaderLineLength == 0) {
                    *pfFoundEndOfHeaders  = TRUE;
                    break;
                }

                success = TRUE;
            }
        }


        // If a header name has no trailing colon ignore it

        if (lpszHeaderName[dwHeaderNameLength] != ':')
        {
            continue;   
        }

        //
        // Now we have our parsed header to add to the array
        //

        HEADER_STRING * freeHeader;
        DWORD iSlot;

        freeHeader = FindFreeSlot(&iSlot);
        if (freeHeader == NULL) {
            error = GetError();

            INET_ASSERT(error != ERROR_SUCCESS);
            goto quit;

        } else {
            freeHeader->CreateOffsetString((DWORD) (lpszHeaderName - lpHeaderBase), dwHeaderLineLength);
            freeHeader->SetHash(dwHash);
        }


        //CHAR szTemp[256];
        //
        //memcpy(szTemp, lpszHeaderName, dwHeaderLineLength);
        //lpszHeaderName[dwHeaderLineLength] = '\0';

        //DEBUG_PRINT(HTTP,
        //    INFO,
        //    ("ParseHeaders: adding=%q\n", lpszHeaderName
        //    ));


        //
        // Now see if this is a known header we are adding, if so then we note that fact
        //

        DWORD dwKnownQueryIndex;

        if (HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwKnownQueryIndex) )
        {
            freeHeader->SetNextKnownIndex(FastAdd(dwKnownQueryIndex, iSlot));
        }
    } while (TRUE);

quit:

    *lpdwBufferLengthScanned += dwBytesScanned;
    *pfFoundCompleteLine = success;

    return error;
}

#if 0
//
// Slower version of the function above used for performance work!!! Keep around
//   until we're sure it will never be used.
//

DWORD
HTTP_HEADER_PARSER::ParseHeaders(
    IN LPSTR lpHeaderBase,
    IN DWORD dwBufferLength,
    IN BOOL fEof,
    IN OUT DWORD *lpdwBufferLengthScanned,
    OUT LPBOOL pfFoundCompleteLine,
    OUT LPBOOL pfFoundEndOfHeaders
    )

/*++

Routine Description:

    Parses string based headers and adds their parts to an internally stored
    array of HTTP_HEADERS.


    Input is assumed to be well formed Header Name/Value pairs, each deliminated
    by ':' and '\r\n'.

Arguments:

    lpszHeader      - pointer to the header to check

    dwHeaderLength  - length of the header

Return Value:

    None.

--*/


{

#define HTTP_HEADER_PARSE_LEADING_SPACE 0
#define HTTP_HEADER_PARSE_NAME 1
#define HTTP_HEADER_PARSE_VALUE 2
#define HTTP_HEADER_PARSE_CR 3
#define HTTP_HEADER_PARSE_LF 4


    LPSTR lpszEnd = lpHeaderBase + dwBufferLength;
    LPSTR response = lpHeaderBase + *lpdwBufferLengthScanned;
    DWORD dwBytesScanned = 0;
    BOOL success = FALSE;
    DWORD error = ERROR_SUCCESS;
    DWORD state = HTTP_HEADER_PARSE_LEADING_SPACE;

    *pfFoundEndOfHeaders  = FALSE;

    //
    // Each iteration of the following loop
    // walks an HTTP header line of the form:
    //  HeaderName: HeaderValue\r\n
    //

        DWORD dwHash = HEADER_HASH_SEED;
        LPSTR lpszHeaderName;
        DWORD dwHeaderNameLength = 0;
        DWORD dwHeaderLineLength = 0;
        DWORD dwPreviousAmountOfBytesScanned = dwBytesScanned;
        DWORD dwWhiteSpace = 0;


        while ( (response < lpszEnd) )
        {
            switch (state)
            {

                case HTTP_HEADER_PARSE_LEADING_SPACE:

                    //
                    // Remove leading whitespace from header
                    //

                    if ( *response == ' ' ||
                         *response == '\t' )
                    {
                        break;
                    }

                    //
                    // Scan for HeaderName:
                    //

                    state = HTTP_HEADER_PARSE_NAME;
                    lpszHeaderName = response;
                    dwPreviousAmountOfBytesScanned = dwBytesScanned;

                    // fall through

                case HTTP_HEADER_PARSE_NAME:

                    switch (*response)
                    {
                        case ':':
                            //
                            // Now parse the Header Value
                            //

                            state = HTTP_HEADER_PARSE_VALUE;
                            dwHeaderNameLength = (DWORD) (response - lpszHeaderName);
                            break;


                        case '\r':
                            state = HTTP_HEADER_PARSE_CR;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName);
                            break;

                        case '\n':

                            state = HTTP_HEADER_PARSE_LF;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName);
                            goto Got_LF;
                            //break;

                        default:
                        {
                            CHAR ch = *response;

                            if ((ch >= 'A') && (ch <= 'Z')) {
                                ch = MAKE_LOWER(ch);
                            }
                            dwHash += (DWORD)(dwHash << 5) + ch;

                            break;
                        }
                    }

                    break;

                case HTTP_HEADER_PARSE_VALUE:

                    switch ( *response )
                    {
                        case '\r':
                            state = HTTP_HEADER_PARSE_CR;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName) - dwWhiteSpace;
                            break;

                        case '\n':

                            state = HTTP_HEADER_PARSE_LF;
                            // note: this is headerLINElength
                            dwHeaderLineLength = (DWORD) (response - lpszHeaderName) - dwWhiteSpace;
                            goto Got_LF;

                        case ' ':
                        case '\t':
                            // count whitespace at end of the line
                            dwWhiteSpace++;
                            break;

                        default:
                            dwWhiteSpace = 0;
                            break;
                    }

                    break;

                case HTTP_HEADER_PARSE_CR:

                    if (*response == ' ' ||
                        *response == '\r' )
                    {
                        break;
                    }

                    state = HTTP_HEADER_PARSE_LF;
                    // fall through

                case HTTP_HEADER_PARSE_LF:

Got_LF:

                    //
                    // if we found the empty line then we are done
                    //

                    success = TRUE;

                    if (dwHeaderLineLength == 0) {
                        ++dwBytesScanned;
                        ++response;
                        *pfFoundEndOfHeaders  = TRUE;
                        goto quit;
                    }


                    {
                        //
                        // Now we have our parsed header to add to the array
                        //

                        HEADER_STRING * freeHeader;
                        DWORD iSlot;

                        freeHeader = FindFreeSlot(&iSlot);
                        if (freeHeader == NULL) {
                            error = GetError();

                            INET_ASSERT(error != ERROR_SUCCESS);
                            goto quit;

                        } else {
                            freeHeader->CreateOffsetString((lpszHeaderName - lpHeaderBase), dwHeaderLineLength);
                            freeHeader->SetHash(dwHash);
                        }

                        CHAR szTemp[256];

                        memcpy(szTemp, lpszHeaderName, dwHeaderLineLength);
                        szTemp[dwHeaderLineLength] = '\0';

                        DEBUG_PRINT(HTTP,
                            INFO,
                            ("ParseHeaders: adding=%q\n", lpszHeaderName
                            ));


                        //
                        // Now see if this is a known header we are adding, if so then we note that fact
                        //

                        DWORD dwKnownQueryIndex;

                        if (HeaderMatch(dwHash, lpszHeaderName, dwHeaderNameLength, &dwKnownQueryIndex) )
                        {
                            freeHeader->SetNextKnownIndex(FastAdd(dwKnownQueryIndex, iSlot));
                        }
                    }

                    //
                    // Move on to our next header.
                    //

                    dwHash = HEADER_HASH_SEED;
                    dwHeaderNameLength = 0;
                    dwHeaderLineLength = 0;
                    dwPreviousAmountOfBytesScanned = dwBytesScanned;
                    dwWhiteSpace = 0;

                    state = HTTP_HEADER_PARSE_LEADING_SPACE;

                    break;

            } // switch (state)

            ++response;
            ++dwBytesScanned;

        } // while (response < lpszEnd)


        //
        // response now points one past the end of the buffer. We may be looking
        // over the edge...
        //
        // if we're at the end of the connection then the server sent us an
        // incorrectly formatted response. Probably an error.
        //
        // Otherwise its a partial response. We need more
        //


        DEBUG_PRINT(HTTP,
                    INFO,
                    ("found end of short response\n"
                    ));

        success = fEof ? TRUE : FALSE;

        //
        // if we really hit the end of the response then update the amount of
        // headers scanned
        //

        if (!success) {
            dwBytesScanned = dwPreviousAmountOfBytesScanned;
        }

quit:

  *lpdwBufferLengthScanned += dwBytesScanned;
  *pfFoundCompleteLine    = success;

  return error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\httpp.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    httpp.h

Abstract:

    Private master include file for the HTTP API project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

//
//  Local include files.
//

#include "proc.h"
#include "headers.h"

// Beta logging
#ifdef BETA_LOGGING
#define BETA_LOG(stat) \
    {DWORD dw; IncrementUrlCacheHeaderData (CACHE_HEADER_DATA_##stat, &dw);}
#else
#define BETA_LOG(stat) do { } while(0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\headers.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    headers.h

Abstract:

    This file contains the well-known HTTP/MIME request/response headers.
    For each header, two manifests are defined. HTTP_*_SZ contains the header
    name, immediatly followed by a colon. HTTP_*_LEN is the strlen of the
    corresponding HTTP_*_SZ, which does not include the terminating '\0'.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#define CSTRLEN(str)  (sizeof(str)-1)

#ifndef _HEADERS_H_
#define _HEADERS_H_

struct KnownHeaderType {
    LPSTR Text;
    INT Length;
    DWORD Flags;
    DWORD HashVal;
};

#define MAX_HEADER_HASH_SIZE 153
#define HEADER_HASH_SEED 1291949


extern const BYTE GlobalHeaderHashs[];
extern const struct KnownHeaderType GlobalKnownHeaders[];

DWORD
FASTCALL
CalculateHashNoCase(
    IN LPSTR lpszString,
    IN DWORD dwStringLength
    );


//
// Various other header defines for different HTTP headers.
//

#define HTTP_ACCEPT_RANGES_SZ           "Accept-Ranges:"
#define HTTP_ACCEPT_RANGES_LEN          CSTRLEN(HTTP_ACCEPT_RANGES_SZ)

#define HTTP_DATE_SZ                    "Date:"
#define HTTP_DATE_LEN                   (sizeof(HTTP_DATE_SZ) - 1)

#define HTTP_EXPIRES_SZ                 "Expires:"
#define HTTP_EXPIRES_LEN                (sizeof(HTTP_EXPIRES_SZ) - 1)


#define HTTP_CONTENT_DISPOSITION_SZ     "Content-Disposition:"
#define HTTP_CONTENT_DISPOSITION_LEN     (sizeof(HTTP_CONTENT_DISPOSITION_SZ) - 1)

#define HTTP_LAST_MODIFIED_SZ           "Last-Modified:"
#define HTTP_LAST_MODIFIED_LEN          (sizeof(HTTP_LAST_MODIFIED_SZ) - 1)

// nuke?
#define HTTP_UNLESS_MODIFIED_SINCE_SZ   "Unless-Modified-Since:"
#define HTTP_UNLESS_MODIFIED_SINCE_LEN  CSTRLEN(HTTP_UNLESS_MODIFIED_SINCE_SZ)

#define HTTP_SERVER_SZ                  "Server:"
#define HTTP_SERVER_LEN                 (sizeof(HTTP_SERVER_SZ) - 1)

#define HTTP_CONNECTION_SZ              "Connection:"
#define HTTP_CONNECTION_LEN             (sizeof(HTTP_CONNECTION_SZ) - 1)

#define HTTP_PROXY_CONNECTION_SZ        "Proxy-Connection:"
#define HTTP_PROXY_CONNECTION_LEN       (sizeof(HTTP_PROXY_CONNECTION_SZ) - 1)

#define HTTP_SET_COOKIE_SZ              "Set-Cookie:"
#define HTTP_SET_COOKIE_LEN             (sizeof(HTTP_SET_COOKIE_SZ)-1)

//
//  Miscellaneous header goodies.
//

#define CHUNKED_SZ                      "chunked"
#define CHUNKED_LEN                     (sizeof(CHUNKED_SZ) - 1)

#define KEEP_ALIVE_SZ                   "Keep-Alive"
#define KEEP_ALIVE_LEN                  (sizeof(KEEP_ALIVE_SZ) - 1)

#define CLOSE_SZ                        "Close"
#define CLOSE_LEN                       (sizeof(CLOSE_SZ) - 1)

#define BYTES_SZ                        "bytes"
#define BYTES_LEN                       CSTRLEN(BYTES_SZ)

#define HTTP_VIA_SZ                     "Via:"
#define HTTP_VIA_LEN                    (sizeof(HTTP_VIA_SZ) - 1)

#define HTTP_DATE_SIZE  40

// Cache control defines:

#define HTTP_CACHE_CONTROL_SZ           "Cache-Control:"
#define HTTP_CACHE_CONTROL_LEN          CSTRLEN(HTTP_CACHE_CONTROL_SZ)

#define HTTP_AGE_SZ                     "Age:"
#define HTTP_AGE_LEN                    (sizeof(HTTP_AGE_SZ)-1)

#define HTTP_VARY_SZ                    "Vary:"
#define HTTP_VARY_LEN                   (sizeof(HTTP_VARY_SZ)-1)

#define NO_CACHE_SZ                     "no-cache"
#define NO_CACHE_LEN                    (sizeof(NO_CACHE_SZ) -1)

#define NO_STORE_SZ                     "no-store"
#define NO_STORE_LEN                    (sizeof(NO_STORE_SZ) -1)

#define MUST_REVALIDATE_SZ              "must-revalidate"
#define MUST_REVALIDATE_LEN             (sizeof(MUST_REVALIDATE_SZ) -1)

#define MAX_AGE_SZ                      "max-age"
#define MAX_AGE_LEN                     (sizeof(MAX_AGE_SZ) -1)

#define PRIVATE_SZ                      "private"
#define PRIVATE_LEN                     (sizeof(PRIVATE_SZ) - 1)

#define POSTCHECK_SZ                    "post-check"
#define POSTCHECK_LEN                   (sizeof(POSTCHECK_SZ) -1)

#define PRECHECK_SZ                     "pre-check"
#define PRECHECK_LEN                    (sizeof(PRECHECK_SZ) -1)

#define FILENAME_SZ                     "filename"
#define FILENAME_LEN                    (sizeof(FILENAME_SZ) - 1)

#define USER_AGENT_SZ                   "user-agent"
#define USER_AGENT_LEN                  (sizeof(USER_AGENT_SZ) - 1)

#endif  // _HEADERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\hhead.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    hhead.cxx

Abstract:

    This file contains autogenerated table values of a perfect hash function
    DO NOT, DO NOT EDIT THIS FILE, TO ADD HEADERS SEE hashgen.cpp
    Contents:
      GlobalKnownHeaders
      GlobalHeaderHashs

Author:

   Arthur Bierer (arthurbi) 19-Dec-1997 (AND) my code generator[hashgen.exe]

Revision History:

--*/


#include <wininetp.h>
#include "httpp.h"

#ifdef HEADER_HASH_SEED
#if (HEADER_HASH_SEED != 1291949)
#error HEADER_HASH_SEED has not been updated in the header file, please copy this number to the header
#endif
#else
#define HEADER_HASH_SEED 1291949
#endif

#ifdef MAX_HEADER_HASH_SIZE
#if (MAX_HEADER_HASH_SIZE != 153)
#error MAX_HEADER_HASH_SIZE has not been updated in the header file, please copy this number to the header
#endif
#else
#define MAX_HEADER_HASH_SIZE 153
#endif

#ifdef HTTP_QUERY_MAX
#if (HTTP_QUERY_MAX != 78)
#error HTTP_QUERY_MAX is not the same as the value used in wininet.h, this indicates mismatched headers, see hashgen.cpp
#endif
#endif

//
// GlobalHeaderHashs - array of precalculated hashes on case-sensetive set of known headers.
// This array must be used with the same hash function used to generate it.
// Note, all entries in this array are biased (++'ed) by 1 from HTTP_QUERY_ manifests in wininet.h.
//   0-ed entries indicate error values
//

const BYTE GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {
      0,   0,   0,  71,   0,   0, 
     53,   0,   0,   0,   0,   0, 
     40,  60,  72,   0,   0,   0, 
     64,  61,   0,  28,   4,   0, 
     76,  57,   0,  30,   0,   8, 
      0,  15,   0,   0,   0,   0, 
     24,   0,  66,  29,   0,   0, 
      0,   0,   0,   0,  13,  14, 
     16,  33,   0,   0,   0,  68, 
     41,   0,   7,   0,   0,   0, 
      0,   0,  32,  17,  51,  48, 
     67,  11,   0,   0,   5,   0, 
     65,   2,   0,   0,  35,   6, 
      0,   0,  31,  50,   0,   0, 
      0,  49,  78,  26,   0,   0, 
     42,   0,   0,  43,   0,  27, 
     69,   9,   1,   0,   0,  18, 
     10,  79,   0,   3,  47,  55, 
      0,  44,   0,  56,   0,  70, 
     54,  52,   0,   0,   0,   0, 
      0,   0,  36,  62,   0,   0, 
     45,   0,   0,  12,   0,  73, 
     77,   0,  63,   0,  59,   0, 
      0,   0,   0,  58,  38,   0, 
      0,   0,  39,  25,   0,  37, 
      0,  34,   0, 
   };

//
// GlobalKnownHeaders - array of HTTP request and response headers that we understand.
// This array must be in the same order as the HTTP_QUERY_ manifests in WININET.H
//

#define HEADER_ENTRY(String, Flags, HashVal) String, sizeof(String) - 1, Flags, HashVal

const struct KnownHeaderType GlobalKnownHeaders[HTTP_QUERY_MAX+1] = {
    HEADER_ENTRY("Mime-Version",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x179ED708),
    HEADER_ENTRY("Content-Type",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A50E357),
    HEADER_ENTRY("Content-Transfer-Encoding",  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x562B730E),
    HEADER_ENTRY("Content-Id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xE7ADCA82),
    HEADER_ENTRY("Content-Description",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9D4EB3D9),
    HEADER_ENTRY("Content-Length",             (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_NUMBER), 0x4E02E517),
    HEADER_ENTRY("Content-Language",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA6681019),
    HEADER_ENTRY("Allow",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x297A46CC),
    HEADER_ENTRY("Public",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C5DD44C),
    HEADER_ENTRY("Date",                       (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xBB71C70B),
    HEADER_ENTRY("Expires",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC153144D),
    HEADER_ENTRY("Last-Modified",              (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x23617A4F),
    HEADER_ENTRY("Message-id",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC9AE6FAC),
    HEADER_ENTRY("Uri",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D45D),
    HEADER_ENTRY("Derived-From",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x6AAF4091),
    HEADER_ENTRY("Cost",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB717626),
    HEADER_ENTRY("Link",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB764B5B),
    HEADER_ENTRY("Pragma",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C26E9A5),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_NUMBER, 0x0),
    HEADER_ENTRY("",                           0, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Connection",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x190A507D),
    HEADER_ENTRY("Accept",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x581B295D),
    HEADER_ENTRY("Accept-Charset",             HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC87564B4),
    HEADER_ENTRY("Accept-Encoding",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x81EEF031),
    HEADER_ENTRY("Accept-Language",            HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2827D6EE),
    HEADER_ENTRY("Authorization",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xEC768B9E),
    HEADER_ENTRY("Content-Encoding",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2F295C),
    HEADER_ENTRY("Forwarded",                  HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x420550EB),
    HEADER_ENTRY("From",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB732781),
    HEADER_ENTRY("If-Modified-Since",          (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x88B69529),
    HEADER_ENTRY("Location",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8DD3A2C6),
    HEADER_ENTRY("Orig-Uri",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x47CCA2FB),
    HEADER_ENTRY("Referer",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7CFEFF98),
    HEADER_ENTRY("Retry-After",                (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xD2881822),
    HEADER_ENTRY("Server",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8244B644),
    HEADER_ENTRY("Title",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AD094CF),
    HEADER_ENTRY("User-Agent",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x968679A8),
    HEADER_ENTRY("WWW-Authenticate",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x21BED5E),
    HEADER_ENTRY("Proxy-Authenticate",         HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBE0F117B),
    HEADER_ENTRY("Accept-Ranges",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC3BF828A),
    HEADER_ENTRY("Set-Cookie",                 HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC704A760),
    HEADER_ENTRY("Cookie",                     HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x5DA54DC7),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Refresh",                    0, 0x7D05EAFC),
    HEADER_ENTRY("Content-Disposition",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDCB6FC4A),
    HEADER_ENTRY("Age",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF607DDA),
    HEADER_ENTRY("Cache-Control",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBBD3B86F),
    HEADER_ENTRY("Content-Base",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8A469ED0),
    HEADER_ENTRY("Content-Location",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xC201A76E),
    HEADER_ENTRY("Content-Md5",                HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xDD672BFB),
    HEADER_ENTRY("Content-Range",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD43BEC42),
    HEADER_ENTRY("Etag",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB72A1CE),
    HEADER_ENTRY("Host",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB74340B),
    HEADER_ENTRY("If-Match",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x971A5776),
    HEADER_ENTRY("If-None-Match",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF6E9D3),
    HEADER_ENTRY("If-Range",                   HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x9774B8F6),
    HEADER_ENTRY("If-Unmodified-Since",        (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0xC946042C),
    HEADER_ENTRY("Max-Forwards",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x3C693EC8),
    HEADER_ENTRY("Proxy-Authorization",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x96A221ED),
    HEADER_ENTRY("Range",                      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x2AA7E69A),
    HEADER_ENTRY("Transfer-Encoding",          HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBD09B166),
    HEADER_ENTRY("Upgrade",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7DAF65B5),
    HEADER_ENTRY("Vary",                       HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xBB7BA5AF),
    HEADER_ENTRY("Via",                        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF60D76D),
    HEADER_ENTRY("Warning",                    HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xF56B7D23),
    HEADER_ENTRY("Expect",                     (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME), 0x62F2EDB6),
    HEADER_ENTRY("Proxy-Connection",           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xD79F12C),
    HEADER_ENTRY("Unless-Modified-Since",      HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x8E53B934),
    HEADER_ENTRY("Ms-Echo-Request",            0, 0xBB7AF4AF),
    HEADER_ENTRY("Ms-Echo-Reply",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xA5326612),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("",                           HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x0),
    HEADER_ENTRY("Proxy-Support",              HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7C4F7F99),
    HEADER_ENTRY("Authentication-Info",        HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xB03F47E6),
    HEADER_ENTRY("PassportURLs",               HTTP_QUERY_FLAG_REQUEST_HEADERS, 0xCF7C676F),
    HEADER_ENTRY("PassportConfig",             HTTP_QUERY_FLAG_REQUEST_HEADERS, 0x7601C9BF),
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\httptime.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    httptime.cxx

Abstract:

    This file contains routines to get various timestamps from an http response
    header.

    We handle only the three standards-mandated date forms, since these are used by
    the vast majority of sites out there on the WWW. Handling additional date forms
    adds to the overhead of these functions, so unless a new form makes headway, we
    will keep these functions simple.

    Contents:
        FGetHttpExpiryTime
        FGetHttpLastModifiedTime
        FParseHttpDate
        FHttpDateTimeToFiletime
        FFileTimetoHttpDateTime
        HttpDateToSystemTime
        HttpTimeFromSystemTime
        (FInternalParseHttpDate)
        (MapDayMonthToDword)

Author:

    Shishir Pardikar (shishirp) 06-Jan-1996

Revision History:

    06-Jan-1996 rfirth
        Created this header

    12-Dec-1997 arthurbi
        Rewrote the date parser to reduce allocs, and other bad stuff.

--*/

#include <wininetp.h>
#include "httpp.h"
#include "httptime.h"

//
// external prototypes
//

/********************* Local data *******************************************/
/******************** HTTP date format strings ******************************/

// Month
static const char cszJan[]="Jan";
static const char cszFeb[]="Feb";
static const char cszMar[]="Mar";
static const char cszApr[]="Apr";
static const char cszMay[]="May";
static const char cszJun[]="Jun";
static const char cszJul[]="Jul";
static const char cszAug[]="Aug";
static const char cszSep[]="Sep";
static const char cszOct[]="Oct";
static const char cszNov[]="Nov";
static const char cszDec[]="Dec";

// DayOfWeek in rfc1123 or asctime format
static const char cszSun[]="Sun";
static const char cszMon[]="Mon";
static const char cszTue[]="Tue";
static const char cszWed[]="Wed";
static const char cszThu[]="Thu";
static const char cszFri[]="Fri";
static const char cszSat[]="Sat";

// List of weekdays for rfc1123 or asctime style date
static const char *rgszWkDay[7] =
   {
        cszSun,cszMon,cszTue,cszWed,cszThu,cszFri,cszSat
   };

// list of month strings for all date formats
static const char *rgszMon[12] =
   {
        cszJan,cszFeb,cszMar,cszApr,cszMay,cszJun,
        cszJul,cszAug,cszSep,cszOct,cszNov,cszDec
   };

/******************** HTTP date format strings ******************************/

/* Http date format: Sat, 29 Oct 1994 19:43:00 GMT */
const char cszHttpDateFmt[]="%s, %02i %s %02i %02i:%02i:%02i GMT";

/****************************************************************************/


/******************************** Local Functions ***************************/

BOOL
FHttpDateTimeToFiletime(
    LPCSTR pcszStr,      // input datetime string
    LPCSTR *rgszWkDay,   // day of week strings
    LPCSTR *rgszMon,     // month strings
    LPCSTR pcszSep,      // seperators
    UINT dateId,         // date format
    FILETIME *lpft       // output filetime in GMT
    );


BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    );


/****************************************************************************/






//+---------------------------------------------------------------------------
//
//  Function: FGetHttpExpiryTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpExpiryTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_EXPIRES, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

//+---------------------------------------------------------------------------
//
//  Function: FGetHttpLastModifiedTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------

BOOL FGetHttpLastModifiedTime(HINTERNET hRequest, FILETIME *lpFt)
   {
        BOOL fRet=FALSE;
   char buff[256];
   DWORD dwBuffLen;

   dwBuffLen = sizeof(buff);
   if (HttpQueryInfo(hRequest, HTTP_QUERY_LAST_MODIFIED, buff, &dwBuffLen, NULL))
      {
      fRet = FParseHttpDate(lpFt, buff);
      }

        return fRet;
   }

DWORD
inline
MapDayMonthToDword(
    LPCSTR lpszDay
    )
/*++

Routine Description:

    Looks at the first three bytes of string to determine if we're looking
        at a Day of the Week, or Month, or "GMT" string.  Is inlined so that
        the compiler can optimize this code into the caller FInternalParseHttpDate.

Arguments:

    lpszDay - a string ptr to the first byte of the string in question.

Return Value:

    DWORD
    Success - The Correct date token, 0-6 for day of the week, 1-14 for month, etc

    Failure - DATE_TOKEN_ERROR

--*/

{
    switch ( MAKE_UPPER(*lpszDay) ) // make uppercase
    {
        case 'A':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'P':
                    return DATE_TOKEN_APRIL;
                case 'U':
                    return DATE_TOKEN_AUGUST;

            }
            return DATE_TOKEN_ERROR;

        case 'D':
            return DATE_TOKEN_DECEMBER;

        case 'F':
            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'R':
                    return DATE_TOKEN_FRIDAY;
                case 'E':
                    return DATE_TOKEN_FEBRUARY;
            }

            return DATE_TOKEN_ERROR;

        case 'G':
            return DATE_TOKEN_GMT;

        case 'M':

            switch ( MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'O':
                    return DATE_TOKEN_MONDAY;
                case 'A':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'R':
                            return DATE_TOKEN_MARCH;
                        case 'Y':
                            return DATE_TOKEN_MAY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;            

        case 'N':
            return DATE_TOKEN_NOVEMBER;

        case 'J':

            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_JANUARY;

                case 'U':
                    switch (MAKE_UPPER(*(lpszDay+2)) )
                    {
                        case 'N':
                            return DATE_TOKEN_JUNE;
                        case 'L':
                            return DATE_TOKEN_JULY;
                    }

                    // fall through to error
            }

            return DATE_TOKEN_ERROR;

        case 'O':
            return DATE_TOKEN_OCTOBER;

        case 'S':
            
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {
                case 'A':
                    return DATE_TOKEN_SATURDAY;
                case 'U':
                    return DATE_TOKEN_SUNDAY;
                case 'E':
                    return DATE_TOKEN_SEPTEMBER;
            }

            return DATE_TOKEN_ERROR;


        case 'T':
            switch (MAKE_UPPER(*(lpszDay+1)) )
            {    
                case 'U':
                    return DATE_TOKEN_TUESDAY;
                case 'H':
                    return DATE_TOKEN_THURSDAY;
            }

            return DATE_TOKEN_ERROR;

        case 'U':
            return DATE_TOKEN_GMT;
            
        case 'W':
            return DATE_TOKEN_WEDNESDAY;

    }

    return DATE_TOKEN_ERROR;
}

BOOL 
FInternalParseHttpDate(
    OUT FILETIME *lpft,
    OUT SYSTEMTIME *lpSysTime,
    IN  LPCSTR lpInputBuffer
    )
/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME/SYSTEMTIME time format.  

    Important this a time-critical function and should only be changed 
     with the intention of optimizing or a critical need work item.

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.
            Must be NULL if not intended to be used !!!

    lpSysTime - Ptr to SYSTEMTIME struture. Used to return Systime if needed.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    int i = 0, iLastLettered = -1;
    BOOL fIsANSIDateFormat = FALSE;
    DWORD rgdwDateParseResults[MAX_DATE_ENTRIES];
    SYSTEMTIME  sSysTime;
    FILETIME    ftTime;
    BOOL fRet = TRUE;

    DEBUG_ENTER((DBG_HTTP,
                Bool,
                "FInternalParseHttpDate",
                "%x %.10q",
                lpft,
                lpInputBuffer
                ));

    //
    // Date Parsing v2 (1 more to go), and here is how it works... 
    //  We take a date string and churn through it once, converting
    //  integers to integers, Month,Day, and GMT strings into integers,
    //  and all is then placed IN order in a temp array. 
    //
    // At the completetion of the parse stage, we simple look at 
    //  the data, and then map the results into the correct 
    //  places in the SYSTIME structure.  Simple, No allocations, and
    //  No dirting the data.   
    //
    // The end of the function does something munging and pretting
    //  up of the results to handle the year 2000, and TZ offsets
    //  Note: do we need to fully handle TZs anymore?
    //

    memset(rgdwDateParseResults, 0, sizeof(rgdwDateParseResults));

    while ( *lpInputBuffer && i < MAX_DATE_ENTRIES)
    {
        if ( *lpInputBuffer >= '0' && *lpInputBuffer <= '9' )
        {
            //
            // we have a numerical entry, scan through it and convent to DWORD
            //

            rgdwDateParseResults[i] = 0;

            do {
                rgdwDateParseResults[i] *= BASE_DEC;
                rgdwDateParseResults[i] += (DWORD) (*lpInputBuffer - '0');
                lpInputBuffer++;
            } while ( *lpInputBuffer && *lpInputBuffer >= '0' && *lpInputBuffer <= '9' );

            i++; // next token
        }
        else if ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
             (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') )
        {
            //
            // we have a string, should be a day, month, or GMT
            //   lets skim to the end of the string
            //
            
            rgdwDateParseResults[i] = 
                MapDayMonthToDword(lpInputBuffer);

            iLastLettered = i;

            // We want to ignore the possibility of a time zone such as PST or EST in a non-standard
            // date format such as "Thu Dec 17 16:01:28 PST 1998" (Notice that the year is _after_ the time zone
            if ((rgdwDateParseResults[i] == DATE_TOKEN_ERROR) 
                && 
                !(fIsANSIDateFormat && (i==DATE_ANSI_INDEX_YEAR)))
            {
                fRet = FALSE;
#ifdef DEBUG
                dprintf("FInternalParseHttpDate: Invalid Date Format, could not parse %s\n", lpInputBuffer);
#endif
                
                goto quit;
            }

            //
            // At this point if we have a vaild string
            //  at this index, we know for sure that we're
            //  looking at a ANSI type DATE format.
            //

            if ( i == DATE_ANSI_INDEX_MONTH )
            {
                fIsANSIDateFormat = TRUE;
            }

            //
            // Read past the end of the current set of alpha characters,
            //  as MapDayMonthToDword only peeks at a few characters
            //

            do {
                lpInputBuffer++;
            } while ( *lpInputBuffer && 
                        ( (*lpInputBuffer >= 'A' && *lpInputBuffer <= 'Z') ||
                          (*lpInputBuffer >= 'a' && *lpInputBuffer <= 'z') ) );

            i++; // next token
        }
        else
        {
            //
            // For the generic case its either a space, comma, semi-colon, etc.
            //  the point is we really don't care, nor do we need to waste time
            //  worring about it (the orginal code did).   The point is we 
            //  care about the actual date information, So we just advance to the 
            //  next lexume.
            //

            lpInputBuffer++;        
        }
    }

    //
    // We're finished parsing the string, now take the parsed tokens
    //  and turn them to the actual structured information we care about.
    //  So we build lpSysTime from the Array, using a local if none is passed in.
    //

    if ( lpSysTime == NULL )
    {
        lpSysTime = &sSysTime;
    }

    lpSysTime->wDayOfWeek    = (WORD)rgdwDateParseResults[DATE_INDEX_DAY_OF_WEEK];
    lpSysTime->wMilliseconds =  0;

    if ( fIsANSIDateFormat )
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MONTH];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_SECS];
        if (iLastLettered != DATE_ANSI_INDEX_YEAR)
        {
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_ANSI_INDEX_YEAR];
        }
        else
        {
            // Warning! This is a hack to get around the toString/toGMTstring fiasco (where the timezone is
            // appended at the end. (See above)
            lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_INDEX_TZ];
         }
    }
    else
    {
        lpSysTime->wDay    = (WORD)rgdwDateParseResults[DATE_1123_INDEX_DAY];
        lpSysTime->wMonth  = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MONTH];
        lpSysTime->wYear   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_YEAR];
        lpSysTime->wHour   = (WORD)rgdwDateParseResults[DATE_1123_INDEX_HRS];
        lpSysTime->wMinute = (WORD)rgdwDateParseResults[DATE_1123_INDEX_MINS];
        lpSysTime->wSecond = (WORD)rgdwDateParseResults[DATE_1123_INDEX_SECS];
    }

    //
    // Normalize the year, 90 == 1990, handle the year 2000, 02 == 2002
    //  This is Year 2000 handling folks!!!  We get this wrong and 
    //  we all look bad. 
    //

    if (lpSysTime->wYear < 100) {
        lpSysTime->wYear += ((lpSysTime->wYear < 80) ? 2000 : 1900);
    }

    //
    // if we got misformed time, then plug in the current time
    // !lpszHrs || !lpszMins || !lpszSec
    //

    if ( i < 4) 
    {
        SYSTEMTIME  sCurSysTime;

        // this is a bad date; logging.
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));

        GetSystemTime(&sCurSysTime);

        if ( i < 2 )
        {
            //
            // If we really messed up the parsing, then
            //  just use the current time. 
            //

            *lpSysTime = sCurSysTime;
        }
        else
        {
            lpSysTime->wHour = sCurSysTime.wHour;
            lpSysTime->wMinute = sCurSysTime.wMinute;
            lpSysTime->wSecond = sCurSysTime.wSecond;
        }
    }


    if ((lpSysTime->wDay > 31)
    || (lpSysTime->wHour > 23)
    || (lpSysTime->wMinute > 59)
    || (lpSysTime->wSecond > 59)) 
    {
        fRet = FALSE;
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
        goto quit;
    }

    // Hack: we want the system time to be accurate. This is _suhlow_
    // The time passed in is in the local time zone; we have to convert this into GMT.
    
    if (iLastLettered==DATE_ANSI_INDEX_YEAR)
    {
        i--;
        
        FILETIME ft1, ft2;

        fRet = 
            SystemTimeToFileTime(lpSysTime, &ft1);

        if (fRet)
        {
            fRet = LocalFileTimeToFileTime(&ft1, &ft2);
            if (fRet)
            {
                fRet = FileTimeToSystemTime(&ft2, lpSysTime);
            }

        }
        
        if (!fRet)
        {
            DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
            goto quit;
        }
    }


    //
    // If FILETIME Ptr passed in/or we have an Offset to another Time Zone
    //   then convert to FILETIME for necessity/convenience
    //

    if ( lpft ||
         (i > DATE_INDEX_TZ &&
          rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT))
    {

        if ( lpft == NULL )
        {
            lpft = &ftTime;
        }

        fRet = 
            SystemTimeToFileTime(lpSysTime, lpft);

        if ( ! fRet )
        {
           DEBUG_PRINT(HTTP,
                    INFO,
                    ("*** Received a malformed date: %s\n", lpInputBuffer
                    ));
           goto quit;
        }

        if (i > DATE_INDEX_TZ &&
            rgdwDateParseResults[DATE_INDEX_TZ] != DATE_TOKEN_GMT) 
        {
            // time zones are a very expensive operation, I want to know if this is a common case.
            DEBUG_PRINT(HTTP,
                        INFO,
                        ("*** Received a time zone: %d\n", (int) rgdwDateParseResults[DATE_INDEX_TZ]
                        ));

            //
            // if we received +/-nnnn as offset (hhmm), modify the output FILETIME
            //

            LONGLONG delta;
            BOOL negative;
            int offset;

            offset = (int) rgdwDateParseResults[DATE_INDEX_TZ];

            //
            // BUGBUG - some sites return +0000 instead of GMT. Presumably, this is
            //          an offset from GMT (== 0). What are the units? What are the
            //          boundaries (-12 hours to +12 hours? In seconds? (43200
            //          seconds in 12 hours, so can't be this)
            //

            //
            // BUGBUG - must handle negatives...and (-1 == GMT)
            //

            if (offset < 0) {
                negative = TRUE;
                offset = -offset;
            } else {
                negative = FALSE;
            }

            //
            // hours and minutes as 100nSec intervals
            //

            delta = (((offset / 100) * 60)
                    + (offset % 100)) * 60 * 10000000;
            if (negative) {
                delta = -delta;
            }
            AddLongLongToFT(lpft,delta);

            //
            // Chk to see if we Need to turn the offseted 
            //   FILETIME back into SYSTEMTIME.
            //

            if ( lpSysTime == &sSysTime )
            {
                fRet = FileTimeToSystemTime(lpft, lpSysTime);
            }
        }
    }

quit:

    DEBUG_LEAVE(fRet);

    return fRet;
}

PUBLIC 
BOOL 
FParseHttpDate(
    OUT FILETIME *lpft,
    IN  LPCSTR lpInputBuffer
    )

/*++

Routine Description:

    Parses through a ANSI, RFC850, or RFC1123 date format and covents it into
     a FILETIME time format.  

Arguments:

    lpft - Ptr to FILETIME structure.  Used to store converted result.

    lpcszDateStr - Const Date string to parse.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    return FInternalParseHttpDate(
                lpft,                
                NULL, // SYSTEMTIME
                lpInputBuffer
                );
}



//+---------------------------------------------------------------------------
//
//  Function: FFileTimetoHttpDateTime
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns: TRUE if successful. lpft contains the datetime in FILETIME format
//
//
//  Notes:
//
//
//----------------------------------------------------------------------------
BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    )
{
    SYSTEMTIME  sSysTime;

    INET_ASSERT (*lpdwSize >= HTTP_DATE_SIZE);

    if (FileTimeToSystemTime(lpft, &sSysTime)) {
        *lpdwSize = wsprintf(lpszBuff, cszHttpDateFmt
                , rgszWkDay[sSysTime.wDayOfWeek]
                , sSysTime.wDay
                , rgszMon[sSysTime.wMonth-1]
                , sSysTime.wYear
                , sSysTime.wHour
                , sSysTime.wMinute
                , sSysTime.wSecond);
        return (TRUE);
    }
    return (FALSE);
}


BOOL
HttpDateToSystemTime(
    IN LPSTR lpszHttpDate,
    OUT LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    Takes a HTTP time/date string of the format "Sat, 6 Jan 1996 21:22:04 GMT"
    and converts it to a SYSTEMTIME structure

Arguments:

    lpszHttpDate    - pointer to time string to convert

    lpSystemTime    - pointer to converted time

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string

--*/

{
    return FInternalParseHttpDate(
                NULL, // FILETIME               
                lpSystemTime, 
                (LPCSTR)lpszHttpDate
                );
}


INTERNETAPI_(BOOL) InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    dwRFC:  RFC number of the format in which the result string should be returned

    lpszTime: buffer to return the string in

    cbTime: size of lpszTime buffer

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%#x, %d, %#x, %d",
                     pst,
                     dwRFC,
                     lpszTime,
                     cbTime
                     ));

    DWORD dwErr;
    BOOL fResult = FALSE;
    FILETIME ft;
    
    if (   dwRFC != INTERNET_RFC1123_FORMAT
        || IsBadReadPtr (pst, sizeof(*pst))
        || IsBadWritePtr (lpszTime, cbTime)
        || !SystemTimeToFileTime(pst, &ft)
       )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    } 
    else if (cbTime < INTERNET_RFC1123_BUFSIZE)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        SYSTEMTIME st;
        
        if ((pst->wDay < 0)
            || (pst->wDay > 6))
        {
            // ST2FT ignores the week of the day; so if we round trip back,
            // it should place the correct week of the day.
            FileTimeToSystemTime(&ft, &st);
            pst = &st;
        }

        wsprintf (lpszTime, cszHttpDateFmt,
            rgszWkDay[pst->wDayOfWeek],
            pst->wDay,
            rgszMon[pst->wMonth-1],
            pst->wYear,
            pst->wHour,
            pst->wMinute,
            pst->wSecond);
        fResult = TRUE;
    }

    if (!fResult)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(BOOL) InternetTimeToSystemTimeA(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

    dwreserved          - Reserved

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%q, %#x, %#x",
                     lpcszTimeString,
                     lpSysTime,
                     dwReserved
                     ));
    BOOL fRet = FALSE;;
    DWORD dwErr;

    if (IsBadWritePtr (lpSysTime, sizeof(*lpSysTime)) ||
        IsBadStringPtr(lpcszTimeString, 0xffff))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        fRet = FInternalParseHttpDate(NULL, lpSysTime, (LPCSTR)lpcszTimeString);
        if (!fRet)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    if (!fRet)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fRet);
    return (fRet);
}

INTERNETAPI_(BOOL) InternetTimeFromSystemTimeW(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPWSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    dwRFC:  RFC number of the format in which the result string should be returned

    lpszTime: buffer to return the string in

    cbTime: size of lpszTime buffer in bytes

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeW",
                     "%#x, %d, %#x, %d",
                     pst,
                     dwRFC,
                     lpszTime,
                     cbTime
                     ));

    DWORD dwErr = ERROR_SUCCESS;;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;
    DWORD ccSize;
    
    if (!(cbTime >= INTERNET_RFC1123_BUFSIZE*sizeof(WCHAR)))
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        goto cleanup;
    }
    if (!lpszTime)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpTime.psStr = (LPSTR)ALLOC_BYTES(cbTime);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpTime.dwAlloc = cbTime;
    
    fResult = InternetTimeFromSystemTimeA(pst, dwRFC, mpTime.psStr, cbTime);

    if (fResult)
    {
        ccSize = MultiByteToWideChar(CP_ACP, 0, mpTime.psStr, -1, NULL, 0);
        if (cbTime<=ccSize*sizeof(WCHAR))
        {
            fResult = FALSE;
            dwErr = ERROR_INSUFFICIENT_BUFFER;;
        }
        else
        {
            MultiByteToWideChar(CP_ACP, 0, mpTime.psStr, -1, lpszTime, cbTime/sizeof(WCHAR));
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(BOOL) InternetTimeToSystemTimeW(
    IN  LPCWSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
)
/*++

Routine Description:

    API. Takes a HTTP time/date string of the formats that we deal with
    and converts it to a SYSTEMTIME structure

Arguments:

    lpcszTimeString     - pointer to a null terminated date/time string to convert

    lpSysTime           - pointer to converted time

    dwreserved          - Reserved

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeW",
                     "%wq, %#x, %#x",
                     lpcszTimeString,
                     lpSysTime,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpTime;

    if (!lpcszTimeString)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpcszTimeString, 0, mpTime);
    if (!mpTime.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(lpcszTimeString, mpTime);
    fResult = InternetTimeToSystemTimeA(mpTime.psStr, lpSysTime, dwReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\makeconn.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    makeconn.cxx

Abstract:

    This file contains the MakeConnection method

    Contents:
        CFsm_MakeConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_MakeConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_MakeConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_MakeConnection * stateMachine = (CFsm_MakeConnection *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->MakeConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm(
    IN CFsm_MakeConnection * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::MakeConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(MakeConnection_Fsm);

    CFsm_MakeConnection & fsm = *Fsm;
    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    if (state == FSM_STATE_INIT) {
        if (GetAuthState() == AUTHSTATE_NEEDTUNNEL) {
            state = FSM_STATE_1;
        } else if (IsTalkingToSecureServerViaProxy()) {
            state = FSM_STATE_3;
        } else {
            state = FSM_STATE_6;
        }
    } else {
        state = fsm.GetFunctionState();
    }
    switch (state) {
    case FSM_STATE_1:

        //
        // If we're attempting to do NTLM authentication using Proxy tunnelling
        // and we don't have a keep-alive socket to use, then create one
        //

        if (!(IsWantKeepAlive() && (_Socket != NULL) && _Socket->IsOpen())) {

            DEBUG_PRINT(
                HTTP,
                INFO,
                ("opening proxy tunnel for authentication on socket %#x", _Socket->GetSocket())
                );

            fsm.SetFunctionState(FSM_STATE_2);
            error = OpenProxyTunnel();
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
                goto quit;
            }
        } else {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_2:
        if ((error != ERROR_SUCCESS)
        || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        if (_Socket->IsSecure()) {
            /* SCLE ref */
            error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }

        //
        // Undo the proxy-ified info found in this Request Object, make it seem like
        //  we're doing a connect connection, since we're about to do something like it
        //  ( a tunnelled connection through the firewall )
        //

        error = SetServerInfo(INTERNET_SCHEME_HTTP, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        LPSTR urlPath;
        DWORD urlPathLength;

        //
        // get URL-path again if it was changed during tunnel creation
        //

        error = CrackUrl(GetURL(),
                     lstrlen(GetURL()),
                     FALSE, // don't escape URL-path
                     NULL,  // don't care about scheme type
                     NULL,  // or scheme name
                     NULL,  // or scheme name length
                     NULL,  // or host name
                     NULL,  // or host name length
                     NULL,  // or port
                     NULL,  // or user name
                     NULL,  // or user name length
                     NULL,  // or password
                     NULL,  // or password length
                     &urlPath,
                     &urlPathLength,
                     NULL,  // don't care about extra
                     NULL,  // or extra length
                     NULL
                     );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        LockHeaders();

        ModifyRequest(HTTP_METHOD_TYPE_GET,
                      urlPath,
                      urlPathLength,
                      NULL,
                      0
                      );

        UnlockHeaders();

        //SetProxyNTLMTunnelling(FALSE);
        SetRequestUsingProxy(FALSE);             // don't generate proxy stuff.
        break;

    case FSM_STATE_3:

        //
        // Hack for SSL2 Client Hello bug in IIS Servers.
        //  Need to ReOpen connection after failure with
        //  a Client Hello Message.
        //

        if (_Socket != NULL) {
            ((ICSecureSocket *)_Socket)->SetProviderIndex(0);
        }

attempt_ssl_connect:

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_4);
        error = OpenProxyTunnel();
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_4:
        if ((error != ERROR_SUCCESS) || (GetStatusCode() != HTTP_STATUS_OK)) {
            goto quit;
        }

        //
        // Bind Socket Object with Proper HostName,
        //  so we can check for valid common name
        //  in the handshake.
        //

        INET_ASSERT(_Socket->IsSecure());

        /* SCLE ref */
        error = ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if the app wants a secure channel (PCT/SSL) then we must negotiate
        // the security here
        //

        //
        // dwProviderIndex will be managed by SecureHandshakeWithServer,
        // And will be set to 0 when we can't try anymore.
        //

        DWORD asyncFlags;

        //
        // find out if we're async. N.B. see Assumes
        //

        asyncFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;

        //
        // If we're Posting or sending data, make sure
        //  the SSL connection knows about it, for the
        //  purposes of generating errors.
        //

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
        || (GetMethodType() == HTTP_METHOD_TYPE_PUT)) {
            asyncFlags |= SF_SENDING_DATA;
        }

        fsm.SetFunctionState(FSM_STATE_5);
        error = ((ICSecureSocket *)_Socket)->SecureHandshakeWithServer(
                                                (asyncFlags | SF_ENCRYPT),
                                                &fsm.m_bAttemptReconnect);
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

        //
        // fall through
        //

    case FSM_STATE_5:
        if (error != ERROR_SUCCESS) {

            if (error == ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED)
            {
                if (_Socket->IsSecure())
                {
                    if(m_pSecurityInfo)
                    {
                        /* SCLE ref */
                        m_pSecurityInfo->Release();
                    }
                    /* SCLE ref */
                    m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                }
            }

            //
            // we disconnected the socket and we won't attempt to reconnect. We
            // need to release the connection to balance the connection limiter
            //

            if (!fsm.m_bAttemptReconnect) {
                ReleaseConnection(TRUE,     // bClose
                                  FALSE,    // bIndicate
                                  TRUE      // bDispose
                                  );
            }
            else
            {
                _Socket->SetLinger(FALSE, 0);
                _Socket->Disconnect(); // close socket.
            }
        }

        //
        // SSL2 hack for old IIS servers.
        //  We re-open the socket, and call again.
        //

        if (fsm.m_bAttemptReconnect) {
            goto attempt_ssl_connect;
        }
        break;

    case FSM_STATE_6:
        fsm.SetFunctionState(FSM_STATE_7);
        error = OpenConnection(FALSE, FALSE);
        if (error == ERROR_IO_PENDING) {
            break;
        }

    case FSM_STATE_7:
//dprintf("HTTP connect took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        //hack
        if (error == ERROR_SUCCESS &&
            _Socket &&
            _Socket->IsSecure() &&
            m_pSecurityInfo == NULL
            )
        {
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
        }
        break;

    default:

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
//        PERF_LEAVE(MakeConnection_Fsm);

    }
        PERF_LEAVE(MakeConnection_Fsm);

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\proc.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    This file contains global procedure declarations for the HTTP API
    project.

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/


#ifndef _PROC_H_
#define _PROC_H_

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>

DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    );

BOOL FParseHttpDate(
    FILETIME *lpFt,
    LPCSTR lpcszDateStr
    );

BOOL FFileTimetoHttpDateTime(
    FILETIME *lpft,       // output filetime in GMT
    LPSTR   lpszBuff,
    LPDWORD lpdwSize
    );

#if defined(__cplusplus)
}
#endif

#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\open.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    open.cxx

Abstract:

    This file contains the implementation of the HttpOpenRequestA API.

    The following functions are exported by this module:

        HttpOpenRequestA
        HttpOpenRequestW
        ParseHttpUrl
        ParseHttpUrl_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpOpenRequestA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


BOOL IsInappropriateHTTPPort (INTERNET_PORT port)
/*++
Routine Description:
The following outgoing ports should be blocked for HTTP:
21 - FTP,25 - SMTP,110 - POP3,119 - NNTP,143 - IMAP
Arguments: Port number
Return Value: TRUE- Need to be blocked
			  FALSE-Not to be blocked
--*/
{
    if (port > INTERNET_MAX_WELL_KNOWN_PORT)
        return FALSE;
    switch (port) {
        case INTERNET_INVALID_PORT_NUMBER:
        case INTERNET_DEFAULT_FTP_PORT:
        case INTERNET_DEFAULT_SMTP_PORT:
        case INTERNET_DEFAULT_POP3_PORT:
        case INTERNET_DEFAULT_NNTP_PORT:
        case INTERNET_DEFAULT_IMAP_PORT:
            return TRUE;
        default:
            return FALSE;
    }
}



INTERNETAPI_(HINTERNET) HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb OPTIONAL,
    IN LPCSTR lpszObjectName OPTIONAL,
    IN LPCSTR lpszVersion OPTIONAL,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hConnect            - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request. May be NULL in which
                          case "GET" will be used

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier. May be NULL in which case the empty
                          string will be used

    lpszVersion         - The version string for the request. May be NULL in
                          which case "HTTP/1.0" will be used

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    dwContext           - app-supplied context value for call-backs

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    HINTERNET

        Success - non-NULL (open) handle to an HTTP request

        Failure - NULL. Error status is available by calling GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "HttpOpenRequestA",
                     "%#x, %.80q, %.80q, %.80q, %.80q, %#x, %#08x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags,
                     dwContext
                     ));

    DWORD error;
    HINTERNET hConnectMapped = NULL;
    BOOL fRequestUsingProxy;
    HINTERNET hRequest = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // find path from internet handle and validate handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hConnectMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpConnectHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters. Allow lpszVerb to default to "GET" if a NULL pointer
    // is supplied
    //

    if (!ARGUMENT_PRESENT(lpszVerb) || (*lpszVerb == '\0')) {
        lpszVerb = DEFAULT_HTTP_REQUEST_VERB;
    }

    //
    // if a NULL pointer or empty string is supplied for the object name, then
    // convert to the default object name (root object)
    //

    if (!ARGUMENT_PRESENT(lpszObjectName) || (*lpszObjectName == '\0')) {
        lpszObjectName = "/";
    }

    //
    // check the rest of the parameters
    //


    if (dwFlags & ~INTERNET_FLAGS_MASK) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // default to the current supported version
    //

    char versionBuffer[sizeof("HTTP/4294967295.4294967295")];
    DWORD verMajor;
    DWORD verMinor;

    if (!ARGUMENT_PRESENT(lpszVersion) || (*lpszVersion == '\0')) {
        wsprintf(versionBuffer,
                 "HTTP/%d.%d",
                 HttpVersionInfo.dwMajorVersion,
                 HttpVersionInfo.dwMinorVersion
                 );
        lpszVersion = versionBuffer;
        verMajor = HttpVersionInfo.dwMajorVersion;
        verMinor = HttpVersionInfo.dwMinorVersion;
    } else if (strnicmp(lpszVersion, "HTTP/", sizeof("HTTP/") - 1) == 0) {

        LPSTR p = (LPSTR)lpszVersion + sizeof("HTTP/") - 1;

        ExtractInt(&p, 0, (LPINT)&verMajor);
        while (!isdigit(*p) && (*p != '\0')) {
            ++p;
        }
        ExtractInt(&p, 0, (LPINT)&verMinor);
    } else {
        verMajor = 1;
        verMinor = 0;
    }

    //
    // if we have HTTP 1.1 enabled in the registry and the version is < 1.1
    // then convert
    //

    if (GlobalEnableHttp1_1
    && (((verMajor == 1) && (verMinor == 0)) || (verMajor < 1))) {
        lpszVersion = "HTTP/1.1";
    }

    //
    // allow empty strings to be equivalent to NULL pointer
    //

    if (ARGUMENT_PRESENT(lpszReferrer) && (*lpszReferrer == '\0')) {
        lpszReferrer = NULL;
    }

    //
    // if the caller has specified CERN proxy access then we convert the
    // object request to the URL that the CERN proxy will use
    //

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    INTERNET_HANDLE_OBJECT * pInternet;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT hostPort;
    BOOL isProxy;
    INTERNET_SCHEME schemeType;
    BOOL bSchemeChanged;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped;
    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    hostName = pConnect->GetHostName(&hostNameLength);
    hostPort = pConnect->GetHostPort();
    isProxy = pConnect->GetServerInfo()->IsCernProxy();
    schemeType = pConnect->GetSchemeType();

    // WinSe Bug 21109- Security: Block http access to ports: 21, 25, 110, 119 and 143
    if(schemeType == INTERNET_SCHEME_HTTP && IsInappropriateHTTPPort(hostPort))
    {
        error = ERROR_INTERNET_INVALID_URL;
        goto quit;
    }

    //
    // set the per-thread info: parent handle object and context value
    //

    _InternetSetObjectHandle(lpThreadInfo, hConnect, hConnectMapped);
    _InternetSetContext(lpThreadInfo, dwContext);

    //
    // make local HTTP request handle object before we can add headers to it
    //

    error = RMakeHttpReqObjectHandle(hConnectMapped,
                                     &hRequest,
                                     NULL,  // (CLOSE_HANDLE_FUNC)wHttpCloseRequest
                                     dwFlags,
                                     dwContext
                                     );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if the scheme type changed and we are going via proxy, get the SERVER_INFO
    // for the new proxy (if we changed it). N.B. We ONLY change the proxy for
    // this request object, NOT for the connect object
    //

    //if (isProxy && bSchemeChanged) {
    //    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->SetServerInfo(schemeType);
    //}

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    //
    // add the request line
    //

    INET_ASSERT((lpszVerb != NULL) && (*lpszVerb != '\0'));
    INET_ASSERT((lpszObjectName != NULL) && (*lpszObjectName != '\0'));
    INET_ASSERT((lpszVersion != NULL) && (*lpszVersion != '\0'));

    pRequest->LockHeaders();

    //
    // encode the URL-path
    //

    error = pRequest->AddRequest((LPSTR)lpszVerb,
                                 (LPSTR)lpszObjectName,
                                 (LPSTR)lpszVersion
                                 );
    if (error != ERROR_SUCCESS) {
        pRequest->UnlockHeaders();
        goto quit;
    }

    //
    // set the method type from the verb
    //

    pRequest->SetMethodType(lpszVerb);

    //
    // add the headers
    //

    if (lpszReferrer != NULL) {
        error = pRequest->AddRequestHeader(HTTP_QUERY_REFERER,
                                           (LPSTR)lpszReferrer,
                                           lstrlen(lpszReferrer),
                                           0,
                                           CLEAN_HEADER
                                           );
        if (error != ERROR_SUCCESS) {
            pRequest->UnlockHeaders();
            goto quit;
        }
    }

    if (lplpszAcceptTypes != NULL) {
        while (*lplpszAcceptTypes) {
            error = pRequest->AddRequestHeader(HTTP_QUERY_ACCEPT,
                                               (LPSTR)*lplpszAcceptTypes,
                                               lstrlen(*(LPSTR*)lplpszAcceptTypes),
                                               0,
                                               CLEAN_HEADER | COALESCE_HEADER_WITH_COMMA
                                               );
            if (error != ERROR_SUCCESS) {
                pRequest->UnlockHeaders();
                goto quit;
            }
            ++lplpszAcceptTypes;
        }
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    pRequest->UnlockHeaders();

    //
    // change the object state to opened
    //

    pRequest->SetState(HttpRequestStateOpen);
    ((HTTP_REQUEST_HANDLE_OBJECT *)hRequest)->SetRequestUsingProxy(
                                                    FALSE
                                                    );

    switch (pRequest->GetMethodType()) {
    case HTTP_METHOD_TYPE_GET:
    case HTTP_METHOD_TYPE_POST:
        break;

    default:
        dwFlags |= (INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE);
        break;
    }

    switch (GlobalCacheMode)
    {
        case CACHEMODE_REFRESH:
            dwFlags |= INTERNET_FLAG_RESYNCHRONIZE;
            break;

        case CACHEMODE_BYPASS:
            dwFlags |= INTERNET_FLAG_RELOAD;
            break;
            
        case CACHEMODE_NORMAL:
        default:
            break;
    }

    pRequest->SetCacheFlags(dwFlags);

    //
    // if the object name is not set then all cache methods fail
    //

    URLGEN_FUNC fn;

    fn = (URLGEN_FUNC)pHttpGetUrlString;

    //
    // BUGBUG - change prototype to take LPCSTR
    //

    error = pRequest->SetObjectName((LPSTR)lpszObjectName,
                                    NULL,
                                    &fn
                                    );

    //
    // Record whether the original object was empty ("") or slash ("/")
    //

    if (lpszObjectName[0] == '/' &&
        lpszObjectName[1] == 0x00 ) {
        pRequest->SetObjectRoot();
    }

quit:

    _InternetDecNestingCount(1);

done:

    if (error != ERROR_SUCCESS) {
        if (hRequest != NULL) {
            InternetCloseHandle(((HANDLE_OBJECT *)hRequest)->GetPseudoHandle());
        }

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        hRequest = NULL;
    } else {

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hRequest = ((HANDLE_OBJECT *)hRequest)->GetPseudoHandle();
    }

    if (hConnectMapped != NULL) {
        DereferenceObject((LPVOID)hConnectMapped);
    }

    DEBUG_LEAVE_API(hRequest);

    return hRequest;
}


INTERNETAPI_(HINTERNET) HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates a new HTTP request handle and stores the specified parameters
    in that context.

Arguments:

    hHttpSession        - An open Internet handle returned by InternetConnect()

    lpszVerb            - The verb to use in the request

    lpszObjectName      - The target object for the specified verb. This is
                          typically a file name, an executable module, or a
                          search specifier

    lpszVersion         - The version string for the request

    lpszReferrer        - Specifies the address (URI) of the document from
                          which the URI in the request (lpszObjectName) was
                          obtained. May be NULL in which case no referer is
                          specified

    lplpszAcceptTypes   - Points to a NULL-terminated array of LPCTSTR pointers
                          to content-types accepted by the client. This value
                          may be NULL in which case the default content-type
                          (text/html) is used

    dwFlags             - open options

    dwContext           - app-supplied context value for call-backs

    BUGBUG: WHAT IS THE DEFAULT CONTENT-TRANSFER-ENCODING?

Return Value:

    !NULL - An open handle to an HTTP request.

    NULL - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "HttpOpenRequestW",
                     "%#x, %.80wq, %.80wq, %.80wq, %.80wq, %#x, %#08x, %#08x",
                     hConnect,
                     lpszVerb,
                     lpszObjectName,
                     lpszVersion,
                     lpszReferrer,
                     lplpszAcceptTypes,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpVerb, mpObjectName, mpVersion, mpReferrer;
    MEMORYPACKETTABLE mptAcceptTypes;

    if (lpszVerb)
    {
        ALLOC_MB(lpszVerb,0,mpVerb);
        if (!mpVerb.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVerb,mpVerb);
    }
    if (lpszObjectName)
    {
        ALLOC_MB(lpszObjectName,0,mpObjectName);
        if (!mpObjectName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszObjectName,mpObjectName);
    }
    if (lpszVersion)
    {
        ALLOC_MB(lpszVersion,0,mpVersion);
        if (!mpVersion.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszVersion,mpVersion);
    }
    if (lpszReferrer)
    {
        ALLOC_MB(lpszReferrer,0,mpReferrer);
        if (!mpReferrer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszReferrer,mpReferrer);
    }

    // Create a table of ansi strings
    if (lplpszAcceptTypes)
    {
        WORD csTmp=0;
        for (;lplpszAcceptTypes[csTmp];csTmp++);
        mptAcceptTypes.SetUpFor(csTmp);
        for (WORD ce=0; ce < csTmp; ce++)
        {
            mptAcceptTypes.pdwAlloc[ce] = (lstrlenW(lplpszAcceptTypes[ce]) + 1)*sizeof(WCHAR);
            mptAcceptTypes.ppsStr[ce] = (LPSTR)ALLOC_BYTES(mptAcceptTypes.pdwAlloc[ce]*sizeof(CHAR));
            if (!mptAcceptTypes.ppsStr[ce])
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            mptAcceptTypes.pdwSize[ce] = WideCharToMultiByte(CP_ACP,
                                                                0,
                                                                lplpszAcceptTypes[ce],
                                                                mptAcceptTypes.pdwAlloc[ce]/sizeof(WCHAR),
                                                                mptAcceptTypes.ppsStr[ce],
                                                                mptAcceptTypes.pdwAlloc[ce],NULL,NULL);
        }
    }

    hInternet = HttpOpenRequestA(hConnect, mpVerb.psStr, mpObjectName.psStr, mpVersion.psStr,
                               mpReferrer.psStr, (LPCSTR*)mptAcceptTypes.ppsStr,
                               dwFlags, dwContext);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


DWORD
ParseHttpUrl(
    IN OUT LPHINTERNET phInternet,
    IN LPSTR lpszUrl,
    IN DWORD dwSchemeLength,
    IN LPSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    URL parser for HTTP URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls HTTP APIs to
    do the work

Arguments:

    phInternet      - IN: InternetOpen() handle
                      OUT: if successful HttpOpenRequest(), else undefined

    lpszUrl         - pointer to string containing HTTP URL to open

    dwSchemeLength  - length of the URL scheme, exluding "://"

    lpszHeaders     - additional HTTP headers

    dwHeadersLength - length of Headers

    dwFlags         - optional flags for opening a file (cache/no-cache, etc.)

    dwContext       - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ParseHttpUrl",
                 "%#x [%#x], %q, %d, %.80q, %d, %08x, %08x",
                 phInternet,
                 *phInternet,
                 lpszUrl,
                 dwSchemeLength,
                 lpszHeaders,
                 dwHeadersLength,
                 dwFlags,
                 dwContext
                 ));

    INET_ASSERT(GlobalDataInitialized);

    DWORD error = DoFsm(new CFsm_ParseHttpUrl(phInternet,
                                              lpszUrl,
                                              dwSchemeLength,
                                              lpszHeaders,
                                              dwHeadersLength,
                                              dwFlags,
                                              dwContext
                                              ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ParseHttpUrl_Fsm(
    IN CFsm_ParseHttpUrl * Fsm
    )

/*++

Routine Description:

    Run next ParseHttpUrl state. Note this FSM has no RunSM(). Since there is
    no object to instantiate, we don't need one

Arguments:

    Fsm - pointer to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "ParseHttpUrl_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ParseHttpUrl & fsm = *Fsm;
    DWORD error = fsm.GetError();
    BOOL success;

    if (fsm.IsInvalid()) {
        goto quit;
    }

    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        goto parse_continue;
    }

    LPSTR userName;
    DWORD userNameLength;
    LPSTR password;
    DWORD passwordLength;
    LPSTR pHostName;
    DWORD hostNameLength;
    DWORD urlLength;
    INTERNET_PORT port;
    LPSTR schemeName;

    //
    // new scheme - we now pass in the entire URL, so find the start of the
    // address info again. Keep a pointer to the scheme (may be different than
    // http:// if going via proxy); we already know the scheme length from the
    // parameters
    //

    schemeName = fsm.m_lpszUrl;
    fsm.m_lpszUrl += fsm.m_dwSchemeLength + sizeof("://") - 1;

    //
    // extract the address information - no user name or password
    //

    error = GetUrlAddress(&fsm.m_lpszUrl,
                          &urlLength,
                          &userName,
                          &userNameLength,
                          &password,
                          &passwordLength,
                          &pHostName,
                          &hostNameLength,
                          &port,
                          NULL
                          );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if we got user name & password, convert them to zero-terminated strings.
    // The URL is a copy, so we can write into it, and the characters that
    // terminate user name & password (@ & : resp) are not significant
    //

    if (userName != NULL) {
        userName[userNameLength] = '\0';
    }
    if (password != NULL) {
        password[passwordLength] = '\0';
    }

    //
    // get the HTTP object path - decode any escape sequences
    //

    //if (*Url != '\0') {
    //
    //    INET_ASSERT((int)urlLength > 0);
    //
    //    error = DecodeUrlStringInSitu(Url, &urlLength);
    //    if (error != ERROR_SUCCESS) {
    //        goto quit;
    //    }
    //}

    //
    // convert the host name pointer and length to an ASCIIZ string
    //

    char hostName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    DWORD len;

    len = (DWORD)min(hostNameLength, sizeof(hostName) - 1);
    memcpy(hostName, pHostName, len);
    hostName[len] = '\0';

    //
    // make the GET request
    //

    HINTERNET hConnect;
    HINTERNET hRequest;

    fsm.m_hConnect = NULL;
    fsm.m_hRequest = NULL;

    //
    // if there is no port specified and we're sending an FTP or gopher request
    // then we have to map the port, or else we will try to use the HTTP port
    // (80)
    //

    INTERNET_SCHEME scheme;

    scheme = MapUrlSchemeName(schemeName, fsm.m_dwSchemeLength);
    if (port == INTERNET_INVALID_PORT_NUMBER) {
        switch (scheme) {
        case INTERNET_SCHEME_FTP:
            port = INTERNET_DEFAULT_FTP_PORT;
            break;

        case INTERNET_SCHEME_GOPHER:
            port = INTERNET_DEFAULT_GOPHER_PORT;
            break;
        }
    }

    fsm.m_hConnect = InternetConnect(*fsm.m_phInternet,
                                     hostName,
                                     port,
                                     userName,
                                     password,
                                     INTERNET_SERVICE_HTTP,

                                     //
                                     // we can ignore EXISTING_CONNECT for HTTP
                                     // connect handle objects
                                     //

                                     fsm.m_dwFlags & ~INTERNET_FLAG_EXISTING_CONNECT,

                                     //
                                     // we are creating a "hidden" handle - don't
                                     // tell the app about it
                                     //

                                     INTERNET_NO_CALLBACK
                                     );
    if (fsm.m_hConnect != NULL) {

        //
        // set the real scheme type. e.g. we may be performing a CERN proxy
        // request for an FTP site, in which case the real scheme type is FTP
        //

        HINTERNET hConnectMapped;

        error = MapHandleToAddress(fsm.m_hConnect, (LPVOID *)&hConnectMapped, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        ((INTERNET_CONNECT_HANDLE_OBJECT *)hConnectMapped)->SetSchemeType(scheme);

        DereferenceObject((LPVOID)hConnectMapped);

        //
        // create the request object. Both proxy and non-proxy paths submit only
        // the URL-path
        //

        //
        // BUGBUG - this should be fixed in java download code!
        //
        // java downloads (synchronous) are requesting INTERNET_FLAG_EXISTING_CONNECT
        // when they really want INTERNET_FLAG_KEEP_CONNECTION
        //

        if (fsm.m_dwFlags & INTERNET_FLAG_EXISTING_CONNECT) {
            fsm.m_dwFlags |= INTERNET_FLAG_KEEP_CONNECTION;
        }
        fsm.m_hRequest = HttpOpenRequest(fsm.m_hConnect,
                                         NULL,    // default verb is GET
                                         fsm.m_lpszUrl,
                                         NULL,    // default version is HTTP/1.0
                                         NULL,    // default referrer
                                         NULL,    // default accept encodings
                                         fsm.m_dwFlags,
                                         fsm.m_dwContext
                                         );
        if (fsm.m_hRequest != NULL) {
            success = HttpSendRequest(fsm.m_hRequest,
                                      fsm.m_lpszHeaders,
                                      fsm.m_dwHeadersLength,
                                      NULL,
                                      0
                                      );
            if (!success) {
                error = GetLastError();
                if (error == ERROR_IO_PENDING) {
                    goto quit;

parse_continue:

                    //
                    // in the async case, the result from HttpSendRequest() is
                    // returned as a DWORD error. Convert it back to a BOOL
                    //

                    success = (BOOL)(error == ERROR_SUCCESS);
                }
            }
        }
    } else {
        error = GetLastError();
    }
    if (success) {

        //
        // associate the connect handle with the request handle, so that when
        // we close the request handle, the connect handle is also closed
        //

        HINTERNET hConnectMapped = NULL;
        HINTERNET hRequestMapped = NULL;

        error = MapHandleToAddress(fsm.m_hConnect, (LPVOID *)&hConnectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            error = MapHandleToAddress(fsm.m_hRequest, (LPVOID *)&hRequestMapped, FALSE);
            if (error == ERROR_SUCCESS) {
                RSetParentHandle(hRequestMapped, hConnectMapped, TRUE);

                //
                // return the request handle
                //

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("returning handle %#x\n",
                            fsm.m_hRequest
                            ));

                *fsm.m_phInternet = fsm.m_hRequest;
            }
        }

        //
        // dereference the handles referenced by MapHandleToAddress()
        //

        if (hRequestMapped != NULL) {
            DereferenceObject((LPVOID)hRequestMapped);
        }
        if (hConnectMapped != NULL) {
            DereferenceObject((LPVOID)hConnectMapped);
        }
    }

quit:

    if ((error != ERROR_SUCCESS) && (error != ERROR_IO_PENDING)) {
        if (fsm.m_hRequest != NULL) {
            InternetCloseHandle(fsm.m_hRequest);
        }
        if (fsm.m_hConnect != NULL) {
            InternetCloseHandle(fsm.m_hConnect);
        }
    }
    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\query.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    query.cxx

Abstract:

    This file contains the implementation of the HttpQueryInfoA API.

    Contents:
        HttpQueryInfoA
        HttpQueryInfoW
        HTTP_REQUEST_HANDLE_OBJECT::QueryInfo

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpQueryInfoA remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include "httpp.h"

//
// private prototypes
//

//
// private data
//

#define NUM_HEADERS ARRAY_ELEMENTS(GlobalKnownHeaders)

//
// functions
//


INTERNETAPI_(BOOL) HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries a request or response header from the HTTP request handle

Arguments:

    hRequest            - an open HTTP request handle returned by
                          HttpOpenRequest()

    dwInfoLevel         - one of the HTTP_QUERY_* values indicating the
                          attribute to query. In addition, the following flags
                          can be set:

                            HTTP_QUERY_FLAG_REQUEST_HEADERS
                                - Causes the request headers to be queried. The
                                  default is to check the response headers

                            HTTP_QUERY_FLAG_SYSTEMTIME
                                - Causes headers that contain date & time
                                  information to be returned as SYSTEMTIME
                                  structures

                            HTTP_QUERY_FLAG_NUMBER
                                - Causes header value to be returned as a number.
                                  Useful for when the app knows it is expecting
                                  a numeric value, e.g. status code

                            HTTP_QUERY_FLAG_COALESCE
                                - Combine several headers of the same name into
                                  one output buffer

    lpBuffer            - pointer to the buffer to receive the information.
                          If dwInfoLevel is HTTP_QUERY_CUSTOM then buffer
                          contains the header to query.

                          If NULL then we just return the required buffer length
                          to hold the header specified by dwInfoLevel

    lpdwBufferLength    - IN: contains the length (in BYTEs) of lpBuffer
                          OUT: size of data written to lpBuffer, or required
                               buffer length if ERROR_INSUFFICIENT_BUFFER
                               returned

    lpdwIndex           - IN: 0-based header index
                          OUT: next index to query, if success returned

Return Value:

    TRUE    - The query succeeded. lpBuffer contains the query information, and
              *lpdwBufferLength contains the size (in BYTEs) of the information

    FALSE   - The operation failed. Error status is available by calling
              GetLastError().

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpQueryInfoA",
                     "%#x, %s (%#x), %#x [%q], %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpBuffer,
                     ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
                        ? lpBuffer
                        : "",
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD defaultIndex = 0;
    DWORD error;
    HINTERNET hRequestMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the thread info
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();

    //
    // map the handle
    //

    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    //
    // find path from Internet handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters
    //

    DWORD queryModifiers;
    DWORD infoLevel;

    queryModifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    infoLevel = dwInfoLevel & HTTP_QUERY_HEADER_MASK;

    if (((infoLevel > HTTP_QUERY_MAX) && (infoLevel != HTTP_QUERY_CUSTOM))
    || (lpdwBufferLength == NULL)

    //
    // nip in the bud apps that want SYSTEMTIME AND NUMBER for same header(!)
    //

#define EXCLUSIVE_MODIFIERS (HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_FLAG_SYSTEMTIME)

    || ((dwInfoLevel & EXCLUSIVE_MODIFIERS) == EXCLUSIVE_MODIFIERS)) {

        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the app passed in a NULL lpdwIndex then it is asking for index 0
    //

    if (!ARGUMENT_PRESENT(lpdwIndex)) {
        lpdwIndex = &defaultIndex;
    }

    //
    // if the app is asking for one of the special query items - status code,
    // status text, HTTP version, or one of the raw header variants, then make
    // sure the index is 0. These pseudo-header types cannot be enumerated
    //

    if ((*lpdwIndex != 0)
    && ((infoLevel == HTTP_QUERY_VERSION)
        || (infoLevel == HTTP_QUERY_STATUS_CODE)
        || (infoLevel == HTTP_QUERY_STATUS_TEXT)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS)
        || (infoLevel == HTTP_QUERY_RAW_HEADERS_CRLF))) {

        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    //
    // ensure that we can use any flags passed in
    //

    if (infoLevel == HTTP_QUERY_CUSTOM) {

        //
        // lpBuffer MUST be present if we were asked to find a custom header
        //

        if (!ARGUMENT_PRESENT(lpBuffer)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // the app has given us a string to locate. We only accept strings in
        // the following format:
        //
        //  <header-to-find>[:][CR][LF]<EOS>
        //
        // The header cannot contain any spaces
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        __try {

            LPSTR lpszBuffer = (LPSTR)lpBuffer;
            int queryLength = 0;
            int headerLength = 0;

            for (; lpszBuffer[queryLength] != '\0'; ++queryLength) {
                if ((lpszBuffer[queryLength] == ':')
                || (lpszBuffer[queryLength] == '\r')
                || (lpszBuffer[queryLength] == '\n')) {
                    break;
                }
                if (iscntrl(lpszBuffer[queryLength])
                || isspace(lpszBuffer[queryLength])) {
                    error = ERROR_INVALID_PARAMETER;
                    break;
                }
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else if ((queryModifiers & ~GlobalKnownHeaders[infoLevel].Flags) != 0) {
        error = ERROR_HTTP_INVALID_QUERY_REQUEST;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if NULL buffer pointer then app wants length of option: set buffer length
    // to zero
    //

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    } else {

        //
        // ensure app buffer is writeable
        //

        error = ProbeWriteBuffer(lpBuffer, *lpdwBufferLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;
    if (dwInfoLevel & HTTP_QUERY_FLAG_REQUEST_HEADERS) {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_REQUEST, TRUE)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        }
    } else {
        if (!IS_VALID_HTTP_STATE(pRequest, QUERY_RESPONSE, TRUE)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        }
    }
    if (error == ERROR_SUCCESS) {
        error = pRequest->QueryInfo(dwInfoLevel,
                                    lpBuffer,
                                    lpdwBufferLength,
                                    lpdwIndex
                                    );
    }

quit:

    _InternetDecNestingCount(1);

done:

    BOOL success;

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(HTTP, error);

        SetLastError(error);
        success = FALSE;
    } else {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwBufferLength = %d\n",
                        *lpdwBufferLength
                        ));

        DEBUG_DUMP_API(DUMP_API_DATA,
                       "Query data:\n",
                       lpBuffer,
                       *lpdwBufferLength
                       );

        success = TRUE;
    }

    if (hRequestMapped != NULL) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )

/*++

Routine Description:

    Queries information from the HTTP request handle.

Arguments:

    hHttpRequest - An open HTTP request handle returned by HttpOpenRequest().

    dwInfoLevel - One of the HTTP_QUERY_* values indicating the attribute
        to query.

    lpBuffer - Pointer to the buffer to receive the information.

    dwBufferLength - On entry, contains the length (in BYTEs) of the data
        buffer. On exit, contains the size (in BYTEs) of the data written
        to lpBuffer.

Return Value:

    TRUE - The query succeeded. lpBuffer contains the query information,
        and lpBufferLength contains the size (in BYTEs) of the information.

    FALSE - The operation failed. Error status is available by calling
        GetLastError().

Comments:

--*/

{
    DEBUG_ENTER_API((DBG_API,   
                     Bool,
                     "HttpQueryInfoW",
                     "%#x, %s (%#x), %#x [%wq], %#x [%d], %#x [%d]",
                     hRequest,
                     InternetMapHttpOption(dwInfoLevel & HTTP_QUERY_HEADER_MASK),
                     dwInfoLevel,
                     lpBuffer,
                     ((dwInfoLevel & HTTP_QUERY_HEADER_MASK) == HTTP_QUERY_CUSTOM)
                        ? lpBuffer
                        : L"",
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     lpdwIndex,
                     lpdwIndex ? *lpdwIndex : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult=FALSE;
    INET_ASSERT(hRequest);
    MEMORYPACKET mpBuffer;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && IsBadWritePtr(lpBuffer, *lpdwBufferLength))
        || (lpdwIndex && IsBadWritePtr(lpdwIndex, sizeof(*lpdwIndex))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (lpBuffer)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
        if (dwInfoLevel==HTTP_QUERY_CUSTOM)
        {
            DWORD dwTemp = WideCharToMultiByte(CP_ACP,0,(LPWSTR)lpBuffer,-1,NULL,0,NULL,NULL);
            if (dwTemp>mpBuffer.dwAlloc)
            {
                mpBuffer.dwAlloc = dwTemp;
            }
        }
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (dwInfoLevel==HTTP_QUERY_CUSTOM)
    {
        if (!lpBuffer)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        WideCharToMultiByte(CP_ACP,0,(LPWSTR)lpBuffer,-1,mpBuffer.psStr,mpBuffer.dwAlloc,NULL,NULL);
    }

    fResult = HttpQueryInfoA(hRequest,dwInfoLevel,(LPVOID)mpBuffer.psStr,&mpBuffer.dwSize,lpdwIndex);

    if (!((dwInfoLevel & HTTP_QUERY_FLAG_NUMBER) ||
        (dwInfoLevel & HTTP_QUERY_FLAG_SYSTEMTIME)))
    {
        // This is the default, we've been handed back a string.
        if (fResult)
        {
            *lpdwBufferLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                        NULL, 0);
            *lpdwBufferLength *= sizeof(WCHAR);
            if (*lpdwBufferLength<=mpBuffer.dwAlloc)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, mpBuffer.dwAlloc/sizeof(WCHAR));
                *lpdwBufferLength -= sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
    }
    else
    {
        if (fResult)
        {
            memcpy(lpBuffer, (LPVOID)mpBuffer.psStr, mpBuffer.dwSize);
        }
        *lpdwBufferLength = mpBuffer.dwSize;
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

//
// object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryInfo(
    IN DWORD dwInfoLevel,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Header query method for HTTP_REQUEST_HANDLE_OBJECT class

Arguments:

    dwInfoLevel         - level of info (header) to get

    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

    lpdwIndex           - IN: 0-based index of named header to return
                          OUT: index of next header if success returned

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_HTTP_DOWNLEVEL_SERVER
                    Response came from a down-level (<= HTTP 0.9) server. There
                    are no headers to query

                  ERROR_HTTP_HEADER_NOT_FOUND
                    Couldn't find the requested header

                  ERROR_HTTP_INVALID_QUERY_REQUEST
                    The caller asked for e.g. the Accept: header to be returned
                    as a SYSTEMTIME structure, or for e.g. a request header that
                    only exists for response headers (status code, for example)

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/

{
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT(lpdwIndex != NULL);

    DWORD error;
    LPSTR headerName;
    DWORD headerNameLength;
    DWORD modifiers;

    modifiers = dwInfoLevel & HTTP_QUERY_MODIFIER_FLAGS_MASK;
    dwInfoLevel &= HTTP_QUERY_HEADER_MASK;

    if (dwInfoLevel == HTTP_QUERY_CUSTOM) {
        headerName = (LPSTR)lpBuffer;
        for (headerNameLength = 0; ; ++headerNameLength) {
            if ((headerName[headerNameLength] == '\0')
            || (headerName[headerNameLength] == ':')
            || (headerName[headerNameLength] == '\r')
            || (headerName[headerNameLength] == '\n')) {
                break;
            }
        }
    } else if (dwInfoLevel == HTTP_QUERY_REQUEST_METHOD) {

        LPSTR lpszVerb;
        DWORD dwVerbLength;

        lpszVerb = _RequestHeaders.GetVerb(&dwVerbLength);
        if ((lpszVerb != NULL) && (dwVerbLength != 0)) {

            //
            // the verb is (usually) space terminated
            //

            while ((dwVerbLength > 0) && (lpszVerb[dwVerbLength - 1] == ' ')) {
                --dwVerbLength;
            }

            //
            // *lpdwBufferLength will be 0 if lpBuffer is NULL
            //

            if (*lpdwBufferLength > dwVerbLength) {
                memcpy(lpBuffer, lpszVerb, dwVerbLength);
                ((LPBYTE)lpBuffer)[dwVerbLength] = '\0';
                error = ERROR_SUCCESS;
            } else {
                ++dwVerbLength;
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            *lpdwBufferLength = dwVerbLength;
        } else {
            error = ERROR_HTTP_HEADER_NOT_FOUND;
        }
        goto quit;
    } else {
        headerName = GlobalKnownHeaders[dwInfoLevel].Text;
        headerNameLength = GlobalKnownHeaders[dwInfoLevel].Length;
    }

    if (modifiers & HTTP_QUERY_FLAG_REQUEST_HEADERS) {

        //
        // we can always query request headers, even if the server is down
        // level
        //

        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
            
            error = _RequestHeaders.QueryRequestVersion(
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;
        case HTTP_QUERY_STATUS_CODE:
        case HTTP_QUERY_STATUS_TEXT:

            //
            // can't query these sub-header values from the request headers
            //

            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _RequestHeaders.QueryRawHeaders(
                        NULL,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = QueryRequestHeadersWithEcho(
                        dwInfoLevel == HTTP_QUERY_ECHO_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_CUSTOM:

            _RequestHeaders.LockHeaders();

            error = QueryRequestHeader(headerName,
                                       headerNameLength,
                                       lpBuffer,
                                       lpdwBufferLength,
                                       modifiers,
                                       lpdwIndex
                                       );

            _RequestHeaders.UnlockHeaders();

            break;

        default:

            _RequestHeaders.LockHeaders();

            error = QueryRequestHeader( dwInfoLevel,
                                        lpBuffer,
                                        lpdwBufferLength,
                                        modifiers,
                                        lpdwIndex
                                        );

            _RequestHeaders.UnlockHeaders();

            break;

        }
    } else if (!IsDownLevel()) {
        switch (dwInfoLevel) {
        case HTTP_QUERY_VERSION:
            error = QueryResponseVersion(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_STATUS_CODE:
            error = QueryStatusCode(lpBuffer, lpdwBufferLength, modifiers);
            break;

        case HTTP_QUERY_STATUS_TEXT:
            error = QueryStatusText(lpBuffer, lpdwBufferLength);
            break;

        case HTTP_QUERY_RAW_HEADERS:
        case HTTP_QUERY_RAW_HEADERS_CRLF:
            error = _ResponseHeaders.QueryRawHeaders(
                        (LPSTR)_ResponseBuffer,
                        dwInfoLevel == HTTP_QUERY_RAW_HEADERS_CRLF,
                        lpBuffer,
                        lpdwBufferLength
                        );
            break;

        case HTTP_QUERY_ECHO_HEADERS:
        case HTTP_QUERY_ECHO_HEADERS_CRLF:
            error = ERROR_HTTP_INVALID_QUERY_REQUEST;
            break;

        case HTTP_QUERY_CUSTOM:

            _ResponseHeaders.LockHeaders();

            error = QueryResponseHeader(
                                        headerName,
                                        headerNameLength,
                                        lpBuffer,
                                        lpdwBufferLength,
                                        modifiers,
                                        lpdwIndex
                                        );

            _ResponseHeaders.UnlockHeaders();

            break;

        default:

            _ResponseHeaders.LockHeaders();

            error = QueryResponseHeader(
                                        dwInfoLevel,
                                        lpBuffer,
                                        lpdwBufferLength,
                                        modifiers,
                                        lpdwIndex
                                        );

            _ResponseHeaders.UnlockHeaders();

            break;
        }
    } else {

        //
        // there are no response headers from down-level servers
        //

        error = ERROR_HTTP_DOWNLEVEL_SERVER;
    }

quit:

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryRequestHeadersWithEcho(
    IN BOOL bCrlfTerminated,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    Header query for request headers with echo headers added if any..

Arguments:

    bCrlfTerminated     - should the headers be seperated by CRLF's
    lpBuffer            - pointer to user's buffer

    lpdwBufferLength    - IN: length of user's buffer
                          OUT: length of returned information or required buffer
                               length if insufficient

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_INSUFFICIENT_BUFFER
                    User's buffer not large enough to hold requested data

--*/
{
    INET_ASSERT(lpdwBufferLength != NULL);

    DWORD error;
    LPSTR lpszEchoHeaderIn = NULL ;
    LPSTR lpszEchoHeaderOut = NULL;
    DWORD cbHeaderIn = 0;
    DWORD cbHeaderOut = 0;
    BOOL bEchoPresent = FALSE;

    // List of headers to filter out of the Request headers

    LPSTR rglpFilter [ ] =
    {
        GlobalKnownHeaders[HTTP_QUERY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_CONTENT_LENGTH].Text,
        GlobalKnownHeaders[HTTP_QUERY_COOKIE].Text,
        GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text,
        GlobalKnownHeaders[HTTP_QUERY_HOST].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_NONE_MATCH].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_IF_UNMODIFIED_SINCE].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_AUTHORIZATION].Text,
        GlobalKnownHeaders[HTTP_QUERY_PROXY_CONNECTION].Text,
        GlobalKnownHeaders[HTTP_QUERY_RANGE].Text,
        GlobalKnownHeaders[HTTP_QUERY_UNLESS_MODIFIED_SINCE].Text,
    };

    _ResponseHeaders.LockHeaders();

    error = FastQueryResponseHeader(HTTP_QUERY_ECHO_REQUEST,
                                    (LPVOID *)&lpszEchoHeaderIn,
                                    &cbHeaderIn,
                                    0);

    if (error == ERROR_SUCCESS)
    {
        DWORD cbEchoRequest = GlobalKnownHeaders[HTTP_QUERY_ECHO_REQUEST].Length;
        DWORD cbEchoReply   = GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Length;

        bEchoPresent = TRUE;

        // Add echo-reply: to the begining of the header.
        cbHeaderOut = cbEchoReply  + 1                      // For echo-reply:
                        + cbHeaderIn                        // Send back the stuff from the header.
                        + (bCrlfTerminated ? 2 : 1)         // 2 for CRLF
                        + 1;                                // 1 for NULL terminator

        lpszEchoHeaderOut = (LPSTR) _alloca(cbHeaderOut); // Add 1 for null terminator.

        if ( lpszEchoHeaderOut == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        LPSTR lpsz = lpszEchoHeaderOut;

        memcpy(lpszEchoHeaderOut, GlobalKnownHeaders[HTTP_QUERY_ECHO_REPLY].Text, cbEchoReply);
        lpsz += cbEchoReply;

        lpsz[0] = ':';
        lpsz++;


        memcpy(lpsz, lpszEchoHeaderIn, cbHeaderIn );
        lpsz += cbHeaderIn;


        if ( bCrlfTerminated)
        {
            lpsz[0] = '\r';
            lpsz[1] = '\n';
            lpsz += 2;
        }
        else
        {
            lpsz[0] = '\0';
            lpsz++;
        }

        *lpsz = '\0';
    }

    DWORD dwBufferLength;
    dwBufferLength = *lpdwBufferLength;


    error = _RequestHeaders.QueryFilteredRawHeaders(
                NULL,
                rglpFilter,
                sizeof(rglpFilter)/sizeof(rglpFilter[0]),
                TRUE,
                TRUE,
                bCrlfTerminated,
                lpBuffer,
                lpdwBufferLength
                );

    if ( !bEchoPresent )
    {
        // Nothing more to do in this case.
    }
    else if ( error == ERROR_SUCCESS )
    {
        DWORD dwBufferReqd = *lpdwBufferLength + cbHeaderOut;
        // Check if we have space to add extra headers.
        if (dwBufferReqd <= dwBufferLength)
        {
            memcpy((LPSTR)lpBuffer + *lpdwBufferLength, lpszEchoHeaderOut, cbHeaderOut);
            *lpdwBufferLength += cbHeaderOut - 1; // -1 to exclude terminating '\0'
        }
        else
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            // There is a NULL termination count included both in cbHeaderOut and *lpdwBufferLength
            // hence the -1.
            *lpdwBufferLength += cbHeaderOut - 1 ;
        }
    }
    else if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        *lpdwBufferLength += cbHeaderOut - 1 ;
    }
    else
    {
        // For other errors just return the original error from QueryRawHeaders.
    }

done:
    _ResponseHeaders.UnlockHeaders();

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\prefetch.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    prefetch.cxx

Abstract:

    Functions and methods to support http random read access.

    Contents:
        AttemptReadFromFile
        SetStreamPointer
        SetLengthFromCache
        ReadLoop_Fsm
        WriteResponseBufferToCache
        WriteQueryBufferToCache
Author:

    Rajeev Dujari (rajeevd) March 1996

Revision History:

    Ahsan Kabir (akabir) November 1997
--*/

#include <wininetp.h>


#define READLOOP_BUFSIZE 2048



BOOL
HTTP_REQUEST_HANDLE_OBJECT::AttemptReadFromFile(

    LPVOID lpBuf,
    DWORD cbToRead,
    DWORD* pcbRead
    )
{
    DEBUG_ENTER((DBG_CACHE,
                 Bool,
                 "INTERNET_CONNECT_HANDLE_OBJECT::AttemptReadFromFile",
                 "%#x, %d, %#x",
                 lpBuf,
                 cbToRead,
                 pcbRead
                 ));

    BOOL fSuccess;
    DWORD dwBytesToCopy = 0;

    if (!cbToRead)
    {
        *pcbRead = 0;
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    if (IsCacheReadInProgress())
    {
        INET_ASSERT(_VirtualCacheFileSize == _RealCacheFileSize);

        // Entire read should be satisfied from cache.
        *pcbRead = cbToRead;
        if (ReadUrlCacheEntryStream
            (_hCacheStream, _dwCurrentStreamPosition, lpBuf, pcbRead, 0))
        {
            AdvanceReadPosition (*pcbRead);
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
        else
        {
            *pcbRead = 0;
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
    }

    else if (IsCacheWriteInProgress())
    {

        // See if the read is completely within the file.
        if (!IsEndOfFile() && _dwCurrentStreamPosition + cbToRead > _VirtualCacheFileSize)
        {

            DEBUG_PRINT(HTTP, ERROR, ("AttemptRead Failed streampos=%d cbToRead=%d, _VitrualCacheFileSize=%d\n",
                            _dwCurrentStreamPosition, cbToRead, _VirtualCacheFileSize));

            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        HANDLE hfRead;
        hfRead = GetDownloadFileReadHandle();
        if (hfRead == INVALID_HANDLE_VALUE) 
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        // Read the data from the file.
        SetFilePointer (hfRead, _dwCurrentStreamPosition, NULL, FILE_BEGIN);
        fSuccess = ReadFile (hfRead, lpBuf, cbToRead, pcbRead, NULL);
        if (!fSuccess)
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        AdvanceReadPosition (*pcbRead);
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    else
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
}


// Called from InternetSetFilePointer
DWORD
HTTP_REQUEST_HANDLE_OBJECT::SetStreamPointer(
    LONG lDistanceToMove,
    DWORD dwMoveMethod
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    // Fail if data is not from cache or going to cache.
    if (!IsCacheReadInProgress() && !IsCacheWriteInProgress())
    {
        dwErr = ERROR_INTERNET_INVALID_OPERATION;
        goto done;
    }

    // BUGBUG: we don't handle chunked transfer, new with http 1.1
    if (IsChunkEncoding())
    {
        dwErr = ERROR_INTERNET_INVALID_OPERATION;
        goto done;
    }

    switch (dwMoveMethod)
    {

        case FILE_BEGIN:
            _dwCurrentStreamPosition = (DWORD) lDistanceToMove;
            break;

        case FILE_CURRENT:
            if (lDistanceToMove < 0
                && ((DWORD) -lDistanceToMove) > _dwCurrentStreamPosition)
            {
                dwErr = ERROR_NEGATIVE_SEEK;
            }
            else
            {
                _dwCurrentStreamPosition += lDistanceToMove;
            }
            break;

        case FILE_END:
            if (!IsContentLength())
                 dwErr = ERROR_INTERNET_INVALID_OPERATION;
            else if (lDistanceToMove < 0 && ((DWORD) -lDistanceToMove) > _ContentLength)
                dwErr = ERROR_NEGATIVE_SEEK;
            else
                _dwCurrentStreamPosition = _ContentLength + lDistanceToMove;
            break;

        default:
            dwErr = ERROR_INVALID_PARAMETER;
            break;
    }


done:

    if (dwErr == ERROR_SUCCESS)
    {
        if (IsKeepAlive() && IsContentLength())
            _BytesRemaining = _ContentLength - _dwCurrentStreamPosition;

        if (_VirtualCacheFileSize > _dwCurrentStreamPosition)
            SetAvailableDataLength (_VirtualCacheFileSize - _dwCurrentStreamPosition);
        else
            SetAvailableDataLength (0);

        return _dwCurrentStreamPosition;
    }
    else
    {
        SetLastError (dwErr);
        return (DWORD) -1L;
    }
}

DWORD
CFsm_ReadLoop::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadLoop::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_ReadLoop * stateMachine = (CFsm_ReadLoop *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
        case FSM_STATE_INIT:
        case FSM_STATE_CONTINUE:
            error = pRequest->ReadLoop_Fsm(stateMachine);
            break;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;
            Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);
            INET_ASSERT(FALSE);
            break;
    }

    DEBUG_LEAVE(error);
    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadLoop_Fsm(
    IN CFsm_ReadLoop * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadLoop_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadLoop & fsm = *Fsm;
    DWORD dwErr = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_CONTINUE)
    {
        goto receive_continue;
    }

    // Set the goal for reading from the socket.
    fsm.m_dwReadEnd = _dwCurrentStreamPosition +
        ((fsm.m_dwSocketFlags & SF_NO_WAIT)? 1 : fsm.m_cbReadIn);

    // If app is trying to read beyond eof, limit it.
    if (fsm.m_dwReadEnd > _ContentLength)
    {
        fsm.m_dwReadEnd = _ContentLength;
        fsm.m_cbReadIn = fsm.m_dwReadEnd - _dwCurrentStreamPosition;
    }
    
    // Flush any data in response buffer to download file.
    dwErr = WriteResponseBufferToCache();
    if (dwErr != ERROR_SUCCESS)
        goto done;

    // Flush any data in query buffer to download file.
    dwErr = WriteQueryBufferToCache();
    if (dwErr != ERROR_SUCCESS)
        goto done;

    // BUGBUG: what if HaveReadFileExData?

    // Allocate receive buffer.  We could optimize this to use
    // the client buffer or query buffer when available to avoid
    // reading from the file data that was just written.

    fsm.m_cbBuf = READLOOP_BUFSIZE;
    if (!(fsm.m_pBuf = (PVOID) new BYTE [fsm.m_cbBuf]))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    HANDLE hfRead;
    hfRead = GetDownloadFileReadHandle();
    if (hfRead == INVALID_HANDLE_VALUE) 
    {
        dwErr = GetLastError();
        DEBUG_PRINT(CACHE, ERROR, ("Cache: createfile failed error=%ld\n", dwErr));
        goto done;
    }
    
    while (1)
    {
        // Calculate amount of data available for next read.
        if (_VirtualCacheFileSize > _dwCurrentStreamPosition)
            SetAvailableDataLength  (_VirtualCacheFileSize - _dwCurrentStreamPosition);
        else
            SetAvailableDataLength (0);

        // Check if pending request can be satisfied from file.
        if (_EndOfFile || _VirtualCacheFileSize >= fsm.m_dwReadEnd)
        {
            INET_ASSERT (AvailableDataLength());

            if (fsm.m_pRead)
            {
                // The client wants us to fill the buffer.
                if (fsm.m_dwSocketFlags & SF_NO_WAIT)
                {
                    // If the app is greedy, give it all we've got.
                    if (fsm.m_cbReadIn > AvailableDataLength())
                        fsm.m_cbReadIn = AvailableDataLength();
                }
                else
                {
                    INET_ASSERT (fsm.m_cbReadIn <= AvailableDataLength());
                }
            }

            // Read the data from the file.
            LONG lRet;
            lRet = SetFilePointer
                (hfRead, _dwCurrentStreamPosition, NULL, FILE_BEGIN);
            INET_ASSERT ((DWORD) lRet == _dwCurrentStreamPosition);
            if (lRet == -1)
            {
                dwErr = GetLastError();
                goto done;
            }

            BOOL fRet;
            fRet = ReadFile
                (hfRead, fsm.m_pRead, fsm.m_cbReadIn, fsm.m_pcbReadOut, NULL);
            if (!fRet)
            {
                dwErr = GetLastError();
                goto done;
            }

            AdvanceReadPosition (*fsm.m_pcbReadOut);
            INET_ASSERT (dwErr == ERROR_SUCCESS);
            goto done;
        }

        INET_ASSERT (!_EndOfFile);
        INET_ASSERT (_Socket);

        fsm.m_cbRead = fsm.m_cbBuf;
        if (IsKeepAlive() && fsm.m_cbRead > _BytesInSocket)
            fsm.m_cbRead = _BytesInSocket;
        fsm.m_cbRecv = 0;

        // Get some more data from the socket.

        dwErr = _Socket->Receive
        (
            &fsm.m_pBuf,     // IN OUT LPVOID* lplpBuffer,
            &fsm.m_cbBuf,    // IN OUT LPDWORD lpdwBufferLength,
            &fsm.m_cbRead,   // IN OUT LPDWORD lpdwBufferRemaining,
            &fsm.m_cbRecv,   // IN OUT LPDWORD lpdwBytesReceived,
            0,               // IN DWORD dwExtraSpace,
            fsm.m_dwSocketFlags,     // IN DWORD dwFlags,
            &_EndOfFile  // OUT LPBOOL lpbEof
        );

        if (dwErr == ERROR_IO_PENDING)
        {
            if (fsm.m_dwSocketFlags & SF_NO_WAIT)
            {
                // InternetReadFileEx can set IRF_NO_WAIT.  If we must go async
                // in this case, morph the request into a QueryDataAvailable
                // and app will call again to get the data after notification.

                fsm.m_pRead = NULL;
                fsm.m_cbReadIn = 1;
                fsm.m_pcbReadOut = NULL;
            }
            goto done;
        }

receive_continue:

        if (dwErr != ERROR_SUCCESS)
        {
            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("error %d on socket %#x\n",
                        dwErr,
                        _Socket->GetSocket()));

            goto done;
        }

        // Append data to download file.
        dwErr = WriteCache ((PBYTE) fsm.m_pBuf, fsm.m_cbRecv);
        if (dwErr != ERROR_SUCCESS)
            goto done;

        // If content length is known, check for EOF.
        if (IsKeepAlive())
        {
            _BytesInSocket -= fsm.m_cbRecv;
            if (!_BytesInSocket)
                _EndOfFile = TRUE;
        }

        if (_EndOfFile)
        {
            // Set handle state.
            SetState(HttpRequestStateReopen);
            if (!IsKeepAlive())
                CloseConnection(FALSE);
            SetData(FALSE);
        }

    } // end while (1)

done:

    if (dwErr != ERROR_IO_PENDING)
    {
        delete [] fsm.m_pBuf;
        fsm.SetDone();

        if (dwErr != ERROR_SUCCESS)
        {
            DEBUG_PRINT(HTTP, ERROR, ("Readloop: Error = %d\n", dwErr));

            SetState(HttpRequestStateError);
            LocalEndCacheWrite(FALSE);
        }
    }

    DEBUG_LEAVE(dwErr);

    return dwErr;
}


// Called from ReadLoop to write data in response buffer to download file.
DWORD HTTP_REQUEST_HANDLE_OBJECT::WriteResponseBufferToCache (VOID)
{
    DWORD cbData = _BytesReceived - _DataOffset;
    if (!cbData)
        return ERROR_SUCCESS;
    DWORD dwErr = WriteCache
        (((LPBYTE) _ResponseBuffer) + _DataOffset, cbData);
    _DataOffset += cbData;

    DEBUG_PRINT(HTTP, ERROR, ("WriteResponseBufferToCache: Error = %d", dwErr));

    return dwErr;
}

// Called from ReadLoop to write data in query buffer to download file.
DWORD HTTP_REQUEST_HANDLE_OBJECT::WriteQueryBufferToCache (VOID)
{
    if (!_QueryBytesAvailable)
        return ERROR_SUCCESS;
    DWORD dwErr = WriteCache
        (((LPBYTE) _QueryBuffer) + _QueryOffset, _QueryBytesAvailable);
    _QueryOffset += _QueryBytesAvailable;
    _QueryBytesAvailable = 0;

    DEBUG_PRINT(HTTP, ERROR, ("WriteQueryBufferToCache: Error = %d", dwErr));

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\read.cxx ===
/*++

Copyright (c) 1994-1997 Microsoft Corporation

Module Name:

    read.cxx

Abstract:

    This file contains the implementation of the HttpReadData API.

    Contents:
        HttpReadData
        CFsm_HttpReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::ReadData
        CFsm_ReadData::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable
        CFsm_HttpQueryAvailable::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse
        CFsm_DrainResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    Modified to make HttpReadData remotable. madana (2/8/95)

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
VOID
FilterHeaders(
    IN LPSTR lpszHeaderInfo,
    OUT LPDWORD lpdwLen
    );

//
// functions
//


DWORD
HttpReadData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Reads a block of data from an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetReadFile() which
        globally validates parameters for all Internet data read
        functions

         2. We will never get a request for 0 bytes at this level. This
        request will have been handled in InternetReadFile()

Arguments:

    hRequest                - mapped HTTP request handle

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToRead   - number of bytes to read into lpBuffer

    lpdwNumberOfBytesRead   - number of bytes read into lpBuffer

    dwSocketFlags           - controlling socket operation

Return Value:

    TRUE - The data was read successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpReadData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 dwSocketFlags
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT*) hRequest;

    if (pRequest->IsReadRequest()) {

        //
        // Invoke ReadLoop fsm only if the read and write positions
        // are different, otherwise older code is more efficient.
        //

        error = DoFsm (new CFsm_ReadLoop (pRequest, dwSocketFlags,
            (PBYTE) lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead));

    } else {

        error = DoFsm(new CFsm_HttpReadData(lpBuffer,
                                            dwNumberOfBytesToRead,
                                            lpdwNumberOfBytesRead,
                                            dwSocketFlags,
                                            pRequest
                                           ));
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpReadData * stateMachine = (CFsm_HttpReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->HttpReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm(
    IN CFsm_HttpReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpReadData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (!IsValidHttpState(READ)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
            goto quit;
        }
        error = ReadData(fsm.m_lpBuffer,
                         fsm.m_dwNumberOfBytesToRead,
                         fsm.m_lpdwNumberOfBytesRead,
                         FALSE, // BUGBUG RFirthRemove on chkin
                         fsm.m_dwSocketFlags
                         );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }
    if (IsCacheWriteInProgress()) {
        if (*fsm.m_lpdwNumberOfBytesRead == 0) {

            DEBUG_PRINT(CACHE,
                        INFO,
                        ("Cache write complete\r\n"
                        ));

            LocalEndCacheWrite((error == ERROR_SUCCESS)
                               && (GetBytesInSocket() == 0));
        } else if (!HaveReadFileExData()) {

            INET_ASSERT(!IsCacheReadInProgress());

            if (WriteCache((LPBYTE)fsm.m_lpBuffer,
                           *fsm.m_lpdwNumberOfBytesRead) != ERROR_SUCCESS) {

                DEBUG_PRINT(CACHE,
                            ERROR,
                            ("Error in Cache write\n"
                            ));

                LocalEndCacheWrite(FALSE);
            }
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    PERF_LOG(PE_TRACE, 0x1002);

    DEBUG_LEAVE(error);

    return error;
}

//
// HTTP_REQUEST_HANDLE_OBJECT methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData(
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN BOOL fNoAsync, // BUGBUG RFirthRemove on DrainSocket checkin
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT ReadData method

    Reads data into users buffer. Reads from header buffer if data exists
    there, or reads from the socket

Arguments:

    lpBuffer                - pointer to users buffer

    dwNumberOfBytesToRead   - size of buffer/number of bytes to read

    lpdwNumberOfBytesRead   - pointer to returned number of bytes read

    fNoAsync                - TRUE if we want to override defaults and have
                              no Async Read.

    dwSocketFlags           - controlling socket operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData",
                 "%#x, %d, %#x, %B, %#x",
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead,
                 fNoAsync,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(new CFsm_ReadData(lpBuffer,
                                          dwNumberOfBytesToRead,
                                          lpdwNumberOfBytesRead,
                                          fNoAsync,
                                          dwSocketFlags,
                                          this
                                          ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadData::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_ReadData * stateMachine = (CFsm_ReadData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReadData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm(
    IN CFsm_ReadData * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReadData_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_LOG(PE_TRACE, 0x6001);

    CFsm_ReadData & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {

        PERF_LOG(PE_TRACE, 0x6101);

        error = fsm.GetError();
        goto receive_continue;
    }

    fsm.m_dwBytesRead = 0;
    fsm.m_dwBufferLeft = fsm.m_dwNumberOfBytesToRead;
    fsm.m_nBytesCopied = 0;

    //
    // if there's no data then we're done
    //

    if (!IsData()) {

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("!IsData()\n"
                    ));

        SetState(HttpRequestStateReopen);

        INET_ASSERT(error == ERROR_SUCCESS);

        goto quit;
    }

    //
    // If using keep-alive, reduce output buffer so we don't over-read.
    //

    if (IsKeepAlive() && IsContentLength()) {
        if (_BytesRemaining == 0) {

            INET_ASSERT(error == ERROR_SUCCESS);

            PERF_LOG(PE_TRACE, 0x6102);

            goto done;
        }

        PERF_LOG(PE_TRACE, 0x6103);

        fsm.m_dwBufferLeft = min(fsm.m_dwBufferLeft, _BytesRemaining);
    }

    //
    // if there's data left in the response buffer then copy it
    //

    fsm.m_bEof = FALSE;

    if (IsBufferedData()) {

        DWORD amountToCopy = min(fsm.m_dwNumberOfBytesToRead, BufferDataAvailToRead());

        if (amountToCopy != 0) {

            PERF_LOG(PE_TRACE, 0x6104);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Copying %d (%#x) bytes from header buffer @ %#x - %d left\n",
                        amountToCopy,
                        amountToCopy,
                        BufferedDataStart(),
                        BufferDataAvailToRead() - amountToCopy
                        ));

            memcpy(fsm.m_lpBuffer, BufferedDataStart(), amountToCopy);
            ReduceDataAvailToRead(amountToCopy);
            fsm.m_dwBytesRead += amountToCopy;
            fsm.m_dwBufferLeft -= amountToCopy;
            fsm.m_nBytesCopied += amountToCopy;

            //
            // we don't update lpBuffer here. Receive() takes the address of
            // the start of the buffer
            //

        }

        //
        // if we exhausted all the buffer space, then we're done
        //

        if (fsm.m_dwBufferLeft == 0) {

            PERF_LOG(PE_TRACE, 0x6105);

            goto done;
        }
    }

    //
    // find out if we're async. Even though the handle was created for async I/O
    // the request may be satisfied immediately
    //

    DWORD asyncFlags;

    if ( fsm.m_fNoAsync )   // BUGBUG RFirthRemove on Checkin of DrainSocket
        asyncFlags = 0;
    else
        asyncFlags = (IsAsyncHandle()
                        && (fsm.m_dwBufferLeft > AvailableDataLength()))
                   ? SF_NON_BLOCKING
                   : 0
                   ;

    //
    // if we have data already received in the query buffer, then return that
    //

    if (HaveQueryData()) {

        PERF_LOG(PE_TRACE, 0x6106);

        DWORD nCopied;

        nCopied = CopyQueriedData((LPVOID)((LPBYTE)fsm.m_lpBuffer + fsm.m_dwBytesRead),
                                  fsm.m_dwBufferLeft
                                  );

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied %d (%#x) bytes from query buffer @ %#x - %d left\n",
                    nCopied,
                    nCopied,
                    (LPBYTE)_QueryBuffer - _QueryOffset,
                    _QueryBytesAvailable
                    ));

        fsm.m_dwBytesRead += nCopied;
        fsm.m_dwBufferLeft -= nCopied;
        fsm.m_nBytesCopied += nCopied;
        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    //
    // If the Chunk parser claims we're done, then we're done,
    //  stop ready and tell the reader
    //

    //if ( IsChunkEncoding() && IsChunkedEncodingFinished() )
    //{
    //    fsm.m_bEof = TRUE;
    //    goto done;
    //}


    if (HaveReadFileExData()) {
        PERF_LOG(PE_TRACE, 0x6107);
        *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
        --fsm.m_dwNumberOfBytesToRead;
        --fsm.m_dwBufferLeft;
        ++fsm.m_dwBytesRead;

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Copied 1 byte (%#x) from ReadFileEx buffer %#x\n",
                    (BYTE)_ReadFileExData & 0xff,
                    &_ReadFileExData
                    ));

        if (fsm.m_dwBufferLeft == 0) {
            goto done;
        }
    }

    //
    // If the Chunk parser claims we're done, then we're done,
    //  stop ready and tell the reader
    //

    if ( IsChunkEncoding() && IsChunkedEncodingFinished() )
    {
        PERF_LOG(PE_TRACE, 0x6108);
        fsm.m_bEof = TRUE;
        goto done;
    }

    //
    // we're about to check the socket. Make sure its valid to do so
    //

    //INET_ASSERT(_Socket != NULL);

    if ((_Socket == NULL) || !_Socket->IsOpen()) {

        //
        // socket was closed - no more data
        //

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6109);
        goto quit;
    }

read_again:

    fsm.m_nBytes = fsm.m_dwBytesRead;

    //
    // if we had a content-length and we don't think there is any data left to
    // read then we're done
    //

    if (IsContentLength() && (_BytesInSocket == 0)) {
        fsm.m_bEof = TRUE;
        PERF_LOG(PE_TRACE, 0x6110);
        goto done;
    }

    //
    // receive data into user's buffer. Because we don't own the buffer, we
    // cannot resize it
    //

    LPVOID lpBuffer;
    DWORD dwBytesToRead;
    DWORD dwBufferLeft;
    DWORD dwBytesRead;

    lpBuffer = fsm.m_lpBuffer;
    dwBytesToRead = fsm.m_dwNumberOfBytesToRead;
    dwBufferLeft = fsm.m_dwBufferLeft;
    dwBytesRead = fsm.m_dwBytesRead;

    //INET_ASSERT(!(fsm.m_dwSocketFlags & SF_NO_WAIT)
    //            ? (fsm.m_dwBufferLeft <= _BytesRemaining)
    //            : TRUE);

    PERF_LOG(PE_TRACE, 0x6111);

    if (IsBadNSServer() && !IsConnCloseResponse()) {
        SetBadNSReceiveTimeout();
    }

    error = _Socket->Receive(&fsm.m_lpBuffer,
                             &fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBufferLeft,
                             &fsm.m_dwBytesRead,
                             0,
                             SF_INDICATE
                             | ((fsm.m_dwSocketFlags & SF_NO_WAIT)
                                ? SF_NO_WAIT
                                : (IsChunkEncoding() ? 0 : SF_RECEIVE_ALL)),
                             &fsm.m_bEof
                             );

    //
    // only if we performed an asynchronous no-wait receive and there was no
    // data available in the socket will we get WSAEWOULDBLOCK. Make another
    // receive request, this time without no-wait. It will complete
    // asynchronously and the app must make another no-wait request
    //

    if (error == WSAEWOULDBLOCK) {

        PERF_LOG(PE_TRACE, 0x6112);

        INET_ASSERT(fsm.m_dwSocketFlags & SF_NO_WAIT);
        INET_ASSERT(!fsm.m_bEof);

        //
        // BUGBUG - IsAsyncHandle() || IsAsyncRequest()
        //

        if ((fsm.m_dwBytesRead == 0) && IsAsyncHandle()) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("Initiating wait-for-data (1-byte read)\n"
                        ));

            fsm.m_lpBuffer = (LPVOID)&_ReadFileExData;
            fsm.m_dwNumberOfBytesToRead = 1;
            fsm.m_dwBufferLeft = 1;
            fsm.m_dwSocketFlags &= ~SF_NO_WAIT;

            INET_ASSERT(!_HaveReadFileExData);

            SetReadFileExData();

            _ReadFileExData = 0;

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            PERF_LOG(PE_TRACE, 0x6113);

            if (IsBadNSServer() && !IsConnCloseResponse()) {
                SetBadNSReceiveTimeout();
            }

            error = _Socket->Receive(&fsm.m_lpBuffer,
                                     &fsm.m_dwNumberOfBytesToRead,
                                     &fsm.m_dwBufferLeft,
                                     &fsm.m_dwBytesRead,
                                     0,
                                     fsm.m_dwSocketFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_SUCCESS) {

                PERF_LOG(PE_TRACE, 0x6114);

                BOOL fReadNothing = (fsm.m_dwBytesRead == 0 ? TRUE : FALSE);

                //
                // we have successfully read a single byte from the socket.
                //

                //INET_ASSERT(FALSE);

                fsm.m_lpBuffer = lpBuffer;
                fsm.m_dwNumberOfBytesToRead = dwBytesToRead;
                fsm.m_dwBufferLeft = dwBufferLeft;
                fsm.m_dwBytesRead = dwBytesRead;
                if (fReadNothing) {
                    // Don't copy if nothing was actually read.
                    ResetReadFileExData();
                }
                else {
                    *(LPBYTE)fsm.m_lpBuffer = GetReadFileExData();
                    --fsm.m_dwBufferLeft;
                    ++fsm.m_dwBytesRead;
                }

                //
                // BUGBUG - if socket unblocked already, should go round & read
                //          again, not just return 1 byte
                //

            }

            PERF_LOG(PE_TRACE, 0x6115);

        } else {

            PERF_LOG(PE_TRACE, 0x6116);

            DEBUG_PRINT(HTTP,
                        WARNING,
                        ("Not initiating wait-for-data: bytesRead = %d, asyncHandle = %B\n",
                        fsm.m_dwBytesRead,
                        IsAsyncHandle()
                        ));

            //
            // read data from buffers but nothing available from socket
            //

            error = ERROR_SUCCESS;
        }
    }

    if (error == ERROR_IO_PENDING) {
        PERF_LOG(PE_TRACE, 0x6117);
        goto quit_pending;
    }

receive_continue:

    PERF_LOG(PE_TRACE, 0x6118);

    //
    // if we timed-out while talking to 'bad' NS server (returns HTTP/1.1 but
    // content-length or chunked encoding info) then close the connection and
    // reset any RFX status. We return SUCCESS in this case
    //

    if ((error == ERROR_INTERNET_TIMEOUT) && IsBadNSServer()) {

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("Bad NS server: Closing connection %#x/%d on timeout\n",
                    _Socket ? _Socket->GetSocket() : -1,
                    _Socket ? _Socket->GetSourcePort() : -1
                    ));

        CloseConnection(TRUE);
        ResetReadFileExData();
        SetData(FALSE);
        _dwCurrentStreamPosition += fsm.m_dwBytesRead;
        fsm.m_bEof = TRUE;
        error = ERROR_SUCCESS;
        goto quit;
    }
    if (error == ERROR_SUCCESS) {
        if (IsContentLength()) {

            INET_ASSERT(fsm.m_dwBytesRead >= fsm.m_nBytes);

            _BytesInSocket -= fsm.m_dwBytesRead - fsm.m_nBytes;

            INET_ASSERT((int)_BytesInSocket >= 0);

            if ((int)_BytesInSocket < 0) {
                _BytesInSocket = 0;
            }
        }

        if ( IsChunkEncoding() && !(HaveReadFileExData()))
        {

            PERF_LOG(PE_TRACE, 0x6119);

            LPSTR lpszNewBuffer;
            DWORD dwNewBufferLength;
            DWORD dwBytesJustRead = (fsm.m_dwBytesRead - fsm.m_nBytes);

            error = _ctChunkInfo.ParseChunkInput(
                (((LPSTR) fsm.m_lpBuffer) + fsm.m_nBytesCopied),
                (fsm.m_dwBytesRead - fsm.m_nBytesCopied),
                &lpszNewBuffer,
                &dwNewBufferLength
                );

            //
            // hack - wait for more data
            //

            if ((error == ERROR_SUCCESS)
            && (dwNewBufferLength == 0)
            && !IsChunkedEncodingFinished()
            && (fsm.m_nBytesCopied == 0)) {

                PERF_LOG(PE_TRACE, 0x6120);

                fsm.m_dwBufferLeft += fsm.m_dwBytesRead;
                fsm.m_dwBytesRead = 0;

                struct fd_set read_fds;
                struct fd_set write_fds;
                struct fd_set except_fds;

                FD_ZERO(&read_fds);
                FD_ZERO(&write_fds);
                FD_ZERO(&except_fds);

                FD_SET(_Socket->GetSocket(), &read_fds);

                struct timeval to;

                to.tv_sec = 30;
                to.tv_usec = 0;
                int n = _I_select(1, &read_fds, &write_fds, &except_fds, &to);
                goto read_again;
            }

            fsm.m_dwBufferLeft += (fsm.m_dwBytesRead - fsm.m_nBytesCopied);
            fsm.m_dwBytesRead  -= (fsm.m_dwBytesRead - fsm.m_nBytesCopied);

            fsm.m_dwBufferLeft -= dwNewBufferLength;
            fsm.m_dwBytesRead  += dwNewBufferLength;
            fsm.m_nBytesCopied += dwNewBufferLength;

            INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.

            if ( error != ERROR_SUCCESS )
            {
                goto quit;
            }

            if ( IsChunkedEncodingFinished() )
            {
                fsm.m_bEof = TRUE;
            }
        }
    } else {

        PERF_LOG(PE_TRACE, 0x6121);

        DEBUG_PRINT(HTTP,
                    ERROR,
                    ("error %d on socket %#x\n",
                    error,
                    _Socket->GetSocket()
                    ));

        //
        // socket error
        //

        SetState(HttpRequestStateError);

        //
        // cause connection to be closed/released
        //

        fsm.m_bEof = TRUE;
    }

done:

    //
    // only update bytes remaining, EOF and the current stream position values
    // if we're returning data. If we just completed reading ReadFileEx data
    // then don't update. The 1 byte of ReadFileEx data will be read on the next
    // read proper
    //

    if (HaveReadFileExData()) {
        goto quit;
    }

    //
    // whether the data came from the response buffer or the socket, if we have
    // a content-length, update the amount of data left to retrieve
    //

    if (IsChunkEncoding()
        && IsChunkedEncodingFinished()
        && (_QueryBytesAvailable == 0)
        && (BufferDataAvailToRead() == 0)) {
        fsm.m_bEof = TRUE;
    } else if (IsKeepAlive() && IsContentLength()) {
        _BytesRemaining -= fsm.m_dwBytesRead;

        INET_ASSERT((int)_BytesRemaining >= 0);
        //
        // if we have read all the entity-body then we can release the keep-alive
        // connection, or close the socket
        //

        if (_BytesRemaining<=0 && ((int)_BytesRemaining>=-2)) {
            // We might overshoot by 1 or 2 because of server misinformation.
            fsm.m_bEof = TRUE;
        }
    }

    DEBUG_PRINT(HTTP,
                INFO,
                ("read %d bytes\n",
                fsm.m_dwBytesRead
                ));

    _dwCurrentStreamPosition += fsm.m_dwBytesRead;

    //
    // if we reached the end of the connection - either the end of the server
    // connection for real, or we received all indicated data on a keep-alive
    // connection - then close the connection
    //

    if (fsm.m_bEof) {

        PERF_LOG(PE_TRACE, 0x6122);

        //
        // if we don't need to keep hold of the connection, release it. In the
        // case of multi-part authentication (NTLM) over keep-alive connection
        // we need to keep the connection. With Kerberos, we don't need to keep
        // the connection.
        //

        if (GetAuthState() != AUTHSTATE_CHALLENGE) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("end of data - freeing connection %#x (Auth State = %s)\n",
                        _Socket ? _Socket->GetSocket() : 0,
                        InternetMapAuthState(GetAuthState())
                        ));
            if (!((GetStatusCode() == 407) && IsKeepAlive()))
                CloseConnection(FALSE);

        } else {

            // AUTHSTATE_CHALLENGE - check if request is through proxy or is kerberos.

            // When IsRequestUsingProxy returns TRUE, there are three types of connections possible:
            // 1) http request forwarded by the proxy to the server
            // 2) connect request to proxy to establish https tunnel
            // 3) using https tunnel through proxy to the server

            // I believe the various methods return:
            // http conn. tunnel
            // IsRequestUsingProxy                          1 1 1
            // IsViaProxy                       1 1 0
            // IsTunnel 0   1 0
            // IsTalkingToSecureServerViaProxy 0 0 1

            INET_ASSERT(_pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_NEGOTIATE);

            if (GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_KERBEROS)
            {
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - kerberos and auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }                
            else if (IsRequestUsingProxy()
                && !(IsTunnel() || IsTalkingToSecureServerViaProxy())
                && (_pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED)
                && !_pAuthCtx->_fIsProxy)
            {
                // Ordinarily, if the auth state is AUTHSTATE_CHALLENGE we wish to keep
                // the current connection open (keep alive) so that the response will go
                // out on the same socket. NTLM, which requires keep-alive, does not
                // work when going through a proxy. DPA on the other hand can work through
                // a proxy. In the case that the proxy does not return keep-alive with the
                // challenge (Catapult appears to be the only proxy that does) we want to
                // close the socket to ensure that it is not subsequently used for the response.

                DEBUG_PRINT(HTTP,
                            INFO,
                            ("freeing connection - auth state challenge\n"
                            ));
                CloseConnection(FALSE);
            }
            else
            {
                //  Keep alive required - don't close socket.
                DEBUG_PRINT(HTTP,
                            INFO,
                            ("not freeing connection - auth state challenge\n"
                            ));
            }

        }

        //
        // there is no more data to be received on this object
        //

        SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

quit:

    //
    // update the amount of data returned then we're outta here
    //

    *fsm.m_lpdwNumberOfBytesRead = fsm.m_dwBytesRead;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

quit_pending:

    PERF_LOG(PE_TRACE, 0x6002);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable(
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines how much data is available to be read by the caller

    BUGBUG - need cache case

Arguments:

    lpdwNumberOfBytesAvailable  - returned number of bytes available

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_INTERNET_INCORRECT_HANDLE_STATE

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::QueryDataAvailable",
                 "%#x",
                 lpdwNumberOfBytesAvailable
                 ));

    DWORD error = DoFsm(new CFsm_HttpQueryAvailable(lpdwNumberOfBytesAvailable,
                                                    this
                                                    ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpQueryAvailable::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpQueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpQueryAvailable * stateMachine = (CFsm_HttpQueryAvailable *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryAvailable_Fsm(
    IN CFsm_HttpQueryAvailable * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpQueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD bytesAvailable = 0;

    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        goto fsm_continue;
    }

    INET_ASSERT(fsm.GetState() == FSM_STATE_INIT);

    if (IsReadRequest()) {
        *fsm.m_lpdwNumberOfBytesAvailable = 0;
        if (_Socket != NULL) {

            //
            // Invoked ReadLoop fsm only if the read and write positions
            // are different, otherwise older code is more efficient.
            //
            error = DoFsm (new CFsm_ReadLoop (this, 0, NULL, 1, NULL));

            if (error == ERROR_SUCCESS) {
                *fsm.m_lpdwNumberOfBytesAvailable = AvailableDataLength();
            }
        } else {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("no socket\n"
                        ));

            fsm.m_bEof = TRUE;
        }
        goto done;
    }

    //
    // the handle must be readable
    //

    if (!IsValidHttpState(READ)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
        goto quit;
    }

    fsm.m_bEof = FALSE;

    //
    // error must be ERROR_SUCCESS - we just read it out of FSM & didn't jump
    // anywhere
    //

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // first check if there is data to receive at all
    //

    if (IsData()) {

        //
        // if there's buffered data still available from receiving the headers,
        // then return that length, else query the information from the socket
        //

        if (IsBufferedData()) {
            bytesAvailable = BufferDataAvailToRead();

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("%d bytes available in buffer\n",
                        bytesAvailable
                        ));

        } else if (_Socket != NULL) {

            //
            // the rest of the data must be read from the socket
            //

            BOOL checkSocket;

            if (IsKeepAlive() && IsContentLength()) {
                checkSocket = ((int)_BytesInSocket > 0) ? TRUE : FALSE;
            } else if (IsChunkEncoding()) {
                checkSocket = !IsChunkedEncodingFinished();
            } else {
                checkSocket = TRUE;
            }
            if (checkSocket) {
                if (_QueryBuffer != NULL) {
                    bytesAvailable = _QueryBytesAvailable;
                    checkSocket = (bytesAvailable == 0) ? TRUE : FALSE;
                } else {
                    error = _Socket->AllocateQueryBuffer(&_QueryBuffer,
                                                         &_QueryBufferLength
                                                         );
                    if (error != ERROR_SUCCESS) {
                        checkSocket = FALSE;
                    }
                }
            } else if (IsKeepAlive() && IsContentLength() && (_BytesRemaining == 0)) {
                fsm.m_bEof = TRUE;
            } else if (IsChunkEncoding() && IsChunkedEncodingFinished()) {
                fsm.m_bEof = TRUE;
            }
            if (checkSocket) {

                INET_ASSERT(_Socket->IsValid());
                INET_ASSERT(_QueryBytesAvailable == 0);

                //
                // reset the query buffer offset
                //

                _QueryOffset = 0;

                //
                // don't create another FSM just for the DataAvailable2 wrapper.
                // If it ever becomes more than a call to Receive() then create
                // an FSM
                //

read_again:

                fsm.m_lpBuffer = _QueryBuffer;
                fsm.m_dwBufferLength = (IsKeepAlive() && IsContentLength())
                                     ? min(_BytesRemaining, _QueryBufferLength)
                                     : _QueryBufferLength;
                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;

                //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

                if (IsBadNSServer() && !IsConnCloseResponse()) {
                    SetBadNSReceiveTimeout();
                }

                error = _Socket->Receive(&fsm.m_lpBuffer,
                                         &fsm.m_dwBufferLength,
                                         &fsm.m_dwBufferLeft, // don't care about this
                                         &_QueryBytesAvailable,
                                         0,
                                         0,
                                         &fsm.m_bEof
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

fsm_continue:

                if ((error == ERROR_INTERNET_TIMEOUT) && IsBadNSServer()) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("Bad NS server: Closing connection %#x/%d on timeout\n",
                                _Socket ? _Socket->GetSocket() : -1,
                                _Socket ? _Socket->GetSourcePort() : -1
                                ));

                    CloseConnection(TRUE);
                    _QueryBytesAvailable = 0;
                    error = ERROR_SUCCESS;
                }
                if (error == ERROR_SUCCESS) {


                    //if ( IsChunkEncoding() )
                    if ( IsChunkEncoding() && (_QueryBytesAvailable != 0))
                    {
                        LPSTR lpszNewBuffer;
                        DWORD dwNewBufferLength = 0;

                        error = _ctChunkInfo.ParseChunkInput(
                            (LPSTR) _QueryBuffer,
                            _QueryBytesAvailable,
                            &lpszNewBuffer,
                            &dwNewBufferLength
                            );

                        _QueryBytesAvailable = dwNewBufferLength;

                        INET_ASSERT(error == ERROR_SUCCESS); // I want to see this.

                        if ( error != ERROR_SUCCESS )
                        {
                            goto quit;
                        }

                        //
                        // hack - wait for more data
                        //

                        if ((dwNewBufferLength == 0) && !IsChunkedEncodingFinished()) {

                            struct fd_set read_fds;
                            struct fd_set write_fds;
                            struct fd_set except_fds;

                            FD_ZERO(&read_fds);
                            FD_ZERO(&write_fds);
                            FD_ZERO(&except_fds);

                            FD_SET(_Socket->GetSocket(), &read_fds);

                            struct timeval to;

                            to.tv_sec = 30;
                            to.tv_usec = 0;
                            int n = _I_select(1, &read_fds, &write_fds, &except_fds, &to);
                            if (n > 0) {
                                goto read_again;
                            }
                        }
                    }


                    bytesAvailable = _QueryBytesAvailable;

                    //
                    // note the amount of data that is available immediately.
                    // This allows e.g. async InternetReadFile() to complete
                    // synchronously if the next request is for <= bytesAvailable
                    //

                    //SetAvailableDataLength(bytesAvailable);

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("%d bytes available in socket %#x\n",
                                bytesAvailable,
                                (_Socket ? _Socket->GetSocket() : 0)
                                ));

                    if ((bytesAvailable == 0)
                    && (IsChunkEncoding() ? IsChunkedEncodingFinished() : TRUE)) {
                        fsm.m_bEof = TRUE;
                    }
                    if (IsKeepAlive() && IsContentLength()) {
                        _BytesInSocket -= bytesAvailable;

                        INET_ASSERT((int)_BytesInSocket >= 0);

                        if ((int)_BytesInSocket < 0) {
                            _BytesInSocket = 0;
                        }
                    }
                }
            }
        } else {

            //
            // all data read from socket & socket released
            //

            INET_ASSERT(error == ERROR_SUCCESS);
            INET_ASSERT(bytesAvailable == 0);

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("no socket\n"
                        ));

            fsm.m_bEof = TRUE;
        }
    } else {

        INET_ASSERT(error == ERROR_SUCCESS);

        //
        // we may have already removed all the data from the socket
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("all data has been read\n"
                    ));

        fsm.m_bEof = TRUE;
    }

quit:

    if ((error == ERROR_SUCCESS) && (bytesAvailable == 0)) {
        if (IsCacheWriteInProgress()) {
            LocalEndCacheWrite(TRUE);
        }
    }

    *fsm.m_lpdwNumberOfBytesAvailable = bytesAvailable;

    //
    // if we have reached the end of the data then we can release the connection
    //

    /*
    if (fsm.m_bEof || (bytesAvailable >= _BytesRemaining)) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }
    */
    if (fsm.m_bEof) {
        if (_Socket != NULL) {
            CloseConnection(FALSE);
        }
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse(
    OUT LPBOOL lpbDrained
    )

/*++

Routine Description:

    Receives any remaining response data into the buffer we allocated for the
    headers. Used in redirection: if the server returns some HTML page (e.g.)
    with the redirection response, we give the app a chance to read it. This
    way, we allow the app to retrieve the data immediately during the status
    callback in which we indicate that the request has been redirected

Arguments:

    lpbDrained  - TRUE if we really drained the socket else FALSE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to ERROR_INTERNET_XXX

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse",
                 "%#x",
                 lpbDrained
                 ));

    DWORD error = DoFsm(new CFsm_DrainResponse(lpbDrained, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_DrainResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_DrainResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_DrainResponse * stateMachine = (CFsm_DrainResponse *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->DrainResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm(
    IN CFsm_DrainResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::DrainResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_DrainResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    BOOL drainIt = FALSE;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (fsm.GetState() == FSM_STATE_CONTINUE) {
        drainIt = TRUE;
        goto fsm_continue;
    }

    PERF_LOG(PE_TRACE, 0x8001);

    drainIt = TRUE;

    //
    // if the socket is already closed, we can't drain it
    //

    if ((_Socket == NULL) || !_Socket->IsValid()) {
        drainIt = FALSE;
    } else if (IsWantKeepAlive()) {

        //
        // IIS 1.0 has a bug where it can return a failure indication to a
        // request that was made using a keep-alive connection. The response
        // doesn't contain a keep-alive header but the server has left open the
        // connection AND it has returned us fewer bytes than was claimed in
        // the content-length header. If we try to drain the response buffer at
        // this point, we will wait a long time waiting for the server to send
        // us the non-existent additional bytes. Therefore, if we are talking
        // to an IIS 1.0 server, we don't drain the response buffer
        //

        LPSTR lpszServerBuf;
        DWORD serverBufferLength;

        _ResponseHeaders.LockHeaders();

        error = FastQueryResponseHeader(HTTP_QUERY_SERVER,
                                        (LPVOID *)&lpszServerBuf,
                                        &serverBufferLength,
                                        0
                                        );
        if (error == ERROR_SUCCESS) {

#define IIS         "Microsoft-IIS/"
#define IIS_LEN     (sizeof(IIS) - 1)

#define PWS         "Microsoft-PWS/"
#define PWS_LEN     (sizeof(PWS) - 1)

#define PWS95       "Microsoft-PWS-95/"
#define PWS95_LEN   (sizeof(PWS95) - 1)

#define IIS10       "Microsoft-Internet-Information-Server/"
#define IIS10_LEN   (sizeof(IIS10) - 1)

            if ((serverBufferLength > IIS_LEN)
                && !strnicmp(lpszServerBuf, IIS, IIS_LEN)) {

                int major_num = 0;

                for (DWORD i = IIS_LEN; i < serverBufferLength; ++i) {

                    char ch = lpszServerBuf[i];

                    if (isdigit(ch)) {
                        major_num = major_num * 10 + (int)(ch - '0');
                    } else {
                        break;
                    }
                }
                if (major_num < 4) {
                    drainIt = FALSE;
                }
            } else if (IsBadNSServer()) {
                drainIt = FALSE;
            } else if (((serverBufferLength > IIS10_LEN)
                        && !strncmp(lpszServerBuf, IIS10, IIS10_LEN))
                       || ((serverBufferLength > PWS_LEN)
                           && !strncmp(lpszServerBuf, PWS, PWS_LEN))
                       || ((serverBufferLength > PWS95_LEN)
                           && !strncmp(lpszServerBuf, PWS95, PWS95_LEN))) {
                drainIt = FALSE;
            }
        }
        _ResponseHeaders.UnlockHeaders();
    }

    error = ERROR_SUCCESS;

    if (drainIt) {

        fsm.m_dwAsyncFlags = IsAsyncHandle() ? SF_WAIT : 0;
        fsm.m_dwAmountToRead = IsContentLength() ? _BytesInSocket : (DWORD)-1;
        //DWORD bufferLeft = _ResponseBufferLength - _BytesReceived;
        fsm.m_dwBufferLeft = min(fsm.m_dwAmountToRead, _ResponseBufferLength - _BytesReceived);

        if (IsChunkEncoding() && IsChunkedEncodingFinished()) {
            fsm.m_dwAmountToRead = 0;
            fsm.m_bEof = TRUE;

            INET_ASSERT(fsm.m_dwBytesReceived == 0);

        }

        //
        // either receive the amount specified in the "Content-Length" header, or
        // receive until we hit the end of the connection. We may have already
        // received the entire response
        //

        while ((fsm.m_dwAmountToRead != 0) && !fsm.m_bEof && (error == ERROR_SUCCESS)) {

            fsm.m_dwPreviousBytesReceived = _BytesReceived;

            //
            // receive the rest of the data. We are assuming here that it is a
            // couple of K at the most. Notice that we don't care to make status
            // callbacks to the app while we are doing this
            //

            //INET_ASSERT(fsm.m_dwBufferLeft <= _BytesRemaining);

            error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                     &_ResponseBufferLength,
                                     &fsm.m_dwBufferLeft,
                                     &_BytesReceived,
                                     0,   // dwExtraSpace
                                     SF_EXPAND
                                     | SF_COMPRESS
                                     | fsm.m_dwAsyncFlags,
                                     &fsm.m_bEof
                                     );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

fsm_continue:

            if (error == ERROR_SUCCESS) {

                DWORD nRead = _BytesReceived - fsm.m_dwPreviousBytesReceived;

                if (IsContentLength()) {
                    fsm.m_dwAmountToRead -= nRead;

                    INET_ASSERT((int)fsm.m_dwAmountToRead >= 0);

                    _BytesInSocket -= nRead;

                    INET_ASSERT((int)_BytesInSocket >= 0);

                    if (IsKeepAlive()) {
                        _BytesRemaining -= nRead;

                        INET_ASSERT((int)_BytesRemaining >= 0);

                        //
                        // if we have read all the entity-body then we can
                        // release the keep-alive connection, or close the
                        // socket
                        //

                        //
                        // BUGBUG - put back post-ie30a
                        //

                        //if (_BytesRemaining == 0) {
                        //    fsm.m_bEof = TRUE;
                        //}
                    }
                }

                if ( IsChunkEncoding() )
                {
                    LPSTR lpszNewBuffer;
                    DWORD dwNewBufferLength;

                    INET_ASSERT(!IsContentLength());

                    error = _ctChunkInfo.ParseChunkInput(
                        (LPSTR) (_ResponseBuffer + fsm.m_dwPreviousBytesReceived),
                        nRead,
                        &lpszNewBuffer,
                        &dwNewBufferLength
                        );

                    nRead = dwNewBufferLength;
                    _BytesReceived = nRead + fsm.m_dwPreviousBytesReceived;

                    INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.
                    if ( error != ERROR_SUCCESS )
                    {
                        break;
                    }

                    if ( IsChunkedEncodingFinished() )
                    {
                        fsm.m_bEof = TRUE;
                        break;
                    }
                }

                fsm.m_dwBytesReceived += nRead;
                fsm.m_dwPreviousBytesReceived = _BytesReceived;
            }
        }
    }

    if (error == ERROR_SUCCESS) {

        //
        // update the amount of data immediately available to the caller
        //

        IncreaseAvailableDataLength(fsm.m_dwBytesReceived);

        //
        // and set the end-of-file indication in the top level handle object
        //

        SetEndOfFile();

        //
        // there is no more data to be received on this HTTP object
        //

        //SetData(FALSE);

        //
        // this object can now be re-used
        //

        SetState(HttpRequestStateReopen);
    }

    //
    // return indication that we drained the socket
    //

    DEBUG_PRINT(HTTP,
                INFO,
                ("returning *lpbDrained = %B\n",
                drainIt
                ));

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        *fsm.m_lpbDrained = drainIt;
    }

    PERF_LOG(PE_TRACE, 0x8002);

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout(
    VOID
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::SetBadNSReceiveTimeout",
                 NULL
                 ));

    if ((_Socket != NULL)
        && !IsContentLength()
        && !IsChunkEncoding()) {

        CServerInfo * pServerInfo = GetServerInfo();

        if (pServerInfo) {

            DWORD timeout = max(5000, 5 * pServerInfo->GetRTT());

            _Socket->SetTimeout(RECEIVE_TIMEOUT, timeout);
            SetTimeout(INTERNET_OPTION_RECEIVE_TIMEOUT, timeout);
        }
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\redirect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    redirect.cxx

Abstract:

    Contains HTTP_REQUEST_HANDLE_OBJECT method for handle redirection

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::Redirect

Author:

    Richard L Firth (rfirth) 18-Feb-1996

Environment:

    Win32 user-level

Revision History:

    18-Feb-1996 rfirth
        Created
	
--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// manifests
//

#define DEFAULT_COOKIE_BUFFER_LENGTH    (1 K)

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect(
    IN HTTP_METHOD_TYPE tMethod,
    IN BOOL fRedirectToProxy
    )

/*++

Routine Description:

    Called after a successful SendData() in which we discover that the requested
    object has been moved.

    We need to change the HTTP_REQUEST_HANDLE_OBJECT so that we can resubmit the
    request and retrieve the redirected object.

    To do this we have to:

        get the new URI
        crack the new URI
        if callbacks are enabled or the server is the same and we are using keep-alive
            drain the current response into the response buffer
        if we are not using keep-alive
            kill the connection
        if callbacks are enabled
            indicate redirection to the app
        create a new request header
        if the server or port has changed
            update the local server & port information

Arguments:

    tMethod - new request method type (e.g. if POST => GET), or POST => POST ( for HTTP 1.1)

    fRedirectToProxy  - TRUE if we're actually redirected to use a proxy instead of another site


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "Redirect",
                "%s, %x",
                MapHttpMethodType(tMethod),
                fRedirectToProxy
                ));

    DWORD error = DoFsm(new CFsm_Redirect(tMethod, fRedirectToProxy, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_Redirect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_Redirect::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_Redirect * stateMachine = (CFsm_Redirect *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->Redirect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm(
    IN CFsm_Redirect * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::Redirect_Fsm",
                 "%#x",
                 Fsm
                 ));

    DWORD index;
    LPSTR uriBuffer = NULL;
    DWORD uriLength = INTERNET_MAX_PATH_LENGTH;
    CFsm_Redirect & fsm = *Fsm;
    DWORD error = fsm.GetError();
    char *buffer = NULL;

    AUTHCTX* pAuthCtx = GetAuthCtx();
    AUTHCTX::SPMScheme eAuthScheme = AUTHCTX::SCHEME_UNKNOWN;
    if (pAuthCtx != NULL)
    {
        eAuthScheme = pAuthCtx->GetSchemeType();
    }

    // For redirects, this should be reset ( if it ever was set. )
    _fSendUTF8ServerNameToProxy = FALSE;
    
    _ResponseHeaders.LockHeaders();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (fsm.GetState() == FSM_STATE_INIT) {

        if (GlobalAlwaysDrainOnRedirect || !IsKeepAlive() || IsContentLength() || IsChunkEncoding()) {
            error = DrainResponse(&fsm.m_bDrained);
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }
    }

    if (eAuthScheme == AUTHCTX::SCHEME_PASSPORT)
    {
        PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)pAuthCtx;
        if (pPPCtx->m_lpszRetUrl)
        {
        ReplaceResponseHeader(HTTP_QUERY_LOCATION, 
                              pPPCtx->m_lpszRetUrl, 
                              strlen(pPPCtx->m_lpszRetUrl), 
                              0, 
                              HTTP_ADDREQ_FLAG_REPLACE);

        delete [] pPPCtx->m_lpszRetUrl;
        pPPCtx->m_lpszRetUrl = NULL;
        }
    }

    //
    // get the "Location:" header
    //
    // BUGBUG - we also need to get & parse the "URI:" header(s)
    //

    do {

        //
        // we allow ourselves to fail due to insufficient buffer (at least once)
        //

        uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength, FALSE);
        if (uriBuffer != NULL) {

            DWORD previousLength = uriLength;

            index = 0;

            error = QueryResponseHeader(HTTP_QUERY_LOCATION,
                                        uriBuffer,
                                        &uriLength,
                                        0,      // no modifiers
                                        &index  // should only be one
                                        );
            if (error == ERROR_SUCCESS) {

                //
                // we probably allocated too much buffer - shrink it
                //

                uriBuffer = (LPSTR)ResizeBuffer(uriBuffer, uriLength + 1, FALSE);

                //
                // check for NULL below
                //

            } else if ((error == ERROR_INSUFFICIENT_BUFFER)
            && (previousLength >= uriLength)) {

                //
                // this should never happen, but we will avoid a loop if it does
                //

                INET_ASSERT(FALSE);

                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        }
        if (uriBuffer == NULL) {

            //
            // failed to (re)alloc or shrink
            //

            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } while (error == ERROR_INSUFFICIENT_BUFFER);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    ////
    //// strip all cookie request headers
    ////
    //
    //RemoveAllRequestHeadersByName("Cookie");
    //
    ////
    //// and add any we received
    ////
    //
    //DWORD headerLength;
    //DWORD bufferLength;
    //LPVOID lpHeader;
    //
    //bufferLength = DEFAULT_COOKIE_BUFFER_LENGTH;
    //lpHeader = (LPVOID)ResizeBuffer(NULL, bufferLength, FALSE);
    //if (lpHeader == NULL) {
    //    error = ERROR_NOT_ENOUGH_MEMORY;
    //    goto quit;
    //}
    //
    //index = 0;
    //
    //do {
    //    headerLength = bufferLength;
    //    error = QueryResponseHeader("Set-Cookie",
    //                                sizeof("Set-Cookie") - 1,
    //                                lpHeader,
    //                                &headerLength,
    //                                0,
    //                                &index
    //                                );
    //    if (error == ERROR_INSUFFICIENT_BUFFER) {
    //        error = ERROR_SUCCESS;
    //        bufferLength = headerLength;
    //        lpHeader = (LPVOID)ResizeBuffer((HLOCAL)lpHeader,
    //                                        bufferLength,
    //                                        FALSE
    //                                        );
    //        if (lpHeader == NULL) {
    //            error = ERROR_NOT_ENOUGH_MEMORY;
    //            goto quit;
    //        }
    //    } else if (error == ERROR_SUCCESS) {
    //        error = AddRequestHeader("Cookie",
    //                                 sizeof("Cookie") - 1,
    //                                 (LPSTR)lpHeader,
    //                                 headerLength,
    //                                 0,
    //                                 0
    //                                 );
    //    }
    //} while (error == ERROR_SUCCESS);
    //
    //INET_ASSERT(error == ERROR_HTTP_HEADER_NOT_FOUND);

    //
    // we may have been given a partial URL. Combine it with the current base
    // URL. If both are base URLs then we just get back the new one
    //

    DWORD newUrlLength;
    buffer = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_URL_LENGTH + 1);

    if (buffer == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    newUrlLength = INTERNET_MAX_URL_LENGTH;

    INET_ASSERT(GetURL() != NULL);

    if (!InternetCombineUrl(GetURL(),
                            uriBuffer,
                            buffer,
                            &newUrlLength,
                            ICU_ENCODE_SPACES_ONLY)) {
        error = GetLastError();
        if (error == ERROR_INSUFFICIENT_BUFFER) {
            error = ERROR_HTTP_REDIRECT_FAILED;
        }

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // we are done with uriBuffer
    //

    uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

    INET_ASSERT(uriBuffer == NULL);

    //
    // if we ended up with exactly the same URL then we're done. Note that the
    // URLs may be the same, even if they're lexicographically different - host
    // name vs. IP address e.g., encoded vs. unencoded, case sensitive? In the
    // encoded case, the URLs should be in canonical form. We may have an issue
    // with host vs IP address which will lead to an additional transaction
    //

    if (!fsm.m_fRedirectToProxy &&
        (eAuthScheme != AUTHCTX::SCHEME_PASSPORT) &&
        !strcmp(GetURL(), buffer))   
        // Passport1.4 auth need redirect to same site works
    {
        DEBUG_PRINT(HTTP,
                    INFO,
                    ("URLs match: %q, %q\n",
                    GetURL(),
                    buffer
                    ));

        error = ERROR_HTTP_NOT_REDIRECTED;
        goto quit;
    }

    //
    // crack the new URL
    //

    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT port;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extra;
    DWORD extraLength;

    error = CrackUrl(buffer,
                     newUrlLength,
                     FALSE, // don't escape URL-path
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &port,
                     NULL,  // don't care about user name
                     NULL,
                     NULL,  // or password
                     NULL,
                     &urlPath,
                     &urlPathLength,
                     &extra,
                     &extraLength,
                     NULL
                     );
    if ((error != ERROR_SUCCESS) || (hostNameLength == 0)) {

        //
        // if this is an URL for which we don't understand the protocol then
        // defer redirection to the caller
        //

        if (error == ERROR_INTERNET_UNRECOGNIZED_SCHEME) {
            error = ERROR_HTTP_REDIRECT_FAILED;
        } else if (hostNameLength == 0) {
            error = ERROR_HTTP_NOT_REDIRECTED;
        }
        goto quit;
    }

    //
    // if the scheme is not HTTP or HTTPS then we can't automatically handle it.
    // We have to return it to the caller. For example, we cannot transmogrify
    // a HTTP handle to an FTP directory handle, and there's no way we can
    // handle a file:// URL (we don't understand file://)
    //

    if ((schemeType != INTERNET_SCHEME_HTTP)
    && (schemeType != INTERNET_SCHEME_HTTPS)) {
        error = ERROR_HTTP_REDIRECT_FAILED;
        goto quit;
    }

    //
    // BUGBUG - we may get back an IP address (IPX?) in which case we need to
    //          resolve it again
    //

    //
    // map port
    //

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT;
    }

    //
    // if the server & port remain the same and we are using keep-alive OR
    // we think the app may want to read any data associated with the redirect
    // header (i.e. callbacks are enabled) then drain the response
    //

    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;
    INTERNET_SCHEME currentSchemeType;

    currentHostPort = GetHostPort();
    currentHostName = GetHostName(&currentHostNameLength);
    currentSchemeType = ((INTERNET_FLAG_SECURE & GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    //
    // close the connection
    //

    //
    // BUGBUG - if we are redirecting to the same site and we have a keep-alive
    //          connection, then we don't have to do this. Worst case is that
    //          we go to get the keep-alive connection and some other bounder
    //          has taken it
    //

    //
    // if we didn't actually drain the socket because of the server type or
    // because there was no or incorrect data indication then force the
    // connection closed (if keep-alive)
    //

    CloseConnection(fsm.m_bDrained ? FALSE : TRUE);

    //
    // inform the app of the redirection. At this point, we have received all
    // the headers and data associated with the original request. We have not
    // modified the object with information for the new request. This is so
    // the application can query information about the original request - e.g.
    // the original URL - before we make the new request for the redirected item
    //

    InternetIndicateStatusString(INTERNET_STATUS_REDIRECT, buffer);

    //
    // BUGBUG - app may have closed the request handle
    //

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            newUrlLength -= extraLength;
        } else {
            urlPathLength += extraLength;
        }
    }

    //
    // create the new request line. If we're going via proxy, add the entire URI
    // else just the URL-path
    //

    //
    // BUGBUG - do we need to perform any URL-path escaping here?
    //

    //
    // BUGBUG - always modifying POST to GET
    //

    //
    // BUGBUG - [arthurbi]
    //   this breaks For HTTPS sent over  HTTP to
    //   a proxy which turns it into HTTPS.
    //

    //INET_ASSERT(fsm.m_tMethod == HTTP_METHOD_TYPE_GET);

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    INTERNET_HANDLE_OBJECT * pInternet;

    pInternet = (INTERNET_HANDLE_OBJECT * )pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    //
    // Set Url in the request object. Authentication, and Cookies
    //  depend on checking the new URL not the previous one.
    //

    BYTE bTemp;

    bTemp = buffer[newUrlLength];
    buffer[newUrlLength] = 0;

    BOOL fSuccess;

    if ( !fsm.m_fRedirectToProxy )
    {
        UrlCacheUnlock();
        fSuccess = SetURL(buffer);
        buffer[newUrlLength] = bTemp;

        if (!fSuccess) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        // Force revalidation of the security zone
        GetSecurityZone(TRUE);

        //
        // update the method, server and port, if they changed
        //

        SetMethodType(fsm.m_tMethod);
        SetPWC(NULL);

        if (port != currentHostPort) {
            SetHostPort(port);
        }
        if ((hostNameLength != currentHostNameLength)
        || (strnicmp(hostName, currentHostName, hostNameLength) != 0)) {

            char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
            LPSTR hostValueStr;
            DWORD hostValueSize; 

            CHAR chBkChar = hostName[hostNameLength]; // save off char

            hostName[hostNameLength] = '\0';
            SetHostName(hostName);

            hostValueSize = hostNameLength;
            hostValueStr = hostName;            

            if ((port != INTERNET_DEFAULT_HTTP_PORT)
            &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
                if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
                {
                    hostName[hostNameLength] = chBkChar; // put back char
                    error = ERROR_INVALID_PARAMETER;
                    goto quit;
                }
                hostValueSize = wsprintf(hostValue, "%s:%d", hostName, (port & 0xffff));
                hostValueStr = hostValue;
            }

            hostName[hostNameLength] = chBkChar; // put back char
    
            //
            // replace the "Host:" header
            //

            ReplaceRequestHeader(HTTP_QUERY_HOST,
                                 hostValueStr,
                                 hostValueSize,
                                 0, // dwIndex
                                 ADD_HEADER
                                 );

            //
            // and get the corresponding server info, resolving the name if
            // required
            //

            SetServerInfo(FALSE);

            //
            // Since we are redirecting to a different host, force an update of the origin
            // server.  Otherwise, we will still pick up the proxy info of the first server.
            //
            SetOriginServer(TRUE);
        }

        //
        // if the new method is GET then remove any content-length headers (there
        // *should* only be 1!) - we won't be sending any data on the redirected
        // request. Remove any content-type (again should only be 1) also
        //

        if (fsm.m_tMethod == HTTP_METHOD_TYPE_GET) {
            RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_LENGTH);
            RemoveAllRequestHeadersByName(HTTP_QUERY_CONTENT_TYPE);
        }

        //
        // Catch Redirections from HTTPS to HTTP (and) HTTP to HTTPS
        //

        if ( currentSchemeType != schemeType )
        {
            DWORD OpenFlags;

            OpenFlags = GetOpenFlags();

            //
            // Switched From HTTPS to HTTP
            //

            if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
            {
                INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

                OpenFlags &= ~(INTERNET_FLAG_SECURE);

                //
                // Allow the Global to shut off this behavior.
                //

                if ( !(OpenFlags & INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP))
                {
                    if ( OpenFlags & INTERNET_FLAG_FORMS_SUBMIT ||
                         fsm.m_tMethod == HTTP_METHOD_TYPE_POST )
                    {
                        if(GlobalWarnOnHTTPSToHTTPRedirect) 
                            error = ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR;
                    }
                    else if (GlobalWarnOnZoneCrossing)
                    {
                        error = ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR;
                    }
                }
            }

            //
            // Switched From HTTP to HTTPS
            //

            else if ( schemeType == INTERNET_SCHEME_HTTPS )
            {
                INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

                OpenFlags |= (INTERNET_FLAG_SECURE);

                // Make sure SSL is loaded now
                error = LoadSecurity();

                //
                // Allow the Global to shut off this behavior.
                //
                if ( ERROR_SUCCESS == error &&
                     !(OpenFlags & INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS) &&
                      GlobalWarnOnZoneCrossing )
                {
                    error = ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR;
                }
            }


            SetOpenFlags(OpenFlags);
            SetSchemeType(schemeType);

        }

        //
        // remember the "Refresh" header if it exists. If we received the header and
        // get redirected to a site that doesn't return "Refresh" then we need to
        // use the original version
        //

        DWORD err;
        DWORD length;

        length = newUrlLength - (sizeof("Refresh: ") - 1);
        index = 0;
        err = QueryResponseHeader(HTTP_QUERY_REFRESH,
                                  &buffer[sizeof("Refresh: ") - 1],
                                  &length,
                                  0,  // dwModifiers
                                  &index
                                  );
        if (err == ERROR_SUCCESS) {

            DWORD len;

            memcpy(buffer, "Refresh: ", sizeof("Refresh: ") - 1);
            SetRefreshHeader(buffer, length + (sizeof("Refresh: ") - 1));
        }
    }
    else
    {
        LPSTR proxyHostName;

        //
        // We're Redirected to a use a new proxy, set the
        //  new proxy atttributes
        //

        proxyHostName = (LPSTR) ALLOCATE_MEMORY(LMEM_FIXED, hostNameLength+1);

        if ( proxyHostName == NULL )
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        memcpy(proxyHostName, hostName, hostNameLength);
        proxyHostName[hostNameLength] = '\0';

        SetProxyName(proxyHostName, hostNameLength, port);

        SetOverrideProxyMode(TRUE);
    }

quit:

    if (buffer != NULL)
    {
        FREE_MEMORY(buffer);
    }

    if (uriBuffer != NULL)
    {
        uriBuffer = (LPSTR)FREE_MEMORY((HLOCAL)uriBuffer);

        INET_ASSERT(uriBuffer == NULL);
    }

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    _ResponseHeaders.UnlockHeaders();

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\send.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the HTTP Request Handle Object SendRequest method

    Contents:
        CFsm_SendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_SendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_SendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    START_SENDREQ_PERF();

    CFsm_SendRequest * stateMachine = (CFsm_SendRequest *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->SendRequest_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm(
    IN CFsm_SendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::SendRequest_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(SendRequest_Fsm);

    CFsm_SendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    LPSTR requestBuffer = fsm.m_pRequestBuffer;
    DWORD requestLength = fsm.m_dwRequestLength;
    LPVOID lpOptional = fsm.m_lpOptional;
    DWORD dwOptionalLength = fsm.m_dwOptionalLength;
    BOOL bExtraCrLf = fsm.m_bExtraCrLf;

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    switch (state) {

    case FSM_STATE_INIT:

    fsm.SetFunctionState(FSM_STATE_1);
    error = DoFsm(new CFsm_MakeConnection(this));


    case FSM_STATE_1:

        if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {
            goto quit;
        }

        DEBUG_PRINT(
            HTTP,
            INFO,
            ("authstate=%x [%s]\n", GetAuthState(), InternetMapAuthState(GetAuthState()))
            );

        // # 62953
        // If initiating MSN or NTLM authentication, don't submit request data since
        // we're expecting to get a challenge and resubmit the request anyway.
        if (GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            if (!((PLUG_CTX*)(GetAuthCtx()))->_fNTLMProxyAuth
                && !(GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_DPA))
            {
                // We are in the negotiate phase during a POST
                // and do not have an authenticated socket. 
                // In both monolithic upload InternetWriteFile
                // cases, we wish to omit any post data, and reflect
                // this in the content length.
                if (!((GetMethodType() == HTTP_METHOD_TYPE_GET) && !IsMethodBody()))
                {
                    ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                         "0",
                                         1,
                                         0,   // dwIndex
                                         ADD_HEADER
                                         );
                }

                // Monolithic upload: If we have optional data to send,
                // save off in handle and flag that the data has been saved.
                if (fsm.m_lpOptional && fsm.m_dwOptionalLength)
                {
                    DEBUG_PRINT(
                        HTTP,
                        INFO,
                        ("omitting request data due to authstate=%x [%s]\n", GetAuthState(), InternetMapAuthState(GetAuthState()))
                        );

                    _lpOptionalSaved = fsm.m_lpOptional;
                    _dwOptionalSaved = fsm.m_dwOptionalLength;
                    fsm.m_lpOptional = lpOptional = NULL;
                    fsm.m_dwOptionalLength = dwOptionalLength = 0;
                    _fOptionalSaved = TRUE;
                }            
            }        
        }
        else
        {
            // Check if optional data has been saved in handle during a previous
            // negotiate stage. If so, restore it and content length and clear flag.
            if (_fOptionalSaved)
            {
                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("restoring request data due to authstate=%x [%s]\n", GetAuthState(), InternetMapAuthState(GetAuthState()))
                    );

                // Reset the fsm optional values and content length.
                
                lpOptional = fsm.m_lpOptional = _lpOptionalSaved;
                dwOptionalLength = fsm.m_dwOptionalLength = _dwOptionalSaved;
                _dwOptionalSaved = 0;
                _lpOptionalSaved = NULL;
                _fOptionalSaved = FALSE;

                DWORD cbNumber;
                CHAR szNumber[sizeof("4294967295")];
                cbNumber = wsprintf(szNumber, "%d", fsm.m_dwOptionalLength);

                ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                    (LPSTR)szNumber,
                                    cbNumber,
                                    0,   // dwIndex
                                    ADD_HEADER
                                    ); 
            }

        }


        bExtraCrLf = (!(GetOpenFlags() & INTERNET_FLAG_SECURE)
                      && (dwOptionalLength != 0)
                      && ((GetServerInfo() != NULL)
                        ? GetServerInfo()->IsHttp1_0()
                        : IsRequestHttp1_0())
                      && GlobalSendExtraCRLF);

        //
        // collect request headers into blob
        //

        BOOL bCombinedData;

        requestBuffer = CreateRequestBuffer(&requestLength,
                                            lpOptional,
                                            dwOptionalLength,
                                            bExtraCrLf,
                                            GlobalTransportPacketLength,
                                            &bCombinedData
                                            );
        if (requestBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        DEBUG_PRINT(HTTP, INFO, ("SendRequest_FSM: lpOptional=0x%x dwOptionalLength=%d\n", 
                                fsm.m_lpOptional, fsm.m_dwOptionalLength));

        if (bCombinedData) {

            //
            // everything copied to one buffer. No need to send separate
            // optional data and CR-LF termination
            //

            fsm.m_lpOptional = lpOptional = NULL;
            fsm.m_dwOptionalLength = dwOptionalLength = 0;
            bExtraCrLf = FALSE;
        }
        fsm.m_pRequestBuffer = requestBuffer;
        fsm.m_dwRequestLength = requestLength;
        fsm.m_bExtraCrLf = bExtraCrLf;
        DEBUG_PRINT(HTTP, INFO, ("fsm.m_pRequestBuffer=0x%x\r\n", fsm.m_pRequestBuffer));
        StartRTT();

        //
        // send the request. If we are using a keep-alive connection, this may
        // fail because the server timed it out since we last used it. We must
        // be prepared to re-establish
        //

        fsm.SetFunctionState(FSM_STATE_3);
        error = _Socket->Send(requestBuffer, requestLength, SF_INDICATE);

        //
        // fall through
        //

    case FSM_STATE_3:
        if (error != ERROR_SUCCESS) {
            if (error != ERROR_IO_PENDING) {
                CloseConnection(TRUE);
            }
            goto quit;
        }

        //
        // send any optional data (that we didn't send in the request buffer).
        // If this fails then we don't retry. We assume that if the first send
        // succeedeed, but the second failed, then this is a non-recoverable
        // error
        //

        //fsm.m_bExtraCrLf = bExtraCrLf = TRUE;
        if (dwOptionalLength != 0) {

            LPSTR buffer = (LPSTR)lpOptional;
            DWORD length = dwOptionalLength;

            if (bExtraCrLf) {
                length += sizeof(gszCRLF) - 1;
                if (requestLength >= length) {
                    buffer = requestBuffer;
                } else if (length <= GlobalTransportPacketLength) {
                    requestBuffer = (LPSTR)ResizeBuffer(requestBuffer,
                                                        length,
                                                        FALSE
                                                        );
                    buffer = requestBuffer;
                    fsm.m_pRequestBuffer = requestBuffer;
                } else {
                    length -= sizeof(gszCRLF) - 1;
                }
                if (buffer == requestBuffer) {
                    memcpy(buffer, lpOptional, dwOptionalLength);
                    buffer[dwOptionalLength] = '\r';
                    buffer[dwOptionalLength + 1] = '\n';
                    fsm.m_bExtraCrLf = bExtraCrLf = FALSE;
                }
            }
            fsm.SetFunctionState(FSM_STATE_4);
            error = _Socket->Send(buffer, length, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_4:

        //
        // Here we also add an extra CR-LF if the app is sending data (even if
        // the amount of data supplied is zero) unless we are using a keep-alive
        // connection, in which case we're not dealing with old servers which
        // require CR-LF at the end of post data.
        //
        // But only do this for non-HTTP 1.1 servers and proxies ( ie when
        //  the user puts us in HTTP 1.0 mode)
        //

        if ((error == ERROR_SUCCESS) && bExtraCrLf) {
            fsm.SetFunctionState(FSM_STATE_5);
            error = _Socket->Send(gszCRLF, 2, SF_INDICATE);
        }

        //
        // fall through
        //

    case FSM_STATE_5:

        //
        // we are now in receiving state
        //

        if (error == ERROR_SUCCESS) {
            SetState(HttpRequestStateResponse);
        }
        break;
    }

quit:

    if (error != ERROR_IO_PENDING) {
//dprintf("HTTP connect-send took %d msec\n", GetTickCount() - _dwQuerySetCookieHeader);
        fsm.SetDone();

        PERF_LEAVE(SendRequest_Fsm);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\sendapi.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    sendapi.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        HttpSendRequestA
        HttpSendRequestW
        HttpSendRequestExA
        HttpSendRequestExW
        HttpEndRequestA
        HttpEndRequestW
        HttpWrapSendRequest

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private prototypes
//

PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest
    );

//
// functions
//


INTERNETAPI_(BOOL) HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "HttpSendRequestA",
                "%#x, %.80q, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));


    BOOL fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                0,
                AR_HTTP_SEND_REQUEST
                );


    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER_API((DBG_API,
                Bool,
                "HttpSendRequestW",
                "%#x, %.80wq, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }
    if (lpszHeaders)
    {
        ALLOC_MB(lpszHeaders, dwHeadersLength, mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
    }
    fResult = HttpWrapSendRequest(hRequest, mpHeaders.psStr, mpHeaders.dwSize,
                lpOptional, dwOptionalLength, 0, AR_HTTP_SEND_REQUEST);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) HttpSendRequestExA(
        IN HINTERNET hRequest,
        IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
        OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
        IN DWORD dwFlags,
        IN DWORD_PTR dwContext
        )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersIn     -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    WINAPI

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpSendRequestExA",
                     "%#x, %#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersIn,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD error = ERROR_SUCCESS;
    LPCSTR lpszHeaders = NULL;
    DWORD dwHeadersLength = 0;
    LPVOID lpOptional = NULL;
    DWORD dwOptionalLength = 0;
    DWORD dwOptionalLengthTotal = 0;
    BOOL fRet = FALSE;

    if ( lpBuffersOut )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if ( lpBuffersIn )
    {
        if ( IsBadReadPtr(lpBuffersIn, sizeof(INTERNET_BUFFERSA)) ||
             lpBuffersIn->dwStructSize != sizeof(INTERNET_BUFFERSA) )
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        lpszHeaders           = lpBuffersIn->lpcszHeader;
        dwHeadersLength       = lpBuffersIn->dwHeadersLength;
        lpOptional            = lpBuffersIn->lpvBuffer;
        dwOptionalLength      = lpBuffersIn->dwBufferLength;
                dwOptionalLengthTotal = lpBuffersIn->dwBufferTotal;
    }

    fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwOptionalLengthTotal,
                AR_HTTP_BEGIN_SEND_REQUEST
                );

quit:

    if ( error != ERROR_SUCCESS )
    {
        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        fRet = FALSE;
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) HttpSendRequestExW(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSW lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersIn     -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpSendRequestExW",
                     "%#x, %#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersIn,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;
    LPVOID pOptional = NULL;
    DWORD dwOptionalLength = 0;
    DWORD dwOptionalLengthTotal = 0;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else 
    {
        if ( lpBuffersIn )
        {
            if (IsBadReadPtr(lpBuffersIn, sizeof(INTERNET_BUFFERS))
                ||
                (lpBuffersIn->dwStructSize != sizeof(INTERNET_BUFFERSW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            if (lpBuffersIn->lpcszHeader)
            {
                ALLOC_MB(lpBuffersIn->lpcszHeader, lpBuffersIn->dwHeadersLength, mpHeaders);
                if (!mpHeaders.psStr)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }
                UNICODE_TO_ANSI(lpBuffersIn->lpcszHeader, mpHeaders);
            }
            pOptional            = lpBuffersIn->lpvBuffer;
            dwOptionalLength      = lpBuffersIn->dwBufferLength;
            dwOptionalLengthTotal = lpBuffersIn->dwBufferTotal;
        }

        fResult = HttpWrapSendRequest(
                hRequest,
                mpHeaders.psStr,
                mpHeaders.dwSize,
                pOptional,
                dwOptionalLength,
                dwOptionalLengthTotal,
                AR_HTTP_BEGIN_SEND_REQUEST
                );
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) HttpEndRequestA(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    WINAPI

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpEndRequestA",
                     "%#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD error = ERROR_SUCCESS;
    IN LPCSTR lpszHeaders = NULL;
    IN DWORD dwHeadersLength = 0;
    IN LPVOID lpOptional = NULL;
    IN DWORD dwOptionalLength = 0;
    BOOL fRet = FALSE;

    if ( lpBuffersOut )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    fRet= HttpWrapSendRequest(
                hRequest,
                NULL,
                0,
                NULL,
                0,
                0,
                AR_HTTP_END_SEND_REQUEST
                );

quit:

    if ( error != ERROR_SUCCESS )
    {
        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        fRet = FALSE;
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) HttpEndRequestW(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "HttpEndRequestW",
                     "%#x, %#x, %#x, %#x",
                     hRequest,
                     lpBuffersOut,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        fResult = HttpWrapSendRequest(hRequest, NULL, 0, NULL, 0, 0, AR_HTTP_END_SEND_REQUEST);
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total length need to be sent for File Upload.

    arRequest               - Which API the caller is making,
                                assumed to be HttpEndRequestA, HttpSendRequestExA, or
                                HttpSendRequestA

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HttpWrapSendRequest",
                 "%#x, %.80q, %d, %#x, %d, %d",
                 hRequest,
                 lpszHeaders,
                 dwHeadersLength,
                 lpOptional,
                 dwOptionalLength,
                 dwOptionalLengthTotal
                 ));

    PERF_ENTER(HttpWrapSendRequest);

    DWORD error = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we will need the thread info for several items
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //
    // the only FSMs that can come before this one are InternetOpenUrl() or
    // HttpSendRequest() when we are performing nested send for https://
    // tunnelling through proxy
    //

    INET_ASSERT((lpThreadInfo->Fsm == NULL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_PARSE_HTTP_URL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_OPEN_PROXY_TUNNEL)
                );

    INET_ASSERT( arRequest == AR_HTTP_SEND_REQUEST ||
                 arRequest == AR_HTTP_BEGIN_SEND_REQUEST ||
                 arRequest == AR_HTTP_END_SEND_REQUEST );


    //
    // map the handle
    //
    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);


    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Cast it to the object that we know. We are going to do caching
    // semantics with this
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    //
    // set the context and handle info & reset the error variables
    //


    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hRequestMapped)->GetContext()
                        );
    _InternetSetObjectHandle(lpThreadInfo, hRequest, hRequestMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle was invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // use RIsHandleLocal() to discover 4 things:
    //
    //  1. Handle is valid
    //  2. Handle is of expected type (HTTP Request in this case)
    //  3. Handle is local or remote
    //  4. Handle supports async I/O
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // For SEND_REQUEST, and BEGIN_SEND_REQUEST, we need
    //  to do some basic initalization
    //

    if ( arRequest == AR_HTTP_SEND_REQUEST ||
         arRequest == AR_HTTP_BEGIN_SEND_REQUEST)
    {
        BOOL fGoneOffline = FALSE;


        error = pRequest->InitBeginSendRequest(lpszHeaders,
                                       dwHeadersLength,
                                       &lpOptional,
                                       &dwOptionalLength,
                                       dwOptionalLengthTotal,
                                       &fGoneOffline
                                       );

        if ( error != ERROR_SUCCESS || fGoneOffline )
        {
            if ( error == ERROR_INTERNET_CACHE_SUCCESS )
            {
                error = ERROR_SUCCESS;
            }

            goto quit;
        }
    }


    //
    // send the request to the server. This may involve redirections and user
    // authentication
    //

    //error = DoFsm(new CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest));
    //if (error == ERROR_IO_PENDING) {
    //    bDeref = FALSE;
    //}
    CFsm_HttpSendRequest * pFsm;

    pFsm = new CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest);

    if (pFsm != NULL) {
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread) {
            error = pFsm->QueueWorkItem();
        } else {
            error = DoFsm(pFsm);
        }
        if (error == ERROR_IO_PENDING) {
            bDeref = FALSE;
        }
    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    //
    // if we went async don't deref the handle
    //

    if (bDeref && (hRequestMapped != NULL)) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

done:

    BOOL success = TRUE;

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(HttpWrapSendRequest);

    if (error != ERROR_SUCCESS) {

        SetLastError(error);
        DEBUG_ERROR(HTTP, error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\response.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    response.cxx

Abstract:

    This file contains the HTTP Request Handle Object ReceiveResponse method

    Contents:
        CFsm_ReceiveResponse::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// private manifests
//

#define DEFAULT_RESPONSE_BUFFER_LENGTH  (1 K)

//
// HTTP Request Handle Object methods
//


DWORD
CFsm_ReceiveResponse::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReceiveResponse::RunSM",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReceiveResponse * stateMachine = (CFsm_ReceiveResponse *)Fsm;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    DWORD error;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pRequest->ReceiveResponse_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm(
    IN CFsm_ReceiveResponse * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
#if INET_DEBUG
//#define RLF_TEST_CODE
#ifdef RLF_TEST_CODE

//
// single 100 response
//

#define TEST_HEADER_0   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n"

//
// single 100 header
//

#define TEST_HEADER_1   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// continue header with moderate amount of data
//

#define TEST_HEADER_2   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Content-Length: 128\r\n" \
                        "Content-Type: octet/shmoctet\r\n" \
                        "\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef"

//
// continue header seen from apache server
//

#define TEST_HEADER_3   "HTTP/1.1 100 Continue\r\n" \
                        "\r\n" \
                        "\n\n\n\n\n"

//
// multiple continue headers, no data
//

#define TEST_HEADER_4   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n" \
                        "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "\r\n"

//
// single 100 response, preceeded by preamble and containing a chunked response
//

#define TEST_HEADER_5   "!!!! this is a pre-amble, should be ignored even though it includes HTTP !!!!" \
                        "     " \
                        "HTTP/1.1 100 Go ahead punk, make my day\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0010 this is the first chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "  10; this is the second chunk (16 bytes)\r\n" \
                        "0123456789abcdef" \
                        "\r\n" \
                        "00F3\r\n" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "0123456789abcdef" \
                        "012" \
                        "\r\n" \
                        "0000; the final chunk\r\n" \
                        "\r\n" \
                        "Entity-Header: this is the chunk footer\r\n" \
                        "\r\n"

//
// enpty chunk encoded response with empty footer
//

#define TEST_HEADER_6   "HTTP/1.1 100 Continue\r\n" \
                        "Server: Richard's Test-Case Virtual Server/1.0\r\n" \
                        "Date: Mon, 01 Apr 2000 00:00:01 GMT\r\n" \
                        "Transfer-Encoding: chunked\r\n" \
                        "\r\n" \
                        "0\r\n" \
                        "\r\n" \
                        "\r\n"

    const struct {LPSTR ptr; DWORD len;} test_cases[] = {
        TEST_HEADER_0, sizeof(TEST_HEADER_0) - 1,
        TEST_HEADER_1, sizeof(TEST_HEADER_1) - 1,
        TEST_HEADER_2, sizeof(TEST_HEADER_2) - 1,
        TEST_HEADER_3, sizeof(TEST_HEADER_3) - 1,
        TEST_HEADER_4, sizeof(TEST_HEADER_4) - 1,
        TEST_HEADER_5, sizeof(TEST_HEADER_5) - 1,
        TEST_HEADER_6, sizeof(TEST_HEADER_6) - 1
    };
    DWORD test_index = 99;

#endif // def RLF_TEST_CODE
#endif // INET_DEBUG

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReceiveResponse_Fsm",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(ReceiveResponse_Fsm);

    CFsm_ReceiveResponse & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();

    if (error != ERROR_SUCCESS) {

        if (error == ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED) {

            if ((_Socket != NULL) && _Socket->IsSecure())
            {
                if(m_pSecurityInfo)
                {
                    /* SCLE ref */
                    m_pSecurityInfo->Release();
                }
                /* SCLE ref */
                m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            }

            SetState(HttpRequestStateOpen);
            CloseConnection(TRUE);
            fsm.SetDone();
            goto quit2;
        }

        goto quit;
    }
    if (state != FSM_STATE_INIT) {
        state = fsm.GetFunctionState();
    }
    do {
        switch (state) {
        case FSM_STATE_INIT:
            if (_ResponseBuffer == NULL) {
                _ResponseBufferLength = DEFAULT_RESPONSE_BUFFER_LENGTH;
                _ResponseBuffer = (LPBYTE)ALLOCATE_MEMORY(LMEM_FIXED,
                                                          _ResponseBufferLength);
                if (_ResponseBuffer == NULL) {
                    _ResponseBufferLength = 0;
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
            }

            INET_ASSERT(_BytesReceived == 0);

            fsm.m_dwResponseLeft = _ResponseBufferLength;
            state = FSM_STATE_2;

            //
            // fall through
            //

#ifdef RLF_TEST_CODE

            InternetGetDebugVariable("WininetTestIndex", &test_index);
            if (test_index < ARRAY_ELEMENTS(test_cases)) {
                _BytesReceived = test_cases[test_index].len;
                memcpy(_ResponseBuffer, test_cases[test_index].ptr, _BytesReceived);
                fsm.m_dwResponseLeft = _ResponseBufferLength - _BytesReceived;
            }

#endif // def RLF_TEST_CODE

        case FSM_STATE_2:

            //
            // we will allow Receive() to expand the buffer (and therefore initially
            // allocate it), and to compress the buffer if we receive the end of the
            // connection. It is up to UpdateResponseHeaders() to figure out when
            // enough data has been read to indicate end of the headers
            //

            fsm.SetFunctionState(FSM_STATE_3);

            INET_ASSERT(_Socket != NULL);

            if (_Socket != NULL) {
                error = _Socket->Receive((LPVOID *)&_ResponseBuffer,
                                         &_ResponseBufferLength,
                                         &fsm.m_dwResponseLeft,
                                         &_BytesReceived,
                                         0,
                                         SF_EXPAND
                                         | SF_COMPRESS
                                         | SF_INDICATE,
                                         &fsm.m_bEofResponseHeaders
                                         );
                if (error == ERROR_IO_PENDING) {
                    goto quit;
                }
            } else {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }

            //
            // fall through
            //

        case FSM_STATE_3:

            //
            // if we are using a keep-alive connection that was previously timed-out
            // by the server, we may not find out about it until now
            //
            // Note: it seems we can get a zero length response at this point also,
            // which I take to mean that the server-side socket has been closed
            //

            INET_ASSERT(_BytesReceived <= _ResponseBufferLength);

            if ((error != ERROR_SUCCESS)
            || ((_BytesReceived == 0) && IsKeepAlive())) {

                //
                // We need to reset the state if we got a
                // certificate request.
                //

                if (error == ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED) {

                    if ((_Socket != NULL) && _Socket->IsSecure())
                    {
                        if(m_pSecurityInfo)
                        {
                            /* SCLE ref */
                            m_pSecurityInfo->Release();
                        }
                        /* SCLE ref */
                        m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
                    }

                    SetState(HttpRequestStateOpen);
                }
                CloseConnection(TRUE);
                goto quit;
            }

            //
            // if we received no data then the server has closed the connection
            // already
            //

            if (_BytesReceived != 0) {

                BOOL bHaveFinalResponse;

                do {
                    bHaveFinalResponse = TRUE;
                    error = UpdateResponseHeaders(&fsm.m_bEofResponseHeaders);
//if (!(rand() % 7)) {
//    error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
//}
                    if (error != ERROR_SUCCESS) {
//dprintf("UpdateResponseHeaders() returns %d\n", error);
                        break;
                    }

                    DWORD statusCode;

                    statusCode = GetStatusCode();

                    //
                    // receive next packet if we didn't get a status code yet
                    //

                    if (statusCode == 0) {
                        break;
                    }

                    //
                    // discard any 1xx responses and get the headers again
                    //

                    if (fsm.m_bEofResponseHeaders
                    && (statusCode >= HTTP_STATUS_CONTINUE)
                    && (statusCode < HTTP_STATUS_OK)) {
                        bHaveFinalResponse = FALSE;
                        fsm.SetFunctionState(FSM_STATE_4);

                        //
                        // get any data that came with the header
                        //

                        fsm.m_bDrained = FALSE;
                        if (IsContentLength() && (_BytesInSocket != 0)) {
                            error = DrainResponse(&fsm.m_bDrained);
                            if (error != ERROR_SUCCESS) {
                                goto quit;
                            }
                        }

                        //
                        // fall through
                        //

        case FSM_STATE_4:

                        //
                        // now that we have drained the socket, we can indicate
                        // the response to the app. This gives apps chance to
                        // perform progress reporting for each 100 response
                        // received, e.g.
                        //

                        InternetIndicateStatus(INTERNET_STATUS_INTERMEDIATE_RESPONSE,
                                               &statusCode,
                                               sizeof(statusCode)
                                               );

                        //
                        // if there is no more data left in the buffer then we
                        // can receive the next response at the start of the
                        // buffer, else continue from where the previous one
                        // ended
                        //

                        if (fsm.m_bDrained || !IsBufferedData()) {
                            fsm.m_dwResponseLeft = _ResponseBufferLength;
                            _BytesReceived = 0;
                            _DataOffset = 0;
                            _ResponseScanned = 0;
                        } else {
                            _ResponseScanned = _DataOffset;
                            if (IsContentLength()) {
                                _ResponseScanned += _ContentLength;
                            }
                            //if (IsChunkEncoding()) {
                            //
                            //    LPSTR lpszNewBuffer;
                            //    DWORD dwNewBufferLength;
                            //
                            //    error = _ctChunkInfo.ParseChunkInput(
                            //        (LPSTR) BufferedDataStart(),
                            //        BufferedDataLength(),
                            //        &lpszNewBuffer,
                            //        &dwNewBufferLength
                            //        );
                            //
                            //    _ResponseBufferDataReadyToRead = dwNewBufferLength;
                            //
                            //    INET_ASSERT(error == ERROR_SUCCESS);
                            //    if ( error != ERROR_SUCCESS )
                            //    {
                            //        goto quit;
                            //    }
                            //}
                            //if (IsChunkEncoding()) {
                            //
                            //    LPSTR lpszNewBuffer;
                            //    DWORD dwNewBufferLength;
                            //    DWORD nRead = 0;
                            //
                            //    INET_ASSERT(!IsContentLength());
                            //
                            //    error = _ctChunkInfo.ParseChunkInput(
                            //        (LPSTR) (_ResponseBuffer + _DataOffset),
                            //        nRead,
                            //        &lpszNewBuffer,
                            //        &dwNewBufferLength
                            //        );
                            //
                            //    nRead = dwNewBufferLength;
                            //    _BytesReceived = nRead + _DataOffset;
                            //
                            //    INET_ASSERT(error == ERROR_SUCCESS); // I want to see this happen.
                            //    if ( error != ERROR_SUCCESS )
                            //    {
                            //        break;
                            //    }
                            //
                            //    if ( IsChunkedEncodingFinished() )
                            //    {
                            //        break;
                            //    }
                            //}
                        }
                        _ResponseHeaders.FreeHeaders();
                        _ResponseHeaders.Initialize();
                        ZapFlags();
                        _ContentLength = 0;
                        _BytesRemaining = 0;
                        _BytesInSocket = 0;
                        fsm.m_bEofResponseHeaders = FALSE;
                        if (_DataOffset == 0) {

                            //
                            // need to read next response - nothing left in
                            // buffer
                            //

                            break;
                        }
                    }

                    // If we have a server authentication context
                    // and the response is anything but 401, mark
                    // the socket as authenticated.
                    AUTHCTX *pAuthCtx;
                    pAuthCtx = GetAuthCtx();
                    if (pAuthCtx && !pAuthCtx->_fIsProxy
                        && (statusCode != HTTP_STATUS_DENIED))
                    {

#define MICROSOFT_IIS_SERVER_SZ "Microsoft-IIS/"
#define MICROSOFT_PWS_SERVER_SZ "Microsoft-PWS/"

#define MICROSOFT_IIS_SERVER_LEN (sizeof(MICROSOFT_IIS_SERVER_SZ) - 1)
#define MICROSOFT_PWS_SERVER_LEN (sizeof(MICROSOFT_PWS_SERVER_SZ) - 1)

                        LPSTR pszBuf;
                        DWORD cbBuf;
                        cbBuf = MAX_PATH;
                        if (FastQueryResponseHeader(HTTP_QUERY_SERVER, 
                            (LPVOID*) &pszBuf, &cbBuf, 0) == ERROR_SUCCESS)
                        {
                            if (cbBuf >= MICROSOFT_IIS_SERVER_LEN 
                                && (!strncmp(pszBuf, MICROSOFT_IIS_SERVER_SZ, MICROSOFT_IIS_SERVER_LEN)
                                    || !strncmp(pszBuf, MICROSOFT_PWS_SERVER_SZ, MICROSOFT_PWS_SERVER_LEN)))

                            {                            
                                // Found an IIS header. Mark socket as authenticated if 
                                // IIS 1, 2 or 3. Lengths of both strings are same.
                                CHAR *pVer = pszBuf + MICROSOFT_IIS_SERVER_LEN;
                                if (*pVer == '1'
                                    || *pVer == '2'
                                    || *pVer == '3'
                                    )
                                {
                                    // IIS 1, 2 or 3  - mark dirty.
                                    _Socket->SetAuthenticated();
                                }
                            }                                
                        }
                        else
                        {
                            // Unknown server; may be IIS 1,2 or 3.
                            _Socket->SetAuthenticated();
                        }
                    }

                } while (!bHaveFinalResponse);
            } else {
                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
            }

            //
            // set state to perform next receive
            //

            state = FSM_STATE_2;
        }
    } while ((error == ERROR_SUCCESS) && !fsm.m_bEofResponseHeaders);

    //
    // we should update the RTT as soon as we get received data from
    // the socket, but then we'd have to store the RTT in the socket
    // object or access this one, etc. Just keep it here for now -
    // its a reasonable approximation in the normal IE case: not too
    // much time spent in callbacks etc.
    //

    UpdateRTT();
//dprintf("RTT for %s = %d\n", GetURL(), GetRTT());
//dprintf("OS = %s, PS = %s\n", ((GetOriginServer() != NULL) ? GetOriginServer()->GetHostName() : "none"),
//    ((GetServerInfo() != NULL) ? GetServerInfo()->GetHostName() : "none"));

    //
    // we have received the headers and possibly some (or all) of the data. The
    // app can now query the headers and receive the data
    //

    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    if ( IsChunkEncoding() )
    {
        LPSTR lpszNewBuffer;
        DWORD dwNewBufferLength;

        error = _ctChunkInfo.ParseChunkInput(
            (LPSTR) BufferedDataStart(),
            BufferedDataLength(),
            &lpszNewBuffer,
            &dwNewBufferLength
            );

        _ResponseBufferDataReadyToRead = dwNewBufferLength;

        INET_ASSERT(error == ERROR_SUCCESS);
        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }
    }

    SetAvailableDataLength(BufferDataAvailToRead());

    //
    // IIS caches authentication credentials on keep-alive sockets.
    //

    if (_Socket) {

        if (IsAuthorized()) {
            _Socket->SetAuthorized();
        }

        if (IsPerUserItem()) {
            _Socket->SetPerUser();
        } else if (_Socket->IsPerUser()) {
            SetPerUserItem(TRUE);
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // if we got the socket from the keep-alive pool, but found no keep-
        // alive header then we no longer have a keep-alive connection
        //

        if (_bKeepAliveConnection && !IsKeepAlive()) {
//dprintf("*** %s - NO LONGER K-A socket %#x\n", GetURL(), _Socket->GetSocket());
            SetNoLongerKeepAlive();
        }

        //
        // don't maintain the connection if there's no more data to read. UNLESS
        // we are in the middle of establishing an authenticated connection
        // (implies using keep-alive connection, e.g. NTLM)
        // IsData() returns FALSE if there's no data at all, otherwise we
        // check to see if we have read all the data already (i.e. with the
        // response headers)
        //

        if ((error != ERROR_SUCCESS)
            || (

                //
                // data-less response (ignoring keep-alive & content-length)
                //

                (!IsData()

                 //
                 // all data body in header buffer
                 //

                 || (IsKeepAlive()
                     && IsContentLength()
                     && (BufferedDataLength() == GetContentLength())
                     )
                 )

                //
                // but only if not in the middle of auth negotiation and if the
                // connection hasn't been dropped by the server
                //

                && ((GetAuthState() != AUTHSTATE_NEGOTIATE)
                    || IsNoLongerKeepAlive())

                && (!((GetStatusCode() == 407) && IsKeepAlive()))
                )
            ) {

//dprintf("socket %#x [%#x/%d] error=%d, IsData()=%B, K-A=%B, C-L=%d, BDL=%d, AS=%d\n",
//        _Socket,
//        _Socket ? _Socket->GetSocket() : 0,
//        _Socket ? _Socket->GetSourcePort() : 0,
//        error,
//        IsData(),
//        IsKeepAlive(),
//        GetContentLength(),
//        BufferedDataLength(),
//        GetAuthState()
//        );

            //
            // BUGBUG - if this is a new keep-alive connection?
            //

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("closing: error = %d, IsData() = %B, K-A = %B, IsC-L = %B, BDL = %d, C-L = %d AS=%d [%s]\n",
                        error,
                        IsData(),
                        IsKeepAlive(),
                        IsContentLength(),
                        BufferedDataLength(),
                        GetContentLength(),
                        GetAuthState(),
                        InternetMapAuthState(GetAuthState())
                        ));

            if(GlobalAlwaysDrainOnRedirect || 
                GetStatusCode() != HTTP_STATUS_REDIRECT || 
                (HTTP_METHOD_TYPE_HEAD == GetMethodType()))
            {
                CloseConnection((error != ERROR_SUCCESS) ? TRUE : FALSE);
            }
            else
                DEBUG_PRINT(HTTP, INFO, ("Not closing socket, Status code = %d \n", GetStatusCode()));

            //
            // set the relevant state
            //

            if (error != ERROR_SUCCESS &&
                error != ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED &&
                error != ERROR_INTERNET_INVALID_CA &&
                error != ERROR_INTERNET_SEC_CERT_DATE_INVALID &&
                error != ERROR_INTERNET_SEC_CERT_CN_INVALID )
            {
                SetState(HttpRequestStateError);
            }
        }

        PERF_LEAVE(ReceiveResponse_Fsm);
    }

quit2:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\socket.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    socket.cxx

Abstract:

    This file contains general socket utilities.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection
        CFsm_OpenConnection::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloseConnection
        HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection
        HTTP_REQUEST_HANDLE_OBJECT::AbortConnection
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel
        CFsm_OpenProxyTunnel::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm
        HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

    18-Dec-1995 rfirth
        Reworked for C++

    27-Mar-1996 arthurbi
        Added OpenProxyTunnel Method

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"

//
// functions
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection(
    IN BOOL bNewConnection,
    IN BOOL fNoCreate /* = FALSE */
    )

/*++

Routine Description:

    Get a connection to the web server. Either use a pre-existing keep-alive
    connection from the global pool or create a new connection

Arguments:

    bNewConnection  - TRUE if we are NOT to get a connection from the keep-alive
                      pool

    fNoCreate       - TRUE if we should NOT create a new socket if a k-a isn't found.
                      This is currently for the SSL tunneling case where we want to break
                      and send a CONNECT if a k-a doesn't match our criteria.
                      

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Opened connection

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection",
                "%B",
                bNewConnection
                ));

    DWORD error = DoFsm(new CFsm_OpenConnection(bNewConnection, this, fNoCreate));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenConnection state

Arguments:

    Fsm - containing open connection state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenConnection * stateMachine = (CFsm_OpenConnection *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pRequest->OpenConnection_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm(
    IN CFsm_OpenConnection * Fsm
    )

/*++

Routine Description:

    Open connection FSM

Arguments:

    Fsm - containing state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenConnection_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenConnection & fsm = *Fsm;
    DWORD error = fsm.GetError();
    CServerInfo * pServerInfo = GetServerInfo();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // BUGBUG - redundancy. Either put these in the FSM or figure out why we need
    //          to do proxy name processing here
    //

    //
    // if this object was created from an InternetOpen() handle which specified
    // INTERNET_OPEN_TYPE_PROXY then we connect to the proxy, otherwise we
    // connect to the server specified in InternetConnect()
    //

    LPSTR hostName;
    LPSTR hostNameServer;
    DWORD hostLength;
    INTERNET_PORT hostPort;

    hostName = hostNameServer = GetHostName(&hostLength);
    hostPort = GetHostPort();

    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        SetViaProxy(TRUE);
        hostName = proxyHostName;
        hostLength = proxyHostNameLength;
        hostPort = proxyHostPort;
    }

    INET_ASSERT(hostName != NULL);
    INET_ASSERT(hostPort != INTERNET_INVALID_PORT_NUMBER);

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto get_continue;            
        case FSM_STATE_2:
            goto connect_continue;       
        default:

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
            goto quit;
        }
    }

    //
    // we may already have a keep-alive connection - don't ask for a new one.
    // This happens in the challenge phase of a multi-part (e.g. NTLM) auth
    // negotiation over keep-alive
    //

    if (IsWantKeepAlive() && !fsm.m_bNewConnection && (_Socket != NULL)
    && _Socket->IsOpen()) {

        //INET_ASSERT(_bKeepAliveConnection);

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x, ALREADY open on Socket=%#x\n", this, _Socket );
        //}


        error = ERROR_SUCCESS;
        goto quit;
    }

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this request wants a keep-alive connection AND we are allowed to use
    // one (i.e. not forced to generate a new connection) AND we can find one
    // then we're done, otherwise we have to generate a new connection
    //

    DWORD dwSocketFlags;

    dwSocketFlags = IsAsyncHandle() ? SF_NON_BLOCKING : 0;
    if ((IsWantKeepAlive() || (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION))
    && !fsm.m_bNewConnection) {
        dwSocketFlags |= SF_KEEP_ALIVE;
    }
    if (GetOpenFlags() & INTERNET_FLAG_SECURE) {
        dwSocketFlags |= SF_SECURE;
        if (m_pSecurityInfo && !m_pSecurityInfo->InCache()) {
                // Don't grab a keep-alive if a fully verified cert
                // hasn't been cached.  VerifyTrust only caches after
                // verification has been done with no errors ignored.
                dwSocketFlags &= ~SF_KEEP_ALIVE;
        }
    }
    if ( IsTunnel() )
    {
        dwSocketFlags |= SF_TUNNEL;
        //    dprintf("Opening Tunnel for nested req=%#x, Socket Flags=%#x, K-A=%B, Secure=%B, N-B=%B\n",
        //             this, dwSocketFlags, (dwSocketFlags & SF_KEEP_ALIVE), (dwSocketFlags & SF_SECURE),
        //            (dwSocketFlags & SF_NON_BLOCKING));
    }


    INET_ASSERT(_Socket == NULL);

    _Socket = NULL;
    fsm.SetFunctionState(FSM_STATE_1);

    // If m_fNoCreate flag is set, then we're attempting to find
    // a matching SSL tunnel that's already been established.
    error = DoFsm(new CFsm_GetConnection(
                            dwSocketFlags,
                            fsm.m_fNoCreate ? GetHostPort() : hostPort,
                            GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                            10000,  // dwLimitTimeout
                            &_Socket,
                            pServerInfo,
                            fsm.m_fNoCreate ? hostNameServer : NULL
                            ));

get_continue:

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (_Socket != NULL) {

        //
        // _bKeepAliveConnection now means "this is a pre-existing k-a socket".
        // Only meaningful when re-establishing connect when dropped by server
        //

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x\n opened on K-A Socket=%#x\n", this, _Socket );
        //}


//dprintf("%s existing K-A connection %#x\n", GetURL(), _Socket->GetSocket());
        _bKeepAliveConnection = TRUE;

        //
        // Get any security Info
        //

        if (_Socket->IsSecure()) {
            if (m_pSecurityInfo != NULL) {
                /* SCLE ref */
                m_pSecurityInfo->Release();
            }
            /* SCLE ref */
            m_pSecurityInfo = ((ICSecureSocket *)_Socket)->GetSecurityEntry();
            ((ICSecureSocket*)_Socket)->SetSecureFlags(SECURITY_FLAG_SECURE);
        }

        //
        // successfully got keep-alive connection from the pool
        //

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("%skeep-alive connection: socket %#x, port %d\n",
                    _Socket->IsSecure() ? "SSL " : "",
                    _Socket->GetSocket(),
                    _Socket->GetSourcePort()
                    ));

        goto quit;
    }
    else if (fsm.m_fNoCreate)
    {
        goto quit;
    }

    //
    // the socket didn't come from the pool
    //

    _bKeepAliveConnection = FALSE;

    //
    // we may already have a socket if we're reusing the object
    //

    if (GetOpenFlags() & INTERNET_FLAG_SECURE) {
        _Socket = new ICSecureSocket(GetErrorMask());
        if (m_pSecurityInfo == NULL) {
            /* SCLE ref */
            if (NULL == (m_pSecurityInfo = GlobalCertCache.Find(GetHostName()))) {
                /* SCLE ref */
                m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
            }
        }

        if (_Socket != NULL) {
            _Socket->SetEncryption();
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetSecurityEntry(&m_pSecurityInfo);
            /* SCLE ref */
            ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
            ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);
       }
    } else {
        _Socket = new ICSocket;
    }
    if (_Socket != NULL) {
        fsm.m_bCreatedSocket = TRUE;
        
        // If app asks to exempt connection limit for this session, 
        // we mark the Socket accordingly.
        if (ConnLimitExempted())
        {
            _Socket->ExemptConnLimit(); 
        }
    } else {

        //
        // balance number of available connections
        //

        ReleaseConnection(FALSE, FALSE, FALSE);
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Turn on Socks, if needed.
    //

    GetSocksProxyName(&proxyHostName,
                      &proxyHostNameLength,
                      &proxyHostPort
                      );

    if ((proxyHostName != NULL) && (proxyHostNameLength > 0)) {
        _Socket->EnableSocks(proxyHostName, proxyHostPort);
    }

    //
    // NOTE: if secure connection is required, TargetServer must
    //       be a fully qualified domain name.
    //       The hostname is used in comparison with CN found in
    //       the certificate.  The hostname MUST NOT BE the
    //       result of a DNS lookup. DNS lookups are open to
    //       spoofing, and that may prevent a security from
    //       being detected.
    //
    //
    // If we're Posting or sending data, make sure
    //  the SSL connection code knows about it.  Therefore we set
    //  the flag "SF_SENDING_DATA" for the purposes of
    //  generating errors if found while making the connection.
    //

    _Socket->SetPort(hostPort);
    fsm.SetFunctionState(FSM_STATE_2);
    error = _Socket->Connect(GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                             GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                             SF_INDICATE
                             | (IsAsyncHandle() ? SF_NON_BLOCKING : 0)
                             | (((GetMethodType() == HTTP_METHOD_TYPE_POST)
                             || (GetMethodType() == HTTP_METHOD_TYPE_PUT))
                                ? SF_SENDING_DATA
                                : 0)
                             );

connect_continue:

    if (error == ERROR_SUCCESS) {
//dprintf("%s NEW connection %#x\n", GetURL(), _Socket->GetSocket());

        DEBUG_PRINT(HTTP,
                    INFO,
                    ("new connection: socket %#x\n",
                    _Socket->GetSocket()
                    ));

        //if ( IsTunnel() )
        //{
        //    dprintf("Tunnel for nested req=%#x opened for Socket=%#x\n", this, _Socket );
        //}


        // This assert is not strictly valid - there is a window in which the Request handle
        // could be closed, invalidating the m_Socket member of ICSocket. (IEv6 bug 24918)
        // Code downstream of this accounts for that possibility.

        // for eg. SetTimeout would lead to a WSA_NOT_SOCK error and the error is replaced with
        // ERROR_CANCELLED. and SetLinger has an Exc. Handler around the winsock call.
        
        //INET_ASSERT(_Socket->IsOpen());

        //pServerInfo->AddActiveConnection();

        //
        // enable receive timeout - ignore any errors
        //

        _Socket->SetTimeout(RECEIVE_TIMEOUT,
                            GetTimeoutValue(INTERNET_OPTION_RECEIVE_TIMEOUT)
                            );

        //
        // set zero linger: force connection closed at transport level when
        // we close the socket. Ignore the error
        //

        _Socket->SetLinger(TRUE, 0);
    }

quit:

    if (error != ERROR_IO_PENDING) {

        //
        // if we created the socket but failed to connect then delete the socket
        // object
        //

        if ((error != ERROR_SUCCESS) && fsm.m_bCreatedSocket) {

            //
            // we created a socket so we must increase the available connection
            // count on failure
            //
            if (fsm.IsInvalid() && fsm.GetState() == FSM_STATE_ERROR) 
            {
                DEBUG_PRINT(
                    HTTP,
                    INFO,
                    ("Fsm in invalid state"));
            }
            else
            {

                INET_ASSERT(_Socket != NULL);

                ReleaseConnection(TRUE,     // close socket (if open)
                                FALSE,    // don't indicate
                                TRUE      // dispose of socket object
                                );
            }
        }
//dprintf("%s get/connect pending socket %#x\n", GetURL(), _Socket ? _Socket->GetSocket() : 0);
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloseConnection(
    IN BOOL bForceClosed
    )

/*++

Routine Description:

    Performs the opposite of OpenConnection(), i.e. closes the socket or marks
    it not in use if keep-alive

Arguments:

    bForceClosed    - TRUE if we are to forcibly release a keep-alive connection
                      (i.e. the server timed out before we did)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::CloseConnection",
                "%B",
                bForceClosed
                ));

//dprintf("*** closing %s%s socket %#x\n",
//        (_bKeepAliveConnection || IsKeepAlive()) ? "K-A " : "",
//        GetURL(),
//        _Socket ? _Socket->GetSocket() : 0
//        );

    DWORD error = ERROR_SUCCESS;
    BOOL bClose = TRUE;
    BOOL bDelete = TRUE;

    if (_Socket == NULL) {

        DEBUG_PRINT(HTTP,
                    WARNING,
                    ("socket already deleted\n"
                    ));

        goto quit;
    }
    if (_bKeepAliveConnection || IsKeepAlive()) {

        //
        // keep-alive connection: just return the connection to the pool
        //

        if ((IsContentLength() && (GetBytesInSocket() != 0))
        || (IsChunkEncoding() && !IsChunkedEncodingFinished())
        || IsNoLongerKeepAlive() || _Socket->IsClosed()
        || ((_State & 0x0F) < (HttpRequestStateObjectData & 0x0F))) {

            DEBUG_PRINT(HTTP,
                        INFO,
                        ("forcing %#x [%#x] closed: bytes left = %d/%d; no longer k-a = %B; closed = %B\n",
                        _Socket,
                        _Socket->GetSocket(),
                        GetBytesInSocket(),
                        GetContentLength(),
                        IsNoLongerKeepAlive(),
                        _Socket->IsClosed()
                        ));

//dprintf("forcing k-a %#x closed - bytes=%d/%d, no longer=%B, chunked=%B, chunk-finished=%B\n",
//        _Socket->GetSocket(),
//        GetBytesInSocket(),
//        GetContentLength(),
//        IsNoLongerKeepAlive(),
//        IsChunkEncoding(),
//        IsChunkedEncodingFinished()
//        );
            bForceClosed = TRUE;
        }
        if (!bForceClosed) {
            bClose = FALSE;
            bDelete = FALSE;
        } else {
//dprintf("%#x forced close\n", _Socket->GetSocket());
        }
    }

    ReleaseConnection(bClose, TRUE, bDelete);
    _Socket = NULL;
    _bKeepAliveConnection = FALSE;
    _bNoLongerKeepAlive = FALSE;

quit:

    DEBUG_LEAVE(error);

    return error;
}


VOID
HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection(
    IN BOOL bClose,
    IN BOOL bIndicate,
    IN BOOL bDispose
    )

/*++

Routine Description:

    Releases the connection back to the server limited pool and optionally
    closes the socket handle and destroys the socket object

Arguments:

    bClose      - if TRUE, increments the available connection count in the
                  server info object and closes the handle, else we are
                  returning a keep-alive connection; after this call we no
                  longer have a socket object owned by this request handle
                  object

    bIndicate   - TRUE if we indicate to the user when we close the socket
                  handle

    bDispose    - TRUE if we are disposing of the socket object (mutually
                  exclusive with !bClose), in which case we will no longer have
                  a socket object after this call returns

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "HTTP_REQUEST_HANDLE_OBJECT::ReleaseConnection",
                 "%B, %B, %B",
                 bClose,
                 bIndicate,
                 bDispose
                 ));


    INET_ASSERT(_Socket != NULL);
    //INET_ASSERT(_Socket->IsOpen());

    BOOL fExemptConnLimit = _Socket->ConnLimitExempted();

    CServerInfo * pServerInfo = GetServerInfo();

    // Always disconnect sockets which have been marked as authenticated.
    // This is to avoid posting data to IIS4 while preauthenticating
    // and inducing the server to close the connection.
    if (_Socket)
        bClose = (bClose || _Socket->IsAuthenticated());
        
    ICSocket * pSocket = bClose ? NULL : _Socket;

    INET_ASSERT(pServerInfo != NULL);

    if (pServerInfo != NULL) {
        if (bClose && (_Socket != NULL)) {

            //
            // BUGBUG - this should be set based on bGraceful parameter
            //

            _Socket->SetLinger(FALSE, 0);

            //INET_ASSERT(!_bKeepAliveConnection || _bNoLongerKeepAlive);

            _Socket->Disconnect(bIndicate ? SF_INDICATE : 0);
            if (bDispose) {
                _Socket->Dereference();
                _Socket = NULL;
            }
        } else {
            _Socket = NULL;
        }
        //if (IsResponseHttp1_1() && IsKeepAlive()) {
        //    pServerInfo->ReleasePipelinedConnection(pSocket);
        //} else {
            pServerInfo->ReleaseConnection(pSocket, fExemptConnLimit);
        //}
    }

    DEBUG_LEAVE(0);
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::AbortConnection(
    IN BOOL bForce
    )

/*++

Routine Description:

    Aborts the current connection. Closes the socket and frees up all receive
    buffers. If the connection is keep-alive, we have the option to forcefully
    terminate the connection, or just return the socket to the keep-alive pool

Arguments:

    bForce  - if TRUE and keep-alive, forcefully close the keep-alive socket

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::AbortConnection",
                "%B",
                bForce
                ));

    DWORD error;

    error = CloseConnection(bForce);
    if (error == ERROR_SUCCESS) {

        //
        // destroy all response variables. This is similar to ReuseObject()
        // except we don't change the object state, or reset the end-of-file
        // state
        //

        _ResponseHeaders.FreeHeaders();
        FreeResponseBuffer();
        ResetResponseVariables();
        _dwCurrentStreamPosition = 0;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel(
    VOID
    )

/*++

Routine Description:

    Creates a connection with the requested server via a Proxy
    tunnelling method.

    Works by creating a nested child HTTP and Connect request object.
    These objects send a "CONNECT" verb to the proxy server asking for
    a connection to made with the destination server. Upon completion the
    child objects are discarded.  If a class 200 response is not received from
    proxy server, the proxy response is copied into this object
    and returned to the user.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel",
                 NULL
                 ));

    DWORD error = DoFsm(new CFsm_OpenProxyTunnel(this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_OpenProxyTunnel::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next OpenProxyTunnel state

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_OpenProxyTunnel::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_OpenProxyTunnel * stateMachine = (CFsm_OpenProxyTunnel *)Fsm;

    START_SENDREQ_PERF();

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pRequest->OpenProxyTunnel_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    STOP_SENDREQ_PERF();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm(
    IN CFsm_OpenProxyTunnel * Fsm
    )

/*++

Routine Description:

    State machine for OpenProxyTunnel

Arguments:

    Fsm - contains state info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::OpenProxyTunnel_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_OpenProxyTunnel & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();


    // Need to bury error on blocked item that failed to find
    // established SSL tunnel
    if (error != ERROR_SUCCESS && fsm.GetFunctionState() != FSM_STATE_2) {
        goto quit;
    }
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }
    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_1:
            goto send_continue;

        case FSM_STATE_2:
            goto keep_alive_tunnel;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);
            goto quit;
        }
    }

    // Do not continue if handle is in NTLM challenge state - we
    // already have a valid socket set up for tunnelling.
    if ((_Socket != NULL) && (GetAuthState() == AUTHSTATE_CHALLENGE))
    {
        DEBUG_PRINT(
            HTTP,
            INFO,
            ("authstate is %s, completing auth over existing tunnel\n", InternetMapAuthState(GetAuthState()))
            );

        error = ERROR_SUCCESS;
        goto quit;
    }

    // First, try and fetch an already established tunnel
    // from the keep-alive pool.  If so, we can avoid the nested
    // CONNECT request.
    //
    if (_Socket == NULL)
    {
        error = OpenConnection(FALSE, TRUE);

        if (error == ERROR_IO_PENDING)
        {
            fsm.SetFunctionState(FSM_STATE_2);
            goto quit;
        }
keep_alive_tunnel:
        if (error == ERROR_SUCCESS && _Socket != NULL)
        {
            // No need to create nested request.  We found an active SSL tunnel
            // for this server in the keep-alive pool.
            goto quit;
        }
        else
        {
            // Start over as normal tunnel since bypass to find
            // keep-alive failed.
            error = ERROR_SUCCESS;
        }
    }

    //
    // Handle Magic... Get the Internet Handle Object,
    //  then constuct a new Connect Object, and new HttpRequest Object.
    //

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)GetParent();
    INET_ASSERT(pConnect != NULL);

    INTERNET_HANDLE_OBJECT * pInternet;
    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();
    INET_ASSERT(pInternet != NULL);

    //
    // increment the nested request level around InternetConnect(). This is
    // required to stop InternetConnect() believing this is the async part of
    // a two-part (FTP) request (original async hackery)
    //

    _InternetIncNestingCount();
    fsm.m_hConnect = InternetConnect(pInternet->GetPseudoHandle(),
                                     GetHostName(),
                                     GetHostPort(),
                                     NULL,
                                     NULL,
                                     INTERNET_SERVICE_HTTP,
                                     0, // no flags
                                     INTERNET_NO_CALLBACK
                                     );
    _InternetDecNestingCount(1);
    if (!fsm.m_hConnect) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_IO_PENDING);

        goto quit;
    }

    //
    // Now do an Open Request. This will pick up the secure proxy flag.
    //

    fsm.m_hRequest = HttpOpenRequest(fsm.m_hConnect,
                                     "CONNECT",
                                     "/",    // we don't need this for a CONNECT
                                     NULL,
                                     NULL,
                                     NULL,
                                     (GetInternetOpenFlags() & INTERNET_FLAG_ASYNC)
                                     | INTERNET_FLAG_RELOAD
                                     | INTERNET_FLAG_NO_CACHE_WRITE
                                     | INTERNET_FLAG_NO_AUTO_REDIRECT
                                     | INTERNET_FLAG_NO_COOKIES
                                     | INTERNET_FLAG_KEEP_CONNECTION, 
                                     INTERNET_NO_CALLBACK  // should be _Context?
                                     //_Context
                                     );
    if (!fsm.m_hRequest) {
        error = GetLastError();
        goto quit;
    }

    //
    // map the handle
    //

    error = MapHandleToAddress(fsm.m_hRequest,
                               (LPVOID *)&fsm.m_hRequestMapped,
                               FALSE);
    if ((error != ERROR_SUCCESS) || (fsm.m_hRequestMapped == NULL)) {
        goto quit;
    }

    fsm.m_pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.m_hRequestMapped;

    //
    // we need to set the special secure proxy flag in the request object
    //

    fsm.m_pRequest->SetTunnel();


    LPSTR proxyHostName;
    DWORD proxyHostNameLength;
    INTERNET_PORT proxyHostPort;

    GetProxyName(&proxyHostName,
                 &proxyHostNameLength,
                 &proxyHostPort
                 );
    fsm.m_pRequest->SetProxyName(proxyHostName,
                                 proxyHostNameLength,
                                 proxyHostPort
                                 );

    //
    // Transfer any proxy user/pass from the handle.
    //
    LPSTR lpszUser, lpszPass = NULL;

    // Get and invalidate username + password off of outer handle.
    if (GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
    {
        // This will automatically re-validate the username/password
        // on the tunneling handle.
        fsm.m_pRequest->SetUserOrPass (lpszUser, IS_USER, IS_PROXY);
        fsm.m_pRequest->SetUserOrPass (lpszPass, IS_PASS, IS_PROXY);

        if (lpszPass)
        {
            SecureZeroMemory(lpszPass, strlen(lpszPass));
            FREE_MEMORY(lpszPass);
            lpszPass = NULL;
        }
    }

    //
    // Transfer any authentication context to the tunnelling handle.
    //

    //fsm.m_pRequest->SetAuthCtx (_pTunnelAuthCtx);


    //dprintf("New tunnel request %#x making nested request= %#x\n", this, fsm.m_pRequest);

    //
    // Do the Nested SendRequest to the Proxy Server.
    //  ie send the CONNECT method.
    //

    if (ShouldSendUTF8ServerNameToProxy())
    {
        DWORD dwSendUTF8 = 1;
        DWORD dwCodePage = GetCodePage();
        InternetSetOption(fsm.m_hRequest, INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY, &dwSendUTF8, sizeof(DWORD));
        InternetSetOption(fsm.m_hRequest, INTERNET_OPTION_CODEPAGE, &dwCodePage, sizeof(DWORD));
    }
    fsm.SetFunctionState(FSM_STATE_1);
    if (!HttpSendRequest(fsm.m_hRequest, NULL, 0, NULL, 0)) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            goto done;
        }
        goto quit;
    }

send_continue:

    //
    // Check Status Code Returned from proxy Server Here.
    // If its not 200 we let the user view it as a Proxy Error
    //  and DON'T continue our connection to the SSL/PCT Server.
    //

    //dprintf("Received Nested Response, Socket=%#x, org request=%#x, nested request=%#x\n", fsm.m_pRequest->_Socket, this, fsm.m_pRequest);

    _StatusCode = fsm.m_pRequest->GetStatusCode();

    switch (_StatusCode) {

        case HTTP_STATUS_OK:
            break;

        case HTTP_STATUS_PROXY_AUTH_REQ:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            break;

        default:
            if ((error = CloneResponseBuffer(fsm.m_pRequest)) != ERROR_SUCCESS)
                goto quit;
            goto quit;
    }

    //
    // Transfer any authentication context back to the outer handle.
    //

    if ( _pTunnelAuthCtx ) {
        delete _pTunnelAuthCtx;
    }

    _pTunnelAuthCtx = fsm.m_pRequest->GetAuthCtx();
    
    if (_pTunnelAuthCtx)
    {
        _pTunnelAuthCtx->_pRequest = NULL;
    }

    fsm.m_pRequest->SetAuthCtx (NULL);

    //
    // pull the socket handle from the socket object used to communicate with
    // the proxy
    //

    INET_ASSERT(fsm.m_pRequest->_Socket != NULL);

    /*
    if server returned anything other than 200 then we failed; revert to non-
    secure socket
    */

    if (_Socket == NULL) {
        _Socket = new ICSecureSocket(GetErrorMask());
    }
    if(m_pSecurityInfo == NULL)
    {
        /* SCLE ref */
        if(NULL == (m_pSecurityInfo = GlobalCertCache.Find(GetHostName())))
        {
            /* SCLE ref */
            m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
        }
    }
    if (_Socket != NULL) {

        INET_ASSERT(_Socket->IsSecure());
        INET_ASSERT(_Socket->IsClosed());

        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetSecurityEntry(&m_pSecurityInfo);
        /* SCLE ref */
        ((ICSecureSocket *)_Socket)->SetHostName(GetHostName());
        ((ICSecureSocket *)_Socket)->SetSecureFlags(GetOpenFlags() & SECURITY_INTERNET_MASK);

    } else {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    _Socket->SetSocket(fsm.m_pRequest->_Socket->GetSocket());
    _Socket->SetSourcePort(fsm.m_pRequest->_Socket->GetSourcePort());
    _Socket->SetPort(fsm.m_pRequest->GetHostPort());
    if (fsm.m_pRequest->_Socket->ConnLimitExempted())
    {
        _Socket->ExemptConnLimit();
    }

    //
    // we need to destroy the ICSocket object in the tunnelled request handle
    // because we don't want to influence the available connection count when
    // we close the connection when we close the handle below
    //

    fsm.m_pRequest->_Socket->SetLinger(FALSE, 0);
    fsm.m_pRequest->_Socket->SetSocket(INVALID_SOCKET);
    fsm.m_pRequest->_Socket->Destroy();
    fsm.m_pRequest->_Socket = NULL;

quit:

    if (fsm.m_hRequestMapped != NULL) {
        DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    }

    if (fsm.m_hRequest != NULL) {

        BOOL bOk;
        bOk = InternetCloseHandle(fsm.m_hRequest);
        INET_ASSERT(bOk);
    }

    if (fsm.m_hConnect != NULL) {

        BOOL bOk;
        bOk = InternetCloseHandle(fsm.m_hConnect);
        INET_ASSERT(bOk);
    }

    //
    // We Reset the ThreadInfo back to the the previous
    //  object handle, and context values.
    //

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, GetPseudoHandle(), (HINTERNET)this);
        _InternetClearLastError(lpThreadInfo);
        _InternetSetContext(lpThreadInfo, GetContext());
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer(
    IN HTTP_REQUEST_HANDLE_OBJECT *pChildRequestObj
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT CloneResponseBuffer method.

    Copies a Child Request Object's Response Buffer into "this"
    request object.  Also forces header parsing to be rerun on
    the header.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer",
                 "%#x",
                 pChildRequestObj
                 ));

    DWORD error;
    LPBYTE lpBuffer;

    error = ERROR_SUCCESS;

    lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(pChildRequestObj->_BytesReceived);

    if ( lpBuffer == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull out headers, and data from Child Request into our request.
    //


    CopyMemory(
           lpBuffer,
           pChildRequestObj->_ResponseBuffer,
           pChildRequestObj->_BytesReceived
           );

    //
    // Recreate and reparse our header structure into our Object,
    //  this is kindof inefficent, but it only happens on errors
    //

    error = CreateResponseHeaders(
                                (LPSTR*) &lpBuffer,
                                pChildRequestObj->_BytesReceived
                                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    SetAvailableDataLength(BufferedDataLength());

    //
    // Copy any chunk-transfer information.
    //

    if ( pChildRequestObj->IsChunkEncoding() )
    {
        _ctChunkInfo = pChildRequestObj->_ctChunkInfo;
        _ResponseBufferDataReadyToRead = pChildRequestObj->_ResponseBufferDataReadyToRead;
        SetHaveChunkEncoding(TRUE);
    }

quit:

    if (lpBuffer) {
        FREE_MEMORY (lpBuffer);
    }
    
    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer(
    IN LPBYTE pBuffer,
    IN DWORD dwBufferLen
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT CloneResponseBuffer method.

    Copies a Child Request Object's Response Buffer into "this"
    request object.  Also forces header parsing to be rerun on
    the header.

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::CloneResponseBuffer",
                 "%#x",
                 0
                 ));

    DWORD error;
    LPBYTE lpBuffer;

    error = ERROR_SUCCESS;

    lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(dwBufferLen);

    if ( lpBuffer == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // pull out headers, and data from Child Request into our request.
    //


    CopyMemory(
           lpBuffer,
           pBuffer,
           dwBufferLen
           );

    //
    // Recreate and reparse our header structure into our Object,
    //  this is kindof inefficent, but it only happens on errors
    //

    error = CreateResponseHeaders(
                                (LPSTR*) &lpBuffer,
                                dwBufferLen
                                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    SetState(HttpRequestStateObjectData);

    //
    // record the amount of data immediately available to the app
    //

    SetAvailableDataLength(BufferedDataLength());

    //
    // Copy any chunk-transfer information.
    //

    /*
    if ( pChildRequestObj->IsChunkEncoding() )
    {
        _ctChunkInfo = pChildRequestObj->_ctChunkInfo;
        _ResponseBufferDataReadyToRead = pChildRequestObj->_ResponseBufferDataReadyToRead;
        SetHaveChunkEncoding(TRUE);
    }
    */

quit:

    if (lpBuffer) {
        FREE_MEMORY (lpBuffer);
    }
    
    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\request.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    request.cxx

Abstract:

    Contains HTTP utility functions

    Contents:
        pHttpGetUrlLen
        pHttpGetUrlString
        pHttpBuildUrl

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

--*/

#include <wininetp.h>
#include "httpp.h"

//
// functions
//


DWORD
pHttpGetUrlLen(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine finds the length of an HTTP URL from targethostname
    port and the object and returns the length

Arguments:

    SchemeType      - type of scheme for URL

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port (if not default)

    lpdwUrlLen      - returned URL length

Return Value:

    DWORD

--*/

{
    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {
        return ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

    int portLen;

    *lpdwUrlLen = 0;

    if (dwPort) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);
        
        portLen = lstrlen(TcpipPortString);
    } else {
        portLen = 0;
    }

    *lpdwUrlLen = schemeLength
                + sizeof("://")
                + portLen
                + lstrlen(lpszTargetName)
                + lstrlen(lpszObjectName)
                ;

    return ERROR_SUCCESS;
}

DWORD
pHttpGetUrlString(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszCWD,
    IN LPSTR lpszObjectName,
    IN LPSTR lpszExtension,
    IN DWORD dwPort,
    OUT LPSTR * lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    )

/*++

Routine Description:

    This routine returns a LocaAlloc'ed buffer containing an HTTP URL constructed
    from the TargetHost, the ObjectName and the port. The caller is responsible
    for freeing the memory.

Arguments:

    SchemeType      -
    lpszTargetName  -
    lpszCWD         -
    lpszObjectName  -
    lpszExtension   -
    dwPort          -
    lplpUrlName     -
    lpdwUrlLen      -

Return Value:

    DWORD

--*/

{
    DWORD dwError, dwSav, i;
    URL_COMPONENTS sUrlComp;
    char *pBuff = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_URL_LENGTH);

    if (pBuff == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    INET_ASSERT(lpszCWD == NULL);

    *lplpUrlName = NULL;

    memset(&sUrlComp, 0, sizeof(URL_COMPONENTS));

    sUrlComp.dwStructSize = sizeof(URL_COMPONENTS);
    sUrlComp.nScheme = SchemeType;
    sUrlComp.lpszHostName = lpszTargetName;
    sUrlComp.lpszUrlPath = lpszObjectName;
    sUrlComp.nPort = (INTERNET_PORT)dwPort;

    dwSav = INTERNET_MAX_URL_LENGTH;

    if(!InternetCreateUrl(&sUrlComp, ICU_ESCAPE_AUTHORITY, pBuff, &dwSav)){
        dwError = GetLastError();
        goto Cleanup;
    }

    for(i=0;i<2;++i) {

        *lplpUrlName = (LPSTR)ALLOCATE_MEMORY(LPTR, dwSav);

        if (*lplpUrlName) {

            if(!InternetCanonicalizeUrl(pBuff, *lplpUrlName, &dwSav, ICU_ENCODE_SPACES_ONLY)){

                FREE_MEMORY(*lplpUrlName);

                // general paranoia
                *lplpUrlName = NULL;

                dwError = GetLastError();

                if ((i == 1) || (dwError != ERROR_INSUFFICIENT_BUFFER)) {
                    goto Cleanup;
                }
            }
            else {

                dwError = ERROR_SUCCESS;
                *lpdwUrlLen = dwSav;
                break;

            }
        }
        else {
            SetLastError(dwError = ERROR_NOT_ENOUGH_MEMORY);
            goto Cleanup;
        }
    }



Cleanup:
    if (pBuff) {
        FREE_MEMORY(pBuff);
    }

    if (dwError != ERROR_SUCCESS) {

        INET_ASSERT(!*lplpUrlName);

        *lpdwUrlLen = 0;
    }

    return (dwError);
}

DWORD
pHttpBuildUrl(
    IN INTERNET_SCHEME SchemeType,
    IN LPSTR lpszTargetName,
    IN LPSTR lpszObjectName,
    IN DWORD dwPort,
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwBuffSize
    )

/*++

Routine Description:

    This routine builds an HTTP URL in the buffer passed. If the size is not
    enough it returns ERROR_INSUFFICIENT_BUFFER.

Arguments:

    SchemeType      - type of scheme - http, gopher, etc.

    lpszTargetName  - host name

    lpszObjectName  - URL-path

    dwPort          - port number (if not default)

    lpszUrl         - place to write URL

    lpdwBuffSize    - IN: size of lpszUrl buffer
                      OUT: size of URL written to lpszUrl

Return Value:

    DWORD

--*/

{
    DWORD dwBuffLen;
    DWORD error;

    error = pHttpGetUrlLen(SchemeType,
                           lpszTargetName,
                           lpszObjectName,
                           dwPort,
                           &dwBuffLen
                           );
    if (error != ERROR_SUCCESS) {
        return error;
    }
    if (dwBuffLen > *lpdwBuffSize) {
        return (ERROR_INSUFFICIENT_BUFFER);
    }

    LPSTR schemeName;
    DWORD schemeLength;

    schemeName = MapUrlScheme(SchemeType, &schemeLength);
    if (schemeName == NULL) {

        //
        // should never happen
        //

        INET_ASSERT(FALSE);

        return ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

    LPSTR p = lpszUrl;
    int len;
    int urlLength;

    memcpy((LPVOID)p, (LPVOID)schemeName, schemeLength);
    p += schemeLength;
    urlLength = schemeLength;

    memcpy((LPVOID)p, (LPVOID)"://", sizeof("://") - 1);
    p += sizeof("://") - 1;
    urlLength += sizeof("://") - 1;

    len = lstrlen(lpszTargetName);
    memcpy((LPVOID)p, (LPVOID)lpszTargetName, len);
    p += len;
    urlLength += len;

    if (dwPort && (dwPort != INTERNET_DEFAULT_HTTP_PORT)) {

        CHAR TcpipPortString[32];

        //itoa(dwPort, TcpipPortString, 10);
        wsprintf(TcpipPortString, "%d", dwPort);

        INET_ASSERT(TcpipPortString[0] != '\0');

        *p++ = ':';
        len = lstrlen(TcpipPortString);
        memcpy((LPVOID)p, (LPVOID)TcpipPortString, len);
        p += len;
        urlLength += len + 1;
    }

    len = lstrlen(lpszObjectName);
    memcpy((LPVOID)p, (LPVOID)lpszObjectName, len);
    urlLength += len;

    *lpdwBuffSize = urlLength;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\constant.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    constant.h

Abstract:

    Contains all internal constant values used in INTERNET.DLL

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// manifests
//

#define K       * 1024
#define M       * 1048576
#define _1K     (1 K)
#define _2K     (2 K)
#define _4K     (4 K)
#define _8K     (8 K)
#define _16K    (16 K)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\sendreq.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    send.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest
        HTTP_REQUEST_HANDLE_OBJECT::CheckClientRequestHeaders
        CFsm_HttpSendRequest::RunSM
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start
        HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish
        HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo
        HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "httpp.h"
#include "autodial.h"

//
// HTTP Request Handle Object methods
//


DWORD
HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest(
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID *lplpOptional,
    IN LPDWORD lpdwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    OUT LPBOOL pfGoneOffline
    )

/*++

Routine Description:

    Performs Initiatization of the HTTP Request by setting up the necessary
     headers and preparing the POST data.

Arguments:

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total Length for File Upload.

    pfGoneOffline           - Pointer to BOOL that is set to TRUE if durning the course
                            of this call, the connection was forced offline

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - One of the Win32 Error values.

  Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::InitBeginSendRequest",
                 "%#x, %d, %d, %#x",
                 lplpOptional ? *lplpOptional : NULL,
                 lpdwOptionalLength ? *lpdwOptionalLength : NULL,
                 dwOptionalLengthTotal,
                 pfGoneOffline
                 ));

    DWORD error = ERROR_SUCCESS;
    LPVOID lpOptional       = *lplpOptional;
    DWORD dwOptionalLength  = *lpdwOptionalLength;

    INET_ASSERT(pfGoneOffline);

    *pfGoneOffline = FALSE;

    //
    // validate parameters
    //

    if ((lpOptional == NULL) || (dwOptionalLength == 0)) {
        lpOptional = NULL;
        dwOptionalLength = 0;
    }

    //
    // the headers lengths can be -1 meaning that we should calculate the
    // string lengths. We must do this before calling MakeAsyncRequest()
    // which is expecting the parameters to be correct
    //

    __try {
        if (dwHeadersLength == -1) {
            dwHeadersLength = lstrlen((LPCSTR)lpszHeaders);
        } else {

            //
            // probe headers
            //

            for (DWORD i = 0; i < dwHeadersLength; ++i) {

                volatile char ch = lpszHeaders[i];

            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if the caller specified some additional headers, then add them before
    // we make the request asynchronously
    //

    if (ARGUMENT_PRESENT(lpszHeaders) && (*lpszHeaders != '\0')) {

        //
        // we use the API here because the headers came from the app, and
        // we don't trust it
        //

        if (!HttpAddRequestHeaders(GetPseudoHandle(),
                                   lpszHeaders,
                                   dwHeadersLength,

                                   //
                                   // if the object is being re-used then
                                   // replace the headers to avoid
                                   // duplicating original headers
                                   //

                                   IS_VALID_HTTP_STATE(this, REUSE, TRUE)
                                    ? ( HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD ): 0
                                    //? HTTP_ADDREQ_FLAG_REPLACE : 0
                                   )) {
            error = GetLastError();
            goto quit;
        }
    }

    if (lpOptional && !GetSecondaryCacheKey()) {

        //
        // IE3 compat: set expiration on cache entry, if any, for this URL.
        //

        ExpireUrl();
    }

    //
    // if we are in offline mode or we have transitioned to offline mode
    // AND the caller didn't request RELOAD then allow only non-data GET
    // requests
    //

    BOOL bDisconnected;

    bDisconnected = IsOffline();

    BOOL bOfflineMode;

    bOfflineMode = (((GetInternetOpenFlags() | GetCacheFlags())
                        & INTERNET_FLAG_OFFLINE)
                    || (bDisconnected));

    if( bOfflineMode && _fIgnoreOffline )
        bOfflineMode = FALSE;

    if (  bOfflineMode  )
    {
        *pfGoneOffline = TRUE;

        if ( !GetSecondaryCacheKey()
        && (   (lpOptional != NULL)
            || (GetMethodType() != HTTP_METHOD_TYPE_GET))) {
            error = ERROR_FILE_NOT_FOUND;
            goto quit;
        }
    }

    CheckClientRequestHeaders();

    //
    // if there's no data to send then if we're offline then we attempt to
    // retrieve the file from cache
    //

    if ((lpOptional == NULL && dwOptionalLengthTotal == 0) || GetSecondaryCacheKey()) {
        if (bOfflineMode) {
            error = FHttpBeginCacheRetrieval(FALSE, TRUE);
            if (error == ERROR_SUCCESS) {
                error = ERROR_INTERNET_CACHE_SUCCESS;
                goto quit;
            }
            else{
                goto quit;
            }
        } else {
            error = GetFromCachePreNetIO();

            //
            // if we succeeded in getting the file from the cache or we're
            // disconnected then we're done
            //

            if ((error == ERROR_SUCCESS) || bDisconnected)
            {
                if ( error == ERROR_SUCCESS )
                {
                    error = ERROR_INTERNET_CACHE_SUCCESS;
                }
                goto quit;
            }
            else if (error == ERROR_INTERNET_INSERT_CDROM)
            {
                // Check if it's ok to return this error. We do this if the
                // client has indicated it allows ERROR_INTERNET_INSERT_CDROM
                // via InternetSetOption and an insert cdrom dialog is not active.
                if (GetErrorMask() & INTERNET_ERROR_MASK_INSERT_CDROM)
                {
                    if (!(BOOL) InterlockedExchange((LONG*) &fCdromDialogActive, (LONG) TRUE))
                        goto quit;
                }
            }
        }
    }

    //
    // If we fall through then we are connected and a) either the thing
    // is not in the cache or we did a conditional get or c) there was
    // some cache error
    //

    error = ERROR_SUCCESS;

    //
    // if the app supplied a user-agent string to InternetOpen() AND hasn't
    // added a "User-Agent:" header, then add it
    //

    LPSTR userAgent;
    DWORD userAgentLength;

    userAgent = GetUserAgent(&userAgentLength);
    if (userAgent != NULL) {
        ReplaceRequestHeader(HTTP_QUERY_USER_AGENT,
                             userAgent,
                             userAgentLength,
                             0, // dwIndex,
                             ADD_HEADER_IF_NEW
                             );
    }

    //
    // do the same thing with the "Host:" header. The header-value is the host
    // name supplied to InternetConnect() (or the name of the redirected host)
    //

    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT hostPort;

    hostName = GetHostName(&hostNameLength);
    hostPort = GetHostPort();

    INET_ASSERT((hostName != NULL) && (hostNameLength > 0));

    char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];

    if ((hostPort != INTERNET_DEFAULT_HTTP_PORT)
    && (hostPort != INTERNET_DEFAULT_HTTPS_PORT)) {
        if (lstrlen(hostName) > INTERNET_MAX_HOST_NAME_LENGTH)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        hostNameLength = wsprintf(hostValue, "%s:%d", hostName, (hostPort & 0xffff));
        hostName = hostValue;
    }
    ReplaceRequestHeader(HTTP_QUERY_HOST,
                         hostName,
                         hostNameLength,
                         0, // dwIndex,
                         ADD_HEADER_IF_NEW
                         );

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    //if (pRequest->GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION) {
    //    pRequest->SetWantKeepAlive(TRUE);
    //}

    //
    // add the content-length header IF we are sending data OR this is a POST,
    // AND ONLY if the app has not already added the header
    //

    if (dwOptionalLength || dwOptionalLengthTotal)
        SetMethodBody();
        
    if (((dwOptionalLength != 0) || (dwOptionalLengthTotal != 0))

    //
    // BUGBUG - just comparing against a method type is insufficient. We need
    //          a test of whether the method implies sending data (PUT, etc).
    //          We make the same test in other places
    //

    || (GetMethodType() != HTTP_METHOD_TYPE_GET)) {

        DWORD dwContentLength;

        char number[sizeof("4294967295")];

        //
        // For File Upload we need to add the Content-Length
        //   header off of the Total Length, Not the current
        //   data size.  Since we get more data via InternetWriteFile
        //

        if ( dwOptionalLengthTotal != 0 )
        {
            dwContentLength = dwOptionalLengthTotal;
        }
        else
        {
            dwContentLength = dwOptionalLength;
        }

        // _itoa(dwOptionalLength, number, 10);
        wsprintf(number, "%d", dwContentLength);

        DWORD numberLength = lstrlen(number);

        /*----------------------------------------------------------------------

        #62953 NOTE --  Authstate can never be in the AUTHSTATE_NEGOTIATE
        state here. It is not necessary to zero out the content length
        header here when omitting post data on NTLM negotiate since this
        will be done later in the request. The commented-out code is not
        necessary.

        if ((GetMethodType() == HTTP_METHOD_TYPE_POST)
            && (GetAuthState() == AUTHSTATE_NEGOTIATE))
        {

            ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                                "0",
                                1,
                                0,   // dwIndex
                                ADD_HEADER
                                );
        }

        ---------------------------------------------------------------------*/

        // Normally we don't over-write the content-length
        // header if one already exists.
        DWORD dwAddHeader;
        dwAddHeader = ADD_HEADER_IF_NEW;

        // But if we're posting data and have an auth ctx
        // over-write the content-length header which will
        // have been reset to 0 to omit post data on the
        // negotiate phase.
        AUTHCTX *pAuthCtx;
        pAuthCtx = GetAuthCtx();
        if (pAuthCtx)
        {
            dwAddHeader = ADD_HEADER;
        }


        ReplaceRequestHeader(HTTP_QUERY_CONTENT_LENGTH,
                            (LPSTR)number,
                            numberLength,
                            0,   // dwIndex
                             dwAddHeader
                            );

    }

quit:

    *lplpOptional       = lpOptional;
    *lpdwOptionalLength = dwOptionalLength;

    DEBUG_LEAVE(error);

    return error;
}


void
HTTP_REQUEST_HANDLE_OBJECT::CheckClientRequestHeaders(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (IsFirstSendProcessed())
    {
        return; // been there, done that
    }

    SetFirstSendProcessed();

    //
    // record the initial URL for offline mapping in case of redirects
    //

    SetOriginalUrl(GetCacheKey());


    //
    // Disabling cache if OFFLINE flag not set and RELOAD flag set.
    //

    if (    !((GetInternetOpenFlags() | GetCacheFlags()) & INTERNET_FLAG_OFFLINE)
        &&  GetCacheFlags() & INTERNET_FLAG_RELOAD
       )
    {
        SetCacheReadDisabled();
        return;
    }

    //
    // See if the client added any headers that imply caching disabled.
    //

    _RequestHeaders.LockHeaders();
   DWORD Headers[] =
    {
        HTTP_QUERY_IF_MODIFIED_SINCE,
        HTTP_QUERY_IF_NONE_MATCH,
        HTTP_QUERY_RANGE
    };

    DWORD i;
    for (i=0; i<ARRAY_ELEMENTS(Headers); i++)
    {
        if (IsRequestHeaderPresent(Headers[i]))
        {
            SetCacheReadDisabled();
            break;
        }
    }

    _RequestHeaders.UnlockHeaders();
}


DWORD
CFsm_HttpSendRequest::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpSendRequest::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    START_SENDREQ_PERF();

    CFsm_HttpSendRequest * stateMachine = (CFsm_HttpSendRequest *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        //
        // Make sure appropriate connection and proxy is in place
        //
        FixProxySettingsForCurrentConnection(FALSE);

        //
        // fall through to FSM_STATE_CONTINUE
        //

    case FSM_STATE_CONTINUE:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Start(stateMachine);
        break;

    case FSM_STATE_FINISH:

        //CHECK_FSM_OWNED(Fsm);

        error = pRequest->HttpSendRequest_Finish(stateMachine);
        break;

    case FSM_STATE_ERROR:

        //CHECK_FSM_OWNED(Fsm);

        error = Fsm->GetError();

        //
        // If we block to call GetProxyInfo async, then
        //  we may get unblocked during a cancel.  We need to
        //   handle it by freeing the object in our destructor.
        //

        INET_ASSERT( (!stateMachine->m_fOwnsProxyInfoQueryObj) ?
                        ( error == ERROR_INTERNET_OPERATION_CANCELLED ||
                          error == ERROR_INTERNET_TIMEOUT )  :
                        TRUE );

        Fsm->SetDone();
        break;

    default:

        //CHECK_FSM_OWNED(Fsm);

        stateMachine->m_fOwnsProxyInfoQueryObj = TRUE;
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    STOP_SENDREQ_PERF();

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    Calls SendData() method in a loop, handling redirects (& authentications?)
    until we have successfully started to retrieve what was originally requested

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Operation completed successfully

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_INTERNET_INCORRECT_HANDLE_STATE
                    The HTTP request handle is in the wrong state for this
                    request

                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Start);

    //CHECK_FSM_OWNED(Fsm);

    CFsm_HttpSendRequest & fsm = *Fsm;

    //
    // we must loop here while the server redirects us or while we authenticate
    // the user
    //

    FSM_STATE state = fsm.GetState();
    DWORD error = fsm.GetError();

    //
    // We set m_fOwnsProxyInfoObj TRUE, because by virtue of being here
    //   we have know that we now own the pointer in our fsm, pointed to by
    //   fsm.m_pProxyInfoQuery.
    //
    // This boolean is used to know when we are allowed to FREE and ACCESS
    //   this pointer.  If FALSE, we CANNOT touch this pointer because
    //   the auto-proxy thread may be accessing it.   The auto-proxy thread
    //   will unblock us, this releasing its "un-offical" lock on this pointer.
    //

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if (state == FSM_STATE_INIT)
    {        
        if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
        {
            state = FSM_STATE_5;
            fsm.SetFunctionState(FSM_STATE_5);
        }
    }
    else
    {
        state = fsm.GetFunctionState();
    }

retry_send_request:

    do {
        switch (state) {
        case FSM_STATE_INIT:
        case FSM_STATE_1:

            //CHECK_FSM_OWNED(Fsm);
            if (IsHttp1_1())
            {
                fsm.m_iRetries = (GlobalMaxConnectionsPerServer + 1);
            }
            else
            {
                fsm.m_iRetries = (GlobalMaxConnectionsPer1_0Server + 1);
            }

            fsm.m_bAuthNotFinished = FALSE;
            fsm.m_dwCookieIndex = 0;

            //
            // Terrible bug that afflicts NS servers while doing SSL,
            //  they lie (those buggers), and claim they do keep-alive,
            //  but when we attempt to reuse their Keep-Alive sockets,
            //  they all fail, so we therefore must increase the retry count
            //  so we can empty all the bad keep-alive sockets out of the pool
            //
              
            if ( (GetOpenFlags() & INTERNET_FLAG_SECURE) )
            {
                CServerInfo * pServerInfo = GetServerInfo();
    
                if ( pServerInfo && pServerInfo->IsBadNSServer() )
                {
                    fsm.m_iRetries = 5;
                }

                // Also, purge all keep-alives and cached client auth cert chains
                // if the user flushed the SSL state via inetcpl, including the
                // one for the request object...if being reused.
                if (RefreshSslState())
                    SetCertContextArray(NULL);
            }

            //
            // if we're not in the right state to send, drain the socket
            //

            if (!IsValidHttpState(SEND)) {

#define DRAIN_SOCKET_BUFFER_LENGTH  (1 K)

                if (fsm.m_pBuffer == NULL) {
                    fsm.m_pBuffer = (LPVOID)ALLOCATE_MEMORY(
                                        LMEM_FIXED,
                                        DRAIN_SOCKET_BUFFER_LENGTH);
                    if (fsm.m_pBuffer == NULL) {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }
                }
                do {
                    if (!fsm.m_bSink) {
                        fsm.m_bSink = TRUE;
                        fsm.SetFunctionState(FSM_STATE_2);
                        error = ReadData(fsm.m_pBuffer,
                                         DRAIN_SOCKET_BUFFER_LENGTH,
                                         &fsm.m_dwBytesDrained,
                                         TRUE,
                                         0);
                        if (error == ERROR_IO_PENDING) {
                            goto quit;
                        }
                    }

                    //
                    // fall through to state 2
                    //

        case FSM_STATE_2:

                    fsm.m_bSink = FALSE;
                } while ((error == ERROR_SUCCESS) && (fsm.m_dwBytesDrained != 0));
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
                if (fsm.m_pBuffer != NULL) {
                    fsm.m_pBuffer = (LPVOID)FREE_MEMORY(fsm.m_pBuffer);

                    INET_ASSERT(fsm.m_pBuffer == NULL);

                }

                ReuseObject();

                INET_ASSERT(!IsData());
                INET_ASSERT(IS_VALID_HTTP_STATE(this, SEND, TRUE));

                //
                // BUGBUG - if we're not in the right state?
                //

            }

            //
            // generate the correct request headers based
            //  on what types, or whether we're using
            //  proxies
            //


            fsm.SetFunctionState(FSM_STATE_3);
            error = UpdateProxyInfo(Fsm, FALSE);

            if (error == ERROR_IO_PENDING) {
                goto done;
            }

            //
            // set function state to not-FSM_STATE_3 to differentiate interrupted
            // path in FSM_STATE_3
            //

            fsm.SetFunctionState(FSM_STATE_BAD);

            //
            // fall through
            //

        case FSM_STATE_3:

            if (error != ERROR_SUCCESS)
            {
                fsm.m_bCancelRedoOfProxy = TRUE;
                goto quit;
            }
            else if (fsm.GetFunctionState() == FSM_STATE_3) 
            {
                BOOL fChangedFsmVariable = TRUE;
                if (! fsm.m_bCancelRedoOfProxy)
                {
                    fsm.m_bCancelRedoOfProxy = TRUE;
                    fChangedFsmVariable = TRUE;
                }
                
                error = UpdateProxyInfo(Fsm, TRUE);

                if (error != ERROR_SUCCESS)
                {
                    goto quit;
                }
                else if (fChangedFsmVariable)
                {
                    fsm.m_bCancelRedoOfProxy = FALSE;
                }
            }

            fsm.SetFunctionState(FSM_STATE_4);

        case FSM_STATE_4:

            //
            // get any cookies required for this site, but only if app didn't
            // tell us it will handle cookies
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES) ) {
                fsm.SetBlocking(TRUE);

                int cCookie = 0;
                
                error = CreateCookieHeaderIfNeeded(&cCookie);
                if (cCookie) {
                    SetPerUserItem(TRUE);
                }
                fsm.SetBlocking(FALSE);

                if(error != ERROR_SUCCESS) {
                    goto quit;
                }
            }

            //
            // if this URL requires authentication then add its header here, but
            // only if the app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_AUTH)) 
            {
                SetPPAbort(FALSE); // let's assume Passport is not going to abort the send.
                
                error = AuthOnRequest(this);
                if (error != ERROR_SUCCESS) 
                {
                    goto quit;
                }

                if (PPAbort())
                {
                    // Passport needed to abort the send cuz the DA wanted to redirect
                    // the App to an different site *AND* the app wanted to handle the 
                    // redirect itself.
                    error = ERROR_INTERNET_LOGIN_FAILURE;
                    goto quit;
                }

                error = HttpFiltOnRequest(this);
            }
try_again:
            fsm.SetFunctionState(FSM_STATE_5);
            DEBUG_PRINT(HTTP, INFO, ("State_4_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));
            error = DoFsm(new CFsm_SendRequest(fsm.m_lpOptional,
                                               fsm.m_dwOptionalLength,
                                               this
                                               ));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_5:
            DEBUG_PRINT(HTTP, INFO, ("State_5_start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            if (error == ERROR_INTERNET_OFFLINE) {
                goto offline_check;
            } else if (((GetOpenFlags() & INTERNET_FLAG_CACHE_IF_NET_FAIL)
                        && ((error == ERROR_INTERNET_CANNOT_CONNECT)
                            || (error == ERROR_INTERNET_CONNECTION_RESET)))
                       || ((error == ERROR_INTERNET_TIMEOUT)
                           && IsFromCacheTimeoutSet()
                           && CanRetrieveFromCache(FALSE))) {

                //CHECK_FSM_OWNED(Fsm);

//if (IsFromCacheTimeoutSet() && IsInCache()) {
//    dprintf("%q timed out on connect/send - getting from cache\n", GetURL());
//}
                error = GetFromCachePostNetIO(HTTP_STATUS_NOT_MODIFIED, TRUE);
                if (error == ERROR_SUCCESS) {
                    SetNetFailed();
                }
                goto quit;
            }

            //CHECK_FSM_OWNED(Fsm);

            //
            // This adds CR-LF for the File Upload case
            //

            //if (_RequestMethod == HTTP_METHOD_TYPE_POST && _AddCRLFToPOST && fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST)
            //{
            //    error = _Socket->Send(gszCRLF, 2, 0);
            //    if (error != ERROR_SUCCESS) {
            //        goto quit;
            //    }
            //}
            fsm.m_bWasKeepAlive = (_bKeepAliveConnection || IsKeepAlive());
            if ((error != ERROR_SUCCESS)
            || ((GetStatusCode() != HTTP_STATUS_OK) && (GetStatusCode() != 0))) {

                //
                // must be doing proxy tunnelling request if status code set
                //

                INET_ASSERT(((GetStatusCode() != HTTP_STATUS_OK)
                            && (GetStatusCode() != 0))
                            ? IsTalkingToSecureServerViaProxy()
                            : TRUE
                            );

                //
                // server may have reset keep-alive connection
                //

                if (((error == ERROR_INTERNET_CONNECTION_RESET)
                || (error == ERROR_INTERNET_CONNECTION_ABORTED))
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after send. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after send\n");
                    CloseConnection(TRUE);
                    goto try_again;
                }
                goto quit;
            }
            if (fsm.m_arRequest == AR_HTTP_BEGIN_SEND_REQUEST) {
                goto quit;
            }
            fsm.SetFunctionState(FSM_STATE_6);
            error = DoFsm(new CFsm_ReceiveResponse(this));
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

            //
            // fall through
            //

        case FSM_STATE_6:

            DEBUG_PRINT(HTTP, INFO, ("State_6_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (error != ERROR_SUCCESS) {
//dprintf("*** post-receive: error=%d, retries=%d\n", error, fsm.m_iRetries);

                //
                // server may have reset keep-alive connection
                //

                if (((error == ERROR_INTERNET_CONNECTION_RESET)
                || (error == ERROR_INTERNET_CONNECTION_ABORTED)
                || (error == ERROR_HTTP_INVALID_SERVER_RESPONSE))
                && fsm.m_bWasKeepAlive
                && (--fsm.m_iRetries != 0)) {

                    DEBUG_PRINT(HTTP,
                                INFO,
                                ("keep-alive connection failed after receive. Retrying\n"
                                ));

//dprintf("*** retrying k-a connection after receive\n");
                    CloseConnection(TRUE);
                    _ResponseHeaders.FreeHeaders();
                    ResetResponseVariables();
                    _ResponseHeaders.Initialize();
                    _dwCurrentStreamPosition = 0;
                    goto try_again;
                }

                //
                // if we reached this far and discover that the state is offline
                // then we have either transitioned to this state by losing the
                // net connection, or by being put into user-offline state. In
                // either case, we attempt to retrieve the item from the cache
                //

offline_check:
                if (IsOffline()) {
                    // if we already have it retrived, don't do it again
                    if (!_hCacheStream && !_pCacheEntryInfo )
                        error = FHttpBeginCacheRetrieval(TRUE, TRUE, FALSE);
                    else
                        error = FHttpBeginCacheRetrieval(TRUE, TRUE, TRUE);
        
                } else if (((GetOpenFlags() & INTERNET_FLAG_CACHE_IF_NET_FAIL)
                           && ((error == ERROR_INTERNET_CANNOT_CONNECT)
                               || (error == ERROR_INTERNET_CONNECTION_RESET)))
                           || ((error == ERROR_INTERNET_TIMEOUT)
                               && IsFromCacheTimeoutSet()
                               && CanRetrieveFromCache(FALSE))) {

//if (IsFromCacheTimeoutSet() && IsInCache()) {
//    dprintf("%q timed out on response - getting from cache\n", GetURL());
//}
                    error = GetFromCachePostNetIO(HTTP_STATUS_NOT_MODIFIED, TRUE);
                    if (error == ERROR_SUCCESS) {
                        SetNetFailed();
                    }
                }
                goto quit;
            }

            fsm.SetFunctionState(FSM_STATE_7);


        case FSM_STATE_7:
            DEBUG_PRINT(HTTP, INFO, ("State_7_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //
            // put any received cookie headers in the cookie jar, but only if the
            // app didn't tell us not to
            //

            if (!(GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
                /* && IsResponseHeaderPresent(HTTP_QUERY_SET_COOKIE) */ )
            {
                DWORD dwError;
                fsm.SetBlocking(TRUE);
                dwError = ExtractSetCookieHeaders(&fsm.m_dwCookieIndex);
                fsm.SetBlocking(FALSE);

                if ( dwError == ERROR_SUCCESS ) {
                    SetPerUserItem(TRUE);
                } else if ( dwError == ERROR_IO_PENDING ) {
                    error = ERROR_IO_PENDING;
                    goto quit;
                }
            }

            //
            // we need to handle various intermediary return codes:
            //
            //  30x - redirection
            //  40x - authentication
            //
            // BUT ONLY if the app didn't tell us it wanted to handle these itself
            //

            DWORD statusCode;
            BOOL bNoAuth;

            statusCode = GetStatusCode();
            bNoAuth = (GetOpenFlags() & INTERNET_FLAG_NO_AUTH) ? TRUE : FALSE;

            //
            // if the status is 200 (most frequently return header == success)
            // and we are not authenticating all responses then we're done
            //

            if ((statusCode == HTTP_STATUS_OK) && bNoAuth) {
                goto quit;
            }

            //
            // handle authentication before checking the cache
            //

            if (!bNoAuth) {

                //
                // call filter for cis rpa
                //

                if (!HttpFiltOnResponse(this)) {
                    switch (error = GetLastError()) {
                    case ERROR_INTERNET_FORCE_RETRY:

                        if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
                        {
                            goto quit;
                        }

                        fsm.m_bFinished = FALSE;
                        fsm.m_bAuthNotFinished = TRUE;
                        error = ERROR_SUCCESS;
                        break;

                    case ERROR_INTERNET_NEED_UI:
                        error = ERROR_SUCCESS;
                        break;
                    }
                }

                //
                // call packages for basic, ntlm, msn, dpa etc.
                //

                error = AuthOnResponse(this);
                // passport1.4 auth could change the status code from 302 to 401 here
                statusCode = GetStatusCode();

                if (error == ERROR_INTERNET_FORCE_RETRY) {

                    if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST )
                    {
                        goto quit;
                    }

                    //
                    // the object has been updated with new info - try again
                    //

                    fsm.m_bFinished = FALSE;
                    fsm.m_bAuthNotFinished = TRUE;
                    error = ERROR_SUCCESS;

                    //
                    // Reset auto-proxy info so we can retry the connection
                    //

                    if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                    {
                        delete fsm.m_pProxyInfoQuery;
                        fsm.m_pProxyInfoQuery = NULL;
                    }


                } else if (error == ERROR_INTERNET_INCORRECT_PASSWORD) {

                    //
                    // just return success to the app which will have to check the
                    // headers and make the request again, with the right password
                    //

                    error = ERROR_SUCCESS;
                    goto quit;
                } else if (error == ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY) {

                    // If app allows this error code return it. Otherwise return ERROR_INTERNET_LOGIN_FAILURE
                    if (!(GetErrorMask() & INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY))
                    {
                        error = ERROR_INTERNET_LOGIN_FAILURE;
                    }
                    else
                    {
                        goto quit;
                    }
                }
        
            }

            //
            // if we can read from the cache then let us try
            //

            if ((statusCode == HTTP_STATUS_OK)
                || (statusCode == HTTP_STATUS_NOT_MODIFIED)
                || (statusCode == HTTP_STATUS_PRECOND_FAILED)
                || (statusCode == HTTP_STATUS_PARTIAL_CONTENT)
                || (statusCode == 0)) {

                if (GetFromCachePostNetIO(statusCode) == ERROR_SUCCESS) {
                    error = ERROR_SUCCESS;
                    goto quit;
                }
            }

            BOOL fMustRedirect;
            
            fMustRedirect = FALSE;

            if (_pAuthCtx)
            {
                if (_pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_PASSPORT)
                {
                    PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)_pAuthCtx;
                    if (pPPCtx->m_lpszRetUrl)
                    {
                        fMustRedirect = TRUE;
                    }
                }
            }

            //
            // handle redirection
            //

            BOOL fDoProxyRedirect;

            fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_UNKNOWN;
            fDoProxyRedirect = FALSE;
            fsm.m_fNeedUserApproval = FALSE;

            fsm.m_bRedirected = FALSE;

            if (((statusCode == HTTP_STATUS_AMBIGUOUS)              // 300
                 || (statusCode == HTTP_STATUS_MOVED)               // 301
                 || (statusCode == HTTP_STATUS_REDIRECT)            // 302
                 || (statusCode == HTTP_STATUS_REDIRECT_METHOD)     // 303
//                 || (statusCode == HTTP_STATUS_USE_PROXY)           // 305
                 || (statusCode == HTTP_STATUS_REDIRECT_KEEP_VERB)) // 307
                && (fMustRedirect || !(GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT))) {

                //
                // Clean out expired PROXY_STATE
                //

                error = ERROR_SUCCESS;
                if ( fsm.m_fOwnsProxyInfoQueryObj && fsm.m_pProxyInfoQuery && fsm.m_pProxyInfoQuery->IsAlloced())
                {
                    delete fsm.m_pProxyInfoQuery;
                    fsm.m_pProxyInfoQuery = NULL;
                }
                //fsm.m_pProxyState = NULL;
                SetProxyName(NULL, 0, 0);

                //
                // if we've already had the max allowable redirects then quit
                //

                if (fsm.m_dwRedirectCount == 0) {
                    error = ERROR_HTTP_REDIRECT_FAILED;
                    fsm.m_bRedirectCountedOut = TRUE;
                    goto quit;
                }

                //
                // we got 300 (ambiguous), 301 (permanent move), 302 (temporary
                // move), or 303 (redirection using new method)
                //

                switch (statusCode) {
                case HTTP_STATUS_AMBIGUOUS:

                    //
                    // 300 - multiple choice
                    //

                    //
                    // If there is a Location header, we do an "automatic" redirect
                    //

                    _ResponseHeaders.LockHeaders();

                    if (! IsResponseHeaderPresent(HTTP_QUERY_LOCATION)) {
                        _ResponseHeaders.UnlockHeaders();
                        fsm.m_bFinished = TRUE;
                        break;
                    }

                    _ResponseHeaders.UnlockHeaders();

                    //
                    // fall through
                    //

                case HTTP_STATUS_MOVED:

                    // Table View:
                    //Method            301             302             303             307
                    //  *               *               *           GET         *
                    //POST                  GET         GET             GET             POST
                    //
                    //Put another way:
                    //301 & 302  - All methods are redirected to the same method but POST. POST is
                    //  redirected to a GET.
                    //303 - All methods are redirected to GET
                    //307 - All methods are redirected to the same method.

                    //
                    // 301 - permanently moved
                    //

                    //
                    // fall through
                    //

                case HTTP_STATUS_REDIRECT:

                    //
                    // 302 - temporarily moved (POST => GET, everything stays the same)
                    //
                    fsm.m_tMethodRedirect = GetMethodType();
                    if (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_POST)
                    //
                    // A POST change method to a GET
                    //
                    {
                        fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                        // force no optional data on second and subsequent sends
                        fsm.m_dwOptionalLength = 0;

                        // Don't decorate URL for a GET.
                        FreeSecondaryCacheKey();
                    }

                    // Other than GET and HEAD methods, we always want to
                    // error out to the client with ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION
                    
                    if ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET) &&
                        (fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD))
                    {
                        AUTHCTX* pAuthCtx = GetAuthCtx();
                        AUTHCTX::SPMScheme eAuthScheme = AUTHCTX::SCHEME_UNKNOWN;
                        if (pAuthCtx != NULL)
                        {
                           eAuthScheme = pAuthCtx->GetSchemeType();
                        }

                        // If Passport1.4 authentication is underway, we relax the user approval requirement
                        // to make app's life easier

                        if (eAuthScheme != AUTHCTX::SCHEME_PASSPORT)
                        {
                            fsm.m_fNeedUserApproval = TRUE;
                        }
                    }

                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;

                    break;
                case HTTP_STATUS_REDIRECT_METHOD:

                    //
                    // 303 - see other (POST => GET)
                    //

                    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                    //
                    // force no optional data on second and subsequent sends
                    //

                    fsm.m_dwOptionalLength = 0;

                    //
                    // Don't decorate URL for a GET.
                    //

                    FreeSecondaryCacheKey();

                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

                case HTTP_STATUS_REDIRECT_KEEP_VERB:

                    //
                    // 307 - see other (POST => POST)
                    //

                    //if (IsHttp1_1()) {
                    fsm.m_tMethodRedirect = GetMethodType();

                    if ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET) &&
                        (fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD))
                    {
                        fsm.m_fNeedUserApproval = TRUE;
                    }


                    INET_ASSERT(((fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_GET)
                                 || (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_HEAD))
                                 ? (fsm.m_dwOptionalLength == 0) : TRUE);

                    //} else {
                    //    fsm.m_dwOptionalLength = 0;
                    //    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;
                    //}
                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;

#if 0 // The http-wg will probably decide that 305 is only for proxies.

                case HTTP_STATUS_USE_PROXY:

                    //
                    // 305 - use proxy, force a re-request but now use a the specifed proxy
                    //

                    if ( IsResponseHttp1_1() )
                    {
                        fsm.m_tMethodRedirect = GetMethodType();
                        fDoProxyRedirect = TRUE;

                        fsm.m_bRedirected = TRUE;
                        --fsm.m_dwRedirectCount;

                        break;
                    }

                    //
                    // fall through
                    //
#endif

                default:
                    fsm.m_tMethodRedirect = HTTP_METHOD_TYPE_GET;

                    //
                    // BUGBUG - force no optional data on second and subsequent
                    //          sends
                    //

                    fsm.m_dwOptionalLength = 0;
                    fsm.m_bRedirected = TRUE;
                    --fsm.m_dwRedirectCount;
                    break;
                }

                //
                // Only allow redirect to continue if we are successful.
                //

                if (fsm.m_bRedirected
                && ((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_UNKNOWN)
                    || (fsm.m_tMethodRedirect == GetMethodType()))) {
                    fsm.SetFunctionState(FSM_STATE_8);
                    // Remember if it was a forms submit.
                    fsm.m_bFormsSubmit = ((GetOpenFlags() & INTERNET_FLAG_FORMS_SUBMIT) ||
                                          (fsm.m_tMethodRedirect == HTTP_METHOD_TYPE_POST));
                    error = Redirect(fsm.m_tMethodRedirect, fDoProxyRedirect);
                    if (error != ERROR_SUCCESS) {
                        goto quit;
                    }
                }
            } else {

                //
                // not a status that we handle. We're done
                //   BUT WAIT, we're only finshed if also
                //   finished retrying HTTP authentication.
                //
                // if the app told us not to handle authentication auth_not_finished
                // will be FALSE
                //

                if (!fsm.m_bAuthNotFinished) {
                    fsm.m_bFinished = TRUE;
                }
            }

            //
            // fall through
            //

        case FSM_STATE_8:
            DEBUG_PRINT(HTTP, INFO, ("State_8_Start: lpOptional = 0x%x deOptionalLength = %d\n", fsm.m_lpOptional, fsm.m_dwOptionalLength));

            //CHECK_FSM_OWNED(Fsm);

            if (fsm.m_bRedirected) {
                BOOL bFormsSubmit = fsm.m_bFormsSubmit;
                fsm.m_bFormsSubmit = FALSE;
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                //if ( IsResponseHttp1_1() &&
                //     fsm.m_fNeedUserApproval &&
                //     GetMethodType() != HTTP_METHOD_TYPE_GET &&
                //     GetMethodType() != HTTP_METHOD_TYPE_HEAD )
                if (fsm.m_fNeedUserApproval)
                {

                    INET_ASSERT((fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET) &&
                                (fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD));
                    //
                    // If servers force us to redirect back
                    //   to another POST, PUT, etc. then we must notify the user.
                    //

                    error = ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION;
                    DEBUG_PRINT(HTTP, INFO, ("User approval needed. returning 0x%x\r\n", error));
                    goto quit;
                }

                // If we are redirecting a forms submit always urlmon a chance
                // to ask the user because the submit might be going to a
                // restricted zone now.
                if ( bFormsSubmit )
                {
                    error = ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION;
                    DEBUG_PRINT(HTTP, INFO, ("Redirected form needs user approval. returning 0x%x\r\n", error));
                    goto quit;
                }

                INET_ASSERT(error == ERROR_SUCCESS);
                INET_ASSERT(!IsCacheReadInProgress());

                //
                // cleanup response headers from redirection
                //

                ReuseObject();
                if (GetFromCachePreNetIO() == ERROR_SUCCESS) {
                    error = ERROR_SUCCESS;
                    goto quit;
                }

                //
                // Allow Redirects to exit out and force the HttpEndRequestA
                //  caller to notice.
                //

                if ( fsm.m_arRequest == AR_HTTP_END_SEND_REQUEST &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_GET &&
                     fsm.m_tMethodRedirect != HTTP_METHOD_TYPE_HEAD
                     )
                {
                    error = ERROR_INTERNET_FORCE_RETRY;
                }
            }
        }
        state = FSM_STATE_INIT;
    } while (!fsm.m_bFinished && (error == ERROR_SUCCESS));

quit:
        DEBUG_PRINT(HTTP, INFO, ("Quit1: error = 0x%x\r\n", error));

    if (error == ERROR_IO_PENDING) {
        goto done;
    }

    {
        AUTHCTX* pAuthCtx = GetAuthCtx();
        AUTHCTX::SPMScheme eAuthScheme = AUTHCTX::SCHEME_UNKNOWN;
        if (pAuthCtx != NULL)
        {
            eAuthScheme = pAuthCtx->GetSchemeType();
        }

        if (!fsm.m_bCancelRedoOfProxy && 
            //(GetStatusCode() != HTTP_STATUS_DENIED) &&
            ((eAuthScheme != AUTHCTX::SCHEME_PASSPORT) || (GetStatusCode() != HTTP_STATUS_DENIED)) && // this is safer
            fsm.m_pInternet->RedoSendRequest(&error, fsm.m_pProxyInfoQuery, GetOriginServer(), GetServerInfo())) 
        {
            fsm.m_bFinished = FALSE;
            fsm.m_bRedirectCountedOut = FALSE;
            fsm.m_dwRedirectCount = GlobalMaxHttpRedirects;
            fsm.SetState(FSM_STATE_INIT);
            state = FSM_STATE_INIT;
            DEBUG_PRINT(HTTP, INFO, ("Quit2: error = 0x%x\r\n", error));
            goto retry_send_request;
        } 
        else 
        {
            //SetProxyName(NULL, 0, 0);
            DEBUG_PRINT(HTTP, INFO, ("Quit3: error = 0x%x\r\n", error));
        }
    }

    //
    // if ERROR_HTTP_REDIRECT_FAILED then we tried to redirect, but found that
    // we couldn't do it (e.g. http:// to ftp:// or file://, etc.) We need to
    // defer this to the caller to clean up & make the new request. They will
    // have all the header info (plus we probably already indicated the new
    // URL during the redirect callback). Just return ERROR_SUCCESS
    //
    // Only do this if we failed because we couldn't change to the new URL, not
    // because we counted out the redirects
    //
    // We also change the error code to ERROR_SUCCESS if we didn't redirect
    // because we were redirected to the same site
    //

    if (((error == ERROR_HTTP_REDIRECT_FAILED)
    || (error == ERROR_HTTP_NOT_REDIRECTED))
    && !fsm.m_bRedirectCountedOut) {
        error = ERROR_SUCCESS;
    }

    //
    // if we received a Refresh header along the way, but no longer have it (we
    // were redirected) then restore it
    //

    if ((error == ERROR_SUCCESS) && IsRefresh()) {

        DWORD err;

        _ResponseHeaders.LockHeaders();

        if (!IsResponseHeaderPresent(HTTP_QUERY_REFRESH))
        {

            DWORD len;
            HEADER_STRING & refreshHeader = GetRefreshHeader();

            if (refreshHeader.HaveString()) {
                err = AddInternalResponseHeader(HTTP_QUERY_REFRESH,
                                                refreshHeader.StringAddress(),
                                                refreshHeader.StringLength()
                                                );

                INET_ASSERT(err == ERROR_SUCCESS);

            }
        }

        _ResponseHeaders.UnlockHeaders();
    }

    fsm.SetNextState(FSM_STATE_FINISH);

done:

    PERF_LEAVE(HttpSendRequest_Start);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish(
    IN CFsm_HttpSendRequest * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Finish",
                 "%#x",
                 Fsm
                 ));

    PERF_ENTER(HttpSendRequest_Finish);

    CFsm_HttpSendRequest & fsm = *Fsm;
    DWORD error = fsm.GetError();

    fsm.m_fOwnsProxyInfoQueryObj = TRUE;


    if ((error == ERROR_SUCCESS)
    && !IsCacheReadInProgress()
    && !IsCacheWriteInProgress()
    && (fsm.m_arRequest != AR_HTTP_BEGIN_SEND_REQUEST)) {

        INET_ASSERT(!IsCacheReadInProgress());

        //
        // we are not reading from the cache
        // Let us ask a routine whether we should cache this
        // stuff or not
        //
        // (only need to do this for 200/206 response code)
        //

        if( _StatusCode == HTTP_STATUS_OK || 
            _StatusCode == HTTP_STATUS_PARTIAL_CONTENT)  
        {
            if (FCanWriteToCache() ) 
            {

                DEBUG_PRINT(CACHE,
                        INFO,
                        ("Starting cache write\n"
                        ));

                FHttpBeginCacheWrite();
            } else {

                //
                // If the WININET client must have caching,
                //  Notify him that we are unable to cache his files,
                //  by erroring out.
                //

                if (GetCacheFlags() & INTERNET_FLAG_NEED_FILE) {
                    error = ERROR_INTERNET_UNABLE_TO_CACHE_FILE;
                }
            }
        }
    }

    INET_ASSERT(fsm.m_hRequestMapped != NULL);

    //if (!IsAsyncHandle() && (fsm.m_hRequestMapped != NULL)) {
    //    DereferenceObject((LPVOID)fsm.m_hRequestMapped);
    //}

    //
    // we will return FALSE even if this is an async operation and the error is
    // ERROR_IO_PENDING
    //

    fsm.SetDone(error);
    //fsm.SetApiResult(error == ERROR_SUCCESS);

    PERF_LEAVE(HttpSendRequest_Finish);

    DEBUG_LEAVE(error);

    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::BuildProxyMessage(
    IN CFsm_HttpSendRequest * Fsm,
    AUTO_PROXY_ASYNC_MSG * pProxyMsg,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Calls CrackUrl to parses request URL, and 
      transfers the information to the AUTO_PROXY_ASYNC_MSG

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_SUCCESS;

    LPSTR currentUrl;
    DWORD currentUrlLength;

    //
    // Gather the URL off the handle
    //

    currentUrl = GetURL();

    if (currentUrl) {
        currentUrlLength = lstrlen(currentUrl);

        //
        // BUGBUG [arthurbi] the following can be a slow call,
        //   but its too risky to change the complete behavior where
        //   we cache it
        //

        //
        // crack the current URL
        //

        memset(pUrlComponents, 0, sizeof(URL_COMPONENTS));
        pUrlComponents->dwStructSize = sizeof(URL_COMPONENTS);

        error = CrackUrl(currentUrl,
                         currentUrlLength,
                         FALSE, // don't escape URL-path
                         &(pUrlComponents->nScheme),
                         NULL,  // don't care about Scheme Name
                         NULL,
                         &(pUrlComponents->lpszHostName),
                         &(pUrlComponents->dwHostNameLength),
                         &(pUrlComponents->nPort),
                         NULL,  // don't care about user name
                         NULL,
                         NULL,  // or password
                         NULL,
                         &(pUrlComponents->lpszUrlPath),
                         &(pUrlComponents->dwUrlPathLength),
                         NULL,  // no extra
                         NULL,
                         NULL
                         );

        pProxyMsg->SetProxyMsg(
            pUrlComponents->nScheme,
            currentUrl,
            currentUrlLength,
            pUrlComponents->lpszHostName,
            pUrlComponents->dwHostNameLength,
            pUrlComponents->nPort
            );
    } else {
        INET_ASSERT(FALSE);
        error = ERROR_INTERNET_INVALID_URL;
    }
    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::QueryProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    INTERNET_HANDLE_OBJECT * pInternet,
    IN OUT URL_COMPONENTS * pUrlComponents
    )

/*++

Routine Description:

    Wrapper over GetProxyInfo call to determine proxy
        settings on our given object

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::QueryProxySettings",
                 "%#x, %#x, %#x",
                 Fsm, pInternet, pUrlComponents
                 ));
                 
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    INET_ASSERT(fsm.m_pProxyInfoQuery);
    INET_ASSERT(pInternet);

    if (!IsAutoProxyChecked())
    {
        // Never do this more than once per request.
        // QFE 353 involves supporting authentication, and
        // this check prevents multiple dialogs from appearing
        // due to invalid credentials.    
        SetAutoProxyChecked(TRUE);
        
        error = pInternet->CheckAutoProxyDownloaded();
    }

    // don't touch fsm state.
    if ( error == ERROR_IO_PENDING )
    {
        goto quit;
    }

    SetProxyName(NULL, 0, 0);

    fsm.m_fOwnsProxyInfoQueryObj = FALSE;

    error = pInternet->GetProxyInfo(
                            &fsm.m_pProxyInfoQuery
                            );

    //
    //  If GetProxyInfo returns pending, then we no longer have
    //   access to the pointer that we've passed.
    //

    if ( error == ERROR_IO_PENDING )
    {
        //
        // Bail out, DO NOT TOUCH any OBJECTS or FSMs 
        //

        goto quit;
    }

    // then regardless we own it unless GetProxyInfo went pending with the FSM
    fsm.m_fOwnsProxyInfoQueryObj = TRUE;

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    INET_ASSERT( error == ERROR_SUCCESS );

    if ( ! ((fsm.m_pProxyInfoQuery)->IsUseProxy()) )
    {
        if ( pUrlComponents->nScheme == INTERNET_SCHEME_FTP ||
             pUrlComponents->nScheme == INTERNET_SCHEME_GOPHER )
        {
            //
            // we cannot go direct on these
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }

        SetIsTalkingToSecureServerViaProxy(FALSE);        
    }

quit:

    DEBUG_LEAVE(error);
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::CheckForCachedProxySettings(
    IN AUTO_PROXY_ASYNC_MSG *pProxyMsg,
    OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Attempts to determine and then resolve if there are cached
     proxy settings saved away in the CServerInfo object,
     which is found in our HTTP_REQUEST_ object.  This can
     be very useful since calling off to an auto-proxy thread
     can be quite expensive in terms of performance.

Arguments:

    pProxyMsg - the object containing our current proxy message
      information, that we use to scripple our proxy state for
      a given request

    ppProxyServerInfo - on return, may contain the resultant
      cached ServerInfo object.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    CServerInfo * pOriginServer = GetOriginServer();
    CServerInfo * pProxyServer;

    INET_ASSERT(pProxyMsg);

    *ppProxyServerInfo = NULL;

    if (pOriginServer)
    {
        BOOL fCachedEntry;

        pProxyServer = 
            pOriginServer->GetCachedProxyServerInfo(            
                pProxyMsg->_tUrlProtocol,
                pProxyMsg->_nUrlPort,
                &fCachedEntry
                );

        if (fCachedEntry)
        {
            if ( pProxyServer )
            {
                if (pProxyServer->CopyCachedProxyInfoToProxyMsg(pProxyMsg))
                {
                    SetOriginServer();
                    *ppProxyServerInfo = pProxyServer;
                    error = ERROR_SUCCESS;
                    goto quit;
                }
            
                // nuke extra ref, sideeffect of GetCachedProxy... call            
                ::ReleaseServerInfo(pProxyServer);
            }  
            else
            {
                // DIRECT, no-proxy cached.
                pProxyMsg->SetUseProxy(FALSE);
                pProxyMsg->_lpszProxyHostName = NULL;
                error = ERROR_SUCCESS;
                goto quit;
            }
        }
    }

    pProxyMsg->SetVersion();

quit:
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::ProcessProxySettings(
    IN CFsm_HttpSendRequest * Fsm,
    IN INTERNET_CONNECT_HANDLE_OBJECT * pConnect,
    IN OUT URL_COMPONENTS * pUrlComponents,
    OUT LPSTR * lplpszRequestObject,
    OUT DWORD * lpdwRequestObjectSize
    )
/*++

Routine Description:

    Armed with the results of the proxy query, this method takes care of 
    assembling the various variables and states to deal with various 
    types of proxies.

    More specifally, this handles HTTP Cern Proxies, SOCKS proxies, 
    SSL-CONNECT/HTTP proxies, and special cases such as FTP URLs
    with passwords through an HTTP Cern Proxy.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::ProcessProxySettings",
                 "%#x, %#x, %#x",
                 Fsm, pConnect, pUrlComponents
                 ));
                 
    DWORD error = ERROR_SUCCESS;
    CFsm_HttpSendRequest & fsm = *Fsm;

    LPSTR lpszUrlObject = NULL;
    LPSTR lpszObject = pUrlComponents->lpszUrlPath;
    DWORD dwcbObject = pUrlComponents->dwUrlPathLength;

    if ((fsm.m_pProxyInfoQuery)->GetProxyScheme() == INTERNET_SCHEME_SOCKS)
    {
        if ( pUrlComponents->nScheme == INTERNET_SCHEME_FTP ||
             pUrlComponents->nScheme == INTERNET_SCHEME_GOPHER )
        {
            //
            // we cannot go direct on these,
            //  this would for example an HTTP request over SOCKS,
            //  redirected to an FTP/GOPHER URL
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;
            goto quit;
        }


        SetSocksProxyName((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                          (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                          (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                          );

        (fsm.m_pProxyInfoQuery)->_lpszProxyHostName = NULL;
        (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength = 0;
    }
    else if (pUrlComponents->nScheme == INTERNET_SCHEME_HTTPS)
    {
        SetIsTalkingToSecureServerViaProxy(TRUE);
    }
    else
    {
        SetIsTalkingToSecureServerViaProxy(FALSE); // default value.

        //
        // if this request is going via proxy then we send the entire URL as the
        // request
        //

        DWORD urlLength;

        //
        // in secure proxy tunnelling case we are going to send the request
        // "CONNECT <host>:<port>"
        //

        LPSTR lpszMBCSHostName;
        DWORD dwMBCSHostNameLength;
        BOOL fUsedUTF8 = FALSE;
        LPSTR lpszUTF8HostName;
        DWORD dwUTF8StrLen;

        if (ShouldSendUTF8ServerNameToProxy())
        {
            INET_ASSERT (GlobalSendUTF8ServerToProxy);
            if (lpszUTF8HostName = ConvertMBCSToUTF8(pUrlComponents->lpszHostName, 
                                                    pUrlComponents->dwHostNameLength, 
                                                    GetCodePage(),
                                                    &dwUTF8StrLen))
            {
                lpszMBCSHostName = pUrlComponents->lpszHostName;
                dwMBCSHostNameLength = pUrlComponents->dwHostNameLength;
                pUrlComponents->lpszHostName = lpszUTF8HostName;
                pUrlComponents->dwHostNameLength = dwUTF8StrLen;
                fUsedUTF8 = TRUE;
            }
        }            
                    

        if (IsTunnel()) {
            urlLength = pUrlComponents->dwHostNameLength + sizeof(":65535");
        } else {
            urlLength = INTERNET_MAX_URL_LENGTH;
        }

        lpszUrlObject = (LPSTR)ResizeBuffer(NULL, urlLength, FALSE);
        if (lpszUrlObject == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto local_quit;
        }

        if (IsTunnel())
        {
            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                INET_ASSERT (pUrlComponents->nScheme == INTERNET_SCHEME_HTTP);
                pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
            }
            memcpy (lpszUrlObject, pUrlComponents->lpszHostName, pUrlComponents->dwHostNameLength);
            wsprintf (lpszUrlObject + pUrlComponents->dwHostNameLength, ":%d", pUrlComponents->nPort);
        }
        else
        {
            //
            // there may be a user name & password (only if FTP)
            //

            LPSTR userName;
            DWORD userNameLength;
            LPSTR password;
            DWORD passwordLength;

            if (pUrlComponents->nScheme == INTERNET_SCHEME_FTP) {
                userName = pConnect->GetUserOrPass(IS_USER, IS_SERVER);
                userNameLength = userName ? lstrlen(userName)  : 0;
                password = pConnect->GetUserOrPass(IS_PASS, IS_SERVER);
                passwordLength = password ? lstrlen(password)  : 0;
            } else {
                userName = NULL;
                userNameLength = 0;
                password = NULL;
                passwordLength = 0;
            }

            if (pUrlComponents->nPort == INTERNET_INVALID_PORT_NUMBER)
            {
                switch (pUrlComponents->nScheme)
                {
                    case INTERNET_SCHEME_FTP:
                        pUrlComponents->nPort = INTERNET_DEFAULT_FTP_PORT;
                        break;

                    case INTERNET_SCHEME_GOPHER:
                        pUrlComponents->nPort = INTERNET_DEFAULT_GOPHER_PORT;
                        break;

                    case INTERNET_SCHEME_HTTP:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTP_PORT;
                        break;

                    case INTERNET_SCHEME_HTTPS:
                        pUrlComponents->nPort = INTERNET_DEFAULT_HTTPS_PORT;
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        break;
                }
            }

            pUrlComponents->lpszUserName = userName;
            pUrlComponents->dwUserNameLength = userNameLength;
            pUrlComponents->lpszPassword = password;
            pUrlComponents->dwPasswordLength = passwordLength;

            if (!InternetCreateUrl(pUrlComponents, ICU_ESCAPE_AUTHORITY, lpszUrlObject, &urlLength))
            {
                error = GetLastError();
            }

            if (password)
            {
                SecureZeroMemory(password, lstrlen(password));
                FREE_MEMORY(password);
                password = NULL;
            }

            if (error != ERROR_SUCCESS)
                goto local_quit;

            //
            // shrink the buffer to fit
            //

            lpszUrlObject = (LPSTR)ResizeBuffer(lpszUrlObject,
                                                (urlLength + 1) * sizeof(TCHAR),
                                                FALSE
                                                );

            INET_ASSERT(lpszUrlObject != NULL);

            if (lpszUrlObject == NULL)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto local_quit;
            }
        }

        SetRequestUsingProxy(TRUE);

        lpszObject = lpszUrlObject;
        dwcbObject = lstrlen(lpszUrlObject);

local_quit:
        if (fUsedUTF8)
        {
            pUrlComponents->lpszHostName = lpszMBCSHostName;
            pUrlComponents->dwHostNameLength = dwMBCSHostNameLength;

            LPSTR hostName = lpszUTF8HostName;
            DWORD hostNameLength = dwUTF8StrLen;
            INTERNET_PORT hostPort = GetHostPort();
            LPSTR pAllocHostName = NULL;

            if ((hostPort != INTERNET_DEFAULT_HTTP_PORT)
                && (hostPort != INTERNET_DEFAULT_HTTPS_PORT)) 
            {
                pAllocHostName = new CHAR[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")+1];

                if (pAllocHostName)
                {
                    hostNameLength = wsprintf(pAllocHostName, "%s:%d", hostName, (hostPort & 0xffff));
                    hostName = pAllocHostName;
                }
                else
                {
                    hostName = NULL;
                }
            }

            if (hostName)
            {
                ReplaceRequestHeader(HTTP_QUERY_HOST,
                                     hostName,
                                     hostNameLength,
                                     0, // dwIndex,
                                     ADD_HEADER
                                     );
            }

            if (pAllocHostName)
            {
                delete [] pAllocHostName;
            }
            
            delete [] lpszUTF8HostName;
        }
    }

quit:

    *lplpszRequestObject   = lpszObject;
    *lpdwRequestObjectSize = dwcbObject;

    DEBUG_LEAVE(error);
    return error;
}

DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateRequestInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN LPSTR lpszObject,
    IN DWORD dwcbObject,
    IN OUT URL_COMPONENTS * pUrlComponents,
    IN OUT CServerInfo **ppProxyServerInfo
    )

/*++

Routine Description:

    Based on object and URL information, for a given HTTP request, 
    this function assembles the "special cases" and modifes the 
    request headers in prepartion of making the actual request.

    The "special cases" includes the handling of HTTP versioning, 
    HTTP 1.0/1.1 keep-alives, and Pragma headers.

    This function also deals with the update the ServerInfo object
    that contains the host resolution information.


Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateRequestInfo",
                 "%#x, %.100q, %d, %#x",
                 Fsm, lpszObject, dwcbObject, pUrlComponents
                 ));
                 
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszVersion = NULL;
    DWORD dwVersionLen = 0;

    CFsm_HttpSendRequest & fsm = *Fsm;

    if ( lpszObject == NULL) 
    {
        lpszObject = pUrlComponents->lpszUrlPath;
        dwcbObject = pUrlComponents->dwUrlPathLength;
    }
        
    INET_ASSERT(dwcbObject > 0 );

    _RequestHeaders.LockHeaders();

    //
    // if we are going via proxy and HTTP 1.1 through proxy is disabled
    // then modify the request version to HTTP/1.0
    //

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() &&        
        ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) &&
        (!GlobalEnableProxyHttp1_1 || GetMethodType() == HTTP_METHOD_TYPE_CONNECT)) {
        lpszVersion = "HTTP/1.0";
        dwVersionLen = sizeof("HTTP/1.0") - 1;
        RemoveGzipDeflateEncHeader();
    }

    ModifyRequest(GetMethodType(),
                  lpszObject,
                  dwcbObject,
                  lpszVersion,
                  dwVersionLen
                  );

    if ((fsm.m_pProxyInfoQuery)->IsUseProxy() )        
    {
        SetProxyName( (fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                      (fsm.m_pProxyInfoQuery)->_nProxyHostPort
                      );

        if ((fsm.m_pProxyInfoQuery)->_lpszProxyHostName != NULL) {

            if (_ServerInfo != NULL)
            {
                _ServerInfo->SetProxyByPassed(FALSE);
            }

            //
            // changing server info from origin server to proxy server. Keep
            // pointer to origin server so that we can update connect and
            // round-trip times
            //

            SetOriginServer();

            if (*ppProxyServerInfo) {
                // cached server info
                SetServerInfo(*ppProxyServerInfo);
                *ppProxyServerInfo = NULL;
            }
            else
            {            
                error = SetServerInfo((fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                                      (fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength
                                      );
                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
            }
        }
    }
    else
    {
        if (_ServerInfo != NULL)
        {
            _ServerInfo->SetProxyByPassed(TRUE);

            if ( pUrlComponents->lpszHostName )
            {
                error = SetServerInfo(pUrlComponents->lpszHostName,
                                      pUrlComponents->dwHostNameLength
                                      );

                if (error != ERROR_SUCCESS) {
                    goto quit;
                }
            }

        }
    }

    //
    // determine whether we use persistent connections and ensure the correct
    // type and number of keep-alive headers are present
    //

    //
    // BUGBUG - we need to check for "Connection: keep-alive". There may be
    //          other types of "Connection" header, and the keep-alive header
    //          may contain additional information
    //

    DWORD bufferLength;
    DWORD index;
    DWORD dwHeaderNameIndex;

    if (IsRequestUsingProxy()) {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_PROXY_CONNECTION;
    } else {
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);
        dwHeaderNameIndex = HTTP_QUERY_CONNECTION;
    }

    if (IsRequestHeaderPresent(dwHeaderNameIndex)) {
        SetWantKeepAlive(TRUE);
        SetOpenFlags(
            GetOpenFlags() | INTERNET_FLAG_KEEP_CONNECTION);
    }

    error = ERROR_SUCCESS;

    //
    // if the global keep-alive switch
    // is off then we don't want any keep-alive headers
    //

    if (GlobalDisableKeepAlive)
    {
        RemoveAllRequestHeadersByName(HTTP_QUERY_CONNECTION);
        RemoveAllRequestHeadersByName(HTTP_QUERY_PROXY_CONNECTION);

        if (IsRequestHttp1_1())
        {
            //
            // Add "Connection: Close" header because we're not doing
            //  keep-alive on this Request, needed for HTTP 1.1
            //

            (void)ReplaceRequestHeader(HTTP_QUERY_CONNECTION,
                                       CLOSE_SZ,
                                       CLOSE_LEN,
                                       0,
                                       REPLACE_HEADER
                                       );
        }

        SetOpenFlags(
            GetOpenFlags() & ~INTERNET_FLAG_KEEP_CONNECTION);
    }

    //
    // if the app requested keep-alive then add the header; if we're going via
    // proxy then use the proxy-connection header
    //

    if (GetOpenFlags() & INTERNET_FLAG_KEEP_CONNECTION)
    {
        SetWantKeepAlive(TRUE);
        (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                   KEEP_ALIVE_SZ,
                                   KEEP_ALIVE_LEN,
                                   0,
                                   ADD_HEADER_IF_NEW
                                   );
    }

    //
    // if app added "connection: close" then we don't want keep-alive
    //

    if (IsRequestHttp1_1()) {

        BOOL bClose = FindConnCloseRequestHeader(dwHeaderNameIndex);
        BOOL bWantKeepAlive;
        DWORD dwOpenFlags = GetOpenFlags();

        if (bClose || (IsTunnel() && GetAuthState() != AUTHSTATE_CHALLENGE)) {
            RemoveAllRequestHeadersByName(dwHeaderNameIndex);

            //
            // For a Tunnel to a proxy we want to make sure that
            //  keep-alive is off since is does not make sense
            //  to do keep-alive with in a HTTP CONNECT request
            //
            // Note: we do not add the Connection: close header
            //  because of its amphorus definition in this case.
            //

            if (!IsTunnel()) {
                (void)ReplaceRequestHeader(dwHeaderNameIndex,
                                           CLOSE_SZ,
                                           CLOSE_LEN,
                                           0,
                                           REPLACE_HEADER
                                           );
            }
            bWantKeepAlive= FALSE;
            dwOpenFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
        } else {
            bWantKeepAlive = TRUE;
            dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION;
        }
        SetWantKeepAlive(bWantKeepAlive);
        SetOpenFlags(dwOpenFlags);
    }

    DWORD dwFlags;
    dwFlags = GetCacheFlags();

    if (GetMethodType() == HTTP_METHOD_TYPE_POST && !GetSecondaryCacheKey())
    {
        //
        // IE30 compat: force reload on post
        //

        dwFlags |= INTERNET_FLAG_RELOAD;
    }

    if (dwFlags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_PRAGMA_NOCACHE))
    {
        //
        // add "Pragma: No-Cache" header for HTTP 1.0  or
        // add "Cache-Control: No-Cache" header for HTTP 1.1
        // if not already present and if forced with CTRL+F5
        // add "Pragma: No-Cache" header if through proxy.
        //
        BOOL fUseProxy = FALSE;
        fUseProxy = IsRequestUsingProxy();

        if ( fUseProxy || !(dwFlags & INTERNET_FLAG_RESYNCHRONIZE) )
        {
            if ((!fUseProxy && GlobalEnableHttp1_1))
            {
            ReplaceRequestHeader(HTTP_QUERY_CACHE_CONTROL,
                               NO_CACHE_SZ,
                               NO_CACHE_LEN,
                               0,   // dwIndex
                               ADD_HEADER_IF_NEW
                               );
            }
            else
            {
            ReplaceRequestHeader(HTTP_QUERY_PRAGMA,
                               NO_CACHE_SZ,
                               NO_CACHE_LEN,
                               0,   // dwIndex
                               ADD_HEADER_IF_NEW
                               );
            }
        }
    }

quit:

    _RequestHeaders.UnlockHeaders();

    DEBUG_LEAVE(error);
    return error;

}



DWORD
HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo(
    IN CFsm_HttpSendRequest * Fsm,
    IN BOOL fCallback
    )

/*++

Routine Description:

    Queries Proxy Information, and based on the proxy info it assembles the appropriate
     HTTP request.

Arguments:

    Fsm - HTTP send request FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY
                    Ran out of resources

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::UpdateProxyInfo",
                 "%#x, %B",
                 Fsm,
                 fCallback
                 ));

    PERF_ENTER(UpdateProxyInfo);

    DWORD error = ERROR_SUCCESS;

    CFsm_HttpSendRequest & fsm = *Fsm;

    CServerInfo *pProxyServer = NULL;

    INTERNET_HANDLE_OBJECT * pInternet;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

    AUTO_PROXY_ASYNC_MSG proxyInfoQuery;
    URL_COMPONENTS urlComponents;

    LPSTR lpszObject = NULL;
    DWORD dwcbObject = 0;


    // once we're woken up, we own the obj stored in our FSM.
    INET_ASSERT(fsm.m_fOwnsProxyInfoQueryObj); 

    //
    // Get the Obj Pointers we care about
    //

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)GetParent();

    INET_ASSERT(pConnect != NULL);
    INET_ASSERT(pConnect->IsValid(TypeHttpConnectHandle) == ERROR_SUCCESS);

    pInternet = (INTERNET_HANDLE_OBJECT *)pConnect->GetParent();

    INET_ASSERT(pInternet != NULL);
    INET_ASSERT(pInternet->IsValid(TypeInternetHandle) == ERROR_SUCCESS);

    //
    // Clear our handle state in regards to proxy settings
    //

    SetSocksProxyName(NULL, NULL, NULL);
    SetRequestUsingProxy(FALSE);

    //
    // Parse URL, I have to do this every time,
    //  and even worse we need to do this before our caching code
    //  gets hit, but we can't move it because the quit code
    //  depends on the parsed URL.  In the future we should cache this!!
    //

    error = BuildProxyMessage(
                Fsm,
                &proxyInfoQuery,
                &urlComponents
                );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // No proxy installed on this object, bail out
    //

    if ( ! pInternet->IsProxy() && ! IsOverrideProxyMode() )
    {
        INET_ASSERT(fsm.m_pProxyInfoQuery == NULL);
        fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        goto quit;
    }

    //
    // If we're in the callback, just retrieve the results,
    //  from the orginal blocking call to proxy code
    //

    if ( fsm.m_pProxyInfoQuery )
    {            
        fCallback = TRUE;

        if ( ! (fsm.m_pProxyInfoQuery)->IsBackroundDetectionPending()) {
            (fsm.m_pProxyInfoQuery)->SetQueryOnCallback(TRUE);
        }

        error = QueryProxySettings(Fsm, pInternet, &urlComponents);
        if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy())              
        {
            goto quit;
        }
    }
    else if ((fsm.m_pProxyInfoQuery = &proxyInfoQuery) &&  // !!! put our local in the FSM
              CheckForCachedProxySettings(fsm.m_pProxyInfoQuery, &pProxyServer) 
                != ERROR_SUCCESS )
    {
        //
        // If there is nothing cached, then we'll need
        //  to do the actual proxy request to the proxy code
        // 

        //fsm.m_pProxyInfoQuery = &proxyInfoQuery; // !!! put our local in the FSM
        proxyInfoQuery.SetBlockUntilCompletetion(TRUE);
        proxyInfoQuery.SetShowIndication(TRUE);        

        if (!IsTunnel() && !IsOverrideProxyMode())
        {
            error = QueryProxySettings(Fsm, pInternet, &urlComponents);
            if ( error != ERROR_SUCCESS || !(fsm.m_pProxyInfoQuery)->IsUseProxy()) {
                goto quit;
            }
        }
        else // fall-back
        {
            //
            // Get the current proxy information,
            //   if we're in an nested SSL tunnell
            //

            GetProxyName(&(fsm.m_pProxyInfoQuery)->_lpszProxyHostName,
                         &(fsm.m_pProxyInfoQuery)->_dwProxyHostNameLength,
                         &(fsm.m_pProxyInfoQuery)->_nProxyHostPort
                         );

            (fsm.m_pProxyInfoQuery)->_tProxyScheme = INTERNET_SCHEME_DEFAULT;
            (fsm.m_pProxyInfoQuery)->SetUseProxy(TRUE);
        }
    }

    //
    // Need to figure out whether we're actually talking
    //  to a Server via proxy.  In this case we need to
    //  special case some logic in the Send so we create
    //  a sub-request to the proxy-server, and then do this
    //  request to the main SSL server.
    //

    if ( (fsm.m_pProxyInfoQuery)->IsUseProxy() ) 
    {
        error = ProcessProxySettings(
                    Fsm,
                    pConnect,
                    &urlComponents,
                    &lpszObject,
                    &dwcbObject
                    );    
    }
    else
    {
        // Ensure this is false in case of very slim chance of
        // redirect from internet https to intranet http
        SetIsTalkingToSecureServerViaProxy(FALSE);
    }

quit:

    //
    // If we didn't fail with pending,
    //  go ahead and process the request headers
    //
   
    if ( error != ERROR_IO_PENDING)
    {
        if ( error == ERROR_SUCCESS ) {
            error = UpdateRequestInfo(Fsm, lpszObject, dwcbObject, &urlComponents, &pProxyServer);
        }

        //
        // Now, Unlink the proxyinfomsg struc from the fsm,
        //   if its our stack based variable that we used as a temp
        //

        if ( fsm.m_fOwnsProxyInfoQueryObj &&
             fsm.m_pProxyInfoQuery &&
             ! (fsm.m_pProxyInfoQuery)->IsAlloced() )
        {
            fsm.m_pProxyInfoQuery = NULL;
        }

    }

    //
    // Don't leak objects, Give a hoot, don't pollute !!
    //

    if ( pProxyServer != NULL )
    {
        ::ReleaseServerInfo(pProxyServer);
    }

    if ( lpszObject != NULL &&
         lpszObject != urlComponents.lpszUrlPath)
    {
        FREE_MEMORY(lpszObject);
    }

    PERF_LEAVE(UpdateProxyInfo);

    DEBUG_LEAVE(error);

    return error;
}


BOOL
HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader(
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Determine if Connection: Close added to request headers

Arguments:

    dwIndex - id of Connection header to search for (Connection or
              Proxy-Connection)

Return Value:

    BOOL
        TRUE    - header found

        FALSE   - header not found

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::FindConnCloseRequestHeader",
                 "%d [%s]",
                 dwIndex,
                 InternetMapHttpOption(dwIndex)
                 ));

    BOOL bFound = FALSE;

    if (CheckedConnCloseRequest()) {
        bFound = IsConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION);
    } else {

        LPSTR ptr;
        DWORD len;
        DWORD index = 0;

        while (FastQueryRequestHeader(dwIndex,
                                      (LPVOID *)&ptr,
                                      &len,
                                      index) == ERROR_SUCCESS) {
            if ((len == CLOSE_LEN) && (strnicmp(ptr, CLOSE_SZ, len) == 0)) {
                bFound = TRUE;
                break;
            }
            index++;
        }
        SetCheckedConnCloseRequest(dwIndex == HTTP_QUERY_PROXY_CONNECTION, bFound);
    }

    DEBUG_LEAVE(bFound);

    return bFound;
}

#define ACCEPT_ENCODING_URLMON_STRING "gzip, deflate"
#define ACCEPT_ENCODING_URLMON_STRLEN (sizeof(ACCEPT_ENCODING_URLMON_STRING)-1)

VOID
HTTP_REQUEST_HANDLE_OBJECT::RemoveGzipDeflateEncHeader(
    VOID
    )

/*++

Routine Description:
    Removes gzip, deflate encoding headers passed in from urlmon, if we finally 
    use Http 1.0 for the request.
Arguments:
    None
Return Value:
    None

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HTTP_REQUEST_HANDLE_OBJECT::RemoveGzipDeflateEncHeader",
                 NULL
                 ));

    LPSTR ptr;
    DWORD len;
    DWORD index = 0;

    while (FastQueryRequestHeader((DWORD)HTTP_QUERY_ACCEPT_ENCODING,
                                  (LPVOID *)&ptr,
                                  &len,
                                  index) == ERROR_SUCCESS) {
        if ((len == ACCEPT_ENCODING_URLMON_STRLEN) &&
            (strnicmp(ptr, ACCEPT_ENCODING_URLMON_STRING, len) == 0)) {
            ReplaceRequestHeader((DWORD)HTTP_QUERY_ACCEPT_ENCODING, NULL, 0,index,0);
        }
        index++;
    }

    DEBUG_LEAVE(0);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\write.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    write.cxx

Abstract:

    This file contains the implementation of the HttpWriteData API.

    Contents:
        HttpWriteData
        HTTP_REQUEST_HANDLE_OBJECT::WriteData

Author:

    Arthur Bierer (arthurbi) 07-Apr-1997

Revision History:



--*/

#include <wininetp.h>
#include "httpp.h"



//
// functions
//

#if !defined(THREAD_POOL)


INTERNETAPI_(BOOL) HttpWriteData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    Writes a block of data for an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetWriteFile() which
        globally validates parameters for all Internet data write
        functions

         2. That we the caller has called HttpBeginSendRequest but not HttpEndSendRequest

Arguments:

    hRequest                - an open HTTP request handle returned by
                  HttpOpenRequest()

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

Return Value:

    TRUE - The data was written successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/

{

    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HttpWriteData",
                "%#x, %#x, %d, %#x",
                hRequest,
                lpBuffer,
                dwNumberOfBytesToWrite,
                lpdwNumberOfBytesWritten
                ));

    DWORD error;

    //
    // find path from internet handle
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hRequest,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // need to set these for both local and remote paths, in case we're in async
    // mode
    //

    DWORD context;

    error = RGetContext(hRequest, &context);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //InternetSetObjectHandle(hRequest);
    //InternetSetContext(context);

    //
    // Cast it to the object that we know. We are going to do call
    // into the method to do the work.
    //

    HTTP_REQUEST_HANDLE_OBJECT *pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequest;

    if (!IS_VALID_HTTP_STATE(pRequest, WRITE, TRUE)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
    } else {
        // This request needs a special CR-LF added to the end at EndRequest
        pRequest->SetAddCRLF(TRUE);
        error = pRequest->WriteData(lpBuffer,
                                   dwNumberOfBytesToWrite,
                                   lpdwNumberOfBytesWritten
                                   );
    }



quit:


    DEBUG_LEAVE(error);

    return error;
}




DWORD
HTTP_REQUEST_HANDLE_OBJECT::WriteData(
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    HTTP_REQUEST_HANDLE_OBJECT WriteData method

    Writes data from users buffer. Writes the data to the currently open
    socket.

Arguments:

    lpBuffer                - pointer to users buffer

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written


Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "HTTP_REQUEST_HANDLE_OBJECT::WriteData",
                "%#x, %d, %#x",
                lpBuffer,
                dwNumberOfBytesToWrite,
                lpdwNumberOfBytesWritten
                ));

    DWORD error = ERROR_SUCCESS;

    if ( _Socket == NULL )
    {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    error = _Socket->Send(lpBuffer, dwNumberOfBytesToWrite, SF_INDICATE);
    if (error == ERROR_SUCCESS)
    {
        *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
    }
    else
    {
        goto quit;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


#else




DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    )

/*++

Routine Description:

    Writes a block of data for an outstanding HTTP request

    Assumes: 1. this function can only be called from InternetWriteFile() which
        globally validates parameters for all Internet data write
        functions

         2. That we the caller has called HttpBeginSendRequest but not HttpEndSendRequest

Arguments:

    hRequest                - an open HTTP request handle returned by
                  HttpOpenRequest()

    lpBuffer                - pointer to the buffer to receive the data

    dwNumberOfBytesToWrite      - number of bytes to write from user's buffer

    lpdwNumberOfBytesWritten    - number of bytes actually written

    dwSocketFlags           - controlling socket operation


Return Value:

    TRUE - The data was written successfully. lpdwNumberOfBytesRead points to the
    number of BYTEs actually read. This value will be set to zero
    when the transfer has completed.

    FALSE - The operation failed. Error status is available by calling
    GetLastError().

--*/


{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HttpWriteData",
                 "%#x, %#x, %d, %#x, %#x",
                 hRequest,
                 lpBuffer,
                 dwNumberOfBytesToWrite,
                 lpdwNumberOfBytesWritten,
                 dwSocketFlags
                 ));

    DWORD error = DoFsm(new CFsm_HttpWriteData(lpBuffer,
                                              dwNumberOfBytesToWrite,
                                              lpdwNumberOfBytesWritten,
                                              dwSocketFlags,
                                              (HTTP_REQUEST_HANDLE_OBJECT *)hRequest
                                              ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_HttpWriteData::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_HttpWriteData::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    HTTP_REQUEST_HANDLE_OBJECT * pRequest;
    CFsm_HttpWriteData * stateMachine = (CFsm_HttpWriteData *)Fsm;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)Fsm->GetContext();
    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:

        pRequest->SetAddCRLF(TRUE);

        //
        // Fall through
        //

    case FSM_STATE_CONTINUE:
        error = pRequest->HttpWriteData_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm(
    IN CFsm_HttpWriteData * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "HTTP_REQUEST_HANDLE_OBJECT::HttpWriteData_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_HttpWriteData & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {
        if (!IsValidHttpState(WRITE)) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_STATE;
            goto quit;
        }

        error = _Socket->Send(
                           fsm.m_lpBuffer,
                           fsm.m_dwNumberOfBytesToWrite,
                           SF_INDICATE
                           );

    }

    if (error == ERROR_SUCCESS)
    {
        *fsm.m_lpdwNumberOfBytesWritten = fsm.m_dwNumberOfBytesToWrite;
    }


quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


#endif // defined(THREAD_POOL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\apdetect.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apdetect.h

Abstract:

    Some extra stuff to allow registry configuration for
    detect type modes..
    
Author:

    Josh Cohen (joshco)		10-Oct-1998

Environment:

    User Mode - Win32

Revision History:

    Josh Cohen (joshco)		07-Oct-1998
       Created

these are defines for autodetection flags
this allows an admin or tester to easily verify
correct operation of the detection system.
You can control which detection methods are used,
wether or not to force netbios name resolution,
or wether or not to cache the flag.

The default is DNS_A, DHCP, cacheable

--*/


#ifndef PROXY_AUTO_DETECT_TYPE_SAFETY_H
	#define PROXY_AUTO_DETECT_TYPE_SAFETY_H

	#define PROXY_AUTO_DETECT_TYPE_DEFAULT 	67
	// do dns_a, dhcp and cache this flag.
	
	#define PROXY_AUTO_DETECT_TYPE_DHCP 	1
	#define PROXY_AUTO_DETECT_TYPE_DNS_A    2
	#define PROXY_AUTO_DETECT_TYPE_DNS_SRV	4
	#define PROXY_AUTO_DETECT_TYPE_DNS_TXT  8
	#define PROXY_AUTO_DETECT_TYPE_SLP		16

// assume no real domain, netbios
	#define PROXY_AUTO_DETECT_TYPE_NO_DOMAIN 32

// just read this once for performance..
	#define PROXY_AUTO_DETECT_CACHE_ME		64
	
/* this is the default path that we append when
	creating a CURL from a DNS resolve.
	http://wpad/wpad
*/

	#define PROXY_AUTO_DETECT_PATH "wpad.dat"
	
	DWORD
	WINAPI
  		GetProxyDetectType( VOID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\autodial.h ===
#ifndef _AUTODIAL_H_
#define _AUTODIAL_H_

#include <regstr.h>
#include <inetreg.h>
#include <windowsx.h>
#include <rasdlg.h>

// initialization for autodial
void InitAutodialModule(BOOL fGlobalDataNeeded);
void ExitAutodialModule(void);
void ResetAutodialModule(void);
void SetAutodialEnable(BOOL);

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// connection mutex name
#define CONNECTION_MUTEX TEXT("WininetConnectionMutex")
// proxy registry mutex name, used to serialze access to proxy settings
#define PROXY_REG_MUTEX TEXT("WininetProxyRegistryMutex")

// typedefs for function pointers for Internet wizard functions
typedef VOID    (WINAPI * INETPERFORMSECURITYCHECK) (HWND,LPBOOL);

#define SMALLBUFLEN     48 // convenient size for small buffers

// callback prototype
extern "C"
VOID
InternetAutodialCallback(
    IN DWORD dwOpCode,
    IN LPCVOID lpParam
    );

// opcode ordinals for dwOpCode parameter in hook
#define WINSOCK_CALLBACK_CONNECT        1
#define WINSOCK_CALLBACK_GETHOSTBYADDR  2
#define WINSOCK_CALLBACK_GETHOSTBYNAME  3
#define WINSOCK_CALLBACK_LISTEN         4
#define WINSOCK_CALLBACK_RECVFROM       5
#define WINSOCK_CALLBACK_SENDTO         6

// maximum length of local host name
#define MAX_LOCAL_HOST          255

// max length of exported autodial handler function
#define MAX_AUTODIAL_FCNNAME    48

INT_PTR CALLBACK OnlineDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
    LPARAM lParam);
BOOL EnsureRasLoaded(void);
INT_PTR CALLBACK GoOfflinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConnectDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern const CHAR szRegPathRemoteAccess[];
extern const CHAR szRegPathInternetSettings[];
extern const CHAR szRegValEnableAutodial[];
extern const CHAR szRegValInternetEntry[];

extern HANDLE g_hAutodialMutex;
extern HANDLE g_hProxyRegMutex;

extern BOOL g_fGetHostByNameNULLFails;

//
// Formerly dialmsg.h
//

#define WM_DIALMON_FIRST        (WM_USER + 100)

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY     (WM_DIALMON_FIRST + 0)

// message sent to dial monitor app window when user changes timeout through
// UI, indicating that timeout value or status has changed
#define WM_REFRESH_SETTINGS     (WM_DIALMON_FIRST + 1)

// message sent to dial monitor app window to set the name of the connectoid
// to monitor and eventually disconnect.  lParam should be an LPSTR that
// points to the name of the connectoid.
#define WM_SET_CONNECTOID_NAME  (WM_DIALMON_FIRST + 2)

// message sent to dial monitor app window when app exits
#define WM_IEXPLORER_EXITING    (WM_DIALMON_FIRST + 3)

// yanked from ras.h becuase we include it as ver4.0 and this is ver4.1.
#include <pshpack4.h>
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};
#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define RASCM_UserName          0x00000001
#define RASCM_Password          0x00000002
#define RASCM_Domain            0x00000004

#include <poppack.h>

// Types for ras functions
typedef DWORD (WINAPI* _RASHANGUP) (HRASCONN);

typedef DWORD (WINAPI* _RASDIALA) (LPRASDIALEXTENSIONS, LPSTR, LPRASDIALPARAMSA,  DWORD, LPVOID, LPHRASCONN);
typedef DWORD (WINAPI* _RASENUMENTRIESA) (LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYDIALPARAMSA) (LPCSTR, LPRASDIALPARAMSA, LPBOOL);
typedef DWORD (WINAPI* _RASSETENTRYDIALPARAMSA) (LPCSTR, LPRASDIALPARAMSA, BOOL);
typedef DWORD (WINAPI* _RASEDITPHONEBOOKENTRYA) (HWND, LPSTR, LPSTR);
typedef DWORD (WINAPI* _RASCREATEPHONEBOOKENTRYA) (HWND, LPSTR);
typedef DWORD (WINAPI* _RASGETERRORSTRINGA) (UINT, LPSTR, DWORD);
typedef DWORD (WINAPI* _RASGETCONNECTSTATUSA) (HRASCONN, LPRASCONNSTATUSA);
typedef DWORD (WINAPI* _RASENUMCONNECTIONSA) (LPRASCONNA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYPROPERTIESA) ( LPSTR, LPSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );
typedef DWORD (WINAPI* _RASDIALDLGA) (LPSTR, LPSTR, LPSTR, LPRASDIALDLG);

typedef DWORD (WINAPI* _RASDIALW) (LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW,  DWORD, LPVOID, LPHRASCONN);
typedef DWORD (WINAPI* _RASENUMENTRIESW) (LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYDIALPARAMSW) (LPCWSTR, LPRASDIALPARAMSW, LPBOOL);
typedef DWORD (WINAPI* _RASSETENTRYDIALPARAMSW) (LPCWSTR, LPRASDIALPARAMSW, BOOL);
typedef DWORD (WINAPI* _RASEDITPHONEBOOKENTRYW) (HWND, LPWSTR, LPWSTR);
typedef DWORD (WINAPI* _RASCREATEPHONEBOOKENTRYW) (HWND, LPWSTR);
typedef DWORD (WINAPI* _RASGETERRORSTRINGW) (UINT, LPWSTR, DWORD);
typedef DWORD (WINAPI* _RASGETCONNECTSTATUSW) (HRASCONN, LPRASCONNSTATUSW);
typedef DWORD (WINAPI* _RASENUMCONNECTIONSW) (LPRASCONNW, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASGETENTRYPROPERTIESW) ( LPWSTR, LPWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );
typedef DWORD (WINAPI* _RASDIALDLGW) (LPWSTR, LPWSTR, LPWSTR, LPRASDIALDLG);
typedef DWORD (WINAPI* _RASGETAUTODIALADDRESSA) (LPCSTR, LPDWORD, LPRASAUTODIALENTRYA, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* _RASSETAUTODIALADDRESSA) (LPCSTR, DWORD, LPRASAUTODIALENTRYA, DWORD, DWORD);
typedef DWORD (WINAPI* _RASGETCREDENTIALSW) (LPCWSTR, LPCWSTR, LPRASCREDENTIALSW);
typedef DWORD (WINAPI* _RASSETCREDENTIALSW) (LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL);

typedef DWORD (WINAPI* _RASINTERNETDIAL) (HWND, LPSTR, DWORD, DWORD_PTR *, DWORD);
typedef DWORD (WINAPI* _RASINTERNETHANGUP) (DWORD_PTR, DWORD);
typedef DWORD (WINAPI* _RASINTERNETAUTODIAL) (DWORD, HWND);
typedef DWORD (WINAPI* _RASINTERNETAUTODIALHANG) (DWORD);
typedef DWORD (WINAPI* _RASINTERNETCONNSTATE) (LPDWORD, LPSTR, DWORD, DWORD);
typedef DWORD (WINAPI* _RNAGETDEFAULTAUTODIAL) (LPSTR, DWORD, LPDWORD);
typedef DWORD (WINAPI* _RNASETDEFAULTAUTODIAL) (LPSTR, DWORD);

// Ras ansi prototypes
DWORD _RasDialA(LPRASDIALEXTENSIONS, LPSTR, LPRASDIALPARAMSA,  DWORD, LPVOID, LPHRASCONN);
DWORD _RasEnumEntriesA(LPTSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD, LPDWORD);
DWORD _RasGetEntryDialParamsA(LPCSTR, LPRASDIALPARAMSA, LPBOOL);
DWORD _RasSetEntryDialParamsA(LPCSTR, LPRASDIALPARAMSA, BOOL);
DWORD _RasEditPhonebookEntryA(HWND, LPSTR, LPSTR);
DWORD _RasCreatePhonebookEntryA(HWND, LPSTR);
DWORD _RasGetErrorStringA(UINT, LPSTR, DWORD);
DWORD _RasGetConnectStatusA(HRASCONN, LPRASCONNSTATUSA);
DWORD _RasEnumConnectionsA(LPRASCONNA, LPDWORD, LPDWORD);
DWORD _RasGetEntryPropertiesA(LPSTR, LPSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

// Ras wide prototypes
DWORD _RasDialW(LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW,  DWORD, LPVOID, LPHRASCONN);
DWORD _RasEnumEntriesW(LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);
DWORD _RasGetEntryDialParamsW(LPCWSTR, LPRASDIALPARAMSW, LPBOOL);
DWORD _RasSetEntryDialParamsW(LPCWSTR, LPRASDIALPARAMSW, BOOL);
DWORD _RasEditPhonebookEntryW(HWND, LPWSTR, LPWSTR);
DWORD _RasCreatePhonebookEntryW(HWND, LPWSTR);
DWORD _RasGetErrorStringW(UINT, LPWSTR, DWORD);
DWORD _RasGetConnectStatusW(HRASCONN, LPRASCONNSTATUSW);
DWORD _RasEnumConnectionsW(LPRASCONNW, LPDWORD, LPDWORD);
DWORD _RasGetEntryPropertiesW(LPWSTR, LPWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
DWORD _RasGetCredentialsW(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW);
DWORD _RasSetCredentialsW(LPCWSTR, LPCWSTR, LPRASCREDENTIALSW, BOOL);

DWORD _RasHangUp(HRASCONN);


// how many ras connections do we care about?
#define MAX_CONNECTION          4

#define CI_SAVE_PASSWORD        0x01
#define CI_DIAL_UNATTENDED      0x02
#define CI_AUTO_CONNECT         0x04
#define CI_SHOW_OFFLINE         0x08
#define CI_SHOW_DETAILS         0x10

// Types of network coverage settable from the ui
#define CO_INTERNET             1
#define CO_INTRANET             2

// definition to call RestartDialog in shell32
typedef int (* _RESTARTDIALOG) (HWND, LPCTSTR, DWORD);

// dialstate - passed to DialAndShowProgress
typedef struct _dialstate {
    DWORD       dwResult;       // final result
    DWORD       dwTry;          // number of dial attempts
    DWORD       dwTryCurrent;   // current attempt
    DWORD       dwWait;         // time to wait between them
    DWORD       dwWaitCurrent;  // current time
    HRASCONN    hConn;          // ras connection
    UINT_PTR    uTimerId;       // timer for redial
    HANDLE      hEvent;         // event when dialing is complete
    DWORD       dwFlags;
    RASDIALPARAMSW params;
} DIALSTATE;

BOOL
GetRedialParameters(
    IN LPWSTR pszConn,
    OUT LPDWORD pdwDialAttempts,
    OUT LPDWORD pdwDialInterval
    );

#define DEFAULT_DIAL_ATTEMPTS 10
#define DEFAULT_DIAL_INTERVAL 5

// When dealing with custom dial handler, it will inform us of disconnections.
// We keep an internal state
#define STATE_NONE          0
#define STATE_CONNECTED     1
#define STATE_DISCONNECTED  2

// info relevant to a custom dial handler
typedef struct _autodial {
    BOOL    fConfigured;
    BOOL    fEnabled;
    BOOL    fHasEntry;
    BOOL    fUnattended;
    BOOL    fSecurity;
    BOOL    fForceDial;
    WCHAR   pszEntryName[RAS_MaxEntryName + 1];
} AUTODIAL;

typedef struct __cdhinfo {
    DWORD   dwHandlerFlags;
    WCHAR   pszDllName[MAX_PATH];
    WCHAR   pszFcnName[MAX_PATH];
    BOOL    fHasHandler;
} CDHINFO;

// dummy connection handle used to mean custom dial handler
#define CDH_HCONN   DWORD_PTR(-3)

#define SAFE_RELEASE(a)            \
                if(a)              \
                {                  \
                    a->Release();  \
                    a = NULL;      \
                }

// List of properties supported by CDialEngine
typedef enum {
    PropInvalid,
    PropUserName,
    PropPassword,
    PropDomain,
    PropSavePassword,
    PropPhoneNumber,
    PropRedialCount,
    PropRedialInterval,
    PropLastError,
    PropResolvedPhone
} DIALPROP;

typedef struct _PropMap {
    LPWSTR      pwzProperty;
    DIALPROP    Prop;
} PROPMAP;

//
// Class definitions for default implementations
//
class CDialEngine : IDialEngine
{
private:
    ULONG               m_cRef;
    IDialEventSink *    m_pdes;
    RASDIALPARAMSW      m_rdp;
    RASCREDENTIALSW     m_rcred;
    RASCONNSTATE        m_rcs;
    HRASCONN            m_hConn;
    HWND                m_hwnd;
    BOOL                m_fPassword;
    BOOL                m_fSavePassword;
    BOOL                m_fCurrentlyDialing;
    BOOL                m_fCancelled;
    UINT                m_uRasMsg;
    DWORD               m_dwTryCurrent;
    DWORD               m_dwTryTotal;
    DWORD               m_dwWaitCurrent;
    DWORD               m_dwWaitTotal;
    DWORD               m_dwError;
    UINT_PTR            m_uTimerId;

public:
    CDialEngine();
    ~CDialEngine();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDialEngine members
    STDMETHODIMP         Initialize(LPCWSTR pwzConnectoid, IDialEventSink *pIDES);
    STDMETHODIMP         GetProperty(LPCWSTR pwzProperty, LPWSTR pwzValue, DWORD dwBufSize);
    STDMETHODIMP         SetProperty(LPCWSTR pwzProperty, LPCWSTR pwzValue);
    STDMETHODIMP         Dial();
    STDMETHODIMP         HangUp();
    STDMETHODIMP         GetConnectedState(DWORD *pdwState);
    STDMETHODIMP         GetConnectHandle(DWORD_PTR *pdwHandle);

    // other members
    VOID                 OnRasEvent(RASCONNSTATE rcs, DWORD dwError);
    VOID                 OnTimer();
    static LONG_PTR CALLBACK
                         EngineWndProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    DWORD                MapRCS(RASCONNSTATE rcs);
    VOID                 UpdateRasState();
    STDMETHODIMP         StartConnection();
    STDMETHODIMP         CleanConnection();
    VOID                 EndOfOperation();
    DIALPROP             PropertyToOrdinal(LPCWSTR pwzProperty);
    BOOL                 ResolvePhoneNumber(LPWSTR pwzBuffer, DWORD dwLen);
};

class CDialUI : IDialEventSink
{
private:
    typedef enum tagSTATE
    {
        UISTATE_Interactive,
        UISTATE_Dialing,
        UISTATE_Unattended
    } UISTATE;

    ULONG               m_cRef;
    IDialEngine *       m_pEng;
    IDialBranding *     m_pdb;
    HWND                m_hwndParent;
    HWND                m_hwnd;         // dialog box
    DWORD               m_dwError;      // final dialing result
    DWORD               m_dwFlags;
    UISTATE             m_State;
    BOOL                m_fOfflineSemantics;
    BOOL                m_fSavePassword;
    BOOL                m_fAutoConnect;
    BOOL                m_fPasswordChanged;
    DIALSTATE *         m_pDial;
    BOOL                m_fCDH;
    BOOL                m_fDialedCDH;
    CDHINFO             m_cdh;

public:
    CDialUI(HWND hwndParent);
    ~CDialUI();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDialEventSink members
    STDMETHODIMP         OnEvent(DWORD dwEvent, DWORD dwStatus);

    // other members
    static INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    VOID                 OnInitDialog();
    VOID                 OnConnect();
    VOID                 OnCancel();
    VOID                 OnSelChange();
    DWORD                StartDial(DIALSTATE *pDial, DWORD dwFlags);
    VOID                 EnumerateConnectoids();
    VOID                 SaveProps();
    VOID                 GetProps();
    VOID                 FixUIComponents();

    BOOL DialedCDH(VOID)
    {
        return m_fDialedCDH;
    }
};



// CDH prototypes
BOOL
IsCDH(
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh
    );

BOOL
CallCDH(
    IN HWND hwndParent,
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh,
    IN DWORD dwOperation,
    OUT LPDWORD lpdwResult
    );

BOOL
IsAutodialEnabled(
    OUT BOOL    *pfForceDial,
    IN AUTODIAL *pConfig
    );

BOOL
FixProxySettingsForCurrentConnection(
    IN BOOL fForceUpdate
    );

VOID
GetConnKeyA(
    IN LPSTR pszConn,
    IN LPSTR pszKey,
    IN int iLen
    );

VOID
GetConnKeyW(
    IN LPWSTR pszConn,
    IN LPWSTR pszKey,
    IN int iLen
    );

BOOL
InternetAutodialIfNotLocalHost(
    IN LPSTR OPTIONAL pszURL,
    IN LPSTR OPTIONAL pszHostName
    );

BOOL
DialIfWin2KCDH(
    LPWSTR              pszEntry,
    HWND                hwndParent,
    BOOL                fHideParent,
    DWORD               *lpdwResult,
    DWORD_PTR           *lpdwConnection
    );

BOOL
InitCommCtrl(
    VOID
    );

VOID
ExitCommCtrl(
    VOID
    );

DWORD
GetAutodialMode(
    );

DWORD
SetAutodialMode(
    IN DWORD dwMode
    );

DWORD
GetAutodialConnection(
    CHAR    *pszBuffer,
    DWORD   dwBufferLength
    );

DWORD
SetAutodialConnection(
    CHAR    *pszConnection
    );

#endif // _AUTODIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\http\hashgen\hashgen.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hashgen.cpp

Abstract:

    Table Generator for hhead.cxx, which contains all known HTTP headers for wininet project.
        This is also the location where all known HTTP headers must be added.

Author:

    Arthur Bierer (arthurbi) 12-Jan-1998

Revision History:

--*/

//
// Instructions for adding new HTTP header:
// 1. Update wininet.w and rebuild wininet.h with new HTTP_QUERY_ code
// 2. Add/Edit header to this file/program, hashgen.cpp with the 
//     new header string (see Items[] array below)
// 3. Compile new hashgen.exe, Execute with -o, write down a good seed
//      note that this may take all night to find a good seed which
//      give a nice smaller table size. (note this can be skipped if
//      you just need a quick table for dev purposes) 
// 4. Re-Execute hashgen.exe with -b# set with your seed to generate
//     hhead.cxx
// 5. Transfer new hhead.cxx file to wininet\http
// 6. Update const defines MAX_HEADER_HASH_SIZE and HEADER_HASH_SEED
//     from new hhead.cxx to wininet\http\headers.h
// 7. Transfer and checkin hashgen.cpp, wininet.w, headers,h, hhead.cxx
//     in their appropriate directories.
//


//
// Includes...
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <wininet.h>

//
// macros
//

#define IS_ARG(c)   ((c) == '-')
#define DIM(x)	(sizeof(x) / sizeof(x[0]))

#define ENUMDEF(x, y) ,x, #x, #y
#define OUTPUT_CODE_FILE "hhead.cxx" 
#define MAX_SIZE_HASHARRAY_TO_ATTEMPT 600
#define UNKNOWN_HASH_ENTRY 0 // character to put in array when when its not valid

//
// Items - This is the array that must be edited for Wininet to process new 
//  HTTP headers
//
//  Things to keep in mind before you add to this array
//  1. Headers are Alphatized for convience sake
//  2. All NULL entries MUST be at the end of the array
//  3. All HTTP_QUERY_* codes in wininet.h MUST have an entry even if they are not strings
//  4. Entries are as follows: 
//      header string, HTTP_QUERY_* code in wininet.h, flags used in wininet\http\query.cxx
//  5. All entries must be in lowercase.
//


struct Item
{
    char  *ptok;
    DWORD id;
    char  *pidName;
    char  *pFlagsName;
} Items[] = 
{
{ "Accept"              ENUMDEF(HTTP_QUERY_ACCEPT, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Charset"      ENUMDEF(HTTP_QUERY_ACCEPT_CHARSET, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Encoding"     ENUMDEF(HTTP_QUERY_ACCEPT_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Language"     ENUMDEF(HTTP_QUERY_ACCEPT_LANGUAGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Accept-Ranges"       ENUMDEF(HTTP_QUERY_ACCEPT_RANGES, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Age"                 ENUMDEF(HTTP_QUERY_AGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Allow"               ENUMDEF(HTTP_QUERY_ALLOW, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Authorization"       ENUMDEF(HTTP_QUERY_AUTHORIZATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Cache-Control"       ENUMDEF(HTTP_QUERY_CACHE_CONTROL, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Connection"          ENUMDEF(HTTP_QUERY_CONNECTION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Base"        ENUMDEF(HTTP_QUERY_CONTENT_BASE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Description" ENUMDEF(HTTP_QUERY_CONTENT_DESCRIPTION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Disposition" ENUMDEF(HTTP_QUERY_CONTENT_DISPOSITION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Encoding"    ENUMDEF(HTTP_QUERY_CONTENT_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Id"          ENUMDEF(HTTP_QUERY_CONTENT_ID, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Language"    ENUMDEF(HTTP_QUERY_CONTENT_LANGUAGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Length"      ENUMDEF(HTTP_QUERY_CONTENT_LENGTH, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_NUMBER)) },
{ "Content-Location"    ENUMDEF(HTTP_QUERY_CONTENT_LOCATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Md5"         ENUMDEF(HTTP_QUERY_CONTENT_MD5, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Range"       ENUMDEF(HTTP_QUERY_CONTENT_RANGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Transfer-Encoding" ENUMDEF(HTTP_QUERY_CONTENT_TRANSFER_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Content-Type"        ENUMDEF(HTTP_QUERY_CONTENT_TYPE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },                    
{ "Cookie"              ENUMDEF(HTTP_QUERY_COOKIE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Cost"                ENUMDEF(HTTP_QUERY_COST, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Date"                ENUMDEF(HTTP_QUERY_DATE, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Derived-From"        ENUMDEF(HTTP_QUERY_DERIVED_FROM, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Etag"                ENUMDEF(HTTP_QUERY_ETAG, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Expect"              ENUMDEF(HTTP_QUERY_EXPECT, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Expires"             ENUMDEF(HTTP_QUERY_EXPIRES, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Forwarded"           ENUMDEF(HTTP_QUERY_FORWARDED, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "From"                ENUMDEF(HTTP_QUERY_FROM, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Host"                ENUMDEF(HTTP_QUERY_HOST, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-Modified-Since"   ENUMDEF(HTTP_QUERY_IF_MODIFIED_SINCE, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "If-Match"            ENUMDEF(HTTP_QUERY_IF_MATCH, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-None-Match"       ENUMDEF(HTTP_QUERY_IF_NONE_MATCH, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-Range"            ENUMDEF(HTTP_QUERY_IF_RANGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "If-Unmodified-Since" ENUMDEF(HTTP_QUERY_IF_UNMODIFIED_SINCE, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Last-Modified"       ENUMDEF(HTTP_QUERY_LAST_MODIFIED, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Link"                ENUMDEF(HTTP_QUERY_LINK, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Location"            ENUMDEF(HTTP_QUERY_LOCATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Mime-Version"        ENUMDEF(HTTP_QUERY_MIME_VERSION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Max-Forwards"        ENUMDEF(HTTP_QUERY_MAX_FORWARDS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Message-id"          ENUMDEF(HTTP_QUERY_MESSAGE_ID, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Ms-Echo-Request"     ENUMDEF(HTTP_QUERY_ECHO_REQUEST, 0) },
{ "Ms-Echo-Reply"       ENUMDEF(HTTP_QUERY_ECHO_REPLY, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Orig-Uri"            ENUMDEF(HTTP_QUERY_ORIG_URI, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Pragma"              ENUMDEF(HTTP_QUERY_PRAGMA, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Authenticate"  ENUMDEF(HTTP_QUERY_PROXY_AUTHENTICATE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Authorization" ENUMDEF(HTTP_QUERY_PROXY_AUTHORIZATION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Connection"    ENUMDEF(HTTP_QUERY_PROXY_CONNECTION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Proxy-Support"       ENUMDEF(HTTP_QUERY_PROXY_SUPPORT, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Public"              ENUMDEF(HTTP_QUERY_PUBLIC, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Range"               ENUMDEF(HTTP_QUERY_RANGE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Referer"             ENUMDEF(HTTP_QUERY_REFERER, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Refresh"             ENUMDEF(HTTP_QUERY_REFRESH, 0) },
{ "Retry-After"         ENUMDEF(HTTP_QUERY_RETRY_AFTER, (HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_FLAG_SYSTEMTIME)) },
{ "Server"              ENUMDEF(HTTP_QUERY_SERVER, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Set-Cookie"          ENUMDEF(HTTP_QUERY_SET_COOKIE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Title"               ENUMDEF(HTTP_QUERY_TITLE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Transfer-Encoding"   ENUMDEF(HTTP_QUERY_TRANSFER_ENCODING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Unless-Modified-Since" ENUMDEF(HTTP_QUERY_UNLESS_MODIFIED_SINCE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Upgrade"             ENUMDEF(HTTP_QUERY_UPGRADE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Uri"                 ENUMDEF(HTTP_QUERY_URI, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "User-Agent"          ENUMDEF(HTTP_QUERY_USER_AGENT, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Vary"                ENUMDEF(HTTP_QUERY_VARY, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Via"                 ENUMDEF(HTTP_QUERY_VIA, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Warning"             ENUMDEF(HTTP_QUERY_WARNING, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "WWW-Authenticate"    ENUMDEF(HTTP_QUERY_WWW_AUTHENTICATE, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "Authentication-Info" ENUMDEF(HTTP_QUERY_AUTHENTICATION_INFO, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "PassportURLs"        ENUMDEF(HTTP_QUERY_PASSPORT_URLS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{ "PassportConfig"      ENUMDEF(HTTP_QUERY_PASSPORT_CONFIG, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
// NULL strs must be in end of array
{  NULL                 ENUMDEF(HTTP_QUERY_VERSION, HTTP_QUERY_FLAG_REQUEST_HEADERS) },         
{  NULL                 ENUMDEF(HTTP_QUERY_STATUS_CODE, HTTP_QUERY_FLAG_NUMBER) },
{  NULL                 ENUMDEF(HTTP_QUERY_STATUS_TEXT, 0) },
{  NULL                 ENUMDEF(HTTP_QUERY_RAW_HEADERS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_RAW_HEADERS_CRLF, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_REQUEST_METHOD, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_ECHO_HEADERS, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
{  NULL                 ENUMDEF(HTTP_QUERY_ECHO_HEADERS_CRLF, HTTP_QUERY_FLAG_REQUEST_HEADERS) },
};


//
// Declarations of common strings used in creating output "C" file
//

char szFileHeader[] = 
{"/*++\n\n"
 "Copyright (c) 1997 Microsoft Corporation\n\n"
 "Module Name:\n\n"
 "    "
 OUTPUT_CODE_FILE
 "\n\n"
 "Abstract:\n\n"
 "    This file contains autogenerated table values of a perfect hash function\n"
 "    DO NOT, DO NOT EDIT THIS FILE, TO ADD HEADERS SEE hashgen.cpp\n"
 "    Contents:\n"
 "      GlobalKnownHeaders\n"
 "      GlobalHeaderHashs\n\n"
 "Author:\n\n"
 "   Arthur Bierer (arthurbi) 19-Dec-1997 (AND) my code generator[hashgen.exe]\n\n"
 "Revision History:\n\n"
 "--*/\n\n\n" };


char szComment1[] = {
"//\n"
"// GlobalHeaderHashs - array of precalculated hashes on case-sensetive set of known headers.\n"
"// This array must be used with the same hash function used to generate it.\n"
"// Note, all entries in this array are biased (++'ed) by 1 from HTTP_QUERY_ manifests in wininet.h.\n"
"//   0-ed entries indicate error values\n"
"//\n\n" };

char szComment2[] = {
"//\n"
"// GlobalKnownHeaders - array of HTTP request and response headers that we understand.\n"
"// This array must be in the same order as the HTTP_QUERY_ manifests in WININET.H\n"
"//\n\n" 
"#define HEADER_ENTRY(String, Flags, HashVal) String, sizeof(String) - 1, Flags, HashVal\n\n" };

char szDef1[] = {
"#ifdef HEADER_HASH_SEED\n"
"#if (HEADER_HASH_SEED != %u)\n"
"#error HEADER_HASH_SEED has not been updated in the header file, please copy this number to the header\n"
"#endif\n"
"#else\n"
"#define HEADER_HASH_SEED %u\n"
"#endif\n\n" };

char szDef2[] = {
"#ifdef MAX_HEADER_HASH_SIZE\n"
"#if (MAX_HEADER_HASH_SIZE != %u)\n"
"#error MAX_HEADER_HASH_SIZE has not been updated in the header file, please copy this number to the header\n"
"#endif\n"
"#else\n"
"#define MAX_HEADER_HASH_SIZE %u\n"
"#endif\n\n" };

char szDef3[] = {
"#ifdef HTTP_QUERY_MAX\n"
"#if (HTTP_QUERY_MAX != %u)\n"
"#error HTTP_QUERY_MAX is not the same as the value used in wininet.h, this indicates mismatched headers, see hashgen.cpp\n"
"#endif\n"
"#endif\n\n" };


char szIncludes[] = {
"#include <wininetp.h>\n"
"#include \"httpp.h\"\n\n" };


//
// Hash - function used to create table, 
//   THIS FUNCTION MUST BE THE SAME AS THE ONE USED in WININET
//

DWORD Hash(char *pszName, DWORD j, DWORD seed)
{
	DWORD hash = seed;

	while (*pszName)
	{
		hash += (hash << 5) + *pszName++;
	}
    return (j==0) ? hash : hash % j;
}

//
// CompareItems - a util function for qsort-ing by ID for table creation
//   in the output file
//

int __cdecl CompareItems (const void *elem1, const void *elem2 ) 
{
    const struct Item *pItem1, *pItem2;

    pItem1 = (struct Item *) elem1;
    pItem2 = (struct Item *) elem2;

    if ( pItem1->id < pItem2->id )    
    {
        return -1;
    }
    else if ( pItem1->id > pItem2->id )
    {
        return 1;
    }

    return 0;
}


//
// usage() - print out our usage instructions to command line
//

void usage() {
    fprintf(stderr,
           "\n"
           "usage: hashgen [-m[#]] [-b[#]] [-t[#]] [-o] [-p<path>] [-f<filename>]\n"
           "\n"
           "where: -m[#] = Max hash table size to test with, default = 600\n"
           "       -b[#] = Starting hash seed, default = 0\n"
           "       -t[#] = Threshold of table size to halt search at, default = 200\n"
           "       -o    = Enable optimal exhaustive search mode (can take 24+ hrs)\n"
           "       -p    = Path used for output generation\n"
           "       -f    = Output filename, \"hhead.cxx\" is assumed\n"
           "\n"
           "Instructions for adding new HTTP header:\n"
           "\t1. Update wininet.w and rebuild wininet.h with new HTTP_QUERY_ code\n"
           "\t2. Add/Edit this file/program, hashgen.cpp with the new header string\n"
           "\t3. Compile/Execute new hashgen.exe with -o, write down a good seed\n"
           "\t4. Re-Execute hashgen.exe with -b# set with your seed to generate\n"
           "\t    hhead.cxx\n"
           "\t5. Transfer new hhead.cxx file to wininet\\http\n"
           "\t6. Update const defines MAX_HEADER_HASH_SIZE and HEADER_HASH_SEED\n"
           "\t    from new hhead.cxx to wininet\\http\\headers.h\n"
           "\t7. Transfer and checkin hashgen.cpp, wininet.w, headers,h, hhead.cxx\n"
           );
    exit(1);
}

//
// MakeMeLower - Makes a lower case string using a static 255 byte array
//

LPSTR
MakeMeLower(
    IN LPSTR lpszMixedCaseStr
    )
{
    static CHAR szLowerCased[256];

    if ( lstrlen(lpszMixedCaseStr) > 255 ) 
    {
        fprintf(stderr, "Internal error: an HTTP header is too long\n\n");
        return szLowerCased;
    }

    lstrcpy( szLowerCased, lpszMixedCaseStr );
    CharLower(szLowerCased);

    return szLowerCased;
}
     


//
// main - where it all gets done !!!!
//

void
__cdecl
//_CRTAPI1
main(
    int   argc,
    char * argv[]
    )
{
    DWORD nMax = MAX_SIZE_HASHARRAY_TO_ATTEMPT;
    DWORD dwBestNumber = 0, dwBestSeed = 0 /*349160*/ /*4458*//*202521*/;
    DWORD dwSearchThreshold = 200;
    BOOL bFoundOne = FALSE;
    BOOL bFindOptimalSeed = FALSE;
    LPSTR szPath = "";
    LPSTR szFileName = OUTPUT_CODE_FILE;
	DWORD i, j, k;
    DWORD dwValidStringsInArray = 0;
	DWORD *pHash = new DWORD[nMax];

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            case '?':
                usage();
                break;

            case 'm':
                nMax = (DWORD)atoi(++*argv);
                break;

            case 'b':
                dwBestSeed = (DWORD)atoi(++*argv);
                break;

            case 't':
                dwSearchThreshold = (DWORD)atoi(++*argv);
                break;
            
            case 'p':
                szPath = ++*argv;
                break;

            case 'f':
                szFileName = ++*argv;
                break;

            case 'o':
                bFindOptimalSeed = TRUE;
                break;
            default:
                fprintf(stderr,"error: unrecognized command line flag: '%c'\n", **argv);
                usage();
            }         
        } else {
            fprintf(stderr,"error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    //
    // Let the Work begin...
    //

    dwBestNumber = nMax;

    if (bFindOptimalSeed)
    {
        printf("This will take a while, perhaps all night(consider a Ctrl-C)...\n");
    }

    for (i = 0; i < DIM(Items); i++ )
    {
        if ( Items[i].ptok )
            dwValidStringsInArray++;
    }

	for (i = dwBestSeed; i < (~0); i++)
	{
		//printf("%d,\n", i);
		for (j = dwValidStringsInArray; j < nMax; j++)
		{
            memset (pHash, UNKNOWN_HASH_ENTRY, nMax * sizeof(DWORD));
			for (k = 0; k < dwValidStringsInArray; k++)
			{
				DWORD HashNow = Hash(MakeMeLower(Items[k].ptok), j, i) /*% j(table_size), i(seed)*/;

                if ( HashNow > j )
                {
                    fprintf(stderr, "Error, Error - exceed table size, bad hash alg\n");
                    break;
                }

                if (pHash[HashNow] != UNKNOWN_HASH_ENTRY)
                    break;
                else
                {
                    pHash[HashNow] = Items[k].id+1;
                }
			}

            if ( k == dwValidStringsInArray )
            {
                //printf( "Found one with hash_size=%d, seed=%u...\n", j,i );
                bFoundOne = TRUE;
                goto found_one;
            }
		}
found_one:

        if ( bFoundOne )
        {
            if (j < dwBestNumber)
            {
                dwBestNumber = j;
                dwBestSeed = i;

                printf("Found a New One, hashtable_size=%d, seed=%u...\n", j ,i);
                
                if ( !bFindOptimalSeed && dwBestNumber < dwSearchThreshold )
                {
                    goto stop_search;
                }
            }

            bFoundOne = FALSE;
        }
	}

stop_search:

    if ( dwBestNumber < nMax && dwBestNumber == j)
    {
        printf("Generating %s which contains, perfect hash for known headers\n", OUTPUT_CODE_FILE);

	    FILE *f;
        CHAR szOutputFileAndPath[512];

        strcpy(szOutputFileAndPath, szPath);
        strcat(szOutputFileAndPath, szFileName);

        f = fopen(szOutputFileAndPath, "w");

        if ( f == NULL )
        {
            fprintf(stderr, "Err: Could Not Open %s for writing\n", szOutputFileAndPath);
            exit(-1);
        }

        fprintf(f, szFileHeader); // print header

        fprintf(f, szIncludes); // includes

        fprintf(f, szDef1, dwBestSeed, dwBestSeed);
        fprintf(f, szDef2, dwBestNumber, dwBestNumber);
        fprintf(f, szDef3, HTTP_QUERY_MAX);

        fprintf(f, szComment1); // print comment
         
        if ( dwBestNumber < 255 )
        {       
            fprintf(f, "const BYTE GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {\n");
        }
        else
        {
            fprintf(f, "const WORD GlobalHeaderHashs[MAX_HEADER_HASH_SIZE] = {\n");
        }
        
        DWORD col = 0;

        //
        // spit our Nicely calculated perfect hash table..         
        //

        for ( i = 0; i < dwBestNumber; i++ )
        {
            col++;
            if ( col == 1 )
            {
                fprintf(f, "    ");
            }

            fprintf(f, "%3u, ", (BYTE) pHash[i]);    

            if ( col == 6 )
            {
                fprintf(f, "\n");
                col = 0;
            }
        }

        fprintf(f, "\n   };\n\n");


        //
        // Now spit our KnownHeader array...
        //
            
        qsort(Items, DIM(Items), sizeof(Items[0]), CompareItems);

        fprintf(f, szComment2);

        if ( DIM(Items) != (HTTP_QUERY_MAX+1) )
        {
            fprintf(stderr, "ERROR, HTTP_QUERY_MAX the wrong size,( different wininet.h's? )\n");
            return;
        }

        fprintf(f, "const struct KnownHeaderType GlobalKnownHeaders[HTTP_QUERY_MAX+1] = {\n");

	    for (j = 0; j < DIM(Items); j++)
	    {
            char szBuffer[256];
            DWORD dwHash = 0;

            sprintf(szBuffer, "    HEADER_ENTRY(\"%s\",", (Items[j].ptok ? Items[j].ptok : "\0"));
            if ( Items[j].ptok )
            {
                dwHash = Hash(MakeMeLower(Items[j].ptok), 0, dwBestSeed);
            }

            fprintf(f, "%-45s  %s, 0x%X),\n", szBuffer, Items[j].pFlagsName, dwHash);                                                 
	    }

        fprintf(f,"    };\n\n\n");

    	fclose(f);
    }
    else
    {
        fprintf(stderr, "Error, could not find an ideal number\n");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\cookie.h ===
// cookie.h - header for external cookie funcs code.


BOOL OpenTheCookieJar();
void CloseTheCookieJar();
VOID PurgeCookieJarOfStaleCookies();


#define COOKIE_SECURE   INTERNET_COOKIE_IS_SECURE
#define COOKIE_SESSION  INTERNET_COOKIE_IS_SESSION      // never saved to disk
#define COOKIE_RESTRICT INTERNET_COOKIE_IS_RESTRICTED   // only used for 1st party context

#define COOKIE_P3PPOLICY    0x10000         // the cookie has associated P3P policy

#define COOKIE_NOUI     4

BOOL InternetGetCookieEx( LPCSTR pchURL, LPCSTR pchCookieName, LPSTR pchCookieData OPTIONAL,
                          LPDWORD pcchCookieData, DWORD dwFlags, LPVOID lpReserved);


BOOL InternalInternetSetCookie( LPCSTR  pchURL, LPCSTR  pchCookieName, LPCSTR  pchCookieData,
                          DWORD dwFlags, LPVOID lpReserved);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\cookexp.h ===
//  Exports the cookies of the current user to a text file in a format
//parseable by Netscape Navigator.

//  -- declarations moved to wininet.w
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\dummy.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dummy.cxx

Abstract:

    Dummy file for build so we can generate the precompiled header for the
    internet project

    Contents:

Author:

     Richard L Firth (rfirth) 03-Feb-1995

Revision History:

    03-Feb-1995
        Created

--*/

#include "wininetp.h"

void __cdecl main(int, char**);

void __cdecl main(int argc, char** argv) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\cookimp.h ===
#ifndef _COOKIMP_H_
#define _COOKIMP_H_

#define NS_NAVI3        	0x00030000
#define NS_NAVI4        	0x00040000
#define NS_NAVI5        	0x00050000  //  NS_NAVI5 is a guess

BOOL FindNetscapeCookieFile( IN DWORD dwNSVer, OUT LPTSTR szFilename, /* in-out */ LPDWORD lpnBufSize);

//  functions to identify active NS version

BOOL GetActiveNetscapeVersion( LPDWORD lpVersion);
BOOL GetExecuteableFromExtension( IN LPCTSTR szExtension, OUT LPTSTR szFilepath, 
                            LPDWORD pcFilenameSize, OUT LPTSTR* pFilenameSubstring);


//  writes version of Netscape to registry for future reference

BOOL SetNetscapeImportVersion( IN DWORD dwNSVersion);
BOOL GetNetscapeImportVersion( OUT DWORD* pNSVersion);

//  dumps the contents of a file out to memory

BOOL ReadFileToBuffer( IN LPCTSTR szFilename, LPBYTE* ppBuf, LPDWORD lpcbBufSize);


/*
Current behavior for cookie importing:
on first entry:
	Check if netscape is default browser, identify version and save in registry.

on every entry:
	check if version is saved in registry, destructively merge
*/


/*
Something of a justification for behavior:
  There are a couple ways to determine the version of cookie file to be imported from.  For all
intents ane purposes, what is being determined is whether the version to import from is less than
or greater than/equal to four.
  The version of the the executeable associated with htm files is what we use.  If the executeable
associated with htm files is not netscape, then presumeably the user isn't using netscape and we
don't want the cookies anyhow.
  An alternative was to use the last installed version of netscape installed which is indicated
in the CurrentVersion\\AppPaths reg key.  This key gets ripped away though, if the user uninstalls
one version and uses an older version.  Also, we can't expect the user to be using the last
installed version of netscape.

  Once IE is installed and ran, it may be associated with htm files while we still want to import
cookies from the once active version of netscape.  Because of this the version of netscape found
to be used during DllInstall(true,HKLM is) saved in the registry.  This works on 
uninstallation/reinstallation since we can always expect DllInstall(true,HKLM) to be ran again
before reentry into any DllInstall(true,HKCU) where the cookies are imported for each user.
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\handle.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Header file for common\handle.cxx

Author:

    Richard L Firth (rfirth) 01-Nov-1994

Revision History:

    01-Nov-1994 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
HandleInitialize(
    VOID
    );

VOID
HandleTerminate(
    VOID
    );

DWORD
AllocateHandle(
    IN LPVOID Address,
    OUT LPHINTERNET lpHandle
    );

DWORD
FreeHandle(
    IN HINTERNET Handle
    );

DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    );

DWORD
DereferenceObject(
    IN LPVOID lpObject
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\crtsubst.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1996 rajeevd
        Created
--*/
#include "iert.h"
#ifndef unix
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
extern "C" void RtlMoveMemory (void *, const void *, unsigned long);
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef wcsdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
#undef StrChr


#define free(ptr)         FREE_MEMORY((HLOCAL) ptr)
#define malloc(size)      ((PVOID)ALLOCATE_MEMORY(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define wcsdup(s)         NewStringW(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD_PTR)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define _strstr           StrStr
#define strstr            StrStr
#define StrChr            PrivateStrChr
#define _strchr           StrChr
#define strchr            StrChr
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNIC
#define _strnicmp         StrCmpNIC
#define strncmp           StrCmpNC
#define _strncmp          StrCmpNC

#undef itoa
#undef ultoa

//#define itoa(val,s,n)     _itoa(val,s,n)
//#define ultoa(val,s,n)    _ultoa(val,s,n)

 
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\debugmem.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.h

Abstract:

    Header for debugmem.cxx

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Revision History:

    02-Feb-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

//
// USE_PRIVATE_HEAP_IN_RETAIL - by default we use the process heap in the retail
// build. Alternative is to use a private (wininet) heap (which we do in the
// debug version if required)
//

#if !defined(USE_PRIVATE_HEAP_IN_RETAIL)
#define USE_PRIVATE_HEAP_IN_RETAIL  0
#endif

//
// prototypes
//

VOID
InternetDebugMemInitialize(
    VOID
    );

VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    );

HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    );

SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    );

BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    );

BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    );

//
// macros
//

#if defined(USE_DEBUG_MEMORY)

#define ALLOCATOR(Flags, Size) \
    InternetDebugAllocMem(Flags, Size, __FILE__, __LINE__)

#define DEALLOCATOR(hLocal) \
    InternetDebugFreeMem(hLocal, __FILE__, __LINE__)

#define REALLOCATOR(hLocal, Size, Flags) \
    InternetDebugReAllocMem(hLocal, Size, Flags, __FILE__, __LINE__)

#define MEMORYSIZER(hLocal) \
    InternetDebugSizeMem(hLocal, __FILE__, __LINE__)

#define INITIALIZE_DEBUG_MEMORY() \
    InternetDebugMemInitialize()

#define TERMINATE_DEBUG_MEMORY(bReport) \
    InternetDebugMemTerminate(bReport)

#define CHECK_MEMORY_FREED(bReport) \
    InternetDebugCheckMemFreed(bReport)

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    InternetDebugMemReport(bTermSym, bCloseFile)

#else   // retail version

#if USE_PRIVATE_HEAP_IN_RETAIL

#error no other memory allocation schemes defined

#else

#ifndef WININET_UNIX_PRVATE_ALLOCATOR
#define ALLOCATOR(Flags, Size) \
    LocalAlloc(Flags, Size)

#define DEALLOCATOR(hLocal) \
    LocalFree(hLocal)

#define REALLOCATOR(hLocal, Size, Flags) \
    LocalReAlloc(hLocal, Size, Flags)

#define MEMORYSIZER(hLocal) \
    LocalSize(hLocal)
#else

HLOCAL IEUnixLocalAlloc(UINT wFlags, UINT wBytes);
HLOCAL IEUnixLocalReAlloc(HLOCAL hMemory, UINT wBytes, UINT wFlags);
HLOCAL IEUnixLocalFree(HLOCAL hMem);
UINT IEUnixLocalSize(HLOCAL hMem);
LPVOID IEUnixLocalLock(HLOCAL hMem);

#define ALLOCATOR(Flags, Size)\
    IEUnixLocalAlloc(Flags, Size)
#define DEALLOCATOR(hLocal)\
    IEUnixLocalFree(hLocal)
#define REALLOCATOR(hLocal, Size, Flags)\
    IEUnixLocalReAlloc(hLocal, Size, Flags)
#define MEMORYSIZER(hLocal) \
    IEUnixLocalSize(hLocal)
#endif /* unix */
#endif // USE_PRIVATE_HEAP_IN_RETAIL

#define INITIALIZE_DEBUG_MEMORY() \
    /* NOTHING */

#define TERMINATE_DEBUG_MEMORY(bReport) \
    /* NOTHING */

#define CHECK_MEMORY_FREED(bReport) \
    /* NOTHING */

#define REPORT_DEBUG_MEMORY(bTermSym, bCloseFile) \
    /* NOTHING */

#endif // defined(USE_DEBUG_MEMORY)

#define ALLOCATE_ZERO_MEMORY(Size) \
    ALLOCATE_MEMORY(LPTR, (Size))

#define ALLOCATE_FIXED_MEMORY(Size) \
    ALLOCATE_MEMORY(LMEM_FIXED, (Size))

#define ALLOCATE_MEMORY(Flags, Size) \
    ALLOCATOR((UINT)(Flags), (UINT)(Size))

#define FREE_ZERO_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_FIXED_MEMORY(hLocal) \
    FREE_MEMORY((HLOCAL)(hLocal))

#define FREE_MEMORY(hLocal) \
    DEALLOCATOR((HLOCAL)(hLocal))

#define REALLOCATE_MEMORY(hLocal, Size, Flags) \
    REALLOCATOR((HLOCAL)(hLocal), (UINT)(Size), (UINT)(Flags))

#define MEMORY_SIZE(hLocal) \
    MEMORYSIZER((HLOCAL)(hLocal))

#if defined(__cplusplus)
}
#endif

//
// Wininet no longer uses moveable memory
//

#define LOCK_MEMORY(p)          (LPSTR)(p)
#define UNLOCK_MEMORY(p)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\gfrinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    gfrinit.h

Abstract:

    Prototypes for gfrinit.c

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

VOID
GopherInitialize(
    VOID
    );

VOID
GopherTerminate(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\ftpinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ftpinit.h

Abstract:

    Prototypes for ftpinit.c

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

VOID
FtpInitialize(
    VOID
    );

VOID
FtpTerminate(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\globals.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    External definitions for data in dll\globals.c

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

// Side-By-Side (loading different urlmon )
#ifdef _SBS_
#define URLMON_DLL "sbsurlmk.dll"
#else
#define URLMON_DLL "urlmon.dll"
#endif // _SBS_

//
// macros
//

#define IsGlobalStateOnline() \
    (((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_ONLINE) \
        ? TRUE : FALSE)

#define IsGlobalStateOffline() \
    (((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE) \
        ? TRUE : FALSE)

#define IsGlobalStateOfflineUser() \
    (((GlobalDllState \
        & (INTERNET_LINE_STATE_MASK | INTERNET_STATE_OFFLINE_USER)) \
        == (INTERNET_STATE_OFFLINE | INTERNET_STATE_OFFLINE_USER)) \
        ? TRUE : FALSE)

#define UPDATE_GLOBAL_PROXY_VERSION() \
    InterlockedIncrement((LPLONG)&GlobalProxyVersionCount)


#define COOKIES_WARN     0 // warn with a dlg if using cookies
#define COOKIES_ALLOW    1 // allow cookies without any warning
#define COOKIES_DENY     2 // disable cookies completely


#define INTERNET_MAX_WELL_KNOWN_PORT 1023
#define INTERNET_DEFAULT_FTP_PORT    21
#define INTERNET_DEFAULT_SMTP_PORT   25 
#define INTERNET_DEFAULT_POP3_PORT   110
#define INTERNET_DEFAULT_NNTP_PORT   119
#define INTERNET_DEFAULT_IMAP_PORT   143 


//
// external variables
//

extern HINSTANCE GlobalDllHandle;
#define GlobalResHandle     GlobalDllHandle  // change for plugable ui
extern DWORD GlobalPlatformType;
extern DWORD GlobalPlatformVersion5;
extern DWORD GlobalPlatformMillennium;
extern DWORD GlobalPlatformWhistler;

extern DWORD GlobalDllState;
extern BOOL GlobalDataInitialized;
extern BOOL GlobalTruncateFileName;

extern DWORD InternetMajorVersion;
extern DWORD InternetMinorVersion;
extern DWORD InternetBuildNumber;

extern DWORD GlobalConnectTimeout;
extern DWORD GlobalConnectRetries;
extern DWORD GlobalSendTimeout;
extern DWORD GlobalReceiveTimeout;
extern DWORD GlobalDataSendTimeout;
extern DWORD GlobalDataReceiveTimeout;
extern DWORD GlobalFromCacheTimeout;
extern DWORD GlobalFtpAcceptTimeout;
extern DWORD GlobalTransportPacketLength;
extern DWORD GlobalKeepAliveSocketTimeout;
extern DWORD GlobalSocketSendBufferLength;
extern DWORD GlobalSocketReceiveBufferLength;
extern DWORD GlobalMaxHttpRedirects;
extern DWORD GlobalMaxConnectionsPerServer;
extern DWORD GlobalMaxConnectionsPer1_0Server;
extern DWORD GlobalConnectionInactiveTimeout;
extern DWORD GlobalServerInfoTimeout;
extern const DWORD GlobalMaxSizeStatusLineResultText;
extern BOOL  GlobalHaveInternetOpened;

extern DWORD GlobalCacheMode;
#define CACHEMODE_NORMAL  0
#define CACHEMODE_REFRESH 1
#define CACHEMODE_BYPASS  2

extern BOOL InDllCleanup;
extern BOOL GlobalPleaseQuitWhatYouAreDoing;
extern BOOL GlobalDynaUnload;
extern BOOL GlobalUseSchannelDirectly;
extern BOOL GlobalDisableKeepAlive;
extern BOOL GlobalDisablePassport;
extern DWORD GlobalSecureProtocols;
extern BOOL GlobalEnableHttp1_1;
extern BOOL GlobalEnableProxyHttp1_1;
extern BOOL GlobalDisableReadRange;
extern BOOL GlobalIsProcessExplorer;
extern BOOL GlobalEnableFortezza;
extern BOOL GlobalEnableRevocation;
extern BOOL GlobalIsProcessNtService;
extern DWORD GlobalSslStateCount;
extern BOOL GlobalEnableGopher;

#if defined(SITARA)

extern BOOL GlobalEnableSitara;
extern BOOL GlobalHasSitaraModemConn;

#endif // SITARA

extern BOOL GlobalEnableUtf8Encoding;

extern BOOL GlobalBypassEditedEntry;
extern BOOL fDontUseDNSLoadBalancing;
extern BOOL GlobalDisableNT4RasCheck;

extern BOOL GlobalWarnOnPost;
extern BOOL GlobalWarnAlways;
extern BOOL GlobalWarnOnZoneCrossing;
extern BOOL GlobalWarnOnBadCertSending;
extern BOOL GlobalWarnOnBadCertRecving;
extern BOOL GlobalWarnOnPostRedirect;
extern BOOL GlobalAlwaysDrainOnRedirect;
extern BOOL GlobalBypassSSLNoCacheCheck;
extern BOOL GlobalWarnOnHTTPSToHTTPRedirect;

extern LONG GlobalInternetOpenHandleCount;
extern DWORD GlobalProxyVersionCount;
extern BOOL GlobalAutoProxyNeedsInit;
extern BOOL GlobalAutoProxyInInit;
extern BOOL GlobalAutoProxyCacheEnable;
extern BOOL GlobalDisplayScriptDownloadFailureUI;
extern BOOL GlobalUseLanSettings;
extern BOOL GlobalSendExtraCRLF;
extern BOOL GlobalBypassFtpTimeCheck;

extern BOOL GlobalSendUTF8ServerToProxy;
extern BOOL GlobalMBCSAPIforCrack;
extern BOOL GlobalUseUTF8ServerForNameRes;

extern BOOL g_bHibernating;
extern BOOL g_bDisableHibernation;
//extern BOOL GlobalAutoProxyInDeInit;

//extern DWORD GlobalServerInfoAllocCount;
//extern DWORD GlobalServerInfoDeAllocCount;

extern SERIALIZED_LIST GlobalObjectList;
extern SERIALIZED_LIST GlobalServerInfoList;

extern LONGLONG dwdwHttpDefaultExpiryDelta;
extern LONGLONG dwdwFtpDefaultExpiryDelta;
extern LONGLONG dwdwGopherDefaultExpiryDelta;
extern LONGLONG dwdwSessionStartTime;
extern LONGLONG dwdwSessionStartTimeDefaultDelta;

extern DWORD GlobalUrlCacheSyncMode;
extern DWORD GlobalDiskUsageLowerBound;
extern DWORD GlobalScavengeFileLifeTime;

extern BOOL  GlobalLeashLegacyCookies;

extern LPSTR vszMimeExclusionList, vszHeaderExclusionList;

extern LPSTR *lpvrgszMimeExclusionTable, *lpvrgszHeaderExclusionTable;

extern DWORD *lpvrgdwMimeExclusionTableOfSizes;

extern DWORD vdwMimeExclusionTableCount, vdwHeaderExclusionTableCount;


extern SECURITY_CACHE_LIST GlobalCertCache;

extern BOOL GlobalDisableSslCaching;
extern BOOL GlobalDisableNTLMPreAuth;

extern CRITICAL_SECTION AuthenticationCritSec;
extern CRITICAL_SECTION GeneralInitCritSec;
extern CRITICAL_SECTION LockRequestFileCritSec;
extern CRITICAL_SECTION AutoProxyDllCritSec;
extern CRITICAL_SECTION ZoneMgrCritSec;
extern CRITICAL_SECTION MlangCritSec;

extern const char vszSyncMode[];

extern const char vszDisableSslCaching[];


// Default user agent string
// This will be used when no other information is available
extern const char gszDefaultUserAgent[];

// moved to proxysup.hxx
//extern PROXY_INFO GlobalProxyInfo;

extern BOOL vfPerUserCookies;

BOOL GetWininetUserName(VOID);
// BUGBUG: GetWininetUserName must be called before accessing vszCurrentUser.
// Instead, it should return the username ptr and the global not accessed.
extern char vszCurrentUser[];
extern DWORD vdwCurrentUserLen;

extern const char vszAllowCookies[];
extern const char vszPerUserCookies[];

extern INTERNET_VERSION_INFO InternetVersionInfo;
extern HTTP_VERSION_INFO HttpVersionInfo;
extern BOOL fCdromDialogActive;
extern DWORD g_dwCredPersistAvail;

extern CUserName GlobalUserName;

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

extern char gszAt[];
extern char gszBang[];
extern char gszCRLF[3];

//
// novell client32 (hack) "support"
//

extern BOOL GlobalRunningNovellClient32;
extern BOOL GlobalNonBlockingClient32;


// shfolder.dll hmod handle
extern HMODULE g_HMODSHFolder;

// shell32.dll hmod handle
extern HMODULE g_HMODShell32;



extern DWORD GlobalIdentity;
extern GUID GlobalIdentityGuid;
#ifdef WININET6
extern HKEY GlobalCacheHKey;
#endif

extern BOOL GlobalSuppressCookiesPolicy;


//
// Localization Structures
//

//
// This definition must be big enough to hold the largest set of localized
// strings.
//

#define LOCAL_STRINGS_MAX_BUFFER 4096

//
// *WARNING* - The order of elements in the following structure must match the
// order of elements in the uStringId array in the FetchLocalStrings routine in
// dll/Globals.cxx.
//

typedef struct {
    LPWSTR
        szEnterAuthInfo,
        szCertInfo,
        szStrengthHigh,
        szStrengthMedium,
        szStrengthLow,
        szCertSubject,
        szCertIssuer,
        szCertEffectiveDate,
        szCertExpirationDate,
        szCertProtocol,
        szCertUsage,
        szHttpsEncryptAlg,
        szHttpsHashAlg,
        szHttpsExchAlg,
        szCertComment,
        szCommentExpires,
        szCommentNotValid,
        szCommentBadCN,
        szCommentBadCA,
        szCommentBadSignature,
        szCommentRevoked,
        szCiphMsg,
        szHashMsg,
        szExchMsg,
        szFingerprint,
        szDomain,
        szRealm,
        szSite,
        szFirewall;

    WCHAR
        rgchBuffer[LOCAL_STRINGS_MAX_BUFFER];
} LOCAL_STRINGS, *PLOCAL_STRINGS;

typedef struct {
    LPSTR
        szEnterAuthInfo,
        szCertInfo,
        szStrengthHigh,
        szStrengthMedium,
        szStrengthLow,
        szCertSubject,
        szCertIssuer,
        szCertEffectiveDate,
        szCertExpirationDate,
        szCertProtocol,
        szCertUsage,
        szHttpsEncryptAlg,
        szHttpsHashAlg,
        szHttpsExchAlg,
        szCertComment,
        szCommentExpires,
        szCommentNotValid,
        szCommentBadCN,
        szCommentBadCA,
        szCommentBadSignature,
        szCommentRevoked,
        szCiphMsg,
        szHashMsg,
        szExchMsg,
        szFingerprint,
        szDomain,
        szRealm,
        szSite,
        szFirewall;

    CHAR
        rgchBuffer[LOCAL_STRINGS_MAX_BUFFER];
} LOCAL_STRINGSA, *PLOCAL_STRINGSA;

//
// prototypes
//


void SetUserOrPass (LPSTR lpszIn, BOOL fUser);
void TimeStampCreds(void); 
PSYSTEMTIME GetCredTimeStamp(void);
BOOL GetUserAndPass (LPSTR *pszUser, LPSTR *pszPass);

VOID
GlobalDllInitialize(
    VOID
    );

VOID
GlobalDllTerminate(
    VOID
    );

DWORD
GlobalDataInitialize(
    VOID
    );

VOID
GlobalDataTerminate(
    VOID
    );

BOOL
IsHttp1_1(
    VOID
    );

BOOL
IsOffline(
    VOID
    );

DWORD
SetOfflineUserState(
    IN DWORD dwState,
    IN BOOL bForce
    );

VOID
GlobalDataReadWarningUIFlags(
    VOID
    );

PLOCAL_STRINGS
FetchLocalStrings(
    VOID
    );

PLOCAL_STRINGSA
FetchLocalStringsA(
    VOID
    );
    
VOID
ChangeGlobalSettings(
    VOID
    );

VOID
RefreshOfflineFromRegistry(
    VOID
    );

VOID
PerformStartupProcessing(
    VOID
    );

DWORD
GetSitaraProtocol(
    VOID
    );


typedef HRESULT
(STDAPICALLTYPE * PFNINETMULTIBYTETOUNICODE)
(
    LPDWORD  lpdword,
    DWORD    dwSrcEncoding,
    LPCSTR   lpSrcStr,
    LPINT    lpnSrcSize,
    LPWSTR   lpDstStr,
    LPINT    lpDstStrSize
);

// Loads Mlang and returns a pointer to the MultiByte to Unicode converter.
// Could return NULL if mlang.dll couldn't be loaded for some reason. 
PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\httpinit.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    httpinit.h

Abstract:

    Prototypes for httpinit.c

Author:

    Richard L Firth (rfirth) 09-Jun-1995

Revision History:

    09-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
HttpInitialize(
    VOID
    );

BOOL
HttpTerminate(
    VOID
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\inetchar.h ===
#ifndef INETCHAR_H

#define INETCHAR_H

/* Copyright (c) 1998  Microsoft Corporation

Module Name:

    inetchar.h

Abstract:

    macros for converting between Unicode and MultiByte characters.

    Contents:
        REASSIGN_ALLOC
        REASSIGN_SIZE
        ALLOC_MB
        UNICODE_TO_ANSI
        MAYBE_COPY_ANSI
        
Author:

    Ahsan S. Kabir  

Revision History:

    18Nov97 akabir
        Created

*/

//

// ---- Macros to simplify recovering values from memory packets -------------

#define REASSIGN_ALLOC(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwAlloc;
    
#define REASSIGN_SIZE(mp,ps,dw) \
    ps = mp.psStr; \
    dw = mp.dwSize;


// -- (MAYBE_)ALLOC_MB ------------
// Macros to allocate enough memory for an ansi-equivalent string

#define ALLOC_MB(URLW,DWW,MPMP) { \
    MPMP.dwAlloc = ((DWW ? DWW : lstrlenW(URLW))+ 1)*sizeof(WCHAR); \
    MPMP.psStr = (LPSTR)ALLOC_BYTES(MPMP.dwAlloc*sizeof(CHAR)); }


// -- UNICODE_TO_ANSI -----
// Base case macro to convert from unicode to ansi
// We're subtracting 1 because we're converting the nullchar in dwAlloc.

#define UNICODE_TO_ANSI(pszW, mpA) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,NULL); \
        mpA.psStr[mpA.dwSize]= '\0';

#define UNICODE_TO_ANSI_CHECKED(pszW, mpA, pfNotSafe) \
    mpA.dwSize = \
        WideCharToMultiByte(CP_ACP,0,pszW,(mpA.dwAlloc/sizeof(*pszW))-1,mpA.psStr,mpA.dwAlloc,NULL,pfNotSafe); \
        mpA.psStr[mpA.dwSize]= '\0';


// -- (MAYBE_)COPY_ANSI ----
//  Given ansi source and widechar destination pointers, convert from the former to latter

#define COPY_ANSI(mp,pszW,dwW) { dwW = MultiByteToWideChar(CP_ACP, 0, mp.psStr, mp.dwSize+1, pszW, dwW) - 1; }


#define MAYBE_COPY_ANSI(mp,pszW,dwW) { if (pszW && mp.psStr) \
            { dwW = MultiByteToWideChar(CP_ACP, 0, mp.psStr, mp.dwSize+1, pszW, dwW) - 1; } }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\defaults.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    defaults.h

Abstract:

    Contains all default manifests for WININET

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

--*/

//
// default timeout values and retry counts
//

#define DEFAULT_CONNECT_TIMEOUT             ((LONG)(1 * 60 * 1000)) // 1 minute
#define DEFAULT_CONNECT_RETRIES             5
#ifndef unix
#define DEFAULT_SEND_TIMEOUT                ((LONG)(5 * 60 * 1000)) // 5 minutes
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)(60 * 60 * 1000)) // 60 minutes
#define DEFAULT_FTP_ACCEPT_TIMEOUT          ((LONG)(5 * 60 * 1000)) // 5 minutes
#else
#define DEFAULT_SEND_TIMEOUT                ((LONG)(1 * 60 * 1000)) // 1 minutes
#define DEFAULT_RECEIVE_TIMEOUT             ((LONG)(1 * 60 * 1000)) // 1 minutes
#define DEFAULT_FTP_ACCEPT_TIMEOUT          ((LONG)(1 * 60 * 1000)) // 1 minutes
#endif /* unix */
#define DEFAULT_KEEP_ALIVE_TIMEOUT          (1 * 60 * 1000)         // 1 minute
#define DEFAULT_FROM_CACHE_TIMEOUT          (5 * 1000)              // 5 seconds
#define DEFAULT_DNS_CACHE_ENTRIES           32
#define DEFAULT_DNS_CACHE_TIMEOUT           (30 * 60)               // 30 minutes
#define DEFAULT_MAX_HTTP_REDIRECTS          100

// JMH - BUGBUG  max connections raised for beta 2, should be reset in RC1 to 2
#define DEFAULT_MAX_CONNECTIONS_PER_SERVER  2                       // default HTTP 1.1
// #define DEFAULT_MAX_CONNECTIONS_PER_SERVER  4                       // default HTTP 1.1 raised for Beta 2 only

#define DEFAULT_MAX_CONS_PER_1_0_SERVER     4                       // default HTTP 1.0
#define DEFAULT_CONNECTION_LIMIT_TIMEOUT    (1 * 60 * 1000)         // 1 minute
#define DEFAULT_CONNECTION_INACTIVE_TIMEOUT (10 * 1000)             // 10 seconds
#define DEFAULT_SERVER_INFO_TIMEOUT         (2 * 60 * 1000)         // 2 minutes
#define DEFAULT_NETWORK_OFFLINE_TIMEOUT     (5 * 1000)              // 5 seconds
#define DEFAULT_DIAL_UP_OFFLINE_TIMEOUT     (20 * 1000)             // 20 seconds
#define DEFAULT_IDLE_TIMEOUT                1000                    // 1 second
#define DEFAULT_NETWORK_PING_RETRIES        1
#define DEFAULT_DIAL_UP_PING_RETRIES        4

//
// thread pool default constants
//

#define DEFAULT_MINIMUM_THREADS     0
#define DEFAULT_MAXIMUM_THREADS     4   // arbitrary
#define DEFAULT_INITIAL_THREADS     1
#define DEFAULT_THREAD_IDLE_TIMEOUT (2 * 60 * 1000) // 2 minutes
#define DEFAULT_WORK_QUEUE_LIMIT    8
#define DEFAULT_WORK_ITEM_PRIORITY  0

//
// async scheduler thread default constants
//

#define DEFAULT_WORKER_THREAD_TIMEOUT       (2 * 60 * 1000)        // 2 minutes
#define DEFAULT_MAXIMUM_QUEUE_DEPTH         2
#define DEFAULT_FIBER_STACK_SIZE            (16 K)
#define DEFAULT_CREATE_FIBER_ATTEMPTS       4

//
// default sizes
//

#define DEFAULT_RECEIVE_BUFFER_INCREMENT        (1 K)
#define DEFAULT_TRANSPORT_PACKET_LENGTH         (1 K)
#define DEFAULT_HTML_QUERY_BUFFER_LENGTH        (4 K)
#define DEFAULT_SOCKET_SEND_BUFFER_LENGTH       ((DWORD)-1)
#define DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH    ((DWORD)-1)
#define DEFAULT_SOCKET_QUERY_BUFFER_LENGTH      (8 K)

//
// default strings
//

#define DEFAULT_HTTP_REQUEST_VERB       "GET"
#define DEFAULT_EMAIL_NAME              "user@domain"
#define DEFAULT_URL_SCHEME_NAME         "http"

// default SSL protocols
#define DEFAULT_SECURE_PROTOCOLS        (SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\oldnames.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oldnames.h

Abstract:

    contains old names of cache structures, etc.

Author:

    Richard L Firth (rfirth) 09-May-1996

Revision History:

    09-May-1996 rfirth
        Created

--*/

#define CACHE_ENTRY_INFO            INTERNET_CACHE_ENTRY_INFO
#define LPCACHE_ENTRY_INFO          LPINTERNET_CACHE_ENTRY_INFO

#define CACHE_ENTRY_INFOA           INTERNET_CACHE_ENTRY_INFOA
#define LPCACHE_ENTRY_INFOA         LPINTERNET_CACHE_ENTRY_INFOA

#define CACHE_ENTRY_INFOW           INTERNET_CACHE_ENTRY_INFOW
#define LPCACHE_ENTRY_INFOW         LPINTERNET_CACHE_ENTRY_INFOW

#define CACHE_CONFIG_PATH_ENTRY     INTERNET_CACHE_CONFIG_PATH_ENTRY
#define LPCACHE_CONFIG_PATH_ENTRY   LPINTERNET_CACHE_CONFIG_PATH_ENTRY

#define CACHE_CONFIG_PATH_ENTRYA    INTERNET_CACHE_CONFIG_PATH_ENTRYA
#define LPCACHE_CONFIG_PATH_ENTRYA  LPINTERNET_CACHE_CONFIG_PATH_ENTRYA

#define CACHE_CONFIG_PATH_ENTRYW    INTERNET_CACHE_CONFIG_PATH_ENTRYW
#define LPCACHE_CONFIG_PATH_ENTRYW  LPINTERNET_CACHE_CONFIG_PATH_ENTRYW

#define CACHE_CONFIG_INFO           INTERNET_CACHE_CONFIG_INFO
#define LPCACHE_CONFIG_INFO         LPINTERNET_CACHE_CONFIG_INFO

#define CACHE_CONFIG_INFOA          INTERNET_CACHE_CONFIG_INFOA
#define LPCACHE_CONFIG_INFOA        LPINTERNET_CACHE_CONFIG_INFOA

#define CACHE_CONFIG_INFOW          INTERNET_CACHE_CONFIG_INFOW
#define LPCACHE_CONFIG_INFOW        LPINTERNET_CACHE_CONFIG_INFOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\httpfilt.h ===
#ifndef _HTTPFILT_
#define _HTTPFILT_

//#include <wininet.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SZFN_FILTEROPEN "HttpFilterOpen"

BOOL
WINAPI
HttpFilterOpen
(
    OUT LPVOID *lppvFilterContext,
    IN  LPCSTR szFilterName,
    IN  LPVOID lpReserved
);

typedef BOOL (WINAPI *PFN_FILTEROPEN)
   (LPVOID*, LPCSTR, LPVOID);

#define SZFN_FILTERCLOSE "HttpFilterClose"

BOOL
WINAPI
HttpFilterClose
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN     BOOL       fInShutdown        // TRUE if in DLL_PROCESS_DETACH
);

typedef BOOL (WINAPI *PFN_FILTERCLOSE)
   (LPVOID, BOOL);

// Per Transaction
// There are called one for every HTTP transaction that WinInet performs.

#define SZFN_FILTERBEGINNINGTRANSACTION "HttpFilterBeginningTransaction"

BOOL
WINAPI
HttpFilterBeginningTransaction
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERBEGINNINGTRANSACTION)
   (LPVOID, LPVOID*, HINTERNET, LPVOID);

//This is called when a transaction begins.  It gives the caller an oppurtunity
// to examine the request header and modify it.

#define SZFN_FILTERONRESPONSE "HttpFilterOnResponse"

BOOL
WINAPI
HttpFilterOnResponse
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERONRESPONSE)
   (LPVOID, LPVOID*, HINTERNET, LPVOID);

// This is called when the HTTP response returns and all of the HTTP headers are
// vailable to examine.

#define SZFN_FILTERONBLOCKINGOPS "HttpFilterOnBlockingOps"

BOOL
WINAPI
HttpFilterOnBlockingOps
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     HWND       hWnd,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERONBLOCKINGOPS)
        (LPVOID, LPVOID*, HINTERNET, HWND, LPVOID);

// Called in response to any of the above APIs returning FALSE and setting the
// GetLastError() value to INTERNET_ERROR_NEED_BLOCKING_UI.  The caller can put
// up UI in this situation.using hWnd as the parent Window.

#define SZFN_FILTERONTRANSACTIONCOMPLETE "HttpFilterOnTransactionComplete"

BOOL
WINAPI
HttpFilterOnTransactionComplete
(
    IN     LPVOID     lpvFilterContext,  // context created by HttpFilterOpen
    IN OUT LPVOID*    lppvTransactionContext,
    IN     HINTERNET  hRequest,
    IN     LPVOID     lpReserved
);

typedef BOOL (WINAPI *PFN_FILTERONTRANSACTIONCOMPLETE)
   (LPVOID, LPVOID*, HINTERNET, LPVOID);

// Called when I the transaction is complete.  This gives the caller an
// opportunity to clean up any transaction specific data.  Filter returns TRUE
// to indicate "I took no action - you should proceed", FALSE to indicate that
// the value from GetLastError() will have ben set.


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _HTTPFILT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\inetsspi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetsspi.h

Abstract:

    Contains all constant values and prototype decls used in inetsspi.cxx

Author:

    Sophia Chung (SophiaC)  02-Jan-1996

Revision History:

--*/

#ifndef _INETSSPI_H_
#define _INETSSPI_H_

#ifdef __cplusplus
extern "C" {
#endif


//
//  Encryption Capabilities
//

#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active
#define ENC_CAPS_SCHANNEL_CREDS    0x00000004       // Uses SCHANNEL Creds Struct

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//  PCT & SSL are both supported
//

#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | ENC_CAPS_PCT)
#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

#define INVALID_CRED_VALUE         {0xFFFFFFFF, 0xFFFFFFFF}

#define IS_CRED_INVALID(s) (((s)->dwUpper == 0xFFFFFFFF) && ((s)->dwLower == 0xFFFFFFFF))

typedef struct _SEC_PROVIDER
{
    CHAR            *pszName;          // security pkg name
    CredHandle      hCreds;           // credential handle
    DWORD           dwFlags;          // encryption capabilities
    BOOL            fEnabled;         // enable flag indicator
    DWORD           dwProtocolFlags;  // protocol flags that this provider supports.
    PCCERT_CONTEXT  pCertCtxt;        // cert context to use when getting default credentials.
} SEC_PROVIDER, *PSEC_PROVIDER;

//
//  Array of encryption providers
//

extern SEC_PROVIDER SecProviders[];

//
//  Global EncProvider flag
//

extern DWORD dwEncFlags;


//
//  Prototypes
//

BOOL
SecurityPkgInitialize(
    BOOL fForce = FALSE
    );

DWORD
EncryptData(
    IN CtxtHandle* hContext,
    IN LPVOID   lpBuffer,
    IN DWORD    dwInBufferLen,
    OUT LPVOID *lplpBuffer,
    OUT DWORD  *lpdwOutBufferLen,
    OUT DWORD  *lpdwInBufferBytesEncrypted
    );

DWORD
DecryptData(
    IN CtxtHandle* hContext,
    IN OUT DBLBUFFER* pdblbufBuffer,
    OUT DWORD     *lpdwBytesNeeded,
    OUT LPBYTE        lpOutBuffer,
    IN OUT DWORD  *lpdwOutBufferLeft,
    IN OUT DWORD  *lpdwOutBufferReceived,
    IN OUT DWORD  *lpdwOutBufferBytesRead
    );

VOID
TerminateSecConnection(
    IN CtxtHandle* hContext
    );


DWORD 
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo);


#ifdef __cplusplus
}
#endif

#endif //_INETSSPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\parsers.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.h

Abstract:

    Contains prototypes etc. for common\parsers.cxx

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD ConvertedNumber
    );

BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD ConvertedNumber
    );

BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT ConvertedNumber
    );

BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    );

LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\makefile.inc ===
!IFNDEF BASEDIR
BASEDIR=$(_NTDRIVE)$(_NTROOT)
!ENDIF

!IFNDEF SDKINC
SDKINC=$(BASEDIR)\public\sdk\inc
!ENDIF

$(O)\unsup.h: unsup.w
    wcshdr < unsup.w > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\iwinsock.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    iwinsock.hxx

Abstract:

    Contains prototypes for indirected sockets functions

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Moved into SOCKET_FUNC_ARRAY in order to supports Socks.

--*/

#if !defined(_IWINSOCK_)
#define _WINSOCK_

#if defined(__cplusplus)
extern "C" {
#endif

//
// includes
//

#include <winsock2.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

//
// prototypes
//

VOID
IwinsockInitialize(
    VOID
    );

VOID
IwinsockTerminate(
    VOID
    );

DWORD
LoadWinsock(
    VOID
    );

VOID
UnloadWinsock(
    VOID
    );

DWORD
SafeCloseSocket(
    IN SOCKET Socket
    );

//
// sockets functions
//

extern
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

extern
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    );

extern
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    );

extern
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    );

extern
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    );

extern
LPHOSTENT
(PASCAL FAR * _I_gethostbyaddr)(
    const char FAR * addr,
    int len,
    int type
    );

extern
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    const char FAR * lpHostName
    );

extern
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    );

extern
int
(PASCAL FAR * _I_getpeername)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    );

extern
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

extern
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    );

extern
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    );

extern
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    );

extern
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    );

extern
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    );

extern
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    );

extern
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    );

extern
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );

extern
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    );

extern
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    );

extern
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    );

extern
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    );

extern
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    );

extern
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    );

extern
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    );

//
// WSA functions
//

extern
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    );

extern
int
(PASCAL FAR * _I_WSACleanup)(
    void
    );

extern
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    );

extern
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    );

extern
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    );

//
// address family independent APIs
//

extern
int
(PASCAL FAR * _I_getaddrinfo)(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    );

extern
void
(PASCAL FAR * _I_freeaddrinfo)(
    IN struct addrinfo *ai
    );

extern
int
(PASCAL FAR * _I_getnameinfo)(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    );

//
// winsock2 name resolution API.
//

extern
int
(PASCAL FAR * _I_WSALookupServiceBeginW)(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    );


extern
int
(PASCAL FAR * _I_WSALookupServiceNextW)(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    );

extern
int
(PASCAL FAR * _I_WSALookupServiceEnd)(
    IN HANDLE  hLookup
    );


extern
int
(PASCAL FAR * _I_WSANSPIoctl)(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    );



//
// macros
//

#ifndef unix
#if defined(FD_ISSET)
#undef FD_ISSET
#endif

#define FD_ISSET(fd, set) _I___WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))
#endif /* unix */

#if INET_DEBUG

VOID
IWinsockCheckSockets(
    VOID
    );

#define CHECK_SOCKETS() IWinsockCheckSockets()

#else

#define CHECK_SOCKETS() /* NOTHING */

#endif

#if defined(__cplusplus)
}
#endif

#endif // _IWINSOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\macros.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    Contains all internal macros used in INTERNET.DLL

    Contents:
        ROUND_UP_?K
        ROUND_UP_DWORD
        NEW
        DEL
        NEW_STRING
        DEL_STRING
        NEW_MEMORY
        ZAP
        PRIVATE
        PUBLIC
        GLOBAL
        LOCAL
        DEBUG_FUNCTION
        SKIPWS

Author:

    Richard L Firth (rfirth) 16-Nov-1994

Revision History:

    16-Nov-1994 rfirth
        Created

--*/

//
// macros
//

//
// ROUND_UP_ - return (n) rounded up to the next (k) bytes
//

#define ROUND_UP_NK(n, k)   (((n) + ((_ ## k ## K) - 1)) & -(_ ## k ## K))
#define ROUND_UP_2K(n)      ROUND_UP_NK(n, 2)
#define ROUND_UP_4K(n)      ROUND_UP_NK(n, 4)
#define ROUND_UP_8K(n)      ROUND_UP_NK(n, 8)
#define ROUND_UP_16K(n)     ROUND_UP_NK(n, 16)

//
// ROUND_UP_DWORD - return (n) rounded up to the next 4 bytes
//

#define ROUND_UP_DWORD(value) \
    (((value) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))

//
// ARRAY_ELEMENTS - returns number of elements in array
//

#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof(array[0]))

//
// NEW - allocates a new 'object' of type (obj). Memory is allocated with
// LocalAlloc and initialized to zeroes
//

#define NEW(object) \
    (object FAR *)ALLOCATE_ZERO_MEMORY(sizeof(object))

//
// DEL - (should be DELETE, but that symbol is taken) - does opposite of NEW()
//

#define DEL(object) \
    FREE_MEMORY(object)

//
// NEW_STRING - performs NEW for a string
//

#define NEW_STRING(string) \
    NewString(string, 0)

//
// DEL_STRING - performs DEL for a string
//

#define DEL_STRING(string) \
    FREE_MEMORY(string)

//
// NEW_MEMORY - performs NEW for arbitrary sized memory
//

#define NEW_MEMORY(n, type) \
    (type FAR *)ALLOCATE_FIXED_MEMORY(n * sizeof(type))

//
// ZAP - zeroes an object (must be a variable, not a pointer)
//

#define ZAP(thing) \
    ZeroMemory((PVOID)&thing, sizeof(thing))

//
// STRTOUL - character-width independent (compile-time controlled) strtoul
//

#define STRTOUL             strtoul

//
// PRIVATE - make static items visible in debug version *FOR GLOBALS ONLY*. Use
// LOCAL in functions
//

#if INET_DEBUG

#define PRIVATE

#else

//#define PRIVATE static
#define PRIVATE

#endif // INET_DEBUG

//
// PUBLIC - just used as an aide-a-programmer pour le nonce
//

#define PUBLIC

//
// GLOBAL - same as PUBLIC, aide-a-programmer (for now) that tells you this
// thang has global scope
//

#define GLOBAL

//
// LOCAL - always expands to static, so you know that this thing only has
// local scope (within the current block)
//

#define LOCAL   static

//
// DEBUG_FUNCTION - this is a debug-only routine (if it get compiled in retail
// version a compile-time error is generated)
//

#if INET_DEBUG

#define DEBUG_FUNCTION

#else

#define DEBUG_FUNCTION

#endif // INET_DEBUG

//
// SKIPWS - skips blank widespace on the front of a string
//

#define SKIPWS(s) while (*(s)==' ' || *(s)=='\t') (s)++;


//
// MAKE_LOWER - takes an assumed upper character and bit manipulates into a lower.
//              (make sure the character is Upper case alpha char to begin, otherwise it corrupts)
//

#define MAKE_LOWER(c) (c | 0x20)

//
// MAKE_UPPER - takes an assumed lower character and bit manipulates into a upper.
//              (make sure the character is Lower case alpha char to begin, otherwise it corrupts)
//

#define MAKE_UPPER(c) (c & 0xdf)

//
// FASTCALL - used to bypass problems that may arise with UNIX compilers
//

#ifdef FASTCALL
#undef FASTCALL
#endif

#ifdef unix
#define FASTCALL
#else
#define FASTCALL __fastcall
#endif


//
// macro to cast FILETIME to LONGLONG
//
#define FT2LL(x) ( ((LONGLONG)((x).dwLowDateTime)) | (((LONGLONG)((x).dwHighDateTime))<<32) )


//
// Inline function to handle adding LONGLONG to FILETIME.
//
static __inline
void AddLongLongToFT( IN OUT LPFILETIME lpft,
                      IN     LONGLONG   llVal )
{
        LONGLONG llTmp;

        llTmp = FT2LL(*lpft);
        llTmp += llVal;

        lpft->dwLowDateTime =  ((LPDWORD)&llTmp)[0];
        lpft->dwHighDateTime = ((LPDWORD)&llTmp)[1];
}





//
// Macro to compute the number of bytes between two pointers
// The type of this expression is size_t, a signed integral
// type matching the size of a pointer
//
#define PtrDifference(x,y)  ((LPBYTE)(x) - (LPBYTE)(y))

//
// Macro to typecast 64-bit quantity to 32-bits
// Asserts in debug mode if the typecast loses information
//
#ifdef  DBG
#define GuardedCast(x)      ((x)<=0xFFFFFFFFL ? (DWORD)(x) : (InternetAssert(FALSE, __FILE__, __LINE__), 0))
#else
#define GuardedCast(x)      (DWORD)(x)
#endif

// Macro for the most common case
#define PtrDiff32(x,y)      (GuardedCast(PtrDifference(x,y)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\inetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetp.h

Abstract:

    Contains the Internet Gateway Service private functions proto type
    definitions.

Author:

    Madan Appiah  (madana)  11-Nov-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#ifndef _INETP_
#define _INETP_

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

//
// flags for close functions
//

#define CF_EXPEDITED_CLOSE  0x00000001

//
// define used to expire entries
//

#define ONE_HOUR_DELTA  (60 * 60 * (LONGLONG)10000000)

//
// define signature for LockRequestInfo structure
//
#define LOCK_REQUEST_SIGNATURE  0xAA55AA55

//
// types
//

typedef enum {
    TypeGenericHandle = 'HneG',
    TypeInternetHandle = 'tenI',
    TypeFtpConnectHandle = 'noCF',
    TypeFtpFindHandle = 'dnFF',
    TypeFtpFindHandleHtml = 'HnFF',
    TypeFtpFileHandle = 'liFF',
    TypeFtpFileHandleHtml = 'HlFF',
    TypeGopherConnectHandle = 'noCG',
    TypeGopherFindHandle = 'dnFG',
    TypeGopherFindHandleHtml = 'HnFG',
    TypeGopherFileHandle = 'liFG',
    TypeGopherFileHandleHtml = 'HlFG',
    TypeHttpConnectHandle = 'noCH',
    TypeHttpRequestHandle = 'qeRH',
    TypeFileRequestHandle = 'flRH',
    TypeWildHandle = 'dliW'
} HINTERNET_HANDLE_TYPE, *LPHINTERNET_HANDLE_TYPE;

typedef enum {
    HTML_STATE_INVALID,
    HTML_STATE_START,
    HTML_STATE_HEADER,
    HTML_STATE_WELCOME,
    HTML_STATE_DIR_HEADER,
    HTML_STATE_BODY,
    HTML_STATE_DIR_FOOTER,
    HTML_STATE_FOOTER,
#ifdef EXTENDED_ERROR_HTML
    HTML_STATE_END,
    HTML_STATE_ERROR_BODY
#else
    HTML_STATE_END
#endif
} HTML_STATE, *LPHTML_STATE;

typedef enum {
    READ_BUFFER_SIZE_INDEX,
    WRITE_BUFFER_SIZE_INDEX
} BUFFER_SIZE_INDEX;

typedef struct {

    DWORD   dwSignature;
    DWORD   dwSize;
    DWORD   dwCount;
    BOOL    fNoCacheLookup;
    BOOL    fNoDelete;
    HANDLE  hFile;
    LPSTR   UrlName;
    LPSTR   FileName;
    char    rgBuff[1];
}
LOCK_REQUEST_INFO, *LPLOCK_REQUEST_INFO;

//
// typedef virtual close function.
//

typedef BOOL ( *CLOSE_HANDLE_FUNC ) ( HINTERNET );
typedef BOOL ( *CONNECT_CLOSE_HANDLE_FUNC ) ( HINTERNET, DWORD );

//
// prototypes
//

BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    );

DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    );

//
// remote/RPC/object functions
//

DWORD
RIsHandleLocal(
    HINTERNET Handle,
    BOOL * IsLocalHandle,
    BOOL * IsAsyncHandle,
    HINTERNET_HANDLE_TYPE ExpectedHandleType
    );

DWORD
RGetHandleType(
    HINTERNET Handle,
    LPHINTERNET_HANDLE_TYPE HandleType
    );

DWORD
RSetHtmlHandleType(
    HINTERNET Handle
    );

DWORD
RSetHtmlState(
    HINTERNET Handle,
    HTML_STATE State
    );

DWORD
RGetHtmlState(
    HINTERNET Handle,
    LPHTML_STATE lpState
    );

DWORD
RSetUrl(
    HINTERNET Handle,
    LPSTR lpszUrl
    );

DWORD
RGetUrl(
    HINTERNET Handle,
    LPSTR* lpszUrl
    );

DWORD
RSetDirEntry(
    HINTERNET Handle,
    LPSTR lpszDirEntry
    );

DWORD
RGetDirEntry(
    HINTERNET Handle,
    LPSTR* lpszDirEntry
    );

DWORD
RSetParentHandle(
    HINTERNET hChild,
    HINTERNET hParent,
    BOOL DeleteWithChild
    );

DWORD
RGetParentHandle(
    HINTERNET hChild,
    LPHINTERNET lphParent
    );

DWORD
RGetContext(
    HINTERNET hInternet,
    DWORD_PTR *lpdwContext
    );

DWORD
RSetContext(
    HINTERNET hInternet,
    DWORD_PTR dwContext
    );

DWORD
RGetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    LPDWORD lpdwTimeoutValue
    );

DWORD
RSetTimeout(
    HINTERNET hInternet,
    DWORD dwTimeoutOption,
    DWORD dwTimeoutValue
    );

DWORD
RGetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    LPDWORD lpdwBufferSize
    );

DWORD
RSetBufferSize(
    HINTERNET hInternet,
    DWORD dwBufferSizeOption,
    DWORD dwBufferSize
    );

DWORD
RGetStatusCallback(
    IN HINTERNET Handle,
    OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback
    );

DWORD
RExchangeStatusCallback(
    IN HINTERNET Handle,
    IN OUT LPINTERNET_STATUS_CALLBACK lpStatusCallback,
    IN BOOL fType
    );

DWORD
RAddAsyncRequest(
    IN HINTERNET Handle,
    BOOL fNoCallbackOK
    );

DWORD
RRemoveAsyncRequest(
    IN HINTERNET Handle
    );

DWORD
RMakeInternetConnectObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CONNECT_CLOSE_HANDLE_FUNC wCloseFunc,
    LPSTR lpszServerName,
    INTERNET_PORT nServerPort,
    LPSTR lpszUserName,
    LPSTR lpszPassword,
    DWORD ServiceType,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );

HINTERNET
FindExistingConnectObject(
    IN HINTERNET hInternet,
    IN LPSTR lpHostName,
    IN INTERNET_PORT nPort,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    IN DWORD dwServiceType,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

INT
FlushExistingConnectObjects(
    IN HINTERNET hInternet
    );

DWORD
RMakeGfrFindObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

DWORD
RMakeGfrFixedObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    DWORD dwFixedType
    );

DWORD
RMakeGfrFileObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

DWORD
RGetLocalHandle(
    HINTERNET Handle,
    HINTERNET *LocalHandle
    );

DWORD
RMakeHttpReqObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD dwFlags,
    DWORD_PTR dwContext
    );

//
// FTP remote functions
//

DWORD
RMakeFtpFindObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

DWORD
RMakeFtpFileObjectHandle(
    HINTERNET ParentHandle,
    HINTERNET *ChildHandle,
    CLOSE_HANDLE_FUNC wCloseFunc,
    DWORD_PTR dwContext
    );

//
// non-exported Internet subordinate functions
//

BOOL
FtpFindNextFileA(
    IN HINTERNET hFtpSession,
    OUT LPWIN32_FIND_DATA lpFindFileData
    );

BOOL
FtpReadFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

BOOL
FtpWriteFile(
    IN HINTERNET hFtpSession,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );

BOOL
FtpCloseFile(
    IN HINTERNET hFtpSession
    );

BOOL
GopherFindNextA(
    IN HINTERNET hGopherFind,
    OUT LPGOPHER_FIND_DATA lpFindFileData
    );

BOOL
GopherReadFile(
    IN HINTERNET hGopherFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

DWORD
HttpWriteData(
    IN HINTERNET hRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten,
    IN DWORD dwSocketFlags
    );

DWORD
HttpReadData(
    IN HINTERNET hHttpRequest,
    OUT LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead,
    IN DWORD dwSocketFlags
    );

PUBLIC
DWORD
wHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

DWORD
wFtpConnect(
    IN LPCSTR pszFtpSite,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR pszUsername,
    IN LPCSTR pszPassword,
    IN DWORD dwService,
    IN DWORD dwFlags,
    OUT LPHINTERNET lphInternet
    );

DWORD
wFtpMakeConnection(
    IN HINTERNET hFtpSession,
    IN LPCSTR pszUsername,
    IN LPCSTR pszPassword
    );

DWORD
wFtpDisconnect(
    IN HINTERNET hFtpSession,
    IN DWORD dwFlags
    );

DWORD
wFtpQueryDataAvailable(
    IN HINTERNET hFtpSession,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

DWORD
wGopherQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

DWORD
pHttpGetUrlInfo(
    IN HANDLE RequestHandle,
    IN LPBYTE Headers,
    IN DWORD HeadersLength,
    IN LPBYTE UrlBuf,
    IN OUT DWORD *UrlBufLen,
    IN BOOL ReloadFlagCheck
    );

DWORD
pFtpGetUrlString(
    IN LPSTR    lpszTargetName,
    IN LPSTR    lpszCWD,
    IN LPSTR    lpszObjectName,
    IN LPSTR    lpszExtension,
    IN DWORD    dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pFtpGetUrlInfo(
    IN HANDLE InternetConnectHandle,
    OUT LPSTR Url
    );

DWORD
pGopherGetUrlString(
    IN LPSTR   lpszTargetName,
    IN LPSTR   lpszCWD,
    IN LPSTR   lpszObjectName,
    IN LPSTR    lpszExtension,
    IN DWORD   dwPort,
    OUT LPSTR   *lplpUrlName,
    OUT LPDWORD lpdwUrlLen
    );

DWORD
pGfrGetUrlInfo(
    IN HANDLE InternetConnectHandle,
    OUT LPSTR Url
    );


DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR     lpszFileExtension,
    IN BOOL fNormal
    );

BOOL
GetCurrentSettingsVersion(
    LPDWORD lpdwVer
    );

BOOL
IncrementCurrentSettingsVersion(
    LPDWORD lpdwVer
    );


extern DWORD  GlobalSettingsVersion;
extern BOOL   GlobalSettingsLoaded;
extern const char   vszSyncMode[];
extern const char   vszInvalidFilenameChars[];


#if defined(__cplusplus)
}
#endif

#endif // _INETP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\inetdbg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetdbg.h

Abstract:

    Manifests, macros, types and prototypes for Windows Internet client DLL
    debugging functions

Author:

    Richard L Firth (rfirth) 11-Oct-1994

Revision History:

    11-Oct-1994 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// misc. debug manifests
//

#define DEBUG_WAIT_TIME     (2 * 60 * 1000)

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

#if DBG

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// types
//

//
// DEBUG_FUNCTION_RETURN_TYPE - Type of result (scalar) that a function returns
//

#ifdef ENABLE_DEBUG

typedef enum {
    None,
    Bool,
    Int,
    Dword,
    String,
    Handle,
    Pointer
} DEBUG_FUNCTION_RETURN_TYPE;

//
// INTERNET_DEBUG_RECORD - for each thread, we maintain a LIFO stack of these,
// describing the functions we have visited
//

typedef struct _INTERNET_DEBUG_RECORD {

    //
    // Stack - a LIFO stack of debug records is maintained in the debug version
    // of the INTERNET_THREAD_INFO
    //

    struct _INTERNET_DEBUG_RECORD* Stack;

    //
    // Category - the function's category flag(s)
    //

    DWORD Category;

    //
    // ReturnType - type of value returned by function
    //

    DEBUG_FUNCTION_RETURN_TYPE ReturnType;

    //
    // Function - name of the function
    //

    LPCSTR Function;

    //
    // LastTime - if we are dumping times as deltas, keeps the last tick count
    //

    DWORD LastTime;

} INTERNET_DEBUG_RECORD, *LPINTERNET_DEBUG_RECORD;

//
// INTERNET_FUNCTION_TRIGGER - if we are required to trigger on a function, this
// structure maintains the debugging flags
//

typedef struct _INTERNET_FUNCTION_TRIGGER {

    //
    // Next - we maintain a singly-linked list of INTERNET_FUNCTION_TRIGGERs
    //

    struct _INTERNET_FUNCTION_TRIGGER* Next;

    //
    // Hash - hash value for the function name, to cut-down strcmp's to 1
    //

    DWORD Hash;

    //
    // Function - name of the function - must match exactly
    //

    LPCSTR Function;

    //
    // Category - category debug flags to use when this function triggers
    //

    DWORD MajorCategory;

} INTERNET_FUNCTION_TRIGGER, *LPINTERNET_FUNCTION_TRIGGER;

//
// data
//

extern DWORD InternetDebugErrorLevel;
extern DWORD InternetDebugControlFlags;
extern DWORD InternetDebugCategoryFlags;
extern DWORD InternetDebugBreakFlags;

//
// prototypes
//

//
// inetdbg.cxx
//

VOID
InternetDebugInitialize(
    VOID
    );

VOID
InternetDebugTerminate(
    VOID
    );

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    );

BOOL
InternetOpenDebugFile(
    VOID
    );

BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    );

VOID
InternetCloseDebugFile(
    VOID
    );

VOID
InternetFlushDebugFile(
    VOID
    );

VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList,
    IN ...
    );

VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetDebugError(
    IN DWORD Error
    );

VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    );

VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    IN va_list valist
    );

VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    );

VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    );

VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    );

DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    );

VOID
InternetAssert(
    IN LPSTR Condition,
    IN LPSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    );

LPSTR
InternetMapError(
    IN DWORD Error
    );

LPSTR
InternetMapStatus(
    IN DWORD Status
    );

LPSTR
InternetMapOption(
    IN DWORD Option
    );

LPSTR
InternetMapSSPIError(
    IN DWORD Status
    );

LPSTR
InternetMapHttpOption(
    IN DWORD Option
    );

LPSTR
InternetMapHttpState(
    IN DWORD State
    );

LPSTR
InternetMapHttpStateFlag(
    IN DWORD Flag
    );

LPSTR
InternetMapAuthScheme(
    IN DWORD Scheme
    );

LPSTR
InternetMapAuthState(
    IN DWORD State
    );

LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    );

LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    );

LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    );

LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    );

LPSTR
InternetMapService(
    IN DWORD Service
    );         

LPSTR
InternetMapWinsockCallbackType(
    IN DWORD CallbackType
    );

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN ctToken
    );

LPSTR
InternetMapChunkState(
    IN CHUNK_STATE csState
    );

DWORD
InternetHandleCount(
    VOID
    );

int dprintf(char *, ...);

LPSTR
SourceFilename(
    LPSTR Filespec
    );

VOID
InitSymLib(
    VOID
    );

VOID
TermSymLib(
    VOID
    );

LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    );

VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

#else

#define dprintf (VOID)

#endif // #ifdef ENABLE_DEBUG

//
// macros
//

#ifdef ENABLE_DEBUG

//
// INET_DEBUG_START - initialize debugging support
//

#define INET_DEBUG_START() \
    InternetDebugInitialize()

//
// INET_DEBUG_FINISH - terminate debugging support
//

#define INET_DEBUG_FINISH() \
    InternetDebugTerminate()

//
// INET_ASSERT - The standard assert, redefined here because Win95 doesn't have
// RtlAssert
//

#if defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    /* NOTHING */

#else

#define INET_ASSERT(test) \
    do if (!(test)) { \
        InternetAssert(#test, __FILE__, __LINE__); \
    } while (0)

#endif // defined(RETAIL_LOGGING)

#else // end #ifdef ENABLE_DEBUG

#define INET_DEBUG_START() \
    /* NOTHING */

#define INET_DEBUG_FINISH() \
    /* NOTHING */

#define INET_ASSERT(test) \
    do { } while(0) /* NOTHING */

#endif // end #ifndef ENABLE_DEBUG

//
// INET_DEBUG_ASSERT - assert only if INET_DEBUG is set
//

#if INET_DEBUG
#define INET_DEBUG_ASSERT(cond) INET_ASSERT(cond)
#else
#define INET_DEBUG_ASSERT(cond) /* NOTHING */
#endif

#if INET_DEBUG

//
// IF_DEBUG_CODE - always on if INET_DEBUG is set
//

#define IF_DEBUG_CODE() \
    if (1)

//
// IF_DEBUG - only execute following code if the specific flag is set
//

#define IF_DEBUG(x) \
    if (InternetDebugCategoryFlags & DBG_ ## x)

//
// IF_DEBUG_CONTROL - only execute if control flag is set
//

#define IF_DEBUG_CONTROL(x) \
    if (InternetDebugControlFlags & DBG_ ## x)

//
// DEBUG_ENTER - creates an INTERNET_DEBUG_RECORD for this function
//

#if defined(RETAIL_LOGGING)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    InternetDebugEnter ParameterList

#else

#define DEBUG_ENTER_API DEBUG_ENTER
#define DEBUG_ENTER(ParameterList) \
    InternetDebugEnter ParameterList

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_LEAVE - destroys this function's INTERNET_DEBUG_RECORD
//

#if defined(RETAIL_LOGGING)

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#else

#define DEBUG_LEAVE_API DEBUG_LEAVE
#define DEBUG_LEAVE(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_ERROR - displays an error and its symbolic name
//

#define DEBUG_ERROR(Category, Error) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugError(Error); \
    }

//
// DEBUG_PRINT - print debug info if we are at the correct level or we are
// requested to always dump information at, or above, InternetDebugErrorLevel
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#else

#define DEBUG_PRINT_API DEBUG_PRINT
#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_PUT - prints formatted string to debug output stream
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    /* NOTHING */

#else

#define DEBUG_PUT(Args) \
    InternetDebugPrintf Args

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_DUMP - dump data
//

#if defined(RETAIL_LOGGING)

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#else

#define DEBUG_DUMP_API DEBUG_DUMP
#define DEBUG_DUMP(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_BREAK - break into debugger if break flag is set for this module
//

#define DEBUG_BREAK(Module) \
    if (InternetDebugBreakFlags & DBG_ ## Module) { \
        InternetDebugPrintf("Breakpoint. File %s Line %d\n", \
                            __FILE__, \
                            __LINE__ \
                            ); \
        DebugBreak(); \
    }

//
// WAIT_FOR_SINGLE_OBJECT - perform WaitForSingleObject and check we didn't
// get a timeout
//

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), DEBUG_WAIT_TIME); \
    if (Error == WAIT_TIMEOUT) { \
        InternetDebugPrintf("single object timeout\n"); \
        DebugBreak(); \
    }

//
// DEBUG_WAIT_TIMER - create DWORD variable for holding time
//

#define DEBUG_WAIT_TIMER(TimerVar) \
    DWORD TimerVar

//
// DEBUG_START_WAIT_TIMER - get current tick count
//

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    TimerVar = GetTickCountWrap()

//
// DEBUG_CHECK_WAIT_TIMER - get the current number of ticks, subtract from the
// previous value recorded by DEBUG_START_WAIT_TIMER and break to debugger if
// outside the predefined range
//

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    TimerVar = (GetTickCountWrap() - TimerVar); \
    if (TimerVar > MilliSeconds) { \
        InternetDebugPrintf("Wait time (%d mSecs) exceeds acceptable value (%d mSecs)\n", \
                            TimerVar, \
                            MilliSeconds \
                            ); \
        DebugBreak(); \
    }

#define DEBUG_DATA(Type, Name, InitialValue) \
    Type Name = InitialValue

#define DEBUG_DATA_EXTERN(Type, Name) \
    extern Type Name

#define DEBUG_LABEL(label) \
    label:

#define DEBUG_GOTO(label) \
    goto label

#define DEBUG_ONLY(x) \
    x

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)
#define GET_CALL_STACK(p)           x86SleazeCallStack((LPVOID *)&p, ARRAY_ELEMENTS(p), 0)

#else

#define GET_CALLERS_ADDRESS(p, pp)
#define GET_CALL_STACK(p)

#endif // defined(i386)

#else // end #if INET_DEBUG

#define IF_DEBUG_CODE() \
    if (0)

#define IF_DEBUG(x) \
    if (0)

#define IF_DEBUG_CONTROL(x) \
    if (0)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    /* NOTHING */

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    /* NOTHING */

#define DEBUG_ERROR(Category, Error) \
    /* NOTHING */

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PUT(Args) \
    /* NOTHING */

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_BREAK(module) \
    /* NOTHING */

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), INFINITE)

#define DEBUG_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    /* NOTHING */

#define DEBUG_DATA(Type, Name, InitialValue) \
    /* NOTHING */

#define DEBUG_DATA_EXTERN(Type, Name) \
    /* NOTHING */

#define DEBUG_LABEL(label) \
    /* NOTHING */

#define DEBUG_GOTO(label) \
    /* NOTHING */

#define DEBUG_ONLY(x) \
    /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\parseurl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.h

Abstract:

    Header for parseurl.c and protocol-specific parsers

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Revision History:

    26-Apr-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define SAFE                0x00    // character is safe in all schemes
#define SCHEME_FTP          0x01    // character is unsafe in FTP scheme
#define SCHEME_GOPHER       0x02    // character is unsafe in gopher scheme
#define SCHEME_HTTP         0x04    // character is unsafe in HTTP scheme
#define UNSAFE              0x80    // character is unsafe in all schemes

#define SCHEME_ANY          (SCHEME_FTP | SCHEME_GOPHER | SCHEME_HTTP)

//
// types
//

typedef
DWORD
(*LPFN_URL_PARSER)(
    LPHINTERNET,
    LPSTR,
    DWORD,
    LPSTR,
    DWORD,
    DWORD,
    DWORD_PTR
    );

//
// prototypes
//

BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    );

BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    );

DWORD
ParseUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPVOID hMapped,
    IN LPCSTR Url,
    IN LPCSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* UrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    );

DWORD
EncodeAuthorityComponent(
    IN LPSTR Component,
    IN DWORD ComponentLength,
    OUT LPSTR EncodedComponent,
    IN OUT LPDWORD EncodedComponentLength
    );

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR EncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    );

//
// flags for EncodeUrlPath
//

#define NO_ENCODE_PATH_SEP  0x00000001

DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR UnescapedString,
    IN OUT LPDWORD UnescapedLength
    );

DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    );

DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    );

DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT INTERNET_PORT* lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    );

INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    );

LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    );

LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    );

//
// protocol-specific URL parsers
//

DWORD
ParseFtpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
ParseGopherUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

DWORD
GopherLocatorToUrl(
    IN LPSTR Locator,
    OUT LPSTR Buffer,
    IN DWORD BufferLength,
    OUT LPDWORD UrlLength
    );

DWORD
ParseHttpUrl(
    IN OUT LPHINTERNET hInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\persist.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    persist.h

Abstract:

Author:

    Adriaan Canter (adriaanc) 13-Jan-1998

Revision History:

    13-Jan-1998 adriaanc
        Created

--*/

#ifndef PERSIST_H
#define PERSIST_H

#include <pstore.h>

#define DISABLE_PASSWORD_CACHE_VALUE  "DisablePasswordCaching"
#define DISABLE_PASSWORD_CACHE        1

#define CRED_PERSIST_NOT_AVAIL        0
#define CRED_PERSIST_AVAIL            1
#define CRED_PERSIST_UNKNOWN          2

// PWL related defines.

// Password-cache-entry, this should be in PCACHE.
#define PCE_WWW_BASIC 0x13  
#define MAX_AUTH_FIELD_LENGTH           MAX_FIELD_LENGTH * 2

#define WNETDLL_MODULE                  "mpr.dll"
#define PSTORE_MODULE                   "pstorec.dll"
#define WNETGETCACHEDPASS               "WNetGetCachedPassword"
#define WNETCACHEPASS                   "WNetCachePassword"
#define WNETREMOVECACHEDPASS            "WNetRemoveCachedPassword"

// MPR.DLL exports used by top level API.
typedef DWORD (APIENTRY *PFWNETGETCACHEDPASSWORD)    (LPSTR, WORD, LPSTR, LPWORD, BYTE);
typedef DWORD (APIENTRY *PFWNETCACHEPASSWORD)        (LPSTR, WORD, LPSTR, WORD, BYTE, UINT);
typedef DWORD (APIENTRY *PFWNETREMOVECACHEDPASSWORD) (LPSTR, WORD, BYTE);


// ----------------Public function prototypes----------------------

// Determines availability of credential cache.
DWORD  InetInitCredentialPersist();

// Persist credentials (username/password).
DWORD InetSetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealmOrDomain, 
                                 LPSTR szUser, 
                                 LPSTR szPass);


// Get persisted credentials (username/password).
DWORD InetGetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealmOrDomain, 
                                 LPSTR szUser, 
                                 LPSTR szPass);


// Remove persisted credentials (username/password).
DWORD InetRemoveCachedCredentials (LPSTR szHost, LPSTR szRealmOrDomain);



#endif //PERSIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\resinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    resinfo.h

Abstract:

    Resource owner info header. Used for tracking resources in debug build

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if INET_DEBUG

//
// types
//

//typedef struct {
//    DWORD Tid;
//    DWORD CallersAddress;
//    DWORD CallersCaller;
//    DWORD SourceFileLine;
//    LPSTR SourceFileName;
//} RESOURCE_INFO, *LPRESOURCE_INFO;
typedef struct {
    DWORD Tid;
    LPSTR SourceFileName;
    DWORD SourceFileLine;
} RESOURCE_INFO, *LPRESOURCE_INFO;

//#define GET_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define GET_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

//#define INITIALIZE_RESOURCE_INFO(pResource) \
//    { \
//        (pResource)->Tid = GetCurrentThreadId(); \
//        (pResource)->CallersAddress = 0; \
//        (pResource)->CallersCaller = 0; \
//        (pResource)->SourceFileLine = __LINE__; \
//        (pResource)->SourceFileName = __FILE__; \
//    }
#define INITIALIZE_RESOURCE_INFO(pResource) \
    { \
        (pResource)->Tid = GetCurrentThreadId(); \
        (pResource)->SourceFileName = __FILE__; \
        (pResource)->SourceFileLine = __LINE__; \
    }

#else

#define GET_RESOURCE_INFO(pResource)
#define INITIALIZE_RESOURCE_INFO(pResource)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\proxreg.h ===
#include <inetreg.h>

#define BLOB_BUFF_GRANULARITY   1024

class CRegBlob
{
    private:
        HKEY    _hkey;
        BOOL    _fWrite;
        BOOL    _fCommit;
        DWORD   _dwOffset;
        DWORD   _dwBufferLimit;
        BYTE *  _pBuffer;
        LPCSTR  _pszValue;

    public:
        CRegBlob(BOOL fWrite);
        ~CRegBlob();
        DWORD Init(HKEY hBaseKey, LPCSTR pszSubKey, LPCSTR pszValue);
        DWORD Abandon();
        DWORD Commit();
        DWORD WriteString(LPCSTR pszString);
        DWORD ReadString(LPCSTR * ppszString);
        DWORD WriteBytes(LPCVOID pBytes, DWORD dwByteCount);
        DWORD ReadBytes(LPVOID pBytes, DWORD dwByteCount);

    private:
        DWORD Encrpyt();
        DWORD Decrypt();
};


class CRefdKey
{
public:
    ULONG CRefdKey::AddRef()
    {
        return InterlockedIncrement(&_cRef);
    }

    ULONG CRefdKey::Release()
    {
        UINT cNewRef = InterlockedDecrement(&_cRef);
        if (cNewRef == 0)
        {
            delete this;
        }
        return cNewRef;
    }

    HKEY GetKey() { return _hkey; }
    CRefdKey(HKEY hkey) : _hkey(hkey), _cRef(1) {}
    ~CRefdKey()
    {
        if ((_hkey != NULL)                  &&
            (_hkey != HKEY_LOCAL_MACHINE)    &&
            (_hkey != HKEY_CURRENT_USER))
        {
            RegCloseKey(_hkey);
        }
    }

private:
    LONG _cRef;
    HKEY _hkey;
};


// NOTE! Changes to the following struct must be made in a backwards-compatible
//       manner. Do not remove fields; only add to the end of the struct.
//       And if you do change the struct, you must increment
//       INTERNET_PROXY_INFO_EX_VERSION and the code in ReadProxySettings to
//       support reading in older versions.

typedef struct {

    //
    // dwStructSize - Structure size to handle growing list of new entries or priv/pub structures
    //

    DWORD dwStructSize;

    //
    // dwFlags - Proxy type flags
    //

    DWORD dwFlags;

    //
    // dwCurrentSettingsVersion - a counter incremented every time we change our settings
    //

    DWORD dwCurrentSettingsVersion;

    //
    // lpszConnectionName - name of the Connectoid for this connection
    //
    
    LPCSTR lpszConnectionName;

    //
    // lpszProxy - proxy server list
    //

    LPCSTR lpszProxy;

    //
    // lpszProxyBypass - proxy bypass list
    //

    LPCSTR lpszProxyBypass;

    //
    // lpszAutoconfigUrl - autoconfig URL
    //

    LPCSTR lpszAutoconfigUrl;
    LPCSTR lpszAutoconfigSecondaryUrl;

    //
    // dwAutoDiscoveryFlags - auto detect flags.
    //

    DWORD dwAutoDiscoveryFlags;

    // 
    // lpszLastKnownGoodAutoConfigUrl - Last Successful Url 
    //

    LPCSTR lpszLastKnownGoodAutoConfigUrl;

    //
    // dwAutoconfigReloadDelayMins - number of mins until automatic 
    //    refresh of auto-config Url, 0 == disabled.
    //

    DWORD dwAutoconfigReloadDelayMins;

    //
    // ftLastKnownDetectTime - When the last known good Url was found with detection.
    //

    FILETIME ftLastKnownDetectTime;

    //
    // dwDetectedInterfaceIpCount - Number of IPs detected in last detection
    //

    DWORD dwDetectedInterfaceIpCount;

    //
    // dwDetectedInterfaceIp - Array of DWORD of IPs detected in last detection
    //

    DWORD *pdwDetectedInterfaceIp;

} INTERNET_PROXY_INFO_EX, * LPINTERNET_PROXY_INFO_EX;


// version stamp of INTERNET_PROXY_INFO_EX
#define INTERNET_PROXY_INFO_EX_VERSION      60      // 60 := IE 5.x & 6.0 format


// name of blob for saved legacy settings
#define LEGACY_SAVE_NAME            "SavedLegacySettings"

DWORD
WriteProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo,
    BOOL fForceUpdate
    );

DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    );

BOOL
ReadLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy
    );

BOOL
WriteLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy,
    IN BOOL    fOverwrite
    );

DWORD
SetPerConnOptions(
    HINTERNET hInternet,    
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    );

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2
    );

CRefdKey*
FindBaseProxyKey(
    VOID
    );

BOOL
CloseBaseProxyKey(
    CRefdKey* prk
    );

BOOL
EnableAutodiscoverForDialup(
    VOID
    );

VOID
CheckForUpgrade(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\readhtml.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    readhtml.h

Abstract:

    Prototypes, etc. for readhtml.h

Author:

    Richard L Firth (rfirth) 26-Jun-1995

Revision History:

    26-Jun-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// prototypes
//

BOOL
ReadHtmlUrlData(
    IN HINTERNET hInternet,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwBytesReturned
    );

DWORD
QueryHtmlDataAvailable(
    IN HINTERNET hInternet,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\rashelp.h ===
#ifndef _RASHELP_H_
#define _RASHELP_H_

#include <regstr.h>
#include <inetreg.h>
#include <windowsx.h>
#include <rasdlg.h>

typedef enum
{
    ENUM_NONE,
    ENUM_MULTIBYTE,             // Win9x
    ENUM_UNICODE,               // NT4
    ENUM_WIN2K                  // Win2K
} ENUM_TYPE;

/////////////////////////////////////////////////////////////////////////////////////
class GetOSVersion
{
protected:
    static ENUM_TYPE    _EnumType;

public:
    GetOSVersion();
    ~GetOSVersion();
};

/////////////////////////////////////////////////////////////////////////////////////
class RasEnumHelp : public GetOSVersion
{
private:

    //
    // Win2k version of RASENTRYNAMEW struct
    //

    // match RAS packing so structs match
    #include <pshpack4.h>
    #define W2KRASENTRYNAMEW struct tagW2KRASENTRYNAMEW
    W2KRASENTRYNAMEW
    {
        DWORD dwSize;
        WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
        DWORD dwFlags;
        WCHAR szPhonebookPath[MAX_PATH + 1];
    };
    #define LPW2KRASENTRYNAMEW W2KRASENTRYNAMEW*
    #include <poppack.h>

    //
    // Any error we got during enumeration
    //
    DWORD           _dwLastError;

    //
    // Number of entries we got
    //
    DWORD           _dwEntries;

    //
    // Pointer to info retrieved from RAS
    //
    RASENTRYNAMEA * _preList;

    //
    // Last entry returned as multibyte or unicode when conversion required
    //
    CHAR            _szCurrentEntryA[RAS_MaxEntryName + 1];
    WCHAR           _szCurrentEntryW[RAS_MaxEntryName + 1];


public:
    RasEnumHelp();
    ~RasEnumHelp();

    DWORD   GetError();
    DWORD   GetEntryCount();
    LPSTR   GetEntryA(DWORD dwEntry);
    LPWSTR  GetEntryW(DWORD dwEntry);
};

/////////////////////////////////////////////////////////////////////////////////////
class RasEnumConnHelp : public GetOSVersion
{
private:

    // match RAS packing so structs match
    #include <pshpack4.h>
    #define W2KRASCONNW struct tagW2KRASCONNW
    W2KRASCONNW
    {
        DWORD    dwSize;
        HRASCONN hrasconn;
        WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];
        //#if (WINVER >= 0x400)
        WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
        WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
        //#endif
        //#if (WINVER >= 0x401)
        WCHAR    szPhonebook [ MAX_PATH ];
        DWORD    dwSubEntry;
        //#endif
        //#if (WINVER >= 0x500)
        GUID     guidEntry;
        //#endif
    };
    #define LPW2KRASCONNW W2KRASCONNW*
    #include <poppack.h>

    DWORD           _dwLastError;       // Any error we got during enumeration
    DWORD           _dwConnections;     // Number of connections
    DWORD           _dwStructSize;
    RASCONNA        *_pRasCon;

    // Last entry returned as multibyte or unicode when conversion required
    WCHAR    _szEntryNameW[ RAS_MaxEntryName + 1 ];
//    WCHAR    _szDeviceTypeW[ RAS_MaxDeviceType + 1 ];
//    WCHAR    _szDeviceNameW[ RAS_MaxDeviceName + 1 ];
//    WCHAR    _szPhonebookW[ MAX_PATH ];

    CHAR    _szEntryNameA[ RAS_MaxEntryName + 1 ];
//    CHAR    _szDeviceTypeA[ RAS_MaxDeviceType + 1 ];
//    CHAR    _szDeviceNameA[ RAS_MaxDeviceName + 1 ];
//    CHAR    _szPhonebookA[ MAX_PATH ];

public:
    RasEnumConnHelp();
    ~RasEnumConnHelp();

    DWORD   Enum();
    DWORD   GetError();
    DWORD   GetConnectionsCount();
    LPWSTR  GetEntryW(DWORD dwConnectionNum);
    LPSTR   GetEntryA(DWORD dwConnectionNum);
    LPWSTR  GetLastEntryW(DWORD dwConnectionNum);
    LPSTR   GetLastEntryA(DWORD dwConnectionNum);
    HRASCONN GetHandle(DWORD dwConnectionNum);
};

/////////////////////////////////////////////////////////////////////////////////////
class RasEntryPropHelp : public GetOSVersion
{
private:

    // match RAS packing so structs match
    #include <pshpack4.h>
    #define W2KRASENTRYW struct tagW2KRASENTRYW
    W2KRASENTRYW
    {
        DWORD       dwSize;
        DWORD       dwfOptions;
        //
        // Location/phone number
        //
        DWORD       dwCountryID;
        DWORD       dwCountryCode;
        WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
        WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        DWORD       dwAlternateOffset;
        //
        // PPP/Ip
        //
        RASIPADDR   ipaddr;
        RASIPADDR   ipaddrDns;
        RASIPADDR   ipaddrDnsAlt;
        RASIPADDR   ipaddrWins;
        RASIPADDR   ipaddrWinsAlt;
        //
        // Framing
        //
        DWORD       dwFrameSize;
        DWORD       dwfNetProtocols;
        DWORD       dwFramingProtocol;
        //
        // Scripting
        //
        WCHAR       szScript[ MAX_PATH ];
        //
        // AutoDial
        //
        WCHAR       szAutodialDll[ MAX_PATH ];
        WCHAR       szAutodialFunc[ MAX_PATH ];
        //
        // Device
        //
        WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
        WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
        //
        // X.25
        //
        WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
        WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
        WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
        WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
        DWORD       dwChannels;
        //
        // Reserved
        //
        DWORD       dwReserved1;
        DWORD       dwReserved2;
        //#if (WINVER >= 0x401)
        //
        // Multilink
        //
        DWORD       dwSubEntries;
        DWORD       dwDialMode;
        DWORD       dwDialExtraPercent;
        DWORD       dwDialExtraSampleSeconds;
        DWORD       dwHangUpExtraPercent;
        DWORD       dwHangUpExtraSampleSeconds;
        //
        // Idle timeout
        //
        DWORD       dwIdleDisconnectSeconds;
        //#endif

        //#if (WINVER >= 0x500)
        //
        // Entry Type
        //
        DWORD       dwType;

        //
        // EncryptionType
        //
        DWORD       dwEncryptionType;

        //
        // CustomAuthKey to be used for EAP
        //
        DWORD       dwCustomAuthKey;

        //
        // Guid of the connection
        //
        GUID        guidId;

        //
        // Custom Dial Dll
        //
        WCHAR       szCustomDialDll[MAX_PATH];

        //
        // Vpn Strategy
        //
        DWORD       dwVpnStrategy;
        //#endif
    };
    #define LPW2KRASENTRYW W2KRASENTRYW*
    #include <poppack.h>

    DWORD           _dwStructSize;
    DWORD           _dwLastError;       // Any error we got during enumeration
    RASENTRYA       *_pRasEntry;

    // Last entry returned as multibyte or unicode when conversion required
    WCHAR    _szEntryNameW[ RAS_MaxEntryName + 1 ];
    WCHAR    _szDeviceTypeW[ RAS_MaxDeviceType + 1 ];
    WCHAR    _szAutodialDllW[ MAX_PATH ];
    WCHAR    _szAutodialFuncW[ MAX_PATH ];
    WCHAR    _szCustomDialDllW[ MAX_PATH ];
    WCHAR    _szPhoneNumberW[ RAS_MaxPhoneNumber + 1 ];
    WCHAR    _szAreaCodeW[ RAS_MaxAreaCode + 1 ];
    CHAR     _szEntryNameA[ RAS_MaxEntryName + 1 ];
    CHAR     _szDeviceTypeA[ RAS_MaxDeviceType + 1 ];
    CHAR     _szAutodialDllA[ MAX_PATH ];
    CHAR     _szAutodialFuncA[ MAX_PATH ];

public:
    RasEntryPropHelp();
    ~RasEntryPropHelp();

    DWORD   GetError();
    DWORD   GetA(LPSTR lpszEntryName);
    DWORD   GetW(LPWSTR lpszEntryName);
    LPWSTR  GetDeviceTypeW(VOID);
    LPSTR   GetDeviceTypeA(VOID);
    LPWSTR  GetAutodiallDllW();
    LPSTR   GetAutodiallDllA();
    LPWSTR  GetAutodialFuncW();
    LPSTR   GetAutodialFuncA();
    LPWSTR  GetCustomDialDllW();
    LPWSTR  GetPhoneNumberW();
    DWORD   GetCountryCode();
    DWORD   GetOptions();
    LPWSTR  GetAreaCodeW();

};

/////////////////////////////////////////////////////////////////////////////////////
class RasEntryDialParamsHelp : public GetOSVersion
{
private:
    DWORD           _dwLastError;       // Any error we got during enumeration
    RASDIALPARAMSA  *_pRasDialParamsA;

public:
    RasEntryDialParamsHelp();
    ~RasEntryDialParamsHelp();
    DWORD GetError();
    DWORD SetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, BOOL fRemovePassword);
    DWORD GetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, LPBOOL pfRemovePassword);
};

/////////////////////////////////////////////////////////////////////////////////////
class RasGetConnectStatusHelp : public GetOSVersion
{
private:
    DWORD           _dwLastError;       // Any error we got during enumeration
    DWORD           _dwStructSize;
    RASCONNSTATUSA  *_pRasConnStatus;

public:
    RasGetConnectStatusHelp(HRASCONN hrasconn);
    ~RasGetConnectStatusHelp();
    DWORD GetError();
    RASCONNSTATE ConnState();
};

/////////////////////////////////////////////////////////////////////////////////////
class RasDialHelp : public GetOSVersion
{
private:
    // We currently build with WINVER == 0x400, on NT we RasDialW needs the 401 struct to support
    //   connectoids greater than 20 chars as found in IE501 bug 82419
    // match RAS packing so structs match
    #include <pshpack4.h>
    #define NT4RASDIALPARAMSW struct tagNT4RASDIALPARAMSW
    NT4RASDIALPARAMSW
    {
        DWORD dwSize;
        WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
        WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
        WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
        WCHAR szUserName[ UNLEN + 1 ];
        WCHAR szPassword[ PWLEN + 1 ];
        WCHAR szDomain[ DNLEN + 1 ];
    //#if (WINVER >= 0x401)
        DWORD dwSubEntry;
        ULONG_PTR dwCallbackId;
    //#endif
    };
    #define LPNT4RASDIALPARAMSW NT4RASDIALPARAMSW*
    #include <poppack.h>

    DWORD           _dwLastError;       // Any error we got during enumeration
    RASDIALPARAMSA *_pRasDialParams;
    LPSTR           _lpszPhonebookA;

public:
    RasDialHelp(LPRASDIALEXTENSIONS lpRDE, LPWSTR lpszPB, LPRASDIALPARAMSW lpRDPW,  DWORD dwType, LPVOID lpvNot, LPHRASCONN lphRasCon);
    ~RasDialHelp();
    DWORD GetError();
};


/////////////////////////////////////////////////////////////////////////////////////
#endif // _RASHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\serialst.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.h

Abstract:

    Header file for serialst.c

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// types
//

typedef struct {

#if INET_DEBUG

    //
    // Signature - must have this to ensure its really a serialized list. Also
    // makes finding start of this structure relatively easy when debugging
    //

    DWORD Signature;

    //
    // ResourceInfo - basically who owns this 'object', combined with yet more
    // debugging information
    //

    RESOURCE_INFO ResourceInfo;

    //
    // LockCount - number of re-entrant locks held
    //

    LONG LockCount;

#endif // INET_DEBUG

    LIST_ENTRY List;

    //
    // ElementCount - number of items on list. Useful for consistency checking
    //

    LONG ElementCount;

    //
    // Lock - we must acquire this to update the list. Put this structure at
    // the end to make life easier when debugging
    //

    CRITICAL_SECTION Lock;

} SERIALIZED_LIST, *LPSERIALIZED_LIST;

//
// SERIALIZED_LIST_ENTRY - we can use this in place of LIST_ENTRY so that in
// the debug version we can check for cycles, etc.
//

typedef struct {

    LIST_ENTRY List;

#if INET_DEBUG

    DWORD Signature;
    DWORD Flags;

#endif

} SERIALIZED_LIST_ENTRY, *LPSERIALIZED_LIST_ENTRY;

//
// prototypes
//

#if INET_DEBUG

VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

VOID
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

#define IsLockHeld(list) \
    (((list)->ResourceInfo.Tid == GetCurrentThreadId()) \
        ? ((list)->LockCount != 0) \
        : FALSE)

#else // INET_DEBUG

#define InitializeSerializedList(list) \
    { \
        InitializeListHead(&(list)->List); \
        InitializeCriticalSection(&(list)->Lock); \
        (list)->ElementCount = 0; \
    }

#define TerminateSerializedList(list) \
    DeleteCriticalSection(&(list)->Lock)

#define LockSerializedList(list) \
    EnterCriticalSection(&(list)->Lock)

#define UnlockSerializedList(list) \
    LeaveCriticalSection(&(list)->Lock)

#define InsertAtHeadOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertHeadList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define InsertAtTailOfSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        InsertTailList(&(list)->List, entry); \
        ++(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define RemoveFromSerializedList(list, entry) \
    { \
        LockSerializedList(list); \
        RemoveEntryList(entry); \
        --(list)->ElementCount; \
        UnlockSerializedList(list); \
    }

#define IsSerializedListEmpty(list) \
    IsListEmpty(&(list)->List)

#define HeadOfSerializedList(list) \
    (list)->List.Flink

#define TailOfSerializedList(list) \
    (list)->List.Blink

#define IsLockHeld(list) \
    /* NOTHING */



#endif // INET_DEBUG

//
// functions that are always functions
//

LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    );

LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    );

BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    );

//
// functions that are always macros
//

#define NextInSerializedList(list, entry)\
        (( ((entry)->List).Flink == &((list)->List))? NULL : ((entry)->List).Flink)

#define ElementsOnSerializedList(list) \
    (list)->ElementCount

#define SlSelf(SerializedList) \
    &(SerializedList)->List.Flink

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\resolver.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    resolver.h

Abstract:

    Definitions etc. for Berkeley resolver

Author:

    Richard L Firth (rfirth) 15-Jun-1996

Revision History:

    15-Jun-1996 rfirth
        Created

--*/

//
// includes
//

#include <nameser.h>
#include <resolv.h>

//
// manifests
//

#if PACKETSZ > 1024
#define MAXPACKET       PACKETSZ
#else
#define MAXPACKET       1024
#endif

#define DBG_RESOLVER    DBG_SOCKETS
#define DBG_VXD_IO      DBG_SOCKETS

#define DLL_PRINT(x)    DEBUG_PRINT(SOCKETS, INFO, x)
#define WS_PRINT(x)     DEBUG_PRINT(SOCKETS, INFO, x)
#define WS_ASSERT       INET_ASSERT
#define DLL_ASSERT      INET_ASSERT

//
// macros
//
#ifndef unix
#define bcopy(s, d, c)  memcpy((u_char *)(d), (u_char *)(s), (c))
#define bzero(d, l)     memset((d), '\0', (l))
#endif /* unix */
#define bcmp(s1, s2, l) memcmp((s1), (s2), (l))

#define IS_DGRAM_SOCK(type)  (((type) == SOCK_DGRAM) || ((type) == SOCK_RAW))

//
// types
//

typedef union {
    HEADER hdr;
    unsigned char buf[MAXPACKET];
} querybuf;

typedef union {
    long al;
    char ac;
} align;

//extern char VTCPPARM[];
//extern char NTCPPARM[];
//extern char TCPPARM[];
//extern char TTCPPARM[];

#ifndef unix
typedef long                   daddr_t;
typedef char FAR *             caddr_t;
struct iovec {
    caddr_t iov_base;
    int     iov_len;
};

struct uio {
    struct  iovec *uio_iov;
    int     uio_iovcnt;
    int     uio_offset;
    int     uio_segflg;
    int     uio_resid;
};

enum    uio_rw { UIO_READ, UIO_WRITE };
#endif /* unix */
/*
 * Segment flag values (should be enum).
 */
#define UIO_USERSPACE   0               /* from user data space */
#define UIO_SYSSPACE    1               /* from system space */
#define UIO_USERISPACE  2               /* from user I space */

#define MAXALIASES      35
#define MAXADDRS        35

#define HOSTDB_SIZE     (_MAX_PATH + 7)   // 7 == strlen("\\hosts") + 1
#define PROTODB_SIZE    (_MAX_PATH + 10)
#define SERVDB_SIZE     (_MAX_PATH + 10)

typedef struct _WINSOCK_TLS_DATA {
    char * GETHOST_h_addr_ptrs[MAXADDRS + 1];
    struct hostent GETHOST_host;
    char * GETHOST_host_aliases[MAXALIASES];
    char GETHOST_hostbuf[BUFSIZ + 1];
    //struct in_addr GETHOST_host_addr;
    //char GETHOST_HOSTDB[HOSTDB_SIZE];
    //FILE *GETHOST_hostf;
    //char GETHOST_hostaddr[MAXADDRS];
    //char *GETHOST_host_addrs[2];
    //int GETHOST_stayopen;
    //char GETPROTO_PROTODB[PROTODB_SIZE];
    //FILE *GETPROTO_protof;
    //char GETPROTO_line[BUFSIZ+1];
    //struct protoent GETPROTO_proto;
    //char *GETPROTO_proto_aliases[MAXALIASES];
    //int GETPROTO_stayopen;
    //char GETSERV_SERVDB[SERVDB_SIZE];
    //FILE *GETSERV_servf;
    //char GETSERV_line[BUFSIZ+1];
    //struct servent GETSERV_serv;
    //char *GETSERV_serv_aliases[MAXALIASES];
    //int GETSERV_stayopen;
    struct state R_INIT__res;
    //char INTOA_Buffer[18];
    //CSOCKET * DnrSocketHandle;
    //BOOLEAN IsBlocking;
    BOOLEAN IoCancelled;
    //BOOLEAN ProcessingGetXByY;
    BOOLEAN GetXByYCancelled;
    //BOOLEAN EnableWinsNameResolution;
    //BOOLEAN DisableWinsNameResolution;
    //SOCKET SocketHandle;
    //PBLOCKING_HOOK BlockingHook;
    //HANDLE EventHandle;
    //ULONG CreateOptions;
    INT DnrErrorCode;
//#if DBG
//    ULONG IndentLevel;
//#endif
} WINSOCK_TLS_DATA, * LPWINSOCK_TLS_DATA;

//extern DWORD SockTlsSlot;

//#define ACCESS_THREAD_DATA(a, file) \
//            (((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))-> \
//                ## file ## _ ## a )

#define ACCESS_THREAD_DATA(a, file) (lpResolverInfo->file ## _ ## a)

#define _h_addr_ptrs    ACCESS_THREAD_DATA(h_addr_ptrs, GETHOST)
#define _host           ACCESS_THREAD_DATA(host, GETHOST)
#define _host_aliases   ACCESS_THREAD_DATA(host_aliases, GETHOST)
#define _hostbuf        ACCESS_THREAD_DATA(hostbuf, GETHOST)
#define _host_addr      ACCESS_THREAD_DATA(host_addr, GETHOST)
//#define HOSTDB          ACCESS_THREAD_DATA(HOSTDB, GETHOST)
//#define hostf           ACCESS_THREAD_DATA(hostf, GETHOST)
//#define hostaddr        ACCESS_THREAD_DATA(hostaddr, GETHOST)
//#define host_addrs      ACCESS_THREAD_DATA(host_addrs, GETHOST)
//#define stayopen        ACCESS_THREAD_DATA(stayopen, GETHOST)
#define _res            ACCESS_THREAD_DATA( _res, R_INIT )

//#define SockThreadProcessingGetXByY lpResolverInfo->ProcessingGetXByY
#define SockThreadGetXByYCancelled  lpResolverInfo->GetXByYCancelled
#define SockDnrSocket               lpResolverInfo->DnrSocketHandle
#define SockThreadDnrErrorCode      lpResolverInfo->DnrErrorCode

//#define SockThreadIsBlocking \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->IsBlocking )
//
//#define SockThreadIoCancelled \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->IoCancelled )
//
//#define SockThreadProcessingGetXByY \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->ProcessingGetXByY )
//
//#define SockThreadGetXByYCancelled \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->GetXByYCancelled )
//
//#define SockThreadSocketHandle \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->SocketHandle )
//
//#define SockThreadBlockingHook \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->BlockingHook )
//
//#define SockThreadEvent \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->EventHandle )
//
//#define SockDnrSocket \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->DnrSocketHandle )
//
//#define SockEnableWinsNameResolution \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->EnableWinsNameResolution )
//
//#define SockDisableWinsNameResolution \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->DisableWinsNameResolution )
//
//#define SockCreateOptions \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->CreateOptions )
//
//#define SockThreadDnrErrorCode \
//            ( ((LPWINSOCK_TLS_DATA)TlsGetValue( SockTlsSlot ))->DnrErrorCode )

#define LPSOCK_THREAD   LPWINSOCK_TLS_DATA
#define GET_THREAD_DATA(p) p = InternetGetResolverInfo()
//#define I_SetLastError  SetLastError
#define DllAllocMem(n)  ALLOCATE_MEMORY(LMEM_FIXED, n)
#define DllFreeMem      FREE_MEMORY

//
// well-known DHCP VxD ID (from netvxd.h)
//

#define VDHCP_Device_ID     0x049A

//
// prototypes
//

int
dn_expand(
    IN  unsigned char *msg,
    IN  unsigned char *eomorig,
    IN  unsigned char *comp_dn,
    OUT unsigned char *exp_dn,
    IN  int            length
    );

static
int
dn_find(
    unsigned char  *exp_dn,
    unsigned char  *msg,
    unsigned char **dnptrs,
    unsigned char **lastdnptr
    );

int
dn_skipname(
    unsigned char *comp_dn,
    unsigned char *eom
    );

void
fp_query(
    char *msg,
    FILE *file
    );

//int
//gethostname(
//    OUT char *name,
//    IN int namelen
//    );

void
p_query(
    char *msg
    );

extern
void
putshort(
    u_short s,
    u_char *msgp
    );

void
putlong(
    u_long l,
    u_char *msgp
    );

void
_res_close(
    void
    );

//DWORD
//sendv(
//    CSOCKET *      s,           /* socket descriptor */
//    struct iovec  *iov,         /* array of vectors */
//    int            iovcnt       /* size of array */
//    );

//int
//strcasecmp(
//    char *s1,
//    char *s2
//    );
//
//int
//strncasecmp(
//    char *s1,
//    char *s2,
//    int   n
//    );
//
//struct hostent *
//myhostent (
//    void
//    );
//
//struct hostent *
//localhostent (
//    void
//    );
//
//struct hostent *
//dnshostent (
//    void
//    );
//
//BOOL
//querydnsaddrs (
//    IN LPDWORD *Array,
//    IN PVOID Buffer
//    );
//
//DWORD
//BytesInHostent (
//    PHOSTENT Hostent
//    );
//
//DWORD
//CopyHostentToBuffer (
//    char FAR *Buffer,
//    int BufferLength,
//    PHOSTENT Hostent
//    );
//
//struct hostent *
//_gethtbyname (
//    IN char *name
//    );

BOOL
OkToUseInternetAsyncGetHostByName(
    VOID
    );

LPHOSTENT
InternetAsyncGetHostByName(
    IN LPSTR lpszHostName,
    OUT LPDWORD lpdwTtl
    );

LPWINSOCK_TLS_DATA
InternetGetResolverInfo(
    VOID
    );

LPHOSTENT
getanswer(
    OUT querybuf *answer,
    OUT int      *ttl,
    IN int       anslen,
    IN int       iquery
    );

//ULONG
//SockNbtResolveName (
//    IN PCHAR Name
//    );

//PHOSTENT
//QueryHostentCache (
//    IN LPSTR Name OPTIONAL,
//    IN DWORD IpAddress OPTIONAL
//    );

//FILE *
//SockOpenNetworkDataBase(
//    IN  char *Database,
//    OUT char *Pathname,
//    IN  int   PathnameLen,
//    IN  char *OpenFlags
//    );
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\secinit.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    secinit.h

Abstract:

    Contains prototypes for indirected security functions

Author:

    Sophia Chung (sophiac) 7-Feb-1996

Revision History:

--*/

#if !defined(_SECINIT_)

#define _SECINIT_

#if defined(__cplusplus)
extern "C" {
#endif

#include <sspi.h>

extern CRITICAL_SECTION InitializationSecLock;

extern PSecurityFunctionTable   GlobalSecFuncTable;
extern WIN_VERIFY_TRUST_FN      pWinVerifyTrust;
extern WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;
extern SSL_CRACK_CERTIFICATE_FN pSslCrackCertificate;
extern SSL_FREE_CERTIFICATE_FN  pSslFreeCertificate;

extern HCERTSTORE   g_hMyCertStore;
extern BOOL         g_bOpenMyCertStore;
extern BOOL         g_fDoSpecialMagicForSGCCerts;

#define g_EnumerateSecurityPackages \
        (*(GlobalSecFuncTable->EnumerateSecurityPackagesA))
#define g_AcquireCredentialsHandle  \
        (*(GlobalSecFuncTable->AcquireCredentialsHandleA))
#define g_FreeCredentialsHandle     \
        (*(GlobalSecFuncTable->FreeCredentialHandle))
#define g_InitializeSecurityContext \
        (*(GlobalSecFuncTable->InitializeSecurityContextA))
#define g_DeleteSecurityContext     \
        (*(GlobalSecFuncTable->DeleteSecurityContext))
#define g_QueryContextAttributes    \
        (*(GlobalSecFuncTable->QueryContextAttributesA))
#define g_FreeContextBuffer         \
        (*(GlobalSecFuncTable->FreeContextBuffer))
#define g_SealMessage               \
        (*((SEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved3))
#define g_UnsealMessage             \
        (*((UNSEAL_MESSAGE_FN)GlobalSecFuncTable->Reserved4))

LONG WINAPI WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD);

// Don't use WinVerifyTrust directly to verify secure channel connections.
// Use the wininet wrapper WinVerifySecureChannel instead.
#define g_WinVerifyTrust \
        pWinVerifyTrust


#define g_SslCrackCertificate \
        pSslCrackCertificate

#define g_SslFreeCertificate pSslFreeCertificate
        

typedef PSecurityFunctionTable  (APIENTRY *INITSECURITYINTERFACE) (VOID);

#define CRYPT_INSTALL_DEFAULT_CONTEXT_NAME      "CryptInstallDefaultContext"

typedef BOOL
(WINAPI * CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
);

#define CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME    "CryptUninstallDefaultContext"
    
typedef BOOL
(WINAPI * CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)   
(
    HCRYPTDEFAULTCONTEXT hDefaultContext,
    IN DWORD dwFlags,
    IN void *pvReserved
);

typedef PCCERT_CHAIN_CONTEXT
(WINAPI *CERT_FIND_CHAIN_IN_STORE_FN)
(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CHAIN_CONTEXT pPrevChainContext
);

#define CERT_FIND_CHAIN_IN_STORE_NAME            "CertFindChainInStore"

typedef VOID
(WINAPI *CERT_FREE_CERTIFICATE_CHAIN_FN)
(
    IN PCCERT_CHAIN_CONTEXT pChainContext
);

#define CERT_FREE_CERTIFICATE_CHAIN_NAME        "CertFreeCertificateChain"


extern CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext;
extern CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext;
extern CERT_FIND_CHAIN_IN_STORE_FN        g_CertFindChainInStore;
extern CERT_FREE_CERTIFICATE_CHAIN_FN     g_CertFreeCertificateChain;

extern HCRYPTPROV GlobalFortezzaCryptProv;

#define LOCK_SECURITY()   EnterCriticalSection( &InitializationSecLock )
#define UNLOCK_SECURITY() LeaveCriticalSection( &InitializationSecLock )


//
// prototypes
//

VOID
SecurityInitialize(
    VOID
    );

VOID
SecurityTerminate(
    VOID
    );

DWORD
ReopenMyCertStore(
    VOID
    );

DWORD
CloseMyCertStore(
    VOID
    );

DWORD
LoadSecurity(
    VOID
    );

VOID
UnloadSecurity(
    VOID
    );

DWORD
LoadWinTrust(
    VOID
    );


BOOL
IsFortezzaInstalled(
    VOID
    );

BOOL AttemptedFortezzaLogin(
    VOID
    );

DWORD FortezzaLogOn(
    HWND hwnd
    );

#if defined(__cplusplus)
}
#endif

#endif // _SECINIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\registry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Prototypes, etc., for dll\registry.c

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Revision History:

    20-Mar-1995
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

#define INTERNET_POLICY_KEY         "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"


//
// prototypes
//

VOID
EnsureInternetSettingsKeyCached(
    VOID
    );

DWORD
CloseInternetSettingsKey(
    VOID
    );

DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    );

DWORD
GetMyDomainName(
    OUT LPSTR DomainName,
    IN OUT LPDWORD Length
    );

BOOL
GetFileExtensionFromMimeType(
    IN LPCSTR  lpszMimeType,
    IN DWORD   dwMimeLen,
    IN LPSTR   lpszFileExtension,
    IN OUT LPDWORD lpdwLen
    );

//DWORD
//InternetGetComputerName(
//    OUT LPSTR Buffer,
//    IN OUT LPDWORD Length
//    );

DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    );

DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

#ifdef WININET6
DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );
#endif

DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );


DWORD
InternetWriteRegistryString(
    IN LPCSTR ParameterName,
    IN LPSTR ParameterValue
    );

//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

DWORD
CreateMimeExclusionTableForCache(VOID);

DWORD
CreateHeaderExclusionTableForCache(VOID);

VOID
DestroyMimeExclusionTableForCache(VOID);

VOID
DestroyHeaderExclusionTableForCache(VOID);

#if INET_DEBUG

VOID
DbgRegKey_Init(
    VOID
    );

VOID
DbgRegKey_Terminate(
    VOID
    );

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    );

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    );

LONG
DbgRegCloseKey(
    IN HKEY hKey
    );

#define INITIALIZE_DEBUG_REGKEY() \
    DbgRegKey_Init()

#define TERMINATE_DEBUG_REGKEY() \
    DbgRegKey_Terminate()

#define REGOPENKEY(a, b, c) \
    DbgRegOpenKey((a), (b), (c), __FILE__, __LINE__)

#define REGOPENKEYEX(a, b, c, d, e) \
    DbgRegOpenKeyEx((a), (b), (c), (d), (e), __FILE__, __LINE__)

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    DbgRegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i), __FILE__, __LINE__)

#define REGCLOSEKEY(a) \
    DbgRegCloseKey(a)

#else

#define INITIALIZE_DEBUG_REGKEY() \
    /* NOTHING */

#define TERMINATE_DEBUG_REGKEY() \
    /* NOTHING */

#define REGOPENKEY(a, b, c) \
    RegOpenKey((a), (b), (c))

#define REGOPENKEYEX(a, b, c, d, e) \
    RegOpenKeyEx((a), (b), (c), (d), (e))

#define REGCREATEKEYEX(a, b, c, d, e, f, g, h, i) \
    RegCreateKeyEx((a), (b), (c), (d), (e), (f), (g), (h), (i))

#define REGCLOSEKEY(a) \
    RegCloseKey(a)

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\thrdinfo.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.h

Abstract:

    Per-thread structure definitions/macros

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define INTERNET_THREAD_INFO_SIGNATURE  'drhT'  // "Thrd"

//
// forward references
//

class CFsm;

//
// types
//

//
// INTERNET_THREAD_INFO - per-thread information, handily referenced via a TLS
// slot
//

typedef struct _INTERNET_THREAD_INFO {

    //
    // List - doubly linked list that we delete on DLL_PROCESS_DETACH
    //

    LIST_ENTRY List;

#if INET_DEBUG

    //
    // Signature - lets us know that this structure is probably an
    // INTERNET_THREAD_INFO
    //

    DWORD Signature;

#endif

    //
    // ThreadId - used to identify this thread within a process
    //

    DWORD ThreadId;

    //
    // ErrorNumber - arbitrary error code, supplied in InternetSetLastError
    //

    DWORD ErrorNumber;

    //
    // hErrorText - we store the last error text on a per-thread basis. This
    // handle identifies a moveable buffer
    //

    HLOCAL hErrorText;

    //
    // ErrorTextLength - length of the error text in hErrorText
    //

    DWORD ErrorTextLength;

    //
    // Context - arbitrary app-supplied context value. This is used by
    // StatusCallback to identify which operation the callback is for. We keep
    // the context in the per-thread information so we don't have to pass it
    // around, nor across the wire in the case of an RPC callback
    //

    DWORD_PTR Context;

    //
    // hObject - the current Internet object handle being used in this API. We
    // need this to maintain context e.g. when we want to get timeout values
    //

    HINTERNET hObject;

    //
    // hObjectMapped - this is the address of the real object mapped to hObject
    //

    HINTERNET hObjectMapped;

    //
    // IsAsyncWorkerThread - TRUE if this thread is an async worker thread
    //

    BOOL IsAsyncWorkerThread;

    //
    // InCallback - TRUE if we have made an app callback. Used to detect
    // re-entrancy
    //

    BOOL InCallback;

    //
    // IsAutoProxyProxyThread - TRUE if we are the thread running auto-proxy requests.  Used
    //  to allow direct shutdown of auto-proxy during PROCESS_DETACH
    //

    BOOL IsAutoProxyProxyThread;

    //
    // NestedRequests - incremented when we detect that we're processing an API
    // in the async worker thread context. If this API then calls other APIs,
    // then we need to treat (mapped) handles differently in the called APIs
    //

    DWORD NestedRequests;

    //
    // dwMappedErrorCode - the real error code returned by e.g. a winsock API,
    // before it was mapped to a WinInet error
    //

    DWORD dwMappedErrorCode;

    //
    // Fsm - currently executing Finite State Machine
    //

    CFsm * Fsm;

#ifdef ENABLE_DEBUG

    //
    // IsAsyncSchedulerThread - TRUE if this INTERNET_THREAD_INFO belongs to the
    // one-and-only async scheduler thread
    //

    BOOL IsAsyncSchedulerThread;

    //
    // per-thread debug variables
    //

    //
    // Pointer to LIFO (stack) of INTERNET_DEBUG_RECORDs. Used to generate
    // indented call-tracing for diagnostics
    //

    LPINTERNET_DEBUG_RECORD Stack;

    //
    // CallDepth - nesting level for calls
    //

    int CallDepth;

    //
    // IndentIncrement - the current indent level. Number of spaces
    //

    int IndentIncrement;

    //
    // StartTime and StopTime - used for timing calls to e.g. send(), recv()
    //

    DWORD StartTime;
    DWORD StopTime;

    DWORD MajorCategoryFlags;
    DWORD MinorCategoryFlags;

#endif // #ifdef ENABLE_DEBUG

} INTERNET_THREAD_INFO, *LPINTERNET_THREAD_INFO;

//
// macros
//

//
// InternetClearLastError - frees the response text buffer for this thread
//

#define InternetClearLastError() \
    InternetSetLastError(0, NULL, 0, 0)

//
// InternetResetContext - resets the per-thread call-back context value
//

#define InternetResetContext() \
    InternetSetContext(INTERNET_NO_CALLBACK)

//
// InternetResetObjectHandle - resets the per-thread current object handle
//

#define InternetResetObjectHandle() \
    InternetSetObjectHandle(NULL)

//
// _InternetIncNestingCount - increments nesting level count
//

#define _InternetIncNestingCount() \
    lpThreadInfo->NestedRequests++;

// ** debug version
//#define _InternetIncNestingCount() \
//    if ( lpThreadInfo->NestedRequests > 0xffff ) { \
//        OutputDebugString("InternetIncNestingCount, inc over threshold, contact arthurbi, x68073 (sechs)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests++;

//
// _InternetDecNestingCount - decrements nesting level count
//

#define _InternetDecNestingCount(dwNestingLevel) \
    lpThreadInfo->NestedRequests -= dwNestingLevel;

// ** debug version
//#define _InternetDecNestingCount(dwNestingLevel) \
//    if ( lpThreadInfo->NestedRequests == 0 ) { \
//        OutputDebugString("InternetDecNestingCount, attempting to dec 0, contact arthurbi, x68073 (sieben)\n"); \
//        DebugBreak(); \
//    } \
//    if ( dwNestingLevel != 1 && dwNestingLevel != 0 ) { \
//        OutputDebugString("InternetDecNestingCount, invalid nesting level, contact arthurbi, x68073 (acht)\n"); \
//        DebugBreak(); \
//    } \
//    lpThreadInfo->NestedRequests -= dwNestingLevel;

//
// _InternetSetObjectHandle - set the object handle given the thread info block
//

#define _InternetSetObjectHandle(lpThreadInfo, hInternet, hMapped) \
    DEBUG_PRINT(HTTP,   \
            INFO,       \
            ("Setting new obj handle on thrd=%x, old=%x, new=%x (map: old=%x, new=%x)\n", \
            lpThreadInfo, \
            lpThreadInfo->hObject, \
            hInternet, \
            lpThreadInfo->hObjectMapped, \
            hMapped \
            )); \
    if ( lpThreadInfo->IsAutoProxyProxyThread ) \
        GlobalProxyInfo.SetAbortHandle(hInternet); \
    lpThreadInfo->hObject = hInternet; \
    lpThreadInfo->hObjectMapped = hMapped;

//
// _InternetSetContext - set the object context given the thread info block
//

#define _InternetSetContext(lpThreadInfo, dwContext) \
    DEBUG_PRINT(HTTP,   \
            INFO,       \
            ("Setting new context on thrd=%x, old=%x, new=%x\n", \
            lpThreadInfo, \
            lpThreadInfo->Context, \
            dwContext \
            )); \
    lpThreadInfo->Context = dwContext;

//
// _InternetClearLastError - clear the last error info given the thread info
// block
//

#define _InternetClearLastError(lpThreadInfo) \
    _InternetSetLastError(lpThreadInfo, 0, NULL, 0, 0)

//
// _InternetResetObjectHandle - clear the object handle given the thread info
// block
//

#define _InternetResetObjectHandle(lpThreadInfo) \
    _InternetSetObjectHandle(lpThreadInfo, NULL, NULL)

//
// _InternetGetObjectHandle - retrieves the object handle from the per-thread
// info block
//

#define _InternetGetObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObject

//
// _InternetGetMappedObjectHandle - retrieves the mapped object handle from the
// per-thread info block
//

#define _InternetGetMappedObjectHandle(lpThreadInfo) \
    lpThreadInfo->hObjectMapped

//
// _InternetGetContext - retrieve the context from the per-thread info block
//

#define _InternetGetContext(lpThreadInfo) \
    lpThreadInfo->Context

//
// _InternetResetContext - reset context in per-thread info block given
// per-thread info block
//

#define _InternetResetContext(lpThreadInfo) \
    _InternetSetContext(lpThreadInfo, 0)

//
// InternetDisableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetDisableAsync(lpThreadInfo) \
    _InternetSetAsync(FALSE)

//
// InternetEnableAsync - turns off the async worker thread indication in the
// thread info block
//

#define _InternetEnableAsync(lpThreadInfo, Val) \
    _InternetSetAsync(TRUE)

//
// _InternetGetAsync - returns the async worker thread indication from the
// thread info block
//

#define _InternetGetAsync(lpThreadInfo) \
    lpThreadInfo->IsAsyncWorkerThread

//
// _InternetSetAsync - turns on or off the async worker thread indication in the
// thread info block
//

#define _InternetSetAsync(lpThreadInfo, Val) \
    lpThreadInfo->IsAsyncWorkerThread = Val

#define _InternetGetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback

#define _InternetSetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = TRUE

#define _InternetResetInCallback(lpThreadInfo) \
    lpThreadInfo->InCallback = FALSE

#define _InternetSetAutoProxy(lpThreadInfo) \
    lpThreadInfo->IsAutoProxyProxyThread = TRUE

#if INET_DEBUG

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE)

#else

#define CHECK_INTERNET_THREAD_INFO(lpThreadInfo) \
    /* NOTHING */

#endif

//
// prototypes
//

#define UI_ACTION_CODE_NONE_TAKEN                   0
#define UI_ACTION_CODE_BLOCKED_FOR_INTERNET_HANDLE  1
#define UI_ACTION_CODE_BLOCKED_FOR_USER_INPUT       2
#define UI_ACTION_CODE_USER_ACTION_COMPLETED        3


DWORD
ChangeUIBlockingState(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwError,
    OUT LPDWORD  lpdwActionTaken,
    OUT LPDWORD  lpdwResultCode,
    IN OUT LPVOID * lplpResultData
    );

DWORD
ResumeAfterUserInput(
    IN HINTERNET hRequestMapped,
    IN DWORD     dwResultCode,
    OUT LPBOOL   pfItemResumed
    );

LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    );

VOID
InternetDestroyThreadInfo(
    VOID
    );

VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

VOID
InternetTerminateThreadInfo(
    VOID
    );

LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    );

VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    );

DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    );

DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo
    );

DWORD
InternetIndicateStatus(
    IN DWORD dwInternetStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    );

DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

#define SLE_APPEND          0x00000001
#define SLE_ZERO_TERMINATE  0x00000002

DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    );

LPSTR
InternetLockErrorText(
    VOID
    );

VOID
InternetUnlockErrorText(
    VOID
    );

VOID
InternetSetContext(
    IN DWORD_PTR dwContext
    );

VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    );

HINTERNET
InternetGetObjectHandle(
    VOID
    );

HINTERNET
InternetGetMappedObjectHandle(
    VOID
    );

//
// external data
//

extern SERIALIZED_LIST ThreadInfoList;

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\rescache.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains prototypes, structures, manifests for rescache.c

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// manifests
//

#define RESOLVER_CACHE_DISABLED         -1
#define MINIMUM_RESOLVER_CACHE_ENTRIES  1
#define MAXIMUM_RESOLVER_CACHE_ENTRIES  128 // arbitrary, just in case user decides to wack it up
#define LIVE_FOREVER                    ((DWORD)-1)
#define LIVE_DEFAULT                    ((DWORD)0)

//
// types
//

//
// RESOLVER_CACHE_ENTRY_STATE - the cache entry can be in-use, unused, or
// awaiting deletion
//

typedef enum {
    ENTRY_UNUSED = 1,
    ENTRY_IN_USE,
    ENTRY_DELETE
} RESOLVER_CACHE_ENTRY_STATE;

//
// RESOLVER_CACHE_ENTRY - we maintain a doubly-linked list of these. The list is
// maintained in MRU order - we throw out the one at the far end of the list.
// Because the name resolution APIs do not return the time-to-live in the DNS
// answer, we cannot honor it (an argument for why we should let the resolver
// do the caching - if only all platforms did this). When we get a response we
// set the ExpirationTime field to a default value. On future cache hits, if
// the current time is >= the ExpirationTime value then we must throw out this
// entry and refresh the cache
//

typedef struct {

    //
    // ListEntry - cache entries comprise a double-linked list
    //

    LIST_ENTRY ListEntry;

    //
    // ExpirationTime - formed by adding the time-to-live value from the DNS
    // response to the result obtained from time(). If ever time() returns a
    // value >= ExpirationTime, this entry is stale and must be refreshed
    //

    DWORD ExpirationTime;

    //
    // HostName - original name that resolved to this entry
    //

    LPSTR HostName;

    //
    // State - unused, in-use, or delete
    //

    RESOLVER_CACHE_ENTRY_STATE State;

    //
    // ReferenceCount - only change State when zero
    //

    LONG ReferenceCount;

    //
    // AddrInfo - pointer to a list of addrinfo structures
    //

    LPADDRINFO AddrInfo;

} RESOLVER_CACHE_ENTRY, *LPRESOLVER_CACHE_ENTRY;

//
// prototypes
//

#if defined(__cplusplus)
extern "C" {
#endif

VOID
InitializeResolverCache(
    VOID
    );

VOID
TerminateResolverCache(
    VOID
    );

LPRESOLVER_CACHE_ENTRY
QueryResolverCache(
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL,
    OUT LPADDRINFO * AddrInfo,
    OUT LPDWORD TimeToLive
    );

VOID
AddResolverCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO lpAddrInfo,
    IN DWORD TimeToLive
    );

VOID
FlushResolverCache(
    VOID
    );

VOID
ThrowOutResolverCacheEntry(
    IN LPADDRINFO lpAddrinfo
    );

VOID
ReleaseResolverCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY cacheEntry
    );

#if defined(__cplusplus)
}
#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.h

Abstract:

    Contains name resolution cache structure definition

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

#if defined(__cplusplus)
extern "C" {
#endif

DWORD
InitNameresCache(
    VOID
);

DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpAddressInfoList
);

DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
);

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
);

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfoList
);

DWORD
DeinitNameresCache(
    VOID
);

#if defined(__cplusplus)
}
#endif

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
        ulong           ipsi_forwarding;
        ulong           ipsi_defaultttl;
        ulong           ipsi_inreceives;
        ulong           ipsi_inhdrerrors;
        ulong           ipsi_inaddrerrors;
        ulong           ipsi_forwdatagrams;
        ulong           ipsi_inunknownprotos;
        ulong           ipsi_indiscards;
        ulong           ipsi_indelivers;
        ulong           ipsi_outrequests;
        ulong           ipsi_routingdiscards;
        ulong           ipsi_outdiscards;
        ulong           ipsi_outnoroutes;
        ulong           ipsi_reasmtimeout;
        ulong           ipsi_reasmreqds;
        ulong           ipsi_reasmoks;
        ulong           ipsi_reasmfails;
        ulong           ipsi_fragoks;
        ulong           ipsi_fragfails;
        ulong           ipsi_fragcreates;
        ulong           ipsi_numif;
        ulong           ipsi_numaddr;
        ulong           ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
        ulong           icmps_msgs;
        ulong           icmps_errors;
        ulong           icmps_destunreachs;
        ulong           icmps_timeexcds;
        ulong           icmps_parmprobs;
        ulong           icmps_srcquenchs;
        ulong           icmps_redirects;
        ulong           icmps_echos;
        ulong           icmps_echoreps;
        ulong           icmps_timestamps;
        ulong           icmps_timestampreps;
        ulong           icmps_addrmasks;
        ulong           icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
        ICMPStats       icsi_instats;
        ICMPStats       icsi_outstats;
} ICMPSNMPInfo;

#define IP_FORWARDING           1
#define IP_NOT_FORWARDING       2

typedef struct IPAddrEntry {
        ulong           iae_addr;
        ulong           iae_index;
        ulong           iae_mask;
        ulong           iae_bcastaddr;
        ulong           iae_reasmsize;
        ushort          iae_context;
        ushort          iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
        ulong           ire_context;
} IPRouteEntry;

typedef struct IPRouteEntry95 {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
} IPRouteEntry95;

typedef struct AddrXlatInfo {
        ulong           axi_count;
        ulong           axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                                 1
#define ICMP_MIB_STATS_ID                               1

#define AT_MIB_ADDRXLAT_INFO_ID                 1
#define AT_MIB_ADDRXLAT_ENTRY_ID                0x101

#define IP_MIB_RTTABLE_ENTRY_ID                 0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID               0x102

#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\xpltfrm.h ===
#ifndef __XPLTFRM_H__
#define __XPLTFRM_H__

#include <platform.h>

#ifdef unix
#define LONGLONG_ZERO 0LL
#define __int8 char
#define DIR_SEPARATOR_CHAR TEXT('/')
#define DIR_SEPARATOR_STRING TEXT("/")
#define WEBDIR_STRING "Web/"
// Follwing is workaround for MainWin Registry API bug 2053.
#else
#define LONGLONG_ZERO 0i64
#define DIR_SEPARATOR_CHAR TEXT('\\')
#define DIR_SEPARATOR_STRING TEXT("\\")
#define WEBDIR_STRING "Web\\" 
#endif /* unix */

#endif /* __XPLTFRM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef	LLINFO_INCLUDED
#define	LLINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define	IF_MIB_STATS_ID		1

#define	MAX_PHYSADDR_SIZE	8

typedef struct IPNetToMediaEntry {
	ulong			inme_index;
	ulong			inme_physaddrlen;
	uchar			inme_physaddr[MAX_PHYSADDR_SIZE];
	ulong			inme_addr;
	ulong			inme_type;
} IPNetToMediaEntry;

#define	INME_TYPE_OTHER			1
#define	INME_TYPE_INVALID		2
#define	INME_TYPE_DYNAMIC		3
#define	INME_TYPE_STATIC		4

#define	MAX_IFDESCR_LEN			256

#define	IFE_FIXED_SIZE	offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


#endif // LLINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\urlcache.h ===
#ifndef URLCACHE_H

#define URLCACHE_H

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    urlcache.h

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:

    Rajeev Dujari (rajeevd) 10-Apr-1997

Revision History:

    10-Apr-97 rajeevd
        Created

--*/

struct CACHE_ENTRY_INFOEX : INTERNET_CACHE_ENTRY_INFO
{
    FILETIME ftDownload;
    FILETIME ftPostCheck;
};

DWORD
UrlCacheRetrieve
(
    IN  LPSTR                pszUrl,
    IN  BOOL                 fRedir,
    OUT HANDLE*              phStream,
    OUT CACHE_ENTRY_INFOEX** ppCEI
);

void UrlCacheFlush (void); // check registry to flush cache

DWORD 
UrlCacheCreateFile
(
    IN LPCSTR szUrl, 
    IN OUT LPTSTR szFile, 
    IN LPTSTR szExt,
    IN HANDLE* phfHandle,
    IN BOOL fCreatePerUser = FALSE
);

struct AddUrlArg
{
    LPCSTR   pszUrl;
    LPCSTR   pszRedirect;
    LPCTSTR  pszFilePath;
    DWORD    dwFileSize;
    LONGLONG qwExpires;
    LONGLONG qwLastMod;
    LONGLONG qwPostCheck;
    FILETIME ftCreate;
    DWORD    dwEntryType;
    LPCSTR   pbHeaders;
    DWORD    cbHeaders;
    LPCSTR   pszFileExt;
    BOOL     fImage;
    DWORD    dwIdentity;
};


DWORD UrlCacheCommitFile (IN AddUrlArg* pArgs);

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile);

DWORD UrlCacheSendNotification (IN DWORD dwOp);

BOOL IsExpired
(
    CACHE_ENTRY_INFOEX* pInfo, 
    DWORD dwCacheFlags, 
    BOOL* pfLaxyUpdate
);

extern const char vszUserNameHeader[4];

#ifdef UNIX
extern "C"
#endif /* UNIX */
BOOL DLLUrlCacheEntry( IN DWORD Reason );

BOOL GetIE5ContentPath( LPSTR szPath);

DWORD SwitchIdentity(GUID* guidIdentity);
DWORD RemoveIdentity(GUID* guidIdentity);
DWORD AlterIdentity(DWORD dwControl);

#ifdef WININET6
DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw);
DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw);
#endif

#endif //URLCACHE.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\ntddtcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ntddtcp.h

Abstract:

    This header file defines constants and types for accessing the NT
    TCP driver.

Author:

    Mike Massa (mikemas)    August 13, 1993

Revision History:

--*/

#ifndef _NTDDTCP_
#define _NTDDTCP_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"


//
// Security Filter Support
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The following ioctls may be used to access the security filter
// database. The ioctls may be issued on any TCP/IP device object. All of them
// require Administrator privilege. These ioctls do not update the registry
// parameters used to initialize security filtering when an interface is
// installed.
//
// The TCP_QUERY_SECURITY_FILTER_STATUS ioctl returns the current status of
// security filtering - enabled or disabled.
//
// The TCP_SET_SECURITY_FILTER_STATUS ioctl modifies the status of security
// filtering. Changing the filtering status does not change the contents of
// the filter database.
//
// The following ioctls manipulate the filter database. They operate the same
// whether security filtering is enabled or disabled. If filtering is disabled,
// any changes will take effect only when filtering is enabled.
//
// The TCP_ADD_SECURITY_FILTER ioctl registers an {Interface, Protocol, Value}
// tuple. The TCP_DELETE_SECURITY_FILTER ioctl deregisters an
// {Interface, Protocol, Value} tuple. The TCP_ENUMERATE_SECURITY_FILTER ioctl
// returns the list of {Interface, Protocol, Value} filters currently
// registered.
//
// Each of these ioctls takes an {Interface, Protocol, Value} tuple as an input
// parameter. Zero is a wildcard value. If the Interface or Protocol elements
// are zero, the operation applies to all interfaces or protocols, as
// appropriate. The meaning of a zero Value element depends on the ioctl.
// For an ADD, a zero Value causes all values to be permissible. For a DELETE,
// a zero Value causes all all values to be rejected. In both cases, any
// previously registered values are purged from the database. For an
// ENUMERATE, a zero Value just causes all registered values to be enumerated,
// as opposed to a specific value.
//
// For all ioctls, a return code of STATUS_INVALID_ADDRESS indicates that
// the IP address submitted in the input buffer does not correspond to
// an interface which exists in the system. A code of
// STATUS_INVALID_PARAMETER possibly indicates that the Protocol number
// submitted in the input buffer does not correspond to a transport protocol
// available in the system.
//

//
// Structures used in Security Filter IOCTLs.
//

//
// Structure contained in the input buffer of
// TCP_SET_SECURITY_FILTER_STATUS ioctls and the output buffer of
// TCP_QUERY_SECURITY_FILTER_STATUS ioctls.
//
struct tcp_security_filter_status {
    ULONG  FilteringEnabled;   // FALSE if filtering is (to be) disabled.
};                             // Any other value indicates that filtering
                               // is (to be) enabled.

typedef struct tcp_security_filter_status
                    TCP_SECURITY_FILTER_STATUS,
                   *PTCP_SECURITY_FILTER_STATUS;


//
// The TCPSecurityFilterEntry structure, defined in tcpinfo.h, is contained in
// the input buffer of TCP_[ADD|DELETE|ENUMERATE]_SECURITY_FILTER ioctls.
//

//
// The TCPSecurityFilterEnum structure, defined in tcpinfo.h, is  contained
// in the output buffer of TCP_ENUMERATE_SECURITY_FILTER ioctls. The output
// buffer passed in the ioctl must be large enough to contain at least this
// structure or the call will fail. The structure is followed immediately in
// the buffer by an array of zero or more TCPSecurityFilterEntry structures.
// The number of TCPSecurityFilterEntry structures is specified by the
// tfe_entries_returned field of the TCPSecurityFilterEnum.
//

//
// TCP/UDP/RawIP IOCTL code definitions
//

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_SET_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ADD_SECURITY_FILTER  \
            _TCP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_DELETE_SECURITY_FILTER  \
            _TCP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ENUMERATE_SECURITY_FILTER  \
            _TCP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#endif  // ifndef _NTDDTCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\tdistat.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDISTAT.H - TDI status code definitions.
//
// This file contains the TDI status code definitions.

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define	TDI_BUFFER_TOO_BIG		35			// Send buffer was too big.
#define TDI_ITEM_NOT_FOUND      36          // Item not found.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define	TDI_BUFFER_TOO_BIG		STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING
#define TDI_ITEM_NOT_FOUND      STATUS_OBJECT_NAME_NOT_FOUND


#endif  // NT

#define	TDI_OPTION_EOL				0

#define	TDI_ADDRESS_OPTION_REUSE	1
#define	TDI_ADDRESS_OPTION_DHCP		2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\tdiinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDIINFO.H - TDI Query/SetInfoEx definitons.
//
//	This file contains definitions for the extended TDI query and set info.
//	calls.
//

#ifndef TDI_INFO_INCLUDED
#define TDI_INFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of an entity ID.
typedef struct TDIEntityID {
	ulong		tei_entity;
	ulong		tei_instance;
} TDIEntityID;

//* Structure of an object ID.
typedef struct TDIObjectID {
	TDIEntityID	toi_entity;
	ulong		toi_class;
	ulong		toi_type;
	ulong		toi_id;
} TDIObjectID;

#define	MAX_TDI_ENTITIES			512

#define	INFO_CLASS_GENERIC			0x100
#define	INFO_CLASS_PROTOCOL			0x200
#define	INFO_CLASS_IMPLEMENTATION	0x300

#define	INFO_TYPE_PROVIDER			0x100
#define	INFO_TYPE_ADDRESS_OBJECT	0x200
#define	INFO_TYPE_CONNECTION		0x300

#define	ENTITY_LIST_ID				0

#define	GENERIC_ENTITY				0

#define	CO_TL_ENTITY				0x400
#define	CL_TL_ENTITY				0x401

#define	ER_ENTITY					0x380

#define	CO_NL_ENTITY				0x300
#define	CL_NL_ENTITY				0x301

#define	AT_ENTITY					0x280

#define	IF_ENTITY					0x200

#define	CONTEXT_SIZE				16


//* The following are IDs supported by all entities. They are of class
//	GENERIC and type PROVIDER.

#define	ENTITY_TYPE_ID				1			// The ID to get the entity
												// type. The return from this
												// type is an unsigned integer
												// (see below).


// Valid values to get back from entity type ID query.
#define	CO_TL_NBF					0x400		// Entity implements NBF prot.
#define	CO_TL_SPX					0x402		// Entity implements SPX prot.
#define	CO_TL_TCP					0x404		// Entity implements TCP prot.
#define	CO_TL_SPP					0x406		// Entity implements SPP prot.

#define	CL_TL_NBF					0x401		// CL NBF protocol.
#define	CL_TL_UDP					0x403		// Entity implements UDP.

#define	ER_ICMP						0x380		// The ICMP protocol.

#define	CL_NL_IPX					0x301		// Entity implements IPX.
#define	CL_NL_IP					0x303		// Entity implements IP.

#define	AT_ARP						0x280		// Entity implements ARP.
#define	AT_NULL						0x282		// Entity does no address
												// translation.

#define	IF_GENERIC					0x200		// Generic interface.
#define	IF_MIB						0x202		// Supports MIB-2 interface.


/*NOINC*/
//
// NT DeviceIoControl definitions for TdiExtendedInformationEx functions.
//

//
// QueryInformationEx IOCTL. The return buffer is passed as the OutputBuffer
// in the DeviceIoControl request. This structure is passed as the
// InputBuffer.
//
struct tcp_request_query_information_ex {
	TDIObjectID   ID;                     // object ID to query.
	uchar         Context[CONTEXT_SIZE];  // multi-request context. Zeroed
	                                      // for the first request.
};

typedef struct tcp_request_query_information_ex
        TCP_REQUEST_QUERY_INFORMATION_EX,
        *PTCP_REQUEST_QUERY_INFORMATION_EX;

//
// SetInformationEx IOCTL request structure. This structure is passed as the
// InputBuffer. The space allocated for the structure must be large enough
// to contain the structure and the set data buffer, which begins at the
// Buffer field. The OutputBuffer parameter in the DeviceIoControl is not used.
//
struct tcp_request_set_information_ex {
	TDIObjectID   ID;                // object ID to set.
	unsigned int  BufferSize;        // size of the set data buffer in bytes
	unsigned char Buffer[1];         // beginning of the set data buffer
};

typedef struct tcp_request_set_information_ex
               TCP_REQUEST_SET_INFORMATION_EX,
			   *PTCP_REQUEST_SET_INFORMATION_EX;


#endif // TDI_INFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
PASCAL FAR
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (PASCAL FAR * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\tstr.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tstr.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    16-Jan-1992 Danl
        Cut this info from \net\inc\tstring.h
    30-Jan-1992 JohnRo
        Added STRSTR().
        Use _wcsupr() instead of wcsupr() to keep PC-LINT happy.
        Added STRCMPI() and STRNCMPI().
        Fixed a few definitions which were missing MAKE_STR_FUNCTION etc.
    14-Mar-1992 JohnRo
        Avoid compiler warnings using WCSSIZE(), MEMCPY(), etc.
        Added TCHAR_TAB.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

#ifndef _TSTR_H_INCLUDED
#define _TSTR_H_INCLUDED

#include <ctype.h>              // isdigit(), iswdigit() eventually, etc.
#include <stdlib.h>             // atol(), _ultoa().
#include <string.h>             // memcpy(), strlen(), etc.
// Don't #define memmove to RtlMoveMemory for wchar.h
// because the protoypes don't match.
#pragma push_macro("memmove")
#undef memmove
#include <wchar.h>
#pragma pop_macro("memmove")


LPWSTR
ultow (
    IN DWORD Value,
    OUT LPWSTR Area,
    IN DWORD Radix
    );

LONG
wtol (
    IN LPWSTR Src
    );


#ifdef LM20_COMPATIBLE
#define MAKE_STR_FUNCTION(s)    s##f
#else
#define MAKE_STR_FUNCTION(s)    s
#endif


#if defined(UNICODE)

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(wtol)(Src)

#define ISALNUM(tchar)      iswalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      iswalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iswcntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      iswdigit(tchar)
#define ISGRAPH(tchar)      iswgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      iswlower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      iswprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      iswpunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      iswspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      iswupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     iswxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscat)((dest), (src))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(wcschr)((s1), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(wcscpy)((dest), (src))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(wcscspn)((s), (c))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(wcslen)(s)
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncat)((dest), (src), (n))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(wcsncpy)((dest), (src), (n))
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(wcsspn)((s1), (s2))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(wcsrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(wcswcs)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(_wcsupr)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(wcscmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(_wcsicmp)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(wcsncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_wcsnicmp)

#define TOLOWER(tchar)      towlower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      towupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(ultow)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  WCHAR

#else   // not UNICODE

//
// function macro prototypes
//

#define ATOL(Src)           (LONG)MAKE_STR_FUNCTION(atol)(Src)

#define ISALNUM(tchar)      isalnum(tchar)   // locale-dependent.
#define ISALPHA(tchar)      isalpha(tchar)   // locale-dependent.
#define ISCNTRL(tchar)      iscntrl(tchar)   // locale-dependent.
#define ISDIGIT(tchar)      isdigit(tchar)
#define ISGRAPH(tchar)      isgraph(tchar)   // locale-dependent.
#define ISLOWER(tchar)      islower(tchar)   // locale-dependent.
#define ISPRINT(tchar)      isprint(tchar)   // locale-dependent.
#define ISPUNCT(tchar)      ispunct(tchar)   // locale-dependent.
#define ISSPACE(tchar)      isspace(tchar)   // locale-dependent.
#define ISUPPER(tchar)      isupper(tchar)   // locale-dependent.
#define ISXDIGIT(tchar)     isxdigit(tchar)

#define STRCAT(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcat)((dest), (src))
#define STRNCAT(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncat)((dest), (src), (n))
// STRLEN: Get character count of s.
#define STRLEN(s)           (DWORD)MAKE_STR_FUNCTION(strlen)(s)
#define STRSPN(s1, s2)      (DWORD)MAKE_STR_FUNCTION(strspn)((s1), (s2))
#define STRCSPN(s, c)       (DWORD)MAKE_STR_FUNCTION(strcspn)((s), (c))
#define STRCPY(dest, src)   (LPTSTR)MAKE_STR_FUNCTION(strcpy)((dest), (src))
#define STRNCPY(dest, src, n) \
            (LPTSTR)MAKE_STR_FUNCTION(strncpy)((dest), (src), (n))
#define STRCHR(s1, c)       (LPTSTR)MAKE_STR_FUNCTION(strchr)((s1), (c))
#define STRRCHR             (LPTSTR)MAKE_STR_FUNCTION(strrchr)
#define STRSTR              (LPTSTR)MAKE_STR_FUNCTION(strstr)
#define STRUPR(s)           (LPTSTR)MAKE_STR_FUNCTION(strupr)(s)
#define STRREV(s)           (LPTSTR)MAKE_STR_FUNCTION(strrev)(s)

// these don't have formal parameters because we want to take the address of
// the mapped function in certain cases.  Modify as appropriate.
// Note that for these functions, lengths are in characters.

// compare functions: len is maximum number of characters being compared.
#define STRCMP              (LONG)MAKE_STR_FUNCTION(lstrcmp)
#define STRCMPI             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRICMP             (LONG)MAKE_STR_FUNCTION(lstrcmpi)
#define STRNCMP             (LONG)MAKE_STR_FUNCTION(strncmp)
#define STRNCMPI            (LONG)MAKE_STR_FUNCTION(_strnicmp)
#define STRNICMP            (LONG)MAKE_STR_FUNCTION(_strnicmp)

#define TOLOWER(tchar)      tolower(tchar)   // locale-dependent.
#define TOUPPER(tchar)      toupper(tchar)   // locale-dependent.

#define ULTOA(Value,Result,Radix) \
            (LPTSTR)MAKE_STR_FUNCTION(_ultoa)( (Value), (Result), (Radix) )

//
// manifests
//

#define _CHAR_TYPE  TCHAR

#endif // not UNICODE


//
// For the memory routines, the counts are always BYTE counts.
//
#define MEMCPY                  MAKE_STR_FUNCTION(memcpy)
#define MEMMOVE                 MAKE_STR_FUNCTION(memmove)

//
// These are used to determine the number of bytes (including the NUL
// terminator) in a string.  This will generally be used when
// calculating the size of a string for allocation purposes.
//

#define STRSIZE(p)      ((STRLEN(p)+1) * sizeof(TCHAR))
#define WCSSIZE(s)      ((MAKE_STR_FUNCTION(wcslen)(s)+1) * sizeof(WCHAR))


//
// character literals (both types)
//

#define TCHAR_EOS       ((_CHAR_TYPE)'\0')
#define TCHAR_STAR      ((_CHAR_TYPE)'*')
#define TCHAR_BACKSLASH ((_CHAR_TYPE)'\\')
#define TCHAR_FWDSLASH  ((_CHAR_TYPE)'/')
#define TCHAR_COLON     ((_CHAR_TYPE)':')
#define TCHAR_DOT       ((_CHAR_TYPE)'.')
#define TCHAR_SPACE     ((_CHAR_TYPE)' ')
#define TCHAR_TAB       ((_CHAR_TYPE)'\t')


//
// General purpose macro for casting character types to whatever type in vogue
// (as defined in this file)
//

#define MAKE_TCHAR(c)   ((_CHAR_TYPE)(c))

//
// IS_PATH_SEPARATOR
//
// lifted from curdir.c and changed to use TCHAR_ character literals, checks
// if a character is a path separator i.e. is a member of the set [\/]
//

#define IS_PATH_SEPARATOR(ch) ((ch == TCHAR_BACKSLASH) || (ch == TCHAR_FWDSLASH))

//
// The following 2 macros lifted from I_Net canonicalization files
//

#define IS_DRIVE(c)             ISALPHA(c)
#define IS_NON_ZERO_DIGIT(c)    (((c) >= MAKE_TCHAR('1')) && ((c) <= MAKE_TCHAR('9')))

//
// STRING_SPACE_REQD returns a number (of bytes) corresponding to the space
// required in which (n) characters can be accomodated
//

#define STRING_SPACE_REQD(n)    ((n) * sizeof(_CHAR_TYPE))

//
// DOWN_LEVEL_STRLEN returns the number of single-byte characters necessary to
// store a converted _CHAR_TYPE string. This will be WCHAR (or wchar_t) if
// UNICODE is defined or CHAR (or char) otherwise
//

#define DOWN_LEVEL_STRSIZE(n)   ((n) / sizeof(_CHAR_TYPE))

#endif  // _TSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\wininetd.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wininetd.h

Abstract:

    Contains the interface for the WININET diagnostic capabilities.

    This interface only exists in the debug version of WININET.DLL.
    Calling the debug functions in the retail version of the DLL will
    yield ERROR_INVALID_PARAMETER

Author:

    Richard L Firth (rfirth) 14-Jun-1995

Revision History:

    14-Jun-1995 rfirth
        Created

--*/

//
// manifests
//

//
// if the environment or registry variable "WininetLog" is set to !0 then the
// following values will be used for control, category and error level resp.
// These options generate "WININET.LOG" in the current directory
//

#define INTERNET_DEBUG_CONTROL_DEFAULT      (DBG_THREAD_INFO       \
                                            | DBG_CALL_DEPTH        \
                                            | DBG_ENTRY_TIME        \
                                            | DBG_PARAMETER_LIST    \
                                            | DBG_TO_FILE           \
                                            | DBG_INDENT_DUMP       \
                                            | DBG_SEPARATE_APIS     \
                                            | DBG_AT_ERROR_LEVEL    \
                                            | DBG_NO_ASSERT_BREAK   \
                                            | DBG_DUMP_LENGTH       \
                                            | DBG_NO_LINE_NUMBER    \
                                            | DBG_ASYNC_ID          \
                                            )
#define INTERNET_DEBUG_CATEGORY_DEFAULT     DBG_ANY
#define INTERNET_DEBUG_ERROR_LEVEL_DEFAULT  DBG_INFO

//
// options. These are the option values to use with InternetQueryOption()/
// InternetSetOption() to get/set the information described herein
//

#define INTERNET_OPTION_GET_DEBUG_INFO      1001
#define INTERNET_OPTION_SET_DEBUG_INFO      1002
#define INTERNET_OPTION_GET_HANDLE_COUNT    1003
#define INTERNET_OPTION_GET_TRIGGERS        1004
#define INTERNET_OPTION_SET_TRIGGERS        1005
#define INTERNET_OPTION_RESET_TRIGGERS      1006

#define INTERNET_FIRST_DEBUG_OPTION         INTERNET_OPTION_GET_DEBUG_INFO
#define INTERNET_LAST_DEBUG_OPTION          INTERNET_OPTION_RESET_TRIGGERS

//
// debug levels
//

#define DBG_INFO            0
#define DBG_WARNING         1
#define DBG_ERROR           2
#define DBG_FATAL           3
#define DBG_ALWAYS          99

//
// debug control flags - these flags control where the debug output goes (file,
// debugger, console) and how it is formatted
//

#define DBG_THREAD_INFO     0x00000001  // dump the thread id
#define DBG_CALL_DEPTH      0x00000002  // dump the call level
#define DBG_ENTRY_TIME      0x00000004  // dump the local time when the function is called
#define DBG_PARAMETER_LIST  0x00000008  // dump the parameter list
#define DBG_TO_DEBUGGER     0x00000010  // output via OutputDebugString()
#define DBG_TO_CONSOLE      0x00000020  // output via printf()
#define DBG_TO_FILE         0x00000040  // output via fprintf()
#define DBG_FLUSH_OUTPUT    0x00000080  // fflush() after every fprintf()
#define DBG_INDENT_DUMP     0x00000100  // indent dumped data to current level
#define DBG_SEPARATE_APIS   0x00000200  // empty line after leaving each API
#define DBG_AT_ERROR_LEVEL  0x00000400  // always output diagnostics >= InternetDebugErrorLevel
#define DBG_NO_ASSERT_BREAK 0x00000800  // don't call DebugBreak() in InternetAssert()
#define DBG_DUMP_LENGTH     0x00001000  // dump length information when dumping data
#define DBG_NO_LINE_NUMBER  0x00002000  // don't dump line number info
#define DBG_APPEND_FILE     0x00004000  // append to the log file (default is truncate)
#define DBG_LEVEL_INDICATOR 0x00008000  // dump error level indicator (E for Error, etc.)
#define DBG_DUMP_API_DATA   0x00010000  // dump data at API level (InternetReadFile(), etc.)
#define DBG_DELTA_TIME      0x00020000  // dump times as millisecond delta if DBG_ENTRY_TIME
#define DBG_CUMULATIVE_TIME 0x00040000  // dump delta time from start of trace if DBG_ENTRY_TIME
#define DBG_FIBER_INFO      0x00080000  // dump the fiber address if DBG_THREAD_INFO
#define DBG_THREAD_INFO_ADR 0x00100000  // dump INTERNET_THREAD_INFO address if DBG_THREAD_INFO
#define DBG_ARB_ADDR        0x00200000  // dump ARB address if DBG_THREAD_INFO
#define DBG_ASYNC_ID        0x00400000  // dump async ID
#define DBG_REQUEST_HANDLE  0x00800000  // dump request handle
#define DBG_TRIGGER_ON      0x10000000  // function is an enabling trigger
#define DBG_TRIGGER_OFF     0x20000000  // function is a disabling trigger
#define DBG_NO_DATA_DUMP    0x40000000  // turn off all data dumping
#define DBG_NO_DEBUG        0x80000000  // turn off all debugging

//
// debug category flags - these control what category of information is output
//

#define DBG_NOTHING         0x00000000  // internal
#define DBG_INET            0x00000001  // e.g. InternetOpenUrl()
#define DBG_FTP             0x00000002  // e.g. FtpFindFirstFile()
#define DBG_GOPHER          0x00000004  // e.g. GopherFindFirstFile()
#define DBG_HTTP            0x00000008  // e.g. HttpOpenRequest()
#define DBG_API             0x00000010  // APIs
#define DBG_UTIL            0x00000020  // various utility functions
#define DBG_UNICODE         0x00000040  // wide character functions
#define DBG_WORKER          0x00000080  // worker functions
#define DBG_HANDLE          0x00000100  // handle creation/deletion functions
#define DBG_SESSION         0x00000200  // session/creation functions
#define DBG_SOCKETS         0x00000400  // sockets functions
#define DBG_VIEW            0x00000800  // gopher view functions
#define DBG_BUFFER          0x00001000  // gopher buffer functions
#define DBG_PARSE           0x00002000  // FTP/gopher parse functions
#define DBG_MEMALLOC        0x00004000  // Debug memory allocation/free functions
#define DBG_SERIALST        0x00008000  // Serialized List functions
#define DBG_THRDINFO        0x00010000  // INTERNET_THREAD_INFO functions
#define DBG_PROTOCOL        0x00020000  // protocol functions
#define DBG_DLL             0x00040000  // DLL functions
#define DBG_REFCOUNT        0x00080000  // logs all reference count functions
#define DBG_REGISTRY        0x00100000  // logs all registry functions
#define DBG_TRACE_SOCKETS   0x00200000  // monitors socket usage
#define DBG_ASYNC           0x00400000  // logs async functions
#define DBG_CACHE           0x00800000  // logs cache specific stuff
#define DBG_INVALID_HANDLES 0x01000000  // logs invalid handles (e.g. in InternetCloseHandle())
#define DBG_OBJECTS         0x02000000  // dump object info
#define DBG_PROXY           0x04000000  // dump proxy info
#define DBG_RESLOCK         0x08000000  // dump resource lock info
#define DBG_DIALUP          0x10000000  // dump dial-up info
#define DBG_GLOBAL          0x20000000  // dump global-scope functions
#define DBG_HTTPAUTH        0x40000000  // authentication functions
#define DBG_ANY             0xFFFFFFFF  // internal

//
// types
//

//
// INTERNET_DEBUG_INFO - structure that receives the current debugging variables
// via InternetQueryOption(), or which contains the new debugging variables to
// be set via InternetSetOption()
//

typedef struct {

    //
    // ErrorLevel - DBG_INFO, etc.
    //

    int ErrorLevel;

    //
    // ControlFlags - DBG_THREAD_INFO, etc.
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - DBG_INET, etc.
    //

    DWORD CategoryFlags;

    //
    // BreakFlags - DBG_API, etc. where breakpoints will be taken
    //

    DWORD BreakFlags;

    //
    // IndentIncrement - increment to use for each depth increase
    //

    int IndentIncrement;

    //
    // Filename - name of output log being used/to use
    //

    char Filename[1];

} INTERNET_DEBUG_INFO, *LPINTERNET_DEBUG_INFO;

//
// INTERNET_TRIGGER_INFO - a diagnostic trigger. Triggers are enabled when the
// function named in this structure is executed. Triggers can enable or disable
// diagnostics
//

typedef struct {

    //
    // FunctionName - name of the function to act as trigger. ControlFlags has
    // DBG_TRIGGER_ON or DBG_TRIGGER_OFF set
    //

    LPCSTR FunctionName;

    //
    // ControlFlags - control flags to use when the trigger is enabled. If the
    // trigger disables diagnostics then the previous control flags will be
    // restored
    //

    DWORD ControlFlags;

    //
    // CategoryFlags - category flags to use when the trigger is enabled. See
    // ControlFlags
    //

    DWORD CategoryFlags;

} INTERNET_TRIGGER_INFO, *LPINTERNET_TRIGGER_INFO;

//
// INTERNET_DEBUG_TRIGGERS - 1 or more of these will be returned from/given to
// InternetQueryOption()/InternetSetOption()
//

typedef struct {

    //
    // Count - number of INTERNET_TRIGGER_INFO structures contained herein
    //

    DWORD Count;

    //
    // Triggers - an array of 0 or more INTERNET_TRIGGER_INFO structures
    //

    INTERNET_TRIGGER_INFO Triggers[1];

} INTERNET_DEBUG_TRIGGERS, *LPINTERNET_DEBUG_TRIGGERS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\resolv.h ===
/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  RESOLV.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/0/s.resolv.h
 *  @(#)resolv.h    5.3
 *
 *  Last delta created  14:05:35 3/4/91
 *  This file extracted 11:19:25 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1987, 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)resolv.h    5.10 (Berkeley) 6/1/90
 */

#ifndef _RESOLV_INCLUDED
#define _RESOLV_INCLUDED

/*
 * Global defines and variables for resolver stub.
 */
#define MAXNS       3       /* max # name servers we'll track */
#define MAXDFLSRCH  3       /* # default domain levels to try */
#define MAXDNSRCH   6       /* max # domains in search path */
#define LOCALDOMAINPARTS 2      /* min levels in name that is "local" */

#define RES_TIMEOUT 4       /* min. seconds between retries */

struct state {
    int  retrans;          /* retransmition time interval */
    int  retry;            /* number of times to retransmit */
    long options;          /* option flags - see below. */
    int  nscount;          /* number of name servers */
    struct   sockaddr_in nsaddr_list[MAXNS];  /* address of name server */
#define nsaddr   nsaddr_list[0]        /* for backward compatibility */
    unsigned short  id;        /* current packet id */
    char     defdname[MAXDNAME];       /* default domain */
    char    *dnsrch[MAXDNSRCH+1];      /* components of domain to search */
};

/*
 * Resolver options
 */
#define RES_INIT    0x0001      /* address initialized */
#define RES_DEBUG   0x0002      /* print debug messages */
#define RES_AAONLY  0x0004      /* authoritative answers only */
#define RES_USEVC   0x0008      /* use virtual circuit */
#define RES_PRIMARY 0x0010      /* query primary server only */
#define RES_IGNTC   0x0020      /* ignore trucation errors */
#define RES_RECURSE 0x0040      /* recursion desired */
#define RES_DEFNAMES    0x0080      /* use default domain name */
#define RES_STAYOPEN    0x0100      /* Keep TCP socket open */
#define RES_DNSRCH  0x0200      /* search up local domain tree */
#define RES_MODE_HOST_ONLY 0x0400          /* use the host file only */
#define RES_MODE_DNS_ONLY  0x0800          /* use the DNS only */
#define RES_MODE_HOST_DNS  0x1000          /* use the host file then the DNS */
#define RES_MODE_DNS_HOST  0x2000          /* use the DNS then the host file */

#define RES_DEFAULT (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)

extern struct state _res;
extern char *p_cdname(), *p_rr(), *p_type(), *p_class(), *p_time();


//
// Resolver function prototypes
//

int
dn_expand(
    IN  unsigned char *msg,
    IN  unsigned char *eomorig,
    IN  unsigned char *comp_dn,
    OUT unsigned char *exp_dn,
    IN  int            length
    );

int
dn_comp(
    IN      unsigned char  *exp_dn,
    OUT     unsigned char  *comp_dn,
    IN      int             length,
    IN      unsigned char **dnptrs,     OPTIONAL
    IN OUT  unsigned char **lastdnptr   OPTIONAL
    );

int
res_init(
    void
    );

int
res_send(
    IN  char *buf,
    IN  int buflen,
    OUT char *answer,
    IN  int anslen
    );

int
res_query(
    IN  char          *name,      /* domain name */
    IN  int            Class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer buffer */
    );

int
res_search(
    IN  char           *name,     /* domain name */
    IN  int            Class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer */
    );

int
res_mkquery(
    IN  int          op,             // opcode of query
    IN  char        *dname,          // domain name
    IN  int          Class,                  // class of query
    IN  int          type,               // type of query
    IN  char        *data,    OPTIONAL       // resource record data
    IN  int          datalen, OPTIONAL       // length of data
    IN  struct rrec *newrr,   OPTIONAL       // new rr for modify or append
    OUT char        *buf,            // buffer to put query
    IN  int          buflen                  // size of buffer
    );

#endif    // _RESOLV_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\private\nameser.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *  @(#)nameser.h   5.3
 *
 *  Last delta created  14:06:04 3/4/91
 *  This file extracted 11:19:28 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)nameser.h   5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ    512     /* maximum packet size */
#define MAXDNAME    256     /* maximum domain name */
#define MAXCDNAME   255     /* maximum compressed domain name */
#define MAXLABEL    63      /* maximum length of domain label */
    /* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ    4
    /* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ   10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT 53

/*
 * Currently defined opcodes
 */
#define QUERY       0x0     /* standard query */
#define IQUERY      0x1     /* inverse query */
#define STATUS      0x2     /* nameserver status query */
/*#define xxx       0x3     /* 0x3 reserved */
    /* non standard */
#define UPDATEA     0x9     /* add resource record */
#define UPDATED     0xa     /* delete a specific resource record */
#define UPDATEDA    0xb     /* delete all nemed resource record */
#define UPDATEM     0xc     /* modify a specific resource record */
#define UPDATEMA    0xd     /* modify all named resource record */

#define ZONEINIT    0xe     /* initial zone transfer */
#define ZONEREF     0xf     /* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR     0       /* no error */
#endif
#define FORMERR     1       /* format error */
#define SERVFAIL    2       /* server failure */
#define NXDOMAIN    3       /* non existent domain */
#define NOTIMP      4       /* not implemented */
#define REFUSED     5       /* query refused */
    /* non standard */
#define NOCHANGE    0xf     /* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A     1       /* host address */
#define T_NS        2       /* authoritative server */
#define T_MD        3       /* mail destination */
#define T_MF        4       /* mail forwarder */
#define T_CNAME     5       /* connonical name */
#define T_SOA       6       /* start of authority zone */
#define T_MB        7       /* mailbox domain name */
#define T_MG        8       /* mail group member */
#define T_MR        9       /* mail rename name */
#define T_NULL      10      /* null resource record */
#define T_WKS       11      /* well known service */
#define T_PTR       12      /* domain name pointer */
#define T_HINFO     13      /* host information */
#define T_MINFO     14      /* mailbox information */
#define T_MX        15      /* mail routing information */
#define T_TXT       16      /* text strings */
#define T_AFSDB     18      /* AFS database servers */
    /* non standard */
#define T_UINFO     100     /* user (finger) information */
#define T_UID       101     /* user ID */
#define T_GID       102     /* group ID */
#define T_UNSPEC    103     /* Unspecified format (binary data) */
    /* Query type values which do not appear in resource records */
#define T_AXFR      252     /* transfer zone of authority */
#define T_MAILB     253     /* transfer mailbox records */
#define T_MAILA     254     /* transfer mail agent records */
#define T_ANY       255     /* wildcard match */

/*
 * Values for class field
 */

#define C_IN        1       /* the arpa internet */
#define C_CHAOS     3       /* for chaos net at MIT */
#define C_HS        4       /* for Hesiod name server at MIT */
    /* Query class values which do not appear in resource records */
#define C_ANY       255     /* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define LITTLE_ENDIAN   1234    /* least-significant byte first (vax) */
#define BIG_ENDIAN  4321    /* most-significant byte first (IBM, net) */
#define PDP_ENDIAN  3412    /* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER  LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined(ux10) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#ifndef BYTE_ORDER      /* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_AMD64_) || defined(IA64)
#define BYTE_ORDER  LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
    /* you must determine what the correct bit order is for your compiler */
    UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
    unsigned short  id;     /* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
            /* fields in third byte */
    unsigned char   qr:1;       /* response flag */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   rd:1;       /* recursion desired */
            /* fields in fourth byte */
    unsigned char   ra:1;       /* recursion available */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   rcode:4;    /* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
            /* fields in third byte */
    unsigned char   rd:1;       /* recursion desired */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   qr:1;       /* response flag */
            /* fields in fourth byte */
    unsigned char   rcode:4;    /* response code */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   ra:1;       /* recursion available */
#endif
            /* remaining bytes */
    unsigned short  qdcount;    /* number of question entries */
    unsigned short  ancount;    /* number of answer entries */
    unsigned short  nscount;    /* number of authority entries */
    unsigned short  arcount;    /* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK  0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
    short           r_zone;         /* zone number */
    short           r_class;        /* class number */
    short           r_type;         /* type number */
    unsigned long   r_ttl;          /* time to live */
    int         r_size;         /* size of data area */
    char           *r_data;             /* pointer to data */
};

extern  unsigned short  _getshort(char *);
extern  unsigned long   _getlong(char *);

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
    (s) = *(cp)++ << 8; \
    (s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
    (l) = *(cp)++ << 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
    *(cp)++ = (s) >> 8; \
    *(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
    (cp)[3] = l; \
    (cp)[2] = (l >>= 8); \
    (cp)[1] = (l >>= 8); \
    (cp)[0] = l >> 8; \
    (cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\util.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Header for util.cxx

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#if !defined(__UTIL_H__)
#define __UTIL_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// manifests
//

#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
#define PLATFORM_TYPE_WINNT         ((DWORD)(1))
#define PLATFORM_TYPE_UNIX          ((DWORD)(2))

#define PLATFORM_SUPPORTS_UNICODE   0x00000001

// max header allowed by wininet in the cache

#define MAX_HEADER_SUPPORTED            2048
#define MAX_USERNAME                    128
#define DEFAULT_MAX_EXTENSION_LENGTH    8

/*
 * These should surround any call to g_pSecMgr->PUA, or MUTZ calls in urlmon
 * [ potentially ANYTHING that passes a URL to the sec. mgr. ]
 * to prevent the auto_proxy queueing calls going async.
 *
 * Why not just put it in HostBypassesProxy()?
 *
 * Try only HostBypassesProxy() and then later, we'll add to the urlmon calls
 * if need be.
 *
 * Can optimize these to surround the outermost calls to these functions where
 * the fsm is already available, but in doing so, make sure that no paths
 * that would legitimately send the autoproxy async are made sync.
 *
 *  USE ONLY ONE EACH OF THESE CALLS IN A FUNCTION, and 
 *  MAKE SURE THEY ARE PAIRED UP and IN THE SAME SCOPE.
 */

#define START_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL \
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();\
    BOOL bSetNonBlocking = FALSE;\
    CFsm* pFsm;\
    if (lpThreadInfo && (pFsm=lpThreadInfo->Fsm) && lpThreadInfo->IsAsyncWorkerThread && !pFsm->IsBlocking())\
    {\
        pFsm->SetBlocking(TRUE);\
        bSetNonBlocking = TRUE;\
    }

#define END_GUARD_AGAINST_ASYNC_AUTOPROXY_CALL \
{\
    if (bSetNonBlocking)\
    {\
        pFsm->SetBlocking(FALSE);\
    }\
}

//
// types
//

//
// TRI_STATE - for places where we need to differentiate between TRUE/FALSE and
// uninitialized
//

typedef enum {
    TRI_STATE_UNKNOWN = -1,
    TRI_STATE_FALSE = 0,
    TRI_STATE_TRUE = 1
} TRI_STATE;

//
// DLL_ENTRY_POINT - maps a name to an entry point in a DLL
//

typedef struct {
    LPSTR lpszProcedureName;
    FARPROC * lplpfnProcedure;
} DLL_ENTRY_POINT, * LPDLL_ENTRY_POINT;

//
// DLL_INFO - used to dynamically load/unload libraries
//

typedef struct {
    LPSTR lpszDllName;
    HINSTANCE hModule;
    LONG LoadCount;
    DWORD dwNumberOfEntryPoints;
    LPDLL_ENTRY_POINT lpEntryPoints;
} DLL_INFO, * LPDLL_INFO;

//
// macros
//

#define IsPlatformWin95() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WIN95) ? TRUE : FALSE)

#define IsPlatformWinNT() \
    (BOOL)((GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : FALSE)

//#define IsUnicodeSupported() \
//    (BOOL)((PlatformSupport() & PLATFORM_SUPPORTS_UNICODE) ? TRUE : FALSE)

#define DLL_ENTRY_POINT_ELEMENT(name) \
    # name, (FARPROC *)&_I_ ## name

#define DLL_INFO_INIT(name, entryPoints) { \
    name, \
    NULL, \
    0, \
    ARRAY_ELEMENTS(entryPoints), \
    (LPDLL_ENTRY_POINT)&entryPoints \
}


#define CompareFileTime(ft1, ft2)   \
    (((*(LONGLONG UNALIGNED *)&ft1) > (*(LONGLONG UNALIGNED *)&ft2)) ? 1 : \
     (((*(LONGLONG UNALIGNED *)&ft1) == (*(LONGLONG UNALIGNED *)&ft2)) ? 0 : -1 ) )



//
// prototypes
//

LPSTR
NewString(
    IN LPCSTR String,
    IN DWORD dwLen = 0
    );

LPWSTR
NewStringW(
    IN LPCWSTR String,
    IN DWORD dwLen = 0
    );


LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    );

HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    );

LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    );

LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    );

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    );

DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os = NULL
    );

DWORD
PlatformSupport(
    VOID
    );

DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    );

DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    );

DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    );

DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    );

//
// flags for LoadDllEntryPoints()
//

#define LDEP_PARTIAL_LOAD_OK    0x00000001  // ok if not all entry points can be loaded

DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    );

DWORD
MapInternetError(
    IN DWORD ErrorCode
    );

DWORD
CalculateHashValue(
    IN LPSTR lpszString
    );

VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    );

//DWORD DwRemoveDots (
//    char * pchPath
//    );


LPSTR GetFileExtensionFromUrl(
    LPSTR lpszUrl,
    LPDWORD lpdwLength
    );

DWORD
CheckExpired(
    HINTERNET   handle,
    BOOL    *lpfIsExpired,
    LPCACHE_ENTRY_INFO lpCEI,
    LONGLONG DefaultExpiryDelta
    );


LPTSTR
FTtoString(
    IN FILETIME *pftTime
    );

BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
);

BOOL
InternetSettingsChanged(
    VOID
    );

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    );

LPTSTR
FormatCertInfo(
    IN INTERNET_CERTIFICATE_INFO *pCertInfo
    );

BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    );

//DWORD
//UnicodeToUtf8(
//    IN LPCWSTR pwszIn,
//    IN DWORD dwInLen,
//    OUT LPBYTE pszOut,
//    IN OUT LPDWORD pdwOutLen
//    );

BOOL
StringContainsHighAnsi(
    IN LPSTR pszIn,
    IN DWORD dwInLen
    );

LPSTR
ConvertMBCSToUTF8(
    IN LPCSTR lpszMBCSHostName,
    IN DWORD dwMBCSHostNameLength,
    IN DWORD dwCodePage,
    OUT DWORD * pdwUTF8HostNameLength,
    BOOL bLowerCase = TRUE
    );
    
DWORD 
GetTickCountWrap();

char *FindNamedValue(char *pszHeader, 
                     const char *pszFieldName, 
                     unsigned long *pdwValSize);

#ifdef DONT_USE_IERT
char *
StrTokEx(
    IN OUT char ** pstring, 
    IN const char * control);

double 
StrToDbl(
    IN const char *str, 
    IN OUT char **strStop);
#endif //DONT_USE_IERT

char* StrTokEx2(char** pstring, const char* control);

BOOL IsAddressValidIPString(LPCSTR pszHostIP);

BOOL
RefreshSslState(
    VOID
    );

BOOL
IsInGUIModeSetup();

#if defined(__cplusplus)
}
#endif

#endif // defined(__UTIL_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inc\wininetp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininetp.h

Abstract:

    Includes all headers for precompiled header to build Windows Internet
    client DLL

Author:

    Richard L Firth (rfirth) 26-Oct-1994

Revision History:

    26-Oct-1994 rfirth
        Created

--*/

#ifndef __WININETP_H__
#define __WININETP_H__ 1

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

// #define STRESS_BUG_DEBUG // for stress debugging

#if DBG

#define STRESS_BUG_DEBUG // for stress debugging

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG


#define WININET_SELFREG     1
//
// common include files
//


//
// CRT includes
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h> // Pull in the 'offsetof' macro.
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <excpt.h>
#include <limits.h>
#include <fcntl.h>
#include <io.h>
#include <time.h>

//
// OS includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>

#if defined(__cplusplus)
}
#endif

//#include <fastcrit.h>

//
// SSL/PCT Security includes
//

#if defined(__cplusplus)
extern "C" {
#endif

#define SECURITY_WIN32
#include <sspi.h>    // standard SSPI interface
#include <issperr.h> // SSPI errors.
#include <spseal.h>  // Private SSPI Seal/UnSeal functions.
#include <schnlsp.h> // shared private schannel/wininet interfaces.
#include <wintrust.h> // various CAPI stuff for cert management
#include <wincrypt.h>
#if defined(__cplusplus)
}
#endif


//
// WININET includes
//

#include <iwinsock.h>
#include <wininet.h>
#include <winineti.h>
#include <oldnames.h>
#include <unsup.h>      // no longer supported items
#include <wininetd.h>
#include <resinfo.h>
#include <serialst.h>
#include <blocklst.hxx>
#include <chunk.hxx>
#include <inetdbg.h>
#include <debugmem.h>
#include <shlwapi.h>
#define NO_SHLWAPI_MLUI
#include <shlwapip.h>
#include <malloc.h>
#include <crtsubst.h>
#include <handle.h>
#include <constant.h>
#include <macros.h>
#include <inetp.h>
#include <util.h>
#include <proxreg.h>
#include <icstring.hxx>
#include <cliauth.hxx>
#include <certcach.hxx>
#include <buffer.hxx>
#include <resolver.h>
#include <thrdinfo.h>
#include <defaults.h>
#include <passport.h>
#include <spluginx.hxx>
#include <splugin.hxx>
#include <secinit.h>
#include <inetsspi.h>
#include <tstr.h>
#include <readhtml.h>
#include <ftpinit.h>
#include <gfrinit.h>
#include <httpinit.h>
#include <registry.h>
#include <parseurl.h>
#include <username.hxx>
#include <globals.h>
#include <autoprox.hxx>
#include <reslock.hxx>
#include <proxysup.hxx>
#include <httpfilt.hxx>
#include <hinet.hxx>
#include <priolist.hxx>
#include <icasync.hxx>
#include <caddrlst.hxx>
#include <icsocket.hxx>
#include <ssocket.hxx>
#include <servinfo.hxx>
#include <urlcache.h>
#include <connect.hxx>
#include <ftp.hxx>
#include <gopher.hxx>
#include <http.hxx>
#include <cookie.h>
#include <rescache.h>
#include <parsers.h>
#include <fsm.hxx>
#include <mpacket.hxx>
#include <inetchar.h>
#include <bgtask.hxx>
#include <cookimp.h>
#include <cookexp.h>
#include <401imprt.hxx>
#include <commctrl.h>
#include <shfusion.h>

#if defined(__cplusplus)
extern "C" {
#endif

#include <resource.h>


//
//  Various protocol package initializers.
//

BOOL
WINAPI
WinInetDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );

#if defined(__cplusplus)
}
#endif

// privacy helper function used in dllinstall
void CheckPrivacyDefaults(void);
void AddHardeningPrivacyDefaults();
void RemoveHardeningPrivacyDefaults();


//
// Need version 0x400 for ras defines for this to work on win95 gold.
//
#if defined(__cplusplus)
extern "C" {
#endif

#undef WINVER
#define WINVER 0x400

#include <ras.h>
#include <raserror.h>

#ifdef ICECAP
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall MarkCAP(long lMark);  // write mark to MEA
extern "C" void _stdcall AllowCAP(void);  // Allow profiling when 'profile=almostnever'
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define MarkCAP(n)
#define AllowCAP()
#endif

#if defined(__cplusplus)
}
#endif

/* X-Platform stuff */
#include <xpltfrm.h>

#endif /* __WININETP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\dialui.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dialui.cxx

Abstract:

    Contains the implementation of all ui for wininet's dialing support

    Contents:

Author:

    Darren Mitchell (darrenmi) 22-Apr-1997

Environment:

    Win32(s) user-mode DLL

Revision History:

    22-Apr-1997 darrenmi
        Created


--*/

#include <wininetp.h>

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
// Prompt to go offline dialog
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK GoOfflinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        return TRUE;
        break;
    case WM_COMMAND:
        switch (wParam) {
        case IDS_WORK_OFFLINE:
        case IDCANCEL:
            EndDialog(hDlg,TRUE);
            return TRUE;
            break;
        case IDS_TRY_AGAIN:
            EndDialog(hDlg,FALSE);
            return TRUE;
            break;
        default:
            break;
        }
        break;
   default:
        break;
   }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                          Go Online dialog
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK OnlineDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    switch(uMsg) {
    case WM_INITDIALOG:
        SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
            case ID_CONNECT:
                EndDialog(hDlg, TRUE);
                break;
            case IDCANCEL:
            case ID_STAYOFFLINE:
                EndDialog(hDlg, FALSE);
                break;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\ierrdlg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ierrdlg.cxx

Abstract:

    Contains immplimentation of generic Windows Dialog
    Manipulation Code.  This Code will support several
    basic operations for putting up dialog UI.

    Contents:
        LaunchDlg
        LaunchAuthPlugInDlg
        MapWininetErrorToDlgId
        (AuthDialogProc)
        (OkCancelDialogProc)
        (CertPickDialogProc)

Author:

    Arthur L Bierer (arthurbi) 04-Apr-1996

Revision History:

    04-Apr-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include "ierrui.hxx"
#include "iehelpid.h"
#include <persist.h>
#ifdef UNIX
#include <unixui.h>
#endif /* UNIX */

#include <wincred.h>
#include <ntverp.h>


// NOTE- This is not a path delmiter. It is used
// to separate NT DOMAIN\USERNAME fields.
#define DOMAIN_DELIMITER '\\'
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//
// private prototypes
//

INT_PTR
CALLBACK
AuthDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );

INT_PTR
CALLBACK
OkCancelDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );

INT_PTR
CALLBACK
InsertCDDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );


VOID
UpdateGlobalSecuritySettings(
    IN DWORD dwCtlId,
    IN DWORD dwFlags
    );




//
// public functions
//


DWORD
LaunchAuthPlugInDlg(
                HTTP_REQUEST_HANDLE_OBJECT *pRequest,
                AUTHCTX * pAuthCtx,
                HWND hWnd,
                DWORD dwError,
                DWORD dwFlags,
                InvalidPassType *pipAuthUIInfo
                )
/*++

Routine Description:

    Creates and Launches a Security Plug-In supported Dialog.
    The PlugIn will register a callback function that can be called
    by WININET to put up a custom authentication Dialog.

    The PlugIn is expected to make a "DialogBox" call and return
    its results using WININET error code conventions.


Arguments:

    lppvContext - pointer to context pointer

    hWnd       - Parent Window handle to show the dialog from.

    dwError    - Error code that caused this authentication to come up,
                 should always be ERROR_INTERNET_PASSWORD_INVALID.

    dwFlags    - A special flags assoicated with this authentication.

    pPwdCacheEntry - A Password cache entry structure.

    pipAuthUIInfo - Username/Password structure to return the result.


Return Value:

    DWORD
        ERROR_SUCCESS    -  Success.

        ERROR_CANCELLED  -  User clicked "Cancel" or "No" in the dialog.

        ERROR_BAD_FORMAT -  We faulted while trying to calldown to the plugin.
--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "LaunchAuthPlugInDlg",
                "%#x, %#x, %d (%s), %#x, %#x",
                pAuthCtx->_pvContext,
                hWnd,
                dwError,
                InternetMapError(dwError),
                dwFlags,
                pAuthCtx->_pPWC
                ));

    DWORD error = ERROR_SUCCESS;

    //
    // If this Authentication Scheme Handles Its Own UI, then we need
    //  to Defer to Its Own Dialog Code.
    //

    if (pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI)
    {
        // Digest context handles its own ui.
        if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST)
        {
            error = ((DIGEST_CTX*) pAuthCtx)->PromptForCreds(hWnd);
        }
        else
        {
            __try
            {
                // The package handles it's own UI, possibly generating an auth
                // header.

                // Since AuthenticateUserUI calls into GetSecAuthMsg which
                // calls into InitializeSecurityPackage we use the same method
                // embbeded in PLUG_CTX methods of checking the return code of the
                // SSPI call against SEC_E_OK to know if the auth context can transit
                // to AUTHSTATE_CHALLENGE.
                SECURITY_STATUS ssResult;
                ssResult = SEC_E_INTERNAL_ERROR;

                error = AuthenticateUserUI
                    (&pAuthCtx->_pvContext, hWnd, dwError, dwFlags, pipAuthUIInfo, 
                        pAuthCtx->GetScheme(), ((PLUG_CTX*)pAuthCtx)->GetUrl(), &ssResult);


                // Transit to the correct auth state.
                if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
                {
                    if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NEGOTIATE)
                        ((PLUG_CTX*)pAuthCtx)->ResolveProtocol();

                    // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
                    // Negotiate does not transit to challenge.
                    // Any other protocol + SEC_E_OK only transits to challenge.
                    if ((pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_KERBEROS
                        && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                        || (pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
                    {
                        /*pAuthCtx->_pRequest*/pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
                    }        
                }
            }


            __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                            ? EXCEPTION_EXECUTE_HANDLER
                            : EXCEPTION_CONTINUE_SEARCH )
            {
                DEBUG_PRINT(HTTP,
                        ERROR,
                        ("AuthenticateUserUI call down Faulted, return failure\n"));

                error = ERROR_BAD_FORMAT;
                goto quit;
            }
            ENDEXCEPT
        }
    }
    else
    {
        //
        // I don't expect to be called in this case
        //

        INET_ASSERT(FALSE);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
LaunchDlg(
          IN HWND      hWnd,
          IN LPVOID    lpParam,
          IN DWORD     dwDlgResource,
          IN DLGPROC   pDlgProc
          )
/*++

Routine Description:

    Creates and Launches the appropriate dialog based on
    the dialog resource passed in.

Arguments:

    hWnd    - Parent Window handle to show the dialog from.

    lpParam - Void pointer which will become the lParam value passed
              the dialog box proc.

    dwDlgResource - the dialog resource id.

    pDlgProc      - Pointer to Function to use for this dialog.

Return Value:

    DWORD
        ERROR_SUCCESS    -  Success.

        ERROR_CANCELLED  -  User clicked "Cancel" or "No" in the dialog.
--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "LaunchDlg",
                "%#x, %#x, %d %x",
                hWnd,
                lpParam,
                dwDlgResource,
                pDlgProc
                ));

    DWORD error = ERROR_SUCCESS;
    INT_PTR result = 0;

    if ((dwDlgResource == IDD_NTLM_AUTH) ||
        (dwDlgResource == IDD_REALM_AUTH) ||
        (dwDlgResource == 0 /*Passport Auth*/) )
    {
        DWORD DisableCredMgr = 0;
        InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                     "DisableCredManager",
                                    (LPDWORD) &DisableCredMgr
                          );

        if (GlobalPlatformWhistler && !DisableCredMgr)
        {
            CREDINFODLGTYPE *pDlgInfo = (CREDINFODLGTYPE *) lpParam;
            
            pDlgInfo->pAuthCtx->InitCredUI();
            HMODULE hCredUI = pDlgInfo->pAuthCtx->_hCredUI;
            PFN_CREDUI_PROMPTFORCREDENTIALS pfnCredUIPromptForCredentials = pDlgInfo->pAuthCtx->_pfnCredUIPromptForCredentials;
            PFN_CREDUI_PROMPTFORCREDENTIALS_W pfnCredUIPromptForCredentialsW = pDlgInfo->pAuthCtx->_pfnCredUIPromptForCredentialsW;

            if ( hCredUI != NULL)
            {
                DWORD dwCredFlags = 0;

                if (dwDlgResource == 0 /*Passport Auth*/)
                {
                    PASSPORT_CTX* pPPCtx = (PASSPORT_CTX*)pDlgInfo->pAuthCtx;
                    HTTP_REQUEST_HANDLE_OBJECT  *pRequest = pDlgInfo->pRequest;

                    HBITMAP hBitmap = NULL;
                    PWSTR pszCbtxtW = NULL;
                    PSTR pszCbtxtA = NULL;
                    DWORD dwszCbChars = 0;

                    WCHAR szUserNameW[CREDUI_MAX_USERNAME_LENGTH];
                    szUserNameW[0] = L'\0';

                    if (pPPCtx->PromptForCreds(&hBitmap, NULL, &dwszCbChars, NULL, NULL) == TRUE) // need to prompt user
                    {
                        // alloc the text and get it.
                        if ( dwszCbChars > 0  )
                        {
	                        pszCbtxtW = (PWSTR)HeapAlloc ( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwszCbChars + 1)*sizeof(WCHAR));
	                        pszCbtxtA = (PSTR)HeapAlloc ( GetProcessHeap(), HEAP_ZERO_MEMORY, (dwszCbChars + 1)*sizeof(CHAR));
	                        if ( pszCbtxtW != NULL && pszCbtxtA != NULL )
	                        {
		                        if ( pPPCtx->PromptForCreds(NULL, pszCbtxtW, &dwszCbChars, NULL, NULL ) == TRUE )
		                        {
                                    // convert WtoA
			                        if ( ::WideCharToMultiByte(CP_ACP, 0, 
                                                                pszCbtxtW, -1, 
                                                                pszCbtxtA, dwszCbChars + 1, 
                                                                NULL, NULL) == 0 )
			                        {
				                        // failed, don't send
				                        HeapFree ( GetProcessHeap(), 0, pszCbtxtW );
				                        HeapFree ( GetProcessHeap(), 0, pszCbtxtA );
				                        pszCbtxtW = NULL;
				                        pszCbtxtA = NULL;
			                        }
                                    else
                                    {
                                        UrlUnescapeA(pszCbtxtA, NULL, NULL, URL_UNESCAPE_INPLACE);

                                        if (::MultiByteToWideChar(CP_UTF8, 0, pszCbtxtA, -1, pszCbtxtW, dwszCbChars + 1) == 0)
                                        {
                                            // failed, don't send
                                            HeapFree ( GetProcessHeap(), 0, pszCbtxtW );
                                            HeapFree ( GetProcessHeap(), 0, pszCbtxtA );
                                            pszCbtxtW = NULL;
                                            pszCbtxtA = NULL;
                                        }
                                    }

		                        }

	                        }

                        }

                        CREDUI_INFOW CredUIInfo;
                        CredUIInfo.cbSize = sizeof(CredUIInfo);
                        CredUIInfo.hbmBanner = hBitmap;
                        CredUIInfo.hwndParent = hWnd;
                        CredUIInfo.pszCaptionText = NULL;
                        CredUIInfo.pszMessageText = pszCbtxtW;

                        WCHAR szPasswordW[CREDUI_MAX_PASSWORD_LENGTH];
                        szPasswordW[0] = L'\0';

                        dwCredFlags = 0;
                        if (pPPCtx->_pPWC && pPPCtx->_pPWC->lpszUser)
                        {
                            ::MultiByteToWideChar(CP_ACP, 0, pPPCtx->_pPWC->lpszUser, -1, szUserNameW, strlen(pPPCtx->_pPWC->lpszUser) + 1);
                        }
                        if (szUserNameW[0] != L'\0')
                        {
                            dwCredFlags |= CREDUI_FLAGS_KEEP_USERNAME;
                        }

                        WCHAR wServerName[128];
                        ::MultiByteToWideChar(CP_ACP, 0, pRequest->GetServerName(), -1, wServerName, 128);
                        DWORD dwRet = (*pfnCredUIPromptForCredentialsW) ( &CredUIInfo, 
                                               wServerName, 
                                               NULL,
                                               ERROR_LOGON_FAILURE,
                                               szUserNameW,
                                               CREDUI_MAX_USERNAME_LENGTH,
                                               szPasswordW,
                                               CREDUI_MAX_PASSWORD_LENGTH,
                                               NULL,
                                               dwCredFlags );	


                        if ( dwRet ==  ERROR_SUCCESS)
                        {
                            CHAR szUserNameA[CREDUI_MAX_USERNAME_LENGTH];
                            CHAR szPasswordA[CREDUI_MAX_PASSWORD_LENGTH];
			                ::WideCharToMultiByte(CP_ACP, 0, 
                                                        szUserNameW, -1, 
                                                        szUserNameA, CREDUI_MAX_USERNAME_LENGTH, 
                                                        NULL, NULL);
			                ::WideCharToMultiByte(CP_ACP, 0, 
                                                        szPasswordW, -1, 
                                                        szPasswordA, CREDUI_MAX_PASSWORD_LENGTH, 
                                                        NULL, NULL);
                            AuthLock();

                            //pRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
                            pRequest->SetUserOrPass ((LPSTR)szUserNameA, TRUE, FALSE);
                            pRequest->SetUserOrPass ((LPSTR)szPasswordA, FALSE, FALSE);
                            pRequest->TimeStampCreds();
                            AuthUnlock();

                            ZeroMemory ( szPasswordW, CREDUI_MAX_PASSWORD_LENGTH * sizeof(WCHAR) );
                            ZeroMemory ( szPasswordA, CREDUI_MAX_PASSWORD_LENGTH * sizeof(CHAR) );
                        }


                        if ( pszCbtxtW != NULL )
                            HeapFree ( GetProcessHeap(), 0, pszCbtxtW );
                        if ( pszCbtxtA != NULL )
                            HeapFree ( GetProcessHeap(), 0, pszCbtxtA );


                        switch ( dwRet )
                        {
                        case ERROR_SUCCESS:
                            g_fIgnoreCachedCredsForPassport = FALSE;
                            // user entered information, try CredReadDomainCredentials again, the
                            // Credentials entered by the user should be found by that call now.
                            break;

                        case ERROR_CANCELLED:
                            // user cancelled from the dialog, fail authentication attempt.
                            error = ERROR_CANCELLED;
                            goto quit;

                            // comment: double-check return code
                        }
                    }
                }
                else
                {
                    InvalidPassType *ipt = pDlgInfo->pipt;

                    CREDUI_INFO uiInfo;
                    dwCredFlags = 0;

                    uiInfo.cbSize = sizeof(uiInfo);
                    uiInfo.hwndParent = hWnd;
                    uiInfo.pszCaptionText = NULL;
                    uiInfo.hbmBanner = NULL;


                    if (dwDlgResource == IDD_NTLM_AUTH)
                    {
                        PLUG_CTX* pAuthCtx = (PLUG_CTX*) (pDlgInfo->pAuthCtx);
                        
                        uiInfo.pszMessageText = NULL;

//                        dwCredFlags = CREDUI_FLAGS_EXPECT_CONFIRMATION;

                        // If we're always prompting in this zone, write a server
                        // specific credential because we may or may not have
                        // target info and need to provide a consistent experience
                        // in either case:

                        if (GetCredPolicy(pDlgInfo->pRequest->GetURL()) ==
                            URLPOLICY_CREDENTIALS_MUST_PROMPT_USER)
                        {
                            dwCredFlags |= CREDUI_FLAGS_SERVER_CREDENTIAL;
                        }

                        // need to check if credential persistence is available
                        // borrowed from AuthDlgProc
                        if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
                            g_dwCredPersistAvail = InetInitCredentialPersist();

                        if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
                            dwCredFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;

                        error = (*pfnCredUIPromptForCredentials) ( &uiInfo,
                                               ipt->lpszHost,
                                               NULL,
                                               pAuthCtx->_SecStatus,
                                               // ERROR_LOGON_FAILURE,
                                               ipt->lpszUsername,
                                               min(CREDUI_MAX_USERNAME_LENGTH, ipt->ulMaxField - 1),
                                               ipt->lpszPassword,
                                               min(CREDUI_MAX_PASSWORD_LENGTH, ipt->ulMaxField - 1),
                                               NULL,
                                               dwCredFlags );	

                    }


                    if ((error == ERROR_NO_SUCH_LOGON_SESSION) ||
                        (dwDlgResource == IDD_REALM_AUTH))
                    {
                        dwCredFlags = CREDUI_FLAGS_EXCLUDE_CERTIFICATES |
                                      CREDUI_FLAGS_DO_NOT_PERSIST | 
                                      CREDUI_FLAGS_GENERIC_CREDENTIALS;

                        
                        BOOL fSave = FALSE;
                        BOOL fLastCredentialsFromStore = FALSE;
                        PSTR pszMessageText = NULL;

                        // If we have a realm name, use it for the message text.
                        // If the name is too long, truncate it by copying to a
                        // new buffer. If out of memory, just pass NULL to get the
                        // default message text:

                        if (ipt->lpszRealm != NULL)
                        {
                            DWORD cbMessageText = lstrlenA(ipt->lpszRealm);

                            if (cbMessageText <= CREDUI_MAX_MESSAGE_LENGTH)
                            {
                                uiInfo.pszMessageText = ipt->lpszRealm;
                            }
                            else
                            {
                                pszMessageText = new CHAR[cbMessageText + 1];

                                if (pszMessageText != NULL)
                                {
                                    if (lstrcpyn(pszMessageText,
                                                 ipt->lpszRealm,
                                                 CREDUI_MAX_MESSAGE_LENGTH) == NULL)
                                    {
                                        delete [] pszMessageText;
                                        pszMessageText = NULL;
                                    }
                                }

                                uiInfo.pszMessageText = pszMessageText;
                            }
                        }
                        else
                        {
                            uiInfo.pszMessageText = NULL;
                        }

                        // First, determine if credential persistence is available:

                        if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
                        {
                            g_dwCredPersistAvail = InetInitCredentialPersist();
                        }

                        if (g_dwCredPersistAvail != CRED_PERSIST_NOT_AVAIL)
                        {
                            dwCredFlags |= CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX;
                        }

                        // If any credentials are passed in, use them:

                        if (ipt->lpszUsername[0] && ipt->lpszPassword[0])
                        {
                            fLastCredentialsFromStore = FALSE;
                            ipt->lpszPassword[0] = '\0';
                        }
                        else
                        {
                            ipt->lpszUsername[0] = '\0';
                            ipt->lpszPassword[0] = '\0';

                            // Attempt to get credentials from persisted store:

                            if (g_dwCredPersistAvail != CRED_PERSIST_NOT_AVAIL)
                            {
                                if (InetGetCachedCredentials(
                                        ipt->lpszHost,
                                        ipt->lpszRealm,
                                        ipt->lpszUsername,
                                        ipt->lpszPassword) == ERROR_SUCCESS)
                                {
                                    fSave = TRUE;
                                    fLastCredentialsFromStore = TRUE;
                                }
                                else
                                {
                                    fSave = FALSE;
                                    fLastCredentialsFromStore = FALSE;
                                }
                            }
                        }

                        error =
                            pfnCredUIPromptForCredentials(
                                &uiInfo,
                                ipt->lpszHost,
                                NULL,
                                // pAuthCtx->_SecStatus,
                                ERROR_LOGON_FAILURE,
                                ipt->lpszUsername,
                                min(CREDUI_MAX_USERNAME_LENGTH, ipt->ulMaxField - 1),
                                ipt->lpszPassword,
                                min(CREDUI_MAX_PASSWORD_LENGTH, ipt->ulMaxField - 1),
                                g_dwCredPersistAvail ? &fSave : NULL,
                                dwCredFlags);


                        if (fSave)
                        {
                            InetSetCachedCredentials(
                                ipt->lpszHost,
                                ipt->lpszRealm,
                                ipt->lpszUsername,
                                ipt->lpszPassword);
                        }
                        else if (fLastCredentialsFromStore)
                        {
                            InetRemoveCachedCredentials(
                                ipt->lpszHost,
                                ipt->lpszRealm);
                        }

                        // Free our temporary message buffer, if necessary:

                        if (pszMessageText != NULL)
                        {
                            delete [] pszMessageText;
                        }
                    }

                    // Translate all failure cases into ERROR_CANCELLED for now:

                    if (error != ERROR_SUCCESS)
                    {
                        error = ERROR_CANCELLED;
                    }
                }

            }
            else
            {
                error = ERROR_CANCELLED;
            }

            goto quit;
        }
        else
        {
            // we are not using the Whistler CredUI
            if (dwDlgResource == 0 /*Passport Auth*/)
            {
                // biaow-todo: we don't know how to handle Passport-CredUI for downlevel yet;
                // panic in checked build
                INET_ASSERT(TRUE);

                // consider this "Cancelled" in retail...
                error = ERROR_CANCELLED;
                goto quit;
            }

            pDlgProc = AuthDialogProc;
            INET_ASSERT(pDlgProc);
        }
    }

    //
    // Launch the Dialog Box, and wait for it to complete
    //

    // Should actually cast lpParam as CREDINFODLGTYPE* and pass
    // pipt element instead of just lpParam.

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);

    result = DialogBoxParamWrapW(GlobalResHandle,
                            MAKEINTRESOURCEW(dwDlgResource),
                            hWnd,
                            pDlgProc,
                            (LPARAM) lpParam);

    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
    if ( result == FALSE || result == -1)
    {
        error = ERROR_CANCELLED;
        goto quit;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

DWORD
MapWininetErrorToDlgId(
    IN  DWORD        dwError,
    OUT LPDWORD     lpdwDlgId,
    OUT LPDWORD     lpdwDlgFlags,
    OUT DLGPROC     *ppDlgProc
    )

/*++

Routine Description:

    Maps a Wininet Error Code to an internal Dlg Resource Id.

Arguments:

    dwError      -  A Wininet defined error code with an expected
                    assoicated dlg.

    lpdwDlgId    -  Pointer to location where Dlg Id result will be returend.
                    This ID can be used for creating a Dlg Resource.

    lpdwDlgFlags -  Pointer to DWORD flags used to store various capiblites
                    for Dialog.

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_INVALID_PARAMETER

Comments:

    none.

--*/

{
    typedef struct {
        DWORD   dwWininetError;
        DWORD   dwDlgId;
        DLGPROC pDlgProc;
        DWORD   dwDlgFlags;
    } ErrorToDlgIdMappingType;


    ErrorToDlgIdMappingType MapErrorToDlg[] = {
        { ERROR_INTERNET_SEC_CERT_CN_INVALID,       IDD_BAD_CN,                      OkCancelDialogProc, (DLG_FLAGS_CAN_HAVE_CERT_INFO | DLG_FLAGS_IGNORE_CERT_CN_INVALID)   },
        { ERROR_INTERNET_SEC_CERT_DATE_INVALID,     IDD_CERT_EXPIRED,                OkCancelDialogProc, (DLG_FLAGS_CAN_HAVE_CERT_INFO | DLG_FLAGS_IGNORE_CERT_DATE_INVALID) },
        { ERROR_INTERNET_MIXED_SECURITY,            IDD_MIXED_SECURITY,              OkCancelDialogProc, 0 },
        { ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR,    IDD_HTTP_TO_HTTPS_ZONE_CROSSING, OkCancelDialogProc, 0 },
        { ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR,    IDD_HTTPS_TO_HTTP_ZONE_CROSSING, OkCancelDialogProc, 0 },
        { ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION,   IDD_HTTP_POST_REDIRECT,          OkCancelDialogProc, 0 },
        { ERROR_INTERNET_CHG_POST_IS_NON_SECURE,    IDD_WARN_ON_POST,                OkCancelDialogProc, 0 },
        { ERROR_INTERNET_POST_IS_NON_SECURE,        IDD_WARN_ON_POST,                OkCancelDialogProc, 0 },
        { ERROR_INTERNET_INVALID_CA,                IDD_INVALID_CA,                  OkCancelDialogProc, (DLG_FLAGS_CAN_HAVE_CERT_INFO | DLG_FLAGS_IGNORE_INVALID_CA)},
        { ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED,   IDD_CERTPICKER,                  CertPickDialogProc, 0 },
        { ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT,     IDD_SCRIPT_ERROR,                OkCancelDialogProc, 0 },
        { ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT, IDD_FAILED_DOWNLOAD,             OkCancelDialogProc, (DLG_FLAGS_BRING_TO_FOREGROUND)},
        { ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR,   IDD_HTTPS_TO_HTTP_SUBMIT_REDIRECT,OkCancelDialogProc, 0 },
        { ERROR_INTERNET_INSERT_CDROM,              IDD_INSERT_CDROM,                InsertCDDialogProc, 0 },
        { ERROR_INTERNET_SEC_CERT_ERRORS,           IDD_SEC_CERT_ERRORS,             OkCancelDialogProc, DLG_FLAGS_CAN_HAVE_CERT_INFO },
        { ERROR_INTERNET_SEC_CERT_REV_FAILED,       IDD_REVOCATION_PROBLEM,          OkCancelDialogProc, DLG_FLAGS_CAN_HAVE_CERT_INFO },
    };


    INET_ASSERT(lpdwDlgId);
    INET_ASSERT(lpdwDlgFlags);

    *lpdwDlgId    = 0;
    *lpdwDlgFlags = 0;
    *ppDlgProc    = 0;

    for ( DWORD i = 0; i < ARRAY_ELEMENTS(MapErrorToDlg); i++ )
    {
        if (  dwError == MapErrorToDlg[i].dwWininetError )
        {
            *lpdwDlgId    = MapErrorToDlg[i].dwDlgId;
            *lpdwDlgFlags = MapErrorToDlg[i].dwDlgFlags;
            *ppDlgProc    = MapErrorToDlg[i].pDlgProc;
            return ERROR_SUCCESS;
        }
    }

    INET_ASSERT(FALSE);
    return ERROR_INVALID_PARAMETER;
}


//
// private functions.
//

BOOL
CALLBACK
ResizeAuthDialogProc(
    HWND hwnd,
    LPARAM lparam
    )
{
    // passed lpRect contains top and bottom for inserted region, move all elements
    // below the top down by bottom-top
    LPRECT lpInsertRect = (LPRECT) lparam;
    RECT ChildRect;
    HWND hwndParent;

    hwndParent = GetParent(hwnd);
    if(!hwndParent)
       return FALSE;

    GetWindowRect(hwnd, &ChildRect);
    if(ChildRect.top >= lpInsertRect->top) {
        ScreenToClient(hwndParent, (LPPOINT) &ChildRect.left);
        SetWindowPos(hwnd, 0, ChildRect.left, ChildRect.top + (lpInsertRect->bottom - lpInsertRect->top), 0, 0, SWP_NOZORDER|SWP_NOSIZE);
    }
    return TRUE;
}

INT_PTR
CALLBACK
AuthDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Handles authentication dialog

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    const static DWORD mapIDCsToIDHs[] =
    {
        IDC_SITE_OR_FIREWALL, IDH_AUTH_SERVER_FIREWALL,
        IDC_SERVER_OR_PROXY,  IDH_AUTH_SERVER_FIREWALL,
        IDC_USERNAME_TAG,     IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
        IDC_USERNAME,         IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
        IDC_PASSWORD_TAG,     IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
        IDC_PASSWORD,         IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
        IDC_DOMAIN_TAG,       IDH_AUTH_DOMAIN,
        IDC_DOMAIN_FIELD,     IDH_AUTH_DOMAIN,
        IDC_SAVE_PASSWORD,    IDH_AUTH_SAVE_PASSWORD,
        IDC_REALM_TAG,        IDH_AUTH_REALM,
        IDC_REALM_FIELD,      IDH_AUTH_REALM,
        0,0
    };

    static BOOL fLastCredentialsFromStore = FALSE;
    WCHAR  wszTmp[MAX_FIELD_LENGTH];

    CREDINFODLGTYPE *pDlgInfo;
    InvalidPassType *ipt;
    PLOCAL_STRINGS plszStrings = FetchLocalStrings();

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        CHAR szUsername[MAX_FIELD_LENGTH],
             szPassword[MAX_FIELD_LENGTH];

        CHAR *pUsr, *pDmn, *ptr;

        pDlgInfo = (CREDINFODLGTYPE *) lparam;
        ipt = pDlgInfo->pipt;

        SetForegroundWindow(hwnd);

        (void)SetWindowLongPtr(hwnd,
                               DWLP_USER,
                               (LONG_PTR)ipt);

        // First determine if credential persistence is available.
        if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
            g_dwCredPersistAvail = InetInitCredentialPersist();

        if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
            ShowWindow(GetDlgItem(hwnd, IDC_SAVE_PASSWORD), SW_HIDE);

        // If any credentials are passed in, use them.
        if (*ipt->lpszUsername && *ipt->lpszPassword)
        {
            // Flag that credentials did not come from
            // persistent store and copy values.
            fLastCredentialsFromStore = FALSE;
            memcpy(szUsername, ipt->lpszUsername, ipt->ulMaxField-1);
//            memcpy(szPassword, ipt->lpszPassword, ipt->ulMaxField-1);
            *szPassword = '\0';
        }
        else
        {
            // Otherwise, get any persisted credentials for this domain or realm.

            // Current credentials are originally blank.
            *szUsername = '\0';
            *szPassword = '\0';

            // Attempt to get credentials from persisted store.
            if (g_dwCredPersistAvail)
            {
                if (InetGetCachedCredentials(ipt->lpszHost, ipt->lpszRealm,
                    szUsername, szPassword) == ERROR_SUCCESS)
                {
#ifdef UNIX
                    /* If the user had not selected to store the password,
                     * we will save the password as NULL, but still save the
                     * username and domain. So, if the password is null, we
                     * don't check the button (this is ok because if somebody
                     * wants to save a null password, it will come out as
                     * null, but the button is not checked. Do you really
                     * want ie to tell you that you saved a null password ?)
                     */
                    if (!*szPassword) {
                       fLastCredentialsFromStore = FALSE;
                       CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_UNCHECKED);
                    }
                    else
#endif /* UNIX */
                    {
                       // Record that credentials were retrieved.
                       CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_CHECKED);
                       fLastCredentialsFromStore = TRUE;
                    }
                }
                else
                {
                    // Credentials were not retrieved.
                    fLastCredentialsFromStore = FALSE;
                    CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_UNCHECKED);
                }
            }
        }

        // If credential persistence is available, the save checkbox
        // is now visible. If credentials were retrieved from persistent
        // store then fLastCredentialsFromStore will now be set to TRUE
        // and the save check box will be checked. Otherwise,
        // fLastCredentialsFromStore will now be set to FALSE.

        // If the authentication type is NTLM, crack the domain\username stored
        // in ipt->lpszUsername into its constituent parts (domain and username).
        if (ipt->eAuthType == NTLM_AUTH)
        {
            // Scan Domain\Username for backslash.
            pUsr = strchr(szUsername, DOMAIN_DELIMITER);

            // Found backslash - replace with '\0'.
            if (pUsr)
            {
                *pUsr = '\0';
                pUsr++;
                pDmn = szUsername;
            }
            // No backslash found - take as username.
            else
            {
                pUsr = szUsername;
                pDmn = NULL;
            }

            // Set user and domain fields.
            SetWindowTextWrapW(GetDlgItem(hwnd,
                IDC_DOMAIN_OR_REALM), plszStrings->szDomain);

            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            SHAnsiToUnicode (pUsr, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW (GetDlgItem(hwnd,IDC_USERNAME), wszTmp);

            // Indicate field is domain.
            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            if (pDmn)
                SHAnsiToUnicode (pDmn, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_DOMAIN_FIELD), wszTmp);

            // Hide IDC_REALM_FIELD which overlays IDC_DOMAIN_FIELD
            ShowWindow(GetDlgItem(hwnd,IDC_REALM_FIELD), SW_HIDE);
        }

        // Otherwise if auth type is basic or digest, simply display username.
        else if (ipt->eAuthType == REALM_AUTH)
        {
            // Set user and realm fields.
            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            SHAnsiToUnicode (szUsername, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW(GetDlgItem(hwnd,IDC_USERNAME),
                wszTmp);

            // Blindly convert to unicode even tho' we don't know
            // the code page
            wszTmp[0] = TEXT('\0');
            SHAnsiToUnicode (ipt->lpszRealm, wszTmp, ARRAYSIZE(wszTmp));
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_REALM_FIELD),
                wszTmp);

            // Indicate field is realm.
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_REALM),
                plszStrings->szRealm);

            // qfe 4857 - long realm names are truncated
            if(ipt->lpszRealm && lstrlen(ipt->lpszRealm) > 20) {
                RECT WndRect;
                RECT RealmRect;
                // about 20 chars will fit per line, but bound it at 6 lines
                int cy = min(6, (lstrlen(ipt->lpszRealm) / 20));

                //resize window, text box, reposition all lower elements in callback

                GetWindowRect(GetDlgItem(hwnd,IDC_REALM_FIELD), &RealmRect);
                cy *= RealmRect.bottom - RealmRect.top;  // Scale box taller
                SetWindowPos(GetDlgItem(hwnd,IDC_REALM_FIELD), 0, 0, 0, RealmRect.right- RealmRect.left, RealmRect.bottom- RealmRect.top + cy, SWP_NOZORDER|SWP_NOMOVE);

                GetWindowRect(hwnd, &WndRect);
                SetWindowPos(hwnd, 0, 0, 0, WndRect.right - WndRect.left, WndRect.bottom - WndRect.top + cy, SWP_NOZORDER|SWP_NOMOVE);

                RealmRect.top = RealmRect.bottom;
                RealmRect.bottom +=cy;   // RealmRect contains the inserted region
                EnumChildWindows(hwnd, ResizeAuthDialogProc, (LPARAM) &RealmRect);

            }

        }

        // Set password field.
        SetWindowText (GetDlgItem(hwnd,IDC_PASSWORD), szPassword);

        // Indicate Site or Firewall as appropriate.
        if (ipt->fIsProxy)
        {
            SetWindowTextWrapW (GetDlgItem(hwnd,IDC_SITE_OR_FIREWALL),
            plszStrings->szFirewall);
        }
        else
        {
            SetWindowTextWrapW (GetDlgItem(hwnd,IDC_SITE_OR_FIREWALL),
            plszStrings->szSite);
        }

        // Finally indicate site/proxy.
        SetWindowText (GetDlgItem(hwnd,IDC_SERVER_OR_PROXY),
            ipt->lpszHost);

        (void)SendMessage(GetDlgItem(hwnd,IDC_USERNAME),
                          EM_LIMITTEXT,
                          (WPARAM)ipt->ulMaxField-1,
                          0L);

        (void)SendMessage(GetDlgItem(hwnd,IDC_PASSWORD),
                          EM_LIMITTEXT,
                          (WPARAM)ipt->ulMaxField-1,
                          0L);

        // If we already have a username, select
        // current password and put caret at end.
        if (*szUsername)
        {
            SendMessage(GetDlgItem(hwnd, IDC_PASSWORD),
                EM_SETSEL, 0, -1);

            SetFocus(GetDlgItem(hwnd, IDC_PASSWORD));
        }
        // Otherwise, select username
        else
        {
            SendMessage(GetDlgItem(hwnd, IDC_USERNAME),
                EM_SETSEL, 0, -1);

            SetFocus(GetDlgItem(hwnd, IDC_USERNAME));
        }

        // Return FALSE since we are always setting the keyboard focus.
        return FALSE;

    case WM_COMMAND:
        {

        WORD wID = LOWORD(wparam);
        WORD wNotificationCode = HIWORD(wparam);
        HWND hWndCtrl = (HWND) lparam;
        DWORD cbUsr, cbPass, cbDmn;

        ipt =
            (InvalidPassType *) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case IDOK:

                    INET_ASSERT(ipt);
                    INET_ASSERT(ipt->ulMaxField > 0 );
                    INET_ASSERT(ipt->lpszUsername);
                    INET_ASSERT(ipt->lpszPassword);

                    if (ipt->eAuthType == REALM_AUTH)
                    {
                        // Basic or digest auth - not much to do.
                        cbDmn = 0;

                        // Does not include null.

                        cbUsr = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_USERNAME),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                        INET_ASSERT(MAX_FIELD_LENGTH >= ipt->ulMaxField);
                        // Convert this  blindly to ANSI
                        SHUnicodeToAnsi(wszTmp, ipt->lpszUsername, ipt->ulMaxField);
                    }

                    // NTLM auth - separate domain and username if necessary.
                    else if (ipt->eAuthType == NTLM_AUTH)
                    {
                        // Does not include null.



                        cbDmn = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_DOMAIN_FIELD),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                        // Convert this blindly to ANSI
                        SHUnicodeToAnsi(wszTmp, ipt->lpszUsername, ipt->ulMaxField);
                        // Domain was typed in.
                        if (cbDmn)
                        {
                            // Check for backslash.
                            ptr = strchr(ipt->lpszUsername, DOMAIN_DELIMITER);
                            if (!ptr)
                            {
                                // No backslash - append one.
                                *(ipt->lpszUsername + cbDmn) = DOMAIN_DELIMITER;
                                *(ipt->lpszUsername + cbDmn + 1) = '\0';
                            }
                            // Found a backslash.
                            else
                            {
                                // Strip after backslash.
                                cbDmn = (DWORD)(ptr - ipt->lpszUsername);
                                *(ptr+1) = '\0';
                            }

                            cbDmn++;
                        }

                        // Get the username and append to domain.
                        cbUsr = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_USERNAME),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                        // Convert this blindly to ANSI
                        // BUGBUG - should i
                        SHUnicodeToAnsi(wszTmp, ipt->lpszUsername + cbDmn, (ipt->ulMaxField - cbDmn));

                    }


                    // Get the password.
                    cbPass = GetWindowTextWrapW(GetDlgItem(hwnd,IDC_PASSWORD),
                                              wszTmp,
                                              ARRAYSIZE(wszTmp));

                    SHUnicodeToAnsi(wszTmp, ipt->lpszPassword, ipt->ulMaxField);


                    // If save box checked, persist credentials.
                    if (IsDlgButtonChecked(hwnd, IDC_SAVE_PASSWORD) == BST_CHECKED)
                    {
                        InetSetCachedCredentials(ipt->lpszHost, ipt->lpszRealm,
                            ipt->lpszUsername, ipt->lpszPassword);
                    }
                    else
                    {
#ifndef UNIX
                        // Otherwise remove the credentials from persisted
                        // store, but only if necessary.
                        if (fLastCredentialsFromStore)
                        {
                            // Current and original credentials are same. Remove
                            // credentials.
                            InetRemoveCachedCredentials(ipt->lpszHost, ipt->lpszRealm);
                        }
#else
                    /*
                     * On Unix, we need to save the username/domain and not
                     * the password in this case
                     */
                    {
                        InetSetCachedCredentials(ipt->lpszHost, ipt->lpszRealm,
                            ipt->lpszUsername, NULL);
                    }
#endif /* UNIX */
                    }

                    EndDialog(hwnd, TRUE);
                    break;

                case IDCANCEL:

                    EndDialog(hwnd, FALSE);
                    break;
            }

        return TRUE;
        }

    case WM_HELP:               // F1
        WinHelp((HWND) ((LPHELPINFO) lparam)->hItemHandle,
                 "iexplore.hlp",
                 HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs);

    break;

    case WM_CONTEXTMENU:        // right mouse click
        WinHelp( hwnd,
                 "iexplore.hlp",
                 HELP_CONTEXTMENU,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs);
        break;
    }

    return FALSE;
}
VOID
UpdateGlobalSecuritySettings(
    IN DWORD dwCtlId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Updates several Global flags, and writes the update to the registry.
    The update is based on dwCtlId which is a dialog resource id.

    The update ALWAYS turns OFF the flag, since the only of turning
    it back on is to use the Ctl Pannel/Internet/Security PropSheet.

Arguments:

    dwCtlId    - Dialog ID to base update on.

    dwFlags    - Flags assoicated with the dialog.

Return Value:

    VOID
        none.


--*/

{
#ifndef WININET6
    switch ( dwCtlId )
    {
        case IDD_BAD_CN:
//        case IDD_BAD_CN_SENDING:

            //
            // BUGBUG [arthurbi] these are grouped together,
            //  they should be seperate.
            //

            GlobalWarnOnBadCertRecving = FALSE;
            GlobalWarnOnBadCertSending = FALSE;

            InternetWriteRegistryDword("WarnOnBadCertSending",
                                      (DWORD)GlobalWarnOnBadCertSending);

            InternetWriteRegistryDword("WarnOnBadCertRecving",
                                      (DWORD)GlobalWarnOnBadCertRecving);


            break;


        case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
        case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:

            GlobalWarnOnZoneCrossing = FALSE;


            InternetWriteRegistryDword("WarnOnZoneCrossing",
                                      (DWORD)GlobalWarnOnZoneCrossing);

            break;

        case IDD_WARN_ON_POST:

            GlobalWarnOnPost = FALSE;


            InternetWriteRegistryDword("WarnOnPost",
                                      (DWORD)GlobalWarnOnPost);

            break;

        case IDD_HTTP_POST_REDIRECT:

            GlobalWarnOnPostRedirect = FALSE;

            InternetWriteRegistryDword("WarnOnPostRedirect",
                                      (DWORD)GlobalWarnOnPostRedirect);

            break;
    }
#else
    switch ( dwCtlId )
    {
        case IDD_BAD_CN:
//        case IDD_BAD_CN_SENDING:

            //
            // BUGBUG [arthurbi] these are grouped together,
            //  they should be seperate.
            //

            GlobalWarnOnBadCertRecving = FALSE;
            GlobalWarnOnBadCertSending = FALSE;

            InternetIDEWriteRegistryDword("WarnOnBadCertSending",
                                      (DWORD)GlobalWarnOnBadCertSending);

            InternetIDEWriteRegistryDword("WarnOnBadCertRecving",
                                      (DWORD)GlobalWarnOnBadCertRecving);


            break;


        case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
        case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:

            GlobalWarnOnZoneCrossing = FALSE;


            InternetIDEWriteRegistryDword("WarnOnZoneCrossing",
                                      (DWORD)GlobalWarnOnZoneCrossing);

            break;

        case IDD_WARN_ON_POST:

            GlobalWarnOnPost = FALSE;


            InternetIDEWriteRegistryDword("WarnOnPost",
                                      (DWORD)GlobalWarnOnPost);

            break;

        case IDD_HTTP_POST_REDIRECT:

            GlobalWarnOnPostRedirect = FALSE;

            InternetIDEWriteRegistryDword("WarnOnPostRedirect",
                                      (DWORD)GlobalWarnOnPostRedirect);

            break;

    }
#endif
}


BOOL
SetCertDlgItem(
    HWND hDlg,
    DWORD dwIconCtl,
    DWORD dwTextCtl,
    DWORD dwString,
    BOOL  fError
)
/*++

--*/
{
    INET_ASSERT(hDlg);

    //
    // The default dialog code always load icons sized 32x32.  To get 16x16
    // we have to LoadImage to the correct size and then set the icon via
    // a windows message.
    //

    HICON hicon = (HICON)LoadImage(GlobalResHandle,
                               MAKEINTRESOURCE(fError ? IDI_WARN : IDI_SUCCESS),
                                   IMAGE_ICON, 16, 16, 0);

    if (hicon)
    {
        HICON hiconOld = (HICON)SendDlgItemMessage(hDlg, dwIconCtl,
                                                   STM_SETIMAGE,
                                                   (WPARAM)IMAGE_ICON,
                                                   (LPARAM)hicon);

        if (hiconOld)
            DestroyIcon(hiconOld);
    }

    //
    // The dialog displays the error string by default.  Replace this with the
    // success string if an error didn't occur.
    //

    if (!fError)
    {
        WCHAR sz[512];

        if (LoadStringWrapW(GlobalResHandle, dwString, sz, ARRAY_ELEMENTS(sz)))
            SetDlgItemTextWrapW(hDlg, dwTextCtl, sz);
    }

    return TRUE;
}

BOOL InitSecCertErrorsDlg(
    HWND hDlg,
    PERRORINFODLGTYPE pDlgInfo
)
/*++

--*/
{
    INET_ASSERT(pDlgInfo);

    //
    // Get the errors that occured from the hInternetMapped object.
    //

    DWORD dwFlags;

    if (pDlgInfo->hInternetMapped)
    {
        dwFlags = ((HTTP_REQUEST_HANDLE_OBJECT*)pDlgInfo->hInternetMapped)->GetSecureFlags();
    }
    else
    {
        dwFlags = -1; // Display all errors.
    }

    //
    // If an error occured set the ignore flag so if the users selects to bypass
    // this error it gets ignored the next time through.  Then initialize the
    // dialog icons and text.
    //

    if (dwFlags & DLG_FLAGS_INVALID_CA)
    {
        pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_INVALID_CA;
    }

    SetCertDlgItem(hDlg, IDC_CERT_TRUST_ICON, IDC_CERT_TRUST_TEXT,
                   IDS_CERT_TRUST, dwFlags & DLG_FLAGS_INVALID_CA);

    if (dwFlags & DLG_FLAGS_SEC_CERT_DATE_INVALID)
    {
        pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_CERT_DATE_INVALID;
    }

    SetCertDlgItem(hDlg, IDC_CERT_DATE_ICON, IDC_CERT_DATE_TEXT,
                   IDS_CERT_DATE, dwFlags & DLG_FLAGS_SEC_CERT_DATE_INVALID);

    if (dwFlags & DLG_FLAGS_SEC_CERT_CN_INVALID)
    {
        pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_CERT_CN_INVALID;
    }

    SetCertDlgItem(hDlg, IDC_CERT_NAME_ICON, IDC_CERT_NAME_TEXT,
                   IDS_CERT_NAME, dwFlags & DLG_FLAGS_SEC_CERT_CN_INVALID);

    //
    // Set the focus to the "No" button and return FALSE so the default dialog
    // code doesn't set the focus to "Yes".
    //

    SetFocus(GetDlgItem(hDlg, IDCANCEL));

    return FALSE;
}


INT_PTR
CALLBACK
OkCancelDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Supports Yes/No, Ok/Cancel decisions for the authentication UI.

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    BOOL              fRet = FALSE;
    PERRORINFODLGTYPE pDlgInfo;

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        (void)SetWindowLongPtr(hwnd,
                               DWLP_USER,
                               lparam);

        pDlgInfo = (PERRORINFODLGTYPE)lparam;

        if (IDD_SEC_CERT_ERRORS == pDlgInfo->dwDlgId)
        {
            fRet = InitSecCertErrorsDlg(hwnd, pDlgInfo);
        }
        else if (IDD_REVOCATION_PROBLEM == pDlgInfo->dwDlgId)
        {
            DWORD dwFlags = 0;

            if (pDlgInfo->hInternetMapped)
                dwFlags = ((HTTP_REQUEST_HANDLE_OBJECT*)pDlgInfo->hInternetMapped)->GetSecureFlags();
            if (dwFlags & DLG_FLAGS_SEC_CERT_REV_FAILED)
                pDlgInfo->dwDlgFlags |= DLG_FLAGS_IGNORE_FAILED_REVOCATION;
        }
        else
        {
#ifdef UNIX
        /* Unix Does not support Context-sensitive help.
         * Don't show the More Info button
         */
        //UnixAdjustButtonSpacing(hwnd, pDlgInfo->dwDlgId);
        UnixRemoveMoreInfoButton(hwnd, pDlgInfo->dwDlgId);
#endif /* UNIX */

            fRet = TRUE;
        }

        // set this dialog as foreground if necessary
        if(pDlgInfo->dwDlgFlags & DLG_FLAGS_BRING_TO_FOREGROUND)
        {
            SetForegroundWindow(hwnd);
        }

        break;

    case WM_COMMAND:
        {

        WORD wID = LOWORD(wparam);
        WORD wNotificationCode = HIWORD(wparam);
        HWND hWndCtrl = (HWND) lparam;

        pDlgInfo =
            (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case ID_CERT_EDIT:

                    //
                    // BUGBUG why can't we do this on WM_INITDIALOG?
                    //

                    if ( wNotificationCode == EN_SETFOCUS)
                    {
                        //
                        // clear any selection, caused by it being the first
                        //  edit control on the dlg page.
                        //

                        if ( ! (pDlgInfo->dwDlgFlags & DLG_FLAGS_HAS_DISABLED_SELECTION) )
                        {
                            SendDlgItemMessage(hwnd,ID_CERT_EDIT,EM_SETSEL,(WPARAM) (INT)-1,0);
                            pDlgInfo->dwDlgFlags |= DLG_FLAGS_HAS_DISABLED_SELECTION;
                        }
                    }

                    break;

                case ID_TELL_ME_ABOUT_SECURITY:
                    {
                    //
                    // Launches help for this button.
                    //

                    //
                    // BUGBUG remove the constant "iexplore.hlp"
                    //
                    UINT uiID = 1;

                    switch (pDlgInfo->dwDlgId)
                    {
                        case IDD_CONFIRM_COOKIE:
                            uiID = IDH_SEC_SEND_N_REC_COOKIES;
                            break;

                        case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
                            uiID = IDH_SEC_ENTER_SSL;
                            break;

                        case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:
                             uiID = IDH_SEC_ENTER_NON_SECURE_SITE;
                             break;

                        case IDD_INVALID_CA:
                            uiID = IDH_SEC_ENTER_SSL_W_INVALIDCERT;
                            break;

                        case IDD_BAD_CN:
                            uiID = IDH_SEC_SIGNED_N_INVALID;
                            break;

                        case IDD_MIXED_SECURITY:
                            uiID = IDH_SEC_MIXED_DOWNLOAD_FROM_SSL;
                            break;

                    }
                    WinHelp(
                            hwnd,
                            "iexplore.hlp",
                            HELP_CONTEXT,
                            (ULONG_PTR)uiID
                            );
                    break;
                    }


                case ID_SHOW_CERTIFICATE:

                    //
                    // If this dialog supports this behavior, then launch
                    //  a show certficate dlg.
                    //

                    if ( (pDlgInfo->dwDlgFlags & DLG_FLAGS_CAN_HAVE_CERT_INFO) &&
                         wNotificationCode == BN_CLICKED)
                    {
                        INTERNET_SECURITY_INFO ciSecInfo;


                        if (ERROR_SUCCESS == ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetSecurityInfo(
                                                    (LPINTERNET_SECURITY_INFO) &ciSecInfo))
                        {



                            ShowSecurityInfo(
                                hwnd,
                                &ciSecInfo
                                );

                            CertFreeCertificateContext(ciSecInfo.pCertificate);
                        }
                    }

                    break;

                case IDOK:
                case IDYES:

                    INET_ASSERT(pDlgInfo);
                    INET_ASSERT(pDlgInfo->dwDlgId != 0);

                    //
                    // Save flags, and change any global vars,
                    //  and registry values if needed.
                    //

                    if (pDlgInfo->hInternetMapped)
                    {
                        HTTP_REQUEST_HANDLE_OBJECT *pHttpRequest;

                        pHttpRequest = (HTTP_REQUEST_HANDLE_OBJECT *)
                                pDlgInfo->hInternetMapped;

                        pHttpRequest->SetSecureFlags(
                                pDlgInfo->dwDlgFlags
                                );
                    }

                    //
                    // If the user checked the "overide" check-box
                    //  let us map it, and force a general
                    //  override of all errors of this type.
                    //

                    if ( IsDlgButtonChecked(hwnd, IDC_DONT_WANT_WARNING) == BST_CHECKED )
                    {
                        UpdateGlobalSecuritySettings(
                            pDlgInfo->dwDlgId,
                            pDlgInfo->dwDlgFlags
                            );
                    }

                    EndDialog(hwnd, TRUE);
                    break;

                case IDCANCEL:
                case IDNO:

                    EndDialog(hwnd, FALSE);
                    break;
            }

        fRet = TRUE;
        break;
        }
    }

    return fRet;
}

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

BOOL
InitCookieDialog(HWND hwnd,PCOOKIE_DLG_INFO pcdi)
/*++
    Fills in all of the fields and resizes the cookie dialog correctly

  Returns TRUE, unless the pcdi is invalid
--*/
{
    RECT rctDlg, rctDetails;
    INT cy;
    SYSTEMTIME st;
    DWORD dwResource;
    BOOL fResult = FALSE;

    INET_ASSERT(pcdi);

    WCHAR wszTemp[INTERNET_MAX_URL_LENGTH];
    WCHAR wszTemp2[INTERNET_MAX_URL_LENGTH];

    if (!pcdi                   ||
        !pcdi->pszServer)
        goto Cleanup;

/*  Don't necessarily have a pic anymore

    if (!pcdi                   ||
        !pcdi->pszServer        ||
        !pcdi->pic->pszName      ||
        !pcdi->pic->pszData      ||
        !pcdi->pic->pszDomain    ||
        !pcdi->pic->pszPath      )
        return FALSE;
*/


    SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pcdi);

    //  do init here.  do we need to do a load loadicon??

    // must limit the size of the window

    GetWindowRect(hwnd, &rctDlg);
    GetWindowRect(GetDlgItem(hwnd, IDC_COOKIE_INFO), &rctDetails);

    pcdi->cx = rctDlg.right - rctDlg.left;
    pcdi->cy = rctDlg.bottom - rctDlg.top;
    cy = rctDetails.top - rctDlg.top;

    SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0,
        pcdi->cx, cy,
        SWP_NOMOVE | SWP_NOZORDER);

    if(pcdi->pic && pcdi->pic->pszDomain)
    {
        LoadStringWrapW(GlobalResHandle, IDS_COOKIE_SAVE, wszTemp, ARRAYSIZE(wszTemp));
        wnsprintfW(wszTemp2, ARRAYSIZE(wszTemp2), wszTemp, pcdi->pic->pszDomain);
        SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_QUESTION), wszTemp2);
    }
    else
    {
        INET_ASSERT(FALSE);
    }

    // Convert to W before setting these fields
    if(pcdi->pic)
    {
        //
        // if we have a pic, fill out the members
        //
        if(SHAnsiToUnicode(pcdi->pic->pszData, wszTemp, ARRAYSIZE(wszTemp)))
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_DATA),wszTemp);
        
        if(SHAnsiToUnicode(pcdi->pic->pszDomain, wszTemp, ARRAYSIZE(wszTemp)))
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_DOMAIN),wszTemp);
        
        if(SHAnsiToUnicode(pcdi->pic->pszPath, wszTemp, ARRAYSIZE(wszTemp)))
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_PATH),wszTemp);
        
        if (pcdi->dwOperation & COOKIE_OP_3RD_PARTY)
            LoadStringWrapW(GlobalResHandle, IDS_YES, wszTemp, ARRAYSIZE(wszTemp));
        else
            LoadStringWrapW(GlobalResHandle, IDS_NO, wszTemp, ARRAYSIZE(wszTemp));
        
        SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_3RDPARTY), wszTemp);
        
        if (pcdi->dwOperation & COOKIE_OP_SESSION)
            LoadStringWrapW(GlobalResHandle, IDS_YES, wszTemp, ARRAYSIZE(wszTemp));
        else
            LoadStringWrapW(GlobalResHandle, IDS_NO, wszTemp, ARRAYSIZE(wszTemp));
        
        SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_SESSION), wszTemp);

        if( pcdi->pic->pszP3PPolicy != NULL)
            if( SHAnsiToUnicode( pcdi->pic->pszP3PPolicy, wszTemp, ARRAYSIZE( wszTemp)))
                SetWindowTextWrapW( GetDlgItem( hwnd, IDC_COOKIE_POLICY), wszTemp);
        
        if(0 == (pcdi->dwOperation & COOKIE_OP_GET))
        {
            if(SHAnsiToUnicode(pcdi->pic->pszName, wszTemp, ARRAYSIZE(wszTemp)))
                SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_NAME),wszTemp);
            
            if (pcdi->pic->dwFlags & INTERNET_COOKIE_IS_SECURE)
                LoadStringWrapW(GlobalResHandle, IDS_YES, wszTemp, ARRAYSIZE(wszTemp));
            else
                LoadStringWrapW(GlobalResHandle, IDS_NO, wszTemp, ARRAYSIZE(wszTemp));
            
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_SECURE),
                wszTemp);
            
            if(pcdi->pic->pftExpires &&
                FileTimeToSystemTime(pcdi->pic->pftExpires, &st) )
            {
                LCID lcid = GetUserDefaultLCID();
                WCHAR szDate[64];
                WCHAR szTime[64];
                WCHAR szDateFormat[] = L"ddd',' MMM dd yyyy";
                WCHAR szTimeFormat[] = L"HH':'mm':'ss";

                GetDateFormatWrapW(lcid, 0, &st, szDateFormat, szDate, 64);
                GetTimeFormatWrapW(lcid, 0, &st, szTimeFormat, szTime, 64);
            
                StrCpyNW(wszTemp, szDate, 64);
                StrCatBuffW(wszTemp, L" ", ARRAYSIZE(wszTemp));
                StrCatBuffW(wszTemp, szTime, ARRAYSIZE(wszTemp));
            }
            else
                LoadStringWrapW(GlobalResHandle, IDS_COOKIE_EXPIRES_ENDSESSION, wszTemp, ARRAYSIZE(wszTemp));
            
            SetWindowTextWrapW(GetDlgItem(hwnd, IDC_COOKIE_EXPIRES),
                wszTemp);
        }       
    }

    // BUGBUGHACK - we actually should be called with the clients hwnd as parent -zekel 15MAY97
    //  then we wouldnt have to do this.  this avoids the window coming up behind a browser window.
    //  of course they can still switch out, and close the browser, which will fault.
    SetForegroundWindow(hwnd);

    fResult = TRUE;

Cleanup:

    return fResult;
}

#define COOKIE_DONT_ALLOW   1
#define COOKIE_ALLOW        2
#define COOKIE_ALLOW_ALL    4
#define COOKIE_DONT_ALLOW_ALL 8

INT_PTR
CALLBACK
CookieDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

{

    DWORD  dwEndDlg = 0;
    BOOL fReturn = FALSE;
    PCOOKIE_DLG_INFO pcdi;

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        if(!InitCookieDialog(hwnd, (PCOOKIE_DLG_INFO) lparam))
        {
            dwEndDlg = COOKIE_DONT_ALLOW;
        }

        if( IsOS(OS_WHISTLERORGREATER))
        {
            HICON hIcon = LoadIcon(GlobalResHandle, MAKEINTRESOURCE(IDI_PRIVACY_XP));
            if( hIcon != NULL)
                SendDlgItemMessage(hwnd, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            // icons loaded with LoadIcon never need to be released
        }
            
        fReturn = TRUE;
        break;

    case WM_COMMAND:
        {

            pcdi = (PCOOKIE_DLG_INFO) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (LOWORD(wparam))
            {
                case IDYES:
                    dwEndDlg = COOKIE_ALLOW;

                    if(BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_COOKIE_ALLOW_ALL))
                    {
                        pcdi->dwStopWarning = COOKIE_ALLOW_ALL;
                    }
                    fReturn = TRUE;
                    break;


                case IDNO:
                    dwEndDlg = COOKIE_DONT_ALLOW;

                    if(BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_COOKIE_ALLOW_ALL))
                    {
                        pcdi->dwStopWarning = COOKIE_DONT_ALLOW_ALL;
                    }
                    fReturn = TRUE;
                    break;

                case IDC_COOKIE_HELP:
                    WinHelp(hwnd,
                            "iexplore.hlp",
                            HELP_CONTEXT,
                            (pcdi->dwOperation & COOKIE_OP_3RD_PARTY) ?
                                (ULONG_PTR)IDH_COOKIE_THIRD_PARTY :
                                (ULONG_PTR)IDH_COOKIE_FIRST_PARTY
                            );
                    fReturn = TRUE;
                    break;

                case IDC_COOKIE_DETAILS:

                    //
                    //  Fold out the bottom of the dialog
                    //

                    SetWindowPos(hwnd, HWND_TOP, 0, 0,
                        pcdi->cx, pcdi->cy,
                        SWP_NOMOVE | SWP_NOZORDER);

                    EnableWindow(GetDlgItem(hwnd, IDC_COOKIE_DETAILS), FALSE);

                    PostMessage( hwnd, WM_NEXTDLGCTL, 
                                 (WPARAM)GetDlgItem( hwnd, IDC_COOKIE_NAME), TRUE);

                    fReturn = TRUE;
                    break;

            }
        }

        break;

    }

    if(dwEndDlg)
    {
        EndDialog(hwnd, (dwEndDlg == COOKIE_DONT_ALLOW) ? ERROR_HTTP_COOKIE_DECLINED : ERROR_SUCCESS);
    }

    return fReturn;
}

INT_PTR
CALLBACK
InsertCDDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

{
    PERRORINFODLGTYPE pDlgInfo;
    DWORD dwDlgEnd = 0;
    HTTP_REQUEST_HANDLE_OBJECT* phro;
    CHAR szName[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];
    BOOL fCD;

    // Cache container info struct.
    BYTE buf[2048];
    DWORD cbCoI = 2048;
    LPINTERNET_CACHE_CONTAINER_INFO pCoI = (LPINTERNET_CACHE_CONTAINER_INFO) buf;

    LPSTR pszUrl;
    BOOL fReturn = FALSE;

    switch (msg)
    {
        // On dialog initialize.
        case WM_INITDIALOG:
        {
            INET_ASSERT(lparam);

            // Get the http request object.
            pDlgInfo = (PERRORINFODLGTYPE)lparam;
            (void)SetWindowLongPtr(hwnd, DWLP_USER, lparam);

            phro = (HTTP_REQUEST_HANDLE_OBJECT*) pDlgInfo->hInternetMapped;

            // Set the dialog window text with the container name.
            pszUrl = phro->GetURL();
            if (pszUrl && GetUrlCacheContainerInfo(pszUrl, pCoI, &cbCoI, 0))
                SetWindowText(GetDlgItem(hwnd,IDC_CD_NAME), pCoI->lpszVolumeTitle);

            fReturn = TRUE;
            break;
        }

        // User entered info.
        case WM_COMMAND:
        {
            pDlgInfo = (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);
            INET_ASSERT(pDlgInfo);

            switch (LOWORD(wparam))
            {
                case IDC_USE_CDROM:
                    dwDlgEnd = ERROR_INTERNET_FORCE_RETRY;

                    // Signal that dialog is no longer active.
                    fCD = InterlockedExchange((LONG*) &fCdromDialogActive, (LONG) FALSE);
                    INET_ASSERT(fCD);
                    fReturn = TRUE;
                    break;

                case IDC_CONNECT_TO_INTERNET:

                    // Delete all containers with the same volume label.

                    // Get the http request object.
                    phro = (HTTP_REQUEST_HANDLE_OBJECT*) pDlgInfo->hInternetMapped;

                    // Set the dialog window text with the container name.
                    pszUrl = phro->GetURL();

                    // Get the container info for this url.
                    if (pszUrl && GetUrlCacheContainerInfo(pszUrl, pCoI, &cbCoI, 0))
                    {
                        // Found a volume label:
                        if (*pCoI->lpszVolumeLabel)
                            strcpy(szVolumeLabel, pCoI->lpszVolumeLabel);
                        else
                            *szVolumeLabel = '\0';

                        // Start an enumeration of containers.
                        DWORD dwOptions, dwModified;
                        dwOptions = dwModified = 0;
                        HANDLE hConFind = FindFirstUrlCacheContainer(&dwModified,
                            pCoI, &(cbCoI = 2048), dwOptions);
                        if (hConFind)
                        {
                            // If the volume label of the first container found
                            // match the volume label of the associated url then
                            // delete this container.
                            if ((*pCoI->lpszVolumeLabel == '\0')
                                || (!strcmp(szVolumeLabel, pCoI->lpszVolumeLabel)))
                            {
                                DeleteUrlCacheContainer(pCoI->lpszName, 0);
                            }
                            // Similarly, delete each container which
                            // is found to have a matching volume label.
                            while (FindNextUrlCacheContainer(hConFind,
                                   pCoI, &(cbCoI = 2048)))
                            {
                                if ((*pCoI->lpszVolumeLabel == '\0')
                                    || (!strcmp(szVolumeLabel, pCoI->lpszVolumeLabel)))
                                {
                                    DeleteUrlCacheContainer(pCoI->lpszName, 0);
                                }
                            }
                            FindCloseUrlCache(hConFind);
                        }
                    }
                    dwDlgEnd = ERROR_CANCELLED;

                    // Signal that dialog is no longer active.
                    fCD = InterlockedExchange((LONG*) &fCdromDialogActive, (LONG) FALSE);
                    INET_ASSERT(fCD);
                    fReturn = TRUE;
                    break;
            }
        }

        break;
    }

    if (dwDlgEnd)
        EndDialog(hwnd, dwDlgEnd);

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\persist.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    persist.cxx

Abstract:

Author:

    Adriaan Canter (adriaanc) 13-Jan-1998

Revision History:

    13-Jan-1998 adriaanc
        Created

--*/

#include <wininetp.h>
#include <persist.h>

typedef HRESULT (*PFNPSTORECREATEINSTANCE)(IPStore**, PST_PROVIDERID*, VOID*, DWORD);

// Globals

// PWL related variables.
static HMODULE MhmodWNET                                     = NULL;
static PFWNETGETCACHEDPASSWORD pfWNetGetCachedPassword       = NULL;
static PFWNETCACHEPASSWORD pfWNetCachePassword               = NULL;
static PFWNETREMOVECACHEDPASSWORD pfWNetRemoveCachedPassword = NULL;

// Pstore related variables.
static PST_PROVIDERID s_provID                       = GUID_NULL;
static WCHAR c_szWininetCacheCredentials[]           = L"WininetCacheCredentials";
static PFNPSTORECREATEINSTANCE pPStoreCreateInstance = NULL;


// Webcheck is currently using this GUID for pstore:
// {14D96C20-255B-11d1-898F-00C04FB6BFC4}
// static const GUID GUID_PStoreType = { 0x14d96c20, 0x255b, 0x11d1, { 0x89, 0x8f, 0x0, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4 } };

// Wininet uses this GUID for pstore:
// {5E7E8100-9138-11d1-945A-00C04FC308FF}
static const GUID GUID_PStoreType = 
{ 0x5e7e8100, 0x9138, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0xff } };


// Private function prototypes.

// PWL private function prototypes.
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred);
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey, LPSTR cbCred, LPDWORD pcbCred);
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey);

BOOL LoadWNet(VOID);


// PStore private function prototypes.
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred, BOOL fRemove=FALSE);
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, LPDWORD pcbCred);
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey);

STDAPI CreatePStore (IPStore **ppIPStore);
STDAPI ReleasePStore(IPStore  *pIPStore);


/*--------------------------- Top Level APIs ---------------------------------*/


BOOL ReadLSARegistryDword( CHAR* lpszValueName, DWORD* pdwValue)
{
    BOOL bRetVal = FALSE;
    HKEY key;
    DWORD dwType;

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Control\\Lsa",
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        
        DWORD dwSize = sizeof(DWORD);
        if ( RegQueryValueEx(
                key,
                lpszValueName,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwSize ) == ERROR_SUCCESS )
        {
            bRetVal = TRUE;
        }


        RegCloseKey(key);

    }

    return bRetVal;

}

/*-----------------------------------------------------------------------------
    InetInitCredentialPersist
  ---------------------------------------------------------------------------*/
DWORD InetInitCredentialPersist()
{
    HRESULT hr;
    IPStore *pIPStore = NULL;
    DWORD dwDisable, dwAvail, dwLSADisable;
    HINSTANCE hInstPStoreC = 0;
    BOOL fPersistDisabled = FALSE;

    AuthLock();
    
    // First check to see if persistence is disabled via registry.
    if ((InternetReadRegistryDword(DISABLE_PASSWORD_CACHE_VALUE, &dwDisable) == ERROR_SUCCESS)
        && (dwDisable == CRED_PERSIST_AVAIL))
    {
        // Persistence disabled via registry.
        dwAvail= CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }

    // check to see if credmgr registry has disabled it
    if ( ReadLSARegistryDword( "DisableDomainCreds", & dwLSADisable ) && dwLSADisable )
    {
        // Persistence disabled via registry.
        dwAvail= CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }
    
    // We use PWL for Win95; this should be available.
    if (IsPlatformWin95())
    {
        dwAvail = CRED_PERSIST_AVAIL;
        goto quit;
    }

    // If is WinNt, check if PStore is installed. 
    hInstPStoreC = LoadLibrary(PSTORE_MODULE);
    if (!hInstPStoreC)
    {
        dwAvail = CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }
    else
    {
        // Get CreatePStoreInstance function pointer.
        pPStoreCreateInstance = (PFNPSTORECREATEINSTANCE) 
            GetProcAddress(hInstPStoreC, "PStoreCreateInstance");
        
        if (!pPStoreCreateInstance)
        {
            dwAvail = CRED_PERSIST_NOT_AVAIL;
            goto quit;
        }
    }
    
    // Create an IPStore.
    hr = CreatePStore(&pIPStore);
        
    // Succeeded in creating an IPStore.
    if (SUCCEEDED(hr) && pIPStore)
    {
        ReleasePStore(pIPStore);
        dwAvail = CRED_PERSIST_AVAIL;
    }
    else
    {
        // Failed to create an IPStore.
        dwAvail = CRED_PERSIST_NOT_AVAIL;
    }

quit:
    g_dwCredPersistAvail = dwAvail;

    AuthUnlock();

    return g_dwCredPersistAvail;
}


/*-----------------------------------------------------------------------------
  InetSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD InetSetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealm, 
                                 LPSTR szUser, 
                                 LPSTR szPass)
{
    DWORD cbKey, cbCred, dwError = ERROR_INTERNET_INTERNAL_ERROR;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH], 
         szCred[MAX_AUTH_FIELD_LENGTH];

    INET_ASSERT(szHost && *szHost && szRealm 
        && szUser && *szUser && szPass);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }


    // Form key and credential strings.
    cbKey  = wsprintf(szKey, "%s/%s", szHost, szRealm) + 1;
#ifndef UNIX
    cbCred = wsprintf(szCred,"%s:%s", szUser, szPass) + 1;
#else
    /* wsprintf on UNIX puts "(null)" if szPass is null. */
    cbCred = szPass ? (wsprintf(szCred,"%s:%s", szUser, szPass) + 1) :
                      (wsprintf(szCred,"%s:", szUser) + 1);
#endif /* UNIX */
        
    // Store credentials.
    if (IsPlatformWin95())
    {
        // Store credentials using PWL.
        dwError = PWLSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }
    else
    {
        // Store credentials using PStore.
        dwError = PStoreSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }

quit:

    return dwError;
}


/*-----------------------------------------------------------------------------
  InetGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD InetGetCachedCredentials  (LPSTR szHost, 
                                 LPSTR szRealm, 
                                 LPSTR szUser, 
                                 LPSTR szPass)

{
    DWORD cbKey, cbCred, nUser, dwError;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH],
         szCred[MAX_AUTH_FIELD_LENGTH],
         *ptr;

    INET_ASSERT(szHost && *szHost && szRealm && szUser && szPass);

    // Check if credential persistence is available.
    if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        InetInitCredentialPersist();
    
    if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }


    // Key string in form of host/[realm or domain].
    cbKey  = wsprintf(szKey, "%s/%s", szHost, szRealm) + 1;
    cbCred = MAX_AUTH_FIELD_LENGTH;

    if (IsPlatformWin95())
    {
        // Store credentials using PWL.
        if ((dwError = PWLGetCachedCredentials(szKey, cbKey, 
            szCred, &cbCred)) != WN_SUCCESS)
            goto quit;
    }
    else
    {
        // Store credentials using PStore.
        if ((dwError = PStoreGetCachedCredentials(szKey, cbKey, 
            szCred, &cbCred)) != ERROR_SUCCESS)
            goto quit;
    }

    // Should have retrieved credentials in form of username:password.
    ptr = strchr(szCred, ':');

    // Should never happen since username & password are required.
    if (!ptr || (ptr == szCred))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    // Copy username & null terminate.
    nUser = (DWORD)(ptr - szCred);
    memcpy(szUser, szCred, nUser);
    szUser[nUser] = '\0';

    // Copy password with null terminator.
    memcpy(szPass, ptr+1, cbCred - nUser);

quit:
    
    return dwError;
}


/*-----------------------------------------------------------------------------
  InetRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD InetRemoveCachedCredentials (LPSTR szHost, LPSTR szRealm)
{
    DWORD cbKey, dwError;
    CHAR szKey[MAX_AUTH_FIELD_LENGTH];

    INET_ASSERT(szHost && *szHost && szRealm);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    // Form key string.
    cbKey  = wsprintf(szKey, "%s/%s", szHost, szRealm) + 1;

    if (IsPlatformWin95())
    {
        // Remove credentials from PWL.
        dwError = PWLRemoveCachedCredentials(szKey, cbKey);
    }
    else
    {
        // Remove credentials from PStore.
        dwError =  PStoreRemoveCachedCredentials(szKey, cbKey);
    }

quit:
    return dwError;
}


/*--------------------------- PWL Functions ---------------------------------*/



/*-----------------------------------------------------------------------------
  PWLSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey, 
                              LPSTR szCred, DWORD cbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;
    
    // Store credentials.  
    dwError =  (*pfWNetCachePassword)(szKey, (WORD) cbKey, szCred, (WORD) cbCred, PCE_WWW_BASIC, 0); 

    return dwError;
}




/*-----------------------------------------------------------------------------
  PWLGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey, 
                                LPSTR szCred, LPDWORD pcbCred)
{    
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    // Retrieve credentials.
    dwError = (*pfWNetGetCachedPassword) (szKey, (WORD) cbKey, szCred, 
                                          (LPWORD) pcbCred, PCE_WWW_BASIC);
    
    return dwError;
}



/*-----------------------------------------------------------------------------
  PWLRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    dwError = (*pfWNetRemoveCachedPassword) (szKey, (WORD) cbKey, PCE_WWW_BASIC);

    return dwError;
}


// PWL utility functions.


/*-----------------------------------------------------------------------------
  LoadWNet
  ---------------------------------------------------------------------------*/
BOOL LoadWNet(VOID)
{
    BOOL fReturn;
    
    AuthLock();

    // MPR.DLL already loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
        goto quit;
    }

    // Load MPR.DLL
    MhmodWNET = LoadLibrary(WNETDLL_MODULE);
    
    // Fail if not loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
        goto quit;
    }

    pfWNetGetCachedPassword    = (PFWNETGETCACHEDPASSWORD)    GetProcAddress(MhmodWNET, WNETGETCACHEDPASS);
    pfWNetCachePassword        = (PFWNETCACHEPASSWORD)        GetProcAddress(MhmodWNET, WNETCACHEPASS);
    pfWNetRemoveCachedPassword = (PFWNETREMOVECACHEDPASSWORD) GetProcAddress(MhmodWNET, WNETREMOVECACHEDPASS);

    // Ensure we have all function pointers.
    if (!(pfWNetGetCachedPassword 
          && pfWNetCachePassword
          && pfWNetRemoveCachedPassword))
    {
        fReturn = FALSE;
    }

quit:
    AuthUnlock();
    
    return fReturn;
}



/*------------------------- PStore Functions -------------------------------*/



/*-----------------------------------------------------------------------------
  PStoreSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey, 
                                 LPSTR szCred, DWORD cbCred, 
                                 BOOL fRemove)
{
    INET_ASSERT(pPStoreCreateInstance);

    HRESULT         hr;
    DWORD           dwError;
    
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo = {0};

    GUID itemType    = GUID_PStoreType;
    GUID itemSubtype = GUID_NULL;

    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];
    
    IPStore *       pStore = NULL;
    
    // PST_TYPEINFO data.
    typeInfo.cbSize = sizeof(typeInfo);
    typeInfo.szDisplayName = c_szWininetCacheCredentials;

    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    INET_ASSERT(pStore != NULL);
               
    // Create a type in HKCU.
    hr = pStore->CreateType(PST_KEY_CURRENT_USER, &itemType, &typeInfo, 0);
    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Create subtype.
    hr = pStore->CreateSubtype(PST_KEY_CURRENT_USER, &itemType, 
                               &itemSubtype, &typeInfo, NULL, 0);

    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;
            
    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);
    
    // Valid credentials are written; No credentials imples
    // that the key and credentials are to be deleted.
    if (szCred && cbCred && !fRemove)
    {
        // Write key and credentials to PStore.
        hr = pStore->WriteItem(PST_KEY_CURRENT_USER,
                               &itemType,
                               &itemSubtype,
                               wszKey,
                               cbCred,
                               (LPBYTE) szCred,
                               &promptInfo,
                               PST_CF_NONE,
                               0);
    }
    else
    {
        // Delete key and credentials from PStore.
        hr = pStore->DeleteItem(PST_KEY_CURRENT_USER,
                                &itemType,
                                &itemSubtype,
                                wszKey,
                                &promptInfo,
                                0);

    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);
    
    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;

    return dwError;
}                                                                       


/*-----------------------------------------------------------------------------
  PStoreGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey, 
                                 LPSTR szCred, LPDWORD pcbCred)
{
    INET_ASSERT(pPStoreCreateInstance);

    HRESULT          hr ;
    DWORD            dwError;
    LPBYTE           pbData;

    PST_PROMPTINFO   promptInfo  = {0};

    GUID             itemType    = GUID_PStoreType;
    GUID             itemSubtype = GUID_NULL;

    IPStore*         pStore      = NULL;
    
    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];

    
    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    INET_ASSERT(pStore != NULL);

    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);

    // Read the credentials from PStore.
    hr = pStore->ReadItem(PST_KEY_CURRENT_USER,
                          &itemType,
                          &itemSubtype,
                          wszKey,
                          pcbCred,
                          (LPBYTE*) &pbData,
                          &promptInfo,
                          0);

    // Copy credentials and free buffer allocated by ReadItem.
    if (SUCCEEDED(hr))
    {
        memcpy(szCred, pbData, *pcbCred);
        CoTaskMemFree(pbData);
        //hr = S_OK;
    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
    
    return dwError;
}

/*-----------------------------------------------------------------------------
  PStoreRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey)
{
    // Pass in TRUE to remove credentials.
    return PStoreSetCachedCredentials(szKey, cbKey, NULL, 0, TRUE);
}

// PStore utility functions

/*-----------------------------------------------------------------------------
  CreatePStore
  ---------------------------------------------------------------------------*/
STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;
    DWORD dwError;

    
    hr = pPStoreCreateInstance (ppIPStore,
                                  IsEqualGUID(s_provID, GUID_NULL) ? NULL : &s_provID,
                                  NULL,
                                  0);

  if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;

    return dwError;
}


/*-----------------------------------------------------------------------------
  ReleasePStore
  ---------------------------------------------------------------------------*/
STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\ierrui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ierrui.cxx

Abstract:

    Contains immplimentation of generic Error UI API.

    Contents:
        InternetErrorDlg
        InternetConfirmZoneCrossing
        (wErrorUIInvalidPassword)

Author:

    Arthur L Bierer (arthurbi) 04-Apr-1996

Revision History:

    04-Apr-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include <persist.h>
#include "ierrui.hxx"


//
// private prototypes
//



PRIVATE
DWORD
wErrorUIInvalidPassword(
    IN HWND hWnd,
    IN OUT HINTERNET hRequest,
    IN DWORD dwError,
    IN DWORD dwFlags,
    IN OUT LPVOID *lppvData
    );


//
// public functions
//

INTERNETAPI_(DWORD) InternetErrorDlg(IN HWND hWnd,
                 IN OUT HINTERNET hRequest,
                 IN DWORD dwError,
                 IN DWORD dwFlags,
                 IN OUT LPVOID *lppvData
                 )
/*++

Routine Description:

    Creates an Error Dialog informing the User of a problem with a WinINet HttpSendRequest.
    Can optionally store the results of dialog in the HTTP handle.
    Data may be specified in the lppvData pointer, or optionally InternetErrorDlg
    will gather the information from the HTTP handle

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    hRequest -    An open HTTP request handle
                  where headers will be added if needed.

    dwError -     The Error code to which the appropriate UI will be shown for.

    dwFlags -     Can be any of all of the following Flags:

                    FLAGS_ERROR_UI_FLAGS_GENERATE_DATA - generates lppvData, and queries
                    internet handle for information.

                    FLAGS_ERROR_UI_FILTER_FOR_ERRORS - scans the returned headers,
                    and determines if there is a "hidden" error, such as an authentication
                    failure.

                    FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS - On successful return of the dialog,
                    this flag will causes the results to be stored in the handle.

                    FLAGS_ERROR_UI_SERIALIZE_DIALOGS - display only one auth dlg and
                    notify subsequent threads when the dialog has been dismissed.

    lppvData -    Contains a Pointer to a Pointer where a stucture is stored containing
                  error specific data, and Dialog results.


Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Serveral Error codes defined in winerror.h or wininet.w

Comments:

    BUGBUG - need to look into multiple authentication scheme handling, and
    how it relates to the UI

--*/

{
    DEBUG_ENTER_API((DBG_HTTP,
                     Dword,
                     "InternetErrorDlg",
                     "%#x, %#x, %s (%d), %#x, %#x",
                     hWnd,
                     hRequest,
                     InternetMapError(dwError),
                     dwError,
                     dwFlags,
                     lppvData
                     ));

    DWORD dwStatusCode = HTTP_STATUS_OK;
    DWORD error = ERROR_SUCCESS;
    HINTERNET hMappedRequestHandle = NULL;
    HINTERNET_HANDLE_TYPE handleType;
    HTTP_REQUEST_HANDLE_OBJECT *lpRequest;

    LPVOID lpVoidData;

    //
    // Check Parameters
    //

    if ( !(dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI) &&
         !IsWindow(hWnd) )
    {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    if ( hRequest )
    {
        error = MapHandleToAddress(hRequest, (LPVOID *)&hMappedRequestHandle, FALSE);

        if ( error != ERROR_SUCCESS )
            goto quit;

        //
        //  We only support HttpRequestHandles for this form of UI.
        //


        error = RGetHandleType(hMappedRequestHandle, &handleType);

        if ( error != ERROR_SUCCESS || handleType != TypeHttpRequestHandle )
            goto quit;

        lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hMappedRequestHandle;

        //
        // See if we can detect an error if needed
        //

        if ( dwFlags & FLAGS_ERROR_UI_FILTER_FOR_ERRORS )
        {
            dwStatusCode = lpRequest->GetStatusCode();

            if ( dwStatusCode == HTTP_STATUS_DENIED || dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ )
                dwError = ERROR_INTERNET_INCORRECT_PASSWORD;

            if ( lpRequest->GetBlockingFilter())
                dwError = ERROR_INTERNET_NEED_UI;
        }
    }
    else
    {
        if( ERROR_INTERNET_NEED_UI                  == dwError ||
            ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED  == dwError ||
            ERROR_INTERNET_INSERT_CDROM             == dwError ||
            ERROR_INTERNET_INCORRECT_PASSWORD       == dwError )
        {

            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // If the Caller didn't pass us anything, then we create our own
    // structure. Lets NULL it, and then allocate it later
    //
    //

    if ( !lppvData )
    {
        lppvData = &lpVoidData;
        *lppvData = NULL;
    }

    if  (   dwFlags & FLAGS_ERROR_UI_FLAGS_GENERATE_DATA
       && !(dwFlags & FLAGS_ERROR_UI_SERIALIZE_DIALOGS))
    {
        *lppvData = NULL;
    }

    //
    // Determine what Function to handle this based on what error where given
    //

    BOOL fRet;

    switch ( dwError )
    {
        case ERROR_INTERNET_NEED_UI:
            fRet = HttpFiltOnBlockingOps
                (lpRequest, hRequest, hWnd);
            error = fRet? ERROR_SUCCESS : GetLastError();
            break;

        case ERROR_INTERNET_INCORRECT_PASSWORD:
            error = wErrorUIInvalidPassword(hWnd,
                                    hMappedRequestHandle,
                                    dwError,
                                    dwFlags,
                                    lppvData);

            break;

        case ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION:
            // If we are in silent mode, we will have to
            // decline the cookie without throwing up a
            // dialog
            if((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
            {
                error = ERROR_HTTP_COOKIE_DECLINED;
            }
            else
            {
                COOKIE_DLG_INFO info;

                memset(&info, 0, sizeof(info));
                info.dwOperation = COOKIE_OP_SET;
                info.pic = (INTERNET_COOKIE*)(*lppvData);

                if(info.pic->dwFlags & INTERNET_COOKIE_IS_SESSION)
                {
                    info.dwOperation |= COOKIE_OP_SESSION;
                }

                error = ConfirmCookie(hWnd,
                                      lpRequest,
                                      &info);

            }
            break;

        case ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION_EX:
            // If we are in silent mode, we will have to
            // decline the cookie without throwing up a
            // dialog
            if((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
            {
                error = ERROR_HTTP_COOKIE_DECLINED;
            }
            else
            {
                error = ConfirmCookie(hWnd,
                                      lpRequest,
                                      (COOKIE_DLG_INFO *)(*lppvData));
            }
            break;

        case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED:
            //
            // Call the function which gets the cert context from the
            // Fortezza CSP.

            error = FortezzaLogOn(hWnd);
            break;

        case ERROR_INTERNET_SEC_CERT_REVOKED:
            {
                static WCHAR szMsgBoxText[128]  = L"\0";
                static WCHAR szCaption[64]      = L"\0";
                if (!szCaption[0])
                {
                    LoadStringWrapW(GlobalDllHandle, IDS_CERT_REVOKED, szMsgBoxText, sizeof(szMsgBoxText));
                    LoadStringWrapW(GlobalDllHandle, IDS_SECURITY_CAPTION, szCaption, sizeof(szCaption));
                }
                MessageBoxWrapW(hWnd, szMsgBoxText, szCaption, MB_OK | MB_ICONWARNING);
                error = ERROR_CANCELLED;
            }
            break;

        case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR:
        case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR:

            //
            // Read the registry, and check to make sure
            //  the user hasn't overriden this.
            //

            GlobalDataReadWarningUIFlags();

            if ( ! GlobalWarnOnZoneCrossing )
                break;


            //
            // fall through to launch dlg code.
            //

            goto l_launchdlg;

        case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION:
            //
            // Read the registry, and check to make sure
            //  the user hasn't overriden this.
            //

            GlobalDataReadWarningUIFlags();

            if ( ! GlobalWarnOnPostRedirect )
                break;


            //
            // fall through to launch dlg code.
            //

            goto l_launchdlg;

        case ERROR_INTERNET_POST_IS_NON_SECURE:
        case ERROR_INTERNET_CHG_POST_IS_NON_SECURE:

            //
            // Read the registry, and check to make sure
            //  the user hasn't overriden this.
            //

            GlobalDataReadWarningUIFlags();

            if ( ! GlobalWarnOnPost )
                break;

            //
            // If we're not warning always, ie only warning
            //  if the user actually changed some fields, then
            //  bail out, and don't warn.
            //

            if ( ! GlobalWarnAlways &&
                   dwError == ERROR_INTERNET_POST_IS_NON_SECURE )
                break;

            //
            // fall through to launch dlg code.
            //

            goto l_launchdlg;

        case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
        case ERROR_INTERNET_SEC_CERT_CN_INVALID:
        case ERROR_INTERNET_MIXED_SECURITY:
        case ERROR_INTERNET_INVALID_CA:
        case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED:
        case ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT:
        case ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT:
        case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR:
        case ERROR_INTERNET_INSERT_CDROM:
        case ERROR_INTERNET_SEC_CERT_ERRORS:
        case ERROR_INTERNET_SEC_CERT_REV_FAILED:

l_launchdlg:
            // if silent flag is set, we can just pass
            // ERROR_CANCELLED back without throwing up
            // a dialog
            if ((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
            {
                error = ERROR_CANCELLED;
            }
            else
            {
                ERRORINFODLGTYPE ErrorInfoDlgInfo;
                DLGPROC          pDlgProc;


                MapWininetErrorToDlgId(
                                       dwError,
                                       &ErrorInfoDlgInfo.dwDlgId,
                                       &ErrorInfoDlgInfo.dwDlgFlags,
                                       &pDlgProc
                                       );


                INET_ASSERT(pDlgProc);

                ErrorInfoDlgInfo.hInternetMapped =
                    hMappedRequestHandle;
                if (ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED == dwError)
                {
                    CERT_CONTEXT_ARRAY* pCertContextArray = 
                        ((HTTP_REQUEST_HANDLE_OBJECT *)hMappedRequestHandle)->GetCertContextArray();

                    if (pCertContextArray)
                    {
                        const DWORD c_dwArraySize = pCertContextArray->GetArraySize();

                        if (1 == c_dwArraySize || 0 == c_dwArraySize)
                        {
                            const BOOL fRestricted =
                                lpRequest->GetOpenFlags() & INTERNET_FLAG_RESTRICTED_ZONE;
                            const DWORD dwClientCertPromptPolicy =
                                ::GetClientCertPromptPolicy(lpRequest->GetURL(), fRestricted);
                            if (dwClientCertPromptPolicy == URLPOLICY_ALLOW)
                            {
                                // If 1, select index 0, otherwise -1 if none
                                pCertContextArray->SelectCertContext(c_dwArraySize ? 0 : -1);
                                error = ERROR_SUCCESS;
                                break;
                            }
                        }
                    }
                }
                error = LaunchDlg(
                          hWnd,
                          (LPVOID) &ErrorInfoDlgInfo,
                          ErrorInfoDlgInfo.dwDlgId,
                          pDlgProc
                          );


            }

            break;
        default:
            //
            // if we're filtering for errors, then its not an error
            // since we're intented to process all errors
            //

            if ( ! (dwFlags & FLAGS_ERROR_UI_FILTER_FOR_ERRORS) )
                error = ERROR_NOT_SUPPORTED;
            break;
    }

quit:

    if ( hMappedRequestHandle != NULL )
        DereferenceObject((LPVOID)hMappedRequestHandle);

    DEBUG_LEAVE_API(error);

    return error;
}


INTERNETAPI_(DWORD) InternetConfirmZoneCrossingA(
    IN HWND hWnd,
    IN LPSTR szUrlPrev,
    IN LPSTR szUrlNew,
    BOOL bPost
    )
/*++

Routine Description:

    Creates an Error Dialog informing the User of a zone crossing ( going
    between HTTPS to HTTP or HTTPS to HTTP ) when one is detected.

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    szUrlPrev -   Previous URL string.

    szUrlNew  -   New URL string that the User is about to go to.

    bPost     -   TRUE if a POST is being done, FALSE otherwise.

Return Value:

    DWORD
    Success - ERROR_SUCCESS
               ( user either confirmed OK to continue, or there was no
                 UI needed )

    Failure - ERROR_CANCELLED ( user canceled, we want to stop )
              ERROR_NOT_ENOUGH_MEMORY

Comments:

    none.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "InternetConfirmZoneCrossingA",
                     "%#x, %q, %q, %d",
                     hWnd,
                     szUrlPrev,
                     szUrlNew,
                     bPost));

    DWORD error = ERROR_SUCCESS;
    INTERNET_SCHEME ustPrevScheme;
    INTERNET_SCHEME ustNewScheme;

    INET_ASSERT(szUrlNew);


    //
    // If the Previous one is NULL, then we could be starting out
    //  for the first time
    //

    if ( szUrlPrev == NULL )
        goto quit;


    error = CrackUrl(szUrlPrev,
             lstrlen(szUrlPrev),
             FALSE,
             &ustPrevScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             NULL,          //  Host Name
             NULL,          //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Length
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra
             NULL,          //  Extra Length
             NULL
             );

    if ( error != ERROR_SUCCESS )
    {
        error = ERROR_SUCCESS;
        ustPrevScheme = INTERNET_SCHEME_UNKNOWN;
    }


    error = CrackUrl(szUrlNew,
             lstrlen(szUrlNew),
             FALSE,
             &ustNewScheme,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             NULL,          //  Host Name
             NULL,          //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Length
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra
             NULL,          //  Extra Length
             NULL
             );

    if ( error != ERROR_SUCCESS )
    {
        error = ERROR_SUCCESS;
        ustNewScheme = INTERNET_SCHEME_UNKNOWN;
    }

    //
    // First Eliminate the obvious.
    //

    if ( ustPrevScheme == ustNewScheme )
        goto quit;


    //
    // Next, if it wasn't HTTPS, and it is now
    //  we've caught one zone cross.
    //

    if ( ustPrevScheme != INTERNET_SCHEME_HTTPS &&
         ustNewScheme  == INTERNET_SCHEME_HTTPS   )
    {
        error = ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR;
    }


    //
    // Otherwise, if it was HTTPS, and it is now
    //  no longer HTTPS, we also flag it.
    //

    else if ((ustPrevScheme == INTERNET_SCHEME_HTTPS)
             && ((ustNewScheme != INTERNET_SCHEME_HTTPS)
                 && (ustNewScheme != INTERNET_SCHEME_JAVASCRIPT)
                 && (ustNewScheme != INTERNET_SCHEME_VBSCRIPT))) {
        error = ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR;
    }


    if ( error != ERROR_SUCCESS &&
         hWnd )
    {
        error = InternetErrorDlg(
                 hWnd,
                 NULL,  // hRequest
                 error,
                 0,
                 NULL   // non Data structure to pass.
                 );
    }

quit:
    DEBUG_LEAVE_API(error);
    return error;
}


//
// private functions
//


PRIVATE
DWORD
wErrorUIInvalidPassword(IN HWND hWnd,
                        IN HINTERNET hRequest,
                        IN DWORD dwError,
                        IN DWORD dwFlags,
                        IN OUT LPVOID *lppvData
                        )
/*++

Routine Description:

    Creates an Error Dialog asking the User for his Username and Password.

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    hRequest -    An open HTTP request handle, that is MAPPED,
                  where headers will be added if needed.

    dwError -     The Error code to which the appropriate UI will be shown for.

    dwFlags -     Can be any of all of the following Flags:

                    FLAGS_ERROR_UI_FLAGS_GENERATE_DATA - generates lppvData, and queries
                    internet handle for information.

                    FLAGS_ERROR_UI_FILTER_FOR_ERRORS - scans the returned headers,
                    and determines if there is a "hidden" error, such as an authentication
                    failure.

                    FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS - On successful return of the dialog,
                    this flag will causes the results to be stored in the handle.

                    FLAGS_ERROR_UI_FLAGS_NO_UI - Don't show any User interface. Silently,
                    accepts the Username, and Password that is passed in.

    lppvData -    Contains a Pointer to a Pointer where a stucture is stored containing
                  error specific data, and Dialog results.


Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Serveral Error codes defined in winerror.h or wininet.w

Comments:

    BUGBUG - need to look into multiple authentication scheme handling, and
    how it relates to the UI
    BUGBUG - need to handle case where one thread calls into this function,
    and a second threads also calls in to put up UI on the same User-Pass Info
    as the first.

--*/

{
    DEBUG_ENTER((DBG_INET,
                Dword,
                "wErrorUIInvalidPassword",
                "%#x, %#x, %d (%s), %#x, %#x",
                hWnd,
                hRequest,
                dwError,
                InternetMapError(dwError),
                dwFlags,
                lppvData
                ));

    DWORD error = ERROR_SUCCESS;
    BOOL fMustLock = FALSE;
    InvalidPassType ipt;
    ipt.lpszPassword = NULL;
    
    // Get the request handle and connect handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequest;
    INTERNET_CONNECT_HANDLE_OBJECT *pConnect =
        (INTERNET_CONNECT_HANDLE_OBJECT *) pRequest->GetParent();

    // Validate parameters.
    if (!pConnect || (!(dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI) && !IsWindow(hWnd)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    // Get the authentication context.
    AUTHCTX *pAuthCtx;
    pAuthCtx = pRequest->GetAuthCtx();
    if (!pAuthCtx)
    {
        pAuthCtx = pRequest->GetTunnelAuthCtx();
        if (!pAuthCtx)
        {
            error = ERROR_SUCCESS;
            goto quit;
        }
    }

    PWC *pwc;
    pwc = pAuthCtx->_pPWC;
    // INET_ASSERT (pwc && pwc->nLockCount); w/ Passport, this is no longer true

    //
    //  Initialize InvalidPassType struct
    //

    if (pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_PASSPORT)
    {
        char szUserBuf[MAX_FIELD_LENGTH], szPassBuf[MAX_FIELD_LENGTH];
        ipt.ulMaxField = MAX_FIELD_LENGTH - 1;
        ipt.lpszPassword = szUserBuf;
        ipt.lpszUsername = szPassBuf;
        
        if (pAuthCtx->_pszFQDN)
        {
            ipt.lpszHost = (LPSTR)pAuthCtx->_pszFQDN;
        }
        else
        {
            ipt.lpszHost = pAuthCtx->_pPWC->lpszHost;
        }
        
        ipt.fIsProxy = pAuthCtx->_fIsProxy;
    
    
        //
        // Transfer password cache entry fields to UI structure.
        //
        AuthLock();
        LPSTR lpszPass = pwc->GetPass();

        if (pwc->lpszUser)
            lstrcpyn (ipt.lpszUsername, pwc->lpszUser, MAX_FIELD_LENGTH);
        else
            ipt.lpszUsername[0] = 0;
        if (lpszPass)
            lstrcpyn (ipt.lpszPassword, lpszPass, MAX_FIELD_LENGTH);
        else
            ipt.lpszPassword[0] = 0;
        ipt.lpszRealm = pwc->lpszRealm;

        if (lpszPass)
        {
            SecureZeroMemory(lpszPass, strlen(lpszPass));
            FREE_MEMORY(lpszPass);
        }
        
        AuthUnlock();
    }

    if (dwFlags & FLAGS_ERROR_UI_SERIALIZE_DIALOGS)
    {
        // Queue this thread if we're already in a dialog.
        INET_ASSERT (lppvData);
        INTERNET_AUTH_NOTIFY_DATA *pNotify =
            (INTERNET_AUTH_NOTIFY_DATA *) *lppvData;
        if (IsBadReadPtr (pNotify, sizeof(*pNotify)))
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        if (AuthInDialog (pAuthCtx, pNotify, &fMustLock))
        {
            // The auth context maintains a context handle
            // to correctly process the 'stale' subheader.
            // Setting _nRetries to 0 will cause no context handle to
            // be passed into the package and restart auth for this context
            // from scratch. Therefore, no attempt will be made to parse the
            // stale header which is the correct behavior.
            if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST)
            {
                ((DIGEST_CTX*)pAuthCtx)->_nRetries = 0;
            }
            error = ERROR_INTERNET_DIALOG_PENDING;
            goto quit;
        }
    }

    if ((dwFlags & FLAGS_ERROR_UI_FLAGS_NO_UI))
    {
        // No UI - retrieve any persisted credentials.
        error = InetGetCachedCredentials(pwc->lpszHost, pwc->lpszRealm,
            ipt.lpszUsername, ipt.lpszPassword);
    }
    else // Launch the appropriate dialog.
    {
        if ((pAuthCtx->GetFlags() & PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI))
        {
            // If auth package handles its own UI, let it.
            error = LaunchAuthPlugInDlg
                (pRequest, pAuthCtx, hWnd, dwError, dwFlags, &ipt);
        }
        else
        {
            if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_BASIC
                || pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_DIGEST)
            {
                ipt.eAuthType = REALM_AUTH;
            }
            else if (pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_PASSPORT)
            {
                ipt.eAuthType = PASSPORT_AUTH;
            }
            else
            {
                INET_ASSERT(pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NTLM 
                    || pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_KERBEROS
                    || pAuthCtx->GetSchemeType() == AUTHCTX::SCHEME_NEGOTIATE);
                ipt.eAuthType = NTLM_AUTH;
            }

            CREDINFODLGTYPE CredInfoDlgInfo;
            CredInfoDlgInfo.pipt = &ipt;
            CredInfoDlgInfo.pRequest = pRequest;
            CredInfoDlgInfo.pAuthCtx = pAuthCtx;

            if (ipt.eAuthType == REALM_AUTH)
                error = LaunchDlg (hWnd,(LPVOID) &CredInfoDlgInfo, IDD_REALM_AUTH, NULL);
            else if (ipt.eAuthType == PASSPORT_AUTH)
                error = LaunchDlg (hWnd,(LPVOID) &CredInfoDlgInfo, 0,              NULL);
            else
                error = LaunchDlg (hWnd,(LPVOID) &CredInfoDlgInfo, IDD_NTLM_AUTH, NULL);
        }
    }
        
    // If dialog was OK, return as follows.
    if (error == ERROR_SUCCESS)
    {
        AuthLock();

        if (ipt.eAuthType == NTLM_AUTH)
        {
            // Update user/pass which would overwrite PWC.
            pRequest->SetUserOrPass (ipt.lpszUsername, IS_USER, pAuthCtx->_fIsProxy);
            pRequest->SetUserOrPass (ipt.lpszPassword, IS_PASS, pAuthCtx->_fIsProxy);

            // Update PWC so related requests will be retried.
            pwc->SetUser (ipt.lpszUsername);
            pwc->SetPass (ipt.lpszPassword);
        }
        else if (pAuthCtx->GetSchemeType() != AUTHCTX::SCHEME_PASSPORT)
        {
            // Update user/pass which would overwrite PWC.
            // Update PWC so related requests will be retried.
            
            //if (ipt.lpszUsername[0])
            {
                pRequest->SetUserOrPass (ipt.lpszUsername, IS_USER, pAuthCtx->_fIsProxy);
                pwc->SetUser (ipt.lpszUsername);
            }
            
            //if (ipt.lpszPassword[0])
            {
                pRequest->SetUserOrPass (ipt.lpszPassword, IS_PASS, pAuthCtx->_fIsProxy);
                pwc->SetPass (ipt.lpszPassword);
            }
    
        }
        AuthUnlock();

        // Retry this request.
        error = ERROR_INTERNET_FORCE_RETRY;
    }

    // Notify any waiting threads.

    if (dwFlags & FLAGS_ERROR_UI_SERIALIZE_DIALOGS)
    {
        if (fMustLock)
        {
            // fMustLock will have been set by AuthInDialog if this is
            // a reentrant call to InternetErrorDlg by AuthNotify. If this
            // is the case, acquire the lock and do not call AuthNotify.
            // so that when control is returned to AuthNotify the lock will
            // already be correctly acquired.
            AuthLock();
        }
        else
        {
            AuthNotify (pwc, error);
        }
    }

quit:

    if (ipt.lpszPassword)
    {
        SecureZeroMemory(ipt.lpszPassword, strlen(ipt.lpszPassword));
    }

    //
    // IE30 compat: must return ERROR_SUCCESS to avoid bogus dialog.
    //
    if ( error == ERROR_CANCELLED )
        error = ERROR_SUCCESS;

    DEBUG_LEAVE(error);
    return error;
}

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

DWORD
ConfirmCookie(
            HWND hwnd,
            HTTP_REQUEST_HANDLE_OBJECT *lpRequest,
            COOKIE_DLG_INFO *pcdi
            )
{
    DWORD dw;
    BYTE *buf = NULL;

    //
    //  Get the server name
    //
    WCHAR wszServer[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    if (lpRequest)
    {
        DEBUG_ONLY(lpRequest->GetHostName(&dw));
        INET_ASSERT(dw <= ARRAYSIZE(wszServer));
        CHAR szServerTmp[INTERNET_MAX_HOST_NAME_LENGTH + 1];
        lpRequest->CopyHostName(szServerTmp);
        if(SHAnsiToUnicode(szServerTmp, wszServer, ARRAYSIZE(wszServer))) 
            pcdi->pszServer = wszServer;
    }
    else if(pcdi->pic)
    {
        if(SHAnsiToUnicode(pcdi->pic->pszDomain, wszServer, ARRAYSIZE(wszServer))) 
            pcdi->pszServer = wszServer;
    }

    /* Consult per-site decisions one more time.
       By the time the prompt is being displayed, another instance
       of the cookie-prompt MAY have already written a decision. */ 
    unsigned long dwPerSiteDecision = COOKIE_STATE_UNKNOWN;

    if (InternetGetPerSiteCookieDecisionW(pcdi->pszServer, &dwPerSiteDecision) &&
        dwPerSiteDecision!=COOKIE_STATE_UNKNOWN)
    {
        if (dwPerSiteDecision==COOKIE_STATE_ACCEPT) 
            return ERROR_SUCCESS;
        else
            return ERROR_HTTP_COOKIE_DECLINED;
    }

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);

    // Can typecast as long as "CookieDialogProc" only returns true or false
    dw = (BOOL ) DialogBoxParamWrapW(GetModuleHandle("WININET.DLL"),
                                    MAKEINTRESOURCEW(IDD_CONFIRM_COOKIE),
                                    hwnd,
                                    CookieDialogProc,
                                    (LPARAM) pcdi);

    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    return dw;
}


INTERNETAPI_(DWORD) InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    BOOL bPost
    )
/*++

Routine Description:

    Creates an Error Dialog informing the User of a zone crossing ( going
    between HTTPS to HTTP or HTTPS to HTTP ) when one is detected.

Arguments:

    hWnd -        Window handle to be used as the parent window of a Error Dialog.

    szUrlPrev -   Previous URL string.

    szUrlNew  -   New URL string that the User is about to go to.

    bPost     -   TRUE if a POST is being done, FALSE otherwise.

Return Value:

    DWORD
    Success - ERROR_SUCCESS
               ( user either confirmed OK to continue, or there was no
                 UI needed )

    Failure - ERROR_CANCELLED ( user canceled, we want to stop )
              ERROR_NOT_ENOUGH_MEMORY

Comments:

    none.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "InternetConfirmZoneCrossingW",
                     "%wq, %wq, %d",
                     szUrlPrev,
                     szUrlNew,
                     bPost));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpNew, mpPrev;

    if (!(szUrlPrev && szUrlNew))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(szUrlPrev,0,mpPrev);
    ALLOC_MB(szUrlNew,0,mpNew);
    if (!(mpPrev.psStr && mpNew.psStr))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(szUrlPrev,mpPrev);
    UNICODE_TO_ANSI(szUrlNew,mpNew);
    dwErr = InternetConfirmZoneCrossingA(hWnd, mpPrev.psStr, mpNew.psStr, bPost);

cleanup:
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\unixui.h ===
#ifndef UNIXUI_H__
#define UNIXUI_H__

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

//void UnixAdjustButtonSpacing(HWND hwnd, DWORD dwDlgId);
void UnixRemoveMoreInfoButton(HWND hwnd, DWORD dwDlgId);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* UNIXUI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inetui.rc
//
#define IDS_SECERT_SUBJECT              1
#define ISNO                            2
#define IDS_SECERT_ISSUER               2
#define IDS_SECERT_EFFECTIVE            3
#define IDCANCEL2                       3
#define IDS_SECERT_EXPIRATION           4
#define IDCANCEL3                       4
#define IDS_SECERT_PROTOCOL             5
#define IDS_SECERT_SIGALG               6
#define IDS_SECERT_ENCRALG              7
#define IDS_SECERT_ENCRSTRENGTH         8
#define IDS_LW95_ENTERAUTHINFO          9
#define IDS_SECERT_CERTINFO             10
#define IDS_SECERT_STRENGTH_HIGH        11
#define IDS_SECERT_STRENGTH_MEDIUM      12
#define IDS_SECERT_STRENGTH_LOW         13
#define IDS_CERT_SUBJECT                14
#define IDS_CERT_ISSUER                 15
#define IDS_CERT_EFFECTIVE_DATE         16
#define IDS_CERT_EXPIRATION_DATE        17
#define IDS_CERT_PROTOCOL               18
#define IDS_CERT_SIG_ALG                19
#define IDS_CERT_ENCRYPT_ALG            20
#define IDS_CERT_PRIV_STRENTH           21
#define IDS_CERT_USAGE                  21
#define IDS_COMMENT_EXPIRES             22
#define IDS_COMMENT_NOT_VALID           23
#define IDS_COMMENT_BAD_CN              24
#define IDS_COMMENT_BAD_CA              25
#define IDS_CERT_COMMENT                26
#define IDS_COMMENT_BAD_SIGNATURE       27
#define IDS_FTP_ROOT                    28
#define IDS_FTP_DIR                     29
#define IDS_FTP_UPLEVEL                 30
#define IDS_GOPHER_ROOT                 31
#define IDS_GOPHER_DIR                  32
#define IDS_GOPHER_INDEX                33
#define IDS_GOPHER_CSO                  34
#define IDS_TAG_DIRECTORY               35
#define IDS_TAG_SEARCH                  36
#define IDS_CACHE_DEFAULT_SUBDIR        37
#define IDS_COOKIES_DEFAULT_SUBDIR      38
#define IDS_HISTORY_DEFAULT_SUBDIR      39
#define IDS_COMMENT_REVOKED             40
#define IDS_CERT_FINGERPRINT            41
#define IDD_CERTPICKER                  101
#define IDD_INVALID_CERT                102
#define IDD_INVALID_CA                  102
#define IDD_VIEW_CERT                   103
#define IDD_CONFIRM_COOKIE              104
#define IDI_COOKIE_ICON                 105
#define IDD_FAILED_DOWNLOAD             106
#define IDD_SCRIPT_ERROR                107
#define IDD_AUTODIAL_SELECT             108
#define IDD_CONNECT_TO                  109
#define IDD_GOONLINE                    110
#define IDC_GOONLINE_TOPMESSAGE         111
#define IDS_GOONLINE_REFRESH_CAPTION    112
#define IDS_GOONLINE_REFRESH_TOPMESSAGE 113
#define IDI_DIAL                        114
#define IDD_PROGRESS                    115
#define IDI_SECURITY1                   116
#define IDD_HTTP_POST_REDIRECT          117
#define IDI_SECURITY2                   118
#define IDI_SECURITY3                   119
#define IDC_LINKFROMDLG                 120
#define IDD_CERT_EXPIRED                121
#define IDB_DIAL                        122
#define IDD_AUTHENTICATION              124
#define IDD_NTLM_AUTH                   124
#define IDD_SEC_CERT_ERRORS             125
#define IDB_CHECK                       126
#define IDD_REALM_AUTH                  126
#define IDB_X                           127
#define IDC_CERT_TRUST_TEXT             128
#define IDI_SECURITY4                   128
#define IDC_CERT_DATE_TEXT              129
#define IDC_CERT_NAME_TEXT              130
#define IDC_CERT_TRUST_ICON             131
#define IDC_CERT_DATE_ICON              132
#define IDC_CERT_NAME_ICON              133
#define IDS_CERT_TRUST                  134
#define IDS_CERT_DATE                   135
#define IDS_CERT_NAME                   136
#define IDI_WARN                        137
#define IDI_SUCCESS                     138
#define IDS_SECURITY_CAPTION            139
#define IDS_CERT_REVOKED                140
#define IDD_REVOCATION_PROBLEM          141
#define IDI_OFFLINE                     142
#define IDI_CONNECT                     143
#define IDS_COOKIE_SENDING              147
#define IDS_COOKIE_RECEIVING            148
#define IDS_COOKIE_SENDING_DOMAIN       149
#define IDS_COOKIE_RECEIVING_DOMAIN     150
#define IDI_PRIVACY                     151
#define IDI_PRIVACY_XP                  152
#define IDC_PRIVACY_ICON                153
#define IDC_DONT_WANT_WARNING           1001
#define IDC_CERTPICKLIST                1002
#define IDC_FIELDLIST                   1005
#define IDC_CERT_SUBJECT                1006
#define IDC_CERT_ISSUER                 1007
#define IDC_CERT_EXPIRES                1008
#define IDC_CERT_STATUS                 1009
#define IDC_DELETE_CERT                 1010
#define IDC_EDIT1                       1010
#define IDC_COOKIE_DATA                 1010
#define IDC_USER_NAME                   1010
#define IDC_DOMAIN_FIELD                1010
#define IDC_DETAILSLIST                 1011
#define IDC_COOKIE_DETAILS              1011
#define IDC_EDIT2                       1012
#define IDC_COOKIE_HELP                 1012
#define IDC_DETAILS_LIST                1012
#define IDC_COOKIE_ALLOW_ALL            1013
#define IDC_COOKIE_NAME                 1014
#define IDC_COOKIE_DOMAIN               1016
#define IDC_COOKIE_PATH                 1017
#define IDC_COOKIE_EXPIRES              1018
#define IDC_COOKIE_SECURE               1019
#define IDC_COOKIE_SERVER               1021
#define IDC_COOKIE_ICON                 1022
#define IDC_COOKIE_INFO                 1023
#define IDC_SAVE_PASSWORD               1024
#define IDC_CONNECT_TO                  1025
#define IDC_CONN_TXT                    1025
#define ID_CONNECT                      1026
#define IDC_URL                         1027
#define ID_STAYOFFLINE                  1028
#define IDC_UNATTENDED                  1029
#define IDC_PROGRESS                    1030
#define IDC_STATUS                      1031
#define IDC_ZONEALERTTEXT               1032
#define IDC_BUTTON_EXPORT               1034
#define IDC_BUTTON_IMPORT               1035
#define IDC_AUTOCONNECT                 1036
#define IDC_BMP                         1039
#define IDC_AVI                         1040
#define IDC_SETTINGS                    1041
#define IDC_PROXY_OR_SERVER             1041
#define IDC_SERVER_OR_PROXY             1041
#define IDC_SITE_OR_FIREWALL            1042
#define IDC_DOMAIN_OR_REALM             1043
#define IDC_DOMAIN                      1043
#define IDC_DOMAIN_TAG                  1043
#define IDC_REALM_FIELD                 1044
#define IDC_REALM                       1045
#define IDC_REALM_TAG                   1045
#define IDC_USERNAME_TAG                1046
#define IDC_PASSWORD_TAG                1047
#define IDC_CONN_LIST                   1048
#define IDC_NAME_TXT                    1050
#define IDC_PASSWORD_TXT                1051
#define IDS_TRY_AGAIN                   1053
#define IDC_COOKIE_3RD_PARTY            1055
#define IDC_COOKIE_SEND_RECEIVE         1056
#define IDC_COOKIE_DESCRIPTION          1057
#define IDC_COOKIE_QUESTION             1058
#define IDC_COOKIE_3RDPARTY             1059
#define IDC_COOKIE_SESSION              1060
#define IDC_COOKIE_POLICY               1061
#define IDD_WARN_ON_POST                1175
#define IDD_HTTP_TO_HTTPS_ZONE_CROSSING 1177
#define IDD_HTTPS_TO_HTTP_ZONE_CROSSING 1178
#define IDD_MIXED_SECURITY              1179
#define ID_TELL_ME_ABOUT_SECURITY       1181
#define ID_TELL_ME_ABOUT_SECURITY2      1182
#define IDD_BAD_CN                      1188
#define IDD_BASIC_AUTHENTICATION        1216
#define IDC_REALM_NAME                  1217
#define IDC_USERNAME                    1218
#define IDC_PASSWORD                    1219
#define IDD_SHOW_CERT                   1301
#define IDD_CERTPICKER1                 1302
#define IDD_CERTVIEWER                  1302
#define IDD_HTTPS_POST_REDIRECT         1303
#define IDD_HTTPS_TO_HTTP_SUBMIT_REDIRECT 1303
#define ID_CERT_EDIT                    1318
#define ID_SHOW_CERTIFICATE             1630
#define ID_SHOW_CERTIFICATE2            1631
#define ID_CERT_MORE_INFO               1632
#define IDS_SETTING_COOKIE              1800
#define IDS_SETTING_COOKIE_TITLE        1801
#define IDS_YES                         1802
#define IDS_NO                          1803
#define IDS_COOKIE_EXPIRES_ENDSESSION   1804
#define IDS_PROTOCOL_UNKNOWN            1806
#define IDS_PROTOCOL_SSL2               1807
#define IDS_PROTOCOL_SSL3               1808
#define IDS_PROTOCOL_PCT1               1809
#define IDS_PROTOCOL_TLS1               1810
#define IDS_CIPHER_UNKNOWN              1811
#define IDS_ALG_MD2                     1812
#define IDS_ALG_MD4                     1813
#define IDS_ALG_MD5                     1814
#define IDS_ALG_SHA                     1815
#define IDS_ALG_MAC                     1816
#define IDS_ALG_HMAC                    1817
#define IDS_ALG_RSA_SIGN                1818
#define IDS_ALG_DSS_SIGN                1819
#define IDS_ALG_RSA_KEYX                1820
#define IDS_ALG_DES                     1821
#define IDS_ALG_3DES_112                1822
#define IDS_ALG_3DES                    1823
#define IDS_ALG_RC2                     1824
#define IDS_ALG_RC4                     1825
#define IDS_ALG_RC5                     1826
#define IDS_ALG_SEAL                    1827
#define IDS_ALG_DH_SF                   1828
#define IDS_ALG_DH_EPHEM                1829
#define IDS_ALG_KEA_KEYX                1830
#define IDS_ALG_SKIPJACK                1831
#define IDS_ALG_TEK                     1832
#define IDS_STRING_CIPHMSG              1833
#define IDS_STRING_HASHMSG              1834
#define IDS_STRING_EXCHMSG              1835
#define IDS_HASH_UNKNOWN                1836
#define IDS_EXCH_UNKNOWN                1837
#define IDS_CERT_HASH_ALG               1838
#define IDS_CERT_EXCH_ALG               1839
#define IDS_EXPORTCERT_ERRORTEXT        1900
#define IDS_EXPORTCERT_ERRORTITLE       1901
#define IDS_IMPORTCERT_ERRORTEXT        1902
#define IDS_IMPORTCERT_ERRORTITLE       1903
#define IDS_RNADLL_FILENAME             2000
#define IDS_CONNECTED_TO                2001
#define IDS_INETCFG_FILENAME            2002
#define IDS_REDIAL_WAIT                 2003
#define IDS_REDIAL_ATTEMPT              2004
#define IDS_DIALING                     2005
#define IDS_AUTHENTICATE                2006
#define IDS_CANCEL                      2007
#define IDS_WORK_OFFLINE                2008
#define IDS_CONNECTED                   2009
#define IDS_DISCONNECTED                2010
#define IDS_NOCERT_TITLE                2011
#define IDS_NOCERT                      2012
#define IDS_CONNECT_TO                  2013
#define IDS_PPPRANDOMFAILURE            2014
#define IDS_MEDIAINIERROR               2015
#define IDS_PHONEBUSY                   2016
#define IDS_NOANSWER                    2017
#define IDS_NODIALTONE                  2019
#define IDS_NODEVICE                    2020
#define IDS_TCPINSTALLERROR             2021
#define IDS_AUTHFAILURE                 2022
#define IDS_DOMAIN                      2023
#define IDS_REALM                       2024
#define IDS_SITE                        2025
#define IDS_FIREWALL                    2026
#define IDD_CHOOSE_CONNECTION           4001
#define IDD_NEW                         4002
#define IDD_DISABLEAUTODIAL             4003
#define IDD_TX_CHOOSE_CONNECTION        4004
#define IDD_EDIT                        4005
#define IDD_ZONE_ALERT                  4006
#define IDD_INVALID_CERT_CONTENTS       4007
#define IDD_INSERT_CDROM                4008
#define IDC_CD_NAME                     4009
#define IDC_USE_CDROM                   4011
#define IDC_CONNECT_TO_INTERNET         4012
#define IDS_LAN_CONNECTION              4013
#define IDD_GOOFFLINE                   4014
#define IDS_RASPHONEBOOK                4015
#define IDS_CONFIRM_PERM_COOKIE         4016
#define IDS_PERM_COOKIE                 4016
#define IDS_PROXY_TITLE                 4018
#define IDS_PROXY_MSG                   4019
#define IDS_CACHE_DEFAULT_SUBDIR_UNIX   4020
#define IDS_COOKIE_SAVE                 4021

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        151
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1061
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\unixui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    unixui.cxx

Abstract:

    Contains Unix fixes

    Contents:
        //UnixAdjustButtonSpacing
        UnixRemoveMoreInfoButton

Author:

    Sriram Nambakam (v-sriran) 07-Dec-1998

Revision History:

    07-Dec-1998 v-sriran
        Created

--*/

#include <wininetp.h>
#include "ierrui.hxx"
#include "iehelpid.h"
#include "unixui.h"
#include <mainwin.h>

#if 0

#define MOVE_LEFT   0
#define MOVE_CENTER 1
#define MOVE_RIGHT  2

static void hAdjustButtonSpacing(HWND   hwnd,
                                 short  buttonSpacingStyle,
                                 short  cButtons,
                                 short  dwSpacing,
                                 ...);
                    

/* HACKHACK
 * On Unix, we draw a focus rectangle around the button that is currently
 * selected. And, the focus rectangle will overlap with the next button.
 * We programatically move the button to the *left*, to make it look good.
 */

void UnixAdjustButtonSpacing(HWND  hwnd, DWORD dwDlgId)
{
     switch(dwDlgId)
     {
           case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
                /* In these the More Info button is ID_TELL_ME_ABOUT_SECURITY */
                hAdjustButtonSpacing(hwnd,
                                     MOVE_LEFT,
                                     1,
                                     5,
                                     IDOK);
                
                break;
#ifdef NOT_YET_IMPLEMENTED
           case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:
                break;
           case IDD_MIXED_SECURITY:
                break;
           case IDD_INVALID_CA:
                break;
           case IDD_BAD_CN:
                break;
           case IDD_CONFIRM_COOKIE:
                /* In this the More Info button is IDC_COOKIE_DETAILS */
                break;
#endif /* NOT_YET_IMPLEMENTED */
     }
}

/* 
 * This function assumes all buttons are of equal width for MOVE_CENTER
 */
void hAdjustButtonSpacing(HWND    hwnd,
                          short   buttonSpacingStyle,
                          short   cButtons,
                          short   dwSpacing,
                          ...)
{
     va_list Arguments;
     DWORD dwButtonId;

     va_start(Arguments, dwSpacing);

     if (buttonSpacingStyle != MOVE_CENTER && dwSpacing)
     {
        HWND hCurButton;
        RECT rect;

        for (short i = 0; i < cButtons; i++)
        {
            dwButtonId = (DWORD)va_arg(Arguments,ULONG);
            if ((hCurButton = GetDlgItem(hwnd, dwButtonId)))
            {
               GetWindowRect(hCurButton, &rect); 
               ScreenToClient(hwnd, (LPPOINT)&rect);
               SetWindowPos(hCurButton,
                            NULL,
                            (buttonSpacingStyle == MOVE_LEFT ? rect.left-dwSpacing : rect.left+dwSpacing),
                            rect.top,
                            0,
                            0,
                            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
            }
        }
     }
     else /* MOVE_CENTER; dwSpacing does not matter */
     {
     }

     va_end(Arguments);

     return;
}
#endif /* 0 */

#define MOVE_CENTER 0x0001

static void hRemoveAndAdjust(HWND   hwnd,
                             DWORD  dwFlags,
                             short  cButtons,
                             ...);

/* If we have Button1 Button2 "More Info"
 * The following function makes it
 * <nothing> Button1 Button2
 * And, you have to pass the ids of "More Info" Button2 Button1 in the
 * variable argument list in that order
 */

void UnixRemoveMoreInfoButton(HWND  hwnd, DWORD dwDlgId)
{
     switch(dwDlgId)
     {
           case IDD_HTTP_TO_HTTPS_ZONE_CROSSING:
                /* In these the More Info button is ID_TELL_ME_ABOUT_SECURITY */
                hRemoveAndAdjust(hwnd,
                                 MOVE_CENTER,
                                 2,
                                 ID_TELL_ME_ABOUT_SECURITY,
                                 IDOK);
                
                break;
           case IDD_HTTPS_TO_HTTP_ZONE_CROSSING:
                hRemoveAndAdjust(hwnd,
                                 0,
                                 3,
                                 ID_TELL_ME_ABOUT_SECURITY,
                                 IDCANCEL,
                                 IDOK);
                break;
#ifdef NOT_YET_IMPLEMENTED
           case IDD_MIXED_SECURITY:
                break;
           case IDD_INVALID_CA:
                break;
           case IDD_BAD_CN:
                break;
           case IDD_CONFIRM_COOKIE:
                /* In this the More Info button is IDC_COOKIE_DETAILS */
                break;
#endif /* NOT_YET_IMPLEMENTED */
     }
}

void hRemoveAndAdjust(HWND   hwnd,
                      DWORD  dwFlags,
                      short  cButtons,
                      ...)
{
     va_list Arguments;
     DWORD   dwMoreInfoButtonId, dwButtonId;
     HWND    hMoreInfoButton, hDefButton;
     RECT    rectCur, rectPrev;

     hDefButton = MwRemoveDefPushButtonStyle(hwnd);

     /* Expect the first button to be the More Info Button
      * Hide the More Info Button, and move the other buttons to
      * the appropriate positions
      */

     if (cButtons < 2)
        goto Cleanup;

     /* We should use MOVE_CENTER only if there are two buttons in the move
      * list, and we hide the more info button, and move the other one to
      * the center
      */
     if ((dwFlags & MOVE_CENTER) && cButtons != 2)
        goto Cleanup;

     va_start(Arguments, cButtons);

     dwMoreInfoButtonId = (DWORD)va_arg(Arguments, ULONG);
     hMoreInfoButton = GetDlgItem(hwnd, dwMoreInfoButtonId);
     if (!hMoreInfoButton)
        goto Cleanup;

     GetWindowRect(hMoreInfoButton, &rectPrev); 
     ScreenToClient(hwnd, (LPPOINT)&rectPrev);

     if (dwFlags & MOVE_CENTER)
     {
        HWND hCurButton;
        dwButtonId = (DWORD)va_arg(Arguments,ULONG);
        if ((hCurButton = GetDlgItem(hwnd, dwButtonId)))
        {
           RECT rectDlg;

           GetWindowRect(hCurButton, &rectCur); 
           ScreenToClient(hwnd, (LPPOINT)&rectCur);
      
           GetWindowRect(hwnd, &rectDlg);
           ScreenToClient(hwnd, (LPPOINT)&rectDlg);
           SetWindowPos(hCurButton,
                        NULL,
                        ((rectDlg.right - rectDlg.left)/2)-((rectCur.right-rectCur.left)/2),
                        rectCur.top,
                        0,
                        0,
                        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
        }
     }
     else
     {
        HWND hCurButton;

        for (short i = 1; i < cButtons; i++)
        {
            dwButtonId = (DWORD)va_arg(Arguments,ULONG);
            if ((hCurButton = GetDlgItem(hwnd, dwButtonId)))
            {
               GetWindowRect(hCurButton, &rectCur); 
               ScreenToClient(hwnd, (LPPOINT)&rectCur);
               SetWindowPos(hCurButton,
                            NULL,
                            rectPrev.left,
                            rectPrev.top,
                            0,
                            0,
                            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
               memcpy(&rectPrev, &rectCur, sizeof(RECT));
            }
        }
     }

     /* Hide the More Info Button */
     ShowWindow(hMoreInfoButton, SW_HIDE);

Cleanup:

     if (hDefButton)
        MwRestoreDefPushButtonStyle(hDefButton);

     return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\download.cpp ===
#include <wininetp.h>

#include "download.h"

static const int EntryInfoSize = 8192;

HINTERNET hDownload = NULL;

struct HandlePair {

   HANDLE hConnect;
   HANDLE hRequest;

   HandlePair(HANDLE hc=NULL, HANDLE hr=NULL) :
      hConnect(hc), hRequest(hr) { }
};

bool initialize() {

   if (!hDownload) {
      hDownload = InternetOpen(NULL,
                               INTERNET_OPEN_TYPE_PRECONFIG,
                               NULL, NULL,
                               0);
   }
   return (hDownload!=NULL);
}

/* Determine local file corresponding to request handle
   this is the file holding the data downloaded from the network.
   typically its an entry in the URL cache. for non-cacheable responses
   WININET creates a temporary file. */
int   getLocalFile(HANDLE hRequest, LPTSTR pLocalPath, unsigned long dwPathSize) {

   *pLocalPath = '\0';
   return InternetQueryOption(hRequest, INTERNET_OPTION_DATAFILE_NAME , pLocalPath, &dwPathSize);
}

/* Determine final URL (after redirects) */
int   getFinalURL(HANDLE hRequest, LPTSTR pszFinalURL, unsigned long cCharacters) {

   *pszFinalURL = '\0';
   return InternetQueryOption(hRequest, INTERNET_OPTION_URL, pszFinalURL, &cCharacters);
}

/* returns the Expiry: header from HTTP response */
FILETIME getExpiryHeader(HANDLE hRequest) {

   SYSTEMTIME st;
   FILETIME ft = {0x0, 0x0};
   DWORD dwIndex = 0;
   DWORD cbBuffer = sizeof(st);

   if (HttpQueryInfo(hRequest, HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME, 
                     &st, &cbBuffer, &dwIndex))
      SystemTimeToFileTime(&st, &ft);
   return ft;
}

HandlePair  createRequest(P3PCURL pszLocation) {

   /* P3P downloads are executed with this combination of flags. */
   const DWORD glDownloadFlags =                                
                     INTERNET_FLAG_NEED_FILE      |  // Require local copy of file for parsing
                     INTERNET_FLAG_KEEP_CONNECTION|  // No authentication-- policy looks up MUST be anonymous
                     INTERNET_FLAG_NO_COOKIES     |  // No cookies -- same reason.
                     INTERNET_FLAG_RESYNCHRONIZE  |  // Check for fresh content
                     INTERNET_FLAG_PRAGMA_NOCACHE;   // For intermediary HTTP caches

   char achCanonicalForm[URL_LIMIT];
   unsigned long cflen = sizeof(achCanonicalForm);

   InternetCanonicalizeUrl(pszLocation, achCanonicalForm, &cflen, 0);

   char achFilePath[URL_LIMIT] = "";
   char achServerName[INTERNET_MAX_HOST_NAME_LENGTH] = "";

   URL_COMPONENTS uc = { sizeof(uc) };

   uc.lpszHostName = achServerName;
   uc.dwHostNameLength = sizeof(achServerName);
   uc.lpszUrlPath = achFilePath;
   uc.dwUrlPathLength = sizeof(achFilePath);

   if (!InternetCrackUrl(achCanonicalForm, 0, 0, &uc))
      return NULL; 
      
   HINTERNET hConnect, hRequest;

   hConnect = InternetConnect(hDownload,
                              achServerName,
                              uc.nPort,
                              NULL, NULL,
                              INTERNET_SERVICE_HTTP,
                              0, 0);

   DWORD dwFlags = glDownloadFlags;

   if (uc.nScheme==INTERNET_SCHEME_HTTPS)
      dwFlags |= INTERNET_FLAG_SECURE;

   hRequest =  HttpOpenRequest(hConnect, NULL, 
                               achFilePath,
                               NULL, NULL, NULL,
                               dwFlags,
                               0);

   return HandlePair(hConnect, hRequest);
}

unsigned long beginDownload(HANDLE hRequest) {

   BOOL fSuccess = HttpSendRequest(hRequest, NULL, 0, NULL, 0); 
   
   if (!fSuccess)
      return HTTP_STATUS_NOT_FOUND;

   /* determine HTTP status code */
   unsigned long dwStatusCode = HTTP_STATUS_NOT_FOUND;
   unsigned long dwIndex = 0;
   unsigned long dwSpace = sizeof(dwStatusCode);

   HttpQueryInfo(hRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                 (void*) &dwStatusCode, &dwSpace, &dwIndex);

   return dwStatusCode;
}

int  readResponse(HANDLE hRequest) {

   int  total = 0;
   unsigned long bytesRead;
   char buffer[256];

   /* This loop downloads the file to HTTP cache.
      Because of WININET specs the loop needs to continue until "bytesRead" is zero,
      at which point the file will be committed to the cache */
   do {
      bytesRead = 0;
      InternetReadFile(hRequest, buffer, sizeof(buffer), &bytesRead);
      total += bytesRead;
   }
   while (bytesRead);

   return total;
}

void  endDownload(HANDLE hConnect) {

   if (hConnect)
      InternetCloseHandle(hConnect);
}

// Download given URL into local file
int   downloadToCache(P3PCURL pszLocation, ResourceInfo *pInfo,
                      HANDLE *phConnect,
                      P3PRequest *pRequest) {

   static bool fReady = initialize();

   HandlePair hndpair = createRequest(pszLocation);
   
   HINTERNET hConnect = hndpair.hConnect;
   HINTERNET hRequest = hndpair.hRequest;

   /* Give the connect handle back to client.
      WININET closes all derived handles when a parent handle is closed.
      Client calls endDownload() when done processing the file, which causes
      connect handle to be closed, which in turn closes actual request handle */
   if (phConnect)
      *phConnect = hConnect;

   if (!hConnect || !hRequest)
      return -1;

   if (pRequest)
      pRequest->enterIOBoundState();

   int total = -1;
   
   unsigned long dwStatusCode = beginDownload(hRequest);

   /* status code different from 200-OK is failure */
   if (dwStatusCode==HTTP_STATUS_OK) {

      total = readResponse(hRequest);

      if (total>0 && pInfo) {

         getFinalURL(hRequest, pInfo->pszFinalURL, pInfo->cbURL);
         getLocalFile(hRequest, pInfo->pszLocalPath, pInfo->cbPath);
         pInfo->ftExpiryDate = getExpiryHeader(hRequest);
      }
   }

   if (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ) {
      DWORD dwRetval;
      DWORD dwError;
      DWORD dwStatusLength = sizeof(DWORD);
      DWORD dwIndex = 0;
      BOOL fDone;
      fDone = FALSE;
      while (!fDone)
      {
         dwRetval = InternetErrorDlg(GetDesktopWindow(),
                                     hRequest,
                                     ERROR_INTERNET_INCORRECT_PASSWORD,
                                     0L,
                                     NULL);
         if (dwRetval == ERROR_INTERNET_FORCE_RETRY) // User pressed ok on credentials dialog
         {   // Resend request, new credentials are cached and will be replayed by HSR()
             if (!HttpSendRequest(hRequest,NULL, 0L, NULL, NULL))
             {
             	dwError = GetLastError();
             	total = -1;
               	goto cleanup;
             }

             dwStatusCode = 0;

             if (!HttpQueryInfo(hRequest,
                        		  HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                				  &dwStatusCode,
                				  &dwStatusLength,
                				  &dwIndex))
             {
              	dwError = GetLastError();
             	total = -1;
               	goto cleanup;
             }

             if ((dwStatusCode != HTTP_STATUS_DENIED) && (dwStatusCode != HTTP_STATUS_PROXY_AUTH_REQ))
             {
                fDone = TRUE;
             }
          }
          else    // User pressed cancel from dialog (note ERROR_SUCCESS == ERROR_CANCELLED from IED())
          {
             fDone = TRUE;
          }
      }
   }

cleanup:   
   if (pRequest)
      pRequest->leaveIOBoundState();

   return total;
}

/*
Set relative/absolute expiration on given URL.
The expiration is derived from the string representation in 2nd parameter
and returned via the out parameter.
*/
int   setExpiration(P3PCURL pszResource, const char *pszExpDate, BOOL fRelative, FILETIME *pftExpires) {

   BOOL success;
   SYSTEMTIME st;

   if (fRelative) {

      union {
         FILETIME ftAbsExpiry;
         unsigned __int64 qwAbsExpiry;
      };

      int maxAgeSeconds = atoi(pszExpDate);

      INTERNET_CACHE_ENTRY_INFO *pInfo = (INTERNET_CACHE_ENTRY_INFO*) new char[EntryInfoSize];
      unsigned long cBytes = EntryInfoSize;

      memset(pInfo, 0, cBytes);
      pInfo->dwStructSize = cBytes;

      /* if we cant get last-sync time from the cache we will
         "fabricate" it by taking current client clock */
      if (GetUrlCacheEntryInfo(pszResource, pInfo, &cBytes))
         ftAbsExpiry = pInfo->LastSyncTime;
      else
         GetSystemTimeAsFileTime(&ftAbsExpiry);

      qwAbsExpiry += (unsigned __int64) maxAgeSeconds * 10000000;
      
      success = setExpiration(pszResource, ftAbsExpiry);
      *pftExpires = ftAbsExpiry;
      delete [] (char*) pInfo;
   }
   else if (InternetTimeToSystemTime(pszExpDate, &st, 0)) {

      SystemTimeToFileTime(&st, pftExpires);
      success = setExpiration(pszResource, *pftExpires);
   }
   return success;
}

/* Set absolute expiry on given URL */
int setExpiration(P3PCURL pszResource, FILETIME ftExpire) {

   INTERNET_CACHE_ENTRY_INFO ceInfo;

   memset(&ceInfo, 0, sizeof(ceInfo));
   ceInfo.dwStructSize = sizeof(ceInfo);
   ceInfo.ExpireTime = ftExpire;
   
   BOOL fRet = SetUrlCacheEntryInfo(pszResource, &ceInfo, CACHE_ENTRY_EXPTIME_FC);
   return fRet;
}

/* Comparison operator for FILETIME structures */
bool operator > (const FILETIME &ftA, const FILETIME &ftB) {

   return (ftA.dwHighDateTime>ftB.dwHighDateTime) ||
            (ftA.dwHighDateTime==ftB.dwHighDateTime && 
             ftA.dwLowDateTime>ftB.dwHighDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\p3pglobal.h ===
#ifndef _P3PGLOBAL_H_
#define _P3PGLOBAL_H_

/***
This file is OBSELETE.
Public P3P declarations have been moved to wininet.w
***/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\inetui\schnlui.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    schnlui.cxx

Abstract:

    Contains immplimentation of generic Windows Dialog
    Manipulation Code.  This code supports SCHANNEL
    (Secure Channel SSL/PCT) specific UI for Certifcates.

    Contents:
        CertPickDialogProc

Author:

    Arthur L Bierer (arthurbi) 27-Jun-1996

Revision History:

    27-Jun-1996 arthurbi
        Created

--*/

#include <wininetp.h>
#include <ntsecapi.h>
#include "resource.h"
#include "ierrui.hxx"
#include "inethelp.h"
#include <softpub.h>
#include <htmlhelp.h>

#define USE_NT5_CRYPTOUI
#ifdef USE_NT5_CRYPTOUI
#include <cryptui.h>
HINSTANCE g_hCryptoUI = NULL;   // handle for cryptui.dll
#endif

//
// private prototypes, and defines.
//

#define TYPICAL_MD5_HASH_SIZE 16

#define NUM_DN_UNITS    6
#define MAX_ITEM_LEN    1000

#define DN_COMMON_NAME  0
#define DN_COUNTRY      1
#define DN_ORG          2
#define DN_ORGUNIT      3
#define DN_LOCALE       4
#define DN_STATE        5

#define MAX_CERT_FIELDS 20

typedef struct _ATTR_MAP
{
    DWORD dwAttr;
    DWORD dwStringID;
} ATTR_MAP;

// Now for some common attribute maps


ATTR_MAP ProtocolAttrMap[] =
{
    {SP_PROT_SSL2_CLIENT, IDS_PROTOCOL_SSL2},
    {SP_PROT_SSL3_CLIENT, IDS_PROTOCOL_SSL3},
    {SP_PROT_PCT1_CLIENT, IDS_PROTOCOL_PCT1},
    {SP_PROT_TLS1_CLIENT, IDS_PROTOCOL_TLS1}
};

ATTR_MAP AlgAttrMap[] =
{
    {CALG_MD2, IDS_ALG_MD2},
    {CALG_MD4, IDS_ALG_MD4},
    {CALG_MD5, IDS_ALG_MD5},
    {CALG_SHA, IDS_ALG_SHA},
    {CALG_SHA1, IDS_ALG_SHA},
    {CALG_MAC, IDS_ALG_MAC},
    {CALG_HMAC, IDS_ALG_HMAC},
    {CALG_RSA_SIGN, IDS_ALG_RSA_SIGN},
    {CALG_DSS_SIGN, IDS_ALG_DSS_SIGN},
    {CALG_RSA_KEYX, IDS_ALG_RSA_KEYX},
    {CALG_DES, IDS_ALG_DES},
    {CALG_3DES_112, IDS_ALG_3DES_112},
    {CALG_3DES, IDS_ALG_3DES},
    {CALG_RC2, IDS_ALG_RC2},
    {CALG_RC4, IDS_ALG_RC4},
    {CALG_RC5, IDS_ALG_RC5},
    {CALG_SEAL, IDS_ALG_SEAL},
    {CALG_DH_SF, IDS_ALG_DH_SF},
    {CALG_DH_EPHEM, IDS_ALG_DH_EPHEM},
    {CALG_KEA_KEYX, IDS_ALG_KEA_KEYX},
    {CALG_SKIPJACK, IDS_ALG_SKIPJACK},
    {CALG_TEK, IDS_ALG_TEK}
};





typedef struct {
    LPWSTR lpszListBoxText;
    LPWSTR lpszEditBoxText;
    DWORD dwSpcCtlId;       // special id for item to be placed in ctl.
} ShowCertMapping;


#define szHelpFile "iexplore.hlp"




//
// private function declariations
//



PRIVATE
BOOL
PlaceCertContextsInListBox(
    IN HWND hWndListBox,
    IN HWND hWndViewCertButton,
    IN HWND hWndExportButton,
    IN CERT_CONTEXT_ARRAY* pCertContexts
    );

PRIVATE
BOOL
PlaceCertificateDataIntoListBox(
    IN HWND hWndDlg,
    IN HWND hWndListBox,
    IN ShowCertMapping *pMapCertFields
    );

PRIVATE
DWORD
OnSelectionOfACertField(
    IN HWND hWndListBox,
    IN HWND hWndEditBox,
    IN ShowCertMapping *pMapCertFields
    );

PRIVATE
BOOL
CALLBACK
ViewCertDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    );

LPWSTR  GetCertStatus(LPINTERNET_SECURITY_INFO pciCert);
//
// public functions
//

#ifdef USE_NT5_CRYPTOUI
//+-------------------------------------------------------------------------
// Returns TRUE if cryptui.dll was found
//--------------------------------------------------------------------------
BOOL UseCryptoUI()
{
    static long fTriedOnce = FALSE;

    // Only try to load the dll once
    if (!fTriedOnce)
    {
        //
        // Note: if this gets called by multiple threads the worst that will
        // happen is that load library will be called twice.  Apparently,
        // there is is no danger of the global getting mangled because
        // writes are atomic.
        //
        g_hCryptoUI = LoadLibrary("cryptui.dll");
        fTriedOnce = TRUE;
    }

    return (g_hCryptoUI != NULL);
}

//+-------------------------------------------------------------------------
// Delay load version of the function in cryptui.dll
//--------------------------------------------------------------------------
BOOL _CryptUIDlgViewCertificate(
    IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCT   pCertViewInfo,
    OUT BOOL                               *pfPropertiesChanged  // OPTIONAL
    )
{
    // Caller must call UseCryptoUI() first to load the dll!
    INET_ASSERT(g_hCryptoUI);
    typedef BOOL (CALLBACK* CRYPTUIDLGVIEWCERTIFICATE)(PCCRYPTUI_VIEWCERTIFICATE_STRUCT, BOOL*);

    static CRYPTUIDLGVIEWCERTIFICATE fnCryptUIDlgViewCertificate = NULL;

    if (fnCryptUIDlgViewCertificate == NULL)
    {
        //
        // Note: if this gets called by multiple threads the worst that will
        // happen is that GetProcAddress will be called twice.  Apparently,
        // there is is no danger of the global getting mangled because
        // writes are atomic.
        //
        fnCryptUIDlgViewCertificate = (CRYPTUIDLGVIEWCERTIFICATE)GetProcAddress(g_hCryptoUI, "CryptUIDlgViewCertificateA");
        if (fnCryptUIDlgViewCertificate == NULL)
        {
            return FALSE;
        }
    }

    // Call the real function
    return fnCryptUIDlgViewCertificate(pCertViewInfo, pfPropertiesChanged);
}
#endif USE_NT5_CRYPTOUI

INTERNETAPI_(BOOL) InternetAlgIdToStringA(
    IN ALG_ID       ai,
    IN LPSTR        lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a algid to a user-displayable string.

Arguments:

    ai - Algorithm identifiers ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)

    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetAlgIdToStringA",
                     "%#x, %q, %#x, %#x",
                     ai,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD error = ERROR_SUCCESS;

    if ((dwReserved!=0) || (lpdwstrLength == NULL))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (lpstr == NULL)
        *lpdwstrLength = 0;

    int i;
    for (i=0; i < ARRAY_ELEMENTS(AlgAttrMap) ; i++ )
    {
        if (ai == AlgAttrMap[i].dwAttr)
            break;
    }

    if ( i == ARRAY_ELEMENTS(AlgAttrMap) )
    {
        INET_ASSERT(FALSE);     // Could be because our table is not up to date.
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    CHAR szTempBuffer[100];

    int nRet;
    nRet = LoadStringA(GlobalDllHandle,
                           AlgAttrMap[i].dwStringID,
                           szTempBuffer,
                           ARRAY_ELEMENTS(szTempBuffer)
                           );

    // If the return value is within one less than the arraysize, it implies the
    // string could have been terminated by LoadString. This should not happen
    // since we have allocated a large enough buffer. If it does we need to bump the
    // size of the temporary array above.
    INET_ASSERT(nRet < ARRAY_ELEMENTS(szTempBuffer) - 1);

    if (*lpdwstrLength > (DWORD)nRet)
    {
        memcpy(lpstr, szTempBuffer, (nRet + 1));
        *lpdwstrLength = nRet;
        error = ERROR_SUCCESS;
    }
    else
    {
        *lpdwstrLength = nRet + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:
    if (ERROR_SUCCESS != error)
    {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(error==ERROR_SUCCESS);
    return (error == ERROR_SUCCESS);
}

INTERNETAPI_(BOOL) InternetSecurityProtocolToStringA(
    IN DWORD        dwProtocol,
    IN LPSTR        lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a security protocol to a user-displayable string.

Arguments:

    dwProtocol - Security protocol identifier ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)

    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSecurityProtocolToStringA",
                     "%d, %q, %#x, %#x",
                     dwProtocol,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD error = ERROR_SUCCESS;

    if ((dwReserved!=0) || (lpdwstrLength == NULL))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (lpstr == NULL)
        *lpdwstrLength = 0;

    int i;
    for (i=0; i < ARRAY_ELEMENTS(ProtocolAttrMap) ; i++ )
    {
        if (dwProtocol == ProtocolAttrMap[i].dwAttr)
            break;
    }

    if ( i == ARRAY_ELEMENTS(ProtocolAttrMap) )
    {
        INET_ASSERT(FALSE);     // Could be because our table is not up to date.
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    CHAR szTempBuffer[100];

    int nRet;
    nRet = LoadStringA(GlobalDllHandle,
                           ProtocolAttrMap[i].dwStringID,
                           szTempBuffer,
                           ARRAY_ELEMENTS(szTempBuffer)
                           );

    // If the return value is within one less than the arraysize, it implies the
    // string could have been terminated by LoadString. This should not happen
    // since we have allocated a large enough buffer. If it does we need to bump the
    // size of the temporary array above.
    INET_ASSERT(nRet < ARRAY_ELEMENTS(szTempBuffer) - 1);

    if (*lpdwstrLength > (DWORD)nRet)
    {
        memcpy(lpstr, szTempBuffer, (nRet + 1));
        *lpdwstrLength = nRet;
        error = ERROR_SUCCESS;
    }
    else
    {
        *lpdwstrLength = nRet + 1;
        error = ERROR_INSUFFICIENT_BUFFER;
    }

quit:
    if (ERROR_SUCCESS != error)
    {
        SetLastError(error);
        DEBUG_ERROR(API, error);
    }
    DEBUG_LEAVE_API(error==ERROR_SUCCESS);
    return (error == ERROR_SUCCESS);
}


LPWSTR DupAnsiToUnicode(
    char *lpszAnsi,
    INT iLen
    )
{
    
    DWORD cbSize = (iLen > 0 ) ? iLen : (lstrlen(lpszAnsi) + 1);
    WCHAR *pwszUnicode = NULL;
    pwszUnicode = new WCHAR[cbSize];
    if(pwszUnicode)
    {
        SHAnsiToUnicode(lpszAnsi, pwszUnicode, cbSize);
    }
    return pwszUnicode;
}



DWORD
ShowSecurityInfo(
    IN HWND                            hWndParent,
    IN LPINTERNET_SECURITY_INFO        pSecurityInfo
    )

/*++

Routine Description:

    Displays a dialog box that shows the information found
    inside of a certificate.

Arguments:

    hWndParent - Parent Window Handle

    pCertInfoEx - Certificate Information structure, containing the
                fields of info to show.

Return Value:

    DWORD
        Win32 or WININET error code.
--*/

{
#ifdef USE_NT5_CRYPTOUI
    //
    // For now, we use the new UI only if we can load the DLL.  Otherwise we
    // resort to the old UI.  Eventually, we may nuke the old UI.
    //
    if (UseCryptoUI())
    {
        CRYPTUI_VIEWCERTIFICATE_STRUCT cert;

        if(pWTHelperProvDataFromStateData && g_fDoSpecialMagicForSGCCerts)
        {
            WINTRUST_DATA           sWTD;
            WINTRUST_CERT_INFO      sWTCI;
            HTTPSPolicyCallbackData polHttps;
            LPCSTR pszPurpose = szOID_PKIX_KP_SERVER_AUTH;
            DWORD status;

            memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
            sWTD.cbStruct               = sizeof(WINTRUST_DATA);
            sWTD.dwUIChoice             = WTD_UI_NONE;
            sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
            sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
            sWTD.pCert                  = &sWTCI;
            sWTD.pwszURLReference       = NULL;
            sWTD.dwStateAction          = WTD_STATEACTION_VERIFY;
        
            memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
            sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
            sWTCI.psCertContext         = (CERT_CONTEXT *)pSecurityInfo->pCertificate;
            sWTCI.chStores              = 1;
            sWTCI.pahStores             = (HCERTSTORE *)&pSecurityInfo->pCertificate->hCertStore;

            memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
            polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
            polHttps.dwAuthType         = AUTHTYPE_SERVER;
            polHttps.fdwChecks          = INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
                                          SECURITY_FLAG_IGNORE_WRONG_USAGE;
            polHttps.pwszServerName     = NULL;

            status = WinVerifySecureChannel(NULL, &sWTD);

            ZeroMemory(&cert, sizeof(cert));
            cert.dwSize         = sizeof(cert);
            cert.hwndParent     = hWndParent;
            cert.pCertContext   = pSecurityInfo->pCertificate;
            cert.hWVTStateData  = pWTHelperProvDataFromStateData(sWTD.hWVTStateData);
            cert.fpCryptProviderDataTrustedUsage = (status == ERROR_SUCCESS) ? TRUE : FALSE;
            cert.rgszPurposes = &pszPurpose;
            cert.cPurposes = 1;

            status = _CryptUIDlgViewCertificate(&cert, NULL);

            sWTD.dwStateAction = WTD_STATEACTION_CLOSE;
            WinVerifySecureChannel(NULL, &sWTD);

            return status;    
        }
        else
        {
            ZeroMemory(&cert, sizeof(cert));
            cert.dwSize         = sizeof(cert);
            cert.hwndParent     = hWndParent;
            cert.pCertContext   = pSecurityInfo->pCertificate;
            cert.cStores        = 1;
            cert.rghStores      = (HCERTSTORE *) & (cert.pCertContext->hCertStore);

            return _CryptUIDlgViewCertificate(&cert, NULL);
        }

    }
#endif
#ifdef _WIN64
    return ERROR_INTERNET_INTERNAL_ERROR;
#else
    LPTSTR szResult = NULL;
    PLOCAL_STRINGS plszStrings;
    ShowCertMapping MapCertFields[MAX_CERT_FIELDS];

    WCHAR szTempBuffer[100];

    INT i = 0, j=0;
    DWORD error;
    LPTSTR lpszSubject = NULL;
    LPWSTR lpwszTempSubject = NULL;
    LPTSTR lpszIssuer = NULL;
    LPWSTR lpwszTempIssuer = NULL;

    WCHAR lpszProtocol[100];
    LPWSTR lpwszCipher = NULL;
    LPWSTR lpwszHash = NULL;
    LPWSTR lpwszExch = NULL;
    LPTSTR szFrom = NULL;
    LPWSTR pwszTempFrom = NULL;
    LPTSTR szUntil = NULL;
    LPWSTR pwszTempUntil = NULL;
    LPWSTR pwszStatus = NULL;
    LPSTR lpszHashStr = NULL;
    LPWSTR pwszTempHashStr = NULL;

    DWORD  adwFormatParams[3];


    PCERT_INFO pCertInfo =  NULL;
    DWORD  dwProtocolID =   IDS_PROTOCOL_UNKNOWN;
    DWORD  dwHashID =       IDS_HASH_UNKNOWN;
    DWORD  dwCipherID =     IDS_CIPHER_UNKNOWN;
    DWORD  dwExchID =       IDS_EXCH_UNKNOWN;
    DWORD cbSize;

    error = ERROR_SUCCESS;

    if((pSecurityInfo == NULL) || (pSecurityInfo->pCertificate == NULL))
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }


    pCertInfo = pSecurityInfo->pCertificate->pCertInfo;

    if(pCertInfo == NULL)
    {
       return ERROR_INTERNET_INTERNAL_ERROR;
    }

    //
    // Get the Certificate Information.
    //

    plszStrings = FetchLocalStrings();

    if ( plszStrings == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    szFrom = FTtoString(&pCertInfo->NotBefore);
    szUntil = FTtoString(&pCertInfo->NotAfter);



    //
    // Put a comment string about the certificate if there is one availble.
    //

    //
    // BUGBUG [arthurbi] This is broken.  We never determnine the host name,
    //  so therefore we never show a Comment for bad CA certificates.
    //

    pwszStatus = GetCertStatus(pSecurityInfo);

    if(pwszStatus)
    {
        MapCertFields[i].lpszListBoxText = plszStrings->szCertComment;
        MapCertFields[i].lpszEditBoxText = pwszStatus;
        MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_COMMENT;
        i++;

    }

    if ( pCertInfo->Subject.cbData )
    {
        cbSize = CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        lpszSubject = new TCHAR[cbSize];

        if ( lpszSubject )
        {
            CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     lpszSubject,
                                     cbSize);
            MapCertFields[i].lpszListBoxText = plszStrings->szCertSubject;
            lpwszTempSubject = DupAnsiToUnicode(lpszSubject, cbSize);
            MapCertFields[i].lpszEditBoxText = lpwszTempSubject;
            MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_SUBJECT;
            i++;
        }
    }


    if ( pCertInfo->Issuer.cbData )
    {
        cbSize = CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        lpszIssuer = new TCHAR[cbSize];

        if ( lpszIssuer )
        {
            CertNameToStr(pSecurityInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     lpszIssuer,
                                     cbSize);
            MapCertFields[i].lpszListBoxText = plszStrings->szCertIssuer;
            lpwszTempIssuer = DupAnsiToUnicode(lpszIssuer, cbSize);
            MapCertFields[i].lpszEditBoxText = lpwszTempIssuer;
            MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_ISSUER;
            i++;
        }
    }


    if ( szFrom )
    {
        MapCertFields[i].lpszListBoxText = plszStrings->szCertEffectiveDate;
        pwszTempFrom = DupAnsiToUnicode(szFrom, 0);
        MapCertFields[i].lpszEditBoxText = pwszTempFrom;
        MapCertFields[i].dwSpcCtlId      = 0;
        i++;
    }


    if ( szUntil )
    {
        MapCertFields[i].lpszListBoxText = plszStrings->szCertExpirationDate;
        pwszTempUntil = DupAnsiToUnicode(szUntil, 0);
        MapCertFields[i].lpszEditBoxText = pwszTempUntil;

        MapCertFields[i].dwSpcCtlId      = 0;//IDC_CERT_EXPIRES;
        i++;
    }

    //
    // Get the fingerprint... aka MD5 Hash
    //

    {
        CHAR lpMD5Hash[TYPICAL_MD5_HASH_SIZE];
        DWORD dwMD5HashSize = TYPICAL_MD5_HASH_SIZE;
        BOOL fSuccess;

        fSuccess = CertGetCertificateContextProperty(
                    pSecurityInfo->pCertificate,
                    CERT_MD5_HASH_PROP_ID,
                    (LPVOID) lpMD5Hash,
                    &dwMD5HashSize
                    );

        if ( fSuccess )
        {
            CertHashToStr( lpMD5Hash,
                           dwMD5HashSize,
                           &lpszHashStr
                           );

            if ( lpszHashStr )
            {
                MapCertFields[i].lpszListBoxText = plszStrings->szFingerprint;
                pwszTempHashStr = DupAnsiToUnicode(lpszHashStr, 0);
                MapCertFields[i].lpszEditBoxText = pwszTempHashStr;

                MapCertFields[i].dwSpcCtlId      = 0;
                i++;
            }
        }
    }

    // Now fill in the connection attributes
    if(pSecurityInfo->dwProtocol)
    {

        for(j=0; j < sizeof(ProtocolAttrMap)/sizeof(ProtocolAttrMap[0]); j++)
        {
            if(ProtocolAttrMap[j].dwAttr == pSecurityInfo->dwProtocol)
            {
                dwProtocolID = ProtocolAttrMap[j].dwStringID;
                break;
            }
        }
        if(LoadStringWrapW(GlobalDllHandle,
                   dwProtocolID,
                   lpszProtocol,
                   sizeof(lpszProtocol)/sizeof(lpszProtocol[0])))
        {

            MapCertFields[i].lpszEditBoxText = lpszProtocol;
            MapCertFields[i].lpszListBoxText = plszStrings->szCertProtocol;
            MapCertFields[i].dwSpcCtlId      = 0;
            i++;
        }
    }

    if(pSecurityInfo->aiCipher)
    {
        for(j=0; j < sizeof(AlgAttrMap)/sizeof(AlgAttrMap[0]); j++)
        {
            if(AlgAttrMap[j].dwAttr == pSecurityInfo->aiCipher)
            {
                dwCipherID = AlgAttrMap[j].dwStringID;
                break;
            }
        }

        LoadStringWrapW(GlobalDllHandle,
                   dwCipherID,
                   szTempBuffer,
                   sizeof(szTempBuffer)/sizeof(szTempBuffer[0]));
        adwFormatParams[0] = (DWORD)szTempBuffer;
        adwFormatParams[1] = (DWORD)pSecurityInfo->dwCipherStrength;

        if (96 <= pSecurityInfo->dwCipherStrength)  // Recommended Key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthHigh;
        else if (64 <= pSecurityInfo->dwCipherStrength) // Passable key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthMedium;
        else    // Ick!  Low key strength.
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthLow;



        if(FormatMessageWrapW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          plszStrings->szCiphMsg,
                          0,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (LPWSTR)&lpwszCipher,
                          0,
                          (va_list *)adwFormatParams))
        {
            MapCertFields[i].lpszEditBoxText = lpwszCipher;
            MapCertFields[i].lpszListBoxText = plszStrings->szHttpsEncryptAlg;
            MapCertFields[i].dwSpcCtlId      = 0;

            i++;
        }
    }

    if(pSecurityInfo->aiHash)
    {
        for(j=0; j < sizeof(AlgAttrMap)/sizeof(AlgAttrMap[0]); j++)
        {
            if(AlgAttrMap[j].dwAttr == pSecurityInfo->aiHash)
            {
                dwHashID = AlgAttrMap[j].dwStringID;
                break;
            }
        }
        LoadStringWrapW(GlobalDllHandle,
                   dwHashID,
                   szTempBuffer,
                   sizeof(szTempBuffer)/sizeof(szTempBuffer[0]));
        adwFormatParams[0] = (DWORD)szTempBuffer;
        adwFormatParams[1] = (DWORD)pSecurityInfo->dwHashStrength;

        if (96 <= pSecurityInfo->dwHashStrength)  // Recommended Key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthHigh;
        else if (64 <= pSecurityInfo->dwHashStrength) // Passable key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthMedium;
        else    // Ick!  Low key strength.
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthLow;

        if(FormatMessageWrapW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      plszStrings->szHashMsg,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPWSTR)&lpwszHash,
                      0,
                      (va_list *)adwFormatParams))
        {
            MapCertFields[i].lpszEditBoxText = lpwszHash;
            MapCertFields[i].lpszListBoxText = plszStrings->szHttpsHashAlg;
            MapCertFields[i].dwSpcCtlId      = 0;
            i++;
        }
    }
    if(pSecurityInfo->aiExch)
    {
        for(j=0; j < sizeof(AlgAttrMap)/sizeof(AlgAttrMap[0]); j++)
        {
            if(AlgAttrMap[j].dwAttr == pSecurityInfo->aiExch)
            {
                dwExchID = AlgAttrMap[j].dwStringID;
                break;
            }
        }
        LoadStringWrapW(GlobalDllHandle,
                   dwExchID,
                   szTempBuffer,
                   sizeof(szTempBuffer)/sizeof(szTempBuffer[0]));
        adwFormatParams[0] = (DWORD)szTempBuffer;
        adwFormatParams[1] = (DWORD)pSecurityInfo->dwExchStrength;

        if (1024 <= pSecurityInfo->dwExchStrength)  // Recommended Key strength
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthHigh;
         else    // Ick!  Low key strength.
            adwFormatParams[2] = (DWORD)plszStrings->szStrengthLow;

        if(FormatMessageWrapW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      plszStrings->szExchMsg,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPWSTR)&lpwszExch,
                      0,
                      (va_list *)adwFormatParams))
        {
            MapCertFields[i].lpszEditBoxText = lpwszExch;
            MapCertFields[i].lpszListBoxText = plszStrings->szHttpsExchAlg;
            MapCertFields[i].dwSpcCtlId      = 0;
            i++;
        }
    }

    //
    // Last Array Item is marked with 2 NULLs
    //

    MapCertFields[i].lpszListBoxText = NULL;
    MapCertFields[i].lpszEditBoxText = NULL;
    MapCertFields[i].dwSpcCtlId      = 0;


    INET_ASSERT(i < MAX_CERT_FIELDS);

    //
    // Now Launch the Dlg so we can show it.
    //

    ERRORINFODLGTYPE CertDlgInfo;

    CertDlgInfo.dwDlgFlags      = DLG_FLAGS_HAS_CERT_INFO;
    CertDlgInfo.dwDlgId         = IDD_SHOW_CERT;
    CertDlgInfo.hInternetMapped = NULL;
    CertDlgInfo.lpVoid          = (LPVOID) MapCertFields;

    LaunchDlg(
              hWndParent,
              (LPVOID) &CertDlgInfo,
              IDD_VIEW_CERT,
              ViewCertDlgProc
              );



quit:
    if(lpszIssuer) {
        FREE_MEMORY(lpszIssuer);
    }
    if(lpwszTempIssuer) {
        FREE_MEMORY(lpwszTempIssuer);
    }
    if(lpszSubject)
    {
        FREE_MEMORY(lpszSubject);
    }
    if(lpwszTempSubject) {
        FREE_MEMORY(lpwszTempSubject);
    }
    if (szFrom) {
        FREE_MEMORY(szFrom);
    }
    if(pwszTempFrom) {
        FREE_MEMORY(pwszTempFrom);
    }
    if (szUntil) {
        FREE_MEMORY(szUntil);
    }
    if(pwszTempUntil) {
        FREE_MEMORY(pwszTempUntil);
    }
    if (lpwszCipher) {
        FREE_MEMORY(lpwszCipher);
    }
    if (lpwszHash) {
        FREE_MEMORY(lpwszHash);
    }
    if (lpwszExch) {
        FREE_MEMORY(lpwszExch);
    }

    if (lpszHashStr) {
        delete lpszHashStr;
    }
    if(pwszTempHashStr) {
        FREE_MEMORY(pwszTempHashStr);
    }

    return error;
#endif
}


STDAPI_(DWORD) ShowCertificate(
    IN HWND                            hWndParent,
    IN LPVOID  pCertInfoEx
    )

/*++

Routine Description:

    Displays a dialog box that shows the information found
    inside of a certificate.

Arguments:

    hWndParent - Parent Window Handle

    pCertInfoEx - Certificate Information structure, containing the
                fields of info to show.

Return Value:

    DWORD
        Win32 or WININET error code.
--*/

{
    //DWORD error = ShowSecurityInfo(
    //                 hWndParent,
    //                (LPINTERNET_SECURITY_INFO) pCertInfoEx // BAD..
    //                 );

    //return error;

    return ERROR_INTERNET_INTERNAL_ERROR;
}







BOOL
CALLBACK
ViewCertDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Shows a Certificate, and relevent security information to the user.

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    PERRORINFODLGTYPE pDlgInfo;

    const static DWORD mapIDCsToIDHs[] =
    {
         IDC_CERTPICKLIST                 ,IDH_LIST_CERT,
         ID_SHOW_CERTIFICATE              ,IDH_VIEW_CERT,
         IDC_DELETE_CERT                  ,IDH_DEL_CERT,
         0,0
    };

    switch (msg)
    {

    case WM_INITDIALOG:

        INET_ASSERT(lparam);

        pDlgInfo = (PERRORINFODLGTYPE)lparam;

        (void)SetWindowLongPtr(hwnd,
                               DWLP_USER,
                               lparam);

        INET_ASSERT(pDlgInfo->dwDlgFlags & DLG_FLAGS_HAS_CERT_INFO );
        INET_ASSERT(pDlgInfo->lpVoid);

        PlaceCertificateDataIntoListBox(
            hwnd,
            GetDlgItem(hwnd,IDC_FIELDLIST),
            (ShowCertMapping *) pDlgInfo->lpVoid
            );

        OnSelectionOfACertField(
            GetDlgItem(hwnd,IDC_FIELDLIST),
            GetDlgItem(hwnd,IDC_DETAILSLIST),
            (ShowCertMapping *) pDlgInfo->lpVoid
            );


        return TRUE;

    case WM_HELP:                   // F1
        WinHelp( (HWND)((LPHELPINFO)lparam)->hItemHandle,
                szHelpFile,
                HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                );
        break;

    case WM_CONTEXTMENU:        // right mouse click
        WinHelp( (HWND) wparam,
                 szHelpFile,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                 );
        break;


    case WM_COMMAND:
        {

        WORD wID = LOWORD(wparam);
        WORD wNotificationCode = HIWORD(wparam);
        HWND hWndCtrl = (HWND) lparam;

        pDlgInfo =
            (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case ID_TELL_ME_ABOUT_SECURITY:

                    //
                    // Launches help for this button.
                    //

                    WinHelp(
                            hwnd,
                            szHelpFile,
                            HELP_CONTEXT,
                            (ULONG_PTR)HELP_TOPIC_SECURITY
                            );
                                break;


                case IDC_FIELDLIST:

                    //
                    // If the user changes the selection of the listbox
                    //  move the edit control field data to the correct
                    //  entry.
                    //

                    if ( wNotificationCode == LBN_SELCHANGE )
                    {
                        OnSelectionOfACertField(
                            hWndCtrl,
                            GetDlgItem(hwnd,IDC_DETAILSLIST),
                            (ShowCertMapping *) pDlgInfo->lpVoid
                            );
                    }

                    break;

                case IDOK:
                case IDYES:

                    INET_ASSERT(pDlgInfo);
                    INET_ASSERT(pDlgInfo->dwDlgId != 0);

                    EndDialog(hwnd, TRUE);
                    break;

                case IDCANCEL:
                case IDNO:

                    EndDialog(hwnd, FALSE);
                    break;
            }

        return TRUE;
        }
    }

    return FALSE;
}



DWORD
ShowClientAuthCerts(
    IN HWND hWndParent
    )

/*++

Routine Description:

    Shows the Client Authentication Certificates found in the system.

Arguments:

    hWndParent - Parent Window Handle

Return Value:

    DWORD
        Win32 or WININET error code.

--*/


{
// With the NT5 crypto UI we don't need to display client-auth certs anymore.
// I left this in code in the source file in case we switch back to the old
// crypto dlls for some reason. Once we decide to move on to the new crypto dlls
// this code can be removed. - sgs
#ifndef USE_NT5_CRYPTOUI
    DWORD error;
    ERRORINFODLGTYPE ErrorInfoDlgInfo;

    ErrorInfoDlgInfo.hInternetMapped    = NULL;
    ErrorInfoDlgInfo.dwDlgId            = IDD_CERTVIEWER;
    ErrorInfoDlgInfo.lpVoid             = NULL;
    ErrorInfoDlgInfo.dwDlgFlags         = 0;


    CliAuthAquireCertChains(
        NULL,
        NULL,
        (CERT_CHAIN_ARRAY **) &ErrorInfoDlgInfo.lpVoid
        );

    //
    // Don't Care about error code, from function.
    //


    error = LaunchDlg(
              hWndParent,
              (LPVOID) &ErrorInfoDlgInfo,
              ErrorInfoDlgInfo.dwDlgId,
              CertPickDialogProc
              );

    if ( ErrorInfoDlgInfo.lpVoid )
        delete ErrorInfoDlgInfo.lpVoid;

    return error;
#else
    INET_ASSERT(FALSE);
    return ERROR_CALL_NOT_IMPLEMENTED;
#endif
}




DWORD
ParseX509EncodedCertificateForListBoxEntry(
    IN LPBYTE  lpCert,
    IN DWORD   cbCert,
    OUT LPSTR  lpszListBoxEntry,
    IN LPDWORD lpdwListBoxEntry
    )
/*++

Routine Description:

    Parses an X509 certificate, into a single text entry that
    can be displayed on a line in a listbox.

Arguments:

    lpCert           - Certificte bytes to parse

    cbCert           - Size of certificate to parse

    lpszListBoxEntry - Formated text to use in List Box.

    lpdwListBoxEntry - IN: size of lpszListBoxEntry, OUT: actual size of string.

Return Value:

    DWORD
        Win32 or WININET error code.

--*/

{
    BOOL fSuccess;
    DWORD error = ERROR_SUCCESS;
    PCCERT_CONTEXT pCert;
    PCERT_NAME_INFO pName = NULL;
    PCERT_RDN       pIdentRDN;
    PCERT_RDN_ATTR  pIdentifier;
    DWORD           cbIdentifier;
    DWORD cbName, cbName2;


    INET_ASSERT(lpdwListBoxEntry);

    if (lpszListBoxEntry == NULL)
        *lpdwListBoxEntry = 0;

    //
    //  30-Aug-1997 pberkman:
    //              we need to do this to be backwards compatible with this function.
    //              however, becuase the create context function does not get us properties
    //              when we are creating it from a already existing context, we need the
    //              ability to just pass in the pre-existing context.  To do this, just
    //              pass "-1" in for the cbCert and we'll do the "right thing".
    //
    if (cbCert == (-1))
    {
        pCert = (PCCERT_CONTEXT)lpCert;
    }
    else
    {
        pCert = CertCreateCertificateContext(X509_ASN_ENCODING,
                                    lpCert,
                                    cbCert);
    }

    //
    //  30-Aug-1997 pberkman:
    //              look at the "Friendly Name" property first.
    //
    cbName = 0;
    CertGetCertificateContextProperty(pCert, CERT_FRIENDLY_NAME_PROP_ID, NULL, &cbName);

    if (cbName > 0)
    {
        WCHAR *pbFName;

        if (pbFName = (WCHAR *)new BYTE[cbName])
        {
            if (CertGetCertificateContextProperty(pCert, CERT_FRIENDLY_NAME_PROP_ID, pbFName, &cbName))
            {
                cbName2 = WideCharToMultiByte(0, 0, (WCHAR *)pbFName, wcslen((WCHAR *)pbFName) + 1,
                                              lpszListBoxEntry, *lpdwListBoxEntry, NULL, NULL);

                if (cbName2 > *lpdwListBoxEntry)
                {
                    error = ERROR_INSUFFICIENT_BUFFER;
                    *lpdwListBoxEntry = cbName2;
                }

                delete pbFName;

                if ((pCert) && (cbCert != (-1)))
                {
                    CertFreeCertificateContext(pCert);
                }

                return(error);
            }

            delete pbFName;
        }
    }

    if(CryptDecodeObject(pCert->dwCertEncodingType,
                         X509_NAME,
                         pCert->pCertInfo->Subject.pbData,
                         pCert->pCertInfo->Subject.cbData,
                         0,
                         NULL,
                         &cbName))
    {
        pName = (PCERT_NAME_INFO)new BYTE[cbName];
        if(pName == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if(!CryptDecodeObject(pCert->dwCertEncodingType,
                                     X509_NAME,
                                     pCert->pCertInfo->Subject.pbData,
                                     pCert->pCertInfo->Subject.cbData,
                                     0,
                                     pName,
                                     &cbName))
        {
            delete pName;
            pName = NULL;
            error = GetLastError();

        }
    }
    else
    {
        error = GetLastError();
    }

    if((NULL != pName) && (pName->cRDN > 0))
    {
        pIdentifier = CertFindRDNAttr(szOID_COMMON_NAME, pName);

        if(pIdentifier == NULL)
        {
            pIdentifier = CertFindRDNAttr(szOID_ORGANIZATIONAL_UNIT_NAME, pName);
            if(pIdentifier == NULL)
            {
                pIdentifier = CertFindRDNAttr(szOID_ORGANIZATION_NAME, pName);
                if(pIdentifier == NULL)
                {
                    pIdentRDN = &pName->rgRDN[pName->cRDN-1];
                    pIdentifier = &pIdentRDN->rgRDNAttr[pIdentRDN->cRDNAttr-1];
                }
            }
        }


        if(pIdentifier != NULL)
        {
            cbIdentifier = CertRDNValueToStr(pIdentifier->dwValueType,
                              &pIdentifier->Value,
                              NULL,
                              0);

            if(cbIdentifier == 0)
            {
                error = GetLastError();
            }
            else if ( (lpszListBoxEntry != NULL) && (cbIdentifier > (*lpdwListBoxEntry)) )
            {
                error = ERROR_INSUFFICIENT_BUFFER;
                *lpdwListBoxEntry = cbIdentifier;
            }
            else
            {

                *lpdwListBoxEntry = CertRDNValueToStr(pIdentifier->dwValueType,
                                  &pIdentifier->Value,
                                  lpszListBoxEntry,
                                  cbIdentifier);
                error = ERROR_SUCCESS;
            }
        }
        else
        {
            *lpdwListBoxEntry = 0;

            error = ERROR_INTERNET_INVALID_OPERATION;
        }


        delete pName;
    }

    //
    //  30-Aug-1997 pberkman:
    //              we have to free this thing!
    //
    if ((pCert) && (cbCert != (-1)))
    {
        CertFreeCertificateContext(pCert);
    }

    return error;
}



DWORD
ShowX509EncodedCertificate(
    IN HWND    hWndParent,
    IN LPBYTE  lpCert,
    IN DWORD   cbCert
    )
/*++

Routine Description:

    Shows an encoded set of bytes which represent a certificate,
    in a dialog box.

Arguments:

    hWndParent

    lpCert

    cbCert

Return Value:

    DWORD
        ERROR_SUCCESS


--*/

{

    DWORD error;

#ifdef USE_NT5_CRYPTOUI

    //
    // For now, we use the new UI only if we can load the DLL.  Otherwise we
    // resort to the old UI.  Eventually, we may nuke the old UI.
    //

    if (UseCryptoUI())
    {
        CRYPTUI_VIEWCERTIFICATE_STRUCT cert;

        ZeroMemory(&cert, sizeof(cert));
        cert.dwSize = sizeof(cert);
        cert.hwndParent = hWndParent;
        cert.pCertContext = (PCCERT_CONTEXT)lpCert;
        cert.cStores = 1;
        cert.rghStores = (HCERTSTORE *) & (cert.pCertContext->hCertStore);

        return _CryptUIDlgViewCertificate(&cert, NULL);
    }
    else
#endif
    {
        X509Certificate *pCertData = NULL;
        INTERNET_SECURITY_INFO ciInfo;

        ZeroMemory(&ciInfo, sizeof(ciInfo));

        ciInfo.dwSize = sizeof(ciInfo);

        ciInfo.pCertificate = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                         lpCert,
                                                         cbCert);
        error = ShowSecurityInfo(
                                hWndParent,
                                &ciInfo
                                );
    }

    return error;
}



BOOL _GetSelectedCertContext(HWND hwnd, PERRORINFODLGTYPE pDlgInfo, PCCERT_CONTEXT *ppCertContext)
{
    CERT_CONTEXT_ARRAY* pCertContextArray;

    if (ppCertContext == NULL)
        return FALSE;

    *ppCertContext = NULL;

    pCertContextArray =
                ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetCertContextArray();

    PCERT_CHAIN pcCertChain;
    LRESULT index;

    INET_ASSERT(pCertContextArray);
    if (!pCertContextArray)
        return FALSE;

    //
    // Retrieve the Cert from List box
    //

    index = SendDlgItemMessage(hwnd,
                               IDC_CERTPICKLIST,
                               LB_GETCURSEL,
                               0,
                               0);


    if ( index == LB_ERR )
        index = 0;


    if ( index >= (INT) pCertContextArray->GetArraySize())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    *ppCertContext =  pCertContextArray->GetCertContext((INT)index);

    if (!*ppCertContext)
        return FALSE;
    else
        return TRUE;
}


INT_PTR
CALLBACK
CertPickDialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam
    )

/*++

Routine Description:

    Supports Ok/Cancel decisions for the Client Authentication UI.
    Allows the User to select a specific Certificate that he wishes
    to use for Client Auth.

Arguments:

    hwnd    - standard dialog params

    msg     - "

    wparam  - "

    lparam  - "

Return Value:

    BOOL
        TRUE    - we handled message

        FALSE   - Windows should handle message

--*/

{
    PERRORINFODLGTYPE pDlgInfo;
    CERT_CONTEXT_ARRAY* pCertContextArray;
    LRESULT index;

    const static DWORD mapIDCsToIDHs[] =
    {
         IDC_CERTPICKLIST,      IDH_CLIENT_AUTHENTICATION_LIST,
         ID_SHOW_CERTIFICATE,   IDH_CLIENT_AUTHENTICATION_CERT_PROPS,
         IDCLOSE,               IDH_ORG_FAVORITES_CLOSE,
         IDC_BUTTON_IMPORT,     IDH_CLIENTAUTH_IMPORT,
         IDC_BUTTON_EXPORT,     IDH_CLIENTAUTH_EXPORT,
         0,0
    };


    switch (msg)
    {

    case WM_INITDIALOG:

        {
            INET_ASSERT(lparam);

            pDlgInfo = (PERRORINFODLGTYPE)lparam;

            (void)SetWindowLongPtr(hwnd,
                                   DWLP_USER,
                                   lparam);

            // We used to have other dialogs use the same dialog proc, but this
            // shouldn't happen with the removal of the personal certs dialog.
            INET_ASSERT(pDlgInfo->dwDlgId == IDD_CERTPICKER);
            pCertContextArray =
                ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetCertContextArray();


            PlaceCertContextsInListBox(
                GetDlgItem(hwnd, IDC_CERTPICKLIST),
                GetDlgItem(hwnd, ID_SHOW_CERTIFICATE),
                GetDlgItem(hwnd, IDC_BUTTON_EXPORT),
                pCertContextArray
                );

            return TRUE;

        }

    case WM_HELP:                   // F1
        WinHelp( (HWND)((LPHELPINFO)lparam)->hItemHandle,
                szHelpFile,
                HELP_WM_HELP,
                (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                );
        break;

    case WM_CONTEXTMENU:        // right mouse click
        WinHelp( (HWND) wparam,
                 szHelpFile,
                 HELP_CONTEXTMENU,
                 (ULONG_PTR)(LPSTR)mapIDCsToIDHs
                 );
        break;

    case WM_COMMAND:
        {
            WORD wID = LOWORD(wparam);
            WORD wNotificationCode = HIWORD(wparam);
            HWND hWndCtrl = (HWND) lparam;

            pDlgInfo =
                (PERRORINFODLGTYPE) GetWindowLongPtr(hwnd,DWLP_USER);

            switch (wID)
            {
                case ID_TELL_ME_ABOUT_SECURITY:

                    //
                    // Launches help for this button.
                    //

                    WinHelp(
                            hwnd,
                            szHelpFile,
                            HELP_CONTEXT,
                            (ULONG_PTR)HELP_TOPIC_SECURITY
                            );
                                break;


                case ID_SHOW_CERTIFICATE:
                {
                    //
                    // If this dialog supports this behavior, then launch
                    //  a show certficate dlg.
                    //
                    PCCERT_CONTEXT pCertContext;

                    if ( wNotificationCode == BN_CLICKED &&
                         _GetSelectedCertContext(hwnd, pDlgInfo, &pCertContext ))
                    {
                        ShowX509EncodedCertificate( hwnd, (LPBYTE)pCertContext, sizeof(pCertContext) );
                    }

                    break;
                }

                case ID_CERT_MORE_INFO:
                    HtmlHelp(hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, (DWORD_PTR)TEXT("cert_ovr.htm"));
                    break;

                case IDCANCEL:

                    index = -1;
                    goto lskip_getcursel;


                case IDOK:

                    //
                    // Get the selected Cert.
                    //

                    index = SendDlgItemMessage(hwnd,
                                        IDC_CERTPICKLIST,
                                        LB_GETCURSEL,
                                        0,
                                        0);

                    if ( index == LB_ERR )
                        index = -1;


        lskip_getcursel:


                    INET_ASSERT(pDlgInfo);
                    INET_ASSERT(pDlgInfo->dwDlgId != 0);

                    //
                    // Select the Client Auth Cert to use,
                    //  but only if we've got the cert picker dialog.
                    //
                    pCertContextArray =
                        ((HTTP_REQUEST_HANDLE_OBJECT *)pDlgInfo->hInternetMapped)->GetCertContextArray();

                    if (pCertContextArray)
                    {
                        pCertContextArray->SelectCertContext((INT)index);
                    }


                    EndDialog(hwnd, TRUE);
                    break;


                case IDCLOSE:

                    //
                    // We're done, so return FALSE.
                    //

                    EndDialog(hwnd, FALSE);
                    break;


            }

        return TRUE;
        }
    }

    return FALSE;
}





//
// private functions
//


PRIVATE
BOOL
PlaceCertContextsInListBox(
    IN HWND hWndListBox,
    IN HWND hWndViewCertButton,
    IN HWND hWndExportButton,
    IN CERT_CONTEXT_ARRAY* pCertContextArray
    )

/*++

Routine Description:

    Takes an array of CertContext's and puts them into a listbox,
    by cracking their contents one at a time.

Arguments:

    hWndListBox         - Window Handle to ListBox to add items to.

    pCertContext's         - Pointer to array of cert chains.

    hWndViewCertButton  - Window handle to ViewCert Button, NULL if no button is around

Return Value:

    BOOL
        TRUE    - success.

        FALSE   - failure.

--*/

{
    DWORD i = 0;

    if ( !pCertContextArray)
    {
        goto quit;
    }

    SendMessage(hWndListBox, LB_RESETCONTENT, 0, 0 );

    for ( i = 0; i < pCertContextArray->GetArraySize(); i++ )
    {
        PCCERT_CONTEXT pCert;
//        PCERT_NAME_INFO pName = NULL;
//        PCERT_RDN_ATTR  pCommonName;
        DWORD cbName;
        DWORD   dwRet;

        pCert =  pCertContextArray->GetCertContext(i);

        INET_ASSERT(pCert);

        LPSTR lpszSubject;

        cbName = 0;
        ParseX509EncodedCertificateForListBoxEntry(pCert->pbCertEncoded,
                                                   pCert->cbCertEncoded,
                                                   NULL,
                                                   &cbName);
        if (cbName > 0)
        {
            if (lpszSubject = new TCHAR[cbName])
            {
                if (ParseX509EncodedCertificateForListBoxEntry(pCert->pbCertEncoded,
                                                               pCert->cbCertEncoded,
                                                               lpszSubject,
                                                               &cbName) == ERROR_SUCCESS)
                {
                    SendMessage(hWndListBox, LB_INSERTSTRING, (WPARAM)-1, (LPARAM) lpszSubject);
                }

                FREE_MEMORY(lpszSubject);
            }
        }
    }


quit:


    // Select the first item in the list box
    // TODO: move selection to current default item.
    SendMessage(hWndListBox, LB_SETCURSEL, 0, 0 );

    // If nothing was added, disable the windows, otherwise enable them

    EnableWindow(hWndListBox, (i != 0));
    if ( hWndViewCertButton )
        EnableWindow(hWndViewCertButton, (i != 0));
    if ( hWndExportButton )
        EnableWindow(hWndExportButton, (i != 0));

    return TRUE;
}

PRIVATE
BOOL
PlaceCertificateDataIntoListBox(
    IN HWND hWndDlg,
    IN HWND hWndListBox,
    IN ShowCertMapping *pMapCertFields
    )
{

    DWORD i;

    INET_ASSERT(pMapCertFields);
    INET_ASSERT(IsWindow(hWndListBox));

    for ( i = 0; pMapCertFields[i].lpszListBoxText != NULL; i++ )
    {
        if ( pMapCertFields[i].dwSpcCtlId != 0 )
        {
            SetDlgItemTextWrapW(hWndDlg,pMapCertFields[i].dwSpcCtlId,
                pMapCertFields[i].lpszEditBoxText );

            SetWindowLong(GetDlgItem(hWndDlg,pMapCertFields[i].dwSpcCtlId),
                           GWL_STYLE, ES_READONLY |
                                        GetWindowLong(GetDlgItem(hWndDlg,pMapCertFields[i].dwSpcCtlId), GWL_STYLE));

        }

        SendMessage(hWndListBox, LB_ADDSTRING, 0, (LPARAM)pMapCertFields[i].lpszListBoxText);
    }

    INET_ASSERT(i>0);

    SendMessage(hWndListBox, LB_SETCURSEL, 0, 0 );

    return TRUE;
}

PRIVATE
DWORD
OnSelectionOfACertField(
    IN HWND hWndListBox,
    IN HWND hWndEditBox,
    IN ShowCertMapping *pMapCertFields
    )
{
    LRESULT index;

    index = SendMessage(hWndListBox, LB_GETCURSEL, 0, 0);

    if (index == LB_ERR )
        index = 0;


    if ( pMapCertFields[index].lpszListBoxText != NULL )
    {
        SetWindowTextWrapW(hWndEditBox,
                        pMapCertFields[index].lpszEditBoxText );

        SetWindowLong(hWndEditBox,
                       GWL_STYLE, ES_READONLY |
                                    GetWindowLong(hWndEditBox, GWL_STYLE));
    }

    return ERROR_SUCCESS;
}

#ifndef CERT_E_WRONG_USAGE
#   define CERT_E_WRONG_USAGE   _HRESULT_TYPEDEF_(0x800B0110L)
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00010000
#endif
/* get a string representing the status of a certificate */
LPWSTR  GetCertStatus(LPINTERNET_SECURITY_INFO pciCert)
{

    // We've done our handshake, now update the security info
    DWORD dwCertFlags;
    PLOCAL_STRINGS plszStrings;
    GUID                    gHTTPS = HTTPSPROV_ACTION;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   cbServerName;
    DWORD                   error;


    plszStrings = FetchLocalStrings();
    if(plszStrings == NULL)
    {
        return NULL;
    }

    if((pciCert == NULL) || (pciCert->pCertificate == NULL))
    {
        return NULL;
    }


    //
    //  initialize the structures for forward/backward support of wintrust.dll!!!
    //
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;


    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)pciCert->pCertificate;
    sWTCI.chStores              = 1;
    sWTCI.pahStores  = (HCERTSTORE *)&pciCert->pCertificate->hCertStore;


    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;
    polHttps.fdwChecks = INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
                         SECURITY_FLAG_IGNORE_WRONG_USAGE;




    polHttps.pwszServerName = NULL;


    sWTCI.pcwszDisplayName  = NULL;


    error = LoadWinTrust();

    if(ERROR_SUCCESS == error)
    {

        error = WinVerifySecureChannel(NULL, &sWTD);
    }

    // If we are unable to verify revocation, then ignore.
    if(error == CERT_E_REVOCATION_FAILURE)
    {
        error = ERROR_SUCCESS;
    }


    switch(error)
    {
        case CERT_E_EXPIRED:
        case CERT_E_VALIDITYPERIODNESTING:
            return plszStrings->szCommentExpires;

        case CERT_E_UNTRUSTEDROOT:
            return plszStrings->szCommentBadCA;


        case CERT_E_CN_NO_MATCH:
            return plszStrings->szCommentBadCN;

        case CRYPT_E_REVOKED:
            return plszStrings->szCommentRevoked;

        case CERT_E_WRONG_USAGE:
            return plszStrings->szCertUsage;

        case CERT_E_ROLE:
        case CERT_E_PATHLENCONST:
        case CERT_E_CRITICAL:
        case CERT_E_PURPOSE:
        case CERT_E_ISSUERCHAINING:
        case CERT_E_MALFORMED:
        case CERT_E_CHAINING:
            return plszStrings->szCommentNotValid;

        case ERROR_SUCCESS:
            return NULL;

        default:
             return plszStrings->szCommentNotValid;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\map2policy.h ===
#include "hierarchy.h"

class MR2P_Request : public P3PRequest {

public:
   MR2P_Request(P3PResource *pResource,
                P3PURL pszPolicy, unsigned long dwSize,
                P3PSignal *pSignal);
                
   ~MR2P_Request();

   virtual int execute();

   /* function invoked by CreateThread -- 
      for running requests in another thread */
   static unsigned long __stdcall ExecRequest(void *pv);

protected:
   bool  tryPolicyRef(P3PCURL pszPolicyRef, P3PCURL pszReferrer=NULL);

private:
   // Request parameters
   P3PResource *pResource;
   unsigned long dwLength;

   // Out parameters
   P3PURL pszPolicyOut;

   // Internal state of the request
   int cTries;
   P3PResource **ppPriorityOrder;

   P3PResource *pLookupContext;
   P3PCURL pszPolicyInEffect;

   HANDLE   hPrimaryIO;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\download.h ===
#ifndef _DOWNLOAD_H_
#define _DOWNLOAD_H_

#include "hierarchy.h"

struct   ResourceInfo {

   P3PURL     pszFinalURL;
   int        cbURL;
   char      *pszLocalPath;
   int        cbPath;
   FILETIME   ftExpiryDate;
};

int   downloadToCache(P3PCURL pszLocation, ResourceInfo *pInfo = NULL,
                      HANDLE *phCancelReq = NULL, 
                      P3PRequest *pRequest = NULL);

void  endDownload(HANDLE hConnect);

int   setExpiration(P3PCURL pszResource, const char *pszExpData, BOOL fRelative, FILETIME *pftExpire);

int   setExpiration(P3PCURL pszResource, FILETIME ftExpire);

bool  operator > (const FILETIME &ftA, const FILETIME &ftB);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\map2policy.cpp ===
#include <wininetp.h>

#include "map2policy.h"

#include "download.h"
#include "policyref.h"
#include "p3pparser.h"

const char gszP3PWellKnownLocation[] = "/w3c/p3p.xml";

#define different(s, p) !(s&&p&&!strcmp(s,p))

INTERNETAPI_(int) MapResourceToPolicy(P3PResource *pResource, P3PURL pszPolicy, unsigned long dwSize, P3PSignal *pSignal) {

   int ret = P3P_Error;
   
   MR2P_Request *pRequest = new MR2P_Request(pResource, pszPolicy, dwSize, pSignal);
   if (pRequest) {
      if (!pSignal) {
         ret = pRequest->execute();
         delete pRequest;
      }
      else {
   
         DWORD dwThreadID;
         CreateThread(NULL, 0, P3PRequest::ExecRequest, (void*)pRequest, 0, &dwThreadID);
         pSignal->hRequest = pRequest->GetHandle();
         ret = P3P_InProgress;
      }
   }
   return ret;
}

INTERNETAPI_(int) GetP3PRequestStatus(P3PHANDLE hObject) {

   P3PObject *pObject = (P3PObject*) hObject;
   P3PRequest *pRequest = (P3PRequest*) pObject;

   return pRequest->queryStatus();
}

INTERNETAPI_(int) FreeP3PObject(P3PHANDLE hObject) {

   P3PObject *pObject = (P3PObject*) hObject;
   pObject->Free();
   return P3P_Done;
}

/*
Implementation of MR2P_Request class
*/
MR2P_Request::MR2P_Request(P3PResource *pResource, 
                           P3PURL pszPolicy, unsigned long dwSize,
                           P3PSignal *pSignal) 
: P3PRequest(pSignal) {

   static BOOL fNoInterrupt = TRUE;

   this->pResource = pResource;
   this->pszPolicyOut = pszPolicy;
   this->dwLength = dwSize;

   cTries = 0;
   ppPriorityOrder = NULL;
   pLookupContext = NULL;

   pszPolicyInEffect = NULL;
}

MR2P_Request::~MR2P_Request() {

   delete [] ppPriorityOrder;
   endDownload(hPrimaryIO);
}

int MR2P_Request::execute() {
  
   int nDepth = 0;
   P3PResource *pr;

   /* Clear out parameters */
   *pszPolicyOut = '\0';

   /* Determine depth of the resource tree */
   for (pr=pResource; pr; pr=pr->pContainer)
      nDepth++;
      
   /* 
   Construct priority order for trying the policy-reference files.
   According P3P V1 spec, we traverse the tree downwards starting with
   top-level document 
   */
   int current = nDepth;
   ppPriorityOrder = new P3PResource*[nDepth];

   for (pr=pResource; pr; pr=pr->pContainer)
      ppPriorityOrder[--current] = pr;

   for (int k=0; k<nDepth; k++) {

      pLookupContext = pr = ppPriorityOrder[k];

      char achWellKnownLocation[URL_LIMIT] = "";
      unsigned long dwLength = URL_LIMIT;

      UrlCombine(pr->pszLocation, gszP3PWellKnownLocation,
                 achWellKnownLocation, &dwLength, 0);

      P3PCURL pszReferrer = pr->pszLocation;

      /*
      Since policy-refs derived from link-tag, P3P headers or
      the well-known location could be same URL, we avoid trying
      the same PREF multiple times as an optimization
      In order of precedence:
      - Check well known location first -- always defined */
      if (tryPolicyRef(achWellKnownLocation, pszReferrer))
         break;

      /* ... followed by policy-ref from P3P header, if one exists and
         is different from the well-known location */
      if (pr->pszP3PHeaderRef                                  && 
          different(pr->pszP3PHeaderRef, achWellKnownLocation) &&
          tryPolicyRef(pr->pszP3PHeaderRef, pszReferrer))
         break;

      /* followed by policy-ref from HTML link tag, if one exists and
         is different from both the well-known location and P3P header */
      if (pr->pszLinkTagRef                                    && 
          different(pr->pszLinkTagRef, achWellKnownLocation)   &&
          different(pr->pszLinkTagRef, pr->pszP3PHeaderRef)    &&
          tryPolicyRef(pr->pszLinkTagRef, pszReferrer))
         break;
   }

   int ret = pszPolicyInEffect ? P3P_Done : P3P_NoPolicy;

   return ret;
}

bool MR2P_Request::tryPolicyRef(P3PCURL pszPolicyRef, P3PCURL pszReferrer) {

   if (pszPolicyRef==NULL)
      return false;

   P3PCHAR achFinalLocation[URL_LIMIT];
   unsigned long dwSpace = URL_LIMIT;
   char achFilePath[MAX_PATH];
   
   ResourceInfo ri;

   ri.pszFinalURL = achFinalLocation;
   ri.cbURL = URL_LIMIT;
   ri.pszLocalPath = achFilePath;
   ri.cbPath = MAX_PATH;
   
   if (downloadToCache(pszPolicyRef, &ri, &hPrimaryIO, this)>0) {

      P3PContext context = { ri.pszFinalURL, pszReferrer };
      context.ftExpires = ri.ftExpiryDate;

      P3PPolicyRef *pPolicyRef = interpretPolicyRef(achFilePath, &context);

      if (pPolicyRef) {

         FILETIME ftCurrentTime;      
         GetSystemTimeAsFileTime(&ftCurrentTime);

         if (pPolicyRef->getExpiration() > ftCurrentTime)
            pszPolicyInEffect = pPolicyRef->mapResourceToPolicy(pResource->pszLocation, pResource->pszVerb);
         if (pszPolicyInEffect)
            strncpy(pszPolicyOut, pszPolicyInEffect, dwLength);

         delete pPolicyRef;
      }
   }

   /* close the primary-IO handle and set it to NULL */
   endDownload(hPrimaryIO);
   hPrimaryIO = NULL;

   return (pszPolicyInEffect!=NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\hierarchy.h ===
#ifndef _HIERARCHY_H_
#define _HIERARCHY_H_

/*
This file defines object hierarchy for P3P implementation
*/
class P3PObject { 

public:
    virtual ~P3PObject() { }  // Virtual destructor required for inheritance

    virtual int QueryProperty(int property, void *description, unsigned char *result, int space)
        { return -1; }        // Provide stub implementation

    /* caution when overriding this function-- handles must point to the
       base class P3PObject regardless of actual derived class.
       pointer values would be different in the presence of MI */
    virtual P3PHANDLE   GetHandle() { return (P3PHANDLE) this; }

    virtual void        Free()      { delete this; }
};


class P3PRequest : public P3PObject {

public:
   P3PRequest(P3PSignal *pSignal=NULL);
   ~P3PRequest();

   virtual int execute()           = 0;

   virtual int queryStatus()       { return status; }

   virtual void Free();

   /* Function invoked by CreateThread -- 
      used for running P3P requests in separate thread. */
   static unsigned long __stdcall ExecRequest(void *pv);

   virtual void   enterIOBoundState();
   virtual void   leaveIOBoundState();

protected:
   /* Default implementation provided for following functions... */
   virtual int run();
   virtual void waitForCompletion();

   HANDLE hComplete;   /* Event handle for signaling completion */
   int    status;      /* Current status */
   P3PSignal retSignal;/* Used for signaling on non-blocking requests */

   CRITICAL_SECTION  csRequest;
   BOOL fRunning     : 1;
   BOOL fCancelled   : 1;
   BOOL fIOBound     : 1;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\p3pparser.h ===
#ifndef _POLICY_MANAGER_H_
#define _POLICY_MANAGER_H_

#include "p3pglobal.h"
#include "policyref.h"


struct P3PContext {

   /* Original URL of the file being parsed */
   P3PCURL  pszOriginalLoc;

   /* Document which referred to this P3P file */
   P3PCURL  pszReferrer;   

   /* Expiration time implied by HTTP headers */
   FILETIME ftExpires;
};

P3PPolicyRef *interpretPolicyRef(char *pszFileName, P3PContext *pContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\p3ppolicy.h ===
#include "hierarchy.h"
#include "xmlwrapper.h"

class Policy_Request : public P3PRequest {

public:
   Policy_Request(P3PCURL pszPolicyID, HANDLE hDest, P3PCXSL pszXSLtransform=NULL, P3PSignal *pSignal=NULL);
   ~Policy_Request();

   virtual int execute();

private:
   // Request parameters
   P3PURL pszPolicyID;
   P3PCXSL pwszStyleSheet;
   HANDLE hDestination;
   
   // Derived from policy-ID
   P3PURL pszInlineName;

   // State of the request
   HANDLE   hPrimaryIO;

   /* Helper function */
   static bool policyExpired(IXMLDOMDocument *pDocument, const char *pszPolicyURL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\request.cpp ===
#include <wininetp.h>

#include "hierarchy.h"

P3PRequest::P3PRequest(P3PSignal *pSignal) {

   hComplete = CreateEvent(NULL, TRUE, FALSE, NULL);
   status = P3P_NotStarted;

   if (pSignal)
      retSignal = *pSignal;
   else
      memset(&retSignal, 0, sizeof(retSignal));

   InitializeCriticalSection(&csRequest);
   fRunning = TRUE;
   fCancelled = FALSE;
   fIOBound = FALSE;
}

P3PRequest::~P3PRequest() {

   CloseHandle(hComplete);
   DeleteCriticalSection(&csRequest);
}

void P3PRequest::Free() {

   EnterCriticalSection(&csRequest);

   if (!fRunning) {
      /* Important: leave critical-section first...
         self-destruction ("delete this") will free the CS */
      LeaveCriticalSection(&csRequest);
      delete this;
      return;
   }

   fCancelled = TRUE;
   BOOL fBlocked = fIOBound;
   LeaveCriticalSection(&csRequest);

   /* If request is CPU-bound, wait until it completes or aborts.
      Returning before that point would mean that client can free
      parameters passed into the request, causing worker thread to
      access deallocated resources */
   if (!fBlocked)
      waitForCompletion();
}

/* block until the request is finished */
void P3PRequest::waitForCompletion() {

   WaitForSingleObject(hComplete, INFINITE);
}

/* this wrapper function calls execute and signals the completion event
   afterwards. its invoked by the static function ExecRequest  */
int P3PRequest::run() {

   CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

   status = P3P_InProgress;

   __try {
      status = execute();
   } __except (EXCEPTION_EXECUTE_HANDLER) {
      /* catch exception thrown from cancelled request */
      status = P3P_Cancelled;
   }
   ENDEXCEPT

   CoUninitialize();
   return status;
}

unsigned long __stdcall P3PRequest::ExecRequest(void *pv) {

   P3PRequest *pRequest = (P3PRequest*) pv;

   int status = pRequest->run();

   EnterCriticalSection(& pRequest->csRequest);

   /* modify state of the request */
   pRequest->fRunning = FALSE;

   /* remember whether the request is cancelled.
      we cannot examine pRequest object after leaving the critical
      section because of possible race condition where FreeP3PObject()
      can invoke the destructor. */
   BOOL fWasCancelled = pRequest->fCancelled;

   /* signal callers that request is complete */
   if (!fWasCancelled) {

      P3PSignal retSignal = pRequest->retSignal;

      if (retSignal.hEvent)
         SetEvent(retSignal.hEvent);
      if (retSignal.hwnd)
         PostMessage(retSignal.hwnd, retSignal.message, status, (WPARAM) retSignal.pContext);
   }

   SetEvent(pRequest->hComplete);

   LeaveCriticalSection(& pRequest->csRequest);

   /* A cancelled request will be freed on the same thread 
      that it executed on. All other threads get freed on the
      thread where FreeP3PObject() is invoked. */
   if (fWasCancelled)
      delete pRequest;

   return status;
}

void   P3PRequest::enterIOBoundState() {

   EnterCriticalSection(&csRequest);
   if (!fCancelled)
      fIOBound = TRUE;
   BOOL fWasCancelled = fCancelled;
   LeaveCriticalSection(&csRequest);

   /* throw exception if request has been cancelled */
   if (fWasCancelled)
      throw P3P_Cancelled;
}

void   P3PRequest::leaveIOBoundState() {

   EnterCriticalSection(&csRequest);
   fIOBound = FALSE;
   BOOL fWasCancelled = fCancelled;
   LeaveCriticalSection(&csRequest);

   /* throw exception if request has been cancelled */
   if (fWasCancelled)
      throw P3P_Cancelled;     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\p3pparser.cpp ===
#include <wininetp.h>

#include "p3pparser.h"
#include "policyref.h"
#include "xmlwrapper.h"
#include "download.h"

#include <shlwapi.h>


P3PReference *constructReference(TreeNode *pReference, P3PCURL pszOriginURL, P3PCURL pszReferrer) {

    P3PCURL pszPolicyURL = pReference->attribute("about");

    /* Element name must be "POLICY-REF" and the policy location
       must be present in the "about" attribute */
    if (!pszPolicyURL)
        return NULL;

    /* P3PReference object operates on absolute URLs */
    P3PCHAR achPolicy[URL_LIMIT];
    unsigned long dwSize = sizeof(achPolicy);

    UrlCombine(pszOriginURL, pszPolicyURL, achPolicy, &dwSize, 0);
    
    P3PReference *pResult = new P3PReference(achPolicy);
        
    for (TreeNode *pNode = pReference->child(); pNode; pNode=pNode->sibling()) {

        if (pNode->child()==NULL ||
            pNode->child()->text()==NULL)
            continue;

        int fInclude;           
        const char *pszTagName = pNode->tagname();

        if (!strcmp(pszTagName, "METHOD")) {
            pResult->addVerb(pNode->child()->text());
            continue;
        }
        else if (!strcmp(pszTagName, "INCLUDE"))
            fInclude = TRUE;
        else if (!strcmp(pszTagName, "EXCLUDE"))
            fInclude = FALSE;
        else
            continue;   /* Unrecognized tag */

        /* Create absolute path
           NOTE: we will accept absolute URLs in the INCLUDE/EXCLUDE elements,
           even though P3P spec mandates relative URIs. */
        P3PCURL pszSubtree = pNode->child()->text();

        P3PCHAR achAbsoluteURL[URL_LIMIT];
        DWORD dwLength = URL_LIMIT;

        /* Only spaces are to be escaped because the asterix characters 
           is used as wildcard according to P3P spec */
        UrlCombine(pszReferrer, pszSubtree, 
                   achAbsoluteURL, &dwLength,
                   URL_ESCAPE_SPACES_ONLY);

        if (fInclude)
            pResult->include(achAbsoluteURL);
        else
            pResult->exclude(achAbsoluteURL);
    }

    return pResult;
}

P3PPolicyRef *interpretPolicyRef(TreeNode *pXMLroot, P3PContext *pContext) {

    bool fHaveExpiry = false;
    
    TreeNode *prefRoot = pXMLroot->child();

    if (!prefRoot ||
        strcmp(prefRoot->tagname(), "POLICY-REFERENCES"))
        return NULL;

    P3PPolicyRef *pPolicyRef = new P3PPolicyRef();

    /* Loop over the individual references in this policy-ref */
    TreeNode *pCurrent = prefRoot->child();

    while (pCurrent) {

        if (!strcmp(pCurrent->tagname(), "EXPIRY")) {

            /* Check expiry time and update expiry of cache entry */
            FILETIME ftExpires = {0x0, 0x0}; /* initialized to past */

            /* expiry could be absolute HTTP date or relative max-age in seconds */
            if (const char *pszAbsExpiry = pCurrent->attribute("date"))
               setExpiration(pContext->pszOriginalLoc, pszAbsExpiry, FALSE, &ftExpires);
            else if (const char *pszRelExpiry = pCurrent->attribute("max-age"))
               setExpiration(pContext->pszOriginalLoc, pszRelExpiry, TRUE, &ftExpires);

            /* P3P-compliance: when expiration syntax is not recognized, user agent
               MUST assume the policy has expired.
               If both the conditionals above are false, or parse errors are
               encountered when interpreting the strings, the expiration is
               set to the zero-struct corresponding to a date in the past */               
            pPolicyRef->setExpiration(ftExpires);
            fHaveExpiry = true;
        }
        else if (!strcmp(pCurrent->tagname(), "POLICY-REF")) {
            
           P3PReference *pReference = constructReference(pCurrent, pContext->pszOriginalLoc, pContext->pszReferrer);

           if (pReference)
              pPolicyRef->addReference(pReference);
        }

        pCurrent = pCurrent->sibling();
    }

    /* When policy-ref contains no EXPIRY tag, 
       the default lifetime is assigned */
    if (!fHaveExpiry) {

      /* P3P spec states that default expiry for documents is 24 hours */ 
      const char DefRelativeExp[] = "86400";

      FILETIME ftHTTPexpiry;          
      setExpiration(pContext->pszOriginalLoc, DefRelativeExp, TRUE, &ftHTTPexpiry);
      pPolicyRef->setExpiration(ftHTTPexpiry);
   }

   return pPolicyRef;
}

P3PPolicyRef *interpretPolicyRef(char *pszFileName, P3PContext *pContext) {

   P3PPolicyRef *pObject = NULL;

   IXMLDOMDocument *pDocument = parseXMLDocument(pszFileName);

   if (!pDocument)
      return NULL;

   TreeNode *pParseTree = createXMLtree(pDocument);
   pDocument->Release();

   if (pParseTree && !strcmp(pParseTree->tagname(), "META"))
      pObject = interpretPolicyRef(pParseTree, pContext);

   delete pParseTree;

   return pObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\xmltree.cpp ===
#include <wininetp.h>

#include "p3pglobal.h"
#include "xmltree.h"

const char *EmptyString = "";

TreeNode::TreeNode() {

   pSibling = pDescendant = pParent = NULL;

   pAttribute = NULL;

   pszContents = NULL;
}

TreeNode::~TreeNode() {

   for (TreeNode *pn = pDescendant; pn; ) {

      TreeNode *temp = pn->pSibling;
      delete pn;
      pn = temp;
   }

   for (XMLAttribute *pa = pAttribute; pa; ) {

      XMLAttribute *temp = pa->pNext;

      free(pa->pszName);
      free(pa->pszValue);
      delete pa;
      pa = temp;
   }

   if (pszContents)
      free(pszContents);
}

void TreeNode::setContent(const char *pszData) {

   if (pszContents)
      free(pszContents);
   pszContents = pszData ? strdup(pszData) : NULL;
}

void TreeNode::defineAttribute(const char *pszName, const char *pszValue) {

    XMLAttribute *pNewAttribute = new XMLAttribute();

    pNewAttribute->pszName = strdup(pszName);
    pNewAttribute->pszValue = strdup(pszValue);

    pNewAttribute->pNext = pAttribute;

    /* Insert at beginning of attribute list */
    pAttribute = pNewAttribute;
}


const char *TreeNode::attribute(const char *pszAttrName) {

   for (XMLAttribute *pa = pAttribute; pa; pa=pa->pNext) {

      if (!strcmp(pa->pszName, pszAttrName))
         return pa->pszValue;
   }
   
   return NULL;
}

TreeNode *TreeNode::find(const char *pszElemName, unsigned int maxDepth) {

   /* fail search if the current node does not represent an XML tag... */
   if (nodetype!=NODE_ELEMENT)
      return NULL;
   else if (!strcmp(pszContents, pszElemName))
      return this;   /* this is the node we are looking for */
   else if (maxDepth>0) {
      /* otherwise recursively search descendants... */
      if (maxDepth!=INFINITE)
         maxDepth--;
         
      for (TreeNode *pn=pDescendant; pn; pn=pn->pSibling)
         if (TreeNode *pNode = pn->find(pszElemName))
            return pNode;
   }

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\p3ppolicy.cpp ===
#include <wininetp.h>

#include "p3ppolicy.h"
#include "download.h"
#include "xmlwrapper.h"

#define  CheckAndRelease(p)    { if (p) p->Release(); }

INTERNETAPI_(int) GetP3PPolicy(P3PCURL pszPolicyURL, HANDLE hDestination, P3PCXSL pszXSLtransform, P3PSignal *pSignal) {

   Policy_Request *pRequest = new Policy_Request(pszPolicyURL, hDestination, pszXSLtransform, pSignal);
   int result = P3P_Error;

   if (pRequest) {
      if (pSignal) {
         DWORD dwThreadID;
         CreateThread(NULL, 0, P3PRequest::ExecRequest, (void*)pRequest, 0, &dwThreadID);
         result = P3P_InProgress;
         pSignal->hRequest = (P3PHANDLE) pRequest;
      }
      else {
         result = pRequest->execute();
         delete pRequest;
      }
   }

   return result;
}


/*
Implementation of Policy_Request object
*/
Policy_Request::Policy_Request(P3PCURL pszP3PPolicy, HANDLE hDest, P3PCXSL pszXSLtransform, P3PSignal *pSignal) 
: P3PRequest(pSignal) {

   this->pszPolicyID = strdup(pszP3PPolicy);
   this->pwszStyleSheet = pszXSLtransform;
   this->hDestination = hDest;

   pszInlineName = strchr(pszPolicyID, '#');
   if (pszInlineName)
      *pszInlineName++ = '\0';
}

Policy_Request::~Policy_Request() {

   free(pszPolicyID);
   endDownload(hPrimaryIO);
}

bool Policy_Request::policyExpired(IXMLDOMDocument *pDocument, const char *pszPolicyID) {

   /* If no expiration is given in the document,
      it defaults to 24hr lifetime (P3Pv1 spec) */
   bool fExpired = false;

   /* Find an EXPIRY element contained in a POLICIES element.
      Simply searching for EXPIRY will not work because in the case
      of inline policies, we can have more than one tag in a document */
   TreeNode *pTree = createXMLtree(pDocument),
            *pPolicies = pTree ?
                         pTree->find("POLICIES") :
                         NULL,
            *pExpiry = pPolicies ? 
                       pPolicies->find("EXPIRY", 1) :
                       NULL;

   if (pExpiry) {

      FILETIME ftExpires = { 0x0, 0x0 };

      if (const char *pszAbsExpiry = pExpiry->attribute("date"))
         setExpiration(pszPolicyID, pszAbsExpiry, FALSE, &ftExpires);
      else if (const char *pszRelExpiry = pExpiry->attribute("max-age"))
         setExpiration(pszPolicyID, pszRelExpiry, TRUE, &ftExpires);

      FILETIME ftNow;
      GetSystemTimeAsFileTime(&ftNow);
      if (ftNow>ftExpires)
         fExpired = true;
   }

   delete pTree;
   return fExpired;
}

int Policy_Request::execute() {

   IXMLDOMElement *pRootNode  = NULL;
   IXMLDOMNode *pPolicyElem   = NULL;
   IXMLDOMDocument *pDocument = NULL;
   
   int result = P3P_Failed;
   char achFinalLocation[URL_LIMIT];
   char achFilePath[MAX_PATH];

   ResourceInfo ri;

   ri.pszFinalURL = achFinalLocation;
   ri.cbURL = URL_LIMIT;
   ri.pszLocalPath = achFilePath;
   ri.cbPath = MAX_PATH;

   int docsize = downloadToCache(pszPolicyID, &ri, &hPrimaryIO, this);

   if (docsize<=0) {
      result = P3P_NotFound;
      goto EndRequest;
   }

   P3PCURL pszFinalURL = achFinalLocation;

   pDocument = parseXMLDocument(achFilePath);

   if (!pDocument) {
      result = P3P_FormatErr;
      goto EndRequest;
   }

   if (policyExpired(pDocument, pszPolicyID)) {
      result = P3P_Expired;
      goto EndRequest;
   }
   
   HRESULT hr;

   /* Inline policy? */
   if (pszInlineName) {

      /* YES-- use XPath query to locate correct name */
      char achXPathQuery[URL_LIMIT];
      
      wsprintf(achXPathQuery, "//POLICY[@name=\"%s\"]", pszInlineName);

      BSTR bsQuery = ASCII2unicode(achXPathQuery);
      hr = pDocument->selectSingleNode(bsQuery, &pPolicyElem);
      SysFreeString(bsQuery);
   }
   else {
      pDocument->get_documentElement(&pRootNode);
      if (pRootNode)
         pRootNode->QueryInterface(IID_IXMLDOMElement, (void**) &pPolicyElem);
   }   

   if (!pPolicyElem) {
      result = P3P_FormatErr;
      goto EndRequest;
   }

   BSTR bsPolicy = NULL;

   /* Apply optional XSL transform */
   if (pwszStyleSheet) {

      /* This XSL transformation only works on XMLDOMDocument objects, not
         fragments or individual XMLDOMNodes. */
      IXMLDOMDocument 
         *pXSLdoc = createXMLDocument(),
         *pPolicyDoc = createXMLDocument();

      if (!(pXSLdoc && pPolicyDoc))
         goto ReleaseXML;
      
      BSTR bsFragment = NULL;
      VARIANT_BOOL 
         fLoadPolicy = FALSE,
         fLoadXSL = FALSE;
      
      pPolicyElem->get_xml(&bsFragment);
      if (bsFragment) {
         pPolicyDoc->loadXML(bsFragment, &fLoadPolicy);
         SysFreeString(bsFragment);
      }
      else
         goto ReleaseXML;

      if (BSTR bsStyleSheet = (BSTR) pwszStyleSheet)
         pXSLdoc->loadXML(bsStyleSheet, &fLoadXSL);

      if (fLoadPolicy && fLoadXSL)
         pPolicyDoc->transformNode(pXSLdoc, &bsPolicy);
      else
         result = P3P_XMLError;

ReleaseXML:
      CheckAndRelease(pPolicyDoc);
      CheckAndRelease(pXSLdoc);
   }
   else if (pPolicyElem)
      pPolicyElem->get_xml(&bsPolicy);
      
   if (bsPolicy) {

      int cbBytes = SysStringByteLen(bsPolicy);

      unsigned long dwWritten;

      /* need BOM (byte order marker) for Unicode content.
         NOTE: this logic assumes we are writing at beggining of a file. */
      WriteFile(hDestination, "\xFF\xFE", 2, &dwWritten, NULL);

      WriteFile(hDestination, bsPolicy, cbBytes, &dwWritten, NULL);

      SysFreeString(bsPolicy);
      result = P3P_Success;
   }

EndRequest:
   /* release the DOM interfaces */
   CheckAndRelease(pPolicyElem);
   CheckAndRelease(pRootNode);
   CheckAndRelease(pDocument);

   /* close the primary-IO handle and set it to NULL */
   endDownload(hPrimaryIO);
   hPrimaryIO = NULL;

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\policyref.cpp ===
#include <wininetp.h>

#include "policyref.h"

#include <stdlib.h>
#include <string.h>

#pragma warning(disable:4800)

/*
Determine whether given string matches the pattern in second argument
The only wildcard allowed is "*" which stands for zero or more characters
(equivalent to the regular-expression construct "(.*)"

The algorithm here breaks up the pattern into a series of asteriks-seperated
literals and tries to locate each literal inside the search string.
There could be multiple occurences of any given literal but the
algorithm uses the first (eg earliest occurring) match.
*/
bool matchWildcardPattern(const char *str, const char *pattern) {

   if (!pattern || !str)
      return false;

   /* Degenerate case: empty pattern always matches */
   if (*pattern=='\0')
      return true;

   /* Duplicate the pattern because we will need to change it */
   char *ptrndup = strdup(pattern);

   int plen = strlen(ptrndup);
   char *ptrnend = ptrndup+plen; /* Points to nil-terminator at end of pattern */

   char *beginLiteral, *endLiteral;
   const char *marker;

   bool fMatch = false;

   beginLiteral = ptrndup;

   // We will scan the source string starting from the beginning
   marker = str;

   while (true) {

      endLiteral = strchr(beginLiteral,'*');
      if (!endLiteral)
         endLiteral = ptrnend;      

      // Overwrite asteriks with nil-character to terminate the substring
      *endLiteral = '\0';

      // Segment length does not include the nil-terminator
      size_t segmentLen = endLiteral-beginLiteral;
      
      // Search for current segment within the source string
      // Failure means that the pattern does not match-- BREAK the loop
      marker = strstr(marker, beginLiteral);
      if (!marker)
         break;

      // The first literal segment MUST appear at beginning of source string
      if (beginLiteral==ptrndup && marker!=str)
         break;

      // Found: advance pointer along the source string
      marker += segmentLen;

      // Restore the asterix in pattern
      *endLiteral = '*';

      // Move on to next literal in the pattern, which starts
      // after the asteriks in the current literal
      beginLiteral = endLiteral+1;

      // If we have matched all the literal sections in the pattern
      // then we have a match IFF 
      // 1. End of source string is reached   OR
      // 2. The pattern ends with an asterix
      if (beginLiteral>=ptrnend)
      {
         fMatch = (*marker=='\0') || (ptrnend[-1]=='*');
         break;
      }
   }

   free(ptrndup);
   return fMatch;
}


/*
Implementation of P3PReference class
*/
P3PReference::P3PReference(P3PCURL pszLocation) {

   pszPolicyAbout = strdup(pszLocation);
   pHead = NULL;
   fAllVerbs = true;
}

P3PReference::~P3PReference() {

   free(pszPolicyAbout);

   /* Free constraint list */
   Constraint *pc, *next=pHead;
   while (pc=next) {
      next = pc->pNext;
      delete pc;
   }
}

void P3PReference::addPathConstraint(P3PCURL pszSubtree, bool fInclude) {

   Constraint *pc = new Constraint();
   if (!pc)
      return;

   /* This is a path constraint */
   pc->fPath = TRUE;
   pc->pszPrefix = strdup(pszSubtree);
   pc->fInclude = fInclude ? TRUE : FALSE;

   addConstraint(pc);
}

void P3PReference::addConstraint(Constraint *pc) {

   /* Insert at beginning of linked list 
      (Constraint ordering is not significant because they are evaluated
      until one fails) */
   pc->pNext = pHead;
   pHead = pc;
}

void P3PReference::include(P3PCURL pszSubtree) {

   addPathConstraint(pszSubtree, true);
}

void P3PReference::exclude(P3PCURL pszSubtree) {

   addPathConstraint(pszSubtree, false);
}

void P3PReference::addVerb(const char *pszVerb) {

   Constraint *pc = new Constraint();
   if (!pc)
      return;

   /* This is a verb constraint */
   pc->fPath = FALSE;
   pc->pszVerb = strdup(pszVerb);

   addConstraint(pc);
   fAllVerbs = false;
}

bool P3PReference::applies(P3PCURL pszAbsoluteURL, const char *pszVerb) {

   bool fVerbMatch = this->fAllVerbs;
   bool fPathMatch = false;

   /* Scan through the constraint list */
   for (Constraint *pc = pHead; pc; pc=pc->pNext) {

      if (pc->fPath) {

         bool fMatch = matchWildcardPattern(pszAbsoluteURL, pc->pszPrefix);

         /* If the constraint requires the URL to be excluded from that subtree,
            the pattern match must fail. Otherwise the constraint is not satisfied.
            If one path constraint is violated, we can return immediately.
            Otherwise the loop continues.
          */
         if (pc->fInclude && fMatch)
            fPathMatch = true;
         else if (!pc->fInclude && fMatch)
             return false;
      }
      else  
          /* Otherwise this is a verb constraint */
         fVerbMatch = fVerbMatch || !stricmp(pc->pszVerb, pszVerb);
   }
   
   /* The reference applies only if the path constraint is satisfied
      (eg the given URL is included in at least one constraint and not
      excluded by any of the negative constraints) AND verb constraint
      is satisfied */
   return fPathMatch && fVerbMatch;
}


/*
Implementation of P3PPolicyRef class
*/
P3PPolicyRef::P3PPolicyRef() {

   pHead = pLast = NULL;
   ftExpires.dwLowDateTime = ftExpires.dwHighDateTime = 0x0;
}

P3PPolicyRef::~P3PPolicyRef() {

   for (P3PReference *temp, *pref = pHead; pref; ) {
      temp = pref->pNext;
      delete pref;
      pref = temp;
   }
}

void P3PPolicyRef::addReference(P3PReference *pref) {

   /* Order of references in a policy-ref files IS significant.
      The references must be added/evaluated in the same order as 
      they appear in the XML document */
   if (pHead==NULL)
      pHead = pLast = pref;
   else {

      pLast->pNext = pref;
      pLast = pref;
   }

   pref->pNext = NULL;
}

P3PCURL P3PPolicyRef::mapResourceToPolicy(P3PCURL pszResource, const P3PVERB pszVerb) {

   for (P3PReference *pref = pHead; pref; pref=pref->pNext)
      if (pref->applies(pszResource, pszVerb))
         return pref->about();

   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\policyref.h ===
#ifndef _POLICYREF_H_
#define _POLICYREF_H_

#include "p3pglobal.h"
#include "hierarchy.h"

class P3PReference {

public:
   P3PReference(P3PCURL pszPolicy);
   ~P3PReference();
   
   void include(P3PCURL pszSubtree);
   void exclude(P3PCURL pszSubtree);
   void addVerb(const char *pszVerb);

   bool applies(P3PCURL pszAbsoluteURL, const char *pszVerb=NULL);

   inline P3PCURL about() { return pszPolicyAbout; }

private:
   struct Constraint {

      union {
         P3PURL   pszPrefix;     // URL prefix (including wildcards)
         char    *pszVerb;       // Allowed verb
       };

      int      fPath    :1;      // True if this is a path constraint
      int      fInclude :1;      // Switch determines whether this subtree is include/exclude

      Constraint *pNext;         // Pointer to next constraint
   };

   void  addPathConstraint(P3PCURL pszSubtree, bool fInclude);
   void  addConstraint(Constraint *pc);

   Constraint *pHead;
   
   P3PReference *pNext;
   bool fAllVerbs;
   P3PURL pszPolicyAbout;

   friend class P3PPolicyRef;
};

class P3PPolicyRef : public P3PObject {

public:
   P3PPolicyRef();
   ~P3PPolicyRef();

   void    addReference(P3PReference *pr);
   P3PCURL mapResourceToPolicy(P3PCURL pszResource, const P3PVERB pszVerb=NULL);

   void    setExpiration(FILETIME ft)  { ftExpires = ft; }
   FILETIME getExpiration() const      { return ftExpires; }

private:
   P3PReference *pHead, *pLast;
   FILETIME ftExpires;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\xmltree.h ===
#ifndef _XMLTREE_H_
#define _XMLTREE_H_

struct IXMLDOMNode;

struct XMLAttribute {

   char *pszName;
   char *pszValue;
   XMLAttribute *pNext;

   XMLAttribute() : pszName(NULL), 
                    pszValue(NULL), 
                    pNext(NULL) {}
};

extern const char *EmptyString;

class TreeNode {

public:
   TreeNode();
   
   const char *attribute(const char *pszAttrName);

   inline const char *text()     { return pszContents; }

   inline const char *tagname()  { return (nodetype==NODE_ELEMENT) ? 
                                   pszContents : 
                                   EmptyString; }

   inline TreeNode *sibling() { return pSibling; }
   inline TreeNode *child()   { return pDescendant; }

   ~TreeNode();

   /* find first node with given element name */
   TreeNode *find(const char *pszElemName, unsigned int maxDepth=INFINITE);

protected:
   void defineAttribute(const char *pszName, const char *pszValue);
   void setContent(const char *pszData);
   
private:
   TreeNode *pDescendant, *pSibling, *pParent;
   char *pszContents;
   int  nodetype;

   XMLAttribute *pAttribute;

   friend class XMLTree;
   friend TreeNode *createXMLtree(IXMLDOMNode *pXMLnode, TreeNode *pParent);
   friend int defineAttributes(TreeNode *pCurrent, IXMLDOMNode *pXMLnode);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\xmlwrapper.cpp ===
#include <wininetp.h>

#include "xmlwrapper.h"


IXMLDOMDocument *createXMLDocument() {

   IXMLDOMDocument *pDocument = NULL;

   HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**) &pDocument);

   /* if COM library was not initialized, retry after init */
   if (hr==CO_E_NOTINITIALIZED) {
      CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
      hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**) &pDocument);
   }

   return pDocument;
}

IXMLDOMDocument *parseXMLDocument(char *pszFileName) {

   IXMLDOMDocument *document = createXMLDocument();

   if (!document)
      return NULL;

   /* Do not perform DTD or schema validation on P3P files */
   document->put_validateOnParse(FALSE);

   /* Open the file */
   HANDLE hf = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ,
                          NULL, OPEN_EXISTING, 0, NULL);

   if (hf!=INVALID_HANDLE_VALUE) {

      /* Obtain stream from the XML document and write out
         contents of the file to stream */
      IStream *pStream = NULL;

      HRESULT hr = document->QueryInterface(IID_IStream, (void**) &pStream);
   
      if (SUCCEEDED(hr))
      {
         unsigned char xmldata[1024];
         DWORD dwBytes, dwWritten;
 
         do {
             ReadFile(hf, xmldata, sizeof(xmldata), &dwBytes, NULL);
             pStream->Write(xmldata, dwBytes, &dwWritten);
             if (dwBytes!=dwWritten)
                 break;
         }
         while (dwBytes>0);
   
         pStream->Release();
      }

      CloseHandle(hf);
   }

   return document;
};

int defineAttributes(TreeNode *pCurrent, IXMLDOMNode *pXMLnode) {

   int cAttribute = 0;

   IXMLDOMNamedNodeMap *pAttributeMap = NULL;
   
   HRESULT hr = pXMLnode->get_attributes(&pAttributeMap);   

   if (SUCCEEDED(hr) && pAttributeMap) {

      long cItems;
      IXMLDOMNode *pNode;
      IXMLDOMAttribute *pAttribute;

      pAttributeMap->get_length(&cItems);

      for (int i=0; i<cItems; i++) {

         pNode = pAttribute = NULL;
         pAttributeMap->get_item(i, &pNode);

         if (pNode) {

            pNode->QueryInterface(IID_IXMLDOMAttribute, (void**) &pAttribute);

            if (pAttribute) {
            
               BSTR bsName = NULL;
               pAttribute->get_name(&bsName);

               VARIANT var;
               VariantInit(&var);
               pAttribute->get_value(&var);

               char *pszName = unicode2ASCII(bsName);
               char *pszValue = (var.vt==VT_BSTR) ? unicode2ASCII(var.bstrVal) : NULL;

               pCurrent->defineAttribute(pszName, pszValue);
   
               delete [] pszName;
               delete [] pszValue;

               SysFreeString(bsName);
               VariantClear(&var);

               pAttribute->Release();
               cAttribute++;
            }

            pNode->Release();
         }
      }

      pAttributeMap->Release();
   }

   return cAttribute;
}

TreeNode *createXMLtree(IXMLDOMNode *pXMLnode, TreeNode *pParent = NULL) {

   HRESULT hr;

   if (!pXMLnode)
      return NULL;
   
   DOMNodeType dt;
   pXMLnode->get_nodeType(&dt);

   if (dt!=NODE_ELEMENT &&
       dt!=NODE_TEXT    &&
       dt!=NODE_CDATA_SECTION)
      return NULL;
   
   TreeNode *pTree = new TreeNode();
   pTree->nodetype = dt;

   switch (dt) {

   case NODE_ELEMENT: {


         IXMLDOMElement *pElement;
         hr = pXMLnode->QueryInterface(IID_IXMLDOMElement, (void**) &pElement);

         if (SUCCEEDED(hr)) {

            BSTR bsName = NULL;
            pElement->get_tagName(&bsName);

            if (bsName) {
               char *pszTagName = unicode2ASCII(bsName);
               pTree->setContent(pszTagName);
               delete [] pszTagName;
               SysFreeString(bsName);
            }
            
            pElement->Release();
         }
         break;
      }
      
   case NODE_TEXT:
   case NODE_CDATA_SECTION: {

         IXMLDOMCharacterData *pCharData = NULL;
         hr = pXMLnode->QueryInterface(IID_IXMLDOMCharacterData, (void**) &pCharData);

         if (SUCCEEDED(hr)) {

             BSTR bsData = NULL;
             pCharData->get_data(&bsData);

             if (bsData) {
                 pTree->pszContents = unicode2ASCII(bsData);
                 SysFreeString(bsData);
             }
             pCharData->Release();
         }

         break;
      }
   }

   /* Enumerate attributes */
   defineAttributes(pTree, pXMLnode);

   /* Recursively create nodes for descendants */
   TreeNode *pLast = NULL;
   IXMLDOMNode *pChild = NULL;

   pXMLnode->get_firstChild(&pChild);

   while (pChild) {
       
      if (TreeNode *pDescendant = createXMLtree(pChild, pTree)) {

         if (pLast)
            pLast->pSibling = pDescendant;
         pLast = pDescendant;

         if (! pTree->pDescendant)
             pTree->pDescendant = pDescendant;
      }

      IXMLDOMNode *pTemp = pChild;
      hr = pChild->get_nextSibling(&pChild);
      pTemp->Release();
      if (!SUCCEEDED(hr))
         break;
   }

   return pTree;
}


TreeNode *createXMLtree(IXMLDOMDocument *pDocument) {

   IXMLDOMElement *pElement = NULL;
   TreeNode *pRoot = NULL;

   HRESULT hr = pDocument->get_documentElement(&pElement);

   if (pElement) {

      pRoot = createXMLtree(pElement);
      pElement->Release();
   }
   
   return pRoot;
}


/*
Utility functions
*/

char *unicode2ASCII(XMLchar *pwszSource) {

   if (!pwszSource)
      return NULL;

   char *pszDestination = NULL;

   int cRequired = WideCharToMultiByte(CP_ACP, 0, pwszSource, -1, pszDestination, 0, NULL, NULL);

   if (cRequired>0 && (pszDestination = new char[cRequired]))
      WideCharToMultiByte(CP_ACP, 0, pwszSource, -1, pszDestination, cRequired, NULL, NULL);
  
   return pszDestination;
}

BSTR ASCII2unicode(const char *pszSource) {

   int cRequired = MultiByteToWideChar(CP_ACP, 0, pszSource, -1, NULL, 0);

   if (cRequired==0)
      return NULL;

   BSTR bsResult = SysAllocStringLen(NULL, cRequired);

   if (bsResult)
      MultiByteToWideChar(CP_ACP, 0, pszSource, -1, bsResult, cRequired);      
   
   return bsResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\p3p\xmlwrapper.h ===
#ifndef _XMLWRAPPER_H_
#define _XMLWRAPPER_H_

#include "p3pglobal.h"
#include "xmltree.h"

#include <objbase.h>
#include <msxml.h>

typedef wchar_t XMLchar;

IXMLDOMDocument *createXMLDocument();
IXMLDOMDocument *parseXMLDocument(char *pszFileName);

TreeNode *createXMLtree(IXMLDOMDocument *pDocument);

char *unicode2ASCII(XMLchar *pwszSource);
BSTR ASCII2unicode(const char *pszSource);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\perf\inetdown\inetdown.h ===
#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Status Constants
#define CONNECTED       1
#define CONNECTING      2
#define REQUEST_OPENING 3
#define REQUEST_OPENED  4
#define LDG_STARTING    5
#define LDG_START       6
#define LDG_LDG         7
#define LDG_RDY         8 
#define LDG_DONE        9

// Priority Constants
#define LOW    1
#define MEDIUM 2
#define HIGH   3

#define BUF_SIZE 8192
#define BUF_NUM 16

#define URLMAX 4
#define TIMEOUT  60000

#define MAX_SCHEME_LENGTH 64

//MESSAGE ID'S
#define DOWNLOAD_DONE         WM_USER + 1
#define DOWNLOAD_OPEN_REQUEST WM_USER + 2
#define DOWNLOAD_SEND_REQUEST WM_USER + 3
#define DOWNLOAD_READ_FILE    WM_USER + 4


typedef struct
{
    TCHAR    *pURLName;     //The name of the URL
    TCHAR    szRHost[INTERNET_MAX_HOST_NAME_LENGTH]; //from crackUrl
    TCHAR    szRPath[INTERNET_MAX_PATH_LENGTH];      //from crackUrl
    TCHAR    szRScheme[MAX_SCHEME_LENGTH];           //from crackUrl
    INTERNET_PORT nPort;                             //from crackUrl
    INTERNET_SCHEME nScheme;                         //from crackUrl
    void *pNext;                                     //pointer to next element
} url_info;

typedef struct
{
    url_info *pHead;
} url_info_cache;

typedef struct
{
    url_info *pURLInfo;     //Url info struct
    INT      iStatus;       //the url's status
    INT      iPriority;     //the url's priority
                            // LOW, MEDIUM, or HIGH
    DWORD    lNumRead;   //number of bytes read in buffer
    void     *pNext;        //pointer to next element
    HINTERNET hInetCon;     //Internet connection
    HINTERNET hInetReq;     //Internet Request
} outQ;

//
void callOpenRequest(outQ *pOutQ);
void callSendRequest(outQ *pOutQ);
void callReadFile(outQ *pOutQ);
BOOL getServerName(outQ *pOutQ);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\socks\makefile.inc ===
!IFNDEF BASEDIR
BASEDIR=$(_NTDRIVE)$(_NTROOT)
!ENDIF

!IFNDEF SDKINC
SDKINC=$(BASEDIR)\public\sdk\inc
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\socks\wsock32.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
Copyright (c) 1996  Hummingbird Corporation of Canada


Module Name:

    wsock32.c

Abstract:

    Contains Socks V4 support, written by Hummingbird corporation.  Licensed from
    Hummingbird for ulimited use by Microsoft.  Ported to WININET code base.

    Contents:
        FindSocket
        closesocket
        connect
        getpeername
        ALL WSOCK32.DLL exports.

Author:

    Arthur L Bierer (arthurbi) 13-Dec-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Dec-1996 arthurbi
        Created, removed flagrent calls to CRTs, and unchecked memory allocations.

    29-Aug-1997 rfirth
        Further reduced from general-purpose SOCKS implementation to Wininet-
        specific SOCKS support

--*/


#define _WINSOCKAPI_
#include <windows.h>
#ifdef DO_FILE_CONFIG
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <malloc.h>
#include <ctype.h>
#include <stdlib.h>
#endif

#ifdef OLD_SOCKS

struct User {
    char *Name;
    struct User *Next;
};

struct Server {
    char *Name;
    struct Server *Next;
    unsigned short port;
};

struct Hosts {
    struct User *Users;
    struct Server *Servers;
    unsigned long dst;
    unsigned long mask;
    unsigned short port;
    unsigned char op;
    unsigned char type;
    struct Hosts *Next;
} *Head=NULL;

struct Sockets {
    int s;
    HWND hWnd;
    unsigned int wMsg;
    long lEvent;
    unsigned long Blocking;
    int type;
    unsigned long ip;
    unsigned short port;
    struct Sockets *Next;
    struct Sockets *Last;
    int Socked:1;
} *SHead=NULL;

HANDLE SMutex;

#define CREATE_MUTEX()  SMutex = CreateMutex(NULL, FALSE, NULL)
#define DELETE_MUTEX()  if (SMutex) CloseHandle(SMutex)
#define ENTER_MUTEX()   WaitForSingleObject(SMutex, INFINITE)
#define LEAVE_MUTEX()   ReleaseMutex(SMutex)

#else

struct Hosts {
    char * user;
    int userlen;
    unsigned long ip;
    unsigned short port;
} *Head = NULL;

struct Sockets {
    int s;
    int type;
    unsigned long ip;
    unsigned short port;
    struct Sockets * Next;
    struct Sockets * Last;
    int Socked : 1;
    int Blocking : 1;
} *SHead = NULL;

CRITICAL_SECTION    CritSec;

#define CREATE_MUTEX()  InitializeCriticalSection(&CritSec)
#define DELETE_MUTEX()  DeleteCriticalSection(&CritSec)
#define ENTER_MUTEX()   EnterCriticalSection(&CritSec)
#define LEAVE_MUTEX()   LeaveCriticalSection(&CritSec)

#endif

#define DENY    1
#define DIRECT  2
#define SOCKD   3

#define ANY 0
#define EQ  1
#define NEQ 2
#define LT  3
#define GT  4
#define LE  5
#define GE  6


/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { unsigned short s_w1,s_w2; } S_un_w;
                unsigned long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        unsigned short  sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

struct  servent {
        char    * s_name;           /* official service name */
        char    * * s_aliases;      /* alias list */
        short   s_port;             /* port # */
        char    * s_proto;          /* protocol to use */
};

struct  hostent {
        char    * h_name;           /* official name of host */
        char    * * h_aliases;      /* alias list */
        short   h_addrtype;         /* host address type */
        short   h_length;           /* length of address */
        char    * * h_addr_list;    /* list of addresses */
#define h_addr  h_addr_list[0]      /* address, for backward compat */
};


#define WSABASEERR              10000
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAENOBUFS              (WSABASEERR+55)


#define SOCKET_ERROR            (-1)
#define INVALID_SOCKET  (int)(~0)

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

#define SOCK_STREAM     1               /* stream socket */

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, unsigned long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, unsigned long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, unsigned long) /* set/clear async i/o */

#define SO_SET_SOCKS_FIREWALL   0xF0000


DWORD (WINAPI * VArecv)(int a,int b,int c, int d);
DWORD (WINAPI * VAsend)(int a,int b,int c, int d);
DWORD (WINAPI * VEnumProtocolsA)(int a,int b,int c);
DWORD (WINAPI * VEnumProtocolsW)(int a,int b,int c);
DWORD (WINAPI * VGetAddressByNameA)(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j);
DWORD (WINAPI * VGetAddressByNameW)(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j);
DWORD (WINAPI * VGetNameByTypeA)(int a,int b,int c);
DWORD (WINAPI * VGetNameByTypeW)(int a,int b,int c);
DWORD (WINAPI * VGetServiceA)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VGetServiceW)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VGetTypeByNameA)(int a,int b);
DWORD (WINAPI * VGetTypeByNameW)(int a,int b);
DWORD (WINAPI * VNPLoadNameSpaces)(int a,int b,int c);
DWORD (WINAPI * VSetServiceA)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VSetServiceW)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VTransmitFile)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VWSAAsyncGetHostByAddr)(int a,int b,int c,int d,int e,int f,int g);
DWORD (WINAPI * VWSAAsyncGetHostByName)(int a,int b,int c,int d,int e);
DWORD (WINAPI * VWSAAsyncGetProtoByName)(int a,int b,int c,int d,int e);
DWORD (WINAPI * VWSAAsyncGetProtoByNumber)(int a,int b,int c,int d,int e);
DWORD (WINAPI * VWSAAsyncGetServByName)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VWSAAsyncGetServByPort)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * VWSAAsyncSelect)(int s, HWND hWnd, unsigned int wMsg, long lEvent);
DWORD (WINAPI * VWSACancelAsyncRequest)(int a);
DWORD (WINAPI * VWSACancelBlockingCall)(void);
DWORD (WINAPI * VWSACleanup)(void);
DWORD (WINAPI * VWSAGetLastError)(void);
DWORD (WINAPI * VWSAIsBlocking)(void);
DWORD (WINAPI * VWSARecvEx)(int a,int b,int c,int d);
DWORD (WINAPI * VWSASetBlockingHook)(int a);
DWORD (WINAPI * VWSASetLastError)(int a);
DWORD (WINAPI * VWSAStartup)(int a,int b);
DWORD (WINAPI * VWSAUnhookBlockingHook)(void);
DWORD ( * VWSHEnumProtocols)(int a,int b,int c,int d);
DWORD (WINAPI * VWsControl)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * V__WSAFDIsSet)(int a,int b);
DWORD (WINAPI * Vaccept)(int a,int b,int c);
DWORD (WINAPI * Vbind)(int a,int b,int c);
DWORD (WINAPI * Vclosesocket)(int a);
DWORD (WINAPI * Vclosesockinfo)(int a);
DWORD (WINAPI * Vconnect)(int s, const struct sockaddr_in FAR *name, int namelen);
DWORD (WINAPI * Vdn_expand)(int a,int b,int c,int d,int e);
DWORD (WINAPI * Vgethostbyaddr)(int a,int b,int c);
struct hostent * (WINAPI * Vgethostbyname)(char *);
DWORD (WINAPI * Vgethostname)(int a,int b);
DWORD (WINAPI * Vgetnetbyname)(int a);
DWORD (WINAPI * Vgetpeername)(int s, struct sockaddr_in *name,int *namelen);
DWORD (WINAPI * Vgetprotobyname)(int a);
DWORD (WINAPI * Vgetprotobynumber)(int a);
struct servent * (WINAPI * Vgetservbyname)(const char FAR * name, const char FAR * proto);
DWORD (WINAPI * Vgetservbyport)(int a,int b);
DWORD (WINAPI * Vgetsockname)(int a,int b,int c);
DWORD (WINAPI * Vgetsockopt)(int a,int b,int c,int d,int e);
DWORD (WINAPI * Vhtonl)(int a);
DWORD (WINAPI * Vhtons)(int a);
DWORD (WINAPI * Vinet_addr)(char *p);
DWORD (WINAPI * Vinet_network)(int a);
DWORD (WINAPI * Vinet_ntoa)(int a);
DWORD (WINAPI * Vioctlsocket)(int s, long cmd, unsigned long *argp);
DWORD (WINAPI * Vlisten)(int a,int b);
DWORD (WINAPI * Vntohl)(int a);
DWORD (WINAPI * Vntohs)(int a);
DWORD (WINAPI * Vrcmd)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vrecv)(int a,int b,int c,int d);
DWORD (WINAPI * Vrecvfrom)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vrexec)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vrresvport)(int a);
DWORD (WINAPI * Vs_perror)(int a,int b);
DWORD (WINAPI * Vselect)(int a,int b,int c,int d,int e);
DWORD (WINAPI * Vsend)(int a,int b,int c,int d);
DWORD (WINAPI * Vsendto)(int a,int b,int c,int d,int e,int f);
DWORD (WINAPI * Vsethostname)(int a,int b);
DWORD (WINAPI * Vsetsockopt)(int s,int level,int optname,const char FAR * optval, int optlen);
DWORD (WINAPI * Vshutdown)(int a,int b);
DWORD (WINAPI * Vsocket)(int a,int b,int c);
DWORD (WINAPI * VWEP)(void);
DWORD (WINAPI * VAcceptEx)(int a,int b,int c,int d,int e,int f,int g,int h);
DWORD (WINAPI * VGetAcceptExSockaddrs)(int a,int b,int c,int d,int e,int f,int g,int h);
DWORD (WINAPI * VMigrateWinsockConfiguration)(int a,int b, int c);
DWORD (WINAPI * VWSApSetPostRoutine)(void *a);

BOOL (WINAPI * VPostMessage)(HWND hWnd, unsigned int wMsg, WPARAM wPAram, LPARAM lParam) = NULL;

BOOL MyPostMessage(HWND hWnd, unsigned int wMsg, WPARAM wParam, LPARAM lParam) {
    if ( VPostMessage)
        return(VPostMessage(hWnd,wMsg, wParam, lParam));
    PostMessage(hWnd,wMsg, wParam, lParam);
}

struct Sockets *
FindSocket(
    int s
    )

/*++

Routine Description:

    Find or create SOCKS socket object. Returns with MUTEX held

Arguments:

    s   - associated socket handle

Return Value:

    struct Sockets *
        Success - address of Sockets object

        Failure - NULL

--*/

{
    struct Sockets *So;

    ENTER_MUTEX();

    So = SHead;
    while (So) {
        if (s == So->s) {
            return So;
        }
        So = So->Next;
    }
    if (So = (struct Sockets *)LocalAlloc(LPTR, sizeof(struct Sockets))) {
        So->s = s;
        So->Next = SHead;
        SHead = So;
        if (So->Next) {
            (So->Next)->Last = So;
        }
    }
    return So;
}

//LPSTR
//NewString(
//    IN LPCSTR String
//    )
//
///*++
//
//Routine Description:
//
//    kind of version of strdup() but using LocalAlloc to allocate memory
//
//Arguments:
//
//    String  - pointer to string to make copy of
//
//Return Value:
//
//    LPSTR
//        Success - pointer to duplicated string
//        Failure - NULL
//
//--*/
//
//{
//    int len = strlen(String) + 1;
//    LPSTR string;
//
//    if (string = (LPSTR)LocalAlloc(LMEM_FIXED, len)) {
//        CopyMemory(string, String, len);
//    }
//    return string;
//}


DWORD WINAPI __WSAFDIsSet(int a,int b) {
    return(V__WSAFDIsSet(a, b));
}

DWORD WINAPI accept(int a,int b,int c) {
    return(Vaccept(a, b, c));
}

DWORD WINAPI Arecv(int a,int b,int c,int d) {
    return(VArecv(a,b,c,d));
}

DWORD WINAPI Asend(int a,int b,int c,int d) {

    return(VAsend(a,b,c,d));
}

DWORD WINAPI bind(int a,int b,int c) {
    return(Vbind(a, b, c));
}

DWORD WINAPI AcceptEx(int a,int b,int c,int d,int e,int f,int g,int h) {
    return(VAcceptEx(a,b,c,d,e,f,g,h));
}

DWORD WINAPI GetAcceptExSockaddrs(int a,int b,int c,int d,int e,int f,int g,int h) {
    return(VGetAcceptExSockaddrs(a,b,c,d,e,f,g,h));
}

DWORD WINAPI MigrateWinsockConfiguration(int a,int b, int c) {
    return(VMigrateWinsockConfiguration(a,b,c));
}

DWORD WINAPI WSApSetPostRoutine(void *a) {
    VPostMessage=a;
    return(VWSApSetPostRoutine(a));
}

DWORD
WINAPI
closesocket(
    int s
    )

/*++

Routine Description:

    Closes socket handle and destroys associated Sockets object if found

Arguments:

    s   - socket handle

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    struct Sockets * So = FindSocket(s);

    if (So == NULL) {
        VWSASetLastError(WSAENOBUFS);

        LEAVE_MUTEX();

        return SOCKET_ERROR;
    }
    if (So->Last == NULL) {
        SHead = So->Next;
    } else {
        (So->Last)->Next = So->Next;
    }
    if (So->Next) {
        (So->Next)->Last = So->Last;
    }

    LEAVE_MUTEX();

    LocalFree(So);
    return Vclosesocket(s);
}

DWORD WINAPI closesockinfo(int a) {
    return(Vclosesockinfo(a));
}

DWORD
WINAPI
connect(
    int s,
    const struct sockaddr_in FAR * name,
    int namelen
    )

/*++

Routine Description:

    Connect to remote host via SOCKS proxy. Modified from original. If we are
    here then we are going specifically via a known SOCKS proxy. There is now
    only one Hosts object, containing a single SOCKD socks proxy address and
    user name

Arguments:

    s       - socket to connect

    name    - sockaddr of remote host

    namelen - length of sockaddr

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    unsigned long ip;
    unsigned short port;
    struct Hosts * pHost;
    int serr;
    int blocking;
    struct Sockets * pSocket;
    struct sockaddr_in sin;
    struct {
        unsigned char VN;
        unsigned char CD;
        unsigned short DSTPORT;
        unsigned long  DSTIP;
        char UserId[255];
    } request;
    int length;
    char response[256];
    int val;

    //
    // get IP address and port we want to connect to on other side of firewall
    //

    port = name->sin_port;
    ip = name->sin_addr.s_addr;

    //
    // initialize sockaddr for connecting to SOCKS firewall
    //

    memset(&sin, 0, sizeof(sin));
    sin.sin_family = 2;

    //
    // initialize SOCKS request packet
    //

    request.VN = 4;
    request.CD = 1;
    request.DSTPORT = port;
    request.DSTIP = ip;

    pSocket = FindSocket(s);
    if (pSocket == NULL) {
        VWSASetLastError(WSAENOBUFS);

        LEAVE_MUTEX();

        return SOCKET_ERROR;
    }
    pHost = Head;
    if (!pHost || (pSocket->type != SOCK_STREAM) || (pSocket->Socked)) {

        LEAVE_MUTEX();

        return Vconnect(s, name, namelen);
    }

    //
    // get information from pSocket and pHost structures before releasing mutex
    //

    blocking = pSocket->Blocking;
    pSocket->port = port;
    pSocket->ip = ip;
    memcpy(request.UserId, pHost->user, pHost->userlen);
    length = pHost->userlen + 8; // 8 == sizeof fixed portion of request
    sin.sin_port = pHost->port;
    sin.sin_addr.s_addr = pHost->ip;

    //
    // from this point, we cannot touch pHost or pSocket until we take the mutex
    // again
    //

    LEAVE_MUTEX();

    //
    // put socket into blocking mode
    //

    val = 0;
    Vioctlsocket(s, FIONBIO, &val);

    //
    // communicate with SOCKS firewall: send SOCKS request & receive response
    //

    serr = Vconnect(s, &sin, sizeof(sin));
    if (serr != SOCKET_ERROR) {
        serr = Vsend(s, (int)&request, length, 0);
        if (serr == length) {
            serr = Vrecv(s, (int)response, sizeof(response), 0);
        }
    }

    //
    // if originally non-blocking, make socket non-blocking again
    //

    if (blocking) {
        Vioctlsocket(s, FIONBIO, &blocking);
    }

    //
    // if success, mark the socket as being connected through firewall
    //

    if ((serr == SOCKET_ERROR) || (response[1] != 90)) {
        VWSASetLastError(WSAECONNREFUSED);
        serr = SOCKET_ERROR;
    } else {

        //
        // if we can't find/crea
        //

        pSocket = FindSocket(s);
        if (pSocket) {
            pSocket->Socked = 1;
            serr = 0;
        } else {
            VWSASetLastError(WSAENOBUFS);
            serr = SOCKET_ERROR;
        }

        LEAVE_MUTEX();

    }
    return serr;
}

DWORD WINAPI dn_expand(int a,int b,int c,int d,int e) {
    return(Vdn_expand(a, b, c, d, e));
}

DWORD WINAPI EnumProtocolsA(int a,int b,int c) {
    return(VEnumProtocolsA(a, b, c));
}

DWORD WINAPI EnumProtocolsW(int a,int b,int c) {
    return(VEnumProtocolsW(a, b, c));
}

DWORD WINAPI GetAddressByNameA(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j) {
    return(VGetAddressByNameA(a, b, c, d, e, f, g, h, i, j));
}

DWORD WINAPI GetAddressByNameW(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j) {
    return(VGetAddressByNameW(a, b, c, d, e, f, g, h, i, j));
}

DWORD WINAPI gethostbyaddr(int a,int b,int c) {
    return(Vgethostbyaddr(a, b, c));
}

struct hostent FAR * WINAPI gethostbyname(char *a) {
    return(Vgethostbyname(a));
}

DWORD WINAPI gethostname(int a,int b) {
    return(Vgethostname(a, b));
}

DWORD WINAPI GetNameByTypeA(int a,int b,int c) {
    return(VGetNameByTypeA(a, b, c));
}

DWORD WINAPI GetNameByTypeW(int a,int b,int c) {
    return(VGetNameByTypeW(a, b, c));
}

DWORD WINAPI getnetbyname(int a) {
    return(Vgetnetbyname(a));
}

DWORD
WINAPI
getpeername(
    int s,
    struct sockaddr_in * name,
    int *namelen
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    s       -

    name    -

    namelen -

Return Value:

    int

--*/

{
    DWORD ret;
    struct Sockets *So;

    ret = Vgetpeername(s, name, namelen);
    if (ret == 0) {
        So = FindSocket(s);
        if (So) {
            if (So->Socked) {
                if (*namelen >= sizeof(struct sockaddr_in)) {
                    name->sin_port = So->port;
                    name->sin_addr.s_addr = So->ip;
                }
            }
        } else {
            VWSASetLastError(WSAENOBUFS);
            ret = SOCKET_ERROR;
        }

        LEAVE_MUTEX();
    }
    return ret;
}

DWORD WINAPI getprotobyname(int a) {
    return(Vgetprotobyname(a));
}

DWORD WINAPI getprotobynumber(int a) {
    return(Vgetprotobynumber(a));
}

struct servent * WINAPI getservbyname(const char FAR * name, const char FAR * proto) {
    return(Vgetservbyname(name, proto));
}

DWORD WINAPI getservbyport(int a,int b) {
    return(Vgetservbyport(a, b));
}

DWORD WINAPI GetServiceA(int a,int b,int c,int d,int e,int f,int g) {
    return(VGetServiceA(a, b, c, d, e, f, g));
}

DWORD WINAPI GetServiceW(int a,int b,int c,int d,int e,int f,int g) {
    return(VGetServiceW(a, b, c, d, e, f, g));
}

DWORD WINAPI getsockname(int a,int b,int c) {
    return(Vgetsockname(a, b, c));
}

DWORD WINAPI getsockopt(int a,int b,int c,int d,int e) {
    return(Vgetsockopt(a, b, c, d, e));
}

DWORD WINAPI GetTypeByNameA(int a,int b) {
    return(VGetTypeByNameA(a, b));
}

DWORD WINAPI GetTypeByNameW(int a,int b) {
    return(VGetTypeByNameW(a, b));
}

DWORD WINAPI htonl(int a) {
    return(Vhtonl(a));
}

DWORD WINAPI htons(int a) {
    return(Vhtons(a));
}

DWORD WINAPI inet_addr(char *p) {
    return(Vinet_addr(p));
}

DWORD WINAPI inet_network(int a) {
    return(Vinet_network(a));
}

DWORD WINAPI inet_ntoa(int a) {
    return(Vinet_ntoa(a));
}

DWORD WINAPI ioctlsocket(int s, long cmd, unsigned long *argp) {
    if (cmd == FIONBIO) {

        struct Sockets * So = FindSocket(s);

        if (So == NULL) {
            VWSASetLastError(WSAENOBUFS);

            LEAVE_MUTEX();

            return SOCKET_ERROR;
        }
        So->Blocking = *argp ? 1 : 0;

        LEAVE_MUTEX();

    }
    return Vioctlsocket(s, cmd, argp);
}

DWORD WINAPI listen(int a,int b) {
    return(Vlisten(a, b));
}

DWORD WINAPI NPLoadNameSpaces(int a,int b,int c) {
    return(VNPLoadNameSpaces(a, b, c));
}

DWORD WINAPI ntohl(int a) {
    return(Vntohl(a));
}

DWORD WINAPI ntohs(int a) {
    return(Vntohs(a));
}

DWORD WINAPI rcmd(int a,int b,int c,int d,int e,int f) {
    return(Vrcmd(a, b, c, d, e, f));
}

DWORD WINAPI recv(int a,int b,int c,int d) {
    return(Vrecv(a, b, c, d));
}

DWORD WINAPI recvfrom(int a,int b,int c,int d,int e,int f) {
    return(Vrecvfrom(a, b, c, d, e, f));
}

DWORD WINAPI rexec(int a,int b,int c,int d,int e,int f) {
    return(Vrexec(a, b, c, d, e, f));
}

DWORD WINAPI rresvport(int a) {
    return(Vrresvport(a));
}

DWORD WINAPI s_perror(int a,int b) {
    return(Vs_perror(a, b));
}

DWORD WINAPI select(int a,int b,int c,int d,int e) {
    return(Vselect(a, b, c, d, e));
}

DWORD WINAPI send(int a,int b,int c,int d) {
    return(Vsend(a, b, c, d));
}

DWORD WINAPI sendto(int a,int b,int c,int d,int e,int f) {
    return(Vsendto(a, b, c, d, e, f));
}

DWORD WINAPI sethostname(int a,int b) {
    return(Vsethostname(a, b));
}

DWORD WINAPI SetServiceA(int a,int b,int c,int d,int e,int f) {
    return(VSetServiceA(a, b, c, d, e, f));
}

DWORD WINAPI SetServiceW(int a,int b,int c,int d,int e,int f) {
    return(VSetServiceW(a, b, c, d, e, f));
}

DWORD
WINAPI
setsockopt(
    int s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    )

/*++

Routine Description:

    If SO_SET_SOCKS_FIREWALL, create SOCKS information if it is new or changed
    from current, else pass on the request to wsock32!setsockopt()

Arguments:

    s       - socket on which to set option

    level   - option type parameter (SO_SET_SOCKS_FIREWALL)

    optname - option type sub-parameter (SOCKS firewall port # in host format)

    optval  - value to set (pointer to SOCKS information:
                DWORD ip address;
                LPSTR username
              )

    optlen  - length of value (8)

Return Value:

    DWORD
        Success - 0

        Failure - -1

--*/

{
    int rc;

    if (level != SO_SET_SOCKS_FIREWALL) {
        rc = Vsetsockopt(s, level, optname, optval, optlen);
    } else {

        struct Hosts * pHost;
        struct FirewallInfo {
            DWORD ipAddress;
            LPSTR userName;
        } * pInfo = (struct FirewallInfo *)optval;

        optname = Vhtons(optname);

        ENTER_MUTEX();

        if (pHost = Head) {
            if ((pHost->ip != pInfo->ipAddress)
            || (pHost->port != optname)
            || (pHost->user && lstrcmp(pHost->user, pInfo->userName))) {
//char buf[256];
//wsprintf(buf,
//         "throwing out: host: %d.%d.%d.%d:%d,%s; info: %d.%d.%d.%d:%d,%s\n",
//         pHost->ip & 0xff,
//         (pHost->ip >> 8) & 0xff,
//         (pHost->ip >> 16) & 0xff,
//         (pHost->ip >> 24) & 0xff,
//         Vhtons(pHost->port) & 0xffff,
//         pHost->user,
//         pInfo->ipAddress & 0xff,
//         (pInfo->ipAddress >> 8) & 0xff,
//         (pInfo->ipAddress >> 16) & 0xff,
//         (pInfo->ipAddress >> 24) & 0xff,
//         Vhtons(optname) & 0xffff,
//         pInfo->userName
//         );
//OutputDebugString(buf);
                LocalFree(pHost);
                pHost = NULL;
            }
        }
        if (!pHost) {

            int userlen = lstrlen(pInfo->userName) + 1;

            if (pHost = (struct Hosts *)LocalAlloc(LPTR,
                                                   sizeof(struct Hosts)
                                                   + userlen
                                                   )) {
                memcpy(pHost + 1, pInfo->userName, userlen);
                pHost->user = (LPSTR)(pHost + 1);
                pHost->userlen = userlen;
                pHost->ip = pInfo->ipAddress;
                pHost->port = (unsigned short)optname;
            }
        }
        Head = pHost;
        if (pHost) {
            rc = 0;
        } else {
            VWSASetLastError(WSAENOBUFS);
            rc = SOCKET_ERROR;
        }

        LEAVE_MUTEX();

    }
    return rc;
}

DWORD WINAPI shutdown(int a,int b) {
    return(Vshutdown(a, b));
}

DWORD WINAPI socket(int af,int type,int protocol) {

    struct Sockets * So;
    int s;

    s = Vsocket(af, type, protocol);
    if (s != INVALID_SOCKET) {
        So = FindSocket(s);
        if (So) {
            So->type = type;
        } else {
            Vclosesocket(s);
            VWSASetLastError(WSAENOBUFS);
            s = INVALID_SOCKET;
        }
        LEAVE_MUTEX();
    }
    return s;
}

DWORD WINAPI TransmitFile(int a,int b,int c,int d,int e,int f,int g) {
    return(VTransmitFile(a, b, c, d, e, f, g));
}

DWORD WINAPI WEP() {
    return(VWEP());
}

DWORD WINAPI WSAAsyncGetHostByAddr(int a,int b,int c,int d,int e,int f,int g) {
    return(VWSAAsyncGetHostByAddr(a, b, c, d, e, f, g));
}

DWORD WINAPI WSAAsyncGetHostByName(int a,int b,int c,int d,int e) {
    return(VWSAAsyncGetHostByName(a, b, c, d, e));
}

DWORD WINAPI WSAAsyncGetProtoByName(int a,int b,int c,int d,int e) {
    return(VWSAAsyncGetProtoByName(a, b, c, d, e));
}

DWORD WINAPI WSAAsyncGetProtoByNumber(int a,int b,int c,int d,int e) {
    return(VWSAAsyncGetProtoByNumber(a, b, c, d, e));
}

DWORD WINAPI WSAAsyncGetServByName(int a,int b,int c,int d,int e,int f) {
    return(VWSAAsyncGetServByName(a, b, c, d, e, f));
}

DWORD WINAPI WSAAsyncGetServByPort(int a,int b,int c,int d,int e,int f) {
    return(VWSAAsyncGetServByPort(a, b, c, d, e, f));
}

DWORD WINAPI WSAAsyncSelect(int s, HWND hWnd, unsigned int wMsg, long lEvent) {
    return(VWSAAsyncSelect(s,hWnd,wMsg,lEvent));
}

DWORD WINAPI WSACancelAsyncRequest(int a) {
    return(VWSACancelAsyncRequest(a));
}

DWORD WINAPI WSACancelBlockingCall() {
    return(VWSACancelBlockingCall());
}

DWORD WINAPI WSACleanup() {
    return(VWSACleanup());
}

DWORD WINAPI WSAGetLastError() {
    return(VWSAGetLastError());
}

DWORD WINAPI WSAIsBlocking() {
    return(VWSAIsBlocking());
}

DWORD WINAPI WSARecvEx(int a,int b,int c,int d) {
    return(VWSARecvEx(a, b, c, d));
}

DWORD WINAPI WSASetBlockingHook(int a) {
    return(VWSASetBlockingHook(a));
}

DWORD WINAPI WSASetLastError(int a) {
    return(VWSASetLastError(a));
}

DWORD WINAPI WSAStartup(int a,int b) {
    return(VWSAStartup(a, b));
}

DWORD WINAPI WSAUnhookBlockingHook() {
    return(VWSAUnhookBlockingHook());
}

DWORD WINAPI WsControl(int a,int b,int c,int d,int e,int f) {
    return(VWsControl(a,b,c,d,e,f));
}

DWORD WSHEnumProtocols(int a,int b, int c,int d) {
    return(VWSHEnumProtocols(a,b,c,d));
}

//#ifdef DO_FILE_CONFIG
//
//void
//ParseList(char *List,struct Server **Head,int IsSvr) {
//
//    char *p;
//    char *p1;
//    char *pTok;
//    struct Server *tmp,*Current=NULL;
//
//    *Head = NULL;
//
//    if ( *(List+1) != '=')
//        return;
//    pTok = List+2;
//    List=StrTokEx(&pTok,"\t ");
//    p = StrTokEx(&List,",");
//    while ( p) {
//        if (IsSvr) {
//            tmp = (struct Server *)LocalAlloc(LPTR, (sizeof(struct Server)));
//            if ( tmp == NULL )
//                return;
//
//            p1 = strchr(p,':');
//            if (p1) {
//                *p1++ = 0;
//                tmp->port = atoi(p1);
//            }
//            else
//                tmp->port = 1080;
//        }
//        else {
//            tmp = (struct Server *)LocalAlloc(LPTR, (sizeof(struct Server)));
//            if ( tmp == NULL )
//                return;
//        }
//        tmp->Name = NewString(p);
//        tmp->Next = NULL;
//        if (Current == NULL) {
//            Current = *Head = tmp;
//        }
//        else {
//            Current->Next = tmp;
//            Current=tmp;
//        }
//        p = StrTokEx(&List,",");
//    }
//}
//
//
//void
//LoadConfig(void) {
//
//    struct Hosts *Current=NULL,*tmp;
//    char Buffer[1024];
//    FILE *f;
//    char *p;
//    char *ServerList;
//    char *UserList;
//    struct Server *Default=NULL;
//    HKEY Key;
//
//    GetSystemDirectory(Buffer,sizeof(Buffer));
//    strcat(Buffer, "\\socks.cnf");
//    f = fopen(Buffer,"rt");
//    if ( f == NULL)
//        return;
//    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\HummingBird", 0, KEY_QUERY_VALUE, &Key) == ERROR_SUCCESS) {
//    int Type, Length=sizeof(Buffer);
//        if ( RegQueryValueEx(Key, "SOCKS_SERVER", NULL, &Type, Buffer, &Length) == ERROR_SUCCESS) {
//            Buffer[Length] = '\0';
//            Default=LocalAlloc(LPTR, sizeof(struct Server));
//            if ( Default == NULL )
//                return;
//
//            p = strchr(Buffer,':');
//            if (p) {
//                *p++ = 0;
//                Default->port = atoi(p);
//            }
//            else
//                Default->port = 1080;
//            Default->Name = NewString(Buffer);
//            Default->Next = NULL;
//        }
//        RegCloseKey(Key);
//    }
//
//    while ( fgets(Buffer,sizeof(Buffer)-1,f) != NULL) {
//        Buffer[strlen(Buffer)-1]='\0';
//        if ( Buffer[0] == '#')
//            continue;
//        tmp = (struct Hosts *) LocalAlloc(LPTR, sizeof(struct Hosts));
//        if ( tmp == NULL )
//            return;
//
//        memset(tmp,0,sizeof(struct Hosts));
//        ServerList=NULL;
//        UserList=NULL;
//        p = StrTokEx(&Buffer,"\t ");
//        if ( p == NULL) {
//            LocalFree(tmp);
//            continue;
//        }
//        if ( lstrcmpi(p,"DENY") == 0) {
//            tmp->type = DENY;
//        } else if (lstrcmpi(p,"DIRECT") == 0) {
//            tmp->type = DIRECT;
//        } else if (lstrcmpi(p,"SOCKD") == 0) {
//            tmp->type = SOCKD;
//        } else {
//            LocalFree(tmp);
//            continue;
//        }
//LookMore:
//        p = StrTokEx(&Buffer,"\t ");
//        if ( p == NULL) {
//            LocalFree(tmp);
//            continue;
//        }
//        if (*p == '*') {
//            UserList=p;
//            goto LookMore;
//        }
//        if (*p == '@') {
//            ServerList=p;
//            goto LookMore;
//        }
//        tmp->dst = Vinet_addr(p);
//        p = StrTokEx(&Buffer,"\t ");
//        if ( p == NULL) {
//            LocalFree(tmp);
//            continue;
//        }
//        tmp->mask = Vinet_addr(p);
//        p = StrTokEx(&Buffer,"\t ");
//        if (p) {
//            if ( lstrcmpi(p,"EQ") == 0)
//                tmp->op = EQ;
//            else if ( lstrcmpi(p,"NEQ") == 0)
//                tmp->op = NEQ;
//            else if ( lstrcmpi(p,"LT") == 0)
//                tmp->op = LT;
//            else if ( lstrcmpi(p,"GT") == 0)
//                tmp->op = GT;
//            else if ( lstrcmpi(p,"LE") == 0)
//                tmp->op = LE;
//            else if ( lstrcmpi(p,"GE") == 0)
//                tmp->op = GE;
//            else {
//                LocalFree(tmp);
//                continue;
//            }
//            p = StrTokEx(&Buffer,"\t ");
//            if ( p == NULL) {
//                LocalFree(tmp);
//                continue;
//            }
//            if ( isdigit(*p))
//                tmp->port = atoi(p);
//            else {
//            struct servent *se;
//                se=Vgetservbyname(p,"tcp");
//                if ( se == NULL) {
//                    LocalFree(tmp);
//                    continue;
//                }
//                tmp->port = se->s_port;
//            }
//        }
//        if ( UserList)
//            ParseList(UserList,(struct Server **)&tmp->Users,0);
//        if ( ServerList)
//            ParseList(ServerList,&tmp->Servers,1);
//        if ( (tmp->type == SOCKD) && (tmp->Servers == NULL))
//            tmp->Servers=Default;
//        if ( Current == NULL) {
//            Head = Current = tmp;
//        }
//        else {
//            Current->Next = tmp;
//            Current = tmp;
//        }
//    }
//    fclose(f);
//}
//
//#endif

HMODULE hModule = NULL;
int LoadCount = 0;

BOOL
WINAPI
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD reason,
    IN LPVOID Reserved
    )
{
    HKEY hKey;
    TCHAR szRegBuf[MAX_PATH+1];
    DWORD dwRegBufSize = sizeof(szRegBuf);
    DWORD dwRegType;
    LONG lResult;

    switch(reason) {
    case DLL_PROCESS_DETACH:
        if (LoadCount == 0) {
            DELETE_MUTEX();
            return 1;
        }
        if (--LoadCount == 0) {
            FreeLibrary(hModule);
        }
        return 1;

    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
        if (++LoadCount == 1) {
            break;
        }

    default:
        return 1;
    }

    // Load an alternate Winsock DLL based on a registry value,
    // in the event that a customer wants to load a different wsock32.
    //
    if (ERROR_SUCCESS == (lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
        0,
        KEY_QUERY_VALUE,
        &hKey
        )))
    {
        if (ERROR_SUCCESS == (lResult = RegQueryValueEx(
            hKey,
            TEXT("AlternateWinsock"),
            NULL,
            &dwRegType,
            (LPBYTE) szRegBuf,
            &dwRegBufSize
            )) && dwRegType == REG_SZ) // only allow type REG_SZ
        {
            // Found a string, so try to load it as the alternate Winsock DLL.
            hModule = LoadLibrary(szRegBuf);
        }
        RegCloseKey(hKey);
    }

    if (lResult != ERROR_SUCCESS)
    {
        hModule = LoadLibrary("WSOCK32.DLL");
    }

    if (hModule < (HMODULE) HINSTANCE_ERROR) {
        MessageBox(NULL,
                   "Unable to find old WSOCK32.DLL named \"WSOCK32.DLL\".",
                   "Microsoft/Hummingbird SOCKS Shim",
                   MB_OK
                   );
        LoadCount = 0;
        return 0;
    }

    (FARPROC) VArecv=GetProcAddress(hModule,"Arecv");
    (FARPROC) VAsend=GetProcAddress(hModule,"Asend");
    (FARPROC) VEnumProtocolsA=GetProcAddress(hModule,"EnumProtocolsA");
    (FARPROC) VEnumProtocolsW=GetProcAddress(hModule,"EnumProtocolsW");
    (FARPROC) VGetAddressByNameA=GetProcAddress(hModule,"GetAddressByNameA");
    (FARPROC) VGetAddressByNameW=GetProcAddress(hModule,"GetAddressByNameW");
    (FARPROC) VGetNameByTypeA=GetProcAddress(hModule,"GetNameByTypeA");
    (FARPROC) VGetNameByTypeW=GetProcAddress(hModule,"GetNameByTypeW");
    (FARPROC) VGetServiceA=GetProcAddress(hModule,"GetServiceA");
    (FARPROC) VGetServiceW=GetProcAddress(hModule,"GetServiceW");
    (FARPROC) VGetTypeByNameA=GetProcAddress(hModule,"GetTypeByNameA");
    (FARPROC) VGetTypeByNameW=GetProcAddress(hModule,"GetTypeByNameW");
    (FARPROC) VNPLoadNameSpaces=GetProcAddress(hModule,"NPLoadNameSpaces");
    (FARPROC) VSetServiceA=GetProcAddress(hModule,"SetServiceA");
    (FARPROC) VSetServiceW=GetProcAddress(hModule,"SetServiceW");
    (FARPROC) VTransmitFile=GetProcAddress(hModule,"TransmitFile");
    (FARPROC) VWSAAsyncGetHostByAddr=GetProcAddress(hModule,"WSAAsyncGetHostByAddr");
    (FARPROC) VWSAAsyncGetHostByName=GetProcAddress(hModule,"WSAAsyncGetHostByName");
    (FARPROC) VWSAAsyncGetProtoByName=GetProcAddress(hModule,"WSAAsyncGetProtoByName");
    (FARPROC) VWSAAsyncGetProtoByNumber=GetProcAddress(hModule,"WSAAsyncGetProtoByNumber");
    (FARPROC) VWSAAsyncGetServByName=GetProcAddress(hModule,"WSAAsyncGetServByName");
    (FARPROC) VWSAAsyncGetServByPort=GetProcAddress(hModule,"WSAAsyncGetServByPort");
    (FARPROC) VWSAAsyncSelect=GetProcAddress(hModule,"WSAAsyncSelect");
    (FARPROC) VWSACancelAsyncRequest=GetProcAddress(hModule,"WSACancelAsyncRequest");
    (FARPROC) VWSACancelBlockingCall=GetProcAddress(hModule,"WSACancelBlockingCall");
    (FARPROC) VWSACleanup=GetProcAddress(hModule,"WSACleanup");
    (FARPROC) VWSAGetLastError=GetProcAddress(hModule,"WSAGetLastError");
    (FARPROC) VWSAIsBlocking=GetProcAddress(hModule,"WSAIsBlocking");
    (FARPROC) VWSARecvEx=GetProcAddress(hModule,"WSARecvEx");
    (FARPROC) VWSASetBlockingHook=GetProcAddress(hModule,"WSASetBlockingHook");
    (FARPROC) VWSASetLastError=GetProcAddress(hModule,"WSASetLastError");
    (FARPROC) VWSAStartup=GetProcAddress(hModule,"WSAStartup");
    (FARPROC) VWSAUnhookBlockingHook=GetProcAddress(hModule,"WSAUnhookBlockingHook");
    (FARPROC) VWSHEnumProtocols=GetProcAddress(hModule,"WSHEnumProtocols");
    (FARPROC) VWsControl=GetProcAddress(hModule,"WsControl");
    (FARPROC) V__WSAFDIsSet=GetProcAddress(hModule,"__WSAFDIsSet");
    (FARPROC) Vaccept=GetProcAddress(hModule,"accept");
    (FARPROC) Vbind=GetProcAddress(hModule,"bind");
    (FARPROC) Vclosesocket=GetProcAddress(hModule,"closesocket");
    (FARPROC) Vclosesockinfo=GetProcAddress(hModule,"closesockinfo");
    (FARPROC) Vconnect=GetProcAddress(hModule,"connect");
    (FARPROC) Vdn_expand=GetProcAddress(hModule,"dn_expand");
    (FARPROC) Vgethostbyaddr=GetProcAddress(hModule,"gethostbyaddr");
    (FARPROC) Vgethostbyname=GetProcAddress(hModule,"gethostbyname");
    (FARPROC) Vgethostname=GetProcAddress(hModule,"gethostname");
    (FARPROC) Vgetnetbyname=GetProcAddress(hModule,"getnetbyname");
    (FARPROC) Vgetpeername=GetProcAddress(hModule,"getpeername");
    (FARPROC) Vgetprotobyname=GetProcAddress(hModule,"getprotobyname");
    (FARPROC) Vgetprotobynumber=GetProcAddress(hModule,"getprotobynumber");
    (FARPROC) Vgetservbyname=GetProcAddress(hModule,"getservbyname");
    (FARPROC) Vgetservbyport=GetProcAddress(hModule,"getservbyport");
    (FARPROC) Vgetsockname=GetProcAddress(hModule,"getsockname");
    (FARPROC) Vgetsockopt=GetProcAddress(hModule,"getsockopt");
    (FARPROC) Vhtonl=GetProcAddress(hModule,"htonl");
    (FARPROC) Vhtons=GetProcAddress(hModule,"htons");
    (FARPROC) Vinet_addr=GetProcAddress(hModule,"inet_addr");
    (FARPROC) Vinet_network=GetProcAddress(hModule,"inet_network");
    (FARPROC) Vinet_ntoa=GetProcAddress(hModule,"inet_ntoa");
    (FARPROC) Vioctlsocket=GetProcAddress(hModule,"ioctlsocket");
    (FARPROC) Vlisten=GetProcAddress(hModule,"listen");
    (FARPROC) Vntohl=GetProcAddress(hModule,"ntohl");
    (FARPROC) Vntohs=GetProcAddress(hModule,"ntohs");
    (FARPROC) Vrcmd=GetProcAddress(hModule,"rcmd");
    (FARPROC) Vrecv=GetProcAddress(hModule,"recv");
    (FARPROC) Vrecvfrom=GetProcAddress(hModule,"recvfrom");
    (FARPROC) Vrexec=GetProcAddress(hModule,"rexec");
    (FARPROC) Vrresvport=GetProcAddress(hModule,"rresvport");
    (FARPROC) Vs_perror=GetProcAddress(hModule,"s_perror");
    (FARPROC) Vselect=GetProcAddress(hModule,"select");
    (FARPROC) Vsend=GetProcAddress(hModule,"send");
    (FARPROC) Vsendto=GetProcAddress(hModule,"sendto");
    (FARPROC) Vsethostname=GetProcAddress(hModule,"sethostname");
    (FARPROC) Vsetsockopt=GetProcAddress(hModule,"setsockopt");
    (FARPROC) Vshutdown=GetProcAddress(hModule,"shutdown");
    (FARPROC) Vsocket=GetProcAddress(hModule,"socket");
    (FARPROC) VWEP=GetProcAddress(hModule,"WEP");
    (FARPROC) VAcceptEx = GetProcAddress(hModule,"AcceptEx");
    (FARPROC) VGetAcceptExSockaddrs = GetProcAddress(hModule,"GetAcceptExSockaddrs");
    (FARPROC) VMigrateWinsockConfiguration = GetProcAddress(hModule,"MigrateWinsockConfiguration");
    (FARPROC) VWSApSetPostRoutine = GetProcAddress(hModule,"WSApSetPostRoutine");

    CREATE_MUTEX();

#ifdef DO_FILE_CONFIG
    LoadConfig();
#endif

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\cachapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapia.cxx

Abstract:

    contains the ANSI version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <cache.hxx>


/*-----------------------------------------------------------------------------
CreateContainer
----------------------------------------------------------------------------*/
URLCACHEAPI_(BOOL) CreateUrlCacheContainerA(
                 IN LPCSTR Name, 
                 IN LPCSTR CachePrefix, 
                 IN LPCSTR CachePath, 
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                 IN DWORD dwOptions,
                 IN OUT LPVOID pvBuffer,
                 IN OUT LPDWORD cbBuffer
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerA", "%q, %q, %q, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CreateContainer(
                        Name,
                        CachePrefix,
                        CachePath,
                        KBCacheLimit,
                        dwOptions);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) DeleteUrlCacheContainerA(
IN LPCSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerA", "%q, %d", Name, dwOptions));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteContainer(
                        Name,
                        0
                        );

    LEAVE_CACHE_API();
}


URLCACHEAPI_(HANDLE) FindFirstUrlCacheContainerA(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerA",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpdwContainerInfoBufferSize,
        dwOptions
    ));

    DWORD Error;
    HANDLE hFind = NULL;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    hFind = GlobalUrlContainers->FindFirstContainer(pdwModified, 
        lpContainerInfo, lpdwContainerInfoBufferSize, dwOptions);

    if (hFind)
        Error = ERROR_SUCCESS;
    else
    {
        Error = GetLastError();
        // BUGBUG: Free hFind?
        // does the free take NULL?
    }

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError( Error );
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

    
URLCACHEAPI_(BOOL) FindNextUrlCacheContainerA(
IN HANDLE hFind, 
OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
IN OUT LPDWORD lpdwContainerInfoBufferSize
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerA",
        "%#x, %#x, %#x",
        hFind, 
        lpContainerInfo,
        lpdwContainerInfoBufferSize
    ));

    DWORD Error;
    DWORD i;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }


    if (GlobalUrlContainers->FindNextContainer(hFind, 
            lpContainerInfo, lpdwContainerInfoBufferSize))
        Error = ERROR_SUCCESS;
    else
        Error = GetLastError();

    LEAVE_CACHE_API();
}

#define GZIPHACK    8624

URLCACHEAPI_(BOOL) CreateUrlCacheEntryA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwExpectedFileSize,
    IN LPCSTR   lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpszFileExtension: File extension for the saved data file

    dwExpectedFileSize : expected size of the incoming file. If it is unknown
        this value is set to null.

    lpszFileName : pointer to a buffer that receives the full path name of
        the the temp file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryA", "%q, %q, %d, %q, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) || IsBadWriteFileName( lpszFileName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Null first char in lpszFileName cues CreateUniqueFile
    // to generate a file name from scratch. Otherwise,
    // an attempt will be made to generate the filename
    // using the contents of the buffer.
    if(dwReserved != GZIPHACK)
    {
        *lpszFileName = '\0';
    }

    Error = GlobalUrlContainers->CreateUniqueFile(
                        lpszUrlName,
                        dwExpectedFileSize,
                        lpszFileExtension,
                        lpszFileName, 
                        NULL
                        );

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )

/*++

Routine Description:

    This API caches a specified URL in the internet service  cache
    storage. It creates a database entry of the URL info and moves the
    URL file to cache storage.

Arguments:

    lpszUrlName : name of the URL that is cached.

    lpszLocalFileName : name of the local file where the URL data is
        stored. This file will be moved to an another file in cache storage, so
        this name is invalid after this api successfully returns. The
        name should include full path.

    ExpireTime : Expire time (GMT) of the file being cached. If it is
        unknown set it to zero.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    CacheEntryType : type of this new entry.

    lpHeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    lpszFileExtension :  file extension used to create this file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryA",
        "%q, %q, <expires>, <last-mod>, %d, %#x, %d, %q, %q",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpHeaderInfo,
        dwHeaderSize,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadReadFileName( lpszLocalFileName ) : FALSE ) ) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( lpHeaderInfo != NULL ) 
    {
        if( IsBadReadPtr(lpHeaderInfo, dwHeaderSize) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if( lpszFileExtension != NULL ) 
    {
        if( IsBadReadPtr(lpszFileExtension, 3) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    FILETIME     ftPostCheck;
    ftPostCheck.dwLowDateTime = 0;
    ftPostCheck.dwHighDateTime = 0; 
  
    // Record args in structure.
    AddUrlArg Args;
    memset(&Args, 0, sizeof(Args));
    Args.pszUrl      = lpszUrlName;
    Args.pszFilePath = lpszLocalFileName;
    Args.dwFileSize  = 0;
    Args.qwExpires   = FT2LL(ExpireTime);
    Args.qwLastMod   = FT2LL(LastModifiedTime);
    Args.qwPostCheck = FT2LL(ftPostCheck);
    Args.ftCreate = LastModifiedTime;
    Args.dwEntryType = CacheEntryType;
    Args.pbHeaders   = (LPSTR)lpHeaderInfo;
    Args.cbHeaders   = dwHeaderSize;
    Args.pszFileExt  = lpszFileExtension;
    Args.pszRedirect = lpszOriginalUrl ? (LPSTR) lpszOriginalUrl : NULL;
    Args.fImage      = FALSE;

    Error = UrlCacheCommitFile(&Args);

    LEAVE_CACHE_API();
}



URLCACHEAPI_(BOOL) RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileA","%q, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved));
        
    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
            IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RetrieveUrl(
                        lpszUrlName,
                        (lpCacheEntryInfo ? &lpCacheEntryInfo : NULL),
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(HANDLE) RetrieveUrlCacheEntryStreamA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    fRandomRead : if this flag is set to TRUE, then stream is open for
        random access.

    dwReserved: must pass 0

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamA",
        "%q, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpdwCacheEntryInfoBufferSize,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD Error, dwFileSize;

    // Validate parameters.
    if(   IsBadUrl( lpszUrlName )
       || IsBadWriteUrlInfo(lpCacheEntryInfo, *lpdwCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->RetrieveUrl
        (lpszUrlName, &lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize,
            LOOKUP_URL_NOCREATE, RETRIEVE_WITHOUT_CHECKS);

    if( Error != ERROR_SUCCESS )
        goto Cleanup;
    fLocked = TRUE;        

    // Allocate a stream handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hStream)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hStream)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // Open the file.
    hFile = CreateFile
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);

    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        Error = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto Cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    pStream->SourceUrlName = NewString(lpszUrlName);
    if( !pStream->SourceUrlName)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hStream)
        {
            HandleMgr.Free (hStream);
            hStream = NULL;
        }
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(lpszUrlName);
        SetLastError (Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hStream);
    return hStream;
}


URLCACHEAPI_(BOOL) GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This function retrieves the specified cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoA", "%q, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize));

    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        (lpCacheEntryInfo && !lpdwCacheEntryInfoBufferSize) ||
        (lpCacheEntryInfo && lpdwCacheEntryInfoBufferSize && IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_NOCREATE,
                        0);

    LEAVE_CACHE_API();
}


BOOLAPI GetUrlCacheEntryInfoExA(
    IN LPCSTR       lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCEI,
    IN OUT LPDWORD  lpcbCEI,
    OUT LPSTR       lpszOut,
    IN OUT LPDWORD  lpcbOut,
    LPVOID          lpReserved,
    DWORD           dwFlags
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x", lpszUrl, lpCEI, lpcbCEI, lpszOut, lpcbOut, lpReserved, dwFlags));

    DWORD Error;

    // Validate parameters
    // NOTE: once the following params change, edit GetUrlCacheEntryInfoExW accordingly.
    if (   IsBadUrl(lpszUrl)
        || lpszOut
        || lpcbOut 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // We allow mixing of INTERNET_CACHE_FLAG_ALLOW_COLLISIONS with lookup flags
    Error = GlobalUrlContainers->GetUrlInfo
        (lpszUrl, lpCEI, lpcbCEI, LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS), dwFlags);
        
    LEAVE_CACHE_API();
}


URLCACHEAPI_(BOOL) SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the specified fields of the cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that has the url info to
        be set.

    dwFieldControl : Bitmask that specifies the fields to be set.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoA", "%q, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) ||
            IsBadReadUrlInfo( lpCacheEntryInfo )) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        dwFieldControl );

    LEAVE_CACHE_API();
}

URLCACHEAPI_(HANDLE) FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function starts the cache entries enumeration and returns
    the first entry in the cache.

Arguments:

    lpszUrlSearchPattern : pointer to a search pattern string. Currently
        it is not implemented.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryA",
        "%q, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpdwFirstCacheEntryInfoBufferSize
    ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if (IsBadWriteUrlInfo(lpFirstCacheEntryInfo,
                          *lpdwFirstCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               lpFirstCacheEntryInfo, 
                                               lpdwFirstCacheEntryInfoBufferSize, 
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        hFind = NULL;
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheEntryA(
    IN HANDLE hFind,
    OUT LPCACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryA",
        "%#x, %#x, %#x",
        hFind, 
        lpNextCacheEntryInfo,
        lpdwNextCacheEntryInfoBufferSize
    ));

    DWORD Error = ERROR_SUCCESS;
    CACHE_FIND_FIRST_HANDLE* pFind;

    // Validate parameters.
    if (!hFind || IsBadWriteUrlInfo(lpNextCacheEntryInfo,
                                    *lpdwNextCacheEntryInfoBufferSize)) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               lpNextCacheEntryInfo, 
                                               lpdwNextCacheEntryInfoBufferSize,
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);



Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API(Error==ERROR_SUCCESS);
    return (Error == ERROR_SUCCESS );
}


INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExA(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;
    HANDLE hFind = NULL;

    // Validate parameters.
    if (IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               pEntryInfo, 
                                               pcbEntryInfo,
                                               dwFilter,
                                               GroupId,
                                               dwFlags);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hFind)
        {
            GlobalUrlContainers->FreeFindHandle(hFind);
            hFind = NULL;
        }
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;    
}

BOOLAPI FindNextUrlCacheEntryExA(
    IN     HANDLE    hFind,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExA",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hFind,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;

    // Validate parameters.
    if (!hFind || IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    

    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               pEntryInfo, 
                                               pcbEntryInfo, 
                                               NULL, 
                                               NULL,
                                               NULL);
    

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) FreeUrlCacheSpaceA(
    IN LPCSTR lpszCachePath,
    IN DWORD dwFactor,
    IN DWORD dwFilter
    )
/*++

Routine Description:

    This function cleans up the cache entries in the specified ccahe
    path to make space for future cache entries.

Arguments:

    dwFactor: % of free space

Return Value:

    TRUE if the cleanup is successful. Otherwise FALSE, GetLastError()
    returns the extended error.

--*/
{
    DWORD Error;
    
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpace", 
        "<path>,%d, %#x", dwFactor, dwFilter));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CleanupUrls(lpszCachePath, dwFactor, dwFilter);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFileA(
    LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
   
    DWORD Error;
    DWORD i;

    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFile",
        "%q, %#x", lpszUrlName, dwReserved));

    // validate parameters.
    if( IsBadUrl( lpszUrlName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->UnlockUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntry",
        "%q", lpszUrlName));


    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->DeleteUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

BOOLAPI SetUrlCacheEntryGroupA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupA", 
        "%q, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    DWORD Error;

    // Validate parameters.
    if (IsBadUrl(lpszUrlName)
        || !GroupId
        || pbGroupAttributes
        || cbGroupAttributes
        || lpReserved
        )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlGroup (lpszUrlName, dwFlags, GroupId);

    LEAVE_CACHE_API();
}



URLCACHEAPI_(BOOL) GetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupInfo ||
        !lpdwGroupInfo ||
        IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOA) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetGroupAttributes(
                        gid,
                        dwAttributes,
                        lpGroupInfo,
                        lpdwGroupInfo );
    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) SetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    DWORD Error;

    // validate parameters.
    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOA) ) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetGroupAttributes(
            gid, dwAttributes, lpGroupInfo);

    LEAVE_CACHE_API();
}

BOOLAPI IsUrlCacheEntryExpiredA(
    IN      LPCSTR       lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    BOOL                        bRet = TRUE;
    CACHE_ENTRY_INFOEX*         pCEI = NULL;    
    DWORD                       cbCEI;
    DWORD                       dwError;
    BOOL                        bLazy = FALSE;
    BOOL                        fLocked = FALSE;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) || !pftLastModifiedTime ) {
        INET_ASSERT(FALSE); 
        return ERROR_INVALID_PARAMETER;
    }

    // set out LastModTime to 0
    pftLastModifiedTime->dwLowDateTime = 0 ;
    pftLastModifiedTime->dwHighDateTime = 0 ;


    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    //
    // BUGBUG
    // ideally, we should use GlobalUrlContainers->GetUrlInfo()
    // with NO_ALLOCATION and HEADONLY flag for perf.
    // however, there is a flag (lookup flag v.s entry flag) collision 
    // in that code path which prevents this working
    // so we use this anti-perf RetrieveUrl for now until that one
    // gets fixed 
    //                                           --DanpoZ, 98.09.09
    
    // Find the container and search the index.
    dwError = GlobalUrlContainers->RetrieveUrl(
                    lpszUrlName, 
                    (CACHE_ENTRY_INFO**) &pCEI, 
                    &cbCEI, 
                    (dwFlags & INTERNET_FLAG_FWD_BACK)?
                        LOOKUP_URL_TRANSLATE : LOOKUP_URL_NOCREATE,
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    
    // not found in cache
    if( dwError != ERROR_SUCCESS )
        goto Cleanup;    

    fLocked = TRUE;

    // found in cache, get the last modified time
    *pftLastModifiedTime = pCEI->LastModifiedTime;

    bRet = IsExpired(pCEI, dwFlags, &bLazy);
    if( bRet && bLazy )
    {
        //
        // the entry is not expired, however, we need to post-fetch
        // so we have to return EXPIRED back to trident to force them
        // issue a binding, on the new binding, urlmon-wininet returns
        // the cache content and queue a background update
        // (an alternative would be to ask trident to catch this case
        //  and call background update themself)
        // 
        bRet = FALSE;
    }

Cleanup:
    if( pCEI )
        FREE_MEMORY(pCEI);

    if (fLocked)
        GlobalUrlContainers->UnlockUrl(lpszUrlName);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\401imprt.cxx ===
#include <cache.hxx>

#include "401imprt.hxx"
#include "401inc.hxx"

#ifdef UNICODE
#error "401imprt.cxx doesn't support UNICODE compilation."
#endif

#define PRE5_CACHE_KEY  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache"
#define IE401_HIST_ROOT "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache"

//IE401_PER_USER_CACHE_LOCATION is in HKCU
#define IE401_PER_USER_CACHE_LOCATION \
        "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"
#define IE401_PER_USER_CACHE_KEY "Cache"
//IE401_ONE_USER_CACHE_LOCATION is in HKLM
#define IE401_ONE_USER_CACHE_LOCATION \
        "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Content"
#define IE401_ONE_USER_CACHE_KEY "CachePath"

#define MSHIST_DIR_SZ       "MSHIST011998020119980225"##FILENAME_SEPARATOR_STR
#define MSHIST_KEY_SZ       "MSHIST011998020119980225"
#define MSHIST_SZ           "MSHIST"
#define MSHIST_PREFIX_SZ    ":1998010119980101:"
#define VISITED_PREFIX_SZ   "Visited:"
#define INDEX_DAT_SZ        "index.dat"
#define CACHE_LIMIT_SZ      "CacheLimit"
#define CACHE_OPTIONS_SZ    "CacheOptions"
#define CACHE_PATH_SZ       "CachePath"
#define CACHE_PREFIX_SZ     "CachePrefix"

//----------------------------------------
//The following tructures and macro, _HISTDATA_V001 and SET_HISTORY_FLAG()
//allow us to notify members of the Visited: cache that they are to be
//listed in the History view.  The structure was cut'n'pasted from
//shdocvw\urlhist.cpp and any changes made to the original need
//to be reflected here as well.
#define PIDISF_HISTORY 0x10000000
#define PID_INTSITE_TITLE         16
//** BUGBUG

struct _HISTDATA_V001
{
    UINT  cbSize : 16;           // size of this header
    UINT  cbVer  : 16;           // version
    DWORD           dwFlags;    // PID_INTSITE_FLAGS (PIDISF_ flags)
    DWORD           dwWatch;    // PID_INTSITE_WATCH (PIDISM_ flags)
    DWORD           dwVisits;   // PID_INTSITE_VISITCOUNT
};

#define SET_HISTORY_FLAG(lpHeaderInfo) \
            (((_HISTDATA_V001*)lpHeaderInfo)->dwFlags |= PIDISF_HISTORY)

//
//  Right after HISTDATA (always at cbSize), we have optional (typically
// variable length) data which has following data structure. It may have
// more than one but always has a null-terimiator (cbExtra == 0).
//
//HISTEXTRA is also cut'n'pasted from shdocvw.
struct HISTEXTRA
{
    UINT cbExtra : 16;
    UINT idExtra : 8;   // PID_INTSITE_*
    UINT vtExtra : 8;   // VT_*
    BYTE abExtra[1];    // abExtra[cbExtra-4];
};

// HISTEXTRA without the abExtra  ==> (sizeof(HISTEXTRA) - sizeof(BYTE))
#define HISTEXTRA_HEAD_SIZE 4
//-----------------------------------------


BOOL IsPerUserCache();

namespace ie401
{


//--------------------------------------------------------

//  The code that enumerates through a IE401 index.dat file is provided
//by IE401IndexFile.  Classes derived from IE401IndexFile override HandleHashElement
//to handle each HASH_ELEMENT as the index file is enumerated.
//  IE401IndexFile::Import401Url is provided to import URLs without overwriting
//already existing entries.

class IE401IndexFile
{
public:
    //  EnumHashValues enumerates hash tables, calling HandleHashElement for each.
    virtual BOOL EnumHashValues();

protected:
    IE401IndexFile( LPCSTR szFilename);
    IE401IndexFile();
    virtual ~IE401IndexFile();

    //  given by derived class
    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry) = 0;

    //  probably useful to many, default URL import.  Not for REDIRs.
    virtual BOOL Import401Url( ie401::URL_FILEMAP_ENTRY* pEntry);

    BYTE* m_pBuf;
};


//--------------------------------------------------------

//  IE401Visited overrides HandleHashElement to import all URLs,
//translating CEI to its current format.
//  All the dependencies on the change in CEI format are
//contained in UpgradeHeaderData.

class IE401Visited : public IE401IndexFile
{
public:
    IE401Visited( LPCSTR szFilename);

protected:
    IE401Visited() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    virtual BOOL Import401UrlTranslatingCEI( ie401::URL_FILEMAP_ENTRY* pEntry);

    virtual BOOL UpgradeHeaderData(
            IN      const CHAR* pIn,
            OUT     CHAR* pOut,
            IN OUT  DWORD* pcbOutSize);
};


//--------------------------------------------------------

//  IE401History overrides HandleHashElement to import all URLs
//and mark them in the Visited: container.
//  All the dependencies on the format for the Visited mark
//are contained in MarkUrlAsVisited.
//(colliding items are not imported and associated data
//files are not copied.)

class IE401History : public IE401IndexFile
{
public:
    IE401History( LPCSTR szFilename);

protected:
    IE401History() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    static BOOL MarkUrlAsVisited( LPSTR szUrlName);
};


//--------------------------------------------------------


// pre-declaration included so IE401Redirects can be declared as a friend
class IE401Redirects;


//  IE401Content overrides HandleHashElement to import all URLs
//and also copy associated data files.
//(colliding items are not imported)
class IE401Content : public IE401IndexFile
{
public:
    IE401Content( LPCSTR szFilename);

    friend IE401Redirects;

protected:
    IE401Content() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    //  Extends the default to import files
    BOOL Import401UrlWithFile( ie401::URL_FILEMAP_ENTRY* pEntry);

    CHAR  m_szRootPath[MAX_PATH];
    DWORD m_cbRootPathLength;
    DWORD m_nDirs;
    CHAR  m_szDir[DEFAULT_MAX_DIRS][DIR_NAME_SIZE + 1];
};


//--------------------------------------------------------


//  IE401Redirects override HandleHashElement to import redirects.
//  This should be done to an index file after IE401Content has
//enumerated over it, so the constructor takes a IE401Content object
//rather than a filename.  This IE401Content represents a process
//that is finished, so its functionality is taken away.
//  Importing redirects is done with a separate enumerator than
//IE401Content since its less work then retooling IE401IndexFile
//to enumerate an arbitrary number of times.
class IE401Redirects : public IE401IndexFile
{
public:
    IE401Redirects( IE401Content* pContent);

protected:
    IE401Redirects() {}

    virtual BOOL HandleHashElement( ie401::HASH_ITEM* pEntry);

    BOOL Import401Redirect( ie401::REDIR_FILEMAP_ENTRY* pEntry);
};


//******************************************************
//
// class OutputStream  - utility
//
//  outputs data to a buffer, tracking buffer used
//and checking for overflow.


class OutputStream
{
public:
    OutputStream( VOID* pBuffer, DWORD cbBufferSize)
    : m_pBuffer( (BYTE*)pBuffer), m_cbBufferSize( cbBufferSize), m_cbPosition(0)
    {
    }

    BOOL Memcpy( const VOID* pSource, DWORD cbSize)
    {
        if( cbSize + m_cbPosition <= m_cbBufferSize)
        {
            memcpy(&m_pBuffer[m_cbPosition], (BYTE*)pSource, cbSize);
            m_cbPosition += cbSize;
            return TRUE;
        }
        else
            return FALSE;
    }

    BOOL CopyAnsiToUnicode( const CHAR* pSource, DWORD cSize)
    {
        if( m_cbPosition + cSize * sizeof(WCHAR) / sizeof(CHAR)
            <= m_cbBufferSize)
        {
            DWORD dwSizeCopied;

            // the semantics of MultiByteToWideChar is different
            //if you give it a zero-length buffer.
            INET_ASSERT( m_cbBufferSize - m_cbPosition != 0);

            dwSizeCopied =
                MultiByteToWideChar( CP_ACP, 0, pSource, cSize,
                    (WCHAR*)&m_pBuffer[m_cbPosition],
                    (m_cbBufferSize - m_cbPosition) / sizeof(WCHAR));

            if( dwSizeCopied != 0)
            {
                m_cbPosition += dwSizeCopied * sizeof(WCHAR);
                return TRUE;
            }
            else
                return FALSE;
        }
        else
            return FALSE;
    }

    DWORD GetFinalLength()
    {
        return m_cbPosition;
    }

private:
    BYTE* m_pBuffer;

    DWORD m_cbBufferSize, m_cbPosition;
};


//*************************************************************************
//
//  IE401IndexFile
//

//  On creation, load the contents of the given file into memory.

IE401IndexFile::IE401IndexFile( LPCSTR szFilename)
{
    m_pBuf = NULL;

    //  load the file into the buffer
    DWORD cbBufSize;
    if( ReadFileToBuffer( szFilename, &m_pBuf, &cbBufSize) == FALSE)
    {
        if( m_pBuf != NULL)
        {
            delete [] m_pBuf;
            m_pBuf = NULL;
        }
    }
    else if( cbBufSize < sizeof(_MEMMAP_HEADER_SMALL)
        || strcmp((LPSTR) m_pBuf, "Client UrlCache MMF Ver 4.7"))
    {
        //  If this file doesn't even have a memmap header, forget it.
        //  Now all derived classes can assume they have at least a memmap header
        //if m_pBuf != NULL
        delete [] m_pBuf;
        m_pBuf = NULL;
    }
}


//  Default constructor made protected to prevent direct creation
IE401IndexFile::IE401IndexFile()
: m_pBuf(NULL)
{
}


IE401IndexFile::~IE401IndexFile()
{
    if( m_pBuf != NULL)
        delete [] m_pBuf;
}


//---------------------------------------------------
//

//  Enumerate through the entries in an ie401 index
//file, calling HandleHashElement on each entry.

BOOL IE401IndexFile::EnumHashValues()
{
    BOOL retVal = FALSE;

    if( m_pBuf == NULL)
        goto doneEnumHashValues;

    HASH_FILEMAP_ENTRY* pTable;
    HASH_ITEM* pItem;
    //  pTable is located by an offset which is located at dwHashTableOffset
    pTable = (HASH_FILEMAP_ENTRY*)(m_pBuf + (((_MEMMAP_HEADER_SMALL*)m_pBuf)->dwHashTableOffset));
    // The first location in the table follows immediately after the HASH_FILEMAP_ENTRY pTable
    pItem = (HASH_ITEM*)(pTable + 1);

    if (pTable->dwSig != SIG_HASH)
        goto doneEnumHashValues;

    do // Scan the list of tables.
    {
        // Scan the current table.
        for (; (LPBYTE)pItem < (LPBYTE)pTable + BYTES_PER_TABLE; pItem++)
        {
            //  call virtual entry handler
            if( HandleHashElement( pItem) == FALSE)
                goto doneEnumHashValues;
        }

        // Follow the link to the next table.
        if (!pTable->dwNext)
        {
            pTable = NULL;
        }
        else
        {
            // Validate the table signature and sequence number.
            DWORD nBlock;
            nBlock = pTable->nBlock;
            pTable = (HASH_FILEMAP_ENTRY*) (m_pBuf + pTable->dwNext);
            if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock + 1)
                goto doneEnumHashValues;

            // Set pointer to first location in table.
            pItem = (HASH_ITEM*) (pTable + 1);
        }
    }
    while (pTable);

    retVal = TRUE;

doneEnumHashValues:
    return retVal;
}


//---------------------------------------------------
//


//  Imports an URL entry without overwriting existing
//cache entries or copying any associated data files.

BOOL IE401IndexFile::Import401Url( ie401::URL_FILEMAP_ENTRY* pEntry)
{
    BOOL retVal = FALSE;

    //  don't import Url if it is already in the buffer
    if( GetUrlCacheEntryInfo( (LPSTR)((BYTE*)pEntry + pEntry->UrlNameOffset), NULL, 0) == TRUE
        || GetLastError() != ERROR_FILE_NOT_FOUND)
    {
        goto doneImport401Url;
    }

    if( pEntry->FileSize != 0)
    {
        INET_ASSERT(0);  // Are you importing URL cache entries with external data?
        goto doneImport401Url;
    }

    if( !CommitUrlCacheEntry(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            NULL,
            *LONGLONG_TO_FILETIME(&pEntry->ExpireTime),
            *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime),
            pEntry->CacheEntryType,
            pEntry->HeaderInfoOffset != NULL ?
                (BYTE*)((BYTE*)pEntry + pEntry->HeaderInfoOffset) : NULL,
            pEntry->HeaderInfoSize,
            pEntry->FileExtensionOffset != 0 ?
                (LPCSTR)((BYTE*)pEntry + pEntry->FileExtensionOffset) : NULL,
            NULL))
        goto doneImport401Url;

    CACHE_ENTRY_INFO cei;

    cei.dwStructSize = sizeof(cei);
    cei.LastAccessTime = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    cei.dwHitRate = pEntry->NumAccessed;
    cei.ExpireTime = *LONGLONG_TO_FILETIME(&pEntry->ExpireTime);
    cei.LastModifiedTime = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    if( !SetUrlCacheEntryInfo(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            &cei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC
            | CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC))
       goto doneImport401Url;

    retVal = TRUE;

doneImport401Url:
    return retVal;
}


//************************************************************************8
//
//  IE401Visited : public IE401IndexFile
//

IE401Visited::IE401Visited( LPCSTR szFilename) : IE401IndexFile( szFilename)
{
}


//  imports only URLs using Import401Url- nothing special
BOOL IE401Visited::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if( !(pEntry->dwHash & HASH_BIT_NOTURL)
        && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_URL)
    {
        Import401UrlTranslatingCEI( (ie401::URL_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset));
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//----------------------------------------
//
//  IE401Visited::Import401UrlTranslatingCEI
//
//  Very much like Import401Url except it makes
//a call to UpgradeHeaderData before calling CommitCacheEntry.

BOOL IE401Visited::Import401UrlTranslatingCEI( ie401::URL_FILEMAP_ENTRY* pEntry)
{
    BOOL retVal = FALSE;

    //  don't import Url if it is already in the buffer
    if( GetUrlCacheEntryInfo( (LPSTR)((BYTE*)pEntry + pEntry->UrlNameOffset), NULL, 0) == TRUE
        || GetLastError() != ERROR_FILE_NOT_FOUND)
    {
        goto doneImport401UrlTranslatingCEI;
    }

    if( pEntry->FileSize != 0)
    {
        INET_ASSERT(0);  // Are you importing URL cache entries with external data?
        goto doneImport401UrlTranslatingCEI;
    }

    DWORD cbHeaderBufSize;
    //BUGBUG:  Does shdocvw still obey MAX_CACHE_ENTRY_INFO_SIZE
    //in the version being imported?
    CHAR szHeaderBuf[ MAX_CACHE_ENTRY_INFO_SIZE];
    cbHeaderBufSize = MAX_CACHE_ENTRY_INFO_SIZE;

    if( pEntry->HeaderInfoOffset != 0)
    {
        if( UpgradeHeaderData(  (CHAR*)((BYTE*)pEntry + pEntry->HeaderInfoOffset),
                                szHeaderBuf, &cbHeaderBufSize) != TRUE)
        {
            goto doneImport401UrlTranslatingCEI;
        }
    }
    else
        cbHeaderBufSize = 0;

    if( !CommitUrlCacheEntry(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            NULL,
            *LONGLONG_TO_FILETIME(&pEntry->ExpireTime),
            *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime),
            pEntry->CacheEntryType,
            cbHeaderBufSize != 0 ?
                (BYTE*)szHeaderBuf : NULL,
            cbHeaderBufSize,
            pEntry->FileExtensionOffset != 0 ?
                ((CHAR*)pEntry + pEntry->FileExtensionOffset) : NULL,
            NULL))
        goto doneImport401UrlTranslatingCEI;

    CACHE_ENTRY_INFO cei;

    cei.dwStructSize = sizeof(cei);
    cei.LastAccessTime = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    cei.dwHitRate = pEntry->NumAccessed;
    cei.ExpireTime = *LONGLONG_TO_FILETIME(&pEntry->ExpireTime);
    cei.LastModifiedTime = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    if( !SetUrlCacheEntryInfo(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            &cei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC
            | CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC))
        goto doneImport401UrlTranslatingCEI;

    retVal = TRUE;

doneImport401UrlTranslatingCEI:
    return retVal;

}


BOOL IE401Visited::UpgradeHeaderData(
            IN      const CHAR* pIn,
            OUT     CHAR* pOut,
            IN OUT  DWORD* pcbOutSize)
{
    BOOL retVal = FALSE;

    OutputStream op( pOut, *pcbOutSize);

    //  The header info struct contains a HISTDATA followed by
    //a list of HISTEXTRAs..  Their sizes can vary but they should
    //be adjacent.  The last HISTEXTRA has a cbExtra of 0 and a sizeof(UINT).
    //  When we import a HISTEXTRA (idExtra = PID_INTSITE_TITLE) then
    //we must convert the attached string from ANSI to Unicode
    HISTEXTRA* pExtra = NULL;

    //first copy the HISTDATA
    if( op.Memcpy( pIn, ((_HISTDATA_V001*)pIn)->cbSize) == FALSE)
        goto doneUpgradeCEIData;

    for(pExtra = (HISTEXTRA*) (pIn + ((_HISTDATA_V001*)pIn)->cbSize);
        pExtra->cbExtra != 0;
        pExtra = (HISTEXTRA*)((BYTE*)pExtra + pExtra->cbExtra))
    {
        if( pExtra->idExtra != PID_INTSITE_TITLE)
        {
            if( op.Memcpy( pExtra, pExtra->cbExtra) == FALSE)
                goto doneUpgradeCEIData;
        }
        else
        {
            HISTEXTRA* pNew = (HISTEXTRA*)((BYTE*)pOut + op.GetFinalLength());

            // copy the HISTEXTRA head
            INET_ASSERT( pExtra->cbExtra >= HISTEXTRA_HEAD_SIZE);
            if( op.Memcpy( pExtra, HISTEXTRA_HEAD_SIZE) == FALSE)
                goto doneUpgradeCEIData;

            if( op.CopyAnsiToUnicode( (CHAR*)&(pExtra->abExtra),
                                      pExtra->cbExtra - HISTEXTRA_HEAD_SIZE)
                == FALSE)
                goto doneUpgradeCEIData;

            pNew->vtExtra = VT_LPWSTR;

            // cbExtra(size) is the change in position of the output stream.
            pNew->cbExtra = ((BYTE*)pOut + op.GetFinalLength()) - (BYTE*)pNew;
        }
    }

    // the final member in the list is just a DWORD, value == 0.
    // determined from assertions in Urlhist.cpp:
    //ASSERT( phext->cbExtra == 0); // terminator
    //ASSERT( (LPBYTE)phdNew+cbHeader == (LPBYTE)phext+SIZEOF(DWORD) );
    if( op.Memcpy( pExtra, sizeof(DWORD)) == FALSE)
        goto doneUpgradeCEIData;

    retVal = TRUE;

doneUpgradeCEIData:

    if( retVal == TRUE)
        *pcbOutSize = op.GetFinalLength();

    return retVal;
}


//************************************************************************8
//
//  IE401History : public IE401IndexFile
//

IE401History::IE401History( LPCSTR szFilename) : IE401IndexFile( szFilename)
{
}


//  imports only URLs using Import401Url then marks them
//as Visited
BOOL IE401History::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if( !(pEntry->dwHash & HASH_BIT_NOTURL)
        && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_URL)
    {
        ie401::URL_FILEMAP_ENTRY* pUrlToImport = (ie401::URL_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset);

        if( Import401Url( pUrlToImport) == TRUE)
            MarkUrlAsVisited( (CHAR*)pUrlToImport + pUrlToImport->UrlNameOffset);
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//  Marks an Url given with a history prefix in the Visited container
BOOL IE401History::MarkUrlAsVisited( LPSTR szUrlName)
{
    BOOL retVal = FALSE;
    LPCACHE_ENTRY_INFO pCei = NULL;
    DWORD cbCei = 0;

    //I'm changing the string from "MSHIST_PREFIX_SZhttp:\\www.urlname"
    //to "VISITED_PREFIX_SZhttp:\\www.urlname" in order to locate/change
    //the cache entry.
    //This requires backing up the old prefix, and setting a new pointer
    //to the correct location to place the new prefix.  Once the modified
    //szUrlName is used the old prefix is always restored.

    // backup the old prefix
    CHAR szBackup[sizeof(MSHIST_PREFIX_SZ)];
    memcpy( szBackup, szUrlName, sizeof(MSHIST_PREFIX_SZ));

    //  Move the pointer to later in the string so that the new, smaller
    //prefix fits, and put the new prefix there.
    LPSTR szModifiedUrl = szUrlName + sizeof(MSHIST_PREFIX_SZ) - sizeof(VISITED_PREFIX_SZ);
    memcpy( szModifiedUrl, VISITED_PREFIX_SZ, sizeof(VISITED_PREFIX_SZ) - 1);

    //  Get the cei
    if( GetUrlCacheEntryInfo( szModifiedUrl, NULL, &cbCei) == TRUE)
        goto doneMarkUrlAsVisited;

    pCei = (CACHE_ENTRY_INFO*)(new BYTE[cbCei]);
    if( pCei == NULL)
        goto doneMarkUrlAsVisited;

    if( GetUrlCacheEntryInfo( szModifiedUrl, pCei, &cbCei) != TRUE)
        goto doneMarkUrlAsVisited;

    if( pCei->dwHeaderInfoSize < sizeof(_HISTDATA_V001))
        goto doneMarkUrlAsVisited;

    //  set the Visited flag
    SET_HISTORY_FLAG(pCei->lpHeaderInfo);

    CHAR* pStrStr;
    if( pCei->lpHeaderInfo != NULL
        && (pStrStr = StrStr( pCei->lpHeaderInfo, CACHE_CONTROL_SZ)) != NULL
        && (pStrStr = StrStr( pStrStr, MUST_REVALIDATE_SZ)) != NULL)
    {
        pCei->CacheEntryType |= MUST_REVALIDATE_CACHE_ENTRY;
    }

    if( CommitUrlCacheEntry( szModifiedUrl, NULL, pCei->ExpireTime,
          pCei->LastModifiedTime, pCei->CacheEntryType, (BYTE*)pCei->lpHeaderInfo,
          pCei->dwHeaderInfoSize, pCei->lpszFileExtension, NULL) != TRUE)
        goto doneMarkUrlAsVisited;

    if( SetUrlCacheEntryInfo(
            szModifiedUrl,
            pCei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC | CACHE_ENTRY_EXPTIME_FC ) != TRUE)
        goto doneMarkUrlAsVisited;

    retVal = TRUE;

doneMarkUrlAsVisited:
    memcpy( szUrlName, szBackup, sizeof(MSHIST_PREFIX_SZ));

    if( pCei != NULL)
        delete [] pCei;

    return retVal;
}


//************************************************************************8
//
//  IE401Content : public IE401IndexFile
//


//  on the creation of a IE401Content object, we
//prepare for the enumeration of its entries by:
// - identifying the subdirectories of the old cache
// - register each subdirectory in the new cache
// - move each subdirectory into the new cache's location
IE401Content::IE401Content( LPCSTR szFilename)
: IE401IndexFile( szFilename)
{
    BOOL fConstructionSuccessful = FALSE;

    //  make sure the index file loaded alright.
    if( m_pBuf == NULL)
        goto exitIE401Construct;

    //  ConfigInfo is retrieved since it contains the path of the new cachefile.
    CACHE_CONFIG_INFO sConfigInfo;
    DWORD dwTemp;
    if( GetUrlCacheConfigInfo( &sConfigInfo,
                               &(dwTemp = sizeof(sConfigInfo)),
                               CACHE_CONFIG_CONTENT_PATHS_FC)
        == FALSE)
    {
        goto exitIE401Construct;
    }

    //  get the target path for subcontainer move
    m_cbRootPathLength = lstrlen( sConfigInfo.CachePath);
    memcpy( m_szRootPath, sConfigInfo.CachePath, m_cbRootPathLength + 1);
    //target path example: m_szRootPath = "c:\winnt\content.ie5"

    //  get the source path for the subcontainers from the given filename
    DWORD cbSourcePathLength;
    CHAR szSourcePath[MAX_PATH];
    cbSourcePathLength = lstrlen( szFilename);
    memcpy( szSourcePath, szFilename, cbSourcePathLength + 1);
    // clip off the filename so that we have just the path.
    while( cbSourcePathLength > 0 && szSourcePath[cbSourcePathLength] != FILENAME_SEPARATOR)
    {
        cbSourcePathLength--;
    }
    szSourcePath[ ++cbSourcePathLength] = '\0';
    //source path example:  szSourcePath = "c:\winnt\content\"

    //  enumerate through the subdirectories,
    //      attempt to register that directory in the new cache
    //      then move the old directory into the new cache.
    //  If the directory cannot be registered or moved, then
    //m_szDir contains "" for that directory index.
    m_nDirs = ((_MEMMAP_HEADER_SMALL*)m_pBuf)->nDirCount;
    DWORD index;
    for( index = 0; index < m_nDirs; index++)
    {
        //  get the name of the old subdirectory from the cache.
        memcpy( m_szDir[index],
                ((_MEMMAP_HEADER_SMALL*)m_pBuf)->DirArray[index].sDirName,
                DIR_NAME_SIZE);
        m_szDir[index][DIR_NAME_SIZE] = '\0';

        if( GlobalUrlContainers->CreateContentDirWithSecureName( m_szDir[index]) != TRUE)
        {
            // signal that the directory couldn't be imported and try the next.
            m_szDir[index][0] = '\0';
            continue;
        }

        //  append the subcontainer names to the appropiate destination and source
        //paths.
        memcpy( m_szRootPath + m_cbRootPathLength, m_szDir[index], DIR_NAME_SIZE + 1);
        memcpy( szSourcePath + cbSourcePathLength, m_szDir[index], DIR_NAME_SIZE + 1);

#ifndef UNIX
        if( MoveFile( szSourcePath, m_szRootPath) == 0)
#else
        if (!hConstructSubDirs(m_szRootPath) ||
            CopyDir(szSourcePath, m_szRootPath))
#endif /* UNIX */
        {

            // signal that the directory couldn't be imported and try the next.
            m_szDir[index][0] = '\0';
            continue;
        }
    }

    szSourcePath[ cbSourcePathLength] = '\0';
    m_szRootPath[ m_cbRootPathLength] = '\0';

#ifndef UNIX
    //  The old index file now is full of dead entries,
    //so we don't keep it around.
    DeleteFile( szFilename);
#endif /* UNIX */

    fConstructionSuccessful = TRUE;

exitIE401Construct:

    if( fConstructionSuccessful != TRUE)
    {
        if( m_pBuf != NULL)
            delete [] m_pBuf;

        m_pBuf = NULL;
    }
}


//  imports only URLs using Import401Url
BOOL IE401Content::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if( !(pEntry->dwHash & HASH_BIT_NOTURL)
        && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_URL)
    {
        Import401UrlWithFile( (ie401::URL_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset));
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//  Extends the default to import files
BOOL IE401Content::Import401UrlWithFile( ie401::URL_FILEMAP_ENTRY* pEntry)
{
    BOOL retVal = FALSE;

    //  don't import Url if it is already in the buffer
    if( GetUrlCacheEntryInfo( (LPSTR)((BYTE*)pEntry + pEntry->UrlNameOffset), NULL, 0) == TRUE
        || GetLastError() != ERROR_FILE_NOT_FOUND)
    {
       goto doneImport401Url;
    }

    //  don't import an URL if its one of those weird registered files.
    if( (pEntry->DirIndex == IE401_NOT_A_CACHE_SUBDIRECTORY)
        || (pEntry->CacheEntryType & IE401_EDITED_CACHE_ENTRY))
    {
        goto doneImport401Url;
    }

    if( pEntry->FileSize != 0)
    {
        //  don't import Url if it's subdirectory didn't get created
        if( m_szDir[pEntry->DirIndex][0] == '\0')
            goto doneImport401Url;

        // store the new file path in m_szRoot
        memcpy( m_szRootPath + m_cbRootPathLength, m_szDir[pEntry->DirIndex], DIR_NAME_SIZE);
        m_szRootPath[ m_cbRootPathLength + DIR_NAME_SIZE] = FILENAME_SEPARATOR;
        m_szRootPath[ m_cbRootPathLength + DIR_NAME_SIZE + 1] = '\0';

        // This may result in truncation of the filename, when the 401 generated filename to
        // particularly long, causing the total path to exceed MAX_PATH.
        // We won't worry abou this.
        StrCatBuff(m_szRootPath,
                   (CHAR*)pEntry + pEntry->InternalFileNameOffset,
                   MAX_PATH);
    }

    if( !CommitUrlCacheEntry(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            (pEntry->FileSize != 0)
              ? m_szRootPath : NULL,
            *LONGLONG_TO_FILETIME(&pEntry->ExpireTime),
            *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime),
            pEntry->CacheEntryType,
            pEntry->HeaderInfoOffset != NULL ?
                (BYTE*)((BYTE*)pEntry + pEntry->HeaderInfoOffset) : NULL,
            pEntry->HeaderInfoSize,
            pEntry->FileExtensionOffset != 0 ?
                (LPCSTR)((BYTE*)pEntry + pEntry->FileExtensionOffset) : NULL,
            NULL))
        goto doneImport401Url;

    CACHE_ENTRY_INFO cei;

    cei.dwStructSize = sizeof(cei);
    cei.LastAccessTime = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    cei.dwHitRate = pEntry->NumAccessed;
    cei.ExpireTime = *LONGLONG_TO_FILETIME(&pEntry->ExpireTime);
    cei.LastModifiedTime = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    if( !SetUrlCacheEntryInfo(
            (LPCSTR)((BYTE*)pEntry + pEntry->UrlNameOffset),
            &cei,
            CACHE_ENTRY_ACCTIME_FC | CACHE_ENTRY_HITRATE_FC
            | CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC))
        goto doneImport401Url;

    retVal = TRUE;

doneImport401Url:

    //  Remove appended data
    m_szRootPath[m_cbRootPathLength] = '\0';

    return retVal;
}



//*************************************************************************
//
//  Import401Redirects()
//

IE401Redirects::IE401Redirects( IE401Content* pContent)
{
    INET_ASSERT( m_pBuf == NULL);

    m_pBuf = pContent->m_pBuf;
    pContent->m_pBuf = NULL;
}


//  import items that are redirects
BOOL IE401Redirects::HandleHashElement( ie401::HASH_ITEM* pEntry)
{
    // No reserved bits should be set.
    INET_ASSERT (!(pEntry->dwHash & HASH_BIT_RESERVED));

    if((pEntry->dwOffset != HASH_END) && ((ie401::FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset))->dwSig == SIG_REDIR)
    {
        Import401Redirect( (ie401::REDIR_FILEMAP_ENTRY*)(m_pBuf + pEntry->dwOffset));
    }

    // after wrapping above in try-catch block, return FALSE on unhandled exception.
    return TRUE;
}


//  Imports entries that are redirects
BOOL IE401Redirects::Import401Redirect( ie401::REDIR_FILEMAP_ENTRY* pEntry)
{
    LPSTR szTargetUrl = NULL;

    //** wrap this one in an exception block, because just one of these guys
    //might just try to reference into space.

    // pEntry is an entry to a redirect entry, which contains an offset to a hash entry.
    // That hash entry contains an offset to the filemap entry of the redirect target.
    FILEMAP_ENTRY* pRedirTarget =
        (FILEMAP_ENTRY*)(m_pBuf + ((HASH_ITEM*)(m_pBuf + pEntry->dwItemOffset))->dwOffset);
    //  The filemap entry of the redirect target could be a URL filmap entry or another
    //redirect filemap entry.  Either way extract the url of that entry as the target url.
    switch( pRedirTarget->dwSig)
    {
    case SIG_REDIR:
        szTargetUrl = ((REDIR_FILEMAP_ENTRY*)pRedirTarget)->szUrl;
        break;
    case SIG_URL:
        szTargetUrl = (CHAR*)pRedirTarget + ((URL_FILEMAP_ENTRY*)pRedirTarget)->UrlNameOffset;
        break;
    default:
        return FALSE;
    }

    return GlobalUrlContainers->CreateContentRedirect( szTargetUrl, pEntry->szUrl);
}


//*************************************************************************
//
//  Import401History()
//


//  Inside IE401_HIST_ROOT{hHistRoot}, there are some keys that list
//the history containers we want to import.  Before we can import those containers,
//we import the Visited: container.  This file will be found in the subdirectory of
//the location of the first history subcontainer.
//  When we reach a new container, we create it but don't worry about collisions.
//Existing Url entries are never overwritten by the import process.

BOOL Import401History()
{
    BOOL retVal = FALSE;

    HKEY hHistRoot = (HKEY) INVALID_HANDLE_VALUE;

    // get key to root of history information (which is the root of all extensible containers)
    if( REGOPENKEYEX( IsPerUserCache() ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE,
                      IE401_HIST_ROOT, 0, KEY_READ, &hHistRoot)
        != ERROR_SUCCESS)
    {
        hHistRoot = (HKEY) INVALID_HANDLE_VALUE;
        goto doneImport401History;
    }

    DWORD index; index = 0;
    CHAR szContainerName[MAX_PATH];
    DWORD cbContainerNameLength;
    DWORD dwCacheLimit;
    DWORD dwCacheOptions;
    CHAR szCachePath[MAX_PATH];
    DWORD cbCachePathSize;
    CHAR szCachePrefix[MAX_PATH];

    //  Enumerate through the extensible containers, if they are History containers import them.
    //  When the first history container is found, its path can be used to locate the Visited:
    //container which also must be imported.
    while( RegEnumKeyEx( hHistRoot, index++, szContainerName, &(cbContainerNameLength = MAX_PATH),
            NULL,NULL,NULL,NULL) == ERROR_SUCCESS)
    {
        static BOOL fFirstRun = TRUE;

        //  we can't be sure all the extended containers are history containers.
        //This check verifies we only import history containers.
        if( StrCmpNI( szContainerName, MSHIST_SZ, sizeof(MSHIST_SZ) - 1) != 0
            || cbContainerNameLength != sizeof(MSHIST_KEY_SZ) - 1)
        {
            continue;
        }

        HKEY hHistContainer = (HKEY) INVALID_HANDLE_VALUE;
        DWORD dwTemp;
        DWORD dwType;

        if( REGOPENKEYEX( hHistRoot, szContainerName, 0, KEY_READ, &hHistContainer) != ERROR_SUCCESS)
            goto doneImportHistContainer;

        if( RegQueryValueEx( hHistContainer, CACHE_LIMIT_SZ, 0, &dwType,
                            (BYTE*)&dwCacheLimit, &(dwTemp = sizeof(dwCacheLimit))) != ERROR_SUCCESS
            || dwType != REG_DWORD)
        {
            goto doneImportHistContainer;
        }

        if( RegQueryValueEx( hHistContainer, CACHE_OPTIONS_SZ, 0, &dwType,
                            (BYTE*)&dwCacheOptions, &(dwTemp = sizeof(dwCacheOptions))) != ERROR_SUCCESS
            || dwType != REG_DWORD)
        {
            goto doneImportHistContainer;
        }

        if( RegQueryValueEx( hHistContainer, CACHE_PATH_SZ, 0, &dwType,
                            (BYTE*)szCachePath, &(cbCachePathSize = sizeof(szCachePath))) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            goto doneImportHistContainer;
        }

        if( RegQueryValueEx( hHistContainer, CACHE_PREFIX_SZ, 0, &dwType,
                            (BYTE*)&szCachePrefix, &(dwTemp = sizeof(szCachePrefix))) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            goto doneImportHistContainer;
        }

        //  After finding the first container, import the Visited: container.
        if( fFirstRun == TRUE)
        {
            //  Clip off the path of the history container, and substitute 'index.dat'
            //to identify the Visited container.  Import the visited container, and
            //restore the path to the history container.
            CHAR szBuf[sizeof(MSHIST_DIR_SZ)];
            LPSTR szMSHIST = szCachePath + cbCachePathSize - sizeof(MSHIST_DIR_SZ);
            // ex result: szCachePath:"c:\path\MSHIST011998020119980225\", szMSHIST:"MSHIST011998020119980225\"

            memcpy( szBuf, szMSHIST, sizeof(MSHIST_DIR_SZ));
            // szBuf:"MSHIST011998020119980225\"
            memcpy( szMSHIST, "index.dat", sizeof("index.dat"));
            //  szMSHIST:"index.dat"  --> szCachePath:"c:\path\index.dat"
            IE401Visited Visited(szCachePath);
            Visited.EnumHashValues();
            memcpy( szMSHIST, szBuf, sizeof(MSHIST_DIR_SZ));
            // szMSHIST:"MSHIST011998020119980225\"  --> szCachePath:"c:\path\MSHIST011998020119980225\"

            fFirstRun = FALSE;
        }

        //  we don't pass the old path so that the container is put in the new one.
        if( CreateUrlCacheContainer( szContainerName, szCachePrefix, NULL,
                                 dwCacheLimit, 0, dwCacheOptions, NULL, NULL) != TRUE
            && GetLastError() != ERROR_ALREADY_EXISTS)
        {
            goto doneImportHistContainer;
        }

        if( cbCachePathSize + (sizeof(INDEX_DAT_SZ) - 1) > MAX_PATH)
            goto doneImportHistContainer;

        memcpy( szCachePath + cbCachePathSize - 1, INDEX_DAT_SZ, sizeof(INDEX_DAT_SZ));

        {
            IE401History History( szCachePath);

            History.EnumHashValues();
        }

    doneImportHistContainer:

        if( hHistContainer != (HKEY) INVALID_HANDLE_VALUE)
            REGCLOSEKEY( hHistContainer);
    }

    retVal = TRUE;

doneImport401History:

    if( hHistRoot != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hHistRoot);

    return retVal;
}


//*************************************************************************
//
//  Import401Content()
//


BOOL Import401Content()
{
    BOOL retVal = FALSE;
    HKEY hContentKey = (HKEY) INVALID_HANDLE_VALUE;
    CHAR szContentFilename[MAX_PATH];
    LPSTR szKeyName = NULL;

    if( !GetIE5ContentPath(szContentFilename))
        goto doneImport401Content;

    //  we now have something like 'c:\..\content\content.ie5'
    //and we want something like 'c:\..\content\index.dat'
    LONG index;

    //  find the position of the last '\\'
    index = lstrlen( szContentFilename);
    while( index >= 0 && szContentFilename[index] != FILENAME_SEPARATOR)
        index--;

    // append an 'index.dat'
    memcpy( szContentFilename + index + 1, INDEX_DAT_SZ, sizeof(INDEX_DAT_SZ));

#ifdef UNIX
    {
       // HACK HACK
       //
       // we now have something like
       //        '/home/blah/.microsoft/ie5/TempInternetFiles/index.dat'
       // and we want something like
       //        /home/blah/.microsoft/TempInternetFiles/index.dat
       char szSearchStr[] = "ie5/";
       char *pszWhere = StrStr(szContentFilename, szSearchStr);
       if (pszWhere)
       {
          memmove(pszWhere, pszWhere+sizeof(szSearchStr)-1,
                  lstrlen(pszWhere+sizeof(szSearchStr)-1)+1);
       }
    }
#endif /* UNIX */

    {
        IE401Content Content(szContentFilename);
        if( Content.EnumHashValues() == TRUE)
        {
            IE401Redirects Redirects( &Content);
            Redirects.EnumHashValues();
        }
    }

doneImport401Content:

    if( hContentKey != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hContentKey);

    return retVal;
}


//-- end of namespace ie401
}
//--


//
//
//  Returns if caches are per user.
//
BOOL IsPerUserCache()
{
    BOOL fProfilesEnabled = FALSE;
    static BOOL fPerUser = FALSE;
#ifndef UNIX
    // Is the OS version Windows 95 or Windows NT?
    if (GlobalPlatformType == PLATFORM_TYPE_WIN95)
    {
        // Operating System is Windows 95.
        //  Look for special key indicating profiles are enables.  If its not found,
        //know that profiles aren't enabled.

        // Determine if profiles are enabled by OS.
        REGISTRY_OBJ roProfilesEnabled(HKEY_LOCAL_MACHINE, PROFILES_ENABLED_VALUE);
        if (roProfilesEnabled.GetStatus() == ERROR_SUCCESS)
        {
            DWORD dwProfilesEnabled = 0;

            if( roProfilesEnabled.GetValue(PROFILES_ENABLED, &dwProfilesEnabled) == ERROR_SUCCESS)
            {
                // Found the registry entry.
                fProfilesEnabled = (BOOL) dwProfilesEnabled;
            }
        }

    }
    else if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
    {
        // Profiles always enabled for NT.
        fProfilesEnabled = TRUE;
    }
#else
    fProfilesEnabled = TRUE;
#endif /* UNIX */

    // Determine if per user cache is allowed.
    REGISTRY_OBJ roProfilesAllowed(HKEY_LOCAL_MACHINE, PRE5_CACHE_KEY);
    if( fProfilesEnabled && roProfilesAllowed.GetStatus() == ERROR_SUCCESS)
    {
        DWORD dwPerUserCache = 0;

        if( roProfilesAllowed.GetValue(PROFILES_ENABLED,&dwPerUserCache) == ERROR_SUCCESS)
        {
            // Found the registry entry. Set g_fPerUserCache to
            // TRUE only if profiles are enabled.
            fPerUser = ((BOOL) dwPerUserCache);
        }
        else
        {
            // No entry. If profiles are enabled, assume they're allowed.
            fPerUser = fProfilesEnabled;
        }
    }
    else
    {
        fPerUser = fProfilesEnabled;
    }

    return fPerUser;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\perf\inetdown\inetdown.c ===
#include "inetdown.h"

//----------------------------------------------------------------------------
// Globals
//----------------------------------------------------------------------------
//#define TEST 1

HINTERNET hInternet;
HANDLE hDownloadThread;
HANDLE hMaxDownloadSem;
DWORD  dwThreadID;
LPSTR ppAccept[] = {"*/*",NULL};
DWORD dwBegin_Time = 0;
DWORD dwEnd_Time;
DWORD dwTot_Time;
DWORD dwNum_Opens = 1;
DWORD dwBuf_Size = BUF_SIZE;
DWORD dwBytes_Read = 0;
DWORD dwMax_Simul_Downloads = URLMAX;
DWORD dwInternet_Open_Flags = INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_EXISTING_CONNECT;
DWORD dwInternet_Connect_Flags = 0;
BOOL bDelim = FALSE;
BOOL g_bSingleThreaded = FALSE;
DWORD g_dwMainThreadID = 0;
DWORD g_iDownloads = 0;
char *pFilename = NULL;
char *pInFile = NULL;
char *g_pRunStr = NULL;
char *g_pTestName = NULL;
char g_CmdLine[1024];
BOOL g_bTimeFirstFile = TRUE;
url_info_cache g_pUrlInfoCache;
HANDLE g_hHeap;


#ifdef DBG
#define dprintf(args) _dprintf args
INT _dprintf(TCHAR *fmt, ... ) 
{
    INT      ret;
    va_list  marker;
    TCHAR     szBuffer[256];
    if(TRUE) {
        va_start(marker, fmt);
        ret = vsprintf(szBuffer, fmt, marker);
        OutputDebugString(szBuffer);
        printf(szBuffer);
    }
    return ret; 
}

#else

#define dprintf(args)

#endif



//----------------------------------------------------------------------------
//Procedure:   generateInfo
//Purpose:     init globals
//Arguments:   none
//RetVal:      void
//----------------------------------------------------------------------------

void generateInfo() 
{
    g_iDownloads = 0;
    g_dwMainThreadID = GetCurrentThreadId();

    return;
}




//----------------------------------------------------------------------------
// Procedure:  getCachedUrlInfo
// Purpose:    Finds existing url_info struct from the cache if it exists
// Arguments:  szUrl
// RetVal:     url_info* or NULL based on whether it's there
//----------------------------------------------------------------------------

url_info *getCachedUrlInfo(TCHAR *szUrl)
{
    url_info *temp = g_pUrlInfoCache.pHead;

    while(temp && (0 != lstrcmp(temp->pURLName,szUrl)))
    {
        temp = temp->pNext;
    }
	
    return temp;
}

//----------------------------------------------------------------------------
// Procedure:  getUrlInfo
// Purpose:    Sets pUrlInfo member of the outQ struct 
// Arguments:  outQ, szUrl
// RetVal:     TRUE or FALSE based on error
//----------------------------------------------------------------------------

BOOL getUrlInfo(outQ *pOutQ, TCHAR *szUrl) 
{
    URL_COMPONENTS urlc;
    BOOL fRet = FALSE;

    if(pOutQ->pURLInfo = getCachedUrlInfo(szUrl))
    {
        //Use existing url_info from cache
        return TRUE;
    }

    pOutQ->pURLInfo = HeapAlloc(g_hHeap,0,sizeof(url_info));
	
    if(!pOutQ->pURLInfo)
        return FALSE;

    pOutQ->pURLInfo->pURLName = HeapAlloc(g_hHeap,0,(1+lstrlen(szUrl))*sizeof(TCHAR));

    if(!pOutQ->pURLInfo->pURLName)
    {
        HeapFree(g_hHeap,0,pOutQ->pURLInfo);
        return FALSE;
    }

    lstrcpy(pOutQ->pURLInfo->pURLName,szUrl);

    //Add to head of url_info cache
    pOutQ->pURLInfo->pNext = g_pUrlInfoCache.pHead;
    g_pUrlInfoCache.pHead = pOutQ->pURLInfo;

    urlc.dwStructSize = sizeof(URL_COMPONENTS);
    urlc.lpszScheme=pOutQ->pURLInfo->szRScheme;
    urlc.dwSchemeLength=  MAX_SCHEME_LENGTH;
    urlc.nScheme = INTERNET_SCHEME_UNKNOWN;
    urlc.lpszHostName=pOutQ->pURLInfo->szRHost;
    urlc.dwHostNameLength=INTERNET_MAX_HOST_NAME_LENGTH;
    
    urlc.lpszUserName=NULL;
    urlc.dwUserNameLength=0;
    urlc.lpszPassword=NULL;
    urlc.dwPasswordLength=0;
    urlc.lpszExtraInfo = NULL;
    urlc.dwExtraInfoLength = 0;
    
    urlc.lpszUrlPath=pOutQ->pURLInfo->szRPath;
    urlc.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    urlc.nPort = 0;
    if (InternetCrackUrl(pOutQ->pURLInfo->pURLName,0,0,&urlc)) 
    {
        fRet = TRUE;
        pOutQ->pURLInfo->nScheme = urlc.nScheme;
        pOutQ->pURLInfo->nPort = urlc.nPort;
        // For now, we will only support HTTP
        if((pOutQ->pURLInfo->nScheme != INTERNET_SERVICE_HTTP) && (pOutQ->pURLInfo->nScheme != INTERNET_SCHEME_HTTPS))
        fRet = FALSE;
    }
    return fRet;
}


//----------------------------------------------------------------------------
// Procedure:  fillOutQ
// Purpose:    fills the OutQ will URLs to be downloaded
// Arguments:  OutQ to be filled
// RetVal:     the start of the Queue or NULL on error
//----------------------------------------------------------------------------

outQ* fillOutQ(outQ *pOutQ, TCHAR *URLName) 
{
    outQ *pStartOutQ;

    pStartOutQ = pOutQ;

    if(pOutQ) {
        //go to first free outQ as opposed to adding to front (not concerned w/time)
        while(pOutQ->pNext != NULL) 
        {
            pOutQ = pOutQ->pNext;
        }
        pOutQ->pNext = HeapAlloc(g_hHeap,0, sizeof(outQ));
        
        if (!pOutQ->pNext) 
        {
            dprintf(("HeapAlloc Failed!\n"));
            return NULL;
        }
        pOutQ = pOutQ->pNext;
        pOutQ->pNext = NULL;
    }
    else 
    {
        pStartOutQ = pOutQ = HeapAlloc(g_hHeap,0, sizeof(outQ));
     
        if (!pOutQ) 
        {
            dprintf(("HeapAlloc Failed!\n"));
            return NULL;   
        }
        pOutQ->pNext = NULL;
    }
    
    //keep track of the number of downloads
    g_iDownloads++;

    if(!getUrlInfo(pOutQ,URLName)) 
    {
        dprintf(("getUrlInfo failed!\n"));
        return NULL;
    }

    return pStartOutQ;
}

//----------------------------------------------------------------------------
// Procedure:  freeOutQMem
// Purpose:    frees the memory held in the given outQ
// Arguments:  outQ to be freed
// RetVal:     none
//----------------------------------------------------------------------------

void freeOutQMem(outQ *pOutQ) 
{
    outQ *pLastOutQ;

    while(pOutQ) 
    {                
        pLastOutQ = pOutQ;
        pOutQ = pOutQ->pNext;
        HeapFree(g_hHeap,0,pLastOutQ);
    }
    return;
}

//----------------------------------------------------------------------------
// Procedure:  callOpenRequest
// Purpose:    calls HttpOpenRequest
// Arguments:  outQ
// RetVal:     none
//----------------------------------------------------------------------------

void callOpenRequest(outQ *pOutQ) 
{
    INT iError = 0;
    DWORD dwAdded_Connect_Flags = 0;

    if(lstrcmpi(pOutQ->pURLInfo->szRScheme, "https") == 0)
    {
        dwAdded_Connect_Flags = INTERNET_FLAG_SECURE;
    }

    if(pOutQ->hInetReq = HttpOpenRequest(
          pOutQ->hInetCon,                //connection
          NULL,                           //verb
          pOutQ->pURLInfo->szRPath,                 //object
          NULL,                           //version
          NULL,                           //referrer
          ppAccept,                       //accept headers
          dwInternet_Open_Flags | dwAdded_Connect_Flags, //flags
          (DWORD) pOutQ))                 //context
    {
        //it was synchronous (usual)
        dprintf(("callOpenRequest: Sync TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_STARTING));
        pOutQ->iStatus = LDG_STARTING;
        callSendRequest(pOutQ);
        return;
    }
    else
    {
        if((iError = GetLastError()) != ERROR_IO_PENDING){
            dprintf((" Error on HttpOpenRequest[%d]\n", iError));

            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                } 
            }
            return;     
        }
        
        dprintf(("callOpenRequest: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, REQUEST_OPENED));
        pOutQ->iStatus = REQUEST_OPENED;
        return;
    }
}

//----------------------------------------------------------------------------
// Procedure:  callSendRequest
// Purpose:    calls HttpSendRequest
// Arguments:  outQ
// RetVal:     none
//----------------------------------------------------------------------------

void callSendRequest(outQ *pOutQ) 
{
    INT iError = 0;
    
    if(HttpSendRequest(pOutQ->hInetReq, NULL, 0, NULL, 0))
    {
        //it was synchronous
        dprintf(("callSendRequest: Sync TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_START));
        pOutQ->iStatus = LDG_START;
        callReadFile(pOutQ);
        return;
    }
    else 
    {
        if((iError = GetLastError()) != ERROR_IO_PENDING)
        {
            dprintf((" Error on HttpSendRequest[%d]\n", iError));
            
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                } 
            }
            return;     
        }
        //it was async (usual)
        dprintf(("callSendRequest: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_START));
        pOutQ->iStatus = LDG_START;
        return;
    }
}

//----------------------------------------------------------------------------
// Procedure:  callReadFile
// Purpose:    calls InternetReadFile
// Arguments:  outQ
// RetVal:     none
//----------------------------------------------------------------------------

void callReadFile(outQ *pOutQ) 
{
#ifndef TEST
    INT iError;
    INTERNET_BUFFERS IB;
    BOOL bRC;

    static TCHAR buf[BUF_SIZE];

    switch (pOutQ->iStatus) 
    {
	    case LDG_START:
	        dprintf(("callReadFile: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_LDG));
	        pOutQ->iStatus = LDG_LDG;
	        break;

	    case LDG_RDY:
	        if(pOutQ->lNumRead == 0) 
	        {
	            // should wait for 0 bytes read so data will cache.
	            dprintf(("callReadFile: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_DONE));
	            pOutQ->iStatus = LDG_DONE;

	            dprintf(("%s downloaded\n", pOutQ->pURLInfo->pURLName));

	            g_iDownloads--;
				//post msg if last download for exit
	            if(g_iDownloads == 0) 
	            {
	                 dwEnd_Time = GetTickCount();

	                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0))
	                {
	                    iError = GetLastError();
	                    dprintf(("error on PostThreadMessage[%d]\n", iError));
	                    return;
	                } 
	            }

	            InternetCloseHandle(pOutQ->hInetReq);
	            InternetCloseHandle(pOutQ->hInetCon);
	         
	            if(!ReleaseSemaphore(hMaxDownloadSem,1,NULL)) 
	            {
	                dprintf((" ReleaseSemaphore failed!\n"));
	                return;   
	            }
	            
	            return;   
	        }
	        
	        dprintf((" '%s':Rd = %d\n", pOutQ->pURLInfo->pURLName, pOutQ->lNumRead));
            dwBytes_Read += pOutQ->lNumRead;
            break;
    }
    
    //Should insert timing test here
    if(dwBegin_Time == 0)
    {
        if(!g_bTimeFirstFile)
            g_bTimeFirstFile = TRUE;
        else
            dwBegin_Time = GetTickCount();
    }

    IB.dwStructSize = sizeof (INTERNET_BUFFERS);
    IB.Next = 0;
    IB.lpcszHeader = 0;
    IB.dwHeadersLength = 0;
    IB.dwHeadersTotal = 0;
    IB.lpvBuffer = buf;
    IB.dwBufferLength = dwBuf_Size;
    IB.dwBufferTotal = 0;
    IB.dwOffsetLow = 0;
    IB.dwOffsetHigh = 0;
    
    bRC = InternetReadFileEx(pOutQ->hInetReq, &IB, IRF_NO_WAIT, 0);
    pOutQ->lNumRead = IB.dwBufferLength;
    
    if(bRC)
    {

        //it was synchronous
        dprintf(("callReadFile: Sync TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        pOutQ->iStatus = LDG_RDY;
        callReadFile(pOutQ); 
        return;
    }
    else 
    {
	    dprintf(("callReadFile: TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        if(GetLastError() != ERROR_IO_PENDING)
        {
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                    return;
                } 
            }
            dprintf(("Error on InternetRead"));
            return;     
        }

        if((pOutQ->lNumRead == 0) && (pOutQ->iStatus == LDG_LDG))   //vmr
            pOutQ->iStatus = LDG_RDY;
    }

#else	// ifndef TEST =======================================================================

    INT iError;
    INTERNET_BUFFERS IB;
	BOOL bRC;
	BYTE Buf[8192];

	pOutQ->pBuf = Buf;
	
    //Should insert timing test here
    if(dwBegin_Time == 0)
    {
        if(!g_bTimeFirstFile)
            g_bTimeFirstFile = TRUE;
        else
            dwBegin_Time = GetTickCount();
    }

    IB.dwStructSize = sizeof (INTERNET_BUFFERS);
    IB.Next = 0;
    IB.lpcszHeader = 0;
    IB.dwHeadersLength = 0;
    IB.dwHeadersTotal = 0;
    IB.lpvBuffer = &Buf;
    IB.dwBufferLength = dwBuf_Size;
    IB.dwBufferTotal = 0;
    IB.dwOffsetLow = 0;
    IB.dwOffsetHigh = 0;
    
    bRC = InternetReadFileEx(pOutQ->hInetReq, &IB, IRF_NO_WAIT, 0);
    pOutQ->lNumRead = IB.dwBufferLength;
    
    if(bRC)
    {
        //it was synchronous
        dprintf(("callReadFile: Sync TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        pOutQ->iStatus = LDG_RDY;
        
        if(pOutQ->lNumRead == 0) 
        {
            pOutQ->iStatus = LDG_DONE;

            dprintf(("%s downloaded\n", pOutQ->pURLInfo->pURLName));

            InternetCloseHandle(pOutQ->hInetReq);
            InternetCloseHandle(pOutQ->hInetCon);
            
            //post msg if last download for exit
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                 dwEnd_Time = GetTickCount();

                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0))
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                    return;
                } 
            }
     
            if(!ReleaseSemaphore(hMaxDownloadSem,1,NULL)) 
            {
                dprintf((" ReleaseSemaphore failed!\n"));
                return;   
            }
        }
	    else
	    {
	        dprintf((" '%s':Rd = %d\n", pOutQ->pURLInfo->pURLName, pOutQ->lNumRead));
            dwBytes_Read += pOutQ->lNumRead;
            callReadFile(pOutQ); 
        }
    }
    else 
    {
	    dprintf(("callReadFile: TID=%x pOutQ=%x Read=%d iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->lNumRead, pOutQ->iStatus, LDG_RDY));
        if(GetLastError() != ERROR_IO_PENDING)
        {
            g_iDownloads--;
            if(g_iDownloads == 0) 
            {
                if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_DONE, (WPARAM) pOutQ, 0)) 
                {
                    iError = GetLastError();
                    dprintf(("error on PostThreadMessage[%d]\n", iError));
                    return;
                } 
            }
            dprintf(("Error on InternetRead"));
            return;     
        }

        if((pOutQ->lNumRead == 0) && (pOutQ->iStatus == LDG_LDG))   //vmr
            pOutQ->iStatus = LDG_RDY;
    }

    return;
#endif	// ifndef TEST

}


//----------------------------------------------------------------------------
// Procedure:  inetCallBackFn
// Purpose:    callback function used for all the async wininet calls
//             simply makes calls to do the actual processing of this callback.
// Arguments:  hInet             HINTERNET for the callback
//             dwContext         the outQ
//             dwInternewStatus  Status of the callback
//             lpStatusInfo      Holds connection handle
//             dwStatusInfoLen   Not used
//----------------------------------------------------------------------------

VOID CALLBACK inetCallBackFn(HINTERNET hInet,
                    DWORD dwContext, 
                    DWORD dwInternetStatus,
                    LPVOID lpStatusInfo,
                    DWORD dwStatusInfoLen) {
    INT iError;
    outQ *pOutQ = (outQ *)(dwContext);
    
    //First check outQ's state
    //Should post messages to other thread to do calls

    switch(pOutQ->iStatus) 
    {
	    case CONNECTED:
	        //should not be called in normal async behavior
	        if(!pOutQ->hInetCon) 
	        {
	            pOutQ->hInetCon = *((HINTERNET *)(lpStatusInfo));
	        }
	        dprintf(("inetCallBackFn: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, REQUEST_OPENING));
	        pOutQ->iStatus = REQUEST_OPENING;
	        if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_OPEN_REQUEST, (WPARAM) pOutQ, 0)) 
	        {
	            iError = GetLastError();
	            dprintf(("error on PostThreadMessage[%d]\n", iError));
	            return;
	        }
	        break;
	    case REQUEST_OPENED:
	        //should not be called in normal async behavior
	        if(!pOutQ->hInetReq) 
	        {
	            pOutQ->hInetReq = *((HINTERNET *)(lpStatusInfo));
	        }
	        dprintf(("inetCallBackFn: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_STARTING));
	        pOutQ->iStatus = LDG_STARTING;
	        if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_SEND_REQUEST, (WPARAM) pOutQ, 0))
	        {
	            iError = GetLastError();
	            dprintf(("error on PostThreadMessage[%d]\n", iError));
	            return;
	        }
	        break;

	    case LDG_LDG:
	///        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE)
	        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE && 
	            pOutQ->lNumRead != 0)
	        {
	            dprintf(("inetCallBackFn: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, LDG_RDY));
	            pOutQ->iStatus = LDG_RDY;
	        }
	        else
	            return;

	    case LDG_START:
	    case LDG_RDY:
	///        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE ||
	///           dwInternetStatus == INTERNET_STATUS_REQUEST_SENT)      // vmr
	        if(dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE)
	        {
	            if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_READ_FILE, (WPARAM) pOutQ, 0)) 
	            {
	                iError = GetLastError();
	                dprintf(("error on PostThreadMessage[%d]\n", iError));
	                return;
	            }   
	        }
	        break;
	    case CONNECTING:
	    case REQUEST_OPENING:
	    case LDG_STARTING:
	    case LDG_DONE:
	        return;
	    default:
	        dprintf(("Bad iStatus=%d\n", pOutQ->iStatus));
	        return;
    }
    
    return;
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL DoInit(void)
{
    hMaxDownloadSem = CreateSemaphore(NULL,dwMax_Simul_Downloads,dwMax_Simul_Downloads, NULL);
    if(!hMaxDownloadSem) {
        dprintf((" *** CreateSem failed!\n"));
        return FALSE;
    }

    hInternet = InternetOpen( 
        NULL,                       //referrer
        PRE_CONFIG_INTERNET_ACCESS, //access type
        NULL,                       //proxy
        0,                          //proxy bypass
#ifndef TEST        
        INTERNET_FLAG_ASYNC);       //flags
#else        
        0);
#endif        

    if(!hInternet) 
    {
        dprintf(("  *** InternetOpen failed!\n"));
        return FALSE;
    }

#ifndef TEST        
    if(InternetSetStatusCallback(hInternet, inetCallBackFn) < 0) 
    {
        dprintf(("  setCallback Failed!\n"));
        return FALSE;
    }
#endif

    return TRUE;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL DoConnect(outQ *pOutQ)
{
    INT iError;
    DWORD dwAdded_Connect_Flags = 0;

    if(lstrcmpi(pOutQ->pURLInfo->szRScheme, "https") == 0)
    {
        dwAdded_Connect_Flags = INTERNET_FLAG_SECURE;
    }
        
    pOutQ->hInetCon = InternetConnect(hInternet, //handle from internetOpen
        pOutQ->pURLInfo->szRHost,                 //name of the server
        pOutQ->pURLInfo->nPort,                   //name of the port
        NULL,                         //username 
        NULL,                         //password
        pOutQ->pURLInfo->nScheme,                //service
        dwInternet_Connect_Flags | dwAdded_Connect_Flags,           //service specific flags
        (DWORD) (pOutQ));               //context

    if(pOutQ->hInetCon) 
    {
        //it was synchronous (usually)
        dprintf(("DoConnect: Sync connect TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, REQUEST_OPENING));
        pOutQ->iStatus = REQUEST_OPENING;  
        if(!PostThreadMessage(g_dwMainThreadID, DOWNLOAD_OPEN_REQUEST, (WPARAM) pOutQ, 0)) 
        {
            iError = GetLastError();
            dprintf(("error on PostThreadMessage[%d]\n", iError));
            return FALSE;
        }
    }
    else 
    {
        if(GetLastError() != ERROR_IO_PENDING)
        {
            dprintf(("  InternetConnect error\n"));
            return FALSE;
        }
        dprintf(("DoConnect: Async connect TID=%x pOutQ=%x iStatus=%ld  ->%ld->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, CONNECTED));
        pOutQ->iStatus = CONNECTED;
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//  Procedure:   DownloadThread
//  Purpose:     Opens internet connection and downloads URL.  Saves
//               URL to pOutQ (one chunk at a time).
//  Arguments:   outQ
//  Return Val:  TRUE or FALSE based on error
//----------------------------------------------------------------------------

DWORD DownloadThread(LPDWORD lpdwParam) 
{
    outQ *pOutQ = (outQ *) lpdwParam;
    BOOL bRC = TRUE;

    if(bRC = DoInit())    // create throttle semaphore, do InternetOpen & InternetSetStatusCallback
    {
        while(pOutQ) 
        {
            //Only allow MAXURL downloads at one time
            if(WaitForSingleObject(hMaxDownloadSem, TIMEOUT) == WAIT_TIMEOUT) 
            {
                dprintf(("timeout on Sem\n"));
                printf("Error: timeout on throttle semaphore\n");
            }

            pOutQ->iStatus = CONNECTING;
            pOutQ->iPriority = LOW;

            dprintf(("DownloadThread: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pOutQ, pOutQ->iStatus, CONNECTING));
            
            if(!(bRC = DoConnect(pOutQ)))
                break;
                
            pOutQ = pOutQ->pNext;
        }
    }
    
    return((DWORD)bRC);
}

//==================================================================
void Display_Usage(char **argv)
{
    printf("\nUsage: %s -fURLname [options]\n", argv[0]);
    printf("\n          -iInputFileName [options]\n");
    printf("\n\t options:\n");
    printf("\t\t -c    - cache reads (flags ^= INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE)\n");
    printf("\t\t -c1   - force reload and cache reads (flags ^= INTERNET_FLAG_DONT_CACHE)\n");
    printf("\t\t         (flags default = INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_EXISTING_CONNECT\n");
    printf("\t\t -k    - keep alive (flags |= INTERNET_FLAG_KEEP_CONNECTION)\n");
    printf("\t\t -l    - read buffer length\n");
    printf("\t\t -m    - maximum number of simultaneous downloads\n");
    printf("\t\t -n##  - number of times to download\n");
    printf("\t\t -o    - set INTERNET_FLAG_NO_COOKIES\n");
    printf("\t\t -x    - don't time first download\n");
    printf("\t\t -s    - run test in single threaded mode\n");
    printf("\t\t -z    - comma delimited format\n");
    printf("\t\t -tStr - test name string (used on results output with -z)\n");
    printf("\t\t -rStr - run# string (used on results output with -z)\n");
}

//==================================================================
BOOL Process_Command_Line(int argcIn, char **argvIn)
{
    BOOL bRC = TRUE;
    int argc = argcIn;
    char **argv = argvIn;
    DWORD dwLen = 0;

    *g_CmdLine = '\0';

    argv++; argc--;
    while( argc > 0 && argv[0][0] == '-' )  
    {
        switch (argv[0][1]) 
        {
            case 'c':
                if(argv[0][2] == '1')
                    dwInternet_Open_Flags ^= INTERNET_FLAG_DONT_CACHE;  // force reload & cache file
                else
                    dwInternet_Open_Flags ^= INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE;  // cache file
                break;
            case 'k':
                dwInternet_Open_Flags |= INTERNET_FLAG_KEEP_CONNECTION;
                break;
            case 'f':
                pFilename = &argv[0][2];
                break;
            case 'i':
                pInFile = &argv[0][2];
                break;
            case 'n':
                dwNum_Opens = atoi(&argv[0][2]);
                break;
            case 'l':
                dwBuf_Size =  atoi(&argv[0][2]);
                break;
            case 'm':
                dwMax_Simul_Downloads = atoi(&argv[0][2]);
                break;
            case 'o':
                dwInternet_Open_Flags |= INTERNET_FLAG_NO_COOKIES;
                break;
            case 'r':
                g_pRunStr = &argv[0][2];
                break;
            case 's':
                g_bSingleThreaded = TRUE;
                break;
            case 't':
                g_pTestName = &argv[0][2];
                break;
            case 'x':
                g_bTimeFirstFile = FALSE;
                break;
            case 'z':
                bDelim = TRUE;
                break;
            default:
                Display_Usage(argvIn);
                bRC = FALSE;
        }

        if(bRC)
        {
            dwLen += lstrlen(argv[0]) + 1;   // length of arg and space
            if(dwLen < ((sizeof(g_CmdLine)/sizeof(g_CmdLine[0]))-1))
            {
                lstrcat(g_CmdLine, ",");
                lstrcat(g_CmdLine, argv[0]);
            }
        }

        argv++; argc--;
    }

    if(!pFilename && !pInFile)
    {
        Display_Usage(argvIn);
        bRC = FALSE;
    }

    return(bRC);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
outQ *FillURLQueue(void)
{
    outQ *pOutQ = NULL;
    DWORD dwCnt = 0;
    char szName[INTERNET_MAX_URL_LENGTH+1];
    
    if(pFilename)
    {
        while(dwCnt++ < dwNum_Opens) 
        {
            if((dwInternet_Open_Flags & (INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE)) == (INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE))   // Not Cached
                lstrcpy(szName, pFilename);
            else
                wsprintf(szName, "%s.%d", pFilename, dwCnt);

            pOutQ = fillOutQ(pOutQ, szName);
    
            if(!pOutQ)
            {
                dprintf(("error filling outQ!\n"));
                return NULL;
            }
        }
    }
    else if(pInFile)    // Process input file
    {
        FILE *fp;

        while(dwCnt++ < dwNum_Opens) 
        {
            if((fp = fopen(pInFile, "r")) == NULL) 
            {
                dprintf(("error opening file\n"));
                return NULL;
            }

            while(fgets(szName, INTERNET_MAX_URL_LENGTH, fp) != NULL) 
            {
                if(szName[0] != '#') 
                {
                    szName[strlen(szName) - sizeof(char)] = '\0';
    
                    pOutQ = fillOutQ(pOutQ, szName);
    
                    if(!pOutQ)
                    {
                        dprintf(("error filling outQ!\n"));
                        return NULL;
                    }
                }
            }

            fclose(fp);
        }
    }
    return(pOutQ);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL ProcessMessage(MSG msg, outQ *pOutQ, outQ *pMsgOutQ)
{
    float fKB;
    float fSec;
    float fKBSec;
    
    switch(msg.message) 
    {
        case DOWNLOAD_DONE:
            dwTot_Time = dwEnd_Time - dwBegin_Time;
            if(dwTot_Time == 0)
                dwTot_Time = 1;
            fKB = ((float)dwBytes_Read)/1024;
            fSec = ((float)dwTot_Time)/1000;
            fKBSec = fKB / fSec;
            if(!bDelim)
            {
                dprintf(("TID=%X, %ld bytes in %ld real milliseconds = %2.0f KB/sec\r\n", GetCurrentThreadId(), dwBytes_Read, dwTot_Time, fKBSec));
                printf("\r\nDownloaded: %s\r\n", pOutQ->pURLInfo->pURLName);
                printf("%ld Reads, %ld Downloads, %ld Byte Read Buffer, %s, %s\r\n",
                    dwNum_Opens, dwMax_Simul_Downloads, dwBuf_Size, (dwInternet_Open_Flags & INTERNET_FLAG_DONT_CACHE) ?"Not Cached" :"Cached", (dwInternet_Open_Flags & INTERNET_FLAG_KEEP_CONNECTION) ?"KeepAlive" : "!KeepAlive");
                printf("Read %ld Bytes in %ld Milliseconds = %2.0f KB/Sec\r\n", dwBytes_Read, dwTot_Time, fKBSec);
            }
            else
            {
                printf("%s, %s, %ld, %ld, %2.0f %s\r\n",
                    g_pTestName ?g_pTestName :"wininet",
                    g_pRunStr ?g_pRunStr :"1",
                    dwTot_Time, 
                    dwBytes_Read, 
                    fKBSec,
                    g_CmdLine
                    );
            }

            InternetCloseHandle(hInternet);
            CloseHandle(hDownloadThread);
            freeOutQMem(pOutQ);
            return TRUE;
        case DOWNLOAD_OPEN_REQUEST:
            dprintf(("main: DOWNLOAD_OPEN_REQUEST msg\n"));
            callOpenRequest(pMsgOutQ);
            break;
        case DOWNLOAD_SEND_REQUEST:
            dprintf(("main: DOWNLOAD_SEND_REQUEST msg\n"));
            callSendRequest(pMsgOutQ);
            break;
        case DOWNLOAD_READ_FILE:
            dprintf(("main: DOWNLOAD_READ_FILE msg\n"));
            callReadFile(pMsgOutQ);
            break;
        default:
            dprintf(("no match for message\n"));
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// Function:  Main
// Purpose:   main entry procedure
// Args:      none
// RetVal:    TRUE or FALSE based on error
//----------------------------------------------------------------------------

__cdecl main(INT argc, TCHAR *argv[])
{
    outQ *pOutQ = NULL;
    outQ *pMsgOutQ = NULL;
    outQ *pQ = NULL;
    MSG msg;
    INT retVal;
    DWORD dwResult;
    HANDLE *pObjs = &hMaxDownloadSem;

    g_hHeap = HeapCreate(0,1000000,0);

    if(!g_hHeap)
        return(FALSE);

    if(!Process_Command_Line(argc, argv))
        return FALSE;

    generateInfo();

    g_pUrlInfoCache.pHead = NULL;

    if(!(pOutQ = FillURLQueue()))
        return(FALSE);
        
    if(g_bSingleThreaded)
    {
        if(!DoInit())    // create throttle semaphore, do InternetOpen & InternetSetStatusCallback
            return FALSE;

        pQ = pOutQ;
    }
    else
    {
        hDownloadThread = CreateThread(NULL,
            0,
            (LPTHREAD_START_ROUTINE)DownloadThread,
            (LPVOID)pOutQ,
            0,
            &dwThreadID );

        if (!hDownloadThread) {
            dprintf(("Could not create Thread\n"));
            return FALSE;
        }
    }

    while(TRUE) 
    {
        if(g_bSingleThreaded)
        {
            dwResult = MsgWaitForMultipleObjects(1, pObjs, FALSE, INFINITE, QS_ALLINPUT);
            if(dwResult == (WAIT_OBJECT_0 + 1))
            {
                MSG msg;
                while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if(msg.message == WM_QUIT)
                        return(FALSE);
                        
                    pMsgOutQ = (outQ *) msg.wParam;
                    ProcessMessage(msg, pOutQ, pMsgOutQ);
                    if(msg.message == DOWNLOAD_DONE)
                        return(TRUE);
                }
            }
            else
            {
                // Semaphore is signaled so do next connect/download
                if(pQ != NULL)    // If there are still more downloads to do
                {
                    pQ->iStatus = CONNECTING;
                    pQ->iPriority = LOW;
                    dprintf(("Download Main: TID=%x pOutQ=%x iStatus=%ld ->%ld\r\n", GetCurrentThreadId(), pQ, pQ->iStatus, CONNECTING));
                
                    if(!DoConnect(pQ))
                        break;
                    pQ = pQ->pNext;
                }
            }
        }
        else
        {
            retVal = GetMessage(&msg, NULL, 0, 0);
            if(retVal == -1) 
            {
                dprintf(("error on GetMessage\n"));
                break;
            }
            if(retVal == FALSE) 
            {
                msg.message = DOWNLOAD_DONE;
            }
            pMsgOutQ = (outQ *) msg.wParam;
            ProcessMessage(msg, pOutQ, pMsgOutQ);
            if(msg.message == DOWNLOAD_DONE)
                return(TRUE);
        }
    }

    dprintf(("exiting abnormally\n"));
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\cachapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapiw.cxx

Abstract:

    contains the UNICODE version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)   Dec-1997
--*/

#include <cache.hxx>
#include <w95wraps.h>

#define NUMBER_MEMBERS 4


const BYTE bOffsetTable[NUMBER_MEMBERS] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszSourceUrlName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszLocalFileName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpHeaderInfo),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszFileExtension)
    };
    
DWORD
TransformA2W(
    IN LPINTERNET_CACHE_ENTRY_INFOA pCEIA,
    IN DWORD cbCEIA,
    OUT LPINTERNET_CACHE_ENTRY_INFOW pCEIW,
    OUT LPDWORD pcbCEIW
    )
{
    DWORD cbSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
    DWORD cc;

    if (!pCEIW || (*pcbCEIW<sizeof(INTERNET_CACHE_ENTRY_INFOW)))
    {
        *pcbCEIW = 0;
        cc = 0;
    }
    else
    {
        //
        // copy fixed portion.
        //
        memcpy((PBYTE)pCEIW, (PBYTE)pCEIA, sizeof(INTERNET_CACHE_ENTRY_INFOW) );
        pCEIW->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
        cc = (*pcbCEIW - sizeof(INTERNET_CACHE_ENTRY_INFOW))/sizeof(WCHAR);
    }

    // Destination for strings
    PWSTR pBuffer = (pCEIW ? (PWSTR)(pCEIW + 1) : NULL);
    // Convert strings
    for (int i=0; i < NUMBER_MEMBERS; i++)
    {
        PSTR *pBufferA = (PSTR*)((PBYTE)pCEIA + bOffsetTable[i]);

        if (*pBufferA)
        {
            DWORD dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, NULL, 0);
            if ((dwTmp<=cc) && pCEIW)
            {
                INET_ASSERT(pBuffer);

                PWSTR *pBufferW = (PWSTR*)((PBYTE)pCEIW + bOffsetTable[i]);
                *pBufferW = pBuffer;
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, *pBufferW, dwTmp);
                pBuffer += dwTmp;
                cc -= dwTmp;
            }
            cbSize += dwTmp*sizeof(WCHAR);
        }
    }

    DWORD dwErr = (*pcbCEIW>=cbSize) ? ERROR_SUCCESS : ERROR_INSUFFICIENT_BUFFER;
    *pcbCEIW = cbSize; // Tell how much space used/needed.
    return dwErr;
}


URLCACHEAPI_(BOOL) CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryW", "%wq, %wq, %d, %wq, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName, mpFileExtension, mpFileName;

    if (lpszUrlName)
    {
        ALLOC_MB(lpszUrlName,0,mpUrlName);
        if (!mpUrlName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    ALLOC_MB(NULL, MAX_PATH, mpFileName);
    if (!mpFileName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    fResult = CreateUrlCacheEntryA(
        mpUrlName.psStr,
        dwExpectedFileSize,
        mpFileExtension.psStr,
        mpFileName.psStr,
        dwReserved);
    if (fResult)
    {
        MultiByteToWideChar(CP_ACP, 0, mpFileName.psStr, -1, lpszFileName, MAX_PATH);
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpszHeaderInfo,
    IN DWORD dwHeaders,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryW",
        "%wq, %wq, <expires>, <last-mod>, %d, %wq, %d, %wq, %wq",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpszHeaderInfo,
        dwHeaders,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName, mpLocalFileName, mpFileExtension, mpHeaders, mpOriginalUrl;

    if( IsBadUrlW( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadStringPtrW( lpszLocalFileName, MAX_PATH ) : FALSE ) ) 
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpszLocalFileName)
    {
        ALLOC_MB(lpszLocalFileName,0,mpLocalFileName);
        if (!mpLocalFileName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszLocalFileName,mpLocalFileName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszHeaderInfo)
    {
        ALLOC_MB(lpszHeaderInfo,0,mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszHeaderInfo,mpHeaders, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

    }
    if (lpszOriginalUrl)
    {
        ALLOC_MB(lpszOriginalUrl,0,mpOriginalUrl);
        if (!mpOriginalUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszOriginalUrl,mpOriginalUrl, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    fResult = CommitUrlCacheEntryA(
            mpUrlName.psStr,
            mpLocalFileName.psStr,
            ExpireTime,
            LastModifiedTime,
            CacheEntryType,
            (LPBYTE)mpHeaders.psStr,
            mpHeaders.dwSize,
            mpFileExtension.psStr,
            mpOriginalUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL
RetrieveUrlCacheEntryWCore(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved,
    IN DWORD dwLookupFlags,
    IN DWORD dwRetrievalFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD dwCEI = 0;
    
    if (!InitGlobals())
    {
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!(lpszUrlName && lpcbCacheEntryInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName, 0, mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName, mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    dwErr = GlobalUrlContainers->RetrieveUrl(
                        mpUrlName.psStr,
                        &pCEIA,
                        &dwCEI,
                        dwLookupFlags,
                        dwRetrievalFlags | RETRIEVE_WITH_ALLOCATION);

    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(
            pCEIA,
            dwCEI,
            lpCacheEntryInfo,
            lpcbCacheEntryInfo);

        if (dwErr!=ERROR_SUCCESS)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
    }

cleanup:
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr == ERROR_SUCCESS);
}


URLCACHEAPI_(BOOL) RetrieveUrlCacheEntryFileW(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileW","%wq, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo, dwReserved));

    BOOL fResult = RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(HANDLE) RetrieveUrlCacheEntryStreamW(
    IN LPCWSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamW",
        "%wq, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpcbCacheEntryInfo,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hInternet = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr = ERROR_SUCCESS, dwFileSize;
    CACHE_STREAM_CONTEXT_HANDLE* pStream;

    if (!RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_NOCREATE,
                        RETRIEVE_WITHOUT_CHECKS))
    {
        goto cleanup;
    }

    fLocked = TRUE;        

    // Allocate a stream handle.
    LOCK_CACHE();
    hInternet = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hInternet)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hInternet);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hInternet)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // Open the file.
    // Does CreateFileW exist on Win9x?

    hFile = CreateFileW
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        dwErr = GetLastError();
        goto cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    {
        MEMORYPACKET mpUrl;
        ALLOC_MB(lpszUrlName,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrlName,mpUrl);
        
        pStream->SourceUrlName = NewString(mpUrl.psStr);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        if (hInternet)
        {
            HandleMgr.Free(hInternet);
            hInternet = NULL;
        }
        if (hFile)
            CloseHandle (hFile);

        if (fLocked)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
        SetLastError (dwErr);
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOL
GetUrlCacheEntryWCore(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        DWORD dwFlags,
        DWORD dwLookupFlags,
        BOOL fConvertHeaders)
{
    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;

    if (!InitGlobals())
    {
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }

    if (IsBadUrlW(lpszUrl))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrl,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrl,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpcbCacheEntryInfo)
    {
        dwErr = GlobalUrlContainers->GetUrlInfo(
            mpUrlName.psStr,
            &pCEIA,
            &cbCEIA,
            dwFlags,
            dwLookupFlags,
            RETRIEVE_WITH_ALLOCATION);
            
        // convert from ansi to unicode. 
        if (dwErr==ERROR_SUCCESS)
        {
            dwErr = TransformA2W(pCEIA, cbCEIA, lpCacheEntryInfo, lpcbCacheEntryInfo);
            if (dwErr==ERROR_SUCCESS)
            {
                fResult = TRUE;
            }
        }
    }
    else
    {
        fResult = GetUrlCacheEntryInfoExA(
                mpUrlName.psStr, 
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                dwFlags);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return fResult;
}


URLCACHEAPI_(BOOL) GetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoW", "%wq, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo));

    BOOL fResult = GetUrlCacheEntryWCore(
                            lpszUrlName,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            0,
                            LOOKUP_URL_NOCREATE,
                            TRUE);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI GetUrlCacheEntryInfoExW(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        OUT LPWSTR lpszRedirectUrl,
        IN OUT LPDWORD lpcbRedirectUrl,
        LPVOID lpReserved,
        DWORD dwFlags
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExW",
        "%wq, %#x, %#x, %wq, %#x, %#x, %#x", 
        lpszUrl, lpCacheEntryInfo, lpcbCacheEntryInfo, lpszRedirectUrl, lpcbRedirectUrl, lpReserved, dwFlags));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    
    if (lpszRedirectUrl
        || lpcbRedirectUrl 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    fResult = GetUrlCacheEntryWCore(
                            lpszUrl,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            dwFlags,
                            LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS),
                            TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI_(BOOL) SetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoW", "%wq, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName;
    INTERNET_CACHE_ENTRY_INFOA CacheEntryInfoA;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    memcpy( &CacheEntryInfoA, lpCacheEntryInfo, sizeof(CacheEntryInfoA) );

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryInfoA(
            mpUrlName.psStr,
            &CacheEntryInfoA,
            dwFieldControl );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL FindUrlCacheEntryWCore(
    IN OUT HANDLE     *phFind,
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    IN     BOOL      fConvertHeaders
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpSearchPattern;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;
    BOOL fFindFirst = *phFind==NULL;
    
    // DebugBreak();
    
    if (!InitGlobals())
    {
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!pcbEntryInfo)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszUrlSearchPattern)
    {
        ALLOC_MB(lpszUrlSearchPattern, 0, mpSearchPattern);
        if (!mpSearchPattern.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlSearchPattern, mpSearchPattern, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = GlobalUrlContainers->FindNextEntry(phFind, 
                                               mpSearchPattern.psStr, 
                                               &pCEIA, 
                                               &cbCEIA,
                                               dwFilter,
                                               GroupId,
                                               dwFlags,
                                               RETRIEVE_WITH_ALLOCATION);

    // TransformA2W will convert from ansi to unicode. ERROR_SUCCESS always means that
    // the cache entry has been returned.
    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(pCEIA,
            cbCEIA,
            pEntryInfo,
            pcbEntryInfo);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        if (fFindFirst && *phFind)
        {
            GlobalUrlContainers->FreeFindHandle(*phFind);
            *phFind = NULL;
        }
        
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr==ERROR_SUCCESS) ;
}


URLCACHEAPI_(HANDLE) FindFirstUrlCacheEntryW(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryW",
        "%wq, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpcbCacheEntryInfo
    ));

    HANDLE hInternet = FindFirstUrlCacheEntryExW(
                        lpszUrlSearchPattern,
                        FIND_FLAGS_OLD_SEMANTICS,
                        URLCACHE_FIND_DEFAULT_FILTER,
                        NULL,
                        lpFirstCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        NULL,
                        NULL,
                        NULL);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPCACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD pcbEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryW",
       "%#x, %#x, %#x",
        hEnumHandle, 
        pEntryInfo,
        pcbEntryInfo
    ));

    BOOL fResult = FindNextUrlCacheEntryExW(
                    hEnumHandle,
                    pEntryInfo,
                    pcbEntryInfo,
                    NULL, 
                    NULL,
                    NULL);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExW(
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExW",
        "%wq, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    HANDLE hInternet = NULL;

    FindUrlCacheEntryWCore(
            &hInternet,
            lpszUrlSearchPattern,
            dwFlags,
            dwFilter,
            GroupId,
            pEntryInfo,
            pcbEntryInfo,
            TRUE);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOLAPI FindNextUrlCacheEntryExW(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExW",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hEnumHandle,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    
    if (!hEnumHandle)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = FindUrlCacheEntryWCore(
                        &hEnumHandle,
                        NULL,
                        0,
                        0,
                        0,
                        pEntryInfo,
                        pcbEntryInfo,
                        TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) FreeUrlCacheSpaceW(
    IN LPCWSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpaceW", 
        "<path>,%d, %#x", dwSize, dwReserved));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;

    MEMORYPACKET mpCachePath;
    if (lpszCachePath)
    {
        ALLOC_MB(lpszCachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszCachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    fResult = FreeUrlCacheSpaceA(
            mpCachePath.psStr,
            dwSize,
            dwReserved );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI_(BOOL) UnlockUrlCacheEntryFileW(
    LPCWSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFileW",
        "%wq, %#x", lpszUrlName, dwReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = UnlockUrlCacheEntryFileA(mpUrl.psStr, dwReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) DeleteUrlCacheEntryW(
    IN LPCWSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntryW",
        "%wq", lpszUrlName));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = DeleteUrlCacheEntryA(mpUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI IsUrlCacheEntryExpiredW(
    IN      LPCWSTR      lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UrlCacheEntryExpiredW", 
        "%wq, %#x", lpszUrlName, dwFlags));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = IsUrlCacheEntryExpiredA(
                    mpUrl.psStr,
                    dwFlags,
                    pftLastModifiedTime);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL CacheGroupInfoA2W(
    IN          LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN          DWORD                           dwAnsiGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN OUT      LPDWORD                         lpdwUnicodeGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);

    lpUnicodeGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOW);
    lpUnicodeGroupInfo->dwGroupFlags = lpAnsiGroupInfo->dwGroupFlags;
    lpUnicodeGroupInfo->dwGroupType = lpAnsiGroupInfo->dwGroupType;
    lpUnicodeGroupInfo->dwDiskUsage = lpAnsiGroupInfo->dwDiskUsage;
    lpUnicodeGroupInfo->dwDiskQuota = lpAnsiGroupInfo->dwDiskQuota;

    memcpy(lpUnicodeGroupInfo->dwOwnerStorage,
           lpAnsiGroupInfo->dwOwnerStorage,
           GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );


    BOOL fRet = MultiByteToWideChar(
               CP_ACP,
               MB_PRECOMPOSED,
               lpAnsiGroupInfo->szGroupName,
               -1,         // null terminated ansi string.
               lpUnicodeGroupInfo->szGroupName,
               GROUPNAME_MAX_LENGTH
    );

    if( fRet )
    {
        *lpdwUnicodeGroupInfoSize = lpUnicodeGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwUnicodeGroupInfoSize = 0;
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return fRet;
}

BOOL CacheGroupInfoW2A(
    IN          LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN          DWORD                           dwUnicodeGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN OUT      LPDWORD                         lpdwAnsiGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);
    BOOL fStrNotSafe = FALSE;

    lpAnsiGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    lpAnsiGroupInfo->dwGroupFlags = lpUnicodeGroupInfo->dwGroupFlags;
    lpAnsiGroupInfo->dwGroupType = lpUnicodeGroupInfo->dwGroupType;
    lpAnsiGroupInfo->dwDiskUsage = lpUnicodeGroupInfo->dwDiskUsage;
    lpAnsiGroupInfo->dwDiskQuota = lpUnicodeGroupInfo->dwDiskQuota;

    memcpy( lpAnsiGroupInfo->dwOwnerStorage,
            lpUnicodeGroupInfo->dwOwnerStorage,
            GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );

    BOOL fRet = WideCharToMultiByte(
                CP_ACP,
                0,              // no flags.
                lpUnicodeGroupInfo->szGroupName,
                -1,             // null terminated unicode string.
                lpAnsiGroupInfo->szGroupName,
                GROUPNAME_MAX_LENGTH,
                NULL,           // lpDefaultChar
                &fStrNotSafe    // lpUseDefaultChar
    );
    if (fStrNotSafe)
    {
        fRet = FALSE;
    }

    if( fRet )
    {
        *lpdwAnsiGroupInfoSize = lpAnsiGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwAnsiGroupInfoSize = 0;
    }
    return fRet;
}


URLCACHEAPI_(BOOL) SetUrlCacheEntryGroupW(
    IN LPCWSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupW", 
        "%wq, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryGroupA(
                    mpUrl.psStr,
                    dwFlags,
                    GroupId,
                    pbGroupAttributes,
                    cbGroupAttributes,
                    lpReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) GetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeW",
        "%d, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( !lpGroupInfo || !lpdwGroupInfo )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOW) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    if( IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( GetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes,
            &AnsiGroupInfo, &dwAnsiGroupInfoSize, lpReserved ) )
    {
        fResult = CacheGroupInfoA2W( &AnsiGroupInfo, 
                                    dwAnsiGroupInfoSize,
                                    lpGroupInfo, 
                                    lpdwGroupInfo );
    }


Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) SetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW) ) )
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else if( CacheGroupInfoW2A(
            lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW),
            &AnsiGroupInfo, &dwAnsiGroupInfoSize ) )
    {
        fResult = SetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes, &AnsiGroupInfo, lpReserved );
    }

    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// Convert all the ansi strings in a structure to unicode

/* How does this work?
    Take this structure for example:

    struct foo 
    {
        DWORD dwA;
        LPTSTR pszB;
        DWORD dwC;
        LPTSTR pszD;
    };
    where LPTSTR are embedded pointers
    
    The memory layout is thus:

    [DWORD][LPTSTR][DWORD][LPTSTR][embedded string pszB][embedded string pszD]
    ^                             ^
    |                             |
    |-struct beginning            |-beginning of embedded strings

    Assuming a 32-bit platform, we can construct pointers (relative to the struct beginning) to each element
    in the structure. In this case,

    { 0, sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Let's say we're interested in strings only, and we know that these strings are embedded. We can create a byte table thus:
    BYTE bFoo[] = { sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Alternatively:
    BYTE bFoo[] = 
    {
        (BYTE)&(((foo*)NULL)->pszB),
        (BYTE)&(((foo*)NULL)->pszD)
    };

    This layout is the same for both Ansi and Unicode versions of a struct, UNLESS the struct contains for example 
    a TCHAR szWhat[256] (in which case, we can't use the bulk converter).

    Pass BulkConverter the following parameters, to convert strings in one swoop.

    pbSrc       = casted pointer to the beginning of the ansi structure
    pbDest      = casted pointer to the beginning of the unicode structure
    cbAvail     = number of bytes available for embedded strings
    wSkip       = offset from the beginning of the structure, at which point embedded strings may be written
    cElements   = number of elements to convert from ansi to unicode

    If BulkConverter succeeds, it'll return the number of bytes used.
    If it fails, it will return the number of bytes needed to store all the unicode strings.

BUT HOW DOES THIS THING WORK?
Oh. 

1. Using the offset table, we figure out where the pointer to the string is in both the structures.
2. Then using magic, we decided where to place the unicode string. 
3. Figure how much space we'll need to store the unicode string
4. If that much is available, convert.
5. Keep track, either way.
6. Go to 1, if we have any other strings left.
*/

LONG BulkConverter(PBYTE pbSrc, PBYTE pbDest, LONG cbAvail, WORD wSkip, CONST BYTE abTable[], WORD cElements)
{
    PWSTR pBuffer = (PWSTR)(pbDest + wSkip);
    PSTR *pBufferA;
    PWSTR *pBufferW;

    for (DWORD i=0; i < cElements; i++)
    {
        pBufferA = (PSTR*)((PBYTE)pbSrc + abTable[i]);
        pBufferW = (PWSTR*)((PBYTE)pbDest + abTable[i]);

        if (*pBufferA)
        {
            *pBufferW = pBuffer;
            LONG dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, 0);
            if (dwTmp<cbAvail)
            {
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, cbAvail);
                pBuffer += dwTmp;
            }
            cbAvail -= dwTmp;
        }
    }
    return cbAvail;
}


const BYTE bOffsetTableContainer[] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszName),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszCachePrefix),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeLabel),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeTitle)
    };

BOOL
TransformCacheContainerInfoToW(
    IN BOOL fResult,
    IN LPINTERNET_CACHE_CONTAINER_INFOA pCCIA,
    IN DWORD cbCCIA,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW pCCIW,
    OUT LPDWORD pcbCCIW
)
{
    DWORD cbSize = *pcbCCIW;

    if (fResult)
    {
        // If we have pointers, try to convert from 

        LONG cc = *pcbCCIW - sizeof(INTERNET_CACHE_CONTAINER_INFOW);
        if (*pcbCCIW > sizeof(INTERNET_CACHE_CONTAINER_INFOW))
        {
            pCCIW->dwCacheVersion = pCCIA->dwCacheVersion;
        }
        cc /= sizeof(WCHAR);
        // Convert strings
        cc = BulkConverter((PBYTE)pCCIA, 
                (PBYTE)pCCIW, 
                cc, 
                sizeof(INTERNET_CACHE_CONTAINER_INFOW), 
                bOffsetTableContainer, 
                ARRAY_ELEMENTS(bOffsetTableContainer));


       // Tell how much space was actually used.
        *pcbCCIW -= cc*sizeof(WCHAR);

        if (*pcbCCIW>cbSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            fResult = FALSE;
        }
    }
    else if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
    {
        *pcbCCIW = (cbCCIA - sizeof(INTERNET_CACHE_CONTAINER_INFOA))*sizeof(WCHAR) + sizeof(INTERNET_CACHE_CONTAINER_INFOW);
    }

    return fResult;
}

#define USE_ORIGINAL_CODE

URLCACHEAPI_(BOOL) CreateUrlCacheContainerW(
                 IN LPCWSTR Name,
                 IN LPCWSTR CachePrefix,
                 IN LPCWSTR CachePath,
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                     IN DWORD dwOptions,
                     IN OUT LPVOID pvBuffer,
                     IN OUT LPDWORD cbBuffer)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerW", "%wq, %wq, %wq, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    MEMORYPACKET mpName, mpCachePrefix, mpCachePath;
    BOOL fStrNotSafe = FALSE;

#ifdef USE_ORIGINAL_CODE
    if (Name)
    {
        ALLOC_MB(Name, 0, mpName);
        if (!mpName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePrefix)
    {
        ALLOC_MB(CachePrefix, 0, mpCachePrefix);
        if (!mpCachePrefix.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePrefix, mpCachePrefix, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePath)
    {
        ALLOC_MB(CachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
#else
// Theoretically, the following fragment should be smaller than the above fragment. 
// Although the retail obj shows a function that's about 100 bytes shorter, the
// actual dll doesn't show this gain. Until I figure this out, we won't use it.

    DWORD c;
    do
    {
        MEMORYPACKET* mp;
        PCWSTR psz;

        switch (c)
        {
        case 0:
            psz = Name;
            mp = &mpName;
            break;
            
        case 1:
            psz = CachePrefix;
            mp = &mpCachePrefix;
            break;

        case 2:
            psz = CachePath;
            mp = &mpCachePath;
            break;
        }
        ALLOC_MB(psz, 0, (*mp));
        if (!mp->psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(psz, (*mp), &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        c++;
    }
    while (c<3);

#endif

    fResult = CreateUrlCacheContainerA(
                mpName.psStr,
                mpCachePrefix.psStr,
                mpCachePath.psStr,
                KBCacheLimit,
                dwContainerType,
                dwOptions,
                pvBuffer,
                cbBuffer);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI_(BOOL) DeleteUrlCacheContainerW(
IN LPCWSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerW", "%wq, %#x", Name, dwOptions));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpName;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;

    ALLOC_MB(Name, 0, mpName);
    if (!mpName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    fResult = DeleteUrlCacheContainerA(mpName.psStr, dwOptions);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI_(HANDLE) FindFirstUrlCacheContainerW(
    IN OUT DWORD *pdwModified,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo,
    IN DWORD dwOptions
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerW",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpcbContainerInfo,
        dwOptions
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    HANDLE hInternet = NULL;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    hInternet = FindFirstUrlCacheContainerA(pdwModified,
        (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, &mpCacheInfo.dwSize, dwOptions);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    if (!TransformCacheContainerInfoToW(
            hInternet ? TRUE : FALSE,
            (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
            mpCacheInfo.dwSize,
            lpContainerInfo,
            lpcbContainerInfo))
    {
        if (hInternet)
        {
            FindCloseUrlCache(hInternet);
            hInternet = NULL;
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheContainerW(
    IN HANDLE hEnumHandle,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerW",
        "%#x, %#x, %#x",
        hEnumHandle, 
        lpContainerInfo,
        lpcbContainerInfo
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    BOOL fResult = FALSE;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    fResult = FindNextUrlCacheContainerA(
                    hEnumHandle,
                    (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, 
                    &mpCacheInfo.dwSize);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    fResult = TransformCacheContainerInfoToW(
                fResult,
                (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
                mpCacheInfo.dwSize,
                lpContainerInfo,
                lpcbContainerInfo);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

/* here's the struct referred to below 

typedef struct _INTERNET_CACHE_CONFIG_INFOA {
    DWORD dwStructSize;
    DWORD dwContainer;
    DWORD dwQuota;
    DWORD dwReserved4;
    BOOL  fPerUser;
    DWORD dwSyncMode;
    DWORD dwNumCachePaths;
    union 
    { 
        struct 
        {
            CHAR   CachePath[MAX_PATH];
            DWORD dwCacheSize;
        };
        INTERNET_CACHE_CONFIG_PATH_ENTRYA CachePaths[ANYSIZE_ARRAY];
    };
    DWORD dwNormalUsage;
    DWORD dwExemptUsage;
} INTERNET_CACHE_CONFIG_INFOA, * LPINTERNET_CACHE_CONFIG_INFOA;

*/

#define ICCIA_FIXED_PORTION_SIZE ((sizeof(DWORD)*6)+sizeof(BOOL))

URLCACHEAPI_(BOOL) GetUrlCacheConfigInfoW(
    OUT LPINTERNET_CACHE_CONFIG_INFOW pCacheConfigInfo,
    IN OUT LPDWORD pcbCacheConfigInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoW", "%#x, %#x, %#x",
        pCacheConfigInfo, pcbCacheConfigInfo, dwFieldControl ));

    INTERNET_CACHE_CONFIG_INFOA iccia;
    
    iccia.dwContainer = pCacheConfigInfo->dwContainer;
    iccia.dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    DWORD dwSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    BOOL fResult = GetUrlCacheConfigInfoA(&iccia, &dwSize, dwFieldControl);
    if (fResult)
    {
        memcpy(pCacheConfigInfo, &iccia, ICCIA_FIXED_PORTION_SIZE);

        // These are appended to the _end_ of the structure.
        pCacheConfigInfo->dwNormalUsage = iccia.dwNormalUsage;
        pCacheConfigInfo->dwExemptUsage = iccia.dwExemptUsage;
        pCacheConfigInfo->dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOW);
        if (pCacheConfigInfo->dwContainer <= HISTORY)
        {
            MultiByteToWideChar(CP_ACP, 0, iccia.CachePath, -1, pCacheConfigInfo->CachePath, ARRAY_ELEMENTS(pCacheConfigInfo->CachePath));
        }
    }

    DEBUG_LEAVE_API (fResult);
    return fResult;
}


URLCACHEAPI_(BOOL) SetUrlCacheConfigInfoW(
    LPCACHE_CONFIG_INFOW lpConfigConfigInfo,
    DWORD dwFieldControl
    )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\cacheapi.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cacheapi.cxx

Abstract:

    contains the URL cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Prefixed containers for supporting cookies and history
    2) Default init, for distributing winint without setup
    3) Crossprocess versionchecking scheme to allow all wininets
       to know about registry change

--*/

#include <cache.hxx>
#include <time.h>
#include <resource.h>
    
URLCACHEAPI_(BOOL) UnlockUrlCacheEntryStream(
    HANDLE hStream,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    hStreamHandle : stream handle returned by a RetrieveUrlCacheEntryStream call.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryStream",
        "%#x, %#x", hStream, dwReserved))

    DWORD Error;


    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE *pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE *) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }
    
        
    TcpsvcsDbgAssert(pStream->SourceUrlName != NULL );

    //
    // close file handle.
    //

    CloseHandle( pStream->FileHandle );

    //
    // unlock cache file.
    //

    if(!UnlockUrlCacheEntryFile(pStream->SourceUrlName, dwReserved) )
        Error = GetLastError();
    else
        Error = ERROR_SUCCESS;

    //
    // freeup url name data buffer.
    //

    FREE_MEMORY (pStream->SourceUrlName);

    //
    // free up context structure.
    //

    LOCK_CACHE();
    HandleMgr.Free (hStream);
    UNLOCK_CACHE();

    LEAVE_CACHE_API();
}

URLCACHEAPI_(BOOL) ReadUrlCacheEntryStream(
    IN HANDLE hStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This API provides a method  of reading the cached data from a stream
    which has been opened using the RetrieveUrlCacheEntryStream API.

Arguments:

    hStream : Handle that was returned by the RetrieveCacheEntryStream API.

    dwLocation  : file offset to read from.

    lpBuffer : Pointer to a buffer where the data is read.

    lpdwLen : Pointer to a DWORD location where the length of the above buffer passed in, on return it contains the actual length of the data read.

    dwReserved : For future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "ReadUrlCacheEntryStream",
        "%#x, %d, %#x, %#x, %#x", hStream, dwLocation, lpBuffer, lpdwLen, Reserved));

    DWORD Error;

    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    TcpsvcsDbgAssert( pStream->SourceUrlName);

    // PERFPERF: should we remember position to avoid this call?
    if ((DWORD) -1L == SetFilePointer
        (pStream->FileHandle, dwLocation, NULL, FILE_BEGIN))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    if( !ReadFile
        (pStream->FileHandle, lpBuffer, *lpdwLen, lpdwLen, NULL ) )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    LEAVE_CACHE_API();
}


URLCACHEAPI_(BOOL) FindCloseUrlCache(
    IN HANDLE hFind
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindCloseUrlCache",
        "%#x", hFind));

    DWORD Error;
    
    Error = GlobalUrlContainers->FreeFindHandle(hFind);

    if (Error != ERROR_SUCCESS)
    {
        SetLastError( Error );
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);
    return (Error==ERROR_SUCCESS);
}


BOOL
GetCurrentSettingsVersion(LPDWORD   lpdwVer) {

    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                              lpdwVer);
}

BOOL
IncrementCurrentSettingsVersion(LPDWORD lpdwVer) {

    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                                    lpdwVer);
}


BOOL
GetUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(nIdx, lpdwData);
}

BOOL
SetUrlCacheHeaderData(IN DWORD nIdx, IN  DWORD  dwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetHeaderData(nIdx, dwData);
}

BOOL
IncrementUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(nIdx, lpdwData);
}


BOOL
LoadUrlCacheContent(VOID)
{
    DWORD dwError;
    if (!InitGlobals())
    {
        SetLastError(ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->LoadContent();
    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}


BOOL
GetUrlCacheContainerInfo(
    IN LPSTR lpszUrlName,
	OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
	IN OUT LPDWORD lpdwContainerInfoBufferSize,
	IN DWORD dwOptions
)
{
    DWORD dwError;

    // Initialize globals.
    if (!InitGlobals())
    {
        SetLastError(ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->GetContainerInfo(lpszUrlName,
            lpContainerInfo, lpdwContainerInfoBufferSize);

    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}

BOOL
UpdateUrlCacheContentPath(
    IN LPSTR lpszNewPath
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UpdateUrlCacheContentPath", "%q", lpszNewPath));
    INET_ASSERT(GlobalCacheInitialized);

    BOOL fResult = GlobalUrlContainers->SetContentPath(lpszNewPath);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}



INTERNETAPI_(GROUPID) CreateUrlCacheGroup(
    IN DWORD  dwFlags,
    IN LPVOID lpReserved  // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheGroup", "%#x, %#x", dwFlags, lpReserved));
    GROUPID gid = 0;
    DWORD   Error; 

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->CreateGroup(dwFlags, &gid);

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(gid);    
    return gid;
}

BOOLAPI DeleteUrlCacheGroup(
    IN  GROUPID GroupId,
    IN  DWORD   dwFlags,       // must pass 0
    IN  LPVOID  lpReserved    // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheGroup", "%#x, %#x, %#x", GroupId, dwFlags, lpReserved));
    DWORD   Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteGroup(GroupId, dwFlags);

    LEAVE_CACHE_API();
}



URLCACHEAPI_(HANDLE) FindFirstUrlCacheGroup(
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwFilter,
    IN      LPVOID                          lpSearchCondition,
    IN      DWORD                           dwSearchCondition,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
) 
{
    ENTER_CACHE_API ((DBG_API, Handle, "FindFirstUrlCacheGroup",
        "%d, %d, %#x, %d, %#x, %#x", 
        dwFlags, dwFilter, lpSearchCondition, 
        dwSearchCondition, lpGroupId, lpReserved ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    // Get the first entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, dwFlags, lpGroupId);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
        hFind = NULL;
    }

    INET_ASSERT (hFind);
    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI_(BOOL) FindNextUrlCacheGroup(
    IN HANDLE                               hFind,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
    )
{

    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheGroup",
        "%#x, %#x, %#x", hFind, lpGroupId, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, 0, lpGroupId);

    LEAVE_CACHE_API();
}



BOOL
AnyFindsInProgress(DWORD ContainerID)
{
    LOCK_CACHE();
    BOOL fInProgress = HandleMgr.InUse();
    UNLOCK_CACHE();
    return fInProgress;
}


BOOLAPI
RegisterUrlCacheNotification(
    HWND        hWnd, 
    UINT        uMsg, 
    GROUPID     gid, 
    DWORD       dwFilter, 
    DWORD       dwReserve
)
{
    DWORD Error;
    ENTER_CACHE_API ((DBG_API, Bool, "RegisterUrlCacheNotification", 
        "%#x,,%#x, %#x, %#x, %#x", hWnd, uMsg, gid, dwFilter, dwReserve));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);

    LEAVE_CACHE_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Contains data definitions for debug code.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

#ifdef __cplusplus
extern "C" {
#endif

// Event tracking macros...
#define EVENTWRAP(API, h) {\
    BOOL ret = API(h);\
    if (ret) \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d)\n", h)); \
    else { \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d) failed err=%d\n",\
            h, GetLastError())); \
        TcpsvcsDbgAssert( FALSE ); \
    } \
}\

#define   SETEVENT(h)  EVENTWRAP(SetEvent,    h)
#define RESETEVENT(h)  EVENTWRAP(ResetEvent,  h)
#define CLOSEHANDLE(h) EVENTWRAP(CloseHandle, h)

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//
#define DEBUG_ERRORS            0x00000001  // hard errors.
#define DEBUG_REGISTRY          0x00000002  // debug registry calls
#define DEBUG_MISC              0x00000004  // misc info.
#define DEBUG_SCAVENGER         0x00000008  // scavenger debug info.

#define DEBUG_SORT              0x00000010  // debug B-TREE functions
#define DEBUG_CONTAINER         0x00000020  // debug container
#define DEBUG_APIS              0x00000040  // debug tcpsvcs apis
#define DEBUG_FILE_VALIDATE     0x00000080 // validate file map file
#define DEBUG_SVCLOC_MESSAGE    0x00000100  // discovery messages



//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_TIMESTAMP         0x00010000  // print time stamps
#define DEBUG_MEM_ALLOC         0x00020000 // memory alloc
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.

#define ENTER_CACHE_API(paramlist) \
{ DEBUG_ONLY(LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();) \
  DEBUG_ENTER_API(paramlist); \
}

#define LEAVE_CACHE_API() \
Cleanup:                         \
    if (Error != ERROR_SUCCESS)  \
    {                            \
        SetLastError( Error );   \
        DEBUG_ERROR(INET, Error); \
    }                            \
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);      \
    return (Error==ERROR_SUCCESS);                 \

#if DBG

///#define DEBUG_PRINT OutputDebugString

//
// debug functions.
//

#define TcpsvcsDbgPrint(_x_) TcpsvcsDbgPrintRoutine _x_

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define TcpsvcsDbgAssert(Predicate) INET_ASSERT(Predicate)

#else

///#define IF_DEBUG(flag) if (FALSE)

#define TcpsvcsDbgPrint(_x_)
#define TcpsvcsDbgAssert(_x_)

#endif // DBG

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

#ifdef __cplusplus
}
#endif

#endif  // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\conmgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conmgr.cxx

Abstract:

    Manages list of containers (CConList)

Author:
    Adriaan Canter (adriaanc) 04-02-97

--*/

#include <cache.hxx>

#define FAILSAFE_TIMEOUT (60000)

/*---------------------  Private Functions -----------------------------------*/
/*-----------------------------------------------------------------------------
DWORD CConMgr::Init
----------------------------------------------------------------------------*/
DWORD CConMgr::Init()
{
    DWORD dwError = ConfigureCache();

    if (dwError==ERROR_SUCCESS)
    {
        // Get the extensible cache config info.
        // These containers are delay-initialized.
        dwError = GetExtensibleCacheConfigInfo(TRUE);
    }
    else
    {
        INET_ASSERT(FALSE);
    }
    return dwError;

}

#ifdef CHECKLOCK_PARANOID
void CConMgr::CheckNoLocks(DWORD dwThreadId)
{
    URL_CONTAINER *co;
    DWORD idx;

    LOCK_CACHE();
    for (idx = 0; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            co->CheckNoLocks(dwThreadId);
            co->Release(FALSE);
        }
    }
    UNLOCK_CACHE();
}
#endif

/*-----------------------------------------------------------------------------
BOOL CConMgr::WasModified
----------------------------------------------------------------------------*/
BOOL CConMgr::WasModified(BOOL fUpdateMemory)
{
    DWORD dwOldCount = _dwModifiedCount;
    return dwOldCount != ReadModifiedCount(fUpdateMemory);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::ReadModifiedCount
----------------------------------------------------------------------------*/
DWORD CConMgr::ReadModifiedCount(BOOL fUpdateMemory)
{
    DWORD dwChangeCount;
    DWORD *pdwChangeCount = fUpdateMemory ? &_dwModifiedCount : &dwChangeCount;

    _coContent->GetHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                             pdwChangeCount);
    return *pdwChangeCount;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::IncrementModifiedCount
----------------------------------------------------------------------------*/
void CConMgr::IncrementModifiedCount()
{
    DWORD dwLocModified;

    _coContent->IncrementHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                                   &dwLocModified);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::InitFixedContainers
----------------------------------------------------------------------------*/
DWORD CConMgr::InitFixedContainers()
{
    DWORD idx;
    DWORD dwError = ERROR_SUCCESS;
    BOOL fInitSucceeded = TRUE;

    //  Create and init
    _hMutexExtensible = OpenMutex(SYNCHRONIZE, FALSE, TEXT("_!MSFTHISTORY!_"));
    if (_hMutexExtensible == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        if (psa)
        {
            _hMutexExtensible = CreateMutex(psa, FALSE, TEXT("_!MSFTHISTORY!_"));
        }
    }
    if (_hMutexExtensible == NULL)
    {
        dwError = GetLastError();
        fInitSucceeded = FALSE;
        goto exit;
    }
    _dwLastUnmap = GetTickCountWrap();

    LOCK_CACHE();
    // Containers are configured. Attempt to initialize.
    for (idx = CONTENT; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            dwError = co->Init();

            // NOTE - URL_CONTAINER::Init() returns ERROR_ALREADY_EXISTS
            // only if the the existing memory mapped file has been opened
            // successfully. If the memory mapped file was created, upgraded
            // or corrupted (in both cases the mem mapped file will be reinited)
            // the return value will be ERROR_SUCCESS.

            if(dwError != ERROR_SUCCESS && dwError != ERROR_ALREADY_EXISTS)
            {
                fInitSucceeded = FALSE;
                goto unlock_exit;
            }

            // Has the container been created, upgrade or corrupted?
            if (dwError == ERROR_SUCCESS)
            {
                if(idx==CONTENT)
                {
                    // Preload the content container.
                    LoadContent();
                }
                else if (idx==COOKIE)
                {
                    CCookieLoader cl;
                    cl.LoadCookies(co);
                }
            }
            co->Release(FALSE);
        }

    }

    // Enable cachevu for CONTENT and HISTORY.
    EnableCacheVu(_coContent->GetCachePath(), CONTENT);
    EnableCacheVu(_coHistory->GetCachePath(), HISTORY);

unlock_exit:

    UNLOCK_CACHE();

exit:
    dwError = (fInitSucceeded ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR);
    if (!fInitSucceeded && _hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
        _hMutexExtensible = NULL;
    }
    INET_ASSERT(dwError == ERROR_SUCCESS);
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::LoadContent()
----------------------------------------------------------------------------*/
DWORD CConMgr::LoadContent()
{
    DWORD cbFile, dwError = ERROR_FILE_NOT_FOUND;
    CHAR  szPreloadKey[MAX_PATH],
          szUrl[MAX_PATH],
          szFile[MAX_PATH];

    // Preload registry key string.
    memcpy(szPreloadKey, OLD_CACHE_KEY, sizeof(OLD_CACHE_KEY) - 1);
    szPreloadKey[sizeof(OLD_CACHE_KEY)-1] = '\\';
    memcpy(szPreloadKey + sizeof(OLD_CACHE_KEY), "Preload", sizeof("PreLoad"));

    // Construct preload registry object.
    REGISTRY_OBJ roPreload(HKEY_CURRENT_USER, szPreloadKey);
    REGISTRY_OBJ roIE5Preload;
    if (roPreload.GetStatus() != ERROR_SUCCESS)
        goto exit;

    // Get the storage directory (cdf preload) to compare against to determine if we
    // need to set EDITED_CACHE_ENTRY or not. We assume any preload entry not in the
    // store dir IS and ECE.
    DWORD cb;
    CHAR szStorePath[MAX_PATH];

    // Store dir is hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szStorePath, MAX_PATH)))
    {
        AppendSlashIfNecessary(szStorePath, &cb);
        memcpy(szStorePath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1; //cb now equals size of szStorePath.
    }


    // Enum the registry url/file values and commit them
    // to the cache.
    while (roPreload.FindNextValue(szUrl, MAX_PATH,
        (LPBYTE) szFile, &(cbFile = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Strip off any file:// off the file path/name.
        CHAR* ptr = szFile;

        if (!strnicmp(ptr, "file://", sizeof("file://") - 1))
            ptr += sizeof("file://") - 1;

        AddUrlArg Args;
        memset(&Args, 0, sizeof(Args));
        Args.pszUrl      = szUrl;
        Args.pszFilePath = ptr;

        // If this is a Store entry, set the type to 0 else ECE
        if (!strnicmp(ptr, szStorePath, cb))
            Args.dwEntryType = 0;
        else
            Args.dwEntryType = EDITED_CACHE_ENTRY;

        _coContent->AddUrl(&Args);
    }


    if (roIE5Preload.WorkWith(&roPreload, "IE5Preload")!=ERROR_SUCCESS)
        goto exit;
        
    DWORD cbMaxUrl, cbMaxEntry, cbEntry;
    LPSTR pszUrl;
    URL_FILEMAP_ENTRY *pEntry;
    KEY_QUERY_INFO QueryInfo;

    if (ERROR_SUCCESS != roIE5Preload.GetKeyInfo(&QueryInfo))
        goto exit;
                
    cbMaxUrl = QueryInfo.MaxValueNameLen + 1;
    cbMaxEntry = QueryInfo.MaxValueLen + 1;
    
    pszUrl = new CHAR[cbMaxUrl];
    pEntry = (URL_FILEMAP_ENTRY*) new CHAR[cbMaxEntry];

    if (!(pszUrl && pEntry))
        goto exit;


    __try
    {
        
        while ((dwError = roIE5Preload.FindNextValue(pszUrl, cbMaxUrl,
            (LPBYTE) pEntry, &(cbEntry = cbMaxEntry))) == ERROR_SUCCESS)
        {
            FILETIME ft;
            AddUrlArg Args;
            memset(&Args, 0, sizeof(Args));

            // Url
            Args.pszUrl      = pEntry->UrlNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset) : NULL;
    
            // File path
            Args.pszFilePath = pEntry->InternalFileNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset) : NULL;

            // Header info
            Args.pbHeaders = pEntry->HeaderInfoOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset) : NULL;
            Args.cbHeaders = pEntry->HeaderInfoSize;

            // Last modified.
            Args.qwLastMod = pEntry->LastModifiedTime;

            // Expires time.
            DosTime2FileTime(pEntry->dostExpireTime, &ft);        
            Args.qwExpires = FT2LL(ft);

            // Post check time.
            DosTime2FileTime(pEntry->dostPostCheckTime, &ft);        
            Args.qwPostCheck = FT2LL(ft);

            // File creation time.
            DosTime2FileTime(pEntry->dostFileCreationTime, &ft);        
            Args.ftCreate = ft;
        
            // File extension.
            Args.pszFileExt = pEntry->FileExtensionOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset) : NULL;
 
            // Entry type.
            Args.dwEntryType = pEntry->CacheEntryType;

            // File size
            Args.dwFileSize = pEntry->dwFileSize;

            // Add the url.
            _coContent->AddUrl(&Args);
        }

    } // __try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = GetLastError();
    }
    ENDEXCEPT
     
    dwError = ERROR_SUCCESS;

    if (pszUrl)
        delete pszUrl;
    if (pEntry)
        delete pEntry;
        
exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
HANDLE CConMgr::FindFirstContainer
----------------------------------------------------------------------------*/
HANDLE CConMgr::FindFirstContainer(DWORD *pdwModified, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    CONTAINER_FIND_FIRST_HANDLE *pFind;
    DWORD dwContainers = 0;
    DWORD dwNames = 0;
    DWORD dwPrefixes = 0;
    DWORD dwLabels = 0;
    DWORD dwTitles = 0;
    DWORD dwTotal;
    HANDLE hFind = NULL;
    DWORD dwModified;

    GetExtensibleCacheConfigInfo(FALSE);

    LOCK_CACHE();
    dwModified = *pdwModified;
    *pdwModified = _dwModifiedCount;


    if ((CACHE_FIND_CONTAINER_RETURN_NOCHANGE & dwOptions) == 0 ||
        dwModified != *pdwModified)
    {
        for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
        {
            URL_CONTAINER *co = ConList.Get(i);
            if (co)
            {
                if (co->IsVisible())
                {
                    dwContainers++;
                    dwNames += strlen(co->GetCacheName()) + 1;
                    dwPrefixes += strlen(co->GetCachePrefix()) + 1;
                    dwLabels += strlen(co->GetVolumeLabel()) + 1;
                    dwTitles += strlen(co->GetVolumeTitle()) + 1;
                }
                co->Release(TRUE);
            }
        }

        dwTotal = sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                         dwContainers*(4 * sizeof(LPSTR)) +
                         (dwNames+dwPrefixes+dwLabels+dwTitles) * sizeof(char);

        hFind = HandleMgr.Alloc (dwTotal);
        if (hFind)
        {
            LPSTR ps;

            pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
            pFind->dwSignature = SIGNATURE_CONTAINER_FIND;
            pFind->dwContainer = 0;
            pFind->dwNumContainers = dwContainers;
            if (dwContainers)
            {
                pFind->ppNames = (LPTSTR *) (((LPBYTE) pFind) + sizeof(CONTAINER_FIND_FIRST_HANDLE));
                pFind->ppPrefixes = pFind->ppNames + dwContainers;
                pFind->ppLabels = pFind->ppPrefixes + dwContainers;
                pFind->ppTitles = pFind->ppLabels + dwContainers;
                ps = (LPSTR) (((LPBYTE) pFind) +
                                sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                                dwContainers*(4 * sizeof(LPSTR)));
                dwContainers = 0;

                for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
                {
                    URL_CONTAINER *co = ConList.Get(i);
                    if (co)
                    {
                        if (co->IsVisible())
                        {
                            pFind->ppNames[dwContainers] = ps;
                            strcpy(ps, co->GetCacheName());
                            ps += strlen(co->GetCacheName()) + 1;
                            pFind->ppPrefixes[dwContainers] = ps;
                            strcpy(ps, co->GetCachePrefix());
                            ps += strlen(co->GetCachePrefix()) + 1;
                            pFind->ppLabels[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeLabel());
                            ps += strlen(co->GetVolumeLabel()) + 1;
                            pFind->ppTitles[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeTitle());
                            ps += strlen(co->GetVolumeTitle()) + 1;

                            dwContainers++;
                        }
                        co->Release(TRUE);
                    }
                }

            }
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwError = ERROR_INTERNET_NO_NEW_CONTAINERS;
    }
    UNLOCK_CACHE();

    if (hFind)
    {
        if (FindNextContainer(hFind, lpContainerInfo, lpdwContainerInfoBufferSize))
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();
    }
    if( dwError != ERROR_SUCCESS )
    {
        FreeFindHandle(hFind);
        SetLastError(dwError);
        return NULL;
    }
    return hFind;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::FindNextContainer
----------------------------------------------------------------------------*/
BOOL CConMgr::FindNextContainer(HANDLE hFind, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize)
{
    // BUGBUG - this logic is borrowed from the original cachapia.cxx.

    DWORD                    dwError;
    CONTAINER_FIND_FIRST_HANDLE* pFind;

    // Map and validate the handle.
    LOCK_CACHE();
    pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
    UNLOCK_CACHE();
    if (!pFind || pFind->dwSignature != SIGNATURE_CONTAINER_FIND ||
        !lpContainerInfo ||
        *lpdwContainerInfoBufferSize < sizeof(INTERNET_CACHE_CONTAINER_INFOA))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Continue the enumeration.
    if (pFind->dwContainer < pFind->dwNumContainers)
    {
        DWORD cbName = strlen(pFind->ppNames[pFind->dwContainer])+1;
        DWORD cbPrefix = strlen(pFind->ppPrefixes[pFind->dwContainer])+1;
        DWORD cbLabel = strlen(pFind->ppLabels[pFind->dwContainer])+1;
        DWORD cbTitle = strlen(pFind->ppTitles[pFind->dwContainer])+1;

        DWORD cbTotal = cbName+cbPrefix+cbLabel+cbTitle+sizeof(INTERNET_CACHE_CONTAINER_INFOA);
        if (cbTotal > *lpdwContainerInfoBufferSize)
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            lpContainerInfo->lpszName = (LPSTR) (((LPBYTE) lpContainerInfo) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));
            lpContainerInfo->lpszCachePrefix = lpContainerInfo->lpszName + cbName;
            lpContainerInfo->lpszVolumeLabel = lpContainerInfo->lpszCachePrefix + cbPrefix;
            lpContainerInfo->lpszVolumeTitle = lpContainerInfo->lpszVolumeLabel + cbLabel;

            strcpy(lpContainerInfo->lpszName, pFind->ppNames[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszCachePrefix, pFind->ppPrefixes[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeLabel, pFind->ppLabels[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeTitle, pFind->ppTitles[pFind->dwContainer]);
            lpContainerInfo->dwCacheVersion = URL_CACHE_VERSION_NUM;
            pFind->dwContainer++;
            dwError = ERROR_SUCCESS;
        }
        *lpdwContainerInfoBufferSize = cbTotal;
    }
    else
    {
        dwError = ERROR_NO_MORE_ITEMS;
    }

exit:
    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetContainerInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetContainerInfo(LPSTR szUrl,
                               LPINTERNET_CACHE_CONTAINER_INFOA pCI,
                               LPDWORD pcbCI)
{
    URL_CONTAINER *co;
    DWORD dwError;

    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        DWORD cbName = strlen(co->GetCacheName()) + 1;
        DWORD cbPrefix = strlen(co->GetCachePrefix()) + 1;
        DWORD cbLabel = strlen(co->GetVolumeLabel()) + 1;
        DWORD cbTitle = strlen(co->GetVolumeTitle()) + 1;
        DWORD cbReq = cbName + cbPrefix + cbLabel + cbTitle;
        if (cbReq > *pcbCI)
        {
            *pcbCI = cbReq;
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            pCI->lpszName = (LPSTR) (((LPBYTE) pCI) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));

            pCI->lpszCachePrefix = pCI->lpszName + cbName;
            pCI->lpszVolumeLabel = pCI->lpszName + cbName + cbPrefix;
            pCI->lpszVolumeTitle = pCI->lpszName + cbName + cbPrefix + cbLabel;

            memcpy(pCI->lpszName, co->GetCacheName(), cbName);
            memcpy(pCI->lpszCachePrefix, co->GetCachePrefix(), cbPrefix);
            memcpy(pCI->lpszVolumeLabel, co->GetVolumeLabel(), cbLabel);
            memcpy(pCI->lpszVolumeTitle, co->GetVolumeTitle(), cbTitle);
            pCI->dwCacheVersion = URL_CACHE_VERSION_NUM;

            *pcbCI = cbReq;
            dwError = ERROR_SUCCESS;
        }

        co->Release(TRUE);
    }
    else
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
    }

    UNLOCK_CACHE();

    return dwError;
}

VOID CompressPath(PTSTR pszPath, PTSTR pszScratch);

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateContainer(LPCSTR Name, LPCSTR CachePrefix, LPCSTR CachePath, DWORD KBCacheLimit, DWORD dwOptions)
{
    BOOL fInsertOk = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];
    CHAR szDefaultPath[MAX_PATH];
    CHAR szCachePath[MAX_PATH];
    LONGLONG CacheStartUpLimit;
    HKEY hKey;
    DWORD cbKeyLen;

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = NULL;
    MUTEX_HOLDER mh;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    if (!CachePath || !*CachePath)
    {
        LPSTR p = _coHistory->GetCachePath();
        int len = _coHistory->GetCachePathLen();
        int clen = lstrlen(Name);

        if (len + clen + sizeof(DIR_SEPARATOR_STRING) > sizeof(szDefaultPath)) 
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
        memcpy(szDefaultPath, p, len);

        memcpy(&szDefaultPath[len], Name, clen);
        memcpy(&szDefaultPath[len + clen], DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    }
    else 
    {
        INET_ASSERT((CachePrefix && *CachePrefix));

        // For non-history containers, we need to stuff into the appropriate subcontainer
        // Assumption: Content cache never falls here.
        if (!GenerateStringWithOrdinal(CachePath, 
                                       GlobalIdentity, 
                                       szDefaultPath, 
                                       ARRAY_ELEMENTS(szDefaultPath)))
        {
            INET_ASSERT(FALSE);
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
    }
    CachePath = szDefaultPath;
    
    if (KBCacheLimit == 0)
    {
        CacheStartUpLimit = _coHistory->GetCacheStartUpLimit();
        KBCacheLimit = (DWORD) (CacheStartUpLimit / 1024);
    }


    if (!CachePrefix || !*CachePrefix || !CachePath || !*CachePath)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }   
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                // Path.
                TCHAR szScratch[MAX_PATH];
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch,&cbKeyLen) != ERROR_SUCCESS)
                    continue;

                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                if (!stricmp(szVendorKey, Name) || !stricmp(CachePath, szCachePath))
                {
                    fInsertOk = FALSE;
                    break;
                }
            }
        }   

        if (fInsertOk)
        {
            REGISTRY_OBJ roNewVendor(&roExtensibleCache, (LPSTR)Name, CREATE_KEY_IF_NOT_EXISTS);
            if (roNewVendor.GetStatus() == ERROR_SUCCESS)
            {
                CHAR szScratch[MAX_PATH];
                CompressPath((LPTSTR)CachePath, szScratch);
                    // Path.
                if ((dwError = roNewVendor.SetValue(CACHE_PATH_VALUE, (LPSTR)szScratch, REG_EXPAND_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Prefix.
                if ((dwError = roNewVendor.SetValue(CACHE_PREFIX_VALUE, (LPSTR)CachePrefix, REG_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Limit.
                if ((dwError = roNewVendor.SetValue(CACHE_LIMIT_VALUE, &KBCacheLimit)) != ERROR_SUCCESS)
                        goto exit;

                    // Options.
                if ((dwError = roNewVendor.SetValue(CACHE_OPTIONS_VALUE, &dwOptions)) != ERROR_SUCCESS)
                    goto exit;
            }
        }
        else
        {
            dwError = ERROR_ALREADY_EXISTS;
        }
    }

    if (fInsertOk)
    {
        IncrementModifiedCount();
    }

exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    if (fInsertOk)
    {
        GetExtensibleCacheConfigInfo(TRUE);
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::FindExtensibleContainer
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SECTION
DWORD CConMgr::FindExtensibleContainer(LPCSTR Name)
{
    DWORD n = NOT_AN_INDEX;
    DWORD i;
    URL_CONTAINER *co;

    for (i = NCONTAINERS; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (!stricmp(Name, co->GetCacheName()) && co->IsVisible())
            {
                // Found a match
                n = i;
                co->Release(FALSE);
                break;
            }
            co->Release(FALSE);
        }
    }

    return n;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteContainer(LPCSTR Name, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    URL_CONTAINER *co = NULL;
    DWORD n = NOT_AN_INDEX;
    HKEY hKey;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    LOCK_CACHE();
    n = FindExtensibleContainer(Name);
    if (n != NOT_AN_INDEX)
    {
        co = ConList.Get(n);

        if (co)
        {
            co->SetDeletePending(TRUE);
            //  Don't release here, hold it pending until we've updated registry
        }
    }
    UNLOCK_CACHE();

    if (n!= NOT_AN_INDEX)
    {
        hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);

        REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
        if (!pro)
        {
            dwError = ERROR_ACCESS_DENIED;
            goto exit;
        }
        
        {
            REGISTRY_OBJ& roExtensibleCache = *pro;
            MUTEX_HOLDER mh;
            mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);
            dwError = roExtensibleCache.DeleteKey((LPSTR)Name);
            mh.Release();
            IncrementModifiedCount();
        }
        delete pro;
    }

exit:
    LOCK_CACHE();
    SAFERELEASE(co, TRUE);
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteFileIfNotRegistered
----------------------------------------------------------------------------*/
BOOL CConMgr::DeleteFileIfNotRegistered(URL_CONTAINER *coDelete)
{
    BOOL fDelete = TRUE;
    BOOL fFound = FALSE;
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    DWORD dwOptions;
    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError;
    CHAR szVendorKey[MAX_PATH];

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
    MUTEX_HOLDER mh;
    
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    if (!WasModified(FALSE))
    {
        //  If our internal cache is up to date, it can't
        //  have been deleted unless DeletePending or Deleted
        fFound = !(coDelete->GetDeletePending()||coDelete->GetDeleted());
        if (fFound)
        {
            goto exit;
        }
        //  If not found, need to look at registry to make sure we're not
        //  deleting a path that has been reused
    }

    mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

    {
    REGISTRY_OBJ& roExtensibleCache = *pro;

     // Get the container paths, prefixes.
    while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
    {
        BOOL fPathMatch;
        REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
        if (roVendor.GetStatus()==ERROR_SUCCESS)
        {
            // Path.
            TCHAR szScratch[MAX_PATH];
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL

            // Prefix.
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PREFIX_VALUE,(LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            // Options.
            if (roVendor.GetValue(CACHE_OPTIONS_VALUE,&dwOptions) != ERROR_SUCCESS)
                continue;

            fPathMatch = !stricmp(coDelete->GetCachePath(), szCachePath);
            if (!stricmp(coDelete->GetCacheName(), szVendorKey) && fPathMatch &&
                !stricmp(coDelete->GetCachePrefix(), szCachePrefix) &&
                coDelete->GetOptions() != dwOptions)
            {
                fFound = TRUE;
            }
            if (fPathMatch)
                fDelete = FALSE;
        }
    }
    }
    if (fDelete)
    {
        //  This will fail if another process still has the container mapped,
        //  that's ok.  They will check on exit if container needs to be
        //  deleted
        if (coDelete->GetOptions() & INTERNET_CACHE_CONTAINER_AUTODELETE)
        {
            CFileMgr::DeleteCache(coDelete->GetCachePath());
        }
    }
exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    
    return !fFound;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindIndexFromPrefix
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
DWORD CConMgr::FindIndexFromPrefix(LPCSTR szUrl)
{
    // Unless we find a matching prefix, CONTENT is the default.
    DWORD n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
    URL_CONTAINER *co = NULL;

    //  NOTE: if deleting a container is supported, ConList.Get(i) can
    //  return NULL, if list shrinks after getting size.
    //  NOTE: if deleting containers is supported, it is not safe to
    //  assume CONTENT if prefix is not found.  client may be trying to
    //  insert into a container that has been deleted, but once existed.
    //  proper response is to return an error.  the simplest way to do this
    //  is to insist that all Extensible cache prefixes start with an illegal
    //  URL character, EXTENSIBLE_FIRST

    GetExtensibleCacheConfigInfo(FALSE);
    for (DWORD i = COOKIE; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (co->PrefixMatch(szUrl))
            {
                // For content container, strnicmp (szUrl, "", 0) returns nonzero
                if (co->IsVisible())
                {
                    // Found a match
                    n = i;
                    if (!co->IsInitialized())
                    {
                        // Init the container. If this fails,
                        // Mark it as DELETED and return CONTENT.
                        switch (co->Init())
                        {
                        case ERROR_SUCCESS:
                        case ERROR_ALREADY_EXISTS:
                            if (!(co->GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                                EnableCacheVu(co->GetCachePath(), n);
                            break;
                        default:
                            INET_ASSERT(FALSE);
                            co->SetDeleted(TRUE);
                            n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
                            break;
                        }
                    }
                    co->Release(FALSE);
                    break;
                }
            }
            co->Release(FALSE);
        }
    }
    return n;
}



/*-----------------------------------------------------------------------------
BOOL CConMgr::PathPrefixMatch
----------------------------------------------------------------------------*/
BOOL CConMgr::PathPrefixMatch(LPCSTR szPath, LPCSTR szPathRef)
{
    // BUGBUG - logic borrowed from original cacheapi.cxx

    INT len;

    // TRUE if the passed in path is NULL
    if (!szPath)
        return TRUE;

    len = lstrlen(szPath);

    // TRUE if it is 0 length.
    if (!len)
        return TRUE;

    // stripout the trailing slash
    if (szPath[len-1] == DIR_SEPARATOR_CHAR)
        --len;

    // Compare paths.
    if (!strnicmp(szPath, szPathRef, len))
        if (szPathRef[len] == DIR_SEPARATOR_CHAR || szPathRef[len] == 0)
            return TRUE;

    return FALSE;
}

/*---------------------  Public Functions -----------------------------------*/

/*-----------------------------------------------------------------------------
CConMgr::CConMgr

  Default Constructor
  ----------------------------------------------------------------------------*/
CConMgr::CConMgr()
: ConList()
{
    _coContent = NULL;
    _coCookies = NULL;
    _coHistory = NULL;
    _hMutexExtensible = 0;

    // Assume this is a profiles-capable machine. Later on, we'll make sure this is
    // the case.
    _fProfilesCapable = TRUE;

    // Assume that we'll be using the regular containers, instead of the backup
    _fUsingBackupContainers = FALSE;
    _dwStatus = Init();
}


/*-----------------------------------------------------------------------------
CConMgr::~CConMgr

  Default Destructor
  ----------------------------------------------------------------------------*/
CConMgr::~CConMgr()
{
    ConList.Free();
    if (_hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
    }
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetStatus()
----------------------------------------------------------------------------*/
DWORD CConMgr::GetStatus()
{
    return _dwStatus;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::UnlockUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::UnlockUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call UnlockUrl on the appropriate container.
        dwError = co->UnlockUrl(szUrl); // may be expensive
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call DeleteUrl on the appropriate container.
        dwError = co->DeleteUrl(szUrl); // may be expensive.
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::GetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::GetHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    return _coContent->GetHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::SetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::SetHeaderData(DWORD nIdx, DWORD dwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->SetHeaderData(nIdx, dwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::IncrementHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::IncrementHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->IncrementHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlGroup(
    IN LPCSTR   szUrl,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId
    )
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call SetUrlInGroup on the appropriate container.
        dwError = co->SetUrlGroup
            (szUrl, dwFlags, GroupId);
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateUniqueFile
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedSize,
                                       LPCSTR szFileExtension, LPTSTR szFileName,
                                       HANDLE *phfHandle,
                                       BOOL   fCreatePerUser)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);


    if (co)
    {
        UNLOCK_CACHE();
        // Call CreateUniqueFile on the appropriate container.
        dwError = co->CreateUniqueFile(szUrl, dwExpectedSize,
            szFileExtension, szFileName, phfHandle, fCreatePerUser); // expensive call
        LOCK_CACHE();

        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::AddUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::AddUrl(AddUrlArg* pArgs)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    DWORD idx = FindIndexFromPrefix(pArgs->pszUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call AddUrl on the appropriate container.
        dwError = co->AddUrl(pArgs); // may be expensive
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::RetrieveUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::RetrieveUrl( LPCSTR               szUrl,
                            LPCACHE_ENTRY_INFOA* ppCacheEntryInfo,
                            LPDWORD              pcbCacheEntryInfoBufferSize,
                            DWORD                dwLookupFlags,
                            DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call RetrieveUrl on the appropriate container.
        dwError = co->RetrieveUrl(szUrl,
                                  ppCacheEntryInfo,
                                  pcbCacheEntryInfoBufferSize,
                                  dwLookupFlags, dwRetrievalFlags); // expensive?
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInfo( LPCSTR               szUrl,
                           LPCACHE_ENTRY_INFOA*  ppCacheEntryInfo,
                           LPDWORD              pcbCacheEntryInfoBufferSize,
                           DWORD                dwLookupFlags,
                           DWORD                dwEntryFlags,
                           DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call GetUrlInfo on the appropriate container.
        dwError = co->GetUrlInfo(szUrl,
                                 ppCacheEntryInfo,
                                 pcbCacheEntryInfoBufferSize,
                                 dwLookupFlags,
                                 dwEntryFlags,
                                 dwRetrievalFlags);

        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::GetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          LPDWORD              pcbCacheEntryInfoBufferSize,
                          DWORD                dwLookupFlags,
                          DWORD                dwEntryFlags)
{
    return GetUrlInfo(szUrl,
                     (pCacheEntryInfo) ? &pCacheEntryInfo : NULL,
                     pcbCacheEntryInfoBufferSize,
                     dwLookupFlags,
                     dwEntryFlags,
                     0);
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          DWORD                dwFieldControl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call SetUrlInfo on the appropriate container.
        dwError = co->SetUrlInfo(szUrl,
                                 pCacheEntryInfo,
                                 dwFieldControl);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::FreeFindHandle(HANDLE hFind)
{
    DWORD dwError = ERROR_INVALID_HANDLE;

    if (hFind)
    {
        LOCK_CACHE();

        LPCACHE_FIND_FIRST_HANDLE pFind;
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
        if (pFind)
        {
            //  NOTHING SPECIAL TO DO FOR SIGNATURE_CONTAINER_FIND
            if (pFind->dwSig == SIG_CACHE_FIND && !pFind->fFixed)
            {
                URL_CONTAINER *co = ConList.Get(pFind->nIdx);
                if (co)
                {
                    //  It now has 2 AddRefs to balance
                    co->Release(FALSE);
                    co->Release(TRUE);
                }
            }

            HandleMgr.Free (hFind);
            dwError = ERROR_SUCCESS;
        }

        UNLOCK_CACHE();
    }
    
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextEntry
----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA*  ppInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags,
      DWORD                dwRetrievalFlags)
{
    DWORD                      idx, dwError;
    URL_CONTAINER             *co    = NULL;
    LPCACHE_FIND_FIRST_HANDLE  pFind = NULL;

    LOCK_CACHE();

    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // Allocate a handle.
        //LOCK_CACHE();
        *phFind = HandleMgr.Alloc (sizeof(CACHE_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig     = SIG_CACHE_FIND;
        pFind->dwHandle  = 0;
        pFind->dwFlags   = dwFlags;

        // Find the associated container. NULL prefix
        // results in enumeration over fixed containers.
        if (!szPrefix)
        {
            pFind->fFixed = TRUE;
            pFind->nIdx   = CONTENT;

        }
        else
        {

            idx = FindIndexFromPrefix(szPrefix);
            if (idx == NOT_AN_INDEX)
            {
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }

            // Under old semantics prefix resolving to CONTENT
            // container implies that an enumeration over all
            // the fixed containers is desired. Enumeration then
            // begins with the CONTENT container. We do not keep
            // a refcount on any fixed containers in this case.
            if (idx == CONTENT && (dwFlags & FIND_FLAGS_OLD_SEMANTICS))
            {
                pFind->fFixed = TRUE;
                pFind->nIdx   = CONTENT;
            }
            else
            {
                // Otherwise only enumeration over the found container
                // is implied. Retrieve this container. Set fFixed to FALSE.
                //  NO RELEASE: hold RefCnt until handle is closed
                co = ConList.Get(idx);

                if (co)
                {
                    pFind->fFixed   = FALSE;
                    pFind->nIdx     = idx;
                    pFind->dwHandle = co->GetInitialFindHandle();
                }
                else
                {
                    dwError = ERROR_NO_MORE_ITEMS;
                    goto exit;
                }
            }

        }
        // Set filter and group id in handle.
        pFind->dwFilter = dwFilter;
        pFind->GroupId  = GroupId;
    }
    else
    {
        // Valid handle passed in - map it.
        //LOCK_CACHE();
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    // -------------------------------------------------------------------------
    // The handle is initialized or was created via a previous FindNextEntry.
    //--------------------------------------------------------------------------

    dwError = ERROR_NO_MORE_ITEMS;

    // Are we only enumerating over one container?
    if (!pFind->fFixed)
    {
        // Get the associated container.
        co = ConList.Get(pFind->nIdx);

        if (co)
        {
            // Enum on the container and release.
            dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
            co->Release(TRUE);
        }
        else
        {
            // Getting container failed.
            dwError = ERROR_NO_MORE_ITEMS;
            goto exit;
        }

    }
    else
    {
        // fFixed is TRUE - enumerate over the fixed containers.
        while (pFind->nIdx < NCONTAINERS)
        {
            // Get the associated container.
            co = ConList.Get(pFind->nIdx);

            if (co)
            {
                // Get the initial hash find handle if not already done so.
                if (!pFind->dwHandle)
                    pFind->dwHandle = co->GetInitialFindHandle();

                // Enum on the container and release.
                dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
                co->Release(TRUE);

                // Goto exit only if ERROR_NO_MORE_ITEMS.
                // This handles ERROR_SUCCESS correctly.
                if (dwError != ERROR_NO_MORE_ITEMS)
                    goto exit;

                // ERROR_NO_MORE_ITEMS: Go to next container
                // and begin enum anew.
                pFind->nIdx++;
                pFind->dwHandle = 0;
            }
            else
            {
                // Getting container failed.
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }
        }
    }

exit:

    UNLOCK_CACHE();

    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA  pInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags)
{
    return FindNextEntry(
                phFind,
                szPrefix,
                (pInfo ? &pInfo : NULL),
                pcbInfo,
                dwFilter,
                GroupId,
                dwFlags,
                0);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CleanupUrls
----------------------------------------------------------------------------*/
DWORD CConMgr::CleanupUrls
    (LPCTSTR szCachePath, DWORD dwFactor, DWORD dwFilter)
{
    DWORD dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    // Bad cleanup parameter.
    if (dwFactor <= 0 || dwFactor > 100)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // For null or empty path, clean up content container.
    if (!szCachePath || !*szCachePath)
    {
        _coContent->CleanupUrls(dwFactor, dwFilter);
    }
    else
    {
        LOCK_CACHE();

        // Find the container with the matching cache path and clean it up.
        for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);

            if (co)
            {
                if (PathPrefixMatch(szCachePath, co->GetCachePath()))
                {
                    UNLOCK_CACHE();
                    co->CleanupUrls(dwFactor, dwFilter); // expensive?
                    LOCK_CACHE();
                    co->Release(TRUE);
                    break;
                }
                co->Release(TRUE);
            }
        }

        UNLOCK_CACHE();
    }

exit:
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInGroup(LPCSTR szUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call GetUrlInGroup on the appropriate container.
        dwError = co->GetUrlInGroup(szUrl, pGroupId, pdwExemptDelta);
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateGroup(dwFlags, pGID);
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateDefaultGroups()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateDefaultGroups()
{
    INET_ASSERT(_coContent); 

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateDefaultGroups();
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();
    GroupMgr gm;
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.DeleteGroup(gid, dwFlags);
    }

    UNLOCK_CACHE();

    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextGroup(
      HANDLE*                               phFind,
      DWORD                                 dwFlags,
      GROUPID*                              pGroupId
)
{
    DWORD                      dwError;
    GROUP_FIND_FIRST_HANDLE*   pFind = NULL;
    GroupMgr gm;

    INET_ASSERT(_coContent);
    LOCK_CACHE();


    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // BUGBUG currently only supports SEARCH_ALL option
        if( dwFlags )
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }


        // Allocate a handle.
        *phFind = HandleMgr.Alloc (sizeof(GROUP_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);

        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig  = SIG_GROUP_FIND;
        pFind->fFixed = TRUE;
        pFind->nIdx = CONTENT;
        pFind->dwLastItemOffset = 0;
    }
    else
    {
        // Valid handle passed in - map it.
        pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    //
    // The handle is initialized or was created via a previous FindNextEntry.
    //

    dwError = ERROR_FILE_NOT_FOUND;

    // Enum on the container and release.
    if( gm.Init(_coContent) )
    {
        DWORD dwLastItemOffset = pFind->dwLastItemOffset;

        dwError = gm.GetNextGroup(&dwLastItemOffset, pGroupId);

        // update offset field of the find handle
        pFind->dwLastItemOffset = dwLastItemOffset;

    }

exit:

    UNLOCK_CACHE();
    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo,
    LPDWORD                             lpdwGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent) )
    {
        dwError = gm.GetGroup(gid, dwAttrib, lpGroupInfo, lpdwGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::SetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_INTERNET_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent))
    {
        dwError = gm.SetGroup(gid, dwAttrib, lpGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


DWORD CConMgr::RegisterCacheNotify(
    HWND    hWnd,
    UINT    uMsg,
    GROUPID gid,
    DWORD   dwFilter
    )
{
    DWORD dwError;
    INET_ASSERT(_coContent);
    dwError = _coContent->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);
    return dwError;
}

DWORD CConMgr::SendCacheNotification( DWORD  dwOp)
{
    DWORD dwError;

    INET_ASSERT(_coContent);
    _coContent->SendCacheNotification(dwOp);
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
VOID CConMgr::GetCacheInfo
----------------------------------------------------------------------------*/
VOID CConMgr::GetCacheInfo(LPCSTR szPrefix, LPSTR szCachePath, LONGLONG *cbLimit)
{
    URL_CONTAINER *co;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szPrefix);
    
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call GetCacheInfo on the appropriate container.
        co->GetCacheInfo(szCachePath, cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}



/*-----------------------------------------------------------------------------
VOID CConMgr::SetCacheLimit
----------------------------------------------------------------------------*/
VOID CConMgr::SetCacheLimit(LONGLONG cbLimit, DWORD idx)
{
    URL_CONTAINER *co;
    // Find the associated container.

    UNIX_RETURN_IF_READONLY_CACHE;
    
    LOCK_CACHE();
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call SetCacheLimit on the container.
        co->SetCacheLimit(cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Contains debug functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#if DBG


#include <windows.h>
#include <winnt.h>

#include <stdlib.h>
#include <stdio.h>
#include <debug.h>



VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    );

extern BOOL UrlcacheDebugEnabled;

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    if (!UrlcacheDebugEnabled) {

        return;

    }

    va_start(arglist, Format);

    InternetDebugPrintValist(Format, arglist);

    va_end(arglist);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\cachedef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains data definitions for cache code.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _CACHEDEF_
#define _CACHEDEF_

//
// C++ inline code definition for retail build only.
//

#if DBG
#undef CHECKLOCK_NORMAL
#undef CHECKLOCK_PARANOID
#define INLINE
#else
#define INLINE      inline
#endif

#define PAGE_SIZE                        4096            // Grow memory mapped file by 1 page.
#define ALLOC_PAGES                      4               // was 2
#define HEADER_ENTRY_SIZE                ALLOC_PAGES * PAGE_SIZE
#define NORMAL_ENTRY_SIZE                128

#define DEFAULT_CLEANUP_FACTOR           10  // % free goal once cache quota exceeded
#define MAX_EXEMPT_PERCENTAGE            70

#define MEMMAP_FILE_NAME                 TEXT("index.dat")
#define DESKTOPINI_FILE_NAME             TEXT("desktop.ini")

#define DEFAULT_FILE_EXTENSION           ""

// Cache configuration and signature.
#define CACHE_SIGNATURE_VALUE           TEXT("Signature")
#define CACHE_SIGNATURE                 TEXT("Client UrlCache MMF Ver 5.2")
#define NUM_HEADER_DATA_DWORDS          (CACHE_HEADER_DATA_LAST + 1)
#define MAX_SIG_SIZE                     (sizeof(CACHE_SIGNATURE) / sizeof(TCHAR))

// The following values parametrize the schema for URL entries.
#define ENTRY_COPYSIZE_IE5    \
    (sizeof(IE5_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE5               0
#define ENTRY_COPYSIZE_IE6    \
    (sizeof(IE6_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE6               0x10

#define ENTRY_COPYSIZE_CURRENT          ENTRY_COPYSIZE_IE6
#define ENTRY_VERSION_CURRENT           ENTRY_VERSION_IE6

// If IE5-IE? sees an entry with low bits of version set, it will be placed
// on async fixup list rather than being destroyed.
#define ENTRY_VERSION_NONCOMPAT_MASK    0x0F


// Roundup
#define ROUNDUPTOPOWEROF2(bytesize, powerof2) (((bytesize) + (powerof2) - 1) & ~((powerof2) - 1))
#define ROUNDUPBLOCKS(bytesize) ((bytesize + NORMAL_ENTRY_SIZE-1) & ~(NORMAL_ENTRY_SIZE-1))
#define ROUNDUPDWORD(bytesize) ((bytesize + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1))
#define ROUNDUPPAGE(bytesize) ((bytesize + PAGE_SIZE-1) & ~(PAGE_SIZE-1))
#define NUMBLOCKS(bytesize) (bytesize / NORMAL_ENTRY_SIZE)

// Power of 2 macros
#define ISPOWEROF2(val) (!((val) & ((val)-1)))
#define ASSERT_ISPOWEROF2(val) INET_ASSERT(ISPOWEROF2(val))

#define URL_CACHE_VERSION_NUM  sizeof(CACHE_ENTRY_INFO);

// Default profiles directory under %SystemRoot%.
#define DEFAULT_PROFILES_DIRECTORY TEXT("Profiles")


//
// Registry key and value names for persistent URL management.
//

// BUGBUG - wasting space. 

#define MS_BASE TEXT("Software\\Microsoft")

#define CV_BASE MS_BASE TEXT("\\Windows\\CurrentVersion")

#define EX_BASE TEXT("\\Explorer")

#define IS_BASE TEXT("\\Internet Settings")

#define CACHE_T TEXT("\\Cache")

#define SHELL_FOLDER_KEY        CV_BASE EX_BASE TEXT("\\Shell Folders")
#define USER_SHELL_FOLDER_KEY   CV_BASE EX_BASE TEXT("\\User Shell Folders")
#define CACHE5_KEY              CV_BASE IS_BASE TEXT("\\5.0") CACHE_T
#define IDENTITIES_KEY          CV_BASE IS_BASE TEXT("\\5.0\\Identities") 
#define OLD_CACHE_KEY           CV_BASE IS_BASE CACHE_T
#define CACHE_PATHS_FULL_KEY    CV_BASE IS_BASE CACHE_T TEXT("\\Paths")
#define RUN_ONCE_KEY            CV_BASE TEXT("\\RunOnce")
#define PROFILELESS_USF_KEY     TEXT(".Default\\") USER_SHELL_FOLDER_KEY
#define CONTENT_CACHE_HARD_NAME TEXT("Content.IE5")
#define OLD_VERSION_KEY         MS_BASE TEXT("\\IE Setup\\SETUP")
#define OLD_VERSION_VALUE       TEXT("UpgradeFromIESysFile")


//
// Cache parameters
//
#ifndef unix
#define PATH_CONNECT_STRING                    TEXT("\\")
#define PATH_CONNECT_CHAR                      TEXT('\\')
#define ALLFILES_WILDCARD_STRING               TEXT("*.*")
#define UNIX_RETURN_IF_READONLY_CACHE 
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) 
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar)
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName)
#else
#define PATH_CONNECT_STRING                    TEXT("/")
#define PATH_CONNECT_CHAR                      TEXT('/')
#define ALLFILES_WILDCARD_STRING               TEXT("*")
#define UNIX_RETURN_IF_READONLY_CACHE   {                        \
                                           if (g_ReadOnlyCaches) \
                                              return;            \
                                        }
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) {                      \
                                                   if (g_ReadOnlyCaches)\
                                                      return (error);   \
                                               }
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar) \
                                        UnixNormalisePath(szOrigPath, szEnvVar);
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName) \
                      UnixNormaliseIfCachePath(szOrigPath, szEnvVar, szKeyName);

#define UNIX_SHARED_CACHE_PATH TEXT("%HOME%/.microsoft")
#endif /* !unix */

#define CACHE_PERSISTENT                TEXT("Persistent")

// Retrieval methods
#define RETRIEVE_WITHOUT_CHECKS     0
#define RETRIEVE_WITH_CHECKS        1
#define RETRIEVE_WITH_ALLOCATION    2
#define RETRIEVE_ONLY_FILENAME      4
#define RETRIEVE_ONLY_STRUCT_INFO   8
//
// Multiple URL containters can be configured under the above key such
// as :
//
//  Cache\Paths\Path1
//  Cache\Paths\Path2
//    ...
//
// Each containter will have the following two parameters.
//

// CConMgr related defines.
#define CACHE_PATHS_KEY                 TEXT("Paths")
#define CACHE_PATH_VALUE                TEXT("CachePath")
#define CACHE_PATH_VALUE_TYPE           REG_SZ
#define CACHE_LIMIT_VALUE               TEXT("CacheLimit")
#define CACHE_LIMIT_VALUE_TYPE          REG_DWORD
#define CACHE_OPTIONS_VALUE             TEXT("CacheOptions")
#define CACHE_OPTIONS_VALUE_TYPE        REG_DWORD
#define CACHE_PATCH_VALUE               TEXT("CacheRepair")
#define CACHE_PATCH_VALUE_TYPE          REG_DWORD

#define EXTENSIBLE_CACHE_PATH_KEY       "Extensible Cache"
#define CONTENT_PATH_KEY                "Content"
#define COOKIE_PATH_KEY                 "Cookies"
#define HISTORY_PATH_KEY                "History"
#define URL_HISTORY_KEY                 "Url History"

#define PER_USER_KEY                    "PerUserItem"
#define PROFILES_ENABLED_VALUE          "Network\\Logon"
#define PROFILES_ENABLED                "UserProfiles"
#define PROFILES_PATH_VALUE             CV_BASE "\\ProfileList"
#define PROFILES_PATH                   "ProfileImagePath"

#define CONTENT_PREFIX                  ""
#define COOKIE_PREFIX                   "Cookie:"
#define HISTORY_PREFIX                  "Visited:" 

#define CONTENT_VERSION_SUBDIR          "Content.IE5"
#define IE3_COOKIES_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\Cookies")
#define IE3_HISTORY_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\History")
#define IE3_PATCHED_USER_KEY            TEXT("Patched User")
#define CACHE_SPECIAL_PATHS_KEY         TEXT("Special Paths")
#define CACHE_DIRECTORY_VALUE           TEXT("Directory")
#define CACHE_DIRECTORY_TYPE            REG_EXPAND_SZ
#define CACHE_NEWDIR_VALUE              TEXT("NewDirectory")
#define CACHE_NEWDIR_TYPE               REG_EXPAND_SZ
#define CACHE_PREFIX_VALUE	            TEXT("CachePrefix")
#define CACHE_PREFIX_MAP_VALUE          "PrefixMap"
#define CACHE_VOLUME_LABLE_VALUE        "VolumeLabel"
#define CACHE_VOLUME_TITLE_VALUE        "VolumeTitle"
#define CACHE_PREFIX_TYPE               REG_SZ
#define NEW_DIR                         TEXT("NewDirectory")
#define USER_PROFILE_SZ                 "%USERPROFILE%"
#define USER_PROFILE_LEN                (sizeof(USER_PROFILE_SZ) - 1)

// URL_CONTAINER related defines.
#define DEF_NUM_PATHS                   4
#define DEF_CACHE_LIMIT                 (2048 * DEF_NUM_PATHS)
#define NO_SPECIAL_CONTAINER            0xffffffff
#define MAX_ENTRY_SIZE                  0xFFFF
#define LONGLONG_TO_FILETIME( _p_ )     ((FILETIME *)(_p_))

// Content limit defines.
#define OLD_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      64
#define NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      32
#define CONTENT_QUOTA_ADJUST_CHECK                   "QuotaAdjustCheck"

// CInstCon related defines.
#define INTERNET_CACHE_CONTAINER_PREFIXMAP INTERNET_CACHE_CONTAINER_RESERVED1
#define MAX_FILE_SIZE_TO_MIGRATE  50000
#define MAX_EXTENSION_LEN        3


// FileMgr related defines.
#define DEFAULT_DIR_TABLE_GROW_SIZE     4
#define DEFAULT_MAX_DIRS                32
#define MAX_FILES_PER_CACHE_DIRECTORY   1024
#define MAX_COLLISSION_ATTEMPTS         150
#define INSTALLED_DIRECTORY_KEY         0xFF
#define NOT_A_CACHE_SUBDIRECTORY        0XFE

#ifdef CHECKLOCK_PARANOID
void CheckEnterCritical(CRITICAL_SECTION *_cs);
void CheckLeaveCritical(CRITICAL_SECTION *_cs);
#define ENTERCRITICAL CheckEnterCritical
#define LEAVECRITICAL CheckLeaveCritical
#else
#define ENTERCRITICAL EnterCriticalSection
#define LEAVECRITICAL LeaveCriticalSection
#endif

// Cache global variable lock -- this should not be entered while holding
// lower-level locks like URL_CONTAINER::LockContainer cross-process mutex.
#define LOCK_CACHE()                    ENTERCRITICAL( &GlobalCacheCritSect )
#define UNLOCK_CACHE()                  LEAVECRITICAL( &GlobalCacheCritSect )

//
// parameter check macros.
//

#define IsBadUrl( _x_ )               IsBadStringPtrA( _x_, (DWORD) -1)
#define IsBadUrlW( _x_ )              IsBadStringPtrW( _x_, (DWORD) -1)
#define IsBadReadFileName( _x_ )      IsBadStringPtr( _x_, MAX_PATH )
#define IsBadWriteFileName( _x_ )     IsBadWritePtr( (PVOID)_x_, MAX_PATH)
#define IsBadWriteBoolPtr( _x_ )      IsBadWritePtr( _x_, sizeof(BOOL))
#define IsBadReadUrlInfo( _x_ )       IsBadReadPtr( _x_, sizeof(CACHE_ENTRY_INFO))
#define IsBadWriteUrlInfo( _x_, _y_ ) IsBadWritePtr( _x_, _y_ )

#define MAX_URL_ENTRIES                 (BIT_MAP_ARRAY_SIZE * sizeof(DWORD) * 8)

#define OFFSET_TO_POINTER( _ep_, _offset_) \
    (LPVOID)((LPBYTE)(_ep_) + (_offset_))


#define FIND_FLAGS_OLD_SEMANTICS                0x1
#define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2
#define FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME 0x04

//---------------- BUGBUG : for History Only -------------------------------
#define MAX_FILETIME   0x7fffffffffffffff
#define MAX_DOSTIME    -1
//---------------- END BUGBUG ----------------------------------------------


//
// ----------------- Allocation entry header -----------------------------//
//

#define SIG_FREE   0xbadf00d
#define SIG_ALLOC  0xdeadbeef

#define SIG_URL         ' LRU'   // URL_FILEMAP_ENTRY
#define SIG_REDIR       'RDER'   // REDR_FILEMAP_ENTRY
#define SIG_LEAK        'KAEL'   // URL_FILEMAP_ENTRY
#define SIG_GLIST       'GLST'   // LIST_GROUP_ENTRY

// signatures for entries placed on fixup list
#define SIG_UPDATE      ' DPU'   // URL_FILEMAP_ENTRY
#define SIG_DELETE      ' LED'   // URL_FILEMAP_ENTRY

enum MemMapStatus
{
    MEMMAP_STATUS_OPENED_EXISTING = 0,
    MEMMAP_STATUS_REINITIALIZED = 1
};

typedef struct FILEMAP_ENTRY
{
    DWORD dwSig;
    DWORD nBlocks;
}
    *LPFILEMAP_ENTRY;

struct LIST_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwNext; // offset to next element in list
    DWORD nBlock; // sequence number for this block
};

//
// URL entry
//

struct IE5_URL_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    LONGLONG LastModifiedTime;       // must be LONGLONG
    LONGLONG LastAccessedTime;       // should be DWORD
    DWORD    dostExpireTime;
    DWORD    dostPostCheckTime;

    DWORD    dwFileSize;
    DWORD    dwRedirHashItemOffset;  // ask DanpoZ

    DWORD    dwGroupOffset;

    union
    {
        DWORD  dwExemptDelta;   // for SIG_URL
        DWORD  dwNextLeak;      // for SIG_LEAK
    };
    
    DWORD    CopySize;               // should be WORD
    DWORD    UrlNameOffset;          // should be WORD
    
    BYTE     DirIndex;           // subdirectory bucket
    BYTE     bSyncState;         // automatic sync mode state
    BYTE     bVerCreate;         // cache version that created this entry
    BYTE     bVerUpdate;         // cache version last updated this entry (unused)
        
    DWORD    InternalFileNameOffset; // should be WORD
    DWORD    CacheEntryType;
    DWORD    HeaderInfoOffset;       // should be WORD
    DWORD    HeaderInfoSize;         // should be WORD
    DWORD    FileExtensionOffset;    // should be WORD
    DWORD    dostLastSyncTime;       
    DWORD    NumAccessed;            // should be WORD
    DWORD    NumReferences;          // should be WORD
    DWORD    dostFileCreationTime;   // should be LONGLONG?

// Do not extend this structure; use inheritance instead.
};

struct IE6_URL_FILEMAP_ENTRY : IE5_URL_FILEMAP_ENTRY 
{
    DWORD   dwIdentity;

    DWORD GetIdentity()
    {
        return (bVerCreate>=ENTRY_VERSION_IE6) ? dwIdentity : 0;
    }
};

typedef IE6_URL_FILEMAP_ENTRY URL_FILEMAP_ENTRY, *LPURL_FILEMAP_ENTRY;

// FILETIME is measured in 100-ns units.
#define FILETIME_SEC    ((LONGLONG) 10000000)
#define FILETIME_DAY    (FILETIME_SEC * 60 * 60 * 24)

// Possible values for bSyncState:
#define SYNCSTATE_VOLATILE   0 // once zero, stuck at zero
#define SYNCSTATE_IMAGE      1 // eligible to increment after MIN_AGESYNC
#define SYNCSTATE_STATIC     6 // max value

// Parameters controlling transition from _IMAGE to _VOLATILE.
// #define MIN_AGESYNC  ((LONGLONG) 5 * 60 * 10000000)  // 5 min in filetime
#define MIN_AGESYNC     (FILETIME_DAY * 7)

//
// Redirect Entry
//

struct REDIR_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwItemOffset;  // offset to hash table item of destination URL
    DWORD dwHashValue;   // destination URL hash value (BUGBUG: collisions?)
    char  szUrl[4];      // original URL, can occupy more bytes
};

//
// Group Record
//

typedef struct GROUP_ENTRY
{
    GROUPID  gid;
    DWORD    dwGroupFlags;
    DWORD    dwGroupType;
    LONGLONG llDiskUsage;       // in Bytes (Actual Usage)
    DWORD    dwDiskQuota;       // in KB
    DWORD    dwGroupNameOffset;
    DWORD    dwGroupStorageOffset;
}
    *LPGROUP_ENTRY;


#define PAGE_SIZE_FOR_GROUPS    (PAGE_SIZE - sizeof(FILEMAP_ENTRY))
#define GROUPS_PER_PAGE         PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_ENTRY)

typedef struct _GROUP_DATA_ENTRY
{
    CHAR    szName[GROUPNAME_MAX_LENGTH];
    DWORD   dwOwnerStorage[GROUP_OWNER_STORAGE_SIZE];
    DWORD   dwOffsetNext;
} GROUP_DATA_ENTRY, *LPGROUP_DATA_ENTRY;

#define GROUPS_DATA_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_DATA_ENTRY)

//
// so the sizeof(GROUPS_PAGE_FILEMAP_ENTRY) = PAGE_SIZE
// this is the allocation unit for groups entry
//
typedef struct _GROUPS_ALLOC_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    BYTE    pGroupBlock[PAGE_SIZE_FOR_GROUPS];    
} GROUPS_ALLOC_FILEMAP_ENTRY, *LPGROUPS_ALLOC_FILEMAP_ENTRY;


typedef struct _LIST_GROUP_ENTRY 
{
    DWORD   dwGroupOffset;
    DWORD   dwNext;

} LIST_GROUP_ENTRY, *LPLIST_GROUP_ENTRY;

#define LIST_GROUPS_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(LIST_GROUP_ENTRY)


#define SIGNATURE_CONTAINER_FIND 0xFAFAFAFA
#define SIG_CACHE_FIND 0XFBFBFBFB
#define SIG_GROUP_FIND 0XFCFCFCFC

typedef struct _CONTAINER_FIND_FIRST_HANDLE 
{
    DWORD dwSignature;
    DWORD dwNumContainers;
    DWORD dwContainer;
    LPSTR *ppNames;
    LPSTR *ppPrefixes;
    LPSTR *ppLabels;
    LPSTR *ppTitles;
    // DATA follows for Names, Prefixes, Volume labels and Volume titles.
} CONTAINER_FIND_FIRST_HANDLE, *LPCONTAINER_FIND_FIRST_HANDLE;

typedef struct _CACHE_FIND_FIRST_HANDLE 
{
    DWORD dwSig;
    BOOL  fFixed;
    DWORD nIdx;
    DWORD dwHandle;
    GROUPID GroupId;
    DWORD dwFilter;
    DWORD dwFlags;
} CACHE_FIND_FIRST_HANDLE, *LPCACHE_FIND_FIRST_HANDLE;

typedef struct _CACHE_STREAM_CONTEXT_HANDLE 
{
    HANDLE FileHandle;
    LPSTR SourceUrlName;
}  CACHE_STREAM_CONTEXT_HANDLE, *LPCACHE_STREAM_CONTEXT_HANDLE;

typedef struct _GROUP_FIND_FIRST_HANDLE : CACHE_FIND_FIRST_HANDLE
{
    DWORD dwLastItemOffset;
} GROUP_FIND_FIRST_HANDLE, *LPGROUP_FIND_FIRST_HANDLE;

#define OFFSET_NO_MORE_GROUP    -1
#define GID_INDEX_TO_NEXT_PAGE	-1
#define OFFSET_TO_NEXT_PAGE     -1

#define GID_MASK            0x0fffffffffffffff
#define GID_STICKY_BIT      0x1000000000000000

#define IsStickyGroup(gid)  (gid & GID_STICKY_BIT)
#define SetStickyBit(gid)   (gid | GID_STICKY_BIT)
#define IsInvalidGroup(gid) (gid & 0xE000000000000000)

//
// RealFileSize() - given the actual filesize,
// this macro computes the approximate real space that a file takes up
// on the disk. It only takes care of rounding to the cluster size
// It doesn't take into account any per-file overhead used in the filesystem
//

#define RealFileSize(fs)  ((LONGLONG) (fs + _ClusterSizeMinusOne) & _ClusterSizeMask)

#define MUTEX_DBG_TIMEOUT   5 * 1000    // 5 secs.

#define URLCACHE_OP_SET_STICKY   1
#define URLCACHE_OP_UNSET_STICKY 2

#ifdef unix
extern BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost);
extern BOOL DeleteAtomicCacheLockFile();
extern void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar);
extern void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,LPCTSTR szKeyName);
extern int  CopyDir(const char* src_dir, const char* dest_dir);
#endif /* unix */

extern VOID FileTime2DosTime(FILETIME, DWORD*);
extern VOID DosTime2FileTime(DWORD, FILETIME*);

#endif  // _CACHEDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\cachecfg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cachecfg.cxx

Abstract:

    This module contains the functions to get and set disk cache
    configuration parameters.

    Contents:
        GetCacheConfigInfoA
        SetCacheConfigInfoA

Author:

    Sophia Chung (sophiac)  1-May-1995
    
Environment:

    User Mode - Win32

Revision History:
    Mucho rewritten by Akabir   1Q 98

    To understand how the new registration code works, it might be better for you to start with ConfigureCache, 
    GetCacheConfigInfo, etc. for a high level acquaintance; _then_ start poring over the actual registry sets code.
--*/

#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <shlobj.h>

#define CACHE_TAG           "Cache"

// Cache path keys.
CHAR* g_szSubKey[] = {CONTENT_PATH_KEY, COOKIE_PATH_KEY, HISTORY_PATH_KEY};
CHAR* g_szOldSubKey[] = {CACHE_TAG, COOKIE_PATH_KEY, HISTORY_PATH_KEY};

INT g_iContainerCSIDL[] = { CSIDL_INTERNET_CACHE, CSIDL_COOKIES, CSIDL_HISTORY };
                                
// Top level cache paths resource IDs
#ifndef UNIX
DWORD g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#else
DWORD g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR_UNIX, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#endif /* UNIX */

// Cache prefixes.
CHAR* g_szCachePrefix[] = {CONTENT_PREFIX, COOKIE_PREFIX, HISTORY_PREFIX};
CHAR* g_szVersionName[] = { CONTENT_VERSION_SUBDIR, "", "History.IE5" };

#define OLD_CACHE_PATH      "Path1"
#define OLD_CACHE_SUBKEY    DIR_SEPARATOR_STRING##"Cache1"

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

void FlushShellFolderCache()
{
    SHFlushSFCacheWrap( );
    return;
}

typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);

VOID CheckCacheLocationConsistency();

//#define DEBUG_CACHE_UPGRADE

#ifdef DEBUG_CACHE_UPGRADE
VOID LOG_UPGRADE_DATA(PTSTR pszData)
{
    CHAR szFileName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    CHAR szComputerName[MAX_PATH];
    HANDLE hResultsFile = NULL;
    strcpy(szFileName, "\\\\BANYAN\\IPTD\\AKABIR\\cacheupgrade\\");
    if (!GetComputerNameA(szComputerName, &dwSize))
    {
        goto exit;
    }
    lstrcatA(szFileName, szComputerName);
    hResultsFile = CreateFileA( szFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL);
    if (hResultsFile != INVALID_HANDLE_VALUE)
    {
        if (SetFilePointer(hResultsFile, 0, NULL, FILE_END)==0xFFFFFFFF)
        {
            goto exit;
        }
        DWORD dwFoo;
        if (0==WriteFile(hResultsFile, (PVOID)pszData, lstrlenA(pszData), &dwFoo, NULL))
        {
            DWORD dwE = GetLastError();
        }
    }
exit:
    if (hResultsFile)
    {
        CloseHandle(hResultsFile);
    }
}
#else
#define LOG_UPGRADE_DATA(x)
#endif

#undef SHGetFolderPath

HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath)
{
    HRESULT hr = E_POINTER;
    static PFNSHGETFOLDERPATH pfn = NULL;

    if (NULL == pfn)
    {
        if (NULL == g_HMODShell32)
            g_HMODShell32 = LoadLibrary("shell32.dll");
        if (NULL != g_HMODShell32)
            pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODShell32, "SHGetFolderPathA");

        if (NULL == pfn)
        {
            if (NULL == g_HMODSHFolder)
                g_HMODSHFolder = LoadLibrary("shfolder.dll");
            if (NULL != g_HMODSHFolder)
                pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODSHFolder, "SHGetFolderPathA");
        }
        
        if (NULL != pfn)
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
    }
    else
        hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);

    return hr;
}

#define CACHE_SIZE_CAP 32000000

DWORD 
GetDefaultCacheQuota(
    LPSTR pszCachePath, 
    DWORD dwFraction
    )
{ 
    DWORDLONG cKBLimit = 0, cbTotal;

    if (GetDiskInfo(pszCachePath, NULL, NULL, &cbTotal))
    {
        cKBLimit = (cbTotal / (DWORDLONG)(1024*dwFraction));
    }
    if (cKBLimit<1024)
    {
        cKBLimit = DEF_CACHE_LIMIT;
    }
    else if (cKBLimit > CACHE_SIZE_CAP)
    {
        cKBLimit = CACHE_SIZE_CAP;
    }

    return (DWORD)cKBLimit;
}
        
VOID CleanPath(PTSTR pszPath);

/*-----------------------------------------------------------------------------
NormalisePath
 (code swiped from shell32\folder.c: UnexpandEnvironmentstring)

  Collapses paths of the form C:\foobar\dir1\...\dirn to
  %FOOBAR%\dir1\...\dirn
  where %FOOBAR% = "C:\foobar".
  storing result in pszOut.

  If collapse is not possible, returns FALSE and path is unchanged.
  If the given environment variable exists as the first part of the path,
  then the environment variable is inserted into the output buffer.

  Returns TRUE if pszResult is filled in.
  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SystemRoot%
            Output -- %SystemRoot%\SYSTEM32\FOO.TXT

---------------------------------------------------------------------------*/


BOOL NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
    TCHAR szEnvVar[MAX_PATH];
//     DWORD dwEnvVar = ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)) - 1; // don't count the NULL
//    akabir: a curious bug? causes ExpandEnvironmentStrings to return twice the number of characters.

    ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1); // don't count the NULL
    DWORD dwEnvVar = lstrlen(szEnvVar);

    if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2) 
    {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
            strncpy(pszResult, pszEnvVar, MAX_PATH);
            strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
            return TRUE;
        }
    }
    return FALSE;
}

VOID CompressPath(LPTSTR pszSrc, LPTSTR pszDest)
{
    if (!NormalisePath(pszSrc, TEXT("%USERPROFILE%"), pszDest, MAX_PATH))
    {
        if (!NormalisePath(pszSrc, TEXT("%SystemRoot%"), pszDest, MAX_PATH))
        {
            strncpy(pszDest, pszSrc, MAX_PATH);
        }
    }
}

// ------------------------------------------------------------------------------------------------
// IE 3, 4 and 5 have different registry settings. These classes help ensure they all stay in sync.


// -- IE5's registry set ------------------------------------------------------------------------------------------------
// *** If using multiple registry sets, use InitialiseKeys for IE5 first.***
// This is to ensure that profiles-capabilities are noted.

class IE5_REGISTRYSET
{
protected:
    REGISTRY_OBJ m_roHKLMCache, m_roHKCUCache, m_roShellFolder, m_roUserShellFolder, m_roWorking;
    BOOL m_fProfiles;
    BOOL m_fWorkingPerUser;
    TCHAR m_szSharedPath[MAX_PATH];
    TCHAR m_szProfilePath[MAX_PATH];
    DWORD cbP, cbS, m_dwWorking;
    BOOL m_fInitialised;
    
    DWORD InitCommonKeys(BOOL fProfilesCapable, LPSTR pszReg)
    {
        DWORD dwError, dwFlag = CREATE_KEY_IF_NOT_EXISTS;

        m_fProfiles = fProfilesCapable;
        // Shared item info are located in HKLM/[...]/Internet Settings/5.0/Cache/*
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag);
        if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
        {
            m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag, BASIC_ACCESS);
            if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roShellFolder.WorkWith(HKEY_CURRENT_USER, SHELL_FOLDER_KEY, dwFlag);
        if (dwError = m_roShellFolder.GetStatus()!=ERROR_SUCCESS)
                goto exit;

        if (fProfilesCapable)
        {
            m_roHKCUCache.WorkWith(HKEY_CURRENT_USER, pszReg, dwFlag);
            if (dwError = m_roHKCUCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roUserShellFolder.WorkWith(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY, dwFlag);
        dwError = m_roUserShellFolder.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            m_fInitialised = TRUE;
        }
        // Per-user items are located in HKCU/[...]/Explorer/Shell Folders and /Internet Settings/[5.0/]Cache/*
    exit:
        return dwError;
    }

    virtual BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        // Determine if this is a per-user item
        // HKCU overrides HKLM
        // If any of the following fail, for content, we'll default to shared.

        if (!m_fProfiles)
        {
            return FALSE;    
        }
        
        DWORD dwTemp;
        REGISTRY_OBJ roCUContainer(&m_roHKCUCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        if ((roCUContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roCUContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }
        
        REGISTRY_OBJ roLMContainer(&m_roHKLMCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        BOOL fPerUser = FALSE;

        if ((roLMContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roLMContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }  

        // On NT, the default will be a per-user container.
#ifndef UNIX
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : (dwWhich!=CONTENT);
#else
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_UNIX) ? TRUE : (dwWhich!=CONTENT);
#endif /* UNIX */

        roLMContainer.SetValue(PER_USER_KEY, &dwTemp);
        roCUContainer.SetValue(PER_USER_KEY, &dwTemp);
        return (BOOL)dwTemp;
    }


    // -- ValidatePath ------
    // We always assume we've been given a valid path, but we have to test that it's there
    // and available.
    BOOL ValidatePath(PSTR pszPath)
    {
        DWORD dwAttribute = GetFileAttributes(pszPath);
        if (dwAttribute==0xFFFFFFFF)
        {
            // We assume that the directory just isn't there. So we create it.
            hConstructSubDirs(pszPath);
            dwAttribute = GetFileAttributes(pszPath);
        }
        if ((dwAttribute==0xFFFFFFFF)
            ||
            (dwAttribute & FILE_ATTRIBUTE_READONLY)
            ||
            (!(dwAttribute & FILE_ATTRIBUTE_DIRECTORY)))
        {
            // BUG BUG BUG We probably want to make sure that the old path gets deleted on other machines....
            // We'll use the system path
            // BUG BUG BUG BUG BUG We are *NOT* recording this default location in the registry. Thus, on another
            // machine, the user might still be able to use the set cache location.
            memcpy(pszPath, m_szSharedPath, cbS);
            LoadString(GlobalDllHandle, g_dwCachePathResourceID[m_dwWorking], pszPath+cbS, MAX_PATH - cbS);
            SetPerUserStatus(FALSE);
        }
        return ERROR_SUCCESS;
    }
    
public:
    IE5_REGISTRYSET()
    {
        m_fInitialised = FALSE;
    }

    virtual DWORD InitialiseKeys(BOOL& fProfilesCapable)
    {
        if (m_fInitialised)
        {
            fProfilesCapable = m_fProfiles;
            return ERROR_SUCCESS;
        }

        DWORD dwError = ERROR_SUCCESS;

        fProfilesCapable = TRUE;
#ifndef UNIX
        cbS = GetWindowsDirectory(m_szSharedPath, sizeof(m_szSharedPath));
#else
        /* On Unix, GetWindowsDirectory points to <install dir>/common
         * And, we don't want to put the cache here.
         */
        lstrcpy(m_szSharedPath, UNIX_SHARED_CACHE_PATH);
        cbS = lstrlen(m_szSharedPath);
#endif /* UNIX */
        if (!cbS || (cbS>sizeof(m_szSharedPath)))
            return ERROR_PATH_NOT_FOUND;
            
        AppendSlashIfNecessary(m_szSharedPath, &cbS);

        cbP = 0;
        // We think that profiles are enabled, so we want to get some info before
        // proceeding. If any of this fails, though, we'll default to no profiles.
        switch (GlobalPlatformType)
        {
#ifndef UNIX
        case PLATFORM_TYPE_WIN95:
        {
            REGISTRY_OBJ roProfilesEnabled(HKEY_LOCAL_MACHINE, PROFILES_ENABLED_VALUE);
            DWORD dwProfilesEnabled = 0;
            if (  (roProfilesEnabled.GetStatus() == ERROR_SUCCESS)
                && 
                  ((roProfilesEnabled.GetValue(PROFILES_ENABLED, &dwProfilesEnabled))==ERROR_SUCCESS)
                &&
                  dwProfilesEnabled)
            {                        
                  // Windows 95 sets the profiles path in the registry.
                CHAR szProfilesRegValue[MAX_PATH];
                memcpy(szProfilesRegValue, PROFILES_PATH_VALUE, sizeof(PROFILES_PATH_VALUE)-1);
                cbP = sizeof(PROFILES_PATH_VALUE)-1;
                AppendSlashIfNecessary(szProfilesRegValue, &cbP);
                cbP = MAX_PATH-sizeof(PROFILES_PATH_VALUE);
                if (GetUserName(szProfilesRegValue + sizeof(PROFILES_PATH_VALUE), &cbP))
                {
                    cbP = MAX_PATH;
                    REGISTRY_OBJ roProfilesDirKey(HKEY_LOCAL_MACHINE, szProfilesRegValue);

                    if (!(((dwError = roProfilesDirKey.GetStatus()) != ERROR_SUCCESS)
                        || 
                        ((dwError = roProfilesDirKey.GetValue(PROFILES_PATH, (LPBYTE) m_szProfilePath, 
                                &cbP)) != ERROR_SUCCESS)))
                    {
                        m_szProfilePath[cbP-1] = DIR_SEPARATOR_CHAR;
                        m_szProfilePath[cbP] = '\0';
                        break;
                    }
                }
            }
            // Either
            // (a) Couldn't get the profiles path from the registry.
            // (b) Couldn't get the user name! 
            // Make the directory the windows directory
            fProfilesCapable = FALSE;
            break;
        }
            
        case PLATFORM_TYPE_WINNT:
            // Windows NT sets the USERPROFILE environment
            // string which contains the user's profile path
            if (cbP = GetEnvironmentVariable("USERPROFILE", m_szProfilePath, MAX_PATH))
            {
                m_szProfilePath[cbP++] = DIR_SEPARATOR_CHAR;
                m_szProfilePath[cbP] = '\0';
            }
            else
            {
                INET_ASSERT(FALSE);
                // Getting the user profiles dir from the environment
                // failed. Set the profiles directory to default.
                memcpy(m_szProfilePath, m_szSharedPath, cbS);
                memcpy(m_szProfilePath + cbS, DEFAULT_PROFILES_DIRECTORY, sizeof(DEFAULT_PROFILES_DIRECTORY));
                cbP = cbS + sizeof(DEFAULT_PROFILES_DIRECTORY) - 1;

                DWORD cbUser = MAX_PATH - cbP;;
                GetUserName(m_szProfilePath + cbP, &cbUser);
                cbP += cbUser;
            }
            break;

#else /* UNIX */
        case PLATFORM_TYPE_UNIX:
            lstrcpy(m_szProfilePath,TEXT("%USERPROFILE%"));
            lstrcat(m_szProfilePath,DIR_SEPARATOR_STRING);
            cbP = lstrlen(m_szProfilePath);
            break;
#endif /* UNIX */

        default:
            // This should never happen.
            INET_ASSERT(FALSE);
        }

        if (dwError==ERROR_SUCCESS)
        {
            dwError = InitCommonKeys(fProfilesCapable, CACHE5_KEY);
        }
        return dwError;
    }

    DWORD SetWorkingContainer(DWORD dwWhich)
    {
        m_dwWorking = dwWhich;
        m_fWorkingPerUser = DetermineKeyPlacing(dwWhich);
        return m_roWorking.WorkWith((m_fWorkingPerUser ? &m_roHKCUCache : &m_roHKLMCache), g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
    }

    VOID AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit);

    // Path --------------------------------------------------------------------------
    virtual DWORD GetPath(PTSTR pszPath)
    {
        if ((S_OK==SHGetFolderPath(NULL, g_iContainerCSIDL[m_dwWorking] | CSIDL_FLAG_CREATE, NULL, 0, pszPath))
            && (*pszPath!='\0'))
        {
            DWORD dwErr = ValidatePath(pszPath);
            if (dwErr==ERROR_SUCCESS)
            {
                DWORD ccPath = lstrlen(pszPath);
                // We check the lengths of the strings only when we're moving the containers. No need to do the check every
                // time (assume a valid path)
                if (m_dwWorking!=COOKIE)
                {
                    EnableCacheVu(pszPath, m_dwWorking);
                }
                AppendSlashIfNecessary(pszPath, &ccPath);

#ifdef UNIX
               /* On Unix, it is possible that IE4 and IE5 co-exist on a user's
                * installation. So, we need to keep the IE4 cookies which are
                * different from the IE5 cookies. For IE5, we have the following
                * configuration for the caches -
                *
                * cookies - %HOME%/.microsoft/ie5/Cookies
                * content - %HOME%/.microsoft/ie5/TempInternetFiles/Content.IE5
                * history - %HOME%/.microsoft/ie5/History/History.IE5
                */
               CHAR szIE5Dir[] = "ie5/";
               int  index = ccPath-2; // skip the last slash
               int  lenIE5Dir = lstrlen(szIE5Dir);

               while(index >= 0 && pszPath[index] != FILENAME_SEPARATOR) 
                    index--;

               index++;
               memmove(&pszPath[index+lenIE5Dir],&pszPath[index],ccPath-index+2);
               memcpy(&pszPath[index],szIE5Dir,lenIE5Dir);
               ccPath += lenIE5Dir;
#endif /* UNIX */

                memcpy(pszPath+ccPath, g_szVersionName[m_dwWorking], lstrlen(g_szVersionName[m_dwWorking])+1);
                if (GlobalIdentity && (m_dwWorking!=CONTENT))
                {
                    if (!GenerateStringWithOrdinal(NULL, GlobalIdentity, pszPath, MAX_PATH))
                    {
                        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
                    }
                }
            }
            return dwErr;
        }
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    virtual DWORD SetPath(PTSTR pszPath)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        DWORD dwError;

        /* Try to preserve the environment variables on Unix */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));
        if (m_fProfiles)
        {
            CHAR szScratch[MAX_PATH];
            CompressPath(pszPath, szScratch);
            if ((dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szScratch, REG_EXPAND_SZ))==ERROR_SUCCESS)
            {
#ifndef UNIX
               DWORD dwType = REG_SZ;
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
#else
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
            }
            // Possible BUG: If we move from the profiled path to the shared path, we still record it as a peruseritem.
            SetPerUserStatus(TRUE);            
        }
        // Non-profiles-enabled machine
        // On Win9x machines, with profiles disabled, we need to write the path to the 
        // HKEY_USERS/.default/blah blah/Explorer/User Shell Folders to ensure that SHGetFolderPath returns
        // the proper value for other users. 
        else
        {
            REGISTRY_OBJ roProfilesLessPath(HKEY_USERS, PROFILELESS_USF_KEY);
            dwError = roProfilesLessPath.GetStatus();
            if (dwError==ERROR_SUCCESS)
            {
                if ((dwError = roProfilesLessPath.SetValue(g_szOldSubKey[m_dwWorking],pszPath, REG_EXPAND_SZ))==ERROR_SUCCESS)
                {
#ifndef UNIX
                    DWORD dwType = REG_SZ;
#else
                    DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */
                    dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
                }
            }
            // For IE4 compatibility, we might have to adjust the old cache location here, as well.
        }
        return dwError;
    }


    // Prefix ------------------------------------------------------------------------
    virtual DWORD GetPrefix(LPSTR szPrefix)
    {
        DWORD dwError, cbKeyLen = MAX_PATH;
        if ((dwError = m_roWorking.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szPrefix, &cbKeyLen))==ERROR_SUCCESS)
        {
            if (cbKeyLen > 0)
            {
                // Strip trailing whitespace.
                cbKeyLen--;
                StripTrailingWhiteSpace(szPrefix, &cbKeyLen);
            }
        }
        else
        {
            // If no prefix found in registry create via
            // defaults and write back to registry.
            strncpy(szPrefix, g_szCachePrefix[m_dwWorking], MAX_PATH);
            SetPrefix(szPrefix);
            dwError = ERROR_SUCCESS;
        }
        
        return dwError;
    }

    virtual DWORD SetPrefix(PTSTR pszPrefix)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        return m_roWorking.SetValue(CACHE_PREFIX_VALUE, (pszPrefix) ? pszPrefix : g_szCachePrefix[m_dwWorking], REG_SZ);
    }

    // Limit -------------------------------------------------------------------------
    virtual DWORD GetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        if ((m_roWorking.GetValue(CACHE_LIMIT_VALUE, &cbLimit)!=ERROR_SUCCESS) || (cbLimit < 512))
        {
            cbLimit = 0;
            return SetLimit(pszCachePath, cbLimit);
        }
        return ERROR_SUCCESS;
    }

    virtual DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit);

    // Use IsFirstTime* to figure out if this is the first time for this install of wininet and for marking it so ------------
private:
    BOOL IsFirstTimeFor(HKEY hKey)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig(hKey, CACHE5_KEY);

        return roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS ? 
                        strcmp(szSigKey, CACHE_SIGNATURE) : TRUE;
    }

public:
    BOOL IsFirstTimeForUser()
    {
        return IsFirstTimeFor((m_fProfiles ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE));
    }

    BOOL IsFirstTimeForMachine()
    {
        return IsFirstTimeFor(HKEY_LOCAL_MACHINE);
    }

    VOID SetIfFirstTime()
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];

        // On a profiles-not-enabled machine, store the signature in HKLM so we don't have to research for values
        // On a profiles-enabled machine, store there to notify IE of previous installation of IE5.
        REGISTRY_OBJ roSig(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);

        // On profiles-enabled machines,  we store a signature in HKCU so that we don't have to do 
        // much hunting for registry values
        if (m_fProfiles)
        {
            REGISTRY_OBJ roSig(HKEY_CURRENT_USER, CACHE5_KEY);
            roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);
        }        
    }

    // PerUserItem ---------------------------------------------------------------------
    virtual VOID SetPerUserStatus(BOOL fState)
    {
        DWORD flState = fState;
        if (m_fProfiles && fState!=m_fWorkingPerUser)
        {
            REGISTRY_OBJ roTemp(&m_roHKCUCache, g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);            
            if (roTemp.GetStatus()==ERROR_SUCCESS)
            {
                roTemp.SetValue(PER_USER_KEY, &flState);
                m_roWorking.WorkWith((fState ? &m_roHKCUCache
                                             : &m_roHKLMCache), g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);
                m_fWorkingPerUser = fState;
            }
        }
    }

    virtual DWORD GetPerUserStatus()
    {
        return m_fWorkingPerUser;
    }

    DWORD UpdateContentPath(PSTR pszNewPath)
    {
        TCHAR szOldPath[MAX_PATH];
        DWORD dwError;

        dwError = ERROR_SUCCESS;

        if ((dwError=SetWorkingContainer(CONTENT))==ERROR_SUCCESS)
        {
            INTERNET_CACHE_CONFIG_INFOA icci;
            icci.dwContainer = CONTENT;
            GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC);
            strncpy(szOldPath, icci.CachePath, ARRAY_ELEMENTS(szOldPath));

            if (((dwError=MoveCachedFiles(szOldPath, pszNewPath))==ERROR_SUCCESS)
                &&
                ((dwError=SetPath(pszNewPath))==ERROR_SUCCESS))
            {
                EnableCacheVu(pszNewPath);

            // Right now, we're adding entries so that once we restart, we'll delete any
            // stray files.

            // BUT, there's a case that Move will be interrupted; in that case, we ought
            // to finish the move on start up -- pop up a dialog notifying user of such
            // and then delete.
            // Also, if the Move's interrupted, then this info never will get written. OTOH,
            // we can argue that the user can just move from the old location to the new.
    
                CHAR szRunOnce          [2 * MAX_PATH];
                CHAR szSystemPath       [MAX_PATH];

            // Add a RunOnce entry to be run on reboot.
                REGISTRY_OBJ roRunOnce((m_fWorkingPerUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), RUN_ONCE_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if ((dwError=roRunOnce.GetStatus())!=ERROR_SUCCESS)
                    return dwError;

            // create RunOnce string in the form:
            // "rundll32.exe <system dir>\wininet.dll,RunOnceUrlCache C:\Windows\NewCacheLocation"
                if (!GetSystemDirectory(szSystemPath, MAX_PATH))
                    return ERROR_INTERNAL_ERROR;
       
                DisableCacheVu(szOldPath);
                // Get rid of content.ie5.
                PathRemoveBackslash(szOldPath);
                PathRemoveFileSpec(szOldPath);
                DisableCacheVu(szOldPath);
                GetShortPathName(szOldPath, szOldPath, ARRAY_ELEMENTS(szOldPath));
                wnsprintf(szRunOnce, sizeof(szRunOnce),
                            "rundll32.exe %s\\wininet.dll,RunOnceUrlCache %s", 
                            szSystemPath, szOldPath);
                
            // Set the RunOnce command in registry for wininet.
                roRunOnce.SetValue(TEXT("MovingCacheA Wininet Settings"), (LPSTR)szRunOnce, REG_SZ);
            }
        }
        return dwError;
    }
};

#define m_roPaths           m_roShellFolder
#define m_roSpecialPaths    m_roHKCUCache

class IE3_REGISTRYSET : public IE5_REGISTRYSET
{
    // Registry keys shipped with IE 3:
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths\path1
    //                                                                        \path2
    //                                                                        \path3
    //                                                                        \path4
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths\Cookies
    //                                                                                \History
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Url History

private:
    REGISTRY_OBJ m_roPath[DEF_NUM_PATHS]; 
    
public:
    // Initialise the IE3 keys that we might work with.
    
    DWORD InitialiseKeys()
    {
        DWORD dwError, i;
        TCHAR szScratch[MAX_PATH];
        TCHAR pszBase[MAX_PATH];
        DWORD dwBaseLen;

        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, OLD_CACHE_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roHKLMCache.GetStatus())!=ERROR_SUCCESS)
                goto exit;

        m_roPaths.WorkWith(&m_roHKLMCache, CACHE_PATHS_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roPaths.GetStatus())!=ERROR_SUCCESS)
            goto exit;

        memcpy(pszBase, OLD_CACHE_PATH, sizeof(OLD_CACHE_PATH));
        dwBaseLen = sizeof(OLD_CACHE_PATH) - 1;
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            pszBase[dwBaseLen-1] = (TCHAR)('1' + i);
            m_roPath[i].WorkWith(&m_roPaths, pszBase, CREATE_KEY_IF_NOT_EXISTS);
            if ((dwError=m_roPath[i].GetStatus())!=ERROR_SUCCESS)
                goto exit;
        }

        m_roSpecialPaths.WorkWith(&m_roHKLMCache, CACHE_SPECIAL_PATHS_KEY);
        m_fInitialised = TRUE;
    exit:
        return dwError;
    }

    BOOL GetContentDetails(LPSTR szPath, DWORD& cbLimit)
    {
        DWORD cbKey = MAX_PATH;
        if (m_roPaths.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szPath, &cbKey)!=ERROR_SUCCESS)
            return FALSE;

        cbLimit = 0;
        for (int i=0; i<DEF_NUM_PATHS; i++)
        {
            if (m_roPath[i].GetValue(CACHE_LIMIT_VALUE, &cbKey)!=ERROR_SUCCESS)
            {
                cbLimit = GetDefaultCacheQuota(szPath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION);
                break;
            }
            cbLimit += cbKey;
        }
        return TRUE;
    }

    DWORD SetPath(PTSTR pszPath)
    {
        DWORD i, nPaths, dwError;
        DWORD cb = strlen((LPSTR)pszPath);
        TCHAR szBase[MAX_PATH];
#ifndef UNIX
        DWORD dwType = REG_SZ;
#else
        DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */

        /* On Unix, try to preserve the Environment variables if possible */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));


        // Cache content path.
        if ((dwError = m_roPaths.SetValue(CACHE_DIRECTORY_VALUE, (LPSTR)pszPath, dwType)) != ERROR_SUCCESS)
            goto exit;

        // Number of subdirectories (optional).
        nPaths = DEF_NUM_PATHS;
        if ((dwError = m_roPaths.SetValue(CACHE_PATHS_KEY, &nPaths)) != ERROR_SUCCESS)
            goto exit;
    
        memcpy(szBase, pszPath, cb);
        memcpy(szBase + cb, OLD_CACHE_SUBKEY, sizeof(OLD_CACHE_SUBKEY));
        cb += sizeof(OLD_CACHE_SUBKEY) - 2;
        // Subdirectories' paths and limits from CONTENT.
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            szBase[cb] = (TCHAR)('1' + i);
            if ((dwError = m_roPath[i].SetValue(CACHE_PATH_VALUE, szBase, REG_SZ)) != ERROR_SUCCESS)
                goto exit;    
        }

    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    DWORD SetLimit(DWORD dwLimit)
    {
        DWORD i, nPaths, dwError;

        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            DWORD cbCacheLimitPerSubCache = (DWORD) (dwLimit/ DEF_NUM_PATHS);
            if ((dwError = m_roPath[i].SetValue(CACHE_LIMIT_VALUE, &cbCacheLimitPerSubCache)) != ERROR_SUCCESS)
                goto exit;
        }
    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    // Restore key IE3 values. *snicker* --------------------------------------------
    VOID FixLegacySettings(PTSTR pszPath, DWORD cbLimit)
    {
        if (InitialiseKeys()==ERROR_SUCCESS)
        {
            SetPath(pszPath);
            SetLimit(cbLimit);
        }
    }
};

class IE4_REGISTRYSET : public IE5_REGISTRYSET
{
private:
    BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        DWORD dwValue;
        if (m_fProfiles && (dwWhich==CONTENT))
        {
            if (m_roHKLMCache.GetValue(PROFILES_ENABLED, &dwValue)==ERROR_SUCCESS)
            {
                return dwValue;
            }

#ifndef UNIX
            if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
            if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* !UNIX */
            {
               return m_fProfiles;
            }

            // On Win9x we have to go through the following contortions to decide whether or not the
            // user is using a per-user cache or a shared cache.
         
            TCHAR szPath[MAX_PATH];
            DWORD cbPath = sizeof(szPath);
            if (m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS)
            {
                cbPath = sizeof(szPath);
                return (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS);
            }
        }
        return m_fProfiles;
    }

public:
    DWORD InitialiseKeys(BOOL& fProfiles)
    {
        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        return InitCommonKeys(fProfiles, OLD_CACHE_KEY);
    }

    DWORD GetPath(PTSTR pszCachePath)
    {
        DWORD cbKeyLen = MAX_PATH;
        LOG_UPGRADE_DATA("Getting IE4 cache location...\n");

        DWORD dwError = m_fProfiles ? m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)pszCachePath, &cbKeyLen) 
                                          : m_roWorking.GetValue(CACHE_PATH_VALUE, (LPBYTE)pszCachePath, &cbKeyLen);
#ifndef UNIX
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_WINNT) && (dwError==ERROR_SUCCESS))
#else
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_UNIX) && (dwError==ERROR_SUCCESS))
#endif /* UNIX */
        {
           LOG_UPGRADE_DATA("Correcting IE4 cache location...\n");
           LOG_UPGRADE_DATA(pszCachePath);
           LOG_UPGRADE_DATA("\n");
           TCHAR szPath[MAX_PATH];
           DWORD cbPath = ARRAY_ELEMENTS(szPath);
            if (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)!=ERROR_SUCCESS)
            {
                CompressPath(pszCachePath, szPath);
                dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szPath, REG_EXPAND_SZ);
            }
        }
        return dwError;
    }

    BOOL WasIE4Present(BOOL& fProfilesCapable)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig((fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), OLD_CACHE_KEY);

        return (roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS);
    }

    DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        // If no limit found in registry create via
        // defaults and write back to registry.
        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (cbLimit==0)
        {
            cbLimit = (m_dwWorking==CONTENT) 
                            ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                            : DEF_CACHE_LIMIT;
        }

        // Dumb hack for back compat. *sigh*
        if (m_dwWorking==CONTENT)
        {
            REGISTRY_OBJ roLimit(&m_roHKLMCache, g_szSubKey[CONTENT]);
            if (roLimit.GetStatus()==ERROR_SUCCESS)
            {
                roLimit.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
            }
        }
        return m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
    }
};


DWORD IE5_REGISTRYSET::SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
{
    INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
    // If no limit found in registry create via
    // defaults and write back to registry.
    // Cache limit - for the content cache we calculate the cache limit
    // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
    // are set to DEF_CACHE_LIMIT.
    if (cbLimit==0)
    {
        cbLimit = (m_dwWorking==CONTENT) 
                        ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                        : DEF_CACHE_LIMIT;
    }
    DWORD dwError = m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
    if (dwError==ERROR_SUCCESS)
    {
        // Hack so that apps that read the cache quota from the registry are
        // still able to do so.
        IE4_REGISTRYSET ie4;
        dwError = ie4.InitialiseKeys(m_fProfiles);
        if (dwError==ERROR_SUCCESS)
        {
            ie4.SetWorkingContainer(m_dwWorking);
            ie4.SetLimit(pszCachePath, cbLimit);
        }
    }
    return dwError;
}


#define IsFieldSet(fc, bitFlag) (((fc) & (bitFlag)) != 0)

#define FAILSAFE_TIMEOUT (60000)
#define UNMAP_TIME (120000)

// ----------------------------------------------------------------------------
// The following functions deal with keeping the cache containers all up and ready

// -- ConfigureCache() --------------------------------------------------------
// Get the cache info from registry and try to init.

// In general, GetCacheConfigInfo should only rarely fail -- mostly whenever HKCU
// is expected but not available. In that case, we use the system root cache. 
// If _that_ fails, we panic.

DWORD CConMgr::ConfigureCache()
{
    for (DWORD iter = 0; ; iter++)
    {
        DWORD dwError;
        switch (iter)
        {
        case 0:
            dwError = GetCacheConfigInfo();
            break;

        case 1:
            dwError = GetSysRootCacheConfigInfo();
            break;

        default:
            INET_ASSERT(FALSE);
            return dwError;
        }

        if (dwError==ERROR_SUCCESS && (dwError=InitFixedContainers())==ERROR_SUCCESS)
            break;

        // If InitFixedContainers has failed, it is possible that the container list 
        // (ConList) is not empty. Make sure it has no entries.
        LOCK_CACHE();
        if (ConList.Size() != 0)
            ConList.Free();
        UNLOCK_CACHE();
    }

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetCacheConfigInfo
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetCacheConfigInfo()
{
    DWORD dwError, i;

    // Prepare and initialise a registry set for every version of IE available.
    // IE5 must be initialised first because it determines whether profiles are
    // enabled on this machine and set ConMgr's _fProfilesCapable for future
    // reference. Then IE4 and IE3 can be called in whatever order.
    IE5_REGISTRYSET ie5rs;
    if ((dwError=ie5rs.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
    {
        goto exit;
    }

#ifdef WININET6
    GlobalCacheHKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
#endif

    // Look for a signature to indicate that this cache has been placed before.
    if (ie5rs.IsFirstTimeForUser())
    {
        LOG_UPGRADE_DATA("Install 1st time for user\n");
        DiscoverRegistrySettings(&ie5rs);
    } else {
        // If the user is roaming across machines that include IE4,
        // then safeguard against IE4 writing REG_SZ values that
        // be REG_EXPAND_SZ.
        CheckCacheLocationConsistency();
    }

    // -----------------------------------------------------------------------------------
    // Get the container paths, prefixes (if any) and default limit values.
    for (i = CONTENT; i < NCONTAINERS; i++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        DWORD cbCacheLimit;
        BOOL fPerUser;
        // This should only rarely fail.

        if ((dwError=ie5rs.SetWorkingContainer(i))!=ERROR_SUCCESS)
        {
            goto exit;
        }
        
        fPerUser = ie5rs.GetPerUserStatus();
        dwError = ie5rs.GetPath(szCachePath);
        LOG_UPGRADE_DATA("GetCacheConfigInfo/ie5rs.GetPath for user: ");
        LOG_UPGRADE_DATA(szCachePath);
        LOG_UPGRADE_DATA("\n");

        if (dwError==ERROR_SUCCESS) 
        {
            ie5rs.GetPrefix(szCachePrefix);
            ie5rs.GetLimit(szCachePath, cbCacheLimit);
        }
        else
        {
            break;
        }

        // Got info, now create the container --------------------------------------
        _coContainer[i] = new URL_CONTAINER(g_szSubKey[i], 
                                            szCachePath, 
                                            szCachePrefix, 
                                            (LONGLONG)cbCacheLimit*1024,
                                            0);

        if (_coContainer[i])
        {
            dwError = _coContainer[i]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[i];
                break;
            }
            ConList.Add(_coContainer[i]);
            _coContainer[i]->SetPerUserItem(fPerUser);
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Maintain values for backwards compatibility
        if (i==CONTENT)
        {
            // If repairing IE3's settings fails, well, who cares? IE5 is still going.
            IE3_REGISTRYSET ie3rs;
            ie3rs.FixLegacySettings(szCachePath, cbCacheLimit);
        }
    }

exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetSysRootCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetSysRootCacheConfigInfo()
{
    CHAR szParentPath[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szParentPath);

#ifndef UNIX
    {
        // In case of failure to create containers in the regular location,
        // we should put the cache in a user-specifiable location HKLM\* REG_EXPAND_SZ
        // Otherwise in the temp directory
        // Otherwise in the Windows directory
        REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        BOOL fResult = FALSE;
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];
            if (roCache.GetValue(TEXT("SystemCache"), (LPBYTE)szTemp, &cb)==ERROR_SUCCESS)
            {
                cb = ExpandEnvironmentStrings(szTemp,szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
                if (cb && (cb < ARRAY_ELEMENTS(szParentPath)))
                {
                    fResult = TRUE;
                }
            }
        }
        if (!fResult)
        {
            cb = ExpandEnvironmentStrings(TEXT("%TEMP%"),szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
            if (!cb || (cb > ARRAY_ELEMENTS(szParentPath)))
            {
                cb = GetWindowsDirectory(szParentPath, ARRAY_ELEMENTS(szParentPath));
            }
        }
    }
#else
    /* On Unix, GetWindowsDirectory will point to <install dir>/common
     * and the cache should not be created here in any case
     */
    lstrcpy(szParentPath,UNIX_SHARED_CACHE_PATH);
    cb = lstrlen(szParentPath);
#endif /* UNIX */
    if (!cb || (cb>sizeof(szParentPath)))
    {
        return ERROR_PATH_NOT_FOUND;
    }
    AppendSlashIfNecessary(szParentPath, &cb);
    
    for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        LONGLONG cbCacheLimit;

        // Get cache paths out of dll resource and form absolute
        // paths to top level cache directories.
        memcpy(szCachePath, szParentPath, cb);
        if (!LoadString(GlobalDllHandle, g_dwCachePathResourceID[idx], szCachePath + cb, MAX_PATH - cb))
        {
            return GetLastError();
        }

        DWORD ccPath = lstrlen(szCachePath);
        AppendSlashIfNecessary(szCachePath, &ccPath);
        memcpy(szCachePath+ccPath, g_szVersionName[idx], lstrlen(g_szVersionName[idx])+1);

        // Cache prefix.        
        memcpy(szCachePrefix, g_szCachePrefix[idx], strlen(g_szCachePrefix[idx]) + 1);

        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (idx == CONTENT)
        {
            
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY);
                fResult = FALSE;
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    DWORD cKBLimit;
                    if (roLimit.GetValue(CACHE_LIMIT_VALUE, &cKBLimit)==ERROR_SUCCESS)
                    {
                        cbCacheLimit = cKBLimit * (LONGLONG)1024;
                        fResult = TRUE;
                    }
                }
            }
            if (!fResult)
            {
                cbCacheLimit = 
                        (DWORDLONG)GetDefaultCacheQuota(szCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION) 
                        * (DWORDLONG)1024;
            }
        }
        else
        {
            // Non-CONTENT cache; use default.
            cbCacheLimit = DEF_CACHE_LIMIT * (LONGLONG)1024;
        }

        _coContainer[idx] = new URL_CONTAINER(g_szSubKey[idx], szCachePath, szCachePrefix, cbCacheLimit, 0);

        if (_coContainer[idx])
        {
            DWORD dwError = _coContainer[idx]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[idx];
                return dwError;
            }
            ConList.Add(_coContainer[idx]);
            _coContainer[idx]->SetPerUserItem(FALSE);
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    _fUsingBackupContainers = TRUE;
    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::GetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
BOOL CConMgr::GetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    LPDWORD lpdwCacheConfigInfoBufferSize, DWORD dwFieldControl)
{
    LOCK_CACHE();

    BOOL fIE5Struct = (lpCacheConfigInfo->dwStructSize == sizeof(INTERNET_CACHE_CONFIG_INFO));
    
    if(IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC))
    {
        lpCacheConfigInfo->dwSyncMode = GlobalUrlCacheSyncMode;
    }
    
    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_QUOTA_FC))
    {
        lpCacheConfigInfo->dwQuota = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit()/1024L);
    }

    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_USAGE_FC))
    {
        lpCacheConfigInfo->dwNormalUsage = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheSize()/1024L);
    }
    
    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_STICKY_CONTENT_USAGE_FC) && (lpCacheConfigInfo->dwContainer==CONTENT))
    {
        lpCacheConfigInfo->dwExemptUsage = (DWORD) (_coContainer[CONTENT]->GetExemptUsage()/1024L);
    }
    
    lpCacheConfigInfo->fPerUser = IsFieldSet( dwFieldControl, CACHE_CONFIG_USER_MODE_FC)
                                    ? _coContainer[lpCacheConfigInfo->dwContainer]->IsPerUserItem()
                                    : _coContent->IsPerUserItem();

    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = CONTENT;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_HISTORY_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = HISTORY;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_COOKIES_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = COOKIE;
    }
    // These are the actual field codes that should be sent for cache paths.
    // Note that the path returned *does not* contain subdirs (cache1..N).
    if (lpCacheConfigInfo->dwContainer <= HISTORY)
    {
        memcpy(lpCacheConfigInfo->CachePath, 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePath(), 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePathLen() + 1);
        lpCacheConfigInfo->dwQuota = (DWORD)
               (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit() / 1024);        

        lpCacheConfigInfo->dwNumCachePaths = (DWORD) 1;    
    }

    UNLOCK_CACHE();
    return TRUE;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::SetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
BOOL CConMgr::SetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO pConfig, 
                                              DWORD dwFieldControl)
{         
    DWORD i, dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);
    
    LOCK_CACHE();
    
    //  Check FieldControl bits and set the values for set fields
    if( IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC ))
    {

        INET_ASSERT(pConfig->dwSyncMode <= WININET_SYNC_MODE_AUTOMATIC);

        InternetWriteRegistryDword(vszSyncMode, pConfig->dwSyncMode);

        GlobalUrlCacheSyncMode = pConfig->dwSyncMode;

        // set a new version and simultaneously
        // increment copy for this process, so we don't
        // read registry for this process
        IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                            &GlobalSettingsVersion);
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_DISK_CACHE_PATHS_FC ))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_QUOTA_FC ) && pConfig->dwContainer==CONTENT)
    {
        DWORD cbSize = pConfig->dwQuota;
        INET_ASSERT(cbSize);

        if (!_fUsingBackupContainers)
        {
            IE5_REGISTRYSET ie5;
            IE3_REGISTRYSET ie3;
            
            if ((dwError=ie5.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
            {
                goto exit;
            }
            ie5.SetWorkingContainer(CONTENT);
            TCHAR szTemp[MAX_PATH];
            ie5.GetPath(szTemp);
            ie5.SetLimit(szTemp, cbSize);

            if (ie3.InitialiseKeys()==ERROR_SUCCESS)
            {
                ie3.FixLegacySettings(szTemp, cbSize);
            }
        }
        else
        {
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY, CREATE_KEY_IF_NOT_EXISTS);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    roLimit.SetValue(CACHE_LIMIT_VALUE, &cbSize);
                }
            }
        }

        if ((((LONGLONG)cbSize * 1024) < _coContent->GetCacheSize()))
            _coContent->CleanupUrls (DEFAULT_CLEANUP_FACTOR, 0);
        _coContent->SetCacheLimit(cbSize* (LONGLONG)1024);
    }

exit:
    UNLOCK_CACHE();
    BOOL fRet = (dwError==ERROR_SUCCESS);
    if (!fRet)
    {
        SetLastError(dwError);
        DEBUG_ERROR(INET, dwError);
    }
    return fRet;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetContentPath

UpdateUrlCacheContentPath leads to this function.
This initiates the cache move. Should be called just before shutdown.

----------------------------------------------------------------------------*/
BOOL CConMgr::SetContentPath(PTSTR pszNewPath)
{
    IE5_REGISTRYSET ie5rs;
    DWORD dwError;
    BOOL fLock;

    if (_coContent->LockContainer(&fLock)
        && (dwError=ie5rs.InitialiseKeys(_fProfilesCapable))==ERROR_SUCCESS)
    {
        dwError = ie5rs.UpdateContentPath(pszNewPath);
    }
    
    if (fLock)
    {
        _coContent->UnlockContainer();
    }

    if (dwError==ERROR_SUCCESS)
    {
        return TRUE;
    }
    SetLastError(dwError);
    return FALSE;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetExtensibleCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetExtensibleCacheConfigInfo(BOOL fAlways)
{
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    CHAR szPrefixMap[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];
    CHAR szVolumeTitle[MAX_PATH];

    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];

    URL_CONTAINER* pNewContainer;
    URL_CONTAINER* co;
    MUTEX_HOLDER mh;

    DWORD idx;
    DWORD idxPrefix;
    DWORD dwNow;
    DWORD dwOptions;
    BOOL fModified;
    BOOL fCDContainer;

    REGISTRY_OBJ* pro = NULL;

    LOCK_CACHE();
    fModified = WasModified(TRUE);

    hKey = _fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    //  WasModified MUST come first, so that we update our cached count!
    if (!fModified && !fAlways)
    {
         //  Unmap every container that hasn't be referenced in UNMAP_TIME
        dwNow = GetTickCountWrap();
        if ((dwNow - _dwLastUnmap) > UNMAP_TIME)
        {
            for (idx = ConList.Size()-1; idx >= NCONTAINERS; idx--)
            {
                co = ConList.Get(idx);
                if (co)
                {
                    if (co->GetDeletePending() ||
                        ((dwNow - co->GetLastReference()) > UNMAP_TIME))
                    {
                        co->TryToUnmap(1);    //  RefCount should be 1 == Us
                    }
                    co->Release(FALSE);
                }
            }

            _dwLastUnmap = dwNow;
        }
        goto exit;
    }

    // Create registry object and entry.
    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        for (idx = NCONTAINERS; idx < ConList.Size(); idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);
            if (co)
            {
                co->Mark(FALSE);
                co->Release(FALSE);
            }
        }

        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        idx = NCONTAINERS;
        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                    // Path.
                cbKeyLen = MAX_PATH;
                DWORD dwRepair = TRUE;
                CHAR szScratch[MAX_PATH];

                roVendor.GetValue(CACHE_PATCH_VALUE, &dwRepair);

                if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                    continue;

                if (!*szScratch)
                {
                    roExtensibleCache.DeleteKey(szVendorKey);
                    continue;
                }

                if (dwRepair)
                {
                    CompressPath(szScratch, szCachePath);
                    cbKeyLen = lstrlen(szCachePath)+1;
                    roVendor.SetValue(CACHE_PATH_VALUE, szCachePath, REG_EXPAND_SZ);
                    dwRepair = FALSE;
                    roVendor.SetValue(CACHE_PATCH_VALUE, &dwRepair);
                }
                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                    
                // Prefix.
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                    continue;
            
                // Limit.
                if (roVendor.GetValue(CACHE_LIMIT_VALUE, &cbKBLimit) != ERROR_SUCCESS)
                    continue;    

            // Options.
                if (roVendor.GetValue(CACHE_OPTIONS_VALUE, &dwOptions) != ERROR_SUCCESS)
                    continue;
            
                if (dwOptions & INTERNET_CACHE_CONTAINER_MAP_ENABLED)
                {
                    fCDContainer = TRUE;

                    // PrefixMap
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_PREFIX_MAP_VALUE, (LPBYTE) szPrefixMap, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szPrefixMap == '\0'))
                        continue;

                    // Volume label.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_LABLE_VALUE, (LPBYTE) szVolumeLabel, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeLabel == '\0'))
                        continue;
            
                    // Volume title.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_TITLE_VALUE, (LPBYTE) szVolumeTitle, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeTitle == '\0'))
                        continue;
                }
                else
                {
                    fCDContainer = FALSE;
                    *szPrefixMap = '\0';
                    dwOptions &= ~INTERNET_CACHE_CONTAINER_PREFIXMAP;
                }
    
                cbCacheLimit = ((LONGLONG) cbKBLimit) * 1024;
                
                idxPrefix = FindExtensibleContainer(szVendorKey);
                if (idxPrefix != NOT_AN_INDEX)
                {
                    co = ConList.Get(idxPrefix);

                    if (co)
                    {
                        //  what if the container has been added
                        //  with the same name but a different path, prefix, or options!
                        if (stricmp(co->GetCachePath(), szCachePath) ||
                            stricmp(co->GetCachePrefix(), szCachePrefix) ||
                            co->GetOptions() != dwOptions)
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else if (fCDContainer && stricmp(co->GetPrefixMap(), szPrefixMap))
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else
                        {
                            co->Mark(TRUE);
                        }
                        co->Release(FALSE);
                    }
                }
            
                if (idxPrefix == NOT_AN_INDEX)
                {
                    // Construct either a normal container, or a CD container.
                    if (!fCDContainer)                        
                    {
                        pNewContainer = new URL_CONTAINER(szVendorKey, szCachePath, szCachePrefix,
                                            cbCacheLimit, dwOptions);
                    }
                    else
                    {
                        pNewContainer = new CInstCon(szVendorKey, szVolumeLabel, szVolumeTitle,
                                             szCachePath, szCachePrefix, szPrefixMap, 
                                             cbCacheLimit, dwOptions);
                    }
                    if (pNewContainer)
                    {
                        dwError = pNewContainer->GetStatus();
                        if (dwError!=ERROR_SUCCESS)
                        {
                            delete pNewContainer;
                            pNewContainer = NULL;
                        }
                        else
                        {
                            pNewContainer->Mark(TRUE);
                            ConList.Add(pNewContainer);
                        }
                    }
                    else
                    {
                        dwError = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                 idx++;
            }
        }
    mh.Release();

    //  Mark every container that's no longer in the registry for pending delete
    //  Unmap every container that hasn't be referenced in UNMAP_TIME
    dwNow = GetTickCountWrap();

    idx = ConList.Size() - 1;

    while (idx >= NCONTAINERS)
    {
        co = ConList.Get(idx);
        if (co)
        {
            if (!co->GetMarked() && !co->GetDeleted())
            {
                co->SetDeletePending(TRUE);
            }
            if (co->GetDeletePending() ||
                ((dwNow - co->GetLastReference()) > UNMAP_TIME))
            {
                co->TryToUnmap(1);    //  RefCount should be 1 == Us, unless enumerator
                                      //  is still open
            }
            co->Release(FALSE);
        }
        idx--;
    }

    _dwLastUnmap = dwNow;
    }
    delete pro;
    
exit:  
    UNLOCK_CACHE();
    return dwError;
}


//
//  Mixed environment of IE4 and IE5 sharing a server causes HKCU keys to get resaved as REG_SZ incorrectly
//  so we repair it here
VOID CheckCacheLocationConsistency()
{
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ if necessary
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        DWORD ValueSize;
        DWORD ValueType;

        //  speed things up a bit by checking if we don't need to do this
        if (roUserShellFolders.GetValueSizeAndType(g_szOldSubKey[i], &ValueSize, &ValueType ) != SUCCESS 
            || ValueType != REG_SZ)
        {
            continue;
        }
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.

        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));

        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);
    }
}


VOID MakeCacheLocationsConsistent()
{
    // Delete any 5.0 cache signatures from previous installs
    REGISTRY_OBJ roHKCU(HKEY_CURRENT_USER, CACHE5_KEY);
    if (roHKCU.GetStatus()==ERROR_SUCCESS)
    {
        roHKCU.DeleteValue(CACHE_SIGNATURE_VALUE);
    }
    
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    roUserShellFolders.DeleteValue(TEXT("Content"));

    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.
        // i. Get rid of all the trailing content.ie5 (History.IE5)
        // ii. Get rid of any trailing Temporary Internet Files (History)
        // iii. Append Temporary Internet Files (History)

        // We want to skip this for cookies, though.

        // PROBLEM: When we have upgrade on top of 0901+, we started appending content.ie5
        // internally. Thus, files start getting misplaced. How do I work around this?

        // Idea: We append Content.ie5 to the USF path, and test for existence. If it's there,
        // then we'll use that. (We won't bother with anymore detective work. Though we could also
        // verify that the index dat there is newer than the index.dat in the parent directory.)
        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));
        DisableCacheVu(szRealPath);

        if (i!=1)
        {
        }
        
        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);

        // Then append Content.IE5 and move the files to this subdirectory
        // Ideally, we should rename this to an intermediate folder,
        // delete the old location (UNLESS THIS IS THE ROOT OR SYSTEM DIRECTORY),
        // and then move intermediate folder to its new location

    }

    FlushShellFolderCache();
}

// External hooks -------------------------------------------------------------------------------------------------------

// -- RunOnceUrlCache -------------------------
// This code is called on reboot to clean up moving the cache.
// If the shutdown was successful, this will move only the few files that were open
// at that point; we assume that we'll move quickly enough to prevent collisions.
// The old index.dat is erased.

DWORD
WINAPI
RunOnceUrlCache( HWND hwnd, HINSTANCE hinst, PSTR pszCmd, int nCmdShow)
{
    // This will clean up the move, especially important if the move was interrupted. (Not too likely.)
    if (pszCmd && *pszCmd)
    {
        CFileMgr::DeleteCache(pszCmd);
    }
    return ERROR_SUCCESS;
}
      
DWORD
WINAPI
DeleteIE3Cache( HWND hwnd, HINSTANCE hinst, PSTR lpszCmd, int nCmdShow)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()==ERROR_SUCCESS)
    {
        TCHAR szTemp[MAX_PATH];
        DWORD cbLimit;
        
        // This fragment will look for a cache location, and test for its share-ability. If it is,
        // we'll use the location; otherwise, we'll use our own shared location.
        if (ie3rs.GetContentDetails(szTemp, cbLimit))
        {
            DWORD cb = lstrlen(szTemp);
            AppendSlashIfNecessary(szTemp, &cb);

            PTSTR psz = szTemp+cb-2;
            while (*psz!='\\' && psz>szTemp)
            {
                psz--;
            }
            if ((psz>szTemp) && !StrCmpNI(psz+1, TEXT("content."), ARRAY_ELEMENTS("content.")-1))
            {
                *(psz+1) = TEXT('\0');
            }
            StrCatBuff(szTemp, TEXT("cache1"), MAX_PATH);
            cb = lstrlen(szTemp) - 1;

            for (int i=0; i<4; i++)
            {
                szTemp[cb] = TEXT('1')+i;
                DeleteCachedFilesInDir(szTemp);
                RemoveDirectory(szTemp);
            }
        }
    }

    return ERROR_SUCCESS;
}
      

// -- Externally available apis

URLCACHEAPI_(BOOL) SetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO pConfig,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the cache configuration parameters.

Arguments:

    lpCacheConfigInfo - place holding cache configuration information to be set

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetUrlCacheConfigInfo(pConfig,dwFieldControl);
}

URLCACHEAPI_(BOOL) GetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function retrieves cache configuration values from globals

Arguments:

    pConfig - pointer to a location where configuration information
                  is stored on a successful return

    lpdwCacheConfigInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoA", "%#x, %#x, %#x",
        lpCacheConfigInfo, lpdwCacheConfigInfoBufferSize, dwFieldControl ));

    BOOL fError;
    
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_INTERNET_INTERNAL_ERROR);
        DEBUG_ERROR(API, ERROR_INTERNET_INTERNAL_ERROR);
        fError = FALSE;
    }
    else
    {
        fError = GlobalUrlContainers->GetUrlCacheConfigInfo(lpCacheConfigInfo,
            lpdwCacheConfigInfoBufferSize, dwFieldControl);
    }
    
    DEBUG_LEAVE_API (fError);
    return fError;
}


// declared in wininet\inc\urlcache.h
BOOL GetIE5ContentPath( LPSTR szPath)
{
    BOOL retVal = FALSE;
    
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesCapable;

    if( ie5rs.InitialiseKeys(fProfilesCapable) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.SetWorkingContainer(CONTENT) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.GetPath( szPath) != ERROR_SUCCESS)
        goto doneGetContentPath;

    retVal = TRUE;

doneGetContentPath:
    return retVal;
}

// SHDOCVW needs to know whether profiles are enabled, to determine whether
// or not it needs to filter out user names. This function will help keep things simple.
// And minimise perf impact.
STDAPI_(BOOL) IsProfilesEnabled()
{
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesEnabled;

    if (ie5rs.InitialiseKeys(fProfilesEnabled) != ERROR_SUCCESS)
    {
        fProfilesEnabled = FALSE;
    }
    return fProfilesEnabled;
}

BOOL CConMgr::DiscoverIE4Settings(IE5_REGISTRYSET* pie5rs)
{
    IE4_REGISTRYSET ie4rs;

    CHAR szTemp[MAX_PATH+1], szPrefix[MAX_PATH+1];
    DWORD cbLimit, dwTemp;
    BOOL fPerUser, fCaughtIE4;
        
    // Try to find IE4 settings. If any paths are found, we will not look for IE3 settings
    fCaughtIE4 = FALSE;

    if (ie4rs.WasIE4Present(_fProfilesCapable))
    {
        if (ie4rs.InitialiseKeys(_fProfilesCapable)!=ERROR_SUCCESS)
        {
           LOG_UPGRADE_DATA("IE4 initialisation failed...\n");
           return FALSE;
        }

        for (dwTemp=0;dwTemp < NCONTAINERS; dwTemp++)
        {
            ie4rs.SetWorkingContainer(dwTemp);
            if (ie4rs.GetPath(szTemp)!=ERROR_SUCCESS)
            {
                continue;
            }
            LOG_UPGRADE_DATA("DIE4Settings: ");
            LOG_UPGRADE_DATA(szTemp);
            LOG_UPGRADE_DATA("\n");
            DisableCacheVu(szTemp);

            pie5rs->SetWorkingContainer(dwTemp);

            // Because SHGetFolderPath uses shell folders to determine where the items are, we have to accomodate this
            // on no-profiles machines. 
            if (!_fProfilesCapable)
            {
                pie5rs->SetPath(szTemp);
            }
            else if (dwTemp==CONTENT)
            {
#ifndef UNIX
                if (ie4rs.GetPerUserStatus() || GlobalPlatformVersion5)
#else
                if (ie4rs.GetPerUserStatus() || GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
                {
                // If it's NT5, we want to go to a per-user, non-roaming location
                // which is the NT5 default anyway
                    LOG_UPGRADE_DATA("DIE4Settings: If NT5, ignore shared cache. Else this isn't shared anyway.");
                    pie5rs->SetPerUserStatus(TRUE);
                }
                else
                {
                // Because IE4 locates a shared cache differently from IE5, we need to
                // save the path and status.
                    LOG_UPGRADE_DATA("DIE4Settings: Will try to use shared cache");
                    pie5rs->AttemptToUseSharedCache(szTemp, 0);
                }
            }
        
            fCaughtIE4 = TRUE;

            // We don't need to check return values since we come up with
            // reasonable values on our own.
            ie4rs.GetLimit(szTemp, cbLimit);
            pie5rs->SetLimit(szTemp, cbLimit);

            ie4rs.GetPrefix(szPrefix);
            pie5rs->SetPrefix(szPrefix);
        }
    }
    if (!fCaughtIE4)
    {
        LOG_UPGRADE_DATA("No IE4 settings...\n");
    }
    else
    {
        FlushShellFolderCache();
    }
    return fCaughtIE4;
}

VOID CConMgr::DiscoverIE3Settings(IE5_REGISTRYSET* pie5rs)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()!=ERROR_SUCCESS)
    {
        return;
    }

    TCHAR szTemp[MAX_PATH];
    DWORD cbLimit;
    
    // This fragment will look for a cache location, and test for its share-ability. If it is,
    // we'll use the location; otherwise, we'll use our own shared location.
    if (ie3rs.GetContentDetails(szTemp, cbLimit))
    {
        DeleteCachedFilesInDir(szTemp);
       // No IE4. Steal IE3's settings? We only care about content cache.
       // Is that a good idea? There's no UI for modifying the cookies/history path; 
       // if someone plumbs into the registry, do we want to support that? *sigh*
       // BUG? We're moving the cache one level deeper. We probably want to be a
       // bit more intelligent about this.
        CleanPath(szTemp);
        pie5rs->AttemptToUseSharedCache(szTemp, cbLimit);
    }

    // This fragment deletes the shared history. It should happen ONLY ONCE.
    DWORD cbKeyLen = ARRAY_ELEMENTS(szTemp);
    REGISTRY_OBJ roHist(HKEY_LOCAL_MACHINE, IE3_HISTORY_PATH_KEY);
    if ((roHist.GetStatus()==ERROR_SUCCESS)
        &&
        (roHist.GetValue(NULL,(LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
    {
        REGISTRY_OBJ roUrlHist(HKEY_LOCAL_MACHINE, szTemp);
        cbKeyLen = ARRAY_ELEMENTS(szTemp);
        if ((roUrlHist.GetStatus()==ERROR_SUCCESS)
            &&
            (roUrlHist.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
        {
            DeleteCachedFilesInDir(szTemp);
        }
    }
}


// Logic for determining the location of the cache -------------------------------------------------------------

// PROFILES ENABLED --------------------------
// [on logon]
// If profiles are enabled, look in HKCU/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature. 
// If a signature is present, [carry on]
// Look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is not present, jump to [over IE4 install]
// For history and cookies, the containers will be located in the profiles directory
// For content, 
//      if it's marked per user, 
//          and there isn't a shell folder/user shell folder value, construct and put it in
//      otherwise feed the HKLM shared location into (user) shell folder.
// Insert signature and [carry on].

// [over IE4 install]
// If a signature is not present in HKCU/Software/Microsoft/Windows/Internet Settings/Cache,
//      jump to [over IE3 install]
// Determine if the content cache is per-user or not.

// [over IE3 install]
// For history and cookies, the containers will be located in the profiles directory
// Examine HKLM/Software/Microsoft/Windows/Internet Settings/Cache/Paths
// If not present, go to [clean install]
// If the cache path is located in a user's profiles directory, ignore and [clean install]
// Otherwise, adopt the values and [carry on]

// [clean install]
// Set up history/cookies to be per user.
// Set up the content cache to be shared.
// Write in default values.

// PROFILES NOT ENABLED --------------------------

// * If profiles are _not_ enabled, we'll look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is present, go ahead and gather information for the paths

// [carry on]
// Get info from the registry, and create the container


// -- DiscoverAnyIE5Settings
// We're going to call this function if we haven't any IE4 settings to upgrade,
// but _before_ we check for IE3,

DWORD GetIEVersion();

BOOL CConMgr::DiscoverAnyIE5Settings(IE5_REGISTRYSET* pie5rs)
{
    // Let's consider the following scenario:
    // User A logs on to the machine with IE4 installed; installs IE5, and then shuts down
    // the machine. User B comes along, but IE5 hasn't been installed yet. If User B has 
    // admin privileges, install will continue, BUT still not have any IE4/5 settings.
    // Which resulted in skipping DiscoverIE4Settings. However, we don't want to look
    // at IE3's settings.

    // If we're installing over IE4/2/5, but we don't have any settings for this user, 
    // we must avoid an IE3 upgrade. Instead, short circuit to use last-minute info-gathering
    // For IE3, use a shared cache
    DWORD dwVer = GetIEVersion();
    
    // We're going to use a shared cache for IE3 and Win9x users.
    // Upgrading over IE4 and 5 -- for users who have logged in before,
    // their signatures shoudl be in place already. In those cases, we shouldn't
    // be in this function anyway. For other users, we'll use the shared cache.
    // This is the first time for the machine.
    if ((dwVer==3) && pie5rs->IsFirstTimeForMachine())
    {
        return FALSE;
    }

    pie5rs->AttemptToUseSharedCache(NULL, 0);
    return TRUE;
}


VOID CConMgr::DiscoverRegistrySettings(IE5_REGISTRYSET* pie5rs)
{
    LOG_UPGRADE_DATA("Attempting to discover IE4 settings...\n");

    if (DiscoverIE4Settings(pie5rs))
    {
        goto exit;
    }


#ifndef UNIX
    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
    if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
    {
        LOG_UPGRADE_DATA("This is NT. Fuhgedabout IE3 et al settings...\n");

        // This will override NT's default behaviour to use per-user containers.
        pie5rs->SetWorkingContainer(CONTENT);
        if (!pie5rs->GetPerUserStatus())
        {
            pie5rs->AttemptToUseSharedCache(NULL, 0);
        }

        // Suppose this is an install over NT. Each user should get a per-user, non-roaming
        // path by default. The values we'd pick up from SHFolderGetPath will be okay; but, we need to make
        // sure that we treat this as a per-user container.

        // Suppose we upgraded from some previous version of Win9x to NT5. There are eight scenarios:
        // nothing                  : in which case, we do as above
        // IE3                      : same; need to delete old cache
        // IE4 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : same as fresh install
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path
        // IE5 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : preserve shared path
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path

        // If an admin wants to use a shared cache under NT5, s/he will have to set
        // HKCU/Shell Folders and User Shell Folders to point to the common path
        // AND {HKCU|HKLM}/blah/PerUserItem to 0 (or delete the HKCU value).
        if ((GetIEVersion()==3) && pie5rs->IsFirstTimeForMachine())
        {
            IE3_REGISTRYSET ie3rs;
            TCHAR szTemp[MAX_PATH];
            DWORD cbLimit;
            if ((ie3rs.InitialiseKeys()==ERROR_SUCCESS)
                &&
                (ie3rs.GetContentDetails(szTemp, cbLimit)))
            {
                DeleteCachedFilesInDir(szTemp);
            }
        }
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE5 settings...\n");
    if (DiscoverAnyIE5Settings(pie5rs))
    {
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE3 settings...\n");
    DiscoverIE3Settings(pie5rs);

exit:
    LOG_UPGRADE_DATA("Flushing shell folders cache...\n");
    pie5rs->SetIfFirstTime();
    FlushShellFolderCache();
}

// -- AttemptToUseSharedCache
// Given a path (and limit) attempt to use the path for a shared location.
// If the path is null, then try to use any value if present, else invent one.

VOID IE5_REGISTRYSET::AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit)
{
    TCHAR szSharedPath[MAX_PATH];
    DWORD cc = ARRAY_ELEMENTS(szSharedPath);

    REGISTRY_OBJ roContent(&m_roHKLMCache, g_szSubKey[CONTENT], CREATE_KEY_IF_NOT_EXISTS);
    if ((roContent.GetStatus()==ERROR_SUCCESS)
        &&
        (roContent.GetValue(CACHE_PATH_VALUE, (LPBYTE)szSharedPath, &cc)==ERROR_SUCCESS))
    {
        LOG_UPGRADE_DATA("Found a shared cache location...\n");
        goto write_value;
    }

    if (pszPath!=NULL)
    {
        LOG_UPGRADE_DATA(pszPath);
        LOG_UPGRADE_DATA("\n is ");
        GetUserName(szSharedPath, &cc);

        // We're going to ignore just the user name, during this comparison. And
        // if it's in the profiles directory, fuhgedaboutit.
        if (m_fProfiles && !StrCmpNI(m_szProfilePath, pszPath, cbP-cc))
        {
            pszPath = NULL;
            LOG_UPGRADE_DATA("not okay \n");
            goto carryon;
        }
        LOG_UPGRADE_DATA("okay \n");
        strcpy(szSharedPath, pszPath);
    }

carryon:
    if (pszPath==NULL)
    {
        memcpy(szSharedPath, m_szSharedPath, (cbS+1)*sizeof(TCHAR));
        CleanPath(szSharedPath);
        LOG_UPGRADE_DATA("Using a constructed shared path\n");
    }

    // We've finally decided on the path. Now let's write the value into the registry.
    roContent.SetValue(CACHE_PATH_VALUE, szSharedPath, REG_SZ);
    SetWorkingContainer(CONTENT);
    SetPerUserStatus(FALSE);
    SetLimit(szSharedPath, ckbLimit);

write_value:
    LOG_UPGRADE_DATA("The shared cache will be located at ");
    LOG_UPGRADE_DATA(szSharedPath);
    LOG_UPGRADE_DATA("\n");
    
    // This will take care of HKCU
    CHAR szScratch[MAX_PATH];
#ifndef UNIX
    if (!NormalisePath(szSharedPath, TEXT("%SystemRoot%"), szScratch, sizeof(szScratch)))
#else
    if (!NormalisePath(szSharedPath, TEXT("%USERPROFILE%"), szScratch, sizeof(szScratch)))
#endif /* UNIX */
    {
        strncpy(szScratch, szSharedPath, MAX_PATH);
    }
    if (m_roUserShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ)==ERROR_SUCCESS)
    {
#ifndef UNIX
       DWORD dwType = REG_SZ;
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szSharedPath, dwType);
#else
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
    }
}


// -- CleanPath
// Given a path, strip away any trailing content.ie5's, and if necessary, add a trailing brand mark,
// i.e. "Temporary Internet Files" or localised version.

VOID CleanPath(PTSTR pszPath)
{
    DWORD ccPath = strlen(pszPath);
    PTSTR pszLastSep = pszPath + ccPath;

    // Now we're at the null terminator, but if the last character is also a separator, we want
    // to skip that too.
    if (*(pszLastSep-1)==DIR_SEPARATOR_CHAR)
    {
        pszLastSep--;
    }
    BOOL fSlash;
    // Strip away any "content.ie5"'s from the path
    for (;(fSlash = ScanToLastSeparator(pszPath, &pszLastSep));)
    {
        if (StrCmpNI((pszLastSep+1), TEXT("content.ie"), ARRAY_ELEMENTS(TEXT("content.ie"))-1))
        {
            break;
        }
        *pszLastSep = '\0';
    }

    // Load temp int files
    TCHAR szBrand[MAX_PATH];
    DWORD ccBrand = 0;

    ccBrand = LoadString(GlobalDllHandle, g_dwCachePathResourceID[CONTENT], szBrand, ARRAY_ELEMENTS(szBrand));

    // The following fragment should never happen, but just in case...
    if (!ccBrand)
    {
        ccBrand = sizeof(TEXT("Temporary Internet Files"));
        memcpy(szBrand, TEXT("Temporary Internet Files"), ccBrand);
        ccBrand /= sizeof(TCHAR);
        ccBrand--;
    }
    
    // If "Temporary Internet Files" doesn't trail the path, add it.
    if (!fSlash)
    {
        *pszLastSep++ = DIR_SEPARATOR_CHAR;
        *pszLastSep = '\0';
    }
    else
    {
        pszLastSep++;
    }
    if (StrCmpNI((pszLastSep), szBrand, ccBrand))
    {
        while (*pszLastSep && *pszLastSep!=DIR_SEPARATOR_CHAR)
        {
            pszLastSep++;
        }
        if (!*pszLastSep && (*(pszLastSep-1)!=DIR_SEPARATOR_CHAR))
        {
            *pszLastSep = DIR_SEPARATOR_CHAR;
            pszLastSep++;
        }
        else if (*pszLastSep)
        {
            pszLastSep++;
        }
        memcpy(pszLastSep, szBrand, ccBrand*sizeof(TCHAR));
    }
    *(pszLastSep+ccBrand)='\0';
}

DWORD GetIEVersion()
{
    DWORD dwVer = 0;

    REGISTRY_OBJ roVersion(HKEY_LOCAL_MACHINE, OLD_VERSION_KEY);
    TCHAR szKey[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szKey);

    if ((roVersion.GetStatus()!=ERROR_SUCCESS)
        ||
        (roVersion.GetValue(OLD_VERSION_VALUE, (LPBYTE)szKey, &cb)!=ERROR_SUCCESS))
    {
        // This should never happen during a proper setup.
        // In case it does, however, we'll just use construct IE5's default settings.
        return 0;
    }

    PTSTR psz = szKey;
    PTSTR pszFirst = szKey;
    // Get the major version number
    while (*psz!='.')
    {
        psz++;
    }
    *psz = '\0';
    dwVer = (DWORD)StrToInt(pszFirst);

    if (dwVer==4)
    {
        psz++;
        // Skip the second number
        while (*psz!='.')
        {
            psz++;
        }
        pszFirst = psz;
        psz++;
        while (*psz!='.')
        {
            psz++;
        }
        *psz = '\0';
        dwVer = ((DWORD)StrToInt(pszFirst))==0 ? 3 : 4;
    }

    return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\cookies.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  cookies.cxx

Abstract:

  Cookie upgrade object implementation

  Upgrades cookies to new format by parsing existing cookies
  files and adding them to the newly created cookie cache index.

  Currently upgrades v3.2 to v4.0.


Author:
    Adriaan Canter (adriaanc) 01-Nov-1996.

Modification history:
    Ahsan Kabir (akabir) 25-Sep-1997 made a few minor alterations.
-------------------------------------------------------------------------------*/
#include <cache.hxx>

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKLMCookiesDirectory

  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    DWORD dwError;
    REGISTRY_OBJ roCookiePath(HKEY_LOCAL_MACHINE, IE3_COOKIES_PATH_KEY);
    DWORD cbKeyLen = MAX_PATH;

    if ((dwError=roCookiePath.GetStatus())==ERROR_SUCCESS)
    {
        dwError = roCookiePath.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szCookiesDirectory,  &cbKeyLen);
    }

    return dwError;

}
/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;

    __try
    {
        // Get the first token (cookie name).
        pszName           = StrTokEx(&ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = StrTokEx(&ptr, "\n");      // Cookie value.
        *ppszHash         = StrTokEx(&ptr, "\n");      // Combo of domain and path.
        pszFlags          = StrTokEx(&ptr, "\n");      // Cookie flags.
        pszExpireTimeLow  = StrTokEx(&ptr, "\n");      // Expire time.
        pszExpireTimeHigh = StrTokEx(&ptr, "\n");
        pszLastTimeLow    = StrTokEx(&ptr, "\n");      // Last Modified time.
        pszLastTimeHigh   = StrTokEx(&ptr, "\n");
        pszDelimiter      = StrTokEx(&ptr, "\n");      // Delimiter should be "*"


        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            TcpsvcsDbgAssert(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);

        pszNextCookie = pszDelimiter+2;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TcpsvcsDbgAssert(FALSE);
        pszNextCookie = 0;
        goto exit;
    }
    ENDEXCEPT

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(URL_CONTAINER *UrlContainer)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szOldMemMapFilePath     [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];

    CHAR               *pszHash, *ptr,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE *abCacheEntryInfoBuffer = NULL;
    LPCACHE_ENTRY_INFO pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer = 2 * PAGE_SIZE;
    DWORD dwDIR_SEP_STRING = strlen(DIR_SEPARATOR_STRING);
    DWORD dwLen;
    REGISTRY_OBJ roCachePath(HKEY_CURRENT_USER, OLD_CACHE_KEY);
    DWORD cbKeyLen = MAX_PATH;

    szBuffer = 0;

    abCacheEntryInfoBuffer = new BYTE[cbCacheEntryInfoBuffer];
    if (abCacheEntryInfoBuffer == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    __try
    {

        if (!UrlContainer)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        TCHAR szSigKey[MAX_PATH];
        
        // Check to see if we are upgrading cookies
        // from local machine to per user.
        // If IE4's signature isn't present, then we'll guess that IE3 might have been.
        if (UrlContainer->IsPerUserItem()
            &&
            ((roCachePath.GetStatus()!=ERROR_SUCCESS)
             ||  
             (roCachePath.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cbKeyLen)!=ERROR_SUCCESS)))
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            dwLen = strlen(szHKLMCookiesPath) +
                    strlen(szUserName) +
                    dwDIR_SEP_STRING   +
                    7;        // strlen("@*.txt" + '\0';

            if( dwLen > MAX_PATH )
            {
                dwError =  ERROR_INSUFFICIENT_BUFFER;
                goto exit;
            }

            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, DIR_SEPARATOR_STRING);
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");

            // Enumerate the users cache files
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                // One or more cookie files exist.
                do
                {
                    // Construct absolute path from HKLM to cookies file.
                    dwLen = strlen(szHKLMCookiesPath) +
                            strlen(FindData.cFileName) +
                            dwDIR_SEP_STRING +
                            1;
                    if( dwLen > MAX_PATH )
                    {
                        dwError =  ERROR_INSUFFICIENT_BUFFER;
                        goto exit;
                    }
                    strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                    strcat(szHKLMCookieFileName, DIR_SEPARATOR_STRING);
                    strcat(szHKLMCookieFileName, FindData.cFileName);

                    // Construct absolute path from HKCU to cookies file.
                    dwLen = strlen(UrlContainer->GetCachePath()) +
                            strlen(FindData.cFileName) +
                            1;
    
                    // We should rescue as many cookies as we can.
                    if( dwLen <= MAX_PATH )
                    {
                        strcpy(szHKCUCookieFileName, UrlContainer->GetCachePath());
                        strcat(szHKCUCookieFileName, FindData.cFileName);
                        // Move the file to the per-user directory.
                        CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);
                    }
                } while (FindNextFile(hFind, &FindData));

                // Close the Find handle.
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    FindClose(hFind);
                    hFind = INVALID_HANDLE_VALUE;
                }
            } // Per-user upgrade.
        }

        // No per-user upgrade. szCookieFileNamePattern will look like
        // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
        dwLen = strlen(UrlContainer->GetCachePath()) + 8;        // strlen("*@*.txt" + '\0';

        if( dwLen > MAX_PATH )
        {
            dwError =  ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
        strcpy(szCookieFileNamePattern, UrlContainer->GetCachePath());
        strcat(szCookieFileNamePattern, "*@*.txt");

        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            dwLen = strlen(UrlContainer->GetCachePath()) +
                    strlen(FindData.cFileName) +
                    1;
            if( dwLen > MAX_PATH )
            {
                continue;
            }

            strcpy(szCookieFileName, UrlContainer->GetCachePath());
            strcat(szCookieFileName, FindData.cFileName);

            // Get the WIN32_FILE_ATTRIBUTE for the call to AddUrl
            // This wrapper works for Win95 and WinNT.

            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );

            // File handle must be valid.
            TcpsvcsDbgAssert(hFile != INVALID_HANDLE_VALUE);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? ->
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                TcpsvcsDbgAssert(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie,
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);

                        ptr = strstr(szCookieName, "@");

                        // Downcase the username portion of the file.
                        CHAR* tptr = ptr;
                        while (*--tptr != ':')
                            *tptr = tolower(*tptr);

                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (LPCACHE_ENTRY_INFO) abCacheEntryInfoBuffer;

                        dwError = UrlContainer->GetUrlInfo(szCookieName, &pCacheEntryInfo,
                            &cbCacheEntryInfoBuffer, 0, 0, 0);

#ifndef UNIX
                        if (dwError == ERROR_SUCCESS
                            && CompareFileTime(pCacheEntryInfo->LastModifiedTime, ftLast) > 0)
#else
                        /* There is a problem with multiple cookies in a single
                         * cookie file. When adding the second cookie, we will
                         * try to delete the existing cookie (the first one that
                         * was added), and thus try to delete the cookie file
                         * itself. But, deletion of the cookie file will fail on
                         * Win32 because the file is already open above for
                         * parsing. On Unix, the deletion will succeed.
                         * So, the work-around is to not add the second cookie
                         * which is from the same site. The entry will remain
                         * in the cookie file anyway.
                         */
                        if (dwError == ERROR_SUCCESS)
#endif /* UNIX */
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or
                            // it was found and the last modified time on it is
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.

                            // Add it to the cookie container.
                            // BUGBUG - besides assert, what to do if this fails?

                            AddUrlArg Args;
                            memset(&Args, 0, sizeof(Args));
                            Args.pszUrl      = szCookieName;  // user@foobar.com
                            Args.pszFilePath = szCookieFileName; // c:\winnt\cookies\user@foobar.txt
                            Args.qwExpires   = FT2LL(ftExpire); // Expire time.
                            Args.qwLastMod   = FT2LL(ftLast); // Last modified time.
                            Args.dwEntryType |= COOKIE_CACHE_ENTRY;
                            dwError = UrlContainer->AddUrl(&Args);

                            TcpsvcsDbgAssert(dwError == ERROR_SUCCESS);
                        }

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.

        } while (FindNextFile(hFind, &FindData));


        // No more cookie files or an error occured.
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != I