ESCRIPTOR));

                numBytesToCopy -= sizeof(STORAGE_DEVICE_DESCRIPTOR);
                outBuffer      += sizeof(STORAGE_DEVICE_DESCRIPTOR);
            }
            else
            {
                RtlCopyMemory (outBuffer, &deviceDescriptor, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->VendorIdOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > VENDORSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, vendorString, VENDORSTRINGSIZE);
                outBuffer[VENDORSTRINGSIZE] = '\0';

                numBytesToCopy -= VENDORSTRINGSIZE + 1;
                outBuffer      += VENDORSTRINGSIZE + 1;
            }
            else
            {
                RtlCopyMemory (outBuffer, vendorString, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->ProductIdOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > PRODUCTSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, productString, PRODUCTSTRINGSIZE);
                outBuffer[PRODUCTSTRINGSIZE] = '\0';

                numBytesToCopy -= PRODUCTSTRINGSIZE + 1;
                outBuffer      += PRODUCTSTRINGSIZE + 1;
            }
            else
            {
                RtlCopyMemory (outBuffer, productString, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->ProductRevisionOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > REVISIONSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, revisionString, REVISIONSTRINGSIZE);
                outBuffer[REVISIONSTRINGSIZE] = '\0';

                numBytesToCopy -= REVISIONSTRINGSIZE + 1;
                outBuffer      += REVISIONSTRINGSIZE + 1;
            }
            else
            {
                RtlCopyMemory (outBuffer, revisionString, numBytesToCopy);
                break;
            }

            storageDeviceDescriptor->SerialNumberOffset = (ULONG) (outBuffer - outBufferBegin);

            if (numBytesToCopy > SERIALSTRINGSIZE + 1)
            {
                RtlCopyMemory (outBuffer, serialString, SERIALSTRINGSIZE);
                outBuffer[SERIALSTRINGSIZE] = '\0';
            }
            else
            {
                RtlCopyMemory (outBuffer, serialString, numBytesToCopy);
            }

            break;
        }

        case StorageAdapterProperty: {

            RtlZeroMemory (&adapterDescriptor, sizeof(adapterDescriptor));

            adapterDescriptor.Version                = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
            adapterDescriptor.Size                   = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
            adapterDescriptor.MaximumTransferLength  = MAX_TRANSFER_SIZE_PER_SRB;
            adapterDescriptor.MaximumPhysicalPages   = 0xffffffff;
            adapterDescriptor.AlignmentMask          = 0x1;
            adapterDescriptor.AdapterUsesPio         = TRUE;
            adapterDescriptor.AdapterScansDown       = FALSE;
            adapterDescriptor.CommandQueueing        = FALSE;
            adapterDescriptor.AcceleratedTransfer    = FALSE;
            adapterDescriptor.BusType                = BusTypeAta;
            adapterDescriptor.BusMajorVersion        = 1;
            adapterDescriptor.BusMinorVersion        = 0;

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                                sizeof(STORAGE_ADAPTER_DESCRIPTOR)) {

                outBufferSize = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

            } else {

                outBufferSize = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
            }

            RtlCopyMemory (QueryIrp->AssociatedIrp.SystemBuffer,
                           &adapterDescriptor,
                           outBufferSize);

            QueryIrp->IoStatus.Information = outBufferSize;
            status = STATUS_SUCCESS;
            break;
        }

        default: {

            status = STATUS_NOT_IMPLEMENTED;
            QueryIrp->IoStatus.Information = 0;
            break;
        }
    }

    QueryIrp->IoStatus.Status = status;
    IoCompleteRequest(QueryIrp, IO_DISK_INCREMENT);

    return status;
}


NTSTATUS
TrueffsCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    create and close routine.  This is called by the I/O system
    when the device is opened or closed.

Arguments:

    DeviceObject - Pointer to device object
    Irp - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateClose\n"));
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;

}


NTSTATUS
TrueffsPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION  deviceExtension;
    PPDO_EXTENSION pdoExtension = NULL;
    PDEVICE_EXTENSION_HEADER devExtension;
    NTSTATUS status;
    KIRQL cIrql;
    KEVENT event;
    BOOLEAN Fdo = FALSE;
    BOOLEAN processHeldRequests = FALSE;

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    if (IS_FDO(devExtension))
    {
        deviceExtension = DeviceObject->DeviceExtension;
        Fdo = TRUE;
    }
    else
    {
        pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: Function %Xh %cDO.\n",irpStack->MinorFunction, Fdo ? 'F':'P'));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    switch (irpStack->MinorFunction)
    {

    case IRP_MN_START_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: PnpDeviceControl: START_DEVICE\n"));

        if (Fdo)
        {
            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;
            if (deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)
            {
                processHeldRequests = TRUE;
            }
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            status = TrueffsStartDevice(deviceExtension, irpStack->Parameters.StartDevice.AllocatedResourcesTranslated, TRUE);

            if (NT_SUCCESS(status))
            {
                //
                // Forward this request down synchronously, so that the lower drivers can be started
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);

                if (NT_SUCCESS(status))
                {
                    status = TrueffsMountMedia(deviceExtension);

                    KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
                    deviceExtension->DeviceFlags &= ~DEVICE_FLAG_STOPPED;
                    deviceExtension->DeviceFlags |=  DEVICE_FLAG_STARTED;
                    KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

                    if (processHeldRequests && !KeReadStateSemaphore(&deviceExtension->requestSemaphore))
                    {
                        KeReleaseSemaphore(&deviceExtension->requestSemaphore, (KPRIORITY) 0, 1, FALSE);
                    }
                }
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        else
        {
            status = STATUS_SUCCESS;

            if (!pdoExtension->CrashDumpPathCount)
            {
                DEVICE_POWER_STATE devicePowerState = PowerDeviceD3;

                pdoExtension->IdleCounter = PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject,
                                                                             DEVICE_DEFAULT_IDLE_TIMEOUT,
                                                                             DEVICE_DEFAULT_IDLE_TIMEOUT,
                                                                             devicePowerState);
            }

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_CHILD_REMOVED;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            TrueffsWmiRegister ((PDEVICE_EXTENSION_HEADER)pdoExtension);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: QUERY_STOP_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            if (deviceExtension->PagingPathCount || deviceExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            if (pdoExtension->PagingPathCount || pdoExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: Failing QUERY_STOP: we are in PagingPath or CrashDumpPath\n"));
            break;
        }

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        if (Fdo)
        {
            if (deviceExtension->TffsportThreadObject)
            {
                KeWaitForSingleObject(&deviceExtension->PendingIRPEvent, Executive, KernelMode, FALSE, NULL);
            }

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_STOP_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: STOP_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            TrueffsStopRemoveDevice(deviceExtension);

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;
            deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
        }
        else
        {
            DEVICE_POWER_STATE devicePowerState = PowerDeviceD3;

            if (pdoExtension->IdleCounter)
            {
                PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject, 0, 0, devicePowerState);
                pdoExtension->IdleCounter = NULL;
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: QUERY_REMOVE_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            if (deviceExtension->PagingPathCount || deviceExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            if (pdoExtension->PagingPathCount || pdoExtension->CrashDumpPathCount)
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: Failing QUERY_REMOVE: we are in PagingPath or CrashDumpPath\n"));
            break;
        }

        //
        // We're not going to queue irps during remove device
        // KLUDGE
        //
        //
        // KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        // deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
        // KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);
        //

        if (Fdo)
        {
            // No need to wait for the thread to become idle
            // KLUDGE
            // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
            //    KeWaitForSingleObject(&deviceExtension->PendingIRPEvent,
            //                            Executive, KernelMode, FALSE, NULL);
            // }
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: CANCEL_STOP_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
        {
            KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0, 1, FALSE);
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: CANCEL_REMOVE_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        //
        // This flas was never set by QUERY_REMOVE
        // due to the KLUDGE we added, for not queuing IRPS's during QUERY_REMOVE
        //
        // KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        // deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
        // KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
        {
            KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0, 1, FALSE);
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: REMOVE_DEVICE\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED))
            {
               // Set the QUERY_STOP_REMOVE FLAG
               // Part of the KLUDGE, we had removed this from the QUERY_REMOVE IRP
               // processing
               KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
               deviceExtension->DeviceFlags |= DEVICE_FLAG_QUERY_STOP_REMOVE;
               KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

               // Now wait for the thread to complete any work its doing
               // Better wait for the thread to complete the current IRP it may be
               // working on
               //
               // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
               //
               if (deviceExtension->TffsportThreadObject)
               {
                   KeWaitForSingleObject(&deviceExtension->PendingIRPEvent, Executive, KernelMode, FALSE, NULL);
               }

               KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
               deviceExtension->DeviceFlags |=  DEVICE_FLAG_REMOVED;
               deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
               deviceExtension->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
               KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

               while (ExInterlockedRemoveHeadList(&deviceExtension->listEntry, &deviceExtension->listSpinLock))
               {
                   ;
               }

               KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
               deviceExtension->threadReferenceCount = 0;
               KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

               if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
               {
                  KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0,1,FALSE);
               }

               //
               // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
               //
               if (deviceExtension->TffsportThreadObject)
               {
                   KeWaitForSingleObject(deviceExtension->TffsportThreadObject, Executive, KernelMode, FALSE, NULL);
                   ObDereferenceObject(deviceExtension->TffsportThreadObject);
                   deviceExtension->TffsportThreadObject = NULL;
               }

               TrueffsStopRemoveDevice(deviceExtension);
            }

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

            //
            // Clean up resources here
            //
            if (deviceExtension->ChildPdo != NULL)
            {
                IoDeleteDevice(deviceExtension->ChildPdo);
            }

            TrueffsDeleteSymblicLinks(deviceExtension);
            IoDetachDevice(deviceExtension->LowerDeviceObject);
            IoDeleteDevice(DeviceObject);
        }
        else
        {
            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_CHILD_REMOVED))
            {
                DEVICE_POWER_STATE devicePowerState;

                KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
                deviceExtension->DeviceFlags |= DEVICE_FLAG_CHILD_REMOVED;
                deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
                deviceExtension->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
                KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

                while (ExInterlockedRemoveHeadList(&deviceExtension->listEntry, &deviceExtension->listSpinLock))
                {
                    ;
                }

                devicePowerState = PowerDeviceD3;

                if (pdoExtension->IdleCounter)
                {
                    PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject, 0, 0, devicePowerState);
                    pdoExtension->IdleCounter = NULL;
                }

                TrueffsWmiDeregister((PDEVICE_EXTENSION_HEADER)pdoExtension);
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_SURPRISE_REMOVAL:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: SURPRISE_REMOVAL\n"));

        status = STATUS_SUCCESS;

        if (Fdo)
        {
            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_REMOVED;
            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_QUERY_STOP_REMOVE;
            deviceExtension->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            while (ExInterlockedRemoveHeadList(&deviceExtension->listEntry,&deviceExtension->listSpinLock))
            {
                ;
            }

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->threadReferenceCount = 0;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore))
            {
                KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0, 1, FALSE);
            }

            //
            // if (deviceExtension->DeviceFlags & DEVICE_FLAG_THREAD) {
            //
            if (deviceExtension->TffsportThreadObject)
            {
                KeWaitForSingleObject(deviceExtension->TffsportThreadObject, Executive, KernelMode, FALSE, NULL);
                ObDereferenceObject(deviceExtension->TffsportThreadObject);
                deviceExtension->TffsportThreadObject = NULL;
            }

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

            TrueffsStopRemoveDevice(deviceExtension);
            TrueffsDeleteSymblicLinks(deviceExtension);
        }
        else
        {
            DEVICE_POWER_STATE devicePowerState;

            IoInvalidateDeviceRelations(deviceExtension->MainPdo,BusRelations);

            KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
            deviceExtension->DeviceFlags |= DEVICE_FLAG_CHILD_REMOVED;
            KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

            devicePowerState = PowerDeviceD3;

            if (pdoExtension->IdleCounter)
            {
                PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject, 0, 0, devicePowerState);
                pdoExtension->IdleCounter = NULL;
            }

            TrueffsWmiDeregister((PDEVICE_EXTENSION_HEADER)pdoExtension);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_QUERY_ID:

        status = TrueffsDeviceQueryId(DeviceObject, Irp, Fdo);
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        status = TrueffsQueryDeviceRelations(DeviceObject, Irp, Fdo);
        break;

    case IRP_MN_QUERY_CAPABILITIES:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: QUERY_CAPABILITIES\n"));

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            status = TrueffsDeviceQueryCapabilities(deviceExtension, irpStack->Parameters.DeviceCapabilities.Capabilities);

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl: DEVICE_USAGE_NOTIFICATION, Type %Xh\n", irpStack->Parameters.UsageNotification.Type));

        if (Fdo)
        {
            PULONG deviceUsageCount = NULL;

            if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED))
            {
                status = STATUS_DEVICE_NOT_READY;

                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
            }

            switch (irpStack->Parameters.UsageNotification.Type)
            {
                case DeviceUsageTypePaging:
                    deviceUsageCount = &deviceExtension->PagingPathCount;
                    break;

                case DeviceUsageTypeHibernation:
                    deviceUsageCount = &deviceExtension->HiberPathCount;
                    break;

                case DeviceUsageTypeDumpFile:
                    deviceUsageCount = &deviceExtension->CrashDumpPathCount;
                    break;

                default:
                    deviceUsageCount = NULL;
                    break;
            }

            //
            // Forward this request down synchronously, in case a lower driver wants to veto it
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);

            if (NT_SUCCESS(status))
            {
                if (deviceUsageCount)
                {
                    IoAdjustPagingPathCount(deviceUsageCount, irpStack->Parameters.UsageNotification.InPath);
                }
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        else
        {
            PULONG deviceUsageCount = NULL;

            if (pdoExtension)
            {
                PDEVICE_OBJECT targetDeviceObject;
                IO_STATUS_BLOCK  ioStatus = { 0 };

                switch (irpStack->Parameters.UsageNotification.Type)
                {
                    case DeviceUsageTypePaging:
                        deviceUsageCount = &pdoExtension->PagingPathCount;
                        break;

                    case DeviceUsageTypeHibernation:
                        deviceUsageCount = &pdoExtension->HiberPathCount;
                        break;

                    case DeviceUsageTypeDumpFile:
                        deviceUsageCount = &pdoExtension->CrashDumpPathCount;
                        break;

                    default:
                        deviceUsageCount = NULL;
                        break;
                }

                targetDeviceObject = IoGetAttachedDeviceReference(deviceExtension->DeviceObject);

                ioStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                status = TrueffsSyncSendIrp(targetDeviceObject, irpStack, &ioStatus);

                ObDereferenceObject(targetDeviceObject);

                if (NT_SUCCESS(status))
                {
                    if (deviceUsageCount)
                    {
                        IoAdjustPagingPathCount(deviceUsageCount, irpStack->Parameters.UsageNotification.InPath);
                    }

                    if (irpStack->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile)
                    {

                        POWER_STATE powerState;
                        DEVICE_POWER_STATE devicePowerState = PowerDeviceD3;

                        //
                        // Reset the idle timeout to "forever"
                        //
                        pdoExtension->IdleCounter = PoRegisterDeviceForIdleDetection(pdoExtension->DeviceObject,
                                                                                     DEVICE_VERY_LONG_IDLE_TIMEOUT,
                                                                                     DEVICE_VERY_LONG_IDLE_TIMEOUT,
                                                                                     devicePowerState);
                        if (pdoExtension->IdleCounter)
                        {
                            PoSetDeviceBusy(pdoExtension->IdleCounter);
                        }

                        powerState.DeviceState = PowerDeviceD0;

                        PoRequestPowerIrp(pdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
                    }
                }
            }
            else
            {

                status = STATUS_NO_SUCH_DEVICE;
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;

    default:

        if (Fdo)
        {
            //
            // Forward this request down, in case a lower driver understands it
            //
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            //
            // Complete this request without altering its status
            //
            status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PnpDeviceControl status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  newIrpSp;
    PIRP                newIrp;
    KEVENT              event;
    NTSTATUS            status;

    newIrp = IoAllocateIrp (TargetDeviceObject->StackSize, FALSE);
    if (newIrp == NULL) {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: SyncSendIrp: Unable to allocate an irp\n"));
        return STATUS_NO_MEMORY;
    }
    newIrpSp = IoGetNextIrpStackLocation(newIrp);
    RtlMoveMemory (newIrpSp, IrpSp, sizeof (*IrpSp));

    if (IoStatus) {
        newIrp->IoStatus.Status = IoStatus->Status;
    } else {
        newIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoSetCompletionRoutine (
        newIrp,
        TrueffsSyncSendIrpCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE);
    status = IoCallDriver (TargetDeviceObject, newIrp);
    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }
    status = newIrp->IoStatus.Status;
    if (IoStatus) {
        *IoStatus = newIrp->IoStatus;
    }
    IoFreeIrp (newIrp);
    return status;
}


NTSTATUS
TrueffsSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;
    KeSetEvent(event, EVENT_INCREMENT,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
TrueffsCallDriverSync(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, TrueffsCallDriverSyncCompletion, &event, TRUE, TRUE, TRUE);

    status = IoCallDriver(DeviceObject, Irp);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = Irp->IoStatus.Status;

    return status;
}


NTSTATUS
TrueffsCallDriverSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = (PKEVENT)Context;

    ASSERT(Irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
TrueffsPowerControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_EXTENSION_HEADER devExtension;
    BOOLEAN Fdo = FALSE;
    NTSTATUS status;

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    if (IS_FDO(devExtension))
    {
        deviceExtension = DeviceObject->DeviceExtension;
        Fdo = TRUE;
    }
    else
    {
        PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PowerControl: Function %Xh %cDO.\n", irpStack->MinorFunction,Fdo ? 'F':'P'));

    switch (irpStack->MinorFunction)
    {

    case IRP_MN_SET_POWER:

        if (Fdo)
        {
            status = TrueffsSetFdoPowerState(DeviceObject, Irp);
        }
        else
        {
            status = TrueffsSetPdoPowerState(DeviceObject, Irp);
        }
        break;

    case IRP_MN_QUERY_POWER:

        status = STATUS_SUCCESS;
        PoStartNextPowerIrp(Irp);

        if (Fdo)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;

    default:

        PoStartNextPowerIrp(Irp);

        if (Fdo)
        {
            //
            // Forward this request down, in case a lower driver understands it
            //
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->LowerDeviceObject, Irp);
        }
        else
        {
            //
            // Complete this request without altering its status
            //
            status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PowerControl status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsSetFdoPowerState (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN OUT PIRP Irp
                       )
/*++

Routine Description

   Dispatches the IRP based on whether a system power state
   or device power state transition is requested

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PDEVICE_EXTENSION  fdoExtension;
   PIO_STACK_LOCATION irpStack;
   NTSTATUS           status = STATUS_SUCCESS;
   PFDO_POWER_CONTEXT context = NULL;
   BOOLEAN            passItDown;

   fdoExtension = DeviceObject->DeviceExtension;

   context = ExAllocatePoolWithTag (NonPagedPool, sizeof(FDO_POWER_CONTEXT), TFFSPORT_POOL_TAG);
   if (context == NULL) {

      status = STATUS_INSUFFICIENT_RESOURCES;
   } else {

      RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));
      irpStack = IoGetCurrentIrpStackLocation (Irp);

      passItDown = TRUE;
      context->PowerType  = irpStack->Parameters.Power.Type;
      context->PowerState = irpStack->Parameters.Power.State;

      if (irpStack->Parameters.Power.Type == SystemPowerState) {

         if (fdoExtension->SystemPowerState == irpStack->Parameters.Power.State.SystemState) {

            // We are already in the given state
            passItDown = FALSE;
         }

      } else if (irpStack->Parameters.Power.Type == DevicePowerState) {

         if (fdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

               // getting out of D0 state, better call PoSetPowerState now
               PoSetPowerState (
                               DeviceObject,
                               DevicePowerState,
                               irpStack->Parameters.Power.State
                               );
            }

         } else {

            // We are already in the given state
            passItDown = FALSE;
         }
      } else {

          status = STATUS_INVALID_DEVICE_REQUEST;
      }
   }

   if (NT_SUCCESS(status) && passItDown) {

      if ((irpStack->Parameters.Power.Type == DevicePowerState) &&
          (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3)) {

          // Getting out of D0 - cancel the timer
          if (timerWasStarted) {
              KeCancelTimer(&timerObject);
              timerWasStarted = FALSE;
          }
      }

      if (irpStack->Parameters.Power.Type == SystemPowerState) {

          //
          // When we get a System Power IRP (S IRP) the correct thing to do
          // is to request a D, and pass the S IRP as context to the D IRP
          // completion routine.  Once the D IRP completes we can pass
          // down the S IRP
          //

          POWER_STATE powerState;

          // Switch to the appropriate device power state
          if (context->PowerState.SystemState == PowerSystemWorking) {

              powerState.DeviceState = PowerDeviceD0;

          } else {

              // We don't need to take special care of leaving the device
              // in powered state in case of hibernation, because it cannot
              // be switched off. Since the device is always on it is enough
              // to send PowerDeviceD3 thus simulating power off.

              powerState.DeviceState = PowerDeviceD3;
          }

          // Transitioned to system state
          fdoExtension->SystemPowerState = context->PowerState.SystemState;

          // Request the IRP for D Power
          status = PoRequestPowerIrp (
              DeviceObject,
              IRP_MN_SET_POWER,
              powerState,
              TrueffsFdoDevicePowerIrpCompletionRoutine,
              Irp,
              NULL
              );

          if (NT_SUCCESS(status)) {
              status = STATUS_PENDING;
          }

          // In this case we should free the context pool because it wont
          // reach the completion callback routine
          ExFreePool(context);


      } else {

          //
          // Its a D irp, we just want to pass down (device power)
          //
          // Send the IRP to the pdo
          IoCopyCurrentIrpStackLocationToNext (Irp);

          IoSetCompletionRoutine(Irp,
                              TrueffsFdoPowerCompletionRoutine,
                              context,
                              TRUE,
                              TRUE,
                              TRUE);

          status = PoCallDriver(fdoExtension->LowerDeviceObject, Irp);

      }

      return (status);


   } else {

      // Unblock the power IRPs and complete the current IRP
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = status;
      PoStartNextPowerIrp (Irp);
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      if (context) {
         ExFreePool (context);
      }
      return status;
   }
}


NTSTATUS
TrueffsFdoDevicePowerIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID contextIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description

    Completion routine for Device Power IRPS.  The context will be the S power IRP
    that was received, and we can now send down the stack

Parameters

    DeviceObject    -   Pointer to FDO for the controller
    Irp             -   Pointer to the D power irp which is completing
    context  -   Pointer to the S power irp that can now be sent down the stack

--*/
{
    PIRP                systemPowerIrp = (PIRP) contextIrp;
    PDEVICE_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS            status;
    PFDO_POWER_CONTEXT  context = NULL;
    PIO_STACK_LOCATION  irpStack = NULL;

    if (!NT_SUCCESS(IoStatus->Status)) {
        // The D IRP is not allowed to fail
        ASSERT(0);
    }

    //
    // Allocate space for the context of the S IRP completion routine
    //
    context = ExAllocatePoolWithTag (NonPagedPool, sizeof(FDO_POWER_CONTEXT), TFFSPORT_POOL_TAG);
    if (context == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;

        // Unblock the power IRPs and complete the current IRP
        systemPowerIrp->IoStatus.Information = 0;
        systemPowerIrp->IoStatus.Status = status;
        PoStartNextPowerIrp (systemPowerIrp);
        IoCompleteRequest(systemPowerIrp, IO_NO_INCREMENT);

    } else {

        // Clear the memory we just allocated
        RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));

        // Get current IRP Stack for S-IRP
        irpStack = IoGetCurrentIrpStackLocation (systemPowerIrp);
        ASSERT(irpStack);

        context->PowerType  = irpStack->Parameters.Power.Type;
        context->PowerState = irpStack->Parameters.Power.State;

        // The D IRP has completed, now we can send the S IRP down
        IoCopyCurrentIrpStackLocationToNext (systemPowerIrp);
        IoSetCompletionRoutine(systemPowerIrp,
                            TrueffsFdoPowerCompletionRoutine,
                            context,
                            TRUE,
                            TRUE,
                            TRUE);

        status = PoCallDriver(fdoExtension->LowerDeviceObject, systemPowerIrp);
    }

    return (status);
}


NTSTATUS
TrueffsFdoPowerCompletionRoutine (
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp,
                                IN PVOID Context
                                )
/*++

Routine Description

   Completion routine for the power IRP sent down to the PDO for the
   controller. If we are getting out of a working system state,
   requests a power IRP to put the device in an appropriate device power state.

Parameters

   DeviceObject   -    Pointer to FDO for the controller
   Irp            -    Pointer to the IRP for the power request
   Context        -    Pointer to the FDO_POWER_CONTEXT which is
                       filled in when the IRP is passed down
Return Value

   Status

--*/
{
   PFDO_POWER_CONTEXT context = Context;
   BOOLEAN            callPoSetPowerState;
   PDEVICE_EXTENSION  fdoExtension;

   fdoExtension = DeviceObject->DeviceExtension;

   if ((NT_SUCCESS(Irp->IoStatus.Status))) {

      callPoSetPowerState = TRUE;

      if (context->PowerType == SystemPowerState) {
          // Do Nothing

      } else if (context->PowerType == DevicePowerState) {

         if (fdoExtension->DevicePowerState == PowerDeviceD0) {

            // PoSetPowerState is called before we get out of D0
            callPoSetPowerState = FALSE;

         }
         else if (context->PowerState.DeviceState == PowerDeviceD0) {

             // Getting back to D0, set the timer on
             startIntervalTimer();

         }
         fdoExtension->DevicePowerState = context->PowerState.DeviceState;
      } else {
          // How did we not get either a SystemPowerState or a DevicePowerState
          ASSERT(0);
      }

      if (callPoSetPowerState) {

         PoSetPowerState (
                         DeviceObject,
                         context->PowerType,
                         context->PowerState
                         );
      }

   }
   ExFreePool(Context);

   PoStartNextPowerIrp (Irp);
   return Irp->IoStatus.Status;
}


NTSTATUS
TrueffsSetPdoDevicePowerState( IN PDEVICE_OBJECT Pdo,
                           IN OUT PIRP Irp
                              )
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PDEVICE_EXTENSION deviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   DEVICE_POWER_STATE newDevicePowerState;
   NTSTATUS status;
   BOOLEAN setPowerRequest, powerUp, powerUpParent;
   KIRQL cIrql;

   status = STATUS_SUCCESS;
   newDevicePowerState = irpStack->Parameters.Power.State.DeviceState;

   deviceExtension = pdoExtension->Pext;

   TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Transition to device power state: %d\n", newDevicePowerState));

   setPowerRequest = FALSE;
   powerUp = FALSE;
   powerUpParent=FALSE;

   if (pdoExtension->DevicePowerState == newDevicePowerState) {
      return STATUS_SUCCESS;
   }

   if (pdoExtension->DevicePowerState == PowerDeviceD0) {

      // Getting out of D0 -  Call PoSetPowerState first
      POWER_STATE newPowerState;

      newPowerState.DeviceState = newDevicePowerState;
      PoSetPowerState(Pdo,
                      DevicePowerState,
                      newPowerState);
   }

   if (newDevicePowerState == PowerDeviceD0 ||
       newDevicePowerState == PowerDeviceD1 ||
       newDevicePowerState == PowerDeviceD2) {

      if (pdoExtension->DevicePowerState == PowerDeviceD3) {
         // D3 --> D0, D1 or D2 .. Wake up
         powerUpParent = TRUE;
         setPowerRequest = TRUE;
         powerUp = TRUE;
      }
   }
   else {  /* newDevicePowerState == D3 */
      if (pdoExtension->DevicePowerState != PowerDeviceD3) {
        // We need to power down now.
        setPowerRequest=TRUE;
      }
   }

   if (setPowerRequest && NT_SUCCESS(status)) {
      // Parent might have to be powered up..
      if (powerUpParent) {
         status = TrueffsFdoChildRequestPowerUp(pdoExtension->Pext,
                                               pdoExtension,
                                               Irp);
      } else {

          if (powerUp) {
                            /* MDOC PLUS */
                            /*
              DOC2window *memWinPtr;
              memWinPtr = (DOC2window *) pdoExtension->Pext->pcmciaParams.windowBase;
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_RESET_MODE);
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_RESET_MODE);
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_NORMAL_MODE);
              tffsWriteByte(memWinPtr->DOCcontrol, ASIC_NORMAL_MODE);
                            */

              MDOCPwindow *memWinPtr;
              memWinPtr = (MDOCPwindow *) pdoExtension->Pext->pcmciaParams.windowBase;
                            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x04);
                            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfb);
                            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x05);
                            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfa);


              KeAcquireSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,&cIrql);
              pdoExtension->Pext->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
              KeReleaseSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,cIrql);
                          if (!KeReadStateSemaphore(&pdoExtension->Pext->requestSemaphore)) {
                                  KeReleaseSemaphore(&pdoExtension->Pext->requestSemaphore,(KPRIORITY) 0,1,FALSE);
                          }
          } else {

              KeAcquireSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,&cIrql);
              pdoExtension->Pext->DeviceFlags |= DEVICE_FLAG_HOLD_IRPS;
              KeReleaseSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,cIrql);

              //
              // if (pdoExtension->Pext->DeviceFlags & DEVICE_FLAG_THREAD) {
              //
              if (deviceExtension->TffsportThreadObject) {
                KeWaitForSingleObject(&pdoExtension->Pext->PendingIRPEvent, Executive, KernelMode, FALSE, NULL);
              }
          }
      }
   }
   return status;
}


NTSTATUS
TrueffsSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION     pdoExtension;
    SYSTEM_POWER_STATE newSystemState;
    POWER_STATE        powerState;

    pdoExtension = DeviceObject->DeviceExtension;
    status = STATUS_SUCCESS;

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    newSystemState = irpStack->Parameters.Power.State.SystemState;

    if (pdoExtension->SystemPowerState != newSystemState) {
        if (pdoExtension->SystemPowerState == PowerSystemWorking) {

            // Getting out of working state.
            if ((newSystemState == PowerSystemHibernate) &&
                        pdoExtension->HiberPathCount) {

                // spin up for the hiber dump driver
                powerState.DeviceState = PowerDeviceD0;

            } else {

                // put the device to D3
                // Issue a D3 to top of my drive stack
                powerState.DeviceState = PowerDeviceD3;
            }
            status = PoRequestPowerIrp (
                         DeviceObject,
                         IRP_MN_SET_POWER,
                         powerState,
                         TrueffsPdoRequestPowerCompletionRoutine,
                         Irp,
                         NULL
                         );

            if (NT_SUCCESS(status)) {

                status = STATUS_PENDING;
            }
        } else {
            if (newSystemState == PowerSystemWorking) {
                powerState.DeviceState = PowerDeviceD0;
            } else {
                powerState.DeviceState = PowerDeviceD3;
            }

            status = PoRequestPowerIrp (
                        DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        TrueffsPdoRequestPowerCompletionRoutine,
                        Irp,
                        NULL
                        );

            if (NT_SUCCESS(status)) {
                status = STATUS_PENDING;
            }
        }
    }
    return status;
}


NTSTATUS
TrueffsSetPdoPowerState(
                      IN PDEVICE_OBJECT Pdo,
                      IN OUT PIRP Irp
                      )
{
   NTSTATUS status;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

   IoMarkIrpPending(Irp);

   if (irpStack->Parameters.Power.Type == DevicePowerState) {
      status = TrueffsSetPdoDevicePowerState(Pdo, Irp);
   } else if (irpStack->Parameters.Power.Type == SystemPowerState) {
      status = TrueffsSetPdoSystemPowerState(Pdo, Irp);
   } else {
      status = STATUS_NOT_IMPLEMENTED;
   }

   if (status != STATUS_PENDING) {
      Irp->IoStatus.Status = status;
      TrueffsPdoCompletePowerIrp(Pdo, Irp);
   }
   return status;
}


VOID
TrueffsPdoCompletePowerIrp (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          )
{
   PPDO_EXTENSION          pdoExtension;
   PDEVICE_EXTENSION       fdoExtension;
   PIO_STACK_LOCATION      irpStack;
   BOOLEAN                 callPoSetPowerState;

   irpStack = IoGetCurrentIrpStackLocation (Irp);
   pdoExtension = DeviceObject->DeviceExtension;
   fdoExtension = pdoExtension->Pext;

   if (NT_SUCCESS(Irp->IoStatus.Status)) {

      callPoSetPowerState = TRUE;

      Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;

      if (irpStack->Parameters.Power.Type == SystemPowerState) {

         if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

            pdoExtension->SystemPowerState = Irp->IoStatus.Information;
         }

      } else { /* if (irpStack->Parameters.Power.Type == DevicePowerState) */

         if (pdoExtension->DevicePowerState == PowerDeviceD0) {

            // PoSetPowerState is called before we power down
            callPoSetPowerState = FALSE;
         }

         if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
            if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {

               // tell parent that we just fell to sleep
               TrueffsFdoChildReportPowerDown(fdoExtension);
            }

            pdoExtension->DevicePowerState = Irp->IoStatus.Information;
         }
      }

      if (callPoSetPowerState) {

         // we didn't get out of device D0 state. calling PoSetPowerState now
         PoSetPowerState (
                         pdoExtension->DeviceObject,
                         irpStack->Parameters.Power.Type,
                         irpStack->Parameters.Power.State
                         );
      }

   }

   PoStartNextPowerIrp (Irp);
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


VOID
TrueffsPdoRequestPowerCompletionRoutine(
                                      IN PDEVICE_OBJECT Pdo,
                                      IN UCHAR MinorFunction,
                                      IN POWER_STATE PowerState,
                                      IN PVOID Context,
                                      IN PIO_STATUS_BLOCK IoStatus
                                      )
{
   PIO_STACK_LOCATION irpStack;
   PIRP               irp = Context;

   irp->IoStatus.Status = IoStatus->Status;
   TrueffsPdoCompletePowerIrp (Pdo,irp);
   return;
}


NTSTATUS
TrueffsParentPowerUpCompletionRoutine(
                                    IN PVOID Context,
                                    IN NTSTATUS FdoStatus
                                    )
/*++

Routine Description

   Completion routine for powering up the controller.

Arguments

   Context   -  Context passed in - this is a pointer to the device extension of
                the disk which originally triggered the power-up of the controller

   FdoStatus - Status of the power up operation of the controller

Return Value

   status

--*/
{

   PPDO_EXTENSION pdoExtension = Context;
   PIRP           irp;
   NTSTATUS       status = FdoStatus;
   KIRQL cIrql;

   if (NT_SUCCESS(FdoStatus)) {

       // Parent woke up..
       /* MDOC PLUS */
    MDOCPwindow *memWinPtr;
        DOC2window *memDOC2000WinPtr;
        volatile  UCHAR chipId = 0;

        memDOC2000WinPtr = (DOC2window *) pdoExtension->Pext->pcmciaParams.windowBase;
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_RESET_MODE);
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_RESET_MODE);
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);
        tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);
        chipId = tffsReadByte(memDOC2000WinPtr->chipId);
        if((chipId == 0x20) || (chipId == 0x30)){

        }
        else{
             /* MDOC PLUS */
        memWinPtr = (MDOCPwindow *) pdoExtension->Pext->pcmciaParams.windowBase;
            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x04);
            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfb);
            tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x05);
            tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfa);
        }


         KeAcquireSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,&cIrql);
         pdoExtension->Pext->DeviceFlags &= ~DEVICE_FLAG_HOLD_IRPS;
         KeReleaseSpinLock(&pdoExtension->Pext->ExtensionDataSpinLock,cIrql);
     if (!KeReadStateSemaphore(&pdoExtension->Pext->requestSemaphore)) {
             KeReleaseSemaphore(&pdoExtension->Pext->requestSemaphore,(KPRIORITY) 0,1,FALSE);
     }
   }

   if ((irp = pdoExtension->PendingPowerIrp)!=NULL) {

        // This is the IRP (for the pdo) that originally caused us to power up the parent
        // Complete it now
        irp->IoStatus.Status = status;
        pdoExtension->PendingPowerIrp = NULL;
        TrueffsPdoCompletePowerIrp(pdoExtension->DeviceObject, irp);
   }
   return status;
}


NTSTATUS
TrueffsFdoChildRequestPowerUp (
                             IN PDEVICE_EXTENSION         FdoExtension,
                             IN PPDO_EXTENSION            PdoExtension,
                             IN PIRP                      Irp
                             )
/*++

Routine Description

   This routine is called whenever a disk needs to be powered up due to
   a device state change. This routine would then  check if the controller
   is powered down and if so, it would request a power IRP to power up the
   controller

Arguments

   FdoExtension   - Pointer to the device extension for the FDO of the
                    controller

   PdoExtension   - Pointer to the device extension for the PDO of the
                    disk. This is required so that this routine can
                    call a completion routine on behalf of the PDO when
                    the controller is powered up with the appropriate context

   Irp            - Irp that needs to be completed when the controller is
                    powered up

Return Value:

   status

--*/
{
   NTSTATUS    status;
   POWER_STATE powerState;


   status = STATUS_SUCCESS;

   if (InterlockedCompareExchange(&FdoExtension->NumberOfDisksPoweredUp, 0, 0) == 0) {

      // One of the children is coming out of sleep,
      // we need to power up the parent (the controller)
      powerState.DeviceState = PowerDeviceD0;

      // Passed in IRP needs to be completed after
      // parent powers up
      PdoExtension->PendingPowerIrp = Irp;

      status = PoRequestPowerIrp (FdoExtension->DeviceObject,
                                  IRP_MN_SET_POWER,
                                  powerState,
                                  TrueffsFdoChildRequestPowerUpCompletionRoutine,
                                  PdoExtension,          // Context
                                  NULL
                                 );
      if (!NT_SUCCESS(status)) {
         return status;
      }
      status = STATUS_PENDING;
   } else {
      InterlockedIncrement(&FdoExtension->NumberOfDisksPoweredUp);
      TrueffsParentPowerUpCompletionRoutine(
                                            PdoExtension,
                                            (NTSTATUS) STATUS_SUCCESS
                                            );
   }
   return status;
}


NTSTATUS
TrueffsFdoChildRequestPowerUpCompletionRoutine (
                                              IN PDEVICE_OBJECT       DeviceObject,
                                              IN UCHAR                MinorFunction,
                                              IN POWER_STATE          PowerState,
                                              IN PVOID                Context,
                                              IN PIO_STATUS_BLOCK     IoStatus
                                              )
/*++

Routine Description

   Completion routine for a request by a disk to power-up the parent controller.

Arguments

   DeviceObject   -  Pointer to the Fdo for the controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested (should be D0)
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status

Return Value:

   status

--*/
{
   PDEVICE_EXTENSION fdoExtension;
   fdoExtension = DeviceObject->DeviceExtension;

   if (NT_SUCCESS(IoStatus->Status)) {
      InterlockedIncrement(&fdoExtension->NumberOfDisksPoweredUp);
   }

   TrueffsParentPowerUpCompletionRoutine(
                                         Context,
                                         (NTSTATUS) IoStatus->Status
                                         );
   return IoStatus->Status;
}


VOID
TrueffsFdoChildReportPowerDown (
                              IN PDEVICE_EXTENSION FdoExtension
                              )
/*++

Routine Description

   This routine is called whenever a disk is powered down due to
   a device state change. This routine would then determine if ALL
   disks controlled by the controller are powered down, and  if
   so, it would request a power IRP to power the controller itself down

Arguments

   FdoExtension   - Pointer to the device extension for the FDO of the controller

Return Value:

   None

--*/
{
   POWER_STATE powerState;

   InterlockedDecrement(&FdoExtension->NumberOfDisksPoweredUp);

   if (InterlockedCompareExchange(&FdoExtension->NumberOfDisksPoweredUp, 0, 0) == 0) {

      // All the children are powered down, we can now power down
      // the parent (the controller)
      powerState.DeviceState = PowerDeviceD3;
      PoRequestPowerIrp (
                        FdoExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        NULL,
                        NULL,
                        NULL
                        );
   }
   return;
}


NTSTATUS
TrueffsScsiRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION_HEADER devExtension;
    PDEVICE_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;
    KIRQL cIrql;

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    if (IS_FDO(devExtension))
    {
        deviceExtension = DeviceObject->DeviceExtension;
    }
    else
    {
        PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    //
    // Get a pointer to the scsi request block
    //
    srb = irpStack->Parameters.Scsi.Srb;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests for %Xh device object, function %Xh\n", DeviceObject, srb->Function));

    if (deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED)
    {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: ScsiRequests: Device does not exist\n"));

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    if (srb->Function == SRB_FUNCTION_CLAIM_DEVICE)
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ClaimDevice\n"));

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        if (deviceExtension->DeviceFlags & DEVICE_FLAG_CLAIMED)
        {
            status = STATUS_DEVICE_BUSY;
            srb->SrbStatus = SRB_STATUS_BUSY;
        }
        else
        {
            deviceExtension->DeviceFlags |= DEVICE_FLAG_CLAIMED;
            srb->DataBuffer = DeviceObject;

            status = STATUS_SUCCESS;
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    if (srb->Function == SRB_FUNCTION_RELEASE_DEVICE)
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ReleaseDevice\n"));

        KeAcquireSpinLock(&deviceExtension->ExtensionDataSpinLock,&cIrql);
        deviceExtension->DeviceFlags &= ~DEVICE_FLAG_CLAIMED;
        KeReleaseSpinLock(&deviceExtension->ExtensionDataSpinLock,cIrql);

        status = STATUS_SUCCESS;
        srb->SrbStatus = SRB_STATUS_SUCCESS;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;

    }

    if ((srb->Function == SRB_FUNCTION_FLUSH_QUEUE) || (srb->Function == SRB_FUNCTION_FLUSH))
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: Flush or FlushQueue\n"));

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        status = STATUS_SUCCESS;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return STATUS_SUCCESS;
    }

    if (srb->Function == SRB_FUNCTION_RESET_BUS)
    {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ResetBus\n"));

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        status = STATUS_SUCCESS;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    if (srb->Function != SRB_FUNCTION_EXECUTE_SCSI)
    {
        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: ScsiRequests: unsupported function\n"));

        status = STATUS_NOT_SUPPORTED;
        srb->SrbStatus = SRB_STATUS_ERROR;

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);

        return status;
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: ScsiRequests: ExecuteScsi\n"));

    IoMarkIrpPending(Irp);
    IoStartPacket(DeviceObject, Irp, NULL, NULL);

    return STATUS_PENDING;
}


VOID
TrueffsStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PDEVICE_EXTENSION_HEADER devExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo\n"));

    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    if (IS_FDO(devExtension)) {
        deviceExtension = DeviceObject->DeviceExtension;
        pdoExtension = deviceExtension->ChildPdo->DeviceExtension;
    }
    else {
        pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    if (deviceExtension->DeviceFlags & DEVICE_FLAG_REMOVED) {

        // we got REMOVE_DEVICE, we can't accept any more requests...
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: Device does not exist\n"));
        status = STATUS_DEVICE_DOES_NOT_EXIST;
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        IoStartNextPacket(DeviceObject,FALSE);
        return;

    }

    status = QueueIrpToThread(Irp, deviceExtension);

    if (status != STATUS_PENDING) {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: QueueIrpToThread failed with status %Xh\n", status));
        Irp->IoStatus.Status = status;
        srb->SrbStatus = SRB_STATUS_ERROR;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }
    if (pdoExtension->IdleCounter) {

        PoSetDeviceBusy(pdoExtension->IdleCounter);
    }
    if (pdoExtension->DevicePowerState != PowerDeviceD0 &&
        pdoExtension->SystemPowerState == PowerSystemWorking) {

        // We are not powered up.
        // issue an power up
        POWER_STATE powerState;

        powerState.DeviceState = PowerDeviceD0;
        PoRequestPowerIrp (
                    pdoExtension->DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL
                    );
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Irp queued\n"));
    Irp->IoStatus.Status = STATUS_PENDING;
    srb->SrbStatus = SRB_STATUS_PENDING;
    IoStartNextPacket(DeviceObject,FALSE);
    return;
}


VOID
TrueffsThread(
    PVOID Context
    )

/*++

Routine Description:

    This is the code executed by the system thread created when the
    Trueffs driver initializes.  This thread loops forever (or until a
    flag is set telling the thread to kill itself) processing packets
    put into the queue by the dispatch routines.

Arguments:

    Context - not used.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY request;
    PDEVICE_EXTENSION deviceExtension = Context;
    PSCSI_REQUEST_BLOCK Srb;
    NTSTATUS ntStatus;
    NTSTATUS waitStatus;
    LARGE_INTEGER queueWait;
    ULONG status;
    ULONG i;
    ULONG startingSector;
    PUCHAR dataOffset;
    PVOID   storedSrbDataBuffer = NULL;
    FLStatus tffsStatus = flOK;
    FLStatus flStatusProt = flOK;
    IOreq ioreq;
    IOreq ioreqProt;

    flIOctlRecord flIoctlRec;
        int l;

    CHAR vendorString[8];// = VENDORSTRING;
    CHAR productString[16];// = PRODUCTSTRING;
    CHAR revisionString[4];// = REVISIONSTRING;

    PCHAR pageData;
    ULONG parameterHeaderLength;
    ULONG blockDescriptorLength;
    PCDB  cdb;
    BOOLEAN transferForbidden;
    flFormatPhysicalInput flFp;
    flBDKOperationInput bdkOperationInput;
    flOtpInput otpInput;
    flIplInput iplInput;
    flProtectionInput protectionInput;
    void * userInput  = NULL;
    void * userOutput = NULL;

    PAGED_CODE();

    queueWait.QuadPart = -(3 * 1000 * 10000);

    do {

    KeSetEvent(&deviceExtension->PendingIRPEvent, 0, FALSE);

    // Wait for a request from the dispatch routines.
    waitStatus = KeWaitForSingleObject(
        (PVOID) &deviceExtension->requestSemaphore,
        Executive,
        KernelMode,
        FALSE,
        &queueWait );

    if (waitStatus == STATUS_SUCCESS && !(deviceExtension->DeviceFlags & DEVICE_FLAG_QUERY_STOP_REMOVE)
                                     && !(deviceExtension->DeviceFlags & DEVICE_FLAG_HOLD_IRPS)) {
        if(deviceExtension->threadReferenceCount == 0) {
            //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Thread: going to kill the thread\n"));
            deviceExtension->threadReferenceCount = -1;
            PsTerminateSystemThread( STATUS_SUCCESS );
        }
    }
    else
        continue;

    while (request = ExInterlockedRemoveHeadList(&deviceExtension->listEntry,&deviceExtension->listSpinLock)) {

        KeClearEvent(&deviceExtension->PendingIRPEvent);
        irp = CONTAINING_RECORD( request, IRP, Tail.Overlay.ListEntry );

        irpSp = IoGetCurrentIrpStackLocation( irp );
        //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Thread: Irp %Xh, IrpSp %Xh\n", irp, irpSp));

        Srb = irpSp->Parameters.Scsi.Srb;
        //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Thread: Srb %Xh DataBuffer %Xh MdlAddress %Xh\n", Srb, Srb->DataBuffer, irp->MdlAddress));

                transferForbidden = FALSE;
        if (irp->MdlAddress != NULL) {
            PVOID   tmpDataBuffer = NULL;
            MM_PAGE_PRIORITY tffsPriority =
                (deviceExtension->PagingPathCount || deviceExtension->CrashDumpPathCount) ?
                    HighPagePriority : NormalPagePriority;

            storedSrbDataBuffer = Srb->DataBuffer;

            dataOffset = MmGetSystemAddressForMdlSafe(irp->MdlAddress, tffsPriority);
            if (dataOffset != NULL) {
                tmpDataBuffer = dataOffset + (ULONG)((PUCHAR)Srb->DataBuffer -
                                  (PCCHAR)MmGetMdlVirtualAddress(irp->MdlAddress));

                //TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: TmpDataBuffer= 0x%x Srb->DataBuffer= 0x%x\n", tmpDataBuffer, Srb->DataBuffer));
                Srb->DataBuffer = tmpDataBuffer;
            }
            else {
                transferForbidden = TRUE;
                TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: MmGetSystemAddressForMdlSafe Failed\n"));
            }
        }

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
                case IOCTL_TFFS_EXTENDED_WRITE_IPL:
                    {
                    if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                    else if ( irpSp->Parameters.DeviceIoControl.InputBufferLength >
              sizeof(flUserIplInput)){
                            status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                    }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_EXTENDED_WRITE_IPL;
                    ioreq.irData   = &flIoctlRec;

                            iplInput.buf = ((flUserIplInput *)(irp->AssociatedIrp.SystemBuffer))->buf;
                            iplInput.bufLen = ((flUserIplInput *)(irp->AssociatedIrp.SystemBuffer))->bufLen;
                            flIoctlRec.inputRecord = &iplInput;
                            flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

#ifdef ENVIRONMENT_VARS
                case IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES:
                    {
                    if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                    else if ( irpSp->Parameters.DeviceIoControl.InputBufferLength >
              sizeof(flExtendedEnvVarsInput)){
                            status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                    }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES;
                    ioreq.irData   = &flIoctlRec;

                            flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                            flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES before flioctl\n"));
                            tffsStatus = flIOctl(&ioreq);
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES after flioctl\n"));

                    if( tffsStatus == flOK ) {
                                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES FLOK\n"));
                        irp->IoStatus.Information = sizeof(flExtendedEnvVarsOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
#endif /* ENVIRONMENT_VARS */

                case IOCTL_TFFS_CUSTOMER_ID:
                {
                    if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof(flCustomerIdOutput)) {

                        status = STATUS_INVALID_PARAMETER;
                        irp->IoStatus.Information = 0;
                    }
                    else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_CUSTOMER_ID;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flCustomerIdOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

                case IOCTL_TFFS_NUMBER_OF_PARTITIONS:   {       // User TFFS IOCTL - FL_GET_INFO

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInfo\n"));

                if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(flCountPartitionsOutput)) {

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Information = 0;
                }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_NUMBER_OF_PARTITIONS;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus  = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flCountPartitionsOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
            case IOCTL_TFFSFL_UNIQUE_ID:
                {       // User TFFS IOCTL -

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_UNIQUE_ID \n"));

                if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(flUniqueIdOutput)) {

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Information = 0;
                }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_UNIQUE_ID Start\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_UNIQUE_ID;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flUniqueIdOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flUserFormatPhysicalInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE Start\n"));
                        userInput = (VOID *)(irp->AssociatedIrp.SystemBuffer); //Get input parameters

                        flFp.formatType = ((flUserFormatPhysicalInput *)userInput)->formatType;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: formatType:%Xh \n",flFp.formatType));

                        flFp.fp.percentUse = (unsigned char)((flUserFormatPhysicalInput *)userInput)->fp.percentUse;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: percentUse:%Xh \n",flFp.fp.percentUse));

                        flFp.fp.noOfBDTLPartitions = ((flUserFormatPhysicalInput *)userInput)->fp.noOfBDTLPartitions;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: noOfBDTLPartitions:%Xh \n",flFp.fp.noOfBDTLPartitions));
                        flFp.fp.noOfBinaryPartitions = ((flUserFormatPhysicalInput *)userInput)->fp.noOfBinaryPartitions;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: noOfBinaryPartitions:%Xh \n",flFp.fp.noOfBinaryPartitions));
                        flFp.fp.BDTLPartitionInfo = ((flUserFormatPhysicalInput *)userInput)->fp.BDTLPartitionInfo;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: BDTLPartitionInfo:%Xh \n",flFp.fp.BDTLPartitionInfo));
                        flFp.fp.binaryPartitionInfo = ((flUserFormatPhysicalInput *)userInput)->fp.binaryPartitionInfo;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: binaryPartitionInfo:%Xh \n",flFp.fp.binaryPartitionInfo));

                        #ifdef WRITE_EXB_IMAGE
                          flFp.fp.exbBuffer = ((flUserFormatPhysicalInput *)userInput)->fp.exbBuffer;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbBuffer:%Xh \n",flFp.fp.exbBuffer));
                            flFp.fp.exbBufferLen = ((flUserFormatPhysicalInput *)userInput)->fp.exbBufferLen;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbBufferLen:%Xh \n",flFp.fp.exbBufferLen));
                            flFp.fp.exbLen = ((flUserFormatPhysicalInput *)userInput)->fp.exbLen;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbLen:%Xh \n",flFp.fp.exbLen));
                            flFp.fp.exbWindow = ((flUserFormatPhysicalInput *)userInput)->fp.exbWindow;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbWindow:%Xh \n",flFp.fp.exbWindow));
                            flFp.fp.exbFlags = ((flUserFormatPhysicalInput *)userInput)->fp.exbFlags;
                            TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: exbFlags:%Xh \n",flFp.fp.exbFlags));
                        #endif /*WRITE_EXB_IMAGE*/

                        flFp.fp.cascadedDeviceNo = ((flUserFormatPhysicalInput *)userInput)->fp.cascadedDeviceNo;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: cascadedDeviceNo:%Xh \n",flFp.fp.cascadedDeviceNo));
                        flFp.fp.noOfCascadedDevices = ((flUserFormatPhysicalInput *)userInput)->fp.noOfCascadedDevices;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: noOfCascadedDevices:%Xh \n",flFp.fp.noOfCascadedDevices));
                        flFp.fp.progressCallback = NULL;
                        flFp.fp.vmAddressingLimit = ((flUserFormatPhysicalInput *)userInput)->fp.vmAddressingLimit;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: vmAddressingLimit:%Xh \n",flFp.fp.vmAddressingLimit));
                        flFp.fp.embeddedCISlength = (unsigned short)((flUserFormatPhysicalInput *)userInput)->fp.embeddedCISlength;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: embeddedCISlength:%Xh \n",flFp.fp.embeddedCISlength));
                        flFp.fp.embeddedCIS = ((flUserFormatPhysicalInput *)userInput)->fp.embeddedCIS;
                        TffsDebugPrint((TFFS_DEB_INFO,"TrueffsFORMAT: embeddedCIS:%Xh \n",flFp.fp.embeddedCIS));

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_FORMAT_PHYSICAL_DRIVE;
                        ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = &flFp;//(VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE after flioctl\n"));
                        userInput = NULL;


                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE after flioctl  - clean userPointer\n"));
                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

        #ifdef VERIFY_VOLUME
            case IOCTL_TFFS_VERIFY_VOLUME:
            {
                  TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_VERIFY_VOLUME\n"));

                  if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                      sizeof(flOutputStatusRecord)) ||
                                    (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                      sizeof(flVerifyVolumeInput))) {

                      status = STATUS_INVALID_PARAMETER;
                      irp->IoStatus.Information = 0;
                    }
                    else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME Start\n"));

                        ioreq.irHandle = deviceExtension->UnitNumber;
                        ioreq.irFlags  = IOCTL_TFFS_VERIFY_VOLUME;
                        ioreq.irData   = &flIoctlRec;
                        flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME before flioctl\n"));
                        tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME after flioctl\n"));

                        if( tffsStatus == flOK ) {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME FLOK\n"));
                            irp->IoStatus.Information = sizeof(flVerifyVolumeOutput);
                            status = STATUS_SUCCESS;


                  }//if( tffsStatus == flOK )
                  else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IOCTL_TFFS_VERIFY_VOLUME Failed!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                  }//else( tffsStatus == flOK )

                }//if( (irpSp->Parameters
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

        #endif /* VERIFY_VOLUME */


        #ifdef HW_PROTECTION
            case IOCTL_TFFS_BDTL_HW_PROTECTION:
                {       // User TFFS IOCTL - IOCTL_TFFS_BDTL_HW_PROTECTION

                  TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDTL_HW_PROTECTION\n"));

                  if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                      sizeof(flOutputStatusRecord)) ||
                                    (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                      sizeof(flProtectionInput))) {

                      status = STATUS_INVALID_PARAMETER;
                      irp->IoStatus.Information = 0;
                    }
                    else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION Start\n"));

                        ioreq.irHandle = deviceExtension->UnitNumber;
                        ioreq.irFlags  = FL_IOCTL_BDTL_HW_PROTECTION;
                        ioreq.irData   = &flIoctlRec;
                        flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION before flioctl\n"));
                        tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION after flioctl\n"));

                        if( tffsStatus == flOK ) {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION FLOK\n"));
                            irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                            status = STATUS_SUCCESS;

                        //Change if protection has been changed
                            /*
                            //If key inserted
                            if(((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_INSERT_KEY){
                                deviceExtension->IsWriteProtected = FALSE;
                            }
                            //If type changed to protected
                            else if((((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_CHANGE_TYPE) &&
                                ((flProtectionInput *)flIoctlRec.inputRecord)->type & (READ_PROTECTED|WRITE_PROTECTED))){
                                deviceExtension->IsWriteProtected = TRUE;
                            }
                            //If type changed to unprotected
                            else if((((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_CHANGE_TYPE) &&
                                ((flProtectionInput *)flIoctlRec.inputRecord)->type  == PROTECTABLE)){
                                deviceExtension->IsWriteProtected = FALSE;
                            }
                            //If remove key - ask if we are in protectable state.
                            else if(((flProtectionInput *)flIoctlRec.inputRecord)->type == PROTECTION_REMOVE_KEY){
                            */

                                flStatusProt = flOK;
                                ioreqProt.irHandle = ioreq.irHandle;
                                ioreqProt.irFlags = 0;
                                flStatusProt = flIdentifyProtection(&ioreqProt);
                                if(flStatusProt == flOK){
                                    if((ioreqProt.irFlags & (WRITE_PROTECTED |READ_PROTECTED))
                                        && !(ioreqProt.irFlags & KEY_INSERTED )){
                                        deviceExtension->IsWriteProtected = TRUE;
                                    }
                                    else{
                                        deviceExtension->IsWriteProtected = FALSE;
                                    }
                                }
                                else{
                                    deviceExtension->IsWriteProtected = FALSE;
                                }//(flStatusProt == flOK)

                  }//if( tffsStatus == flOK )
                  else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDTL_HW_PROTECTION Failed!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                  }//else( tffsStatus == flOK )

                }//if( (irpSp->Parameters
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
            case IOCTL_TFFS_BINARY_HW_PROTECTION:
                {       // User TFFS IOCTL - IOCTL_TFFS_BDTL_HW_PROTECTION

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BINARY_HW_PROTECTION\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flProtectionInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION Start\n"));

                  //ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_BINARY_HW_PROTECTION;
                  ioreq.irData   = &flIoctlRec;

                        //Update protectionInput with flBDKProtectionInput members
                        protectionInput.protectionType  = ((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->protectionType;
                        protectionInput.type  = ((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->type;
                        tffscpy(protectionInput.key  , ((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->key, sizeof(protectionInput.key));
                        ioreq.irHandle = (deviceExtension->UnitNumber & 0x0f) + (((flBDKProtectionInput *)(irp->AssociatedIrp.SystemBuffer))->partitionNumber << 4);

                  //flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.inputRecord = &protectionInput;
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION after flioctl\n"));

                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BINARY_HW_PROTECTION Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            #endif /*HW_PROTECTION*/
            #ifdef WRITE_EXB_IMAGE
            case IOCTL_TFFS_PLACE_EXB_BY_BUFFER:
                {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_PLACE_EXB_BY_BUFFER\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord) )
                            || (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flUserPlaceExbInput) )) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        flPlaceExbInput placeExbInput;
                        ioreq.irHandle = deviceExtension->UnitNumber;
                        ioreq.irFlags  = FL_IOCTL_PLACE_EXB_BY_BUFFER;
                        ioreq.irData   = &flIoctlRec;
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.inputRecord = &placeExbInput;

                        //Update placeExbInput  with flUserPlaceExbInput memebers
                        placeExbInput.buf  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->buf;
                        placeExbInput.bufLen  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->bufLen;
                        placeExbInput.exbFlags  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->exbFlags;
                        placeExbInput.exbWindow  = ((flUserPlaceExbInput *)(irp->AssociatedIrp.SystemBuffer))->exbWindow;
                        tffsStatus = flIOctl(&ioreq);

                        if( tffsStatus == flOK ) {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                            irp->IoStatus.Information = sizeof(flCountPartitionsOutput);
                            status = STATUS_SUCCESS;

                        }
                        else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                            irp->IoStatus.Information = 0;
                            status = STATUS_UNSUCCESSFUL;
                        }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
                }
            #endif /*WRITE_EXB_IMAGE*/

            #ifdef HW_OTP
            case IOCTL_TFFS_OTP:
                {       // User TFFS IOCTL - IOCTL_TFFS_BDTL_HW_PROTECTION

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_OTP\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(UserOtpOutput)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(UserOtpInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP Start\n"));
                        userInput = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        userOutput  = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        otpInput.type = ((UserOtpInput *)userInput)->type;
                        if(otpInput.type != OTP_SIZE){
                            otpInput.length     = ((UserOtpInput *)userInput)->length;
                            if(otpInput.type != OTP_WRITE_LOCK)
                                otpInput.usedSize = ((UserOtpInput *)userInput)->usedSize;
                        }

                        //Updating OTP i/o buffer
                        if(otpInput.type == OTP_WRITE_LOCK)
                            otpInput.buffer = ((UserOtpInput *)userInput)->buffer;
                        else
                            otpInput.buffer = ((UserOtpOutput *)userOutput)->buffer;

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_OTP;
                  ioreq.irData   = &flIoctlRec;

                        flIoctlRec.inputRecord = (VOID *)&otpInput;
                        flIoctlRec.outputRecord = (VOID *)(&(((UserOtpOutput *)userOutput)->statusRec));

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP after flioctl\n"));

                  if( tffsStatus == flOK ) {
                                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP FLOK\n"));
                        irp->IoStatus.Information = sizeof(UserOtpInput);
                        status = STATUS_SUCCESS;
                                if(otpInput.type == OTP_SIZE){
                                    ((UserOtpOutput *)userOutput)->length           = otpInput.length;
                                    ((UserOtpOutput *)userOutput)->usedSize     = otpInput.usedSize;
                                    ((UserOtpOutput *)userOutput)->lockedFlag   = otpInput.lockedFlag;
                                    ((UserOtpOutput *)userOutput)->statusRec.status = tffsStatus;
                                }

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_OTP Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }
                    userInput = NULL;
                    userOutput = NULL;
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
                #endif /* HW_OTP*/
            case IOCTL_TFFS_DEEP_POWER_DOWN_MODE:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_DEEP_POWER_DOWN_MODE\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flOutputStatusRecord)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flPowerDownInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE Start\n"));

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_DEEP_POWER_DOWN_MODE;
                  ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE after flioctl\n"));

                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE FLOK\n"));
                        irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFSFL_INQUIRE_CAPABILITIES:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_UNIQUE_ID \n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flCapabilityOutput)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flCapabilityInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES Start\n"));

                  ioreq.irHandle = deviceExtension->UnitNumber;
                  ioreq.irFlags  = FL_IOCTL_INQUIRE_CAPABILITIES;
                  ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        //tffsStatus = flOK;
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES after flioctl\n"));

                  if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES FLOK\n"));
                        irp->IoStatus.Information = sizeof(flCapabilityInput);
                        status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_INQUIRE_CAPABILITIES Failed!\n"));
                      irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFS_GET_INFO:   {       // User TFFS IOCTL - FL_GET_INFO

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInfo\n"));

          if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flDiskInfoOutput)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo start get info\n"));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_GET_INFO;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo before flioctl\n"));
                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo after flioctl\n"));

                    if( tffsStatus == flOK ) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo FLOK\n"));
                        irp->IoStatus.Information = sizeof(flDiskInfoOutput);
                        status = STATUS_SUCCESS;

                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : TffsGetInfo !FLOK!\n"));
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

            case IOCTL_TFFS_DEFRAGMENT: {       // User TFFS IOCTL - FL_DEFRAGMENT
                flDefragInput iDefrag;

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDefragment\n"));

                if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(flDefragOutput)) {

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Information = 0;
                }
                else {
                    if( irpSp->Parameters.DeviceIoControl.InputBufferLength == 0 )
                        iDefrag.requiredNoOfSectors = -1;
                    else
                        iDefrag.requiredNoOfSectors = *((LONG *)(irp->AssociatedIrp.SystemBuffer));

                    ioreq.irHandle = deviceExtension->UnitNumber;
                    ioreq.irFlags  = FL_IOCTL_DEFRAGMENT;
                    ioreq.irData   = &flIoctlRec;
                    flIoctlRec.inputRecord = (VOID *)&iDefrag;
                    flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                    tffsStatus = flIOctl(&ioreq);
                    //tffsStatus = flOK;

                    if( tffsStatus == flOK ) {
                        irp->IoStatus.Information = sizeof(flDefragOutput);
                        status = STATUS_SUCCESS;
                    }
                    else {
                        irp->IoStatus.Information = 0;
                        status = STATUS_UNSUCCESSFUL;
                    }
                }
                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }

          case IOCTL_TFFS_WRITE_PROTECT: {  // User TFFS IOCTL - FL_WRITE_PROTECT

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsWriteProtect\n"));

            if( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(flWriteProtectInput)) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_WRITE_PROTECT;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;

                //Handling Enable and disable of write portected media
                if(((flWriteProtectInput *)flIoctlRec.inputRecord)->type == FL_PROTECT){
                    deviceExtension->IsSWWriteProtected = TRUE;
                }
                else if(((flWriteProtectInput *)flIoctlRec.inputRecord)->type == FL_UNPROTECT){
                    deviceExtension->IsSWWriteProtected = FALSE;
                }
                else if(((flWriteProtectInput *)flIoctlRec.inputRecord)->type == FL_UNLOCK){
                    deviceExtension->IsSWWriteProtected = FALSE;
                }
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;
          }

        case IOCTL_TFFS_MOUNT_VOLUME:       // User TFFS IOCTL - FL_MOUNT_VOLUME

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsMountVolume\n"));

            if( (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(flMountInput)) ||
                (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(flOutputStatusRecord)) ) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_MOUNT_VOLUME;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;

          case IOCTL_TFFS_FORMAT_VOLUME:    // User TFFS IOCTL - FL_FORMAT_VOLUME

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsFormatVolume\n"));

            if( (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(flFormatInput)) ||
                (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(flOutputStatusRecord)) ) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_FORMAT_VOLUME;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;

            case IOCTL_TFFS_BDK_OPERATION:
                {       // User TFFS IOCTL - IOCTL_TFFSFL_INQUIRE_CAPABILITIES

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDK_OPERATION\n"));

          if( (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(flUserBDKOperationOutput)) ||
                            (irpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(flUserBDKOperationInput))) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
                }
                else {

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : FL_IOCTL_DEEP_POWER_DOWN_MODE Start\n"));
                        userInput = (VOID *)(irp->AssociatedIrp.SystemBuffer);
                        userOutput = (VOID *)(irp->AssociatedIrp.SystemBuffer);

                        bdkOperationInput.type = ((flUserBDKOperationInput *)userInput)->type;
                        //Copy new and old signature
                        for(i = 0; i < BDK_SIGNATURE_NAME; i++){
                            bdkOperationInput.bdkStruct.oldSign[i]  = ((flUserBDKOperationInput *)userInput)->bdkStruct.oldSign[i];
                            bdkOperationInput.bdkStruct.newSign[i]  = ((flUserBDKOperationInput *)userInput)->bdkStruct.newSign[i];
                        }


                        bdkOperationInput.bdkStruct.signOffset      = ((flUserBDKOperationInput *)userInput)->bdkStruct.signOffset;
                        bdkOperationInput.bdkStruct.startingBlock = ((flUserBDKOperationInput *)userInput)->bdkStruct.startingBlock;
                        bdkOperationInput.bdkStruct.length              = ((flUserBDKOperationInput *)userInput)->bdkStruct.length;
                        bdkOperationInput.bdkStruct.flags                   = ((flUserBDKOperationInput *)userInput)->bdkStruct.flags;


                        if(bdkOperationInput.type != BDK_READ)
                            bdkOperationInput.bdkStruct.bdkBuffer = ((flUserBDKOperationInput *)userInput)->bdkStruct.bdkBuffer;
                        else
                            bdkOperationInput.bdkStruct.bdkBuffer = ((flUserBDKOperationOutput *)userOutput)->bdkStruct.bdkBuffer;

                  ioreq.irHandle = (deviceExtension->UnitNumber & 0x0f) + (((flUserBDKOperationInput *)userOutput)->partitionNumber << 4);
                  ioreq.irFlags  = FL_IOCTL_BDK_OPERATION;
                  ioreq.irData   = &flIoctlRec;
                  flIoctlRec.inputRecord = &bdkOperationInput;
                        flIoctlRec.outputRecord = (VOID *) (&(((flUserBDKOperationOutput *)userOutput)->statusRec));

                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION before flioctl\n"));
                  tffsStatus = flIOctl(&ioreq);
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION after flioctl\n"));

                  if( tffsStatus == flOK ) {
                            if(bdkOperationInput.type == BDK_GET_INFO){
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.signOffset      = bdkOperationInput.bdkStruct.signOffset;
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.startingBlock = bdkOperationInput.bdkStruct.startingBlock;
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.length              = bdkOperationInput.bdkStruct.length;
                                ((flUserBDKOperationOutput *)userOutput)->bdkStruct.flags                   = bdkOperationInput.bdkStruct.flags;
                            }
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION FLOK\n"));
                      irp->IoStatus.Information = sizeof(flUserBDKOperationOutput);
                      status = STATUS_SUCCESS;

                  }
                  else {
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : IOCTL_TFFS_BDK_OPERATION Failed!\n"));
                      irp->IoStatus.Information = 0;
                       status = STATUS_UNSUCCESSFUL;
                   }
                }

                irp->IoStatus.Status = status;
                IoCompleteRequest( irp, IO_DISK_INCREMENT );
                continue;
            }
          case IOCTL_TFFS_DELETE_SECTORS:   // User TFFS IOCTL - FL_DELETE_SECTORS

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDeleteSectors\n"));

            if( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(flDeleteSectorsInput) ) {

              status = STATUS_INVALID_PARAMETER;
              irp->IoStatus.Information = 0;
            }
            else {
              ioreq.irHandle = deviceExtension->UnitNumber;
              ioreq.irFlags  = FL_IOCTL_DELETE_SECTORS;
              ioreq.irData   = &flIoctlRec;
              flIoctlRec.inputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);
              flIoctlRec.outputRecord = (VOID *)(irp->AssociatedIrp.SystemBuffer);

              tffsStatus = flIOctl(&ioreq);

              if( tffsStatus == flOK ) {
                irp->IoStatus.Information = sizeof(flOutputStatusRecord);
                status = STATUS_SUCCESS;
              }
              else {
                irp->IoStatus.Information = 0;
                status = STATUS_UNSUCCESSFUL;
              }
            }
            irp->IoStatus.Status = status;
            IoCompleteRequest( irp, IO_DISK_INCREMENT );
            continue;
        }

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: SrbFunction %Xh Command %Xh Unit %Xh\n",Srb->Function, Srb->Cdb[0], deviceExtension->UnitNumber));
        switch (Srb->Function) {

          case SRB_FUNCTION_EXECUTE_SCSI:

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ExecuteScsi\n"));

            // Sanity check. Only one request can be outstanding on a
            // controller.
            if (deviceExtension->CurrentSrb) {

                // Restore the srb->DataBuffer if necesary
                if (irp->MdlAddress != NULL) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Restoration of Srb->DataBuffer done\n"));
                    Srb->DataBuffer = storedSrbDataBuffer;
                }


                TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: Already have a request!\n"));
                Srb->SrbStatus = SRB_STATUS_BUSY;
                irp->IoStatus.Information = 0;
                irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                IoCompleteRequest(irp,IO_NO_INCREMENT);

                return;

            }

            // Indicate that a request is active
            deviceExtension->CurrentSrb = Srb;

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Command %x to device %d\n",
                    Srb->Cdb[0],
                    Srb->TargetId));

            switch (Srb->Cdb[0]) {
              case SCSIOP_INQUIRY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Inquiry\n"));

                if (Srb->Lun != 0 || Srb->TargetId != 0) {

                    status = SRB_STATUS_SELECTION_TIMEOUT;
                    break;

                } else {

                    PINQUIRYDATA    inquiryData  = Srb->DataBuffer;

                    if (transferForbidden) {
                        status = SRB_STATUS_ERROR;
                        break;
                    }
                    // Zero INQUIRY data structure.
                    for (i = 0; i < Srb->DataTransferLength; i++) {
                        ((PUCHAR)Srb->DataBuffer)[i] = 0;
                    }

                    inquiryData->DeviceType = deviceExtension->ScsiDeviceType;

                    if (deviceExtension->removableMedia) {
                        inquiryData->RemovableMedia = 1;
                    }

                    for (i = 0; i < 8; i++)
                        inquiryData->VendorId[i] = vendorString[i];

                    for (i = 0; i < 16; i++)
                        inquiryData->ProductId[i] = productString[i];

                    for (i = 0; i < 4; i++)
                        inquiryData->ProductRevisionLevel[i] = revisionString[i];

                    status = SRB_STATUS_SUCCESS;
                }

                break;

              case SCSIOP_MODE_SENSE:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ModeSense\n"));

                                cdb = (PCDB) Srb->Cdb;

                if ((cdb->MODE_SENSE.PageCode           != MODE_SENSE_RETURN_ALL) ||
                    (cdb->MODE_SENSE.AllocationLength   != MODE_DATA_SIZE )) {

                    status = SRB_STATUS_INVALID_REQUEST;
                    break;
                }

                if (transferForbidden) {
                    status = SRB_STATUS_ERROR;
                    break;
                }

                // Set mode page data(only a geometry) for DISK class driver.
                // DISK class driver get the geometry of all media(scsi ata) by mode sense.
                pageData = Srb->DataBuffer;

                ((PMODE_PARAMETER_HEADER) pageData)->ModeDataLength = MODE_DATA_SIZE;
                parameterHeaderLength = sizeof(MODE_PARAMETER_HEADER);
                blockDescriptorLength = ((PMODE_PARAMETER_HEADER) pageData)->BlockDescriptorLength = 0x8;

                pageData += parameterHeaderLength + blockDescriptorLength;

                // MODE_PAGE_ERROR_RECOVERY data.
                ((PMODE_DISCONNECT_PAGE) pageData)->PageCode    = MODE_PAGE_ERROR_RECOVERY;
                ((PMODE_DISCONNECT_PAGE) pageData)->PageLength  = 0x6;

                // Advance to the next page.
                pageData += ((PMODE_DISCONNECT_PAGE) pageData)->PageLength + 2;

                // MODE_PAGE_FORMAT_DEVICE data set.
                ((PMODE_DISCONNECT_PAGE) pageData)->PageCode    = MODE_PAGE_FORMAT_DEVICE;
                ((PMODE_DISCONNECT_PAGE) pageData)->PageLength  = 0x16;

                // SectorsPerTrack
                ((PFOUR_BYTE)&((PMODE_FORMAT_PAGE) pageData)->SectorsPerTrack[0])->Byte1
                    = ((PFOUR_BYTE)&deviceExtension->SectorsPerTrack)->Byte0;

                ((PFOUR_BYTE)&((PMODE_FORMAT_PAGE) pageData)->SectorsPerTrack[0])->Byte0
                    = ((PFOUR_BYTE)&deviceExtension->SectorsPerTrack)->Byte1;

                // Advance to the next page.
                pageData += ((PMODE_DISCONNECT_PAGE) pageData)->PageLength + 2;

                // MODE_PAGE_RIGID_GEOMETRY data set.
                ((PMODE_DISCONNECT_PAGE) pageData)->PageCode = MODE_PAGE_RIGID_GEOMETRY;
                ((PMODE_DISCONNECT_PAGE) pageData)->PageLength  = 0x12;

                // NumberOfHeads
                ((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfHeads
                    = (UCHAR)deviceExtension->NumberOfHeads;

                // NumberOfCylindersfahjbbjknz
                ((PFOUR_BYTE)&((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfCylinders)->Byte2
                    = ((PFOUR_BYTE)&deviceExtension->Cylinders)->Byte0;
                ((PFOUR_BYTE)&((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfCylinders)->Byte1
                    = ((PFOUR_BYTE)&deviceExtension->Cylinders)->Byte1;
                ((PFOUR_BYTE)&((PMODE_RIGID_GEOMETRY_PAGE) pageData)->NumberOfCylinders)->Byte0
                    = ((PFOUR_BYTE)&deviceExtension->Cylinders)->Byte2;
                Srb->DataTransferLength = MODE_DATA_SIZE;
                status = SRB_STATUS_SUCCESS;

                break;

              case SCSIOP_TEST_UNIT_READY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: TestUnitReady\n"));
                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_READ_CAPACITY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ReadCapacity\n"));

                if (transferForbidden) {
                    status = SRB_STATUS_ERROR;
                    break;
                }

                // Claim 512 byte blocks (big-endian).
                ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->BytesPerBlock = 0x20000;

                // Calculate last sector.
                i = deviceExtension->totalSectors - 1;

                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte0 =
                    ((PFOUR_BYTE)&i)->Byte3;
                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte1 =
                    ((PFOUR_BYTE)&i)->Byte2;
                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte2 =
                    ((PFOUR_BYTE)&i)->Byte1;
                ((PFOUR_BYTE)& ((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress)->Byte3 =
                    ((PFOUR_BYTE)&i)->Byte0;

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: DiskOnChip %x - #sectors %x, #heads %x, #cylinders %x #total %x\n",
                    Srb->TargetId,
                    deviceExtension->SectorsPerTrack,
                    deviceExtension->NumberOfHeads,
                    deviceExtension->Cylinders,
                    i));

                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_VERIFY:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Verify\n"));
                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_READ:
              case SCSIOP_WRITE:

                deviceExtension->DataBuffer = (PUSHORT)Srb->DataBuffer;
                startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                            ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                            ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                            ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ReadWrite: Starting sector is %x, Number of bytes %x\n",startingSector,Srb->DataTransferLength));

                if (transferForbidden) {
                    status = SRB_STATUS_ERROR;
                    break;
                }

                ioreq.irHandle = deviceExtension->UnitNumber;
                ioreq.irSectorNo = startingSector;
                ioreq.irSectorCount = Srb->DataTransferLength >> SECTOR_SIZE_BITS;
                ioreq.irData = deviceExtension->DataBuffer;

                                if (startingSector >= deviceExtension->totalSectors) {
                                    tffsStatus = flSectorNotFound;
                                }
                else {
                    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Read\n"));

                        if(deviceExtension->IsWriteProtected && deviceExtension->IsPartitonTableWritten && (ioreq.irSectorNo == 0)){
                            tffscpy(deviceExtension->DataBuffer, deviceExtension->PartitonTable, sizeof(deviceExtension->PartitonTable));
                            tffsStatus = flOK;
                            status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;

                        }
                        else{
                            tffsStatus = flAbsRead(&ioreq);
                            if (irp->MdlAddress) {
                                KeFlushIoBuffers(irp->MdlAddress, TRUE, FALSE);
                            }
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Read status %Xh\n", tffsStatus));
                            status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;
                        }
                    }
                    else {
                        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Write\n"));
                        //Handle partiton table - simulate write to sector 0 (Volume Manager signature - write it to buffer in RAM) only once.
                        if((deviceExtension->IsWriteProtected || deviceExtension->IsSWWriteProtected) && (ioreq.irSectorNo == 0) && (deviceExtension->IsPartitonTableWritten == FALSE)){
                            tffscpy(deviceExtension->PartitonTable, deviceExtension->DataBuffer, sizeof(deviceExtension->PartitonTable));
                            deviceExtension->IsPartitonTableWritten = TRUE;
                            status = tffsStatus = STATUS_MEDIA_WRITE_PROTECTED;
                            //tffsStatus = flOK;
                            //status = SRB_STATUS_SUCCESS;
                        }//In case of writing to Write Protected Device
                        else if(deviceExtension->IsWriteProtected || deviceExtension->IsSWWriteProtected){
                            status = tffsStatus = STATUS_MEDIA_WRITE_PROTECTED;
                        }
                        else{
                            tffsStatus = flAbsWrite(&ioreq);
                            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Write status %Xh\n", tffsStatus));
                            //For the first time trying to write to SW protected media
                            if(tffsStatus==flWriteProtect){
                                deviceExtension->IsSWWriteProtected = TRUE;
                                if((ioreq.irSectorNo == 0) && (deviceExtension->IsPartitonTableWritten == FALSE)){
                                    tffscpy(deviceExtension->PartitonTable, deviceExtension->DataBuffer, sizeof(deviceExtension->PartitonTable));
                                    deviceExtension->IsPartitonTableWritten = TRUE;
                                }
                                status = tffsStatus = STATUS_MEDIA_WRITE_PROTECTED;
                            }
                            else
                                {
                                //status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;
                                if(tffsStatus==flOK)
                                    status = SRB_STATUS_SUCCESS;
                                else
                                    status = SRB_STATUS_ERROR;
                                }
                        }
                    }
                }
                //TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: ReadWrite status %Xh\n", tffsStatus));
                //status = (UCHAR)(tffsStatus == flOK) ? SRB_STATUS_SUCCESS : SRB_STATUS_ERROR;
                break;

              case SCSIOP_START_STOP_UNIT:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: StartStopUnit\n"));
                status = SRB_STATUS_SUCCESS;
                break;

              case SCSIOP_REQUEST_SENSE:

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: RequestSense\n"));
                // this function makes sense buffers to report the results
                // of the original GET_MEDIA_STATUS command
                // status = SRB_STATUS_SUCCESS;
                break;

              default:

                TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: StartIo: Unsupported command %Xh\n",Srb->Cdb[0]));

                status = SRB_STATUS_INVALID_REQUEST;

            } // end switch

            break;

          case SRB_FUNCTION_ABORT_COMMAND:

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: AbortCommand\n"));

            // Verify that SRB to abort is still outstanding.
            if (!deviceExtension->CurrentSrb) {

                TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartIo: SRB to abort already completed\n"));
                status = SRB_STATUS_ABORT_FAILED;
                break;
            }

          case SRB_FUNCTION_RESET_BUS:

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Reset bus request received\n"));
            status = SRB_STATUS_SUCCESS;
            break;

          default:

            // Indicate unsupported command.
            TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: StartIo: unsupported function\n"));
            status = SRB_STATUS_INVALID_REQUEST;
            break;

        } // end switch

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartIo: Srb %Xh complete with status %Xh\n", Srb, status));

        // Clear current SRB.
        deviceExtension->CurrentSrb = NULL;

        Srb->SrbStatus = (UCHAR)status;

        if (status == SRB_STATUS_SUCCESS) {
            irp->IoStatus.Information = Srb->DataTransferLength;
        }
        else {
            irp->IoStatus.Information = 0;
        }

        // Restore the srb->DataBuffer if necesary
        if (irp->MdlAddress != NULL) {
            TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: Restoration of Srb->DataBuffer done\n"));
            Srb->DataBuffer = storedSrbDataBuffer;
        }

        irp->IoStatus.Status =  TrueffsTranslateSRBStatus(status);
        IoCompleteRequest( irp, IO_DISK_INCREMENT );

    } // while there's packets to process

    } while ( TRUE );
}

NTSTATUS
QueueIrpToThread(
    IN OUT PIRP              Irp,
    IN OUT PDEVICE_EXTENSION deviceExtension
    )

/*++

Routine Description:

    This routine queues the given irp to be serviced by the Trueffs
    thread.  If the thread is down then this routine creates the thread.

Arguments:

    Irp         - Supplies the IRP to queue to the thread.

Return Value:

    May return an error if PsCreateSystemThread fails.
    Otherwise returns STATUS_PENDING and marks the IRP pending.

--*/

{
    NTSTATUS    status;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: QueueIrpToThread\n"));

    IoMarkIrpPending(Irp);

    ExInterlockedInsertTailList(&deviceExtension->listEntry,&Irp->Tail.Overlay.ListEntry,&deviceExtension->listSpinLock);

    if (!KeReadStateSemaphore(&deviceExtension->requestSemaphore)) {
        KeReleaseSemaphore(&deviceExtension->requestSemaphore,(KPRIORITY) 0,1,FALSE);
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: QueueIrpToThread: Irp %Xh queued\n", Irp));
    return STATUS_PENDING;
}

NTSTATUS
TrueffsTranslateSRBStatus(
    ULONG    status
    )
/*++

Routine Description:

    This routine translates an srb status into an ntstatus.

Arguments:

    SRB status

Return Value:

    An nt status approprate for the error.

--*/

{
    switch (status) {
      case SRB_STATUS_INTERNAL_ERROR:
           return(STATUS_MEDIA_WRITE_PROTECTED); //(STATUS_WMI_READ_ONLY);
      case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
      case SRB_STATUS_SUCCESS:
        return (STATUS_SUCCESS);
      case SRB_STATUS_INVALID_REQUEST:
        return(STATUS_INVALID_DEVICE_REQUEST);
      case SRB_STATUS_ABORT_FAILED:
      default:
        return(STATUS_DISK_OPERATION_FAILED);
    }
    return(STATUS_DISK_OPERATION_FAILED);
}


NTSTATUS
TrueffsDeviceQueryId(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension;
    PWSTR idString   = NULL;
    BOOLEAN bHandled = TRUE;
    NTSTATUS status;

    if (Fdo)
    {
        deviceExtension = DeviceObject->DeviceExtension;
    }
    else
    {
        PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    switch (thisIrpSp->Parameters.QueryId.IdType)
    {
        case BusQueryDeviceID:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryDeviceID\n"));

            idString = DeviceBuildBusId(deviceExtension, Fdo);
            break;

        case BusQueryInstanceID:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryInstanceID\n"));

            idString = DeviceBuildInstanceId(deviceExtension, Fdo);
            break;

        case BusQueryCompatibleIDs:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryCompatibleIDs\n"));

            idString = DeviceBuildCompatibleId(deviceExtension, Fdo);
            break;

        case BusQueryHardwareIDs:

            TffsDebugPrint ((TFFS_DEB_INFO, "Trueffs: QueryHardwareIDs\n"));

            idString = DeviceBuildHardwareId(deviceExtension, Fdo);
            break;

        default:

            //
            // The PDO should complete this request without altering its status
            //
            status = Irp->IoStatus.Status;

            bHandled = FALSE;
            break;
    }

    if (bHandled)
    {
        if (idString == NULL)
        {
            status   = STATUS_INSUFFICIENT_RESOURCES;
            bHandled = FALSE;
        }
    }

    if (bHandled)
    {
        if (Fdo)
        {
            //
            // Forward this request down synchronously, in case a lower driver wants to handle it
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);

            if (status == STATUS_NOT_SUPPORTED)
            {
                Irp->IoStatus.Information = (UINT_PTR) idString;
                status = STATUS_SUCCESS;
            }
            else
            {
                //
                // Someone lower down took care of this request
                //
                ExFreePool(idString);
            }
        }
        else
        {
            Irp->IoStatus.Information = (UINT_PTR) idString;
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        if (Fdo)
        {
            //
            // Forward this request down synchronously, in case a lower driver understands it
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            status = TrueffsCallDriverSync(deviceExtension->LowerDeviceObject, Irp);
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


PWSTR
DeviceBuildBusId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
    PUCHAR      idString;
    PCSTR       compatibleIdString;
    CCHAR       compatibleId[10];
    ULONG       compatibleIdLen;
    USHORT      idStringBufLen;
    NTSTATUS    status;
    UCHAR       tffsBusIdFormat[] = "FlashMedia\\%s_%s_%s%s_%s";
    PWCHAR      typeString;
    ANSI_STRING     ansiBusIdString;
    UNICODE_STRING  unicodeIdString;

    if (Fdo) {
        compatibleIdString = TrueffsGetCompatibleIdStringFDO (
                             deviceExtension->ScsiDeviceType
                             );
    }
        else {
        compatibleIdString = TrueffsGetCompatibleIdString (
                             deviceExtension->ScsiDeviceType
                             );
        }

    if (compatibleIdString == NULL) {
        sprintf (compatibleId,
                 "Type%d",
                 deviceExtension->ScsiDeviceType);
        compatibleIdString = compatibleId;
    }
    compatibleIdLen = strlen(compatibleIdString);

    idStringBufLen = (USHORT) (( strlen( tffsBusIdFormat ) +
                       compatibleIdLen +
                       VENDORSTRINGSIZE +
                       PRODUCTSTRINGSIZE +
                       REVISIONSTRINGSIZE +
                       SERIALSTRINGSIZE    +
                        1) * sizeof( WCHAR ));

    idString = ExAllocatePoolWithTag( PagedPool, idStringBufLen * 2, TFFSPORT_POOL_TAG);

    if (idString){

        sprintf (idString + idStringBufLen,
                 tffsBusIdFormat,
                 compatibleIdString,
                 VENDORSTRING,
                 PRODUCTSTRING,
                 REVISIONSTRING,
                 SERIALSTRING
                 );

        RtlInitAnsiString (
            &ansiBusIdString,
            idString + idStringBufLen
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = idStringBufLen;
        unicodeIdString.Buffer        = (PWSTR) idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiBusIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/2 + 0] = L'\0';
    }

    return (PWSTR) idString;
}

PWSTR
DeviceBuildInstanceId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
    PWSTR       idString;
    ULONG       idStringBufLen;
    NTSTATUS    status;
    WCHAR       tffsUniqueIdFormat[] = L"%x.%x.%x";
    UCHAR       firstId = 'A';
    UCHAR       secondId = 'G';

    idStringBufLen = 50 * sizeof( WCHAR );
    idString = ExAllocatePoolWithTag (PagedPool, idStringBufLen, TFFSPORT_POOL_TAG);
    if( idString == NULL ){

        return NULL;
    }

    // Form the string and return it.
    swprintf( idString,
              tffsUniqueIdFormat,
              firstId,
              secondId,
              deviceExtension->TrueffsDeviceNumber);

    return idString;
}


PWSTR
DeviceBuildCompatibleId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
    NTSTATUS        status;

    ULONG           idStringBufLen;
    PCSTR           compatibleIdString;

    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    if (Fdo) {
        compatibleIdString = TrueffsGetCompatibleIdStringFDO (deviceExtension->ScsiDeviceType);
    }
    else {
        compatibleIdString = TrueffsGetCompatibleIdString (deviceExtension->ScsiDeviceType);
    }


    RtlInitAnsiString (
        &ansiCompatibleIdString,
        compatibleIdString
        );

    idStringBufLen = RtlAnsiStringToUnicodeSize (
                         &ansiCompatibleIdString
                         );

    unicodeIdString.Length = 0;
    unicodeIdString.MaximumLength = (USHORT) idStringBufLen;

    idStringBufLen += 2 * sizeof (WCHAR);

    unicodeIdString.Buffer = ExAllocatePoolWithTag (PagedPool, idStringBufLen, TFFSPORT_POOL_TAG);

    if (unicodeIdString.Buffer) {

            RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/2 + 0] = L'\0';
        unicodeIdString.Buffer[unicodeIdString.Length/2 + 1] = L'\0';
    }

    return unicodeIdString.Buffer;
}

PWSTR
DeviceBuildHardwareId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    )
{
#define NUMBER_HARDWARE_STRINGS 5

    ULONG           i;
    PWSTR           idMultiString;
    PWSTR           idString;
    UCHAR           scratch[64] = { 0 };
    ULONG           idStringLen;
    NTSTATUS        status;
    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    PCSTR           deviceTypeCompIdString;
    UCHAR           deviceTypeCompId[20];
    PCSTR           deviceTypeIdString;
    UCHAR           deviceTypeId[20];

    UCHAR           ScsiDeviceType;

    ScsiDeviceType = deviceExtension->ScsiDeviceType;

    idStringLen = (64 * NUMBER_HARDWARE_STRINGS + sizeof (UCHAR)) * sizeof (WCHAR);
    idMultiString = ExAllocatePoolWithTag (PagedPool, idStringLen, TFFSPORT_POOL_TAG);
    if (idMultiString == NULL) {

        return NULL;
    }

    if (Fdo) {
        deviceTypeIdString = TrueffsGetDeviceTypeStringFDO(ScsiDeviceType);
    }
    else {
        deviceTypeIdString = TrueffsGetDeviceTypeString(ScsiDeviceType);
    }

    if (deviceTypeIdString == NULL) {

        sprintf (deviceTypeId,
                 "Type%d",
                 ScsiDeviceType);

        deviceTypeIdString = deviceTypeId;
    }

    if (Fdo)
        deviceTypeCompIdString = TrueffsGetCompatibleIdStringFDO (ScsiDeviceType);
    else
        deviceTypeCompIdString = TrueffsGetCompatibleIdString (ScsiDeviceType);

    if (deviceTypeCompIdString == NULL) {

        sprintf (deviceTypeCompId,
                 "GenType%d",
                 ScsiDeviceType);

        deviceTypeCompIdString = deviceTypeCompId;
    }

    // Zero out the string buffer
    RtlZeroMemory(idMultiString, idStringLen);
    idString = idMultiString;

    for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

        // Build each of the hardware id's
        switch(i) {

            // Bus + Dev Type + Vendor + Product + Revision
            case 0: {

                sprintf(scratch, "FlashMedia\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          PRODUCTSTRING,
                          PRODUCTSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          REVISIONSTRING,
                          REVISIONSTRINGSIZE,
                          '_');
                break;
            }

            // bus + vendor + product + revision[0]
            case 1: {

                sprintf(scratch, "FlashMedia\\");

                CopyField(scratch + strlen(scratch),
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          PRODUCTSTRING,
                          PRODUCTSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          REVISIONSTRING,
                          REVISIONSTRINGSIZE,
                          '_');
                break;
            }

            // bus + device + vendor + product
            case 2: {

                sprintf(scratch, "FlashMedia\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                break;
            }

            // vendor + product + revision[0] (win9x)
            case 3: {

                CopyField(scratch,
                          VENDORSTRING,
                          VENDORSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          PRODUCTSTRING,
                          PRODUCTSTRINGSIZE,
                          '_');
                CopyField(scratch + strlen(scratch),
                          REVISIONSTRING,
                          REVISIONSTRINGSIZE,
                          '_');
                break;
            }

            case 4: {

                strncpy(scratch, deviceTypeCompIdString, sizeof(scratch) - 1);
                break;
            }

            default: {

                break;
            }
        }

        RtlInitAnsiString (
            &ansiCompatibleIdString,
            scratch
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(
                                                     &ansiCompatibleIdString
                                                     );
        unicodeIdString.Buffer        = idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        idString[unicodeIdString.Length / 2] = L'\0';
        idString += unicodeIdString.Length / 2+ 1;
    }
    idString[0] = L'\0';

    return idMultiString;

#undef NUMBER_HARDWARE_STRINGS
}


VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    )

/*++

Routine Description:

    This routine will copy Count string bytes from Source to Destination.  If
    it finds a nul byte in the Source it will translate that and any subsequent
    bytes into Change.  It will also replace spaces with the specified character.

Arguments:

    Destination - the location to copy bytes

    Source - the location to copy bytes from

    Count - the number of bytes to be copied

Return Value:

    none

--*/

{
    ULONG i = 0;
    BOOLEAN pastEnd = FALSE;

    for(i = 0; i < Count; i++) {
        if(!pastEnd) {
            if(Source[i] == 0) {
                pastEnd = TRUE;
                Destination[i] = Change;
            } else if(Source[i] == L' ') {
                Destination[i] = Change;
            } else {
                Destination[i] = Source[i];
            }
        } else {
            Destination[i] = Change;
        }
    }
    Destination[i] = L'\0';
    return;
}


PCSTR
TrueffsGetDeviceTypeString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up SCSI device type string

Arguments:

    DeviceType - SCSI device type

Return Value:

    device type string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceType_tffsport[DeviceType].DeviceTypeString;
    } else {
        return NULL;
    }
}

PCSTR
TrueffsGetDeviceTypeStringFDO (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up SCSI device type string

Arguments:

    DeviceType - SCSI device type

Return Value:

    device type string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceTypeFDO_tffsport[DeviceType].DeviceTypeString;
    } else {
        return NULL;
    }
}


PCSTR
TrueffsGetCompatibleIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up compatible ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    compatible ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceType_tffsport[DeviceType].CompatibleIdString;
    } else {
        return NULL;
    }
}

PCSTR
TrueffsGetCompatibleIdStringFDO (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up compatible ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    compatible ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceTypeFDO_tffsport[DeviceType].CompatibleIdString;
    } else {
        return NULL;
    }
}


PCSTR
TrueffsGetPeripheralIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up peripheral ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    Peripheral ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceType_tffsport[DeviceType].PeripheralIdString;
    } else {
        return NULL;
    }
}

PCSTR
TrueffsGetPeripheralIdStringFDO (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up peripheral ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    Peripheral ID string

--*/
{
    if (DeviceType < (sizeof (TffsDeviceType_tffsport) / sizeof (TFFS_DEVICE_TYPE))) {
        return TffsDeviceTypeFDO_tffsport[DeviceType].PeripheralIdString;
    } else {
        return NULL;
    }
}


NTSTATUS
TrueffsQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_RELATIONS deviceRelations;
    NTSTATUS  status = STATUS_SUCCESS;

    if (Fdo)
    {
        PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

        switch (thisIrpSp->Parameters.QueryDeviceRelations.Type)
        {
            case BusRelations:

                TffsDebugPrint ((TFFS_DEB_INFO,"Trueffs: QueryDeviceRelations: bus relations\n"));

                if (deviceExtension->ChildPdo != NULL)
                {
                    deviceRelations = ExAllocatePoolWithTag(NonPagedPool, sizeof(DEVICE_RELATIONS), TFFSPORT_POOL_TAG);

                    if (deviceRelations)
                    {
                        ObReferenceObject(deviceExtension->ChildPdo);

                        deviceRelations->Objects[0] = deviceExtension->ChildPdo;
                        deviceRelations->Count      = 1;

                        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                    }
                    else
                    {
                        TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: QueryDeviceRelations: Unable to allocate DeviceRelations structures\n"));

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        Irp->IoStatus.Information = (ULONG_PTR) NULL;
                    }
                }

                Irp->IoStatus.Status = status;

                if (NT_SUCCESS(status))
                {
                    //
                    // Send the request down in case a lower driver wants to append to the device relations
                    //
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
                }
                else
                {
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);
                }
                break;

            default:

                //
                // Forward this request down, in case a lower driver understands it
                //
                IoSkipCurrentIrpStackLocation(Irp);
                status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);
                break;
        }
    }
    else
    {
        switch (thisIrpSp->Parameters.QueryDeviceRelations.Type)
        {
            case TargetDeviceRelation:

                TffsDebugPrint ((TFFS_DEB_INFO,"Trueffs: QueryDeviceRelations: target relations\n"));

                deviceRelations = ExAllocatePoolWithTag(NonPagedPool, sizeof(DEVICE_RELATIONS), TFFSPORT_POOL_TAG);

                if (deviceRelations)
                {
                    ObReferenceObject(DeviceObject);

                    deviceRelations->Objects[0] = DeviceObject;
                    deviceRelations->Count      = 1;

                    Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                }
                else
                {
                    TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: QueryDeviceRelations: Unable to allocate DeviceRelations structures\n"));

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Information = (ULONG_PTR) NULL;
                }

                Irp->IoStatus.Status = status;
                break;

            default:

                //
                // Complete this request without altering its status
                //
                status = Irp->IoStatus.Status;
                break;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


BOOLEAN
TrueffsOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
    )
{
    NTSTATUS status;
    ULONG legacyDetection;

    status = TrueffsGetParameterFromServiceSubKey (
                 DriverObject,
                 LEGACY_DETECTION,
                 REG_DWORD,
                 TRUE,
                 (PVOID) &legacyDetection,
                 0
                 );

    if (!NT_SUCCESS(status) || legacyDetection) {
        return TRUE;
    }
    else {
        return FALSE;
    }

}

NTSTATUS
TrueffsGetParameterFromServiceSubKey (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PWSTR           ParameterName,
    IN  ULONG           ParameterType,
    IN  BOOLEAN         Read,
    OUT PVOID           *ParameterValue,
    IN  ULONG           ParameterValueWriteSize
    )
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2] = { 0 };
    ULONG                    defaultParameterValue;

    CCHAR                   deviceBuffer[50];
    ANSI_STRING             ansiString;
    UNICODE_STRING          subKeyPath;
    HANDLE                  subServiceKey;

    UNICODE_STRING          unicodeParameterName;

    RtlZeroMemory(ParameterValue, ParameterValueWriteSize);

    sprintf (deviceBuffer, DRIVER_PARAMETER_SUBKEY);
    RtlInitAnsiString(&ansiString, deviceBuffer);
    status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

    if (NT_SUCCESS(status)) {

        subServiceKey = TrueffsOpenServiceSubKey (
                            DriverObject,
                            &subKeyPath
                            );

        RtlFreeUnicodeString (&subKeyPath);

        if (subServiceKey) {

            if (Read) {

                queryTable->QueryRoutine  = TrueffsRegQueryRoutine;
                queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
                queryTable->Name          = ParameterName;
                queryTable->EntryContext  = ParameterValue;
                queryTable->DefaultType   = 0;
                queryTable->DefaultData   = NULL;
                queryTable->DefaultLength = 0;
                status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                (PWSTR) subServiceKey,
                                                queryTable,
                                                ULongToPtr( ParameterType ),
                                                NULL);

            } else {

                RtlInitUnicodeString (&unicodeParameterName, ParameterName);
                status = ZwSetValueKey(
                             subServiceKey,
                             &unicodeParameterName,
                             0,
                             ParameterType,
                             ParameterValue,
                             ParameterValueWriteSize
                             );
            }

            // close what we open
            TrueffsCloseServiceSubKey (
                subServiceKey
                );
        }
    }
    return status;
}


NTSTATUS
TrueffsRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PVOID *parameterValue = EntryContext;
    ULONG parameterType = PtrToUlong(Context);

    if (ValueType == parameterType) {

        if (ValueType == REG_MULTI_SZ) {

            *parameterValue = ExAllocatePoolWithTag(PagedPool, ValueLength, TFFSPORT_POOL_TAG);
            if (*parameterValue) {

                RtlMoveMemory(*parameterValue, ValueData, ValueLength);
                return STATUS_SUCCESS;
            }

        } else if (ValueType == REG_DWORD) {

            PULONG ulongValue;

            ulongValue = (PULONG) parameterValue;
            *ulongValue = *((PULONG) ValueData);
            return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}


HANDLE
TrueffsOpenServiceSubKey (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING SubKeyPath
    )
{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey;
    HANDLE subServiceKey;
    NTSTATUS status;
    ULONG disposition;

    trueffsDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );
    if (!trueffsDriverExtension) {

        return NULL;
    }
    InitializeObjectAttributes(&objectAttributes,
                               &trueffsDriverExtension->RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_ALL_ACCESS,
                       &objectAttributes);
    if (!NT_SUCCESS(status)) {

        return NULL;
    }
    InitializeObjectAttributes(&objectAttributes,
                               SubKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey(&subServiceKey,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes,
                        0,
                        (PUNICODE_STRING) NULL,
                        REG_OPTION_NON_VOLATILE,
                        &disposition);

    ZwClose(serviceKey);
    if (NT_SUCCESS(status)) {

        return subServiceKey;
    } else {

        return NULL;
    }
}


VOID
TrueffsCloseServiceSubKey (
    IN HANDLE SubServiceKey
    )
{
    ZwClose(SubServiceKey);
}


PPDO_EXTENSION
AllocatePdo(
    IN PDEVICE_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Create physical device object

Arguments:

    DeviceExtension

Return Value:

    Physical device object


--*/
{
    PDEVICE_OBJECT physicalDeviceObject = NULL;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS       status;
    STRING         deviceName;
    CCHAR          deviceNameBuffer[64];
    UNICODE_STRING unicodeDeviceNameString;

    sprintf(deviceNameBuffer, "\\Device\\TrueffsDevice%d",
            FdoExtension->TrueffsDeviceNumber
            );
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceNameString,
                                          &deviceName,
                                          TRUE);
    if (!NT_SUCCESS (status)) {

        return NULL;
    }

    status = IoCreateDevice(
                FdoExtension->DriverObject, // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                &unicodeDeviceNameString,   // our name
                FILE_DEVICE_DISK,           // device type
                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                FALSE,                      // not exclusive
                &physicalDeviceObject       // store new device object here
                );

    if (NT_SUCCESS(status)) {

        pdoExtension = physicalDeviceObject->DeviceExtension;
        RtlZeroMemory (pdoExtension, sizeof(PDO_EXTENSION));
        pdoExtension->DeviceObject = physicalDeviceObject;
        pdoExtension->DriverObject = FdoExtension->DriverObject;
        pdoExtension->Pext = FdoExtension;
        pdoExtension->SystemPowerState = PowerSystemWorking;
        pdoExtension->DevicePowerState = PowerDeviceD0;

    }
    RtlFreeUnicodeString (&unicodeDeviceNameString);

    if (physicalDeviceObject == NULL) {

        return NULL;
    }
    FdoExtension->ChildPdo = physicalDeviceObject;
    physicalDeviceObject->Flags |= DO_DIRECT_IO;
    physicalDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
    physicalDeviceObject->Flags &=~DO_DEVICE_INITIALIZING;

    return pdoExtension;
}

NTSTATUS
TrueffsDeviceQueryCapabilities(IN PDEVICE_EXTENSION    deviceExtension,
                               IN PDEVICE_CAPABILITIES Capabilities
                              )
{

  Capabilities->UniqueID          = FALSE;
  Capabilities->LockSupported     = FALSE;
  Capabilities->EjectSupported    = FALSE;
  Capabilities->DockDevice        = FALSE;
  Capabilities->SilentInstall     = FALSE;
  Capabilities->RawDeviceOK       = FALSE;

  Capabilities->Removable = deviceExtension->removableMedia;
  Capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
  Capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
  Capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
  Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;

  Capabilities->SystemWake = PowerSystemUnspecified;
  Capabilities->DeviceWake = PowerDeviceUnspecified;
  Capabilities->D1Latency = 0;
  Capabilities->D2Latency = 0;
  Capabilities->D3Latency = 10; // 1ms

  return STATUS_SUCCESS;
}

typedef enum {
    FlashDiskInfo = 0
} WMI_DATA_BLOCK_TYPE;

#define MOFRESOURCENAME L"MofResourceName"

#define NUMBER_OF_WMI_GUID 1
WMIGUIDREGINFO TrueffsWmiGuidList[NUMBER_OF_WMI_GUID];


VOID
TrueffsWmiInit (VOID)
{
    TrueffsWmiGuidList[FlashDiskInfo].Guid  = &WmiTffsportAddressGuid;
    TrueffsWmiGuidList[FlashDiskInfo].InstanceCount = 1;
    TrueffsWmiGuidList[FlashDiskInfo].Flags = 0;
    return;
}


NTSTATUS
TrueffsWmiRegister(
    PDEVICE_EXTENSION_HEADER DevExtension
    )
{
    NTSTATUS status;

    DevExtension->WmiLibInfo.GuidCount = NUMBER_OF_WMI_GUID;
    DevExtension->WmiLibInfo.GuidList  = TrueffsWmiGuidList;

    DevExtension->WmiLibInfo.QueryWmiDataBlock  = TrueffsQueryWmiDataBlock;
    DevExtension->WmiLibInfo.QueryWmiRegInfo    = TrueffsQueryWmiRegInfo;
    DevExtension->WmiLibInfo.SetWmiDataBlock    = TrueffsSetWmiDataBlock;
    DevExtension->WmiLibInfo.SetWmiDataItem     = TrueffsSetWmiDataItem;
    DevExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DevExtension->WmiLibInfo.WmiFunctionControl = NULL;

    status = IoWMIRegistrationControl(DevExtension->DeviceObject,WMIREG_ACTION_REGISTER);

    if (!NT_SUCCESS(status)) {
        TffsDebugPrint((TFFS_DEB_ERROR,
            "TrueffsWmiRegister: IoWMIRegistrationControl(%x, WMI_ACTION_REGISTER) failed\n",
            DevExtension->DeviceObject));
    }
    return status;
}


NTSTATUS
TrueffsWmiDeregister(
    PDEVICE_EXTENSION_HEADER DevExtension
    )
{
    NTSTATUS status;

    status = IoWMIRegistrationControl(DevExtension->DeviceObject,WMIREG_ACTION_DEREGISTER);

    if (!NT_SUCCESS(status)) {
        TffsDebugPrint((TFFS_DEB_ERROR,
            "TrueffsWmiRegister: IoWMIRegistrationControl(%x, WMIREG_ACTION_DEREGISTER) failed\n",
            DevExtension->DeviceObject));
    }
    return status;
}


NTSTATUS
TrueffsWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PPDO_EXTENSION pdoExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;
    if (pdoExtension) {

        status = WmiSystemControl(&pdoExtension->WmiLibInfo,
                                  DeviceObject,
                                  Irp,
                                  &disposition);
        switch(disposition)
        {
            case IrpProcessed:
            {
                // This irp has been processed and may be completed or pending.
                break;
            }

            case IrpNotCompleted:
            {
                // This irp has not been completed, but has been fully
                // processed. We will complete it now
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
            }

            case IrpForward:
            case IrpNotWmi:
            default:
            {
                Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
                break;
            }
        }

    } else {

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return status;
}


NTSTATUS
TrueffsQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    ULONG numBytesReturned = sizeof(WMI_FLASH_DISK_INFO);

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    switch (GuidIndex) {
    case FlashDiskInfo: {

        PWMI_FLASH_DISK_INFO flashDiskInfo;

        if (OutBufferSize < sizeof(WMI_FLASH_DISK_INFO)) {
            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            flashDiskInfo = (PWMI_FLASH_DISK_INFO) Buffer;

            flashDiskInfo->Number = pdoExtension->Pext->TrueffsDeviceNumber;
            flashDiskInfo->Address = (ULONG) pdoExtension->Pext->pcmciaParams.physWindow;
            flashDiskInfo->Size = pdoExtension->Pext->pcmciaParams.windowSize;

            *InstanceLengthArray = sizeof(WMI_FLASH_DISK_INFO);
            status = STATUS_SUCCESS;
        }
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  numBytesReturned,
                                  IO_NO_INCREMENT
                                  );

    return status;
}


NTSTATUS
TrueffsQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        trueffsDriverExtension = IoGetDriverObjectExtension(
                                 pdoExtension->DriverObject,
                                 DRIVER_OBJECT_EXTENSION_ID
                                 );

        if (!trueffsDriverExtension) {

            status = STATUS_UNSUCCESSFUL;

        } else {

            *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
            *RegistryPath = &trueffsDriverExtension->RegistryPath;
            *Pdo = pdoExtension->DeviceObject;
            RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);
            status = STATUS_SUCCESS;
        }
    }
    return status;
}


NTSTATUS
TrueffsSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        switch (GuidIndex) {
        case FlashDiskInfo: {
                        status = /*STATUS_WMI_READ_ONLY;*/ STATUS_INVALID_DEVICE_REQUEST;
                        break;
                }

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

    }
    return status;
}


NTSTATUS
TrueffsSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    pdoExtension = DeviceObject->DeviceExtension;

    if (!pdoExtension) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        switch(GuidIndex) {

        case FlashDiskInfo: {
                        status = /*STATUS_WMI_READ_ONLY;*/ STATUS_INVALID_DEVICE_REQUEST;
                        break;
                }

        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

    }
    return status;
}


BOOLEAN
DebugLogEvent(IN PDRIVER_OBJECT DriverObject, IN ULONG Value)
{
    NTSTATUS status;
    ULONG DebugValue = Value;

    DebugValue++;

    // write registry debug value
    status = TrueffsGetParameterFromServiceSubKey(DriverObject,
                                                  L"DebugValue",
                                                  REG_DWORD,
                                                  FALSE,
                                                  (PVOID) &DebugValue,
                                                  sizeof(DebugValue));
    return STATUS_SUCCESS;
}


#if DBG

ULONG TffsDebugPrintLevel = TFFS_DEB_ERROR;

VOID
TrueffsDebugPrint(ULONG DebugPrintLevel, PCHAR DebugMessage, ...)
{
   va_list ap;

   va_start(ap, DebugMessage);

   if (DebugPrintLevel & TffsDebugPrintLevel)
   {
      DbgPrint(DebugMessage, ap);
   }

   va_end(ap);
}

VOID
PRINTF(PCHAR DebugMessage, ...)
{
    va_list ap;

    va_start(ap, DebugMessage);

    TrueffsDebugPrint(TFFS_DEB_INFO, DebugMessage, ap);

    va_end(ap);
}

#else

VOID
PRINTF(PCHAR DebugMessage, ...)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\nftllite.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NFTLLITE.C_V  $
 *
 *    Rev 1.27   Apr 15 2002 07:38:22   oris
 * Added support for RAM based MTD power failure tests.
 * Remove cache allocation checks - They are not needed since the cache routine itself check for proper allocation.
 * Improved power failure resistant:
 *  - Added support for VERIFY_ERASED_SECTOR compilation flag - make sure a sector is free before writing it.
 *  - writeAndCheck() -
 *    1) Added an option to verify that the sector is erased before writing.
 *    It subject to the FL_UPS/FL_OFF/FL_ON modes of the flVerifyWrite environment variable.
 *    2) Added support for partition > 0.
 *  - getUnitData() - Bug fix - in case of invalid replacement unit if we are mounting or formatting store physical unit number in
 *    invalidReplacement field of the Anand record otherwise mark head of chain as frozen and not the unit itself.
 *  - Bug fix - Added logic to find end of endless loops - findEndOfEndlessLoop()
 *  - virtual2Physical() - Added call to findEndOfEndlessLoop() if needed and return address of next free sector (used verifySector()).
 *  - initNFTL() - Added initialization of TL verifyBuffer buffer and invalidReplacement fields.
 *  - Separated the search for a free unit in physical table from allocateUnit() into dedicated routine findFreeUnit().
 *  - foldUnit()
 *    1) Added support for partition > 0.
 *    2) Prevent a recursive call to foldUnit by changing allocateUnit() with findFreeUnit().
 *    3) Added logic for endless loops.
 *    4) Added check that last sector of chain can be used.
 *  - foldBestChain() - revised the entire routine
 *    1) If folding not in place was forced free all frozen units.
 *    2) Validate that a unit was actually freed.
 *  - mountUnit() -
 *    1) In case of bad virtual unit number format the unit . An invalid virtual unit might be a result of power failures.
 *  - allocateAndWrite() - Bug fix - sector count might be incorrectly updated in case folding found a sector with bad EDC.
 *  - mountNFTL -
 *    1) Moved badFormat initialization to the end of the routine so that getUnitData() might know if it was called by mount routine.
 *    2) Made sure there is at least 1 free unit.
 *    3) Fold chains with invalid pointer in their end of chain - caused by power failures.
 *  - Added MAKE_SURE_IGNORE_HAS_BAD_EDC compilation flag - make sure that the sector is really marked
 *  - verifySector() - was completely revised.
 *
 *    Rev 1.26   Feb 19 2002 21:00:56   oris
 * Compilation errors - NO_READ_BBT_CODE
 * Removed warnings.
 * Replaced TL_LEAVE_BINARY_AREA with FL_LEAVE_BINARY_AREA
 *
 *    Rev 1.25   Jan 29 2002 20:09:58   oris
 * Bug fix - if an invalid sector flag is found in getSectorFlags routine and read operation failed, SECTOR_IGNORED should have been returned.
 *
 *    Rev 1.24   Jan 23 2002 23:33:56   oris
 * Improved markAsIgnored routine.
 * Changed DFORMAT_PRINT syntax.
 *
 *    Rev 1.23   Jan 20 2002 20:29:26   oris
 * Remove warnings
 * Bug fix - Missing cache buffers allocation check in formatUnit.
 *
 *    Rev 1.22   Jan 17 2002 23:04:22   oris
 * Added onesCount routine - number of bits in a byte.
 * Improved FL_READ_ONLY compilation mode.
 * Flash field of the TL was changed to a pointer.
 * Added check verifyVolume routine to issue a longer, but safer mount.
 * Moved RAM tables to far heap to allow BIOS driver to allocate far  memory heap even when compiled as tiny model:
 *  - InitTables : allocation was change from FL_MALLOC to FL_FAR_MALLOC.
 *  - mountUnit : changes pointer to virtual table to be FAR.
 *  - mountNFTL :
 *    - changes pointer to virtual table to be FAR.
 *    - allocation of cache tables was change from FL_MALLOC to  FL_FAR_MALLOC.
 *  - dismount : use FL_FAR_FREE instead of FL_FREE
 * formatUnit routine improved re-initialization of sector cache.
 * Changed flPolicy to be socket specific.
 * Added \r to all DEBUG_PRINT.
 * writeSector routine if this sector is the cached sector then force  re-mapping.
 * Bug fix in formatNFTL :
 *  - Add binary length to percentage of bad blocks.
 *  - Report error if there is not enough good blocks.
 *  - Report error if block 0 is bad.
 * New power failures protection algorithm
 *  - setUnitData : When verify write is on , no need to reread unit data
 *  - getSectorFlags : if flags is not valid (including SECTOR_IGNORE)  check EDC and bit distance instead of simple or.
 *  - virtual2Physical : Added endAddress parameter to allow retrieval of  not the newest sector.
 *  - writeAndCheck :
 *    - Toggle socket verify write mode according to global verify write  mode.
 *    - Moved the marking of the sector as bad into a dedicated routine  (markAsIgnored)
 *  - initNftl :
 *    - Init FLFlash pointer (and not structure)
 *    - Init socket number of the TL
 *    - Init verifiedSectorNo for FL_OFF verify write mode
 *  - swapUnits : Catch failed folding operation
 *  - Moved copySector routine into foldUnit.
 *  - Changed chain bound for all chains "for loops" to the constant  DOUBLE_MAX_UNIT_CHAIN (support MAX_UNIT_CHAIN of 1 in case of folding  not in place).
 *  - foldUnit :
 *    - When verify write is set to FL_OFF call verifySectors routine to  gradually scan the entire media
 *    - Force re-mapping of cached sector
 *    - Add force folding parameter
 *    - Toggle socket verify write mode according to verify write mode and  currently scanned sector number
 *    - Verify copied sector EDC even for last sector of chain (no need to  copy it) and if bad freeze chain and return flCanNotFold (unless forced  folding is issued)
 *    - In case of bad EDC use older sector.
 *    - In case write operation failed (could be partially written sector  that was discovered by verify write mode) freeze chain and return  flCanNotFold (unless forced folding is issued)
 *  - foldBestChain : if folding of the chosen unit failed, freeze and try  another unit MAX_FOLDING_TRIES times.
 *  - allocateUnit : free media space even if there is  a free unit  available
 *  - mapSector : if sector has bad EDC read older sector until no sectors  were found or chain bound has been reached
 *  - allocateAndWriteSector :
 *    - Catch failed folding operation.
 *    - Set curSectorWrite to current sector so that writeAndCheck routine  will be able to decide whether to verify this sector or not while in  FL_OFF verify mode.
 *  - deleteSectors : Catch failed folding operation.
 *  - mountNFTL :
 *    - Set default verify write policy to FL_UPS.
 *    - Set checkVolme routine pointer.
 *  - Added checkVolume / checkFolding / verifySectors and markAsIgnored  routines.
 *
 *    Rev 1.21   Nov 21 2001 11:38:04   oris
 * Changed FL_MARK_DELETE to FL_ON.
 *
 *    Rev 1.20   15 Nov 2001 16:28:24   dimitrys
 * Fix Big BDK partition with Bad Units problem in formatNFTL()
 *
 *    Rev 1.19   Sep 25 2001 15:39:58   oris
 * Removed warnings.
 *
 *    Rev 1.18   Jul 29 2001 18:48:50   oris
 * Bug fix - unit 0 of floors > 0 were not marked as bad blocks therefore future write operation might force the device into external eprom mode.
 *
 *    Rev 1.17   Jul 15 2001 20:45:26   oris
 * Changed DFORMAT_PRINT syntax to be similar to DEBUG_PRINT.
 *
 *    Rev 1.16   Jul 13 2001 01:08:38   oris
 * Removed EDC for media header.
 * Added dformat debug print for virgin media.
 *
 *    Rev 1.15   Jun 17 2001 16:39:12   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.14   Jun 17 2001 08:17:34   oris
 * Removed warnings.
 * Changed erase routine to formatUnit.
 * Bug fix - original meida header was not written.
 * Added NO_READ_BBT_CODE compilation flag to reduce code size.
 *
 *    Rev 1.13   May 29 2001 23:12:28   oris
 * Added EDC check of the media header both in the mount and format routines.
 *
 *    Rev 1.12   May 16 2001 21:21:26   oris
 * Added EDC check for media header.
 * Added the FL_ prefix to the following defines: ON , OFF, MALLOC and FREE.
 * Changed wear level counter from 0xFF to 0xFFF0
 *
 *    Rev 1.11   May 06 2001 22:42:26   oris
 * Removed warnings.
 *
 *    Rev 1.10   May 01 2001 16:33:46   oris
 * Bug fix - readBBT routine returned used blocks as bad.
 *
 *    Rev 1.9   Apr 30 2001 18:03:30   oris
 * Bug fix - marking binary partition blocks of devices that use artifitial large erase blocks (units).
 * Added support for the flMarkDeleteOnFlash environment variable.
 *
 *    Rev 1.8   Apr 24 2001 17:10:14   oris
 * Bug fix - readBBT routine missing casting.
 *
 *    Rev 1.7   Apr 16 2001 13:56:46   oris
 * Removed warrnings.
 *
 *    Rev 1.6   Apr 09 2001 15:04:42   oris
 * End with an empty line.
 *
 *    Rev 1.5   Apr 01 2001 07:55:42   oris
 * copywrite notice.
 * changed SEPERATED to SEPARATED.
 * Changed SEPARATED_CASCADED ifdef to a runtime if.
 *
 *    Rev 1.3   Feb 14 2001 02:03:38   oris
 * Changed readBBT to return media size.
 *
 *    Rev 1.2   Feb 12 2001 12:10:56   oris
 * Moved SEPARATED cascaded to include more uneeded code.
 * Rewritten readBBT to support far pointers.
 *
 *    Rev 1.1   Feb 07 2001 17:46:26   oris
 * Added SEPARATED_CASCADED compilation flag
 *
 *    Rev 1.0   Feb 05 2001 12:24:18   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "nftllite.h"
#include "nanddefs.h"

#ifndef FL_READ_ONLY
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
static FLStatus checkVolume(Anand vol);
static FLStatus verifySectors(Anand vol, dword sectorCount);
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
static void markAsIgnored(Anand vol,CardAddress addr);
static FLStatus foldBestChain(Anand vol, ANANDUnitNo *unitNo);
static FLStatus foldUnit(Anand vol, ANANDUnitNo virtualUnitNo, FLBoolean);
static FLStatus checkFolding(Anand vol, ANANDUnitNo virtualUnitNo);
static FLStatus allocateUnit(Anand vol, ANANDUnitNo *);
#endif /* FL_READ_ONLY */
static Anand vols[VOLUMES];

#ifdef NFTL_CACHE
/* translation table for Sector Flags cache */
static unsigned char scacheTable[4] = { SECTOR_DELETED, /* 0 */
                    SECTOR_IGNORE,  /* 1 */
                    SECTOR_USED,    /* 2 */
                    SECTOR_FREE };  /* 3 */
#endif /* NFTL_CACHE */
#ifdef FORMAT_VOLUME
byte ff[ANAND_SPARE_SIZE];
#endif /* FORMAT_VOLUME */

/*------------------------------------------------------*/
/*                o n e s C o u n t                     */
/*                                                      */
/*  counts number of bits that valued 1 in a given byte */
/*------------------------------------------------------*/

static byte onesCount(byte flag)
{
   byte counter;

   for (counter = 0; flag; flag >>= 1)
          if (flag & 1)
           counter++;

   return counter;
}


/*----------------------------------------------------------------------*/
/*                 u n i t B a s e A d d r e s s                        */
/*                                                                      */
/* Returns the physical address of a unit.                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*                                                                      */
/* Returns:                                                             */
/*    physical address of unitNo                                        */
/*----------------------------------------------------------------------*/

static CardAddress unitBaseAddress(Anand vol, ANANDUnitNo unitNo)
{
  return (CardAddress)unitNo << vol.unitSizeBits;
}


/*----------------------------------------------------------------------*/
/*                 g e t U n i t D a t a                                */
/*                                                                      */
/* Get virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol               : Pointer identifying drive                     */
/*    unitNo            : Physical unit number                          */
/*    virtualUnitNo     : Receives the virtual unit no.                 */
/*    replacementUnitNo : Receives the replacement unit no.             */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void getUnitData(Anand vol,
            ANANDUnitNo unitNo,
            ANANDUnitNo *virtualUnitNo,
            ANANDUnitNo *replacementUnitNo)
{
  ANANDUnitHeader unitData;

#ifdef NFTL_CACHE
  /* check ANANDUnitHeader cache first */
  if (vol.ucache != NULL) {
      /* on cache miss read ANANDUnitHeader from flash and re-fill cache */
      if((vol.ucache[unitNo].virtualUnitNo == 0xDEAD) &&
      (vol.ucache[unitNo].replacementUnitNo == 0xDEAD)) {
          vol.flash->read(vol.flash,
                     unitBaseAddress(&vol,unitNo) + UNIT_DATA_OFFSET,
                 &unitData,
                 sizeof(ANANDUnitHeader),
                 EXTRA);

      vol.ucache[unitNo].virtualUnitNo =
          LE2(unitData.virtualUnitNo) | LE2(unitData.spareVirtualUnitNo);
      vol.ucache[unitNo].replacementUnitNo =
          LE2(unitData.replacementUnitNo) | LE2(unitData.spareReplacementUnitNo);
      }

      *virtualUnitNo     = vol.ucache[unitNo].virtualUnitNo;
      *replacementUnitNo = vol.ucache[unitNo].replacementUnitNo;
  }
  else
#endif /* NFTL_CACHE */
  {   /* no ANANDUnitHeader cache */
      vol.flash->read(vol.flash,
                      unitBaseAddress(&vol,unitNo) + UNIT_DATA_OFFSET,
                      &unitData,
                      sizeof(ANANDUnitHeader),
                      EXTRA);

      /* Mask out any 1 -> 0 bit faults by or'ing with spare data */
      *virtualUnitNo = LE2(unitData.virtualUnitNo) |
                   LE2(unitData.spareVirtualUnitNo);
      *replacementUnitNo = LE2(unitData.replacementUnitNo) |
                       LE2(unitData.spareReplacementUnitNo);
  }
  if( !isLegalUnit(*replacementUnitNo) ) {
    vol.invalidReplacement = unitNo;
    if(vol.badFormat == FALSE) /* Not called by mount operation */
    {
       ANANDUnitNo firstUnits = vol.virtualUnits[*virtualUnitNo];
       if(firstUnits != ANAND_NO_UNIT)
          setUnavail(firstUnits & (~ANAND_REPLACING_UNIT));      /* freeze unit chain */
    }
    *replacementUnitNo = ANAND_NO_UNIT;
  }
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                 s e t U n i t D a t a                                */
/*                                                                      */
/* Set virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol               : Pointer identifying drive                     */
/*    unitNo            : Physical unit number                          */
/*    virtualUnitNo     : Virtual unit no.                              */
/*    replacementUnitNo : Replacement unit no.                          */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus      : 0 on success, failed otherwise                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitData(Anand vol,
              ANANDUnitNo unitNo,
              ANANDUnitNo virtualUnitNo,
              ANANDUnitNo replacementUnitNo)
{
  ANANDUnitHeader unitData;
  ANANDUnitNo newVirtualUnitNo, newReplacementUnitNo;

  if( replacementUnitNo == unitNo )              /* prevent chain loop */
    return flGeneralFailure;

  toLE2(unitData.virtualUnitNo,virtualUnitNo);
  toLE2(unitData.spareVirtualUnitNo,virtualUnitNo);
  toLE2(unitData.replacementUnitNo,replacementUnitNo);
  toLE2(unitData.spareReplacementUnitNo,replacementUnitNo);

  checkStatus(vol.flash->write(vol.flash,
                   unitBaseAddress(&vol,unitNo) + UNIT_DATA_OFFSET,
                   &unitData,
                   sizeof(ANANDUnitHeader),
                   EXTRA));

#ifdef VERIFY_WRITE
  if (vol.flash->socket->verifyWrite==FL_ON)
  {
#ifdef NFTL_CACHE
    /* Set new entries for ANANDUnitHeader cache */
     if (vol.ucache != NULL) {
         vol.ucache[unitNo].virtualUnitNo     = virtualUnitNo;
         vol.ucache[unitNo].replacementUnitNo = replacementUnitNo;
     }
#endif /* NFTL_CACHE */
     return flOK;
  }
#endif /* VERIFY_WRITE */


#ifdef NFTL_CACHE
  /* purge ANANDUnitHeader cache to force re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo     = 0xDEAD;
      vol.ucache[unitNo].replacementUnitNo = 0xDEAD;
  }
#endif /* NFTL_CACHE */

  /* Verify the new unit data */
  getUnitData(&vol,unitNo,&newVirtualUnitNo, &newReplacementUnitNo);
  if (virtualUnitNo != newVirtualUnitNo ||
      replacementUnitNo != newReplacementUnitNo)
    return flWriteFault;
  else
    return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                 g e t N e x t U n i t                                */
/*                                                                      */
/* Get next unit in chain.                                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol             : Pointer identifying drive                       */
/*    unitNo          : Physical unit number                            */
/*    virUnitNo       : Virtual unit number of the chain.               */
/*                                                                      */
/* Returns:                                                             */
/*     Physical unit number of the unit following unitNo in the chain.  */
/*     If such unit do not exist, return ANAND_NO_UNIT.                 */
/*----------------------------------------------------------------------*/

static ANANDUnitNo getNextUnit(Anand vol, ANANDUnitNo unitNo, ANANDUnitNo virUnitNo)
{
  ANANDUnitNo virtualUnitNo, replacementUnitNo;

  if (!(vol.physicalUnits[unitNo] & UNIT_REPLACED))
    return ANAND_NO_UNIT;

  getUnitData(&vol,unitNo,&virtualUnitNo,&replacementUnitNo);
  if( virUnitNo != (virtualUnitNo & ~ANAND_REPLACING_UNIT) ) {
    unitNo = vol.virtualUnits[virUnitNo];
    setUnavail(unitNo); /* freeze unit chain */
    return ANAND_NO_UNIT;
  }

  return replacementUnitNo;
}


#ifdef NFTL_CACHE

/*----------------------------------------------------------------------*/
/*         g e t S e c t o r F l a g s F r o m C a c h e                */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    address        : starting address of the sector                   */
/*                                                                      */
/* Returns:                                                             */
/*    sector flags (SECTOR_USED, SECTOR_DELETED etc.)                   */
/*----------------------------------------------------------------------*/
static unsigned char getSectorFlagsFromCache(Anand vol, CardAddress address)
{
  return scacheTable[(vol.scache[address >> (SECTOR_SIZE_BITS+2)] >>
             (((unsigned int)address >> 8) & 0x7)) & 0x3];
}


/*----------------------------------------------------------------------*/
/*             s e t S e c t o r F l a g s C a c h e                    */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    address        : starting address of the sector                   */
/*    sectorFlags    : one of SECTOR_USED, SECTOR_DELETED etc.          */
/*                                                                      */
/*----------------------------------------------------------------------*/
static void setSectorFlagsCache(Anand vol, CardAddress address,
                unsigned char sectorFlags)
{
  register unsigned char tmp, val;

  if (vol.scache == NULL)
    return;

  tmp = vol.scache[address >> (SECTOR_SIZE_BITS+2)];

  switch(sectorFlags) {
    case SECTOR_USED:          val = S_CACHE_SECTOR_USED;    break;
    case SECTOR_FREE:          val = S_CACHE_SECTOR_FREE;    break;
    case SECTOR_DELETED:       val = S_CACHE_SECTOR_DELETED; break;
    default:/* SECTOR_IGNORE */val = S_CACHE_SECTOR_IGNORE;  break;
  }

  switch (((unsigned int)address >> 8) & 0x7) {
    case 0: tmp = (tmp & 0xfc) | (val     ); break;  /* update bits 0..1 */
    case 2: tmp = (tmp & 0xf3) | (val << 2); break;  /*        bits 2..3 */
    case 4: tmp = (tmp & 0xcf) | (val << 4); break;  /*        bits 4..5 */
    case 6: tmp = (tmp & 0x3f) | (val << 6); break;  /*        bits 6..7 */
  }

  vol.scache[address >> (SECTOR_SIZE_BITS+2)] = tmp;
}

#endif /* NFTL_CACHE */



/*----------------------------------------------------------------------*/
/*                  g e t S e c t o r F l a g s                         */
/*                                                                      */
/* Get sector status.                                                   */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*     sectorAddress        : Physical address of the sector            */
/*                                                                      */
/* Returns:                                                             */
/*    Return the OR of the two bytes in the sector status area (the     */
/*    bytes should contain the same data).                              */
/*----------------------------------------------------------------------*/

static unsigned char getSectorFlags(Anand vol, CardAddress sectorAddress)
{
  byte     flags[2];
  byte     blockFlag = SECTOR_IGNORE;
  byte     index,tmpSector;
  FLStatus status;

#ifdef NFTL_CACHE
  if (vol.scache != NULL) {  /* check for Sector Flags cache hit */

    blockFlag = getSectorFlagsFromCache(&vol, sectorAddress);
    if (blockFlag != SECTOR_IGNORE)
      return blockFlag;
  }
#endif /* NFTL_CACHE */

  vol.flash->read(vol.flash, sectorAddress + SECTOR_DATA_OFFSET,
                  flags, sizeof flags, EXTRA);

  if((flags[0] == flags[1]) && (isValidSectorFlag(flags[0])))
  {
     blockFlag = flags[0];
  }
  else /* Sector flags that were read are not legal */
  {
     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Check for ignored sector using the EDC */
     status = vol.flash->read(vol.flash, sectorAddress,
                              nftlBuffer, SECTOR_SIZE, EDC);

     if(status == flOK)
     {
        /* Check if distance is less then 2 bits failure since */
        /* 2 bits failure can be either delete or used         */
        for (index=0 , tmpSector = (byte)SECTOR_USED ; index < 2 ;
             index++ , tmpSector = (byte)SECTOR_DELETED)
        {
           if (distanceOf(flags[0], tmpSector) +
               distanceOf(flags[1], tmpSector) <= 2)
           {
              blockFlag = tmpSector;
              break;
           }
        }
        if(index>=2)
           return SECTOR_IGNORE;
     }
     else
     {
        return SECTOR_IGNORE;
     }
  }

#ifdef NFTL_CACHE
  /* update Sector Flags cache */
  setSectorFlagsCache(&vol, sectorAddress, blockFlag);
#endif /* NFTL_CACHE */

  return blockFlag;
}

/*----------------------------------------------------------------------*/
/*            f i n d E n d O f E n d l e s s C h a i n                 */
/*                                                                      */
/* Find end of endless chain - last unit of unit chain that points to   */
/* itself.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol          : Pointer identifying drive                          */
/*    virUnitNo    : Virtual unit number                                */
/*                                                                      */
/* Returns:                                                             */
/*    Physical unit number of oldest unit of the chain                  */
/*----------------------------------------------------------------------*/

static ANANDUnitNo findEndOfEndlessChain(Anand vol, ANANDUnitNo virUnitNo)
{
  ANANDUnitNo chainsUnit[DOUBLE_MAX_UNIT_CHAIN/2+2];
  ANANDUnitNo unitNo;
  int         i;
  int         chainBound;

  for (unitNo    = vol.virtualUnits[virUnitNo] , chainBound = 0 ;
       chainBound < MAX_UNIT_CHAIN ;
       unitNo    = getNextUnit(&vol,unitNo,virUnitNo) , chainBound++)
  {
     chainsUnit[chainBound] = unitNo; /* Save location of current unit */

     for(i = 0 ; i < chainBound ; i++) /* Check if already been to this unit */
     {
        if(chainsUnit[chainBound] == unitNo) /* Bad next unit number pointer */
            break;
     }
  }
  return chainsUnit[chainBound-1];
}

/*----------------------------------------------------------------------*/
/*                 v i r t u a l 2 P h y s i c a l                      */
/*                                                                      */
/* Translate virtual sector number to physical address.                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol          : Pointer identifying drive                          */
/*    sectorNo     : Virtual sector number                              */
/*    endAddress   : End address for sector search. NULL for no end     */
/*                                                                      */
/* Returns:                                                             */
/*    endAddress   : Next free sector address                           */
/*    physical address of sectorNo                                      */
/*----------------------------------------------------------------------*/

static CardAddress virtual2Physical(Anand vol, SectorNo sectorNo , CardAddress* endAddress)
{
  unsigned unitOffset = (unsigned)((sectorNo % vol.sectorsPerUnit) << SECTOR_SIZE_BITS);
  CardAddress prevSectorAddress = ANAND_UNASSIGNED_ADDRESS;
  CardAddress sectorAddress;
  CardAddress *freeSectorAddressPtr;
  ANANDUnitNo unitNo, virUnitNo;
  ANANDUnitNo chainBound = 0;
  ANANDUnitNo endUnit;
  byte        sectorFlags;
  FLBoolean   badPointerFound = FALSE;

  /* Set end unit and nextFreeSectorAddress */
  if(endAddress == NULL)
  {
     endUnit = ANAND_NO_UNIT;
  }
  else
  {
     endUnit = (ANANDUnitNo)(*endAddress>>vol.unitSizeBits);
     *endAddress = ANAND_UNASSIGNED_ADDRESS;
  }

  /* follow the chain */
  virUnitNo = (ANANDUnitNo)(sectorNo / vol.sectorsPerUnit);
  for (unitNo = vol.virtualUnits[virUnitNo];
       ( (unitNo != endUnit) && (chainBound < DOUBLE_MAX_UNIT_CHAIN) );
       unitNo = getNextUnit(&vol,unitNo,virUnitNo))
  {
    sectorAddress = unitBaseAddress(&vol,unitNo) + unitOffset;
    sectorFlags   = getSectorFlags(&vol,sectorAddress);

    if (sectorFlags == SECTOR_FREE)
    {
      if(endAddress != NULL)
         *endAddress = sectorAddress;
      break;
    }

    if (sectorFlags != SECTOR_IGNORE)
      prevSectorAddress = sectorFlags != SECTOR_DELETED ? sectorAddress :
                            ANAND_UNASSIGNED_ADDRESS;
    chainBound++;
  }

  if(chainBound < DOUBLE_MAX_UNIT_CHAIN)
     return prevSectorAddress;

  /* Infint loop caused by power failure */
  if(endAddress == NULL)
  {
     freeSectorAddressPtr = &sectorAddress;
  }
  else
  {
      freeSectorAddressPtr = endAddress;
  }
  *freeSectorAddressPtr = unitOffset +
                          unitBaseAddress(&vol,
                          findEndOfEndlessChain(&vol,virUnitNo));
  return virtual2Physical(&vol, sectorNo , freeSectorAddressPtr);
}


/*----------------------------------------------------------------------*/
/*                 g e t F o l d M a r k                                */
/*                                                                      */
/* Get the fold mark a unit.                                            */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*                                                                      */
/* Returns:                                                             */
/*    Return the OR of the two words in the fold mark area (the words   */
/*    should be identical)                                              */
/*----------------------------------------------------------------------*/

static unsigned short getFoldMark(Anand vol, ANANDUnitNo unitNo)
{
  unsigned short foldMark[2];

  vol.flash->read(vol.flash,
          unitBaseAddress(&vol,unitNo) + FOLD_MARK_OFFSET,
          foldMark, sizeof foldMark,
          EXTRA);

  return foldMark[0] | foldMark[1];
}


/*----------------------------------------------------------------------*/
/*                 g e t U n i t T a i l e r                            */
/*                                                                      */
/* Get the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*    eraseMark    : Receives the erase mark of the unit                */
/*    eraseCount    : Receives the erase count of the unit              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void getUnitTailer(Anand vol,
              ANANDUnitNo unitNo,
              unsigned short *eraseMark,
              unsigned long *eraseCount)
{
  UnitTailer unitTailer;

  vol.flash->read(vol.flash,
          unitBaseAddress(&vol,unitNo) + UNIT_TAILER_OFFSET,
          &unitTailer,
          sizeof(UnitTailer),
          EXTRA);

  /* Mask out any 1 -> 0 bit faults by or'ing with spare data */
  *eraseMark = LE2(unitTailer.eraseMark) | LE2(unitTailer.eraseMark1);
  *eraseCount = LE4(unitTailer.eraseCount);
}

/*----------------------------------------------------------------------*/
/*                        s e t U n i t T a i l e r                     */
/*                                                                      */
/* Set the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*    eraseMark    : Erase mark to set                                  */
/*    eraseCount    : Erase count to set                                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitTailer(Anand vol,
                ANANDUnitNo unitNo,
                unsigned short eraseMark,
                unsigned long eraseCount)
{
  UnitTailer unitTailer;

  toLE2(unitTailer.eraseMark,eraseMark);
  toLE2(unitTailer.eraseMark1,eraseMark);
  toLE4(unitTailer.eraseCount,eraseCount);

  return vol.flash->write(vol.flash,
              unitBaseAddress(&vol,unitNo) + UNIT_TAILER_OFFSET,
              &unitTailer,
              sizeof(UnitTailer),
              EXTRA);
}

/*----------------------------------------------------------------------*/
/*                       i n i t N F T L                                */
/*                                                                      */
/* Initializes essential volume data as a preparation for mount or      */
/* format.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    flash        : Flash media mounted on this socket                 */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus initNFTL(Anand vol, FLFlash *flash)
{
  dword size = 1;

  if (flash == NULL || !(flash->flags & NFTL_ENABLED)) {
    DEBUG_PRINT(("Debug: media is not fit for NFTL format.\r\n"));
    return flUnknownMedia;
  }

  vol.flash = flash;

#ifdef NT5PORT
  vol.socketNo = (byte)(flSocketNoOf(vol.flash->socket));
#else
    vol.socketNo = flSocketNoOf(vol.flash->socket);
#endif NT5PORT

  vol.physicalUnits = NULL;
  vol.virtualUnits = NULL;

#ifdef NFTL_CACHE
  vol.ucache = NULL;
  vol.scache = NULL;
#endif

  for (vol.erasableBlockSizeBits = 0; size < vol.flash->erasableBlockSize;
       vol.erasableBlockSizeBits++, size <<= 1);
  vol.unitSizeBits = vol.erasableBlockSizeBits;

  vol.noOfUnits = (unsigned short)((vol.flash->noOfChips * vol.flash->chipSize) >> vol.unitSizeBits);

  /* Adjust unit size so header unit fits in one unit */
  while (vol.noOfUnits * sizeof(ANANDPhysUnit) + SECTOR_SIZE > (1UL << vol.unitSizeBits)) {
    vol.unitSizeBits++;
    vol.noOfUnits >>= 1;
  }
  /* Bound number of units to find room in 64 Kbytes Segment */
  if( (vol.noOfUnits >= MAX_UNIT_NUM) && (vol.unitSizeBits < MAX_UNIT_SIZE_BITS) ) {
    vol.unitSizeBits++;
    vol.noOfUnits >>= 1;
  }

  vol.badFormat      = TRUE;    /* until mount completes*/
  vol.mappedSectorNo = UNASSIGNED_SECTOR;
  vol.countsValid    = 0;          /* No units have a valid count yet */

  /*get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  vol.buffer       = flBufferOf(flSocketNoOf(vol.flash->socket));
#ifdef VERIFY_ERASED_SECTOR
  vol.verifyBuffer = (dword *)flReadBackBufferOf(flSocketNoOf(flash->socket));
#endif /* VERIFY_ERASED_SECTOR */

#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  vol.verifiedSectorNo = 0;    /* Largest sector verified so far     */
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
  vol.invalidReplacement = ANAND_NO_UNIT; /* a unit with bad RUN */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                     i n i t T a b l e s                              */
/*                                                                      */
/* Allocates and initializes the dynamic volume table, including the    */
/* unit tables and secondary virtual map.                               */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus initTables(Anand vol)
{
  /* Allocate the conversion tables */
#ifdef FL_MALLOC
  vol.physicalUnits = (ANANDPhysUnit FAR1*) FL_FAR_MALLOC (vol.noOfUnits * sizeof(ANANDPhysUnit));
  vol.virtualUnits = (ANANDUnitNo FAR1*) FL_FAR_MALLOC (vol.noOfVirtualUnits * sizeof(ANANDUnitNo));
  if (vol.physicalUnits == NULL ||
      vol.virtualUnits == NULL) {
    DEBUG_PRINT(("Debug: failed allocating conversion tables for NFTL.\r\n"));
    return flNotEnoughMemory;
  }
#else
  char *heapPtr;

  heapPtr = vol.heap;
  vol.physicalUnits = (ANANDPhysUnit *) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(ANANDPhysUnit);
  vol.virtualUnits = (ANANDUnitNo *) heapPtr;
  heapPtr += vol.noOfVirtualUnits * sizeof(ANANDUnitNo);
  if (heapPtr > vol.heap + sizeof vol.heap) {
    DEBUG_PRINT(("Debug: not enough memory for NFTL conversion tables.\r\n"));
    return flNotEnoughMemory;
  }
#endif

  return flOK;
}

/*----------------------------------------------------------------------*/
/*                      m a r k U n i t B a d                           */
/*                                                                      */
/* Mark a unit as bad in the conversion table and the bad units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical number of bad unit                       */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus markUnitBad(Anand vol, ANANDUnitNo unitNo)
{
  unsigned short eraseMark;
  unsigned long eraseCount;

  vol.physicalUnits[unitNo] = UNIT_BAD_MOUNT;

  getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount);

  return setUnitTailer(&vol,unitNo,0,eraseCount);
}


/*----------------------------------------------------------------------*/
/*                  f o r m a t U n i t                                 */
/*                                                                      */
/* Format one unit. Erase the unit, and mark the physical units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Unit to format                                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus formatUnit(Anand vol, ANANDUnitNo unitNo)
{
  unsigned short eraseMark;
  unsigned long eraseCount;
  FLStatus status;

  if (!isAvailable(unitNo))
    return flWriteFault;

  if (vol.physicalUnits[unitNo] == ANAND_UNIT_FREE)
    vol.freeUnits--;
  setUnavail(unitNo);

  getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount);

#ifdef NFTL_CACHE
  /* purge ANANDUnitHeader cache to force re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo     = 0xDEAD;
      vol.ucache[unitNo].replacementUnitNo = 0xDEAD;
  }

  /*
   * Purge the Sector Flags cache (set entries for all the unit's
   * sectors to SECTOR_FREE).
   */
  if (vol.scache != NULL) {
    tffsset(&(vol.scache[unitNo << (vol.unitSizeBits - SECTOR_SIZE_BITS-2)]),
    S_CACHE_4_SECTORS_FREE, 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2));
  }
#endif /* NFTL_CACHE */

  status = vol.flash->erase(vol.flash,
                (word)(unitNo << (vol.unitSizeBits - vol.erasableBlockSizeBits)),
                (word)(1 << (vol.unitSizeBits - vol.erasableBlockSizeBits)));
  if (status != flOK) {
    markUnitBad(&vol,unitNo);    /* make sure unit format is not valid */
    return status;
  }

  vol.eraseSum++;
  eraseCount++;
  if (eraseCount == 0)        /* was hex FF's */
    eraseCount++;

  checkStatus(setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount));

  vol.physicalUnits[unitNo] = ANAND_UNIT_FREE;
  vol.freeUnits++;

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                  w r i t e A n d C h e c k                           */
/*                                                                      */
/* Write one sector.                                                    */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    address        : Physical address of the sector to write to       */
/*    fromAddress    : Buffer of data to write                          */
/*    flags        : Write flags (ECC, overwrite etc.)                  */
/*                                                                      */
/* Returns:                                                             */
/*     Status         : 0 on success, failed otherwise.                 */
/*----------------------------------------------------------------------*/

static FLStatus writeAndCheck(Anand vol,
                CardAddress address,
                void FAR1 *fromAddress,
                unsigned flags)
{
  FLStatus status;
#ifdef VERIFY_ERASED_SECTOR
  register int noOfDword;
  int i;
#endif /* VERIFY_ERASED_SECTOR */

  /* Toggle verify write flag */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  switch (flVerifyWrite[vol.socketNo][vol.flash->socket->curPartition])
  {
     case FL_OFF:
        if (vol.verifiedSectorNo>vol.curSectorWrite)
           break;
     case FL_ON:
#ifdef VERIFY_WRITE
        vol.flash->socket->verifyWrite = FL_ON;
#endif /* VERIFY_WRITE */
#ifdef VERIFY_ERASED_SECTOR
        /* Make sure all of the sectors are really free */
        checkStatus(vol.flash->read(vol.flash,address,vol.verifyBuffer,SECTOR_SIZE,0));
        noOfDword = SECTOR_SIZE/sizeof(dword);
        for(i = 0;i<noOfDword;i++)          /* Loop over sector data */
        {
           if(vol.verifyBuffer[i]!=0xffffffffL)
           {
              markAsIgnored(&vol,address);
              DEBUG_PRINT(("writeAndCheck : The sector was not erased and is ignored\r\n"));
              return flWriteFault;
           }
        }
#endif /* VERIFY_ERASED_SECTOR */
     default:
        break;
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /* Write sector */
  status = vol.flash->write(vol.flash,address,fromAddress,SECTOR_SIZE,(word)flags);

  if (status == flWriteFault) {  /* write failed, ignore this sector */
    markAsIgnored(&vol,address);
  }
#ifdef NFTL_CACHE
  else  {
     setSectorFlagsCache(&vol, address, SECTOR_USED);
  }
#endif

#ifdef VERIFY_WRITE
  /* Restore verify write mode */
  if(flVerifyWrite[flSocketNoOf(vol.flash->socket)][vol.flash->socket->curPartition] != FL_ON)
     vol.flash->socket->verifyWrite = FL_OFF;
#endif /* VERIFY_WRITE */

  return status;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                  l a s t I n C h a i n                               */
/*                                                                      */
/* Find last unit in chain.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*     unitNo        : Start the search from this unit                  */
/*                                                                      */
/* Returns:                                                             */
/*     Physical unit number of the last unit in chain.                  */
/*----------------------------------------------------------------------*/

static ANANDUnitNo lastInChain(Anand vol, ANANDUnitNo unitNo)
{
  ANANDUnitNo firstVirtualUnitNo, firstReplacementUnitNo;
  ANANDUnitNo lastUnit = unitNo, nextUnitNo;
  ANANDUnitNo chainBound = 0;

  if(unitNo == ANAND_NO_UNIT)
    return ANAND_NO_UNIT;

  getUnitData(&vol,unitNo,&firstVirtualUnitNo,&firstReplacementUnitNo);
  nextUnitNo = firstReplacementUnitNo;

  while( (nextUnitNo < vol.noOfUnits) &&  /* Validate replacement unit no. */
     (chainBound < DOUBLE_MAX_UNIT_CHAIN) ) {
    ANANDUnitNo nextVirtualUnitNo, nextReplacementUnitNo;

    if( !isAvailable(nextUnitNo) )
      break;
    getUnitData(&vol,nextUnitNo,&nextVirtualUnitNo,&nextReplacementUnitNo);
    if( nextVirtualUnitNo != (firstVirtualUnitNo | ANAND_REPLACING_UNIT) )
      break;        /* Virtual unit no. not validated */
    lastUnit = nextUnitNo;
    nextUnitNo = nextReplacementUnitNo;
    chainBound++;
  }

  return lastUnit;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                   a s s i g n U n i t                                */
/*                                                                      */
/* Assigns a virtual unit no. to a unit                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*    virtualUnitNo    : Virtual unit number to assign                  */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus assignUnit(Anand vol, ANANDUnitNo unitNo, ANANDUnitNo virtualUnitNo)
{
  ANANDUnitNo newVirtualUnitNo, newReplacementUnitNo;
  ANANDUnitNo oldVirtualUnitNo, oldReplacementUnitNo;
  FLStatus status;
  ANANDUnitNo newestUnitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo oldUnitNo;

  /* Assign the new unit */
  newVirtualUnitNo = virtualUnitNo;
  if (newestUnitNo != ANAND_NO_UNIT)
    newVirtualUnitNo |= ANAND_REPLACING_UNIT;
  newReplacementUnitNo = ANAND_NO_UNIT;
  vol.physicalUnits[unitNo] = 0;
  vol.freeUnits--;
  status = setUnitData(&vol,unitNo,newVirtualUnitNo,newReplacementUnitNo);
  if (status != flOK)
  {
    markUnitBad(&vol,unitNo);
    return status;
  }

  /* Add unit to chain */
  if (newestUnitNo != ANAND_NO_UNIT)
  {
    /* If unit is frozen, don't attempt to chain (folding not-in-place) */
    if (!isAvailable(newestUnitNo))
      return flOK;

    oldUnitNo = lastInChain(&vol,newestUnitNo);
    getUnitData(&vol,oldUnitNo,&oldVirtualUnitNo,&oldReplacementUnitNo);
    if (oldReplacementUnitNo != ANAND_NO_UNIT)
      status = flWriteFault;    /* can't write here, so assume failure */
    else {
      vol.physicalUnits[oldUnitNo] |= UNIT_REPLACED;
      status = setUnitData(&vol,oldUnitNo,oldVirtualUnitNo,unitNo);
    }
    if (status != flOK) {
      formatUnit(&vol,unitNo); /* Get rid of the allocated unit quickly */
      setUnavail(newestUnitNo); /* freeze the chain */

      return status;
    }
    if (vol.countsValid > virtualUnitNo && newestUnitNo != oldUnitNo){
      if (countOf(newestUnitNo) + countOf(oldUnitNo) <= UNIT_MAX_COUNT)
        vol.physicalUnits[newestUnitNo] += countOf(oldUnitNo);
      else
        return flGeneralFailure;
    }
  }
  else
    vol.virtualUnits[virtualUnitNo] = unitNo;

  return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                   f o r m a t C h a i n                              */
/*                                                                      */
/* Format all the units in a chain. Start from the last one and go      */
/* backwards until unitNo is reached.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Format the chain from this unit onwards           */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus formatChain(Anand vol, ANANDUnitNo unitNo)
{
  /* Erase the chain from end to start */
  ANANDUnitNo chainBound;

  setUnitCount(unitNo,0);    /* Reenable erase of this unit */
  for (chainBound=0;( chainBound < DOUBLE_MAX_UNIT_CHAIN ); chainBound++) {
    /* Find last unit in chain */
    ANANDUnitNo unitToErase = lastInChain(&vol,unitNo);

    if( formatUnit(&vol,unitToErase) != flOK )
      break;

    if (unitToErase == unitNo)
      break;    /* Erased everything */
  }

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        S w a p U n i t s                             */
/*                                                                      */
/* Applies wear leveling.                                               */
/* A rover unit dictates the current unit to level. If a unit chain     */
/* fold, if single unit chain , append a unit and then fold.            */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

FLStatus swapUnits(Anand vol)
{
  ANANDUnitNo i,unitNo,virtualUnitNo,replacementUnitNo;
  FLStatus    status;

  if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
    return flOK;

  for(i=0,unitNo=vol.virtualUnits[vol.wearLevel.currUnit];
      (unitNo==ANAND_NO_UNIT) && (i<vol.noOfVirtualUnits);i++) {

    vol.wearLevel.currUnit++;
    if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
      vol.wearLevel.currUnit = 0;

    unitNo=vol.virtualUnits[vol.wearLevel.currUnit];
  }

  if(unitNo==ANAND_NO_UNIT) /*The media is empty*/
    return flOK;

  virtualUnitNo = vol.wearLevel.currUnit;

  vol.wearLevel.currUnit++;
  if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
    vol.wearLevel.currUnit = 0;

  if((vol.physicalUnits[unitNo] & UNIT_REPLACED) ||
     (!isAvailable(unitNo)                     )   )
  {
     status = foldUnit(&vol,virtualUnitNo,FALSE);
  }
  else
  {
     checkStatus(allocateUnit(&vol,&replacementUnitNo));
     return assignUnit(&vol,replacementUnitNo,virtualUnitNo);
  }

  /* If folding failed make sure there are enough units and call again */
  if(status == flCanNotFold)
    return checkFolding(&vol,virtualUnitNo);

  return status;
}


/*----------------------------------------------------------------------*/
/*                       f i n d F r e e U n i t                        */
/*                                                                      */
/* Find a free unit from the physical unit pool.                        */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo     : Receives the physical unit no.                       */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus findFreeUnit(Anand vol, ANANDUnitNo *unitNo)
{
   ANANDUnitNo originalUnit = vol.roverUnit;
   unsigned short eraseMark;
   unsigned long eraseCount;

   do
   {
       if (++vol.roverUnit >= vol.noOfUnits)
          vol.roverUnit = vol.bootUnits;

       if (vol.physicalUnits[vol.roverUnit] == ANAND_UNIT_FREE)
        {
          /* found a free unit, if not erased, */
          getUnitTailer(&vol,vol.roverUnit,&eraseMark,&eraseCount);
          if (eraseMark != ERASE_MARK)
            {
             if (formatUnit(&vol,vol.roverUnit) != flOK)
                continue;    /* this unit is bad, find another */
            }
          *unitNo = vol.roverUnit;
          return flOK;
       }
   } while (vol.roverUnit != originalUnit);
   return flNotEnoughMemory;      /* Report no space at all  */
}


/*----------------------------------------------------------------------*/
/*                       f o l d U n i t                                */
/*                                                                      */
/* Copy all the sectors that hold valid data in the chain to the last   */
/* unit of the chain and erase the chain.                               */
/*                                                                      */
/* Parameters:                                                          */
/*    vol           : Pointer identifying drive                         */
/*    virtualUnitNo : Virtual unit number of the first unit in chain.   */
/*    forceFolding  : Boolean flag stating wether to force folding even */
/*                    at the cost of loosing sector data.               */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus foldUnit(Anand vol, ANANDUnitNo virtualUnitNo, FLBoolean forceFolding)
{
  ANANDUnitNo unitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo targetUnitNo, chainBound;
  unsigned long foldMark;
  SectorNo    virtualSectorNo = (SectorNo)virtualUnitNo * vol.sectorsPerUnit;
  CardAddress endSectorAddress;
  CardAddress targetSectorAddress;
  CardAddress sourceSectorAddress;
  unsigned    newSectorCount, i;
  FLBoolean   partialFoldingFlag = FALSE;
  FLStatus    status;

  /* Force remapping of internal catched sector */
  vol.flash->socket->remapped = TRUE;
  vol.unitsFolded++;

/* When using FL_OFF option the media is scanned in the folding operation */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  if(flVerifyWrite[flSocketNoOf(vol.flash->socket)][vol.flash->socket->curPartition]==FL_OFF)
  {
     checkStatus(verifySectors(&vol,SECTORS_VERIFIED_PER_FOLDING));
     vol.curSectorWrite = virtualSectorNo;
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

/* Find target unit */
  if (!isAvailable(unitNo)) /* If this unit is frozen, */
  {
     if(vol.freeUnits > 0)
     {
         /* allocate a new unit to fold into */
         checkStatus(findFreeUnit(&vol,&targetUnitNo));
         checkStatus(assignUnit(&vol,targetUnitNo,virtualUnitNo));
     }
     else
     {
        if(forceFolding==FALSE)
           return flCanNotFold;
        partialFoldingFlag = TRUE;
     }
  }

  if((isAvailable(unitNo)) || (partialFoldingFlag == TRUE))
  {        /* Default. Fold into end of chain */
    targetUnitNo = unitNo;

    for (chainBound=0;( chainBound < DOUBLE_MAX_UNIT_CHAIN );chainBound++)
    {
      ANANDUnitNo nextUnitNo = getNextUnit(&vol,targetUnitNo,virtualUnitNo);
      if (nextUnitNo == ANAND_NO_UNIT)
         break;
      targetUnitNo = nextUnitNo;
    }
    if(chainBound == DOUBLE_MAX_UNIT_CHAIN)
    {
      targetUnitNo = findEndOfEndlessChain(&vol, virtualUnitNo);
    }
  }

  /***********************************/
  /* Copy all sectors to target unit */
  /***********************************/

  /* Mark unit as currently folded */
  foldMark = FOLDING_IN_PROGRESS * 0x10001l;

  if( getFoldMark(&vol,unitNo) != FOLDING_IN_PROGRESS )
    vol.flash->write(vol.flash,
                     unitBaseAddress(&vol,unitNo) + FOLD_MARK_OFFSET,
                     &foldMark,
                     sizeof foldMark,
                     EXTRA);

  setUnavail(unitNo);    /* Freeze this unit chain */

  /* Copy all sectors to target unit */
  targetSectorAddress = unitBaseAddress(&vol,targetUnitNo);
  newSectorCount = 0;

  for (i = 0; i < vol.sectorsPerUnit; i++, virtualSectorNo++,
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
       vol.curSectorWrite++,
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
       targetSectorAddress += SECTOR_SIZE)
  {
     endSectorAddress = ANAND_UNASSIGNED_ADDRESS;
     for(chainBound=0;chainBound<DOUBLE_MAX_UNIT_CHAIN;chainBound++)
     {
        sourceSectorAddress = virtual2Physical(&vol,virtualSectorNo,&endSectorAddress);
        if(sourceSectorAddress == targetSectorAddress)
        {
           /* Sector resides on the last unit of the virtual chain and */
           /* does not need to be copied                               */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
           switch(flVerifyWrite[flSocketNoOf(vol.flash->socket)][vol.flash->socket->curPartition])
           {
              case FL_UPS:
                 newSectorCount++;
                 goto nextSectorLable;

              case FL_OFF:
                 if(vol.verifiedSectorNo > virtualSectorNo)
                 {
                    newSectorCount++;
                    goto nextSectorLable;
                 }
              default: /* FL_ON */
                 break;
           }

           /* Validate the sector has valid EDC/ECC */
           status = vol.flash->read(vol.flash,sourceSectorAddress,nftlBuffer,SECTOR_SIZE,EDC);
           if(status!=flOK)
           {  /* Last sector of chain has EDC errors - can not fold there */
              if(forceFolding!=TRUE)
              {
                 return flCanNotFold;
              }
              else
              {
                 goto nextSectorLable;
              }
           }
           newSectorCount++;
           goto nextSectorLable;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
        }
        else if(sourceSectorAddress != ANAND_UNASSIGNED_ADDRESS)
        {
           /* Check that area is free (ignore flag) */
           if(getSectorFlags(&vol,targetSectorAddress) != SECTOR_FREE)
           {
              if(forceFolding!=TRUE)
              {
                 return flCanNotFold;
              }
              else
              {
                 break;
              }
           }

           /* Copy sector to target sector */
           status = vol.flash->read(vol.flash,sourceSectorAddress,nftlBuffer,SECTOR_SIZE,EDC);
           if (status != flOK) /* Try reading previous sector */
           {
              endSectorAddress = sourceSectorAddress;
              continue;
           }
           status = writeAndCheck(&vol,targetSectorAddress,nftlBuffer,EDC);
           switch (status)
           {
              case flOK:         /* Success */
                 vol.parasiteWrites++;
                 newSectorCount++;
                 goto nextSectorLable;

              case flWriteFault: /* Faild in verify write */
                 if (forceFolding == FALSE)
                    return flCanNotFold;
                 goto nextSectorLable;

              default :          /* Protection error or any other */
                 return status;
           }
        }
        else /* ANAND_UNASSIGNED_ADDRESS - Sector not used */
        {
            goto nextSectorLable;
        }
     }
     return flGeneralFailure;
nextSectorLable:;
  } /* End of copy sector loop */

  /*****************************/
  /* Add unit to virtual chain */
  /*****************************/

  if (newSectorCount > 0) {    /* Some sectors remaining*/
    /* Mark target unit as original */
    if( (setUnitData(&vol,targetUnitNo,virtualUnitNo,ANAND_NO_UNIT) != flOK ) ||
        (partialFoldingFlag == TRUE))
    {
      setUnavail(targetUnitNo);  /* freeze this unit */
    }
    else
    {
      setUnitCount(targetUnitNo,newSectorCount);
    }
    /* Set target unit in virtual unit table */
    vol.virtualUnits[virtualUnitNo] = targetUnitNo;
  }
  else {
    if (unitNo != targetUnitNo) {
/*    If there is a chain to delete ... */
/*    mark unit as completed folding, pending erase */
#ifndef NT5PORT
      unsigned long foldMark = FOLDING_COMPLETE * 0x10001l;
#else /*NT5PORT*/
      foldMark = FOLDING_COMPLETE * 0x10001l;
#endif /*NT5PORT*/

      vol.flash->write(vol.flash,
               unitBaseAddress(&vol,unitNo) + FOLD_MARK_OFFSET,
               &foldMark,
               sizeof foldMark,
               EXTRA);
    }

    vol.virtualUnits[virtualUnitNo] = ANAND_NO_UNIT;
  }

  /* Erase source units */

  return formatChain(&vol,unitNo);

}


/*----------------------------------------------------------------------*/
/*                 c r e a t e U n i t C o u n t                        */
/*                                                                      */
/* Count the number of sectors in a unit that hold valid data.          */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Physical unit number                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void createUnitCount(Anand vol, ANANDUnitNo unitNo)
{
  unsigned int i;
  SectorNo sectorNo;
  CardAddress sectorAddress;
  ANANDUnitNo physicalUnitNo = vol.virtualUnits[unitNo];

  if (physicalUnitNo == ANAND_NO_UNIT)
    return;

  if (!isAvailable(physicalUnitNo))
    return;

  /* Get a count of the valid sector in this unit */
  setUnitCount(physicalUnitNo,0);

  sectorNo = (SectorNo)unitNo * vol.sectorsPerUnit;
  for (i = 0; i < vol.sectorsPerUnit; i++, sectorNo++) {
    sectorAddress = virtual2Physical(&vol,sectorNo,NULL);
    if (sectorAddress != ANAND_UNASSIGNED_ADDRESS) {
      ANANDUnitNo currUnitNo = (ANANDUnitNo)(sectorAddress >> vol.unitSizeBits);
      if (vol.physicalUnits[currUnitNo] & UNIT_REPLACED)
         currUnitNo = physicalUnitNo;
      /* Increament sector count - Assumed EDC OK , was not verified */
      vol.physicalUnits[currUnitNo]++;
    }
  }
}


/*----------------------------------------------------------------------*/
/*                       f o l d B e s t C h a i n                      */
/*                                                                      */
/* Find the best chain to fold and fold it.A good chain to fold is a    */
/* long chain with a small number of sectors that hold valid data.      */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Receives the physical unit no. of the first       */
/*              unit in the chain that was folded.                      */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus foldBestChain(Anand vol, ANANDUnitNo *unitNo)
{
  unsigned     leastCount;
  unsigned     longestChain;
  unsigned     unitCount;
  ANANDUnitNo  virtualUnitNo;
  ANANDUnitNo  u;
  ANANDUnitNo  firstUnitNo;
  unsigned int maxCounter;
  FLStatus     status = flCanNotFold;

  *unitNo = ANAND_NO_UNIT;

  /* Loop as long as can not fold in place or until MAX_FOLDING_TRIES time */

  for (maxCounter = 0 ; maxCounter < MAX_FOLDING_TRIES ; maxCounter++)
  {
     leastCount    = vol.sectorsPerUnit + 1; /* Set to invalid sector count   */
     longestChain  = 0;                      /* Set to invalid unit length    */
     virtualUnitNo = ANAND_NO_UNIT;

     /*************************************************************/
     /* Loop over all virtual units until best candidate is found */
     /*************************************************************/

     for (u = 0; u < vol.noOfVirtualUnits; u++)
      {
       /* If virtual unit does not exist continue to next unit */
       firstUnitNo = vol.virtualUnits[u];
         if( firstUnitNo == ANAND_NO_UNIT )
            continue;

        /* Make sure sector count of unit is valid */
        if (vol.countsValid <= u)
        {
            createUnitCount(&vol,u); /* Update sector count */
            vol.countsValid = u + 1;
        }

        if( isAvailable(firstUnitNo) )     /* store sector count */
        {
           unitCount = countOf(firstUnitNo);
        }
        else
        {
         unitCount         = vol.sectorsPerUnit;    /* set low priority */
        }

        /* This is an empty unit. We can simply erase it */
        if (unitCount == 0)
        {
           leastCount    = 0;
           virtualUnitNo = u;
           break;
        }

        if(/* Smallest sector count found so far */
           (leastCount >= unitCount                       ) &&
           /* And this unit is not a single unit chain  */
           (vol.physicalUnits[firstUnitNo] & UNIT_REPLACED)   )
        {
            unsigned chainLength = 0;

            /* Compare chain length */
            ANANDUnitNo nextUnitNo = getNextUnit(&vol,firstUnitNo,u);
            if(isAvailable(firstUnitNo))
            {
                while((nextUnitNo != ANAND_NO_UNIT        ) &&
                      (chainLength < DOUBLE_MAX_UNIT_CHAIN))
                {
                    chainLength++;
                    nextUnitNo = getNextUnit(&vol,nextUnitNo,u);
                }
            }
            else
            {
                chainLength = 0; /* Set lowest priority to frozen chain */
            }

            /* set low priority to neverending loop chain */
            if(chainLength == DOUBLE_MAX_UNIT_CHAIN)
               chainLength = 0;
            if((leastCount == unitCount ) && (longestChain >= chainLength))
               continue;
            longestChain = chainLength;
            leastCount = unitCount;
            virtualUnitNo = u;
        } /* End - unit has less (or eqaul) no' of used sectors found so far */
     } /* End - Loop over all virtual units and find best candidate */

     /*************************************************************/
     /* Candidate virtual chain has been chosen - try and fold it */
     /*************************************************************/

     if ((leastCount > vol.sectorsPerUnit) ||
         (virtualUnitNo == ANAND_NO_UNIT))
     {
         /* Only single units chains were found */

         if(maxCounter==0) /* And no chain was frozen while searching */
             return flNotEnoughMemory;      /* Report no space at all  */
         break; /* Try and fold the frozen units that have been found */
      }
     else /* Try and fold the candidate unit */
      {
        if(!isAvailable(vol.virtualUnits[virtualUnitNo])) /* This is a frozen unit */
        {
           /* Frozen chains have the lowest priority - stop searching */
             break;
        }
         else                          /* Try and fold the unit */
          {
           /* Store the first unit as the new free unit */
           *unitNo = vol.virtualUnits[virtualUnitNo];
           /* Store number of free Units */
            u = vol.freeUnits;
            /* Fold the candidate unit */
           status = foldUnit(&vol,virtualUnitNo,FALSE);
           switch(status)
           {
              case flOK:
                 if(vol.freeUnits == u) /* Did not free any units */
                    continue;
                 break;
              case flCanNotFold: /* Need to fold not in place */
                 continue;
              default:
                 return status;
           }
           break;
          }
      }
  } /* End MAX_FOLDING_TRIES loop */

  /***************************************************************/
  /* Check folding status - might need a special kind of folding */
  /***************************************************************/

  if(maxCounter)
  {
     *unitNo = ANAND_NO_UNIT;
     /* Unfreeze  all units */
     for (u = vol.spareOrgUnit + 1; u < vol.noOfUnits; u++)
     {
        if(!isAvailable(u)) /* This is a frozen unit */
        {
           /* Get virtual unit of frozen physical unit */
           getUnitData(&vol,u,&virtualUnitNo,&firstUnitNo);
           if(virtualUnitNo < vol.noOfVirtualUnits)
           {
              /* Store the first unit as the new free unit */
              firstUnitNo = vol.virtualUnits[virtualUnitNo];
              /* Force folding no matter what */
              if(firstUnitNo != ANAND_NO_UNIT)
              {
                 checkStatus(foldUnit(&vol,virtualUnitNo,TRUE));
                 /* Recalculate sector count */
                 createUnitCount(&vol, virtualUnitNo);
                 *unitNo = firstUnitNo;
              }
           }
        }
     }
  }
  if((*unitNo!= ANAND_NO_UNIT) &&  (vol.freeUnits > 0)) /* A unit was freed */
     return flOK;
  else
     return flGeneralFailure;
}


/*----------------------------------------------------------------------*/
/*                       a l l o c a t e U n i t                        */
/*                                                                      */
/* Find a free unit to allocate, erase it if necessary.                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*     unitNo        : Receives the physical number of the allocated    */
/*              unit                                                    */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus allocateUnit(Anand vol, ANANDUnitNo *unitNo)
{
  ANANDUnitNo originalUnit = vol.roverUnit;
  FLStatus status;

  if (vol.freeUnits < 2) /* Try to make sure not to use the last unit */
  {
     status = foldBestChain(&vol,unitNo);
     if(status != flNotEnoughMemory)
         return status;
  }

  return findFreeUnit(&vol, unitNo);
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                       m a p S e c t o r                              */
/*                                                                      */
/* Maps and returns location of a given sector no.                      */
/* NOTE: This function is used in place of a read-sector operation.     */
/*                                                                      */
/* A one-sector cache is maintained to save on map operations.          */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : Sector no. to read                                  */
/*    physAddress    : Optional pointer to receive sector address       */
/*                                                                      */
/* Returns:                                                             */
/*    Pointer to physical sector location. NULL returned if sector      */
/*    does not exist.                                                   */
/*----------------------------------------------------------------------*/

static const void FAR0 *mapSector(Anand vol, SectorNo sectorNo, CardAddress *physAddress)
{
  if (sectorNo != vol.mappedSectorNo || vol.flash->socket->remapped)
  {
    if (sectorNo >= vol.virtualSectors)
    {
      vol.mappedSector = NULL;
    }
    else
    {
       int chainBound = 0;

       for(vol.mappedSectorAddress=ANAND_UNASSIGNED_ADDRESS;
           chainBound<DOUBLE_MAX_UNIT_CHAIN;chainBound++)
       {
           CardAddress endSectorAddress = vol.mappedSectorAddress;
           vol.mappedSectorAddress = virtual2Physical(&vol,sectorNo,&endSectorAddress);

           if (vol.mappedSectorAddress == ANAND_UNASSIGNED_ADDRESS)
           {
              vol.mappedSector = NULL;    /* no such sector */
              break;
           }
           else
           {
              vol.mappedSector = nftlBuffer;
              if (vol.flash->read(vol.flash,vol.mappedSectorAddress,nftlBuffer,SECTOR_SIZE,EDC) == flOK)
                 break;
           }
       }
       vol.mappedSectorNo = sectorNo;
       vol.flash->socket->remapped = FALSE;
    }
  }
  if (physAddress)
    *physAddress = vol.mappedSectorAddress;

  return vol.mappedSector;
}


/* Mounting and formatting */

/*----------------------------------------------------------------------*/
/*                   m o u n t U n i t                                  */
/*                                                                      */
/* Mount one unit. Read the relevant data from the unit header and      */
/* update the conversion tables.                                        */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : Unit to mount                                     */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus mountUnit(Anand vol, ANANDUnitNo unitNo,
                          unsigned long* eraseCount)
{
  ANANDUnitNo virtualUnitNo, replacementUnitNo;
  unsigned short eraseMark;
  ANANDPhysUnit FAR1 *pU = &vol.physicalUnits[unitNo];

  getUnitData(&vol,unitNo,&virtualUnitNo,&replacementUnitNo);
  getUnitTailer(&vol,unitNo,&eraseMark,eraseCount);

  if (virtualUnitNo == ANAND_NO_UNIT ||
      eraseMark != ERASE_MARK) {  /* this unit is not assigned */
    *pU = ANAND_UNIT_FREE;
  }
  else {  /* this unit is assigned */
    *pU &= UNIT_ORPHAN;
    if (replacementUnitNo < vol.noOfUnits) {
      *pU |= UNIT_REPLACED;
      if (isAvailable(replacementUnitNo) ||
      isReplaced(replacementUnitNo))
    /* Mark replacement unit as non-orphan */
    vol.physicalUnits[replacementUnitNo] &= ~UNIT_ORPHAN;
    }
    if (!(virtualUnitNo & ANAND_REPLACING_UNIT)) {
      unsigned short foldMark;
      ANANDUnitNo physUnitNo;

      if (virtualUnitNo >= vol.noOfVirtualUnits)
        return formatUnit(&vol,unitNo);

      foldMark = getFoldMark(&vol,unitNo);
      physUnitNo = vol.virtualUnits[virtualUnitNo];
      if (foldMark == FOLDING_COMPLETE)
    formatChain(&vol,unitNo);
      else if (physUnitNo == ANAND_NO_UNIT || !isAvailable(physUnitNo)) {
    /* If we have duplicates, it's OK if one of them is currently folded */
    vol.virtualUnits[virtualUnitNo] = unitNo;
    *pU &= ~UNIT_ORPHAN;

    if (foldMark == FOLDING_IN_PROGRESS) {
          setUnavail(unitNo);
    }
    if (physUnitNo != ANAND_NO_UNIT)
      formatChain(&vol,physUnitNo);    /* Get rid of old chain */
      }
      else if (foldMark == FOLDING_IN_PROGRESS)
    formatChain(&vol,unitNo);
      else
    return flBadFormat;    /* We have a duplicate to a unit that */
                /* is not currently folded. That's bad. */
    }
  }

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*               a l l o c a t e A n d W r i t e S e c t o r            */
/*                                                                      */
/* Write to sectorNo. if necessary, allocate a free sector first.       */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : Virtual sector no. to write                         */
/*    fromAddress    : Address of sector data.                          */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus allocateAndWriteSector(void* rec,
                     SectorNo sectorNo,
                     void FAR1 *fromAddress)
{
  Anand vol = (Anand*)rec;
  ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo / vol.sectorsPerUnit);
  ANANDUnitNo firstUnitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo unitNo;
  unsigned  unitOffset = (unsigned)((sectorNo % vol.sectorsPerUnit) << SECTOR_SIZE_BITS);
  unsigned  unitChainLength = 0;
  FLBoolean sectorExists = FALSE;
  FLBoolean unitWasFoldedOutOfPlace = FALSE;
  FLStatus  status;

  /* If we can't write to this unit, must fold it first */
  if (firstUnitNo != ANAND_NO_UNIT && !isAvailable(firstUnitNo)) {
    status = foldUnit(&vol,virtualUnitNo,FALSE);
    switch(status)
    {
       case  flOK:
          break;
       case  flCanNotFold:
          checkStatus(checkFolding(&vol,virtualUnitNo));
          break;
       default:
          return status;
    }
    firstUnitNo = vol.virtualUnits[virtualUnitNo];
  }

  /* Find a unit to write this sector */

  unitNo = firstUnitNo;
  while ((unitNo != ANAND_NO_UNIT) && (unitChainLength < DOUBLE_MAX_UNIT_CHAIN)) {
    unsigned char sectorFlags = getSectorFlags(&vol,unitBaseAddress(&vol,unitNo) + unitOffset);
    if (sectorFlags == SECTOR_FREE)
      break;
    if (sectorFlags != SECTOR_IGNORE)
      sectorExists = sectorFlags == SECTOR_USED;
    unitNo = getNextUnit(&vol,unitNo,virtualUnitNo);
    unitChainLength++;
  }

  if (unitChainLength == DOUBLE_MAX_UNIT_CHAIN) { /* unit points to itself */
    unitNo = ANAND_NO_UNIT;                  /* force folding not in place */
    setUnavail(firstUnitNo);
  }

  if (unitNo == ANAND_NO_UNIT) { /* Can not write in chain - must add a unit */
    firstUnitNo = vol.virtualUnits[virtualUnitNo];
    if (unitChainLength >= MAX_UNIT_CHAIN)
    {
      status = foldUnit(&vol,virtualUnitNo,FALSE);
      switch(status)
      {
         case  flOK:
            break;
         case  flCanNotFold:
            checkStatus(checkFolding(&vol,virtualUnitNo));
            break;
         default:
            return status;
      }
    }
    if(vol.virtualUnits[virtualUnitNo] != firstUnitNo)
    {
       firstUnitNo = vol.virtualUnits[virtualUnitNo];
       unitWasFoldedOutOfPlace = TRUE;
    }
    checkStatus(allocateUnit(&vol,&unitNo));
    checkStatus(assignUnit(&vol,unitNo,virtualUnitNo));
    if(vol.virtualUnits[virtualUnitNo] != firstUnitNo)
    {
       firstUnitNo = vol.virtualUnits[virtualUnitNo];
       unitWasFoldedOutOfPlace = TRUE;
    }
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
    /* Folding might have discovered that the sector we are using is invalid */
    if(sectorExists) {
       if( unitWasFoldedOutOfPlace ) {
          /* Unit was folded out of place, so if sector exists it must be in
           * the first unit of the chain
           */
          if(getSectorFlags(&vol,unitBaseAddress(&vol,firstUnitNo) + unitOffset)
             != SECTOR_USED) {
             /* The sector we saw before had bad EDC */
             sectorExists = FALSE;
             unitNo = firstUnitNo;
          }
       }
    }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  }

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  vol.curSectorWrite = sectorNo;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  checkStatus(writeAndCheck(&vol,unitBaseAddress(&vol,unitNo) + unitOffset,fromAddress,EDC));

  if (vol.countsValid > virtualUnitNo) {
    if (unitNo != firstUnitNo && !(vol.physicalUnits[unitNo] & UNIT_REPLACED)) {
      if (countOf(unitNo) < UNIT_MAX_COUNT)    /* Increment block count */
         vol.physicalUnits[unitNo]++;
      else
         return flGeneralFailure;

      if (sectorExists)    /* Decrement block count */
      {
         if (countOf(firstUnitNo) > 0)
            vol.physicalUnits[firstUnitNo]--;
         else
            return flGeneralFailure;
      }
    }
    else if (!sectorExists) {
      if (countOf(firstUnitNo) < UNIT_MAX_COUNT)  /* Increment block count */
         vol.physicalUnits[firstUnitNo]++;
      else
    return flGeneralFailure;
    }
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                         w r i t e S e c t o r                        */
/*                                                                      */
/* Writes a sector.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : Virtual sector no. to write                         */
/*    fromAddress    : Data to write                                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus writeSector(Anand vol, SectorNo sectorNo, void FAR1 *fromAddress)
{
  FLStatus status = flWriteFault;
  int i;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo >= vol.virtualSectors)
    return flSectorNotFound;

  if(vol.wearLevel.currUnit!=ANAND_NO_UNIT) {
    vol.wearLevel.alarm++;
    if(vol.wearLevel.alarm>=WLnow) {
      vol.wearLevel.alarm = 0;
      checkStatus(swapUnits(&vol));
    }
  }

  if (sectorNo == vol.mappedSectorNo)
  {
    /* Force remapping of internal catched sector */
    vol.flash->socket->remapped = TRUE;
  }

  vol.sectorsWritten++;
  for (i = 0; i < 4 && status == flWriteFault; i++) {
    if (vol.mappedSectorNo == sectorNo)
      vol.mappedSectorNo = UNASSIGNED_SECTOR;
    status = allocateAndWriteSector(&vol,sectorNo,fromAddress);
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*                   d e l e t e S e c t o r                            */
/*                                                                      */
/* Marks contiguous sectors as deleted.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorNo    : First sector no. to delete                          */
/*    noOfSectors    : No. of sectors to delete                         */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus deleteSector(Anand vol, SectorNo sectorNo, SectorNo noOfSectors)
{
  SectorNo iSector;
  FLStatus status;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo + noOfSectors > vol.virtualSectors)
    return flSectorNotFound;

  for (iSector = 0; iSector < noOfSectors; iSector++, sectorNo++,
       vol.sectorsDeleted++) {

    CardAddress sectorAddress = virtual2Physical(&vol,sectorNo,NULL);
    if (sectorAddress != ANAND_UNASSIGNED_ADDRESS) {
      byte sectorFlags[2];
      ANANDUnitNo currUnitNo;

      /* Check that the unit is writable, and if not, fold it first */
      ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo / vol.sectorsPerUnit);
      ANANDUnitNo unitNo = vol.virtualUnits[virtualUnitNo];
      if (!isAvailable(unitNo)) {
         status = foldUnit(&vol,virtualUnitNo,FALSE);
         switch(status)
         {
            case  flOK:
               break;
            case  flCanNotFold:
               checkStatus(checkFolding(&vol,virtualUnitNo));
               break;
            default:
               return status;
         }
         sectorAddress = virtual2Physical(&vol,sectorNo,NULL);
      }

      /* Mark sector deleted */
      sectorFlags[0] = sectorFlags[1] = SECTOR_DELETED;
#ifdef NFTL_CACHE
      setSectorFlagsCache(&vol, sectorAddress, SECTOR_DELETED);
#ifdef ENVIRONMENT_VARS
      if (((flMarkDeleteOnFlash == FL_ON) &&
       (flPolicy[vol.socketNo][vol.flash->socket->curPartition]  != FL_COMPLETE_ASAP)) ||
      (vol.scache == NULL))
#endif /* ENVIRONMENT_VARS */
#endif
     vol.flash->write(vol.flash,
             sectorAddress + SECTOR_DATA_OFFSET,

#ifndef NT5PORT
             &sectorFlags,
#else /*NT5PORT*/
             sectorFlags,
#endif /*NT5PORT*/

             sizeof sectorFlags,
             EXTRA);

      currUnitNo = (ANANDUnitNo)(sectorAddress >> vol.unitSizeBits);
      if ( isAvailable(currUnitNo) ) {
         if (vol.physicalUnits[currUnitNo] & UNIT_REPLACED)
            currUnitNo = vol.virtualUnits[virtualUnitNo];
         if (vol.countsValid > virtualUnitNo) {
            if (countOf(currUnitNo) > 0)
               vol.physicalUnits[currUnitNo]--; /* Decrement block count */
            else
               return flGeneralFailure;
         }
      }
    }
  }

  return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                    t l S e t B u s y                                 */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*      state        : FL_ON (1) = operation entry                      */
/*                      FL_OFF(0) = operation exit                      */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus tlSetBusy(Anand vol, FLBoolean state)
{
  return flOK;
}

#ifndef FL_READ_ONLY

#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                      d e f r a g m e n t                             */
/*                                                                      */
/* Performs unit allocations to arrange a minimum number of writable    */
/* sectors.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    sectorsNeeded    : Minimum required sectors                       */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus defragment(Anand vol, long FAR2 *sectorsNeeded)
{
  ANANDUnitNo dummyUnitNo, firstFreeUnit = ANAND_NO_UNIT;
  FLBoolean firstRound = TRUE;
  FLStatus status = flOK;

  if( (*sectorsNeeded) == -1 ) { /* fold single chain */
    if (vol.badFormat)
      return flBadFormat;

    status = foldBestChain(&vol,&dummyUnitNo);
    if( (status != flOK) && (vol.freeUnits == 0) )
      return status;
    *sectorsNeeded = vol.freeUnits * vol.sectorsPerUnit;
    return flOK;
  }
  while ((SectorNo)vol.freeUnits * vol.sectorsPerUnit < ((SectorNo)(*sectorsNeeded))) {
    if (vol.badFormat)
      return flBadFormat;

    status = allocateUnit(&vol,&dummyUnitNo);
    if( status != flOK )
      break;
    if (firstRound) {              /* remember the first free unit */
      firstFreeUnit = dummyUnitNo;
      firstRound = FALSE;
    }
    else if (firstFreeUnit == dummyUnitNo) {
      /* We have wrapped around, all the units that were marked as free  */
      /* are now erased, and we still don't have enough space.           */
      status = foldBestChain(&vol,&dummyUnitNo); /* make more free units */
      if( status != flOK )
        break;
    }
  }

  *sectorsNeeded = (long)vol.freeUnits * vol.sectorsPerUnit;

  return status;
}

#endif /* DEFRAGMENT_VOLUME */
#endif /* FL_READ_ONLY */


/*----------------------------------------------------------------------*/
/*                  s e c t o r s I n V o l u m e                       */
/*                                                                      */
/* Gets the total number of sectors in the volume                       */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    Number of sectors in the volume                                   */
/*----------------------------------------------------------------------*/

static SectorNo sectorsInVolume(Anand vol)
{
  return vol.virtualSectors;
}

/*----------------------------------------------------------------------*/
/*                   d i s m o u n t N F T L                            */
/*                                                                      */
/* Dismount NFTL volume                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void dismountNFTL(Anand vol)
{
#ifdef FL_MALLOC
  if( vol.physicalUnits != NULL )
    FL_FAR_FREE (vol.physicalUnits);
  if( vol.virtualUnits != NULL )
    FL_FAR_FREE (vol.virtualUnits);
  vol.physicalUnits = NULL;
  vol.virtualUnits = NULL;

#ifdef NFTL_CACHE
  if( vol.ucache != NULL )
    FL_FAR_FREE (vol.ucache);
  if( vol.scache != NULL )
    FL_FAR_FREE (vol.scache);
  vol.ucache = NULL;
  vol.scache = NULL;
#endif /* NFTL_CACHE */
#endif /* FL_MALLOC */
}


Anand* getAnandRec(unsigned driveNo)
{
  return (&vols[driveNo]);
}


#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                         i s E r a s e d U n i t                      */
/*                                                                      */
/* Check if a unit is erased.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive                            */
/*    unitNo        : unit to check                                     */
/*                                                                      */
/* Returns:                                                             */
/*    TRUE if unit is erased, FALSE otherwise                           */
/*----------------------------------------------------------------------*/

static FLBoolean isErased(Anand vol, ANANDUnitNo unitNo)
{

  CardAddress addr;
  CardAddress endAddr;
  word        offset;

  /* Force remapping of internal catched sector */
  vol.flash->socket->remapped = TRUE;
  addr    = unitBaseAddress(&vol,unitNo);
  endAddr = addr + (1L << vol.unitSizeBits);

  for (;addr < endAddr; addr += SECTOR_SIZE)
  {

    /* Check area a and b */

    vol.flash->read(vol.flash, addr, nftlBuffer,SECTOR_SIZE, 0);
    for (offset=0;offset<SECTOR_SIZE;offset+=ANAND_SPARE_SIZE)
       if (tffscmp(nftlBuffer+offset, ff, ANAND_SPARE_SIZE))
          return FALSE;

    /* Check area c */

    vol.flash->read(vol.flash, addr, nftlBuffer,ANAND_SPARE_SIZE, EXTRA);
    if (tffscmp( nftlBuffer, ff, ANAND_SPARE_SIZE ))
      return FALSE;
  }
  return TRUE;
}

/*----------------------------------------------------------------------*/
/*                      f o r m a t    N F T L                          */
/*                                                                      */
/* Perform NFTL Format.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo        : Volume serial no.                                  */
/*    formatParams    : Address of FormatParams structure to use        */
/*    flash        : Flash media mounted on this socket                 */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus formatNFTL(unsigned volNo, TLFormatParams *formatParams, FLFlash *flash)
{
  Anand vol = &vols[volNo];
  long int unitSize;
  unsigned long prevVirtualSize;
  ANANDUnitNo iUnit, prevOrgUnit;
  ANANDUnitNo noOfBootUnits=0;
  ANANDBootRecord bootRecord;
  int noOfBadUnits = 0;
  FLStatus status = flOK;
  FLBoolean forceHeaderUpdate = FALSE;
  static unsigned char checkSum[EXTRA_LEN] =
       { 0x4B, 0x00, 0xE2, 0x0E, 0x93, 0xF7, 0x55, 0x55 };
#ifdef EXTRA_LARGE
  int moreUnitBits;
  unsigned char anandFlagsTmp;
#endif /* EXTRA_LARGE */

  DEBUG_PRINT(("Debug: starting NFTL format.\r\n"));

  checkStatus(initNFTL(&vol,flash));

  tffsset(&bootRecord,0,sizeof(ANANDBootRecord));

  /* Find the medium boot record */
  for (vol.orgUnit = 0; vol.orgUnit < vol.noOfUnits; vol.orgUnit++)
  {
    vol.flash->read(vol.flash,
           unitBaseAddress(&vol,vol.orgUnit),
           &bootRecord,
           sizeof bootRecord,
           0);
    if (tffscmp(bootRecord.bootRecordId,"ANAND",sizeof bootRecord.bootRecordId) == 0)
       break;
  }

#ifdef EXTRA_LARGE
  if (vol.orgUnit >= vol.noOfUnits) {    /* first time formatting */
    bootRecord.anandFlags = 0xFF;
    moreUnitBits = 0;
    while( ((vol.noOfUnits >> moreUnitBits) > 4096) &&
       ((vol.unitSizeBits + moreUnitBits) < MAX_UNIT_SIZE_BITS) &&
       (bootRecord.anandFlags > 0xFC) ) {
      moreUnitBits++;
      bootRecord.anandFlags--;
    }
  }

  moreUnitBits = ~bootRecord.anandFlags & MORE_UNIT_BITS_MASK;
  if (moreUnitBits > 0) {
    vol.unitSizeBits += moreUnitBits;
    vol.noOfUnits >>= moreUnitBits;
    vol.orgUnit >>= moreUnitBits;
  }
#endif /* EXTRA_LARGE */

  /* adjust number of boot area units include the EXB area */

  if (formatParams->flags & FL_LEAVE_BINARY_AREA)
  {
     /* Leave binary area (except for the area between the old
        original unit and the new one */
     if (formatParams->bootImageLen >= 0)
     {
        noOfBootUnits += (ANANDUnitNo)((formatParams->bootImageLen - 1) >> vol.unitSizeBits) + 1;
     }
     else /* Leave binary area excatly as it was */
     {
    if (vol.orgUnit >= vol.noOfUnits)  /* first time formatting */
        {
           noOfBootUnits = 0;
        }
        else
        {
       if (LE2(bootRecord.bootUnits) > noOfBootUnits )
          noOfBootUnits = LE2(bootRecord.bootUnits);
        }
     }
  }
  else /* Actualy format binary area with a signature */
  {
#ifdef WRITE_EXB_IMAGE
     if (formatParams->exbLen > 0)
     {
        noOfBootUnits = (ANANDUnitNo)((formatParams->exbLen - 1)
                        >> vol.unitSizeBits) + 1;
        formatParams->exbLen = noOfBootUnits;
     }
     else
     {
        formatParams->exbLen = 0;
     }
#endif /* WRITE_EXB_IMAGE */

     if(formatParams->noOfBinaryPartitions > 0)
     {
        noOfBootUnits += (ANANDUnitNo)((formatParams->binaryPartitionInfo
                         ->length - 1) >> vol.unitSizeBits) + 1;
     }
  }
  prevOrgUnit = vol.orgUnit;           /* save previous Original Unit */
  prevVirtualSize = UNAL4(bootRecord.virtualMediumSize);
  vol.bootUnits = noOfBootUnits;
  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  /* Add 'percentUse'% of bootUnits to transfer units */
  formatParams->percentUse -= (unsigned)(((long)(100 - formatParams->percentUse) * (vol.bootUnits)) / (vol.noOfUnits - vol.bootUnits));

  vol.noOfTransferUnits = (ANANDUnitNo)formatParams->noOfSpareUnits;

  vol.noOfTransferUnits += (ANANDUnitNo)((long)(vol.noOfUnits - vol.bootUnits) *
                 (100 - formatParams->percentUse) / 100);

  if (vol.noOfUnits <= vol.bootUnits + vol.noOfTransferUnits)
    return flVolumeTooSmall;

  unitSize = 1L << vol.unitSizeBits;
  vol.noOfVirtualUnits = vol.noOfUnits-vol.bootUnits;

  checkStatus(initTables(&vol));

  for (iUnit = 0; iUnit < (vol.noOfUnits-vol.bootUnits); iUnit++)
    vol.virtualUnits[iUnit] = ANAND_NO_UNIT;


  if (vol.orgUnit >= vol.noOfUnits)
  {
    /* no boot record - virgin card, scan it for bad blocks */
    DFORMAT_PRINT(("Virgin card rebuilding unit map.\r\n"));
    prevVirtualSize = 0L;
    tffsset(ff,0xff,ANAND_SPARE_SIZE);

        /* Generate the bad unit table */
    /* if a unit is not erased it is marked as bad */
    for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
    {
      vol.physicalUnits[iUnit] = (unsigned char)(isErased(&vol,iUnit) ? ANAND_UNIT_FREE : UNIT_BAD_ORIGINAL);
#ifndef NT5PORT
      DFORMAT_PRINT(("Checking unit %ld\r",(CardAddress)iUnit));
#endif/*NT5PORT*/
    }
    DFORMAT_PRINT(("\rMedia has been scanned\r\n"));
  }
  else /* Read bad unit table from boot record */
  {
    status = vol.flash->read(vol.flash,
                   unitBaseAddress(&vol,vol.orgUnit) + SECTOR_SIZE,
                   vol.physicalUnits,
                   vol.noOfUnits * sizeof(ANANDPhysUnit),
                   EDC);
    if( status != flOK ) {
      dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
      return status;
    }
  }

  if(vol.physicalUnits[0] == UNIT_BAD_ORIGINAL)
  {
     DFORMAT_PRINT(("ERROR - IPL block is bad.\r\n"));
     return flBadIPLBlock;
  }

  /*  count bad units */
  vol.noOfTransferUnits += 2;           /* include orgUnit & spareOrgUnit */

  /* Convert first unit of MDOC of any floor > 0 to BAD in order to make it
   *  unchangeable and force internal EEprom mode  */
  if(flash->flags & EXTERNAL_EPROM)
  {
    long docFloorSize;
    int  iFloor, iPage;

    docFloorSize = (flash->chipSize * flash->noOfChips) / flash->noOfFloors;

    for(iFloor=1;( iFloor < flash->noOfFloors ); iFloor++)
    {
      iUnit = (ANANDUnitNo)((docFloorSize * (long)iFloor) >> vol.unitSizeBits);
      if( vol.physicalUnits[iUnit] == ANAND_UNIT_FREE )
      {
         forceHeaderUpdate = TRUE;           /* force writing of NFTL Header */
         vol.physicalUnits[iUnit] = UNIT_BAD_ORIGINAL; /* mark as BAD */
      }
      status = vol.flash->erase(vol.flash,
               (word)(iUnit << (vol.unitSizeBits - vol.erasableBlockSizeBits)),
                 (word)(1 << (vol.unitSizeBits - vol.erasableBlockSizeBits)));
      if( status != flOK ) {
        dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
      }

      for(iPage=0;( iPage < 2 ); iPage++) {
        status = vol.flash->write(vol.flash,
               unitBaseAddress(&vol,iUnit) + iPage * SECTOR_SIZE,
           (const void FAR1 *)checkSum, EXTRA_LEN, EXTRA);
        if( status != flOK ) {
          dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
          return status;
        }
      }
    }
  }

  /* Translate physicalUnits[] to internal representation */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    if (vol.physicalUnits[iUnit] != ANAND_UNIT_FREE)
      vol.physicalUnits[iUnit] = UNIT_BAD_MOUNT;
  }

  /* extend bootimage area if there are bad units in it */
  for( iUnit = vol.bootUnits = 0;
       (vol.bootUnits < noOfBootUnits)  &&  (iUnit < vol.noOfUnits);
       iUnit++ )
    if (isAvailable(iUnit))
      vol.bootUnits++;

  if (vol.bootUnits < noOfBootUnits) {
    dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
    return flVolumeTooSmall;
  }

  vol.bootUnits = iUnit;

  /* Discount transfer units taken by the boot image */
  for (iUnit = 0; iUnit < vol.bootUnits; iUnit++)
    if (!isAvailable(iUnit)) {
      if( vol.noOfTransferUnits <= (ANANDUnitNo)formatParams->noOfSpareUnits ) {
        dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return flVolumeTooSmall;
      }
      vol.noOfTransferUnits--;
    }
    if (vol.noOfUnits <= vol.bootUnits + vol.noOfTransferUnits) {
    dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
    return flVolumeTooSmall;
  }

  vol.virtualSectors = (SectorNo)((vol.noOfUnits - vol.bootUnits - vol.noOfTransferUnits) *
               (unitSize / SECTOR_SIZE));
  vol.noOfVirtualUnits = (unsigned short)((vol.virtualSectors + vol.sectorsPerUnit - 1) / vol.sectorsPerUnit);

  /* Find a place for the boot records and protect them */
  /* NOTE : We don't erase the old orgUnits, this might cause a problem
     when formatting with bootImageLen = 0 and then formatting with
     bootImageLen = 44Kbyte */
  for (vol.orgUnit = vol.bootUnits; vol.orgUnit < vol.noOfUnits; vol.orgUnit++)
    if (vol.physicalUnits[vol.orgUnit] == ANAND_UNIT_FREE)
      break;
  vol.physicalUnits[vol.orgUnit] = UNIT_UNAVAIL;
  for (vol.spareOrgUnit = vol.orgUnit + 1;
       vol.spareOrgUnit < vol.noOfUnits;
       vol.spareOrgUnit++)
    if (vol.physicalUnits[vol.spareOrgUnit] == ANAND_UNIT_FREE)
      break;
  vol.physicalUnits[vol.spareOrgUnit] = UNIT_UNAVAIL;

  for (iUnit = vol.bootUnits; iUnit < vol.noOfUnits; iUnit++)
  {
    status = formatUnit(&vol,iUnit);
    if(status == flWriteFault)
    {
      if ((iUnit != vol.orgUnit) && (iUnit != vol.spareOrgUnit))
      {
    noOfBadUnits++;
    vol.physicalUnits[iUnit] = UNIT_BAD_MOUNT;  /* Mark it bad in table */
    if ((noOfBadUnits+2) >= vol.noOfTransferUnits)
    {
      dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
      return status;
    }
      }
    }
    else if (status != flOK)
    {
      dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
      return status;
    }

    if (formatParams->progressCallback)
    {
      status = (*formatParams->progressCallback)
          ((word)(vol.noOfUnits - vol.bootUnits),
           (word)((iUnit + 1) - vol.bootUnits));
      if(status!=flOK)
      {
    dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
      }
    }
  }

  /* Prepare the boot record header */
  for(iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {  /* Convert Bad Block table to previous state */
    if( vol.physicalUnits[iUnit] == UNIT_BAD_MOUNT )
      vol.physicalUnits[iUnit] = UNIT_BAD_ORIGINAL;
  }
#ifdef EXTRA_LARGE
  anandFlagsTmp = bootRecord.anandFlags;
#endif /* EXTRA_LARGE */
  tffsset(&bootRecord,0xff,sizeof bootRecord);
#ifdef EXTRA_LARGE
  bootRecord.anandFlags = anandFlagsTmp;
#endif /* EXTRA_LARGE */
  toLE2(bootRecord.noOfUnits,vol.noOfUnits - vol.bootUnits);
  toLE2(bootRecord.bootUnits,vol.bootUnits);
  tffscpy(bootRecord.bootRecordId,"ANAND",sizeof bootRecord.bootRecordId);
  toUNAL4(bootRecord.virtualMediumSize,(CardAddress) vol.virtualSectors * SECTOR_SIZE);

  /* Write boot records, spare unit first */
  vol.physicalUnits[vol.orgUnit] = ANAND_UNIT_FREE;    /* Unprotect it */
  vol.physicalUnits[vol.spareOrgUnit] = ANAND_UNIT_FREE;    /* Unprotect it */

  if( ((prevOrgUnit != vol.orgUnit) || (forceHeaderUpdate == TRUE)) ||
      (prevVirtualSize != UNAL4(bootRecord.virtualMediumSize)) )
  {
     /* Copy boot Record to 512 bytes buffer in order to add EDC */
     tffsset(nftlBuffer,0,sizeof nftlBuffer);
     tffscpy(nftlBuffer,&bootRecord,sizeof bootRecord);

     /* Loop over the original unit and the spare (spare first) */
     for (iUnit = vol.spareOrgUnit, prevOrgUnit = 0;
        prevOrgUnit < 2 ; prevOrgUnit ++)
     {
        status = formatUnit(&vol,iUnit);    /* Erase unit */

        if(status==flOK)     /* Write BBT */
        {
           status = vol.flash->write(vol.flash,
              unitBaseAddress(&vol,iUnit) + SECTOR_SIZE,
              vol.physicalUnits,
              vol.noOfUnits * sizeof(ANANDPhysUnit), EDC);
        }

        if(status==flOK)    /* Write header */
        {
           status = vol.flash->write(vol.flash,
                    unitBaseAddress(&vol,iUnit),
                    nftlBuffer, sizeof (nftlBuffer), EDC);
        }

        if(status!=flOK)
        {
           dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
           return status;
        }
        iUnit = vol.orgUnit;
     }
  }

  /* Mark Binary partition with the proper signature */

  if (!(formatParams->flags & FL_LEAVE_BINARY_AREA)&&
       (vol.bootUnits > 0))
  {
     byte sign[BINARY_SIGNATURE_LEN];

     /* Add SPL special Signature */

#ifdef WRITE_EXB_IMAGE
     byte signOffset = 8;
     tffscpy(sign,SIGN_SPL,BINARY_SIGNATURE_NAME);
#else
     byte signOffset = formatParams->binaryPartitionInfo->signOffset;
     tffscpy(sign,formatParams->binaryPartitionInfo->sign,
              BINARY_SIGNATURE_NAME);
#endif /* WRITE_EXB_IMAGE */

     tffsset(sign+BINARY_SIGNATURE_NAME,'F',BINARY_SIGNATURE_NAME);
     unitSize = 1L << vol.unitSizeBits;

     for (iUnit=0;iUnit<vol.bootUnits;iUnit++)
     {
        if ( vol.physicalUnits[iUnit] == ANAND_UNIT_FREE )
        {
           status = formatUnit(&vol,iUnit);
           if(status != flOK)
              break;

#ifdef WRITE_EXB_IMAGE
           if (iUnit == formatParams->exbLen)
           {
              signOffset = formatParams->binaryPartitionInfo->signOffset;
              tffscpy(sign,formatParams->binaryPartitionInfo->sign,
              BINARY_SIGNATURE_NAME);
           }
#endif /* WRITE_EXB_IMAGE */
       /* Each logical unit might contain several physical blocks */
           for (noOfBootUnits = 0 ;
               (noOfBootUnits < unitSize) && (status == flOK) ;
               noOfBootUnits += (ANANDUnitNo)vol.flash->erasableBlockSize)
           {
              status = vol.flash->write(vol.flash, unitBaseAddress(&vol,iUnit) +
              noOfBootUnits + signOffset, sign,
              BINARY_SIGNATURE_LEN,EXTRA);
           }
           if(status != flOK)
              break;
        }
#ifdef WRITE_EXB_IMAGE
       else
       {
           formatParams->exbLen++;
       }
#endif /* WRITE_EXB_IMAGE */
     }
  }
  else /* Erase previous Original and SpareOriginal Unit */
  {
     for (iUnit = prevOrgUnit; iUnit < vol.orgUnit; iUnit++)
       if( vol.physicalUnits[iUnit] != UNIT_BAD_ORIGINAL )
     formatUnit(&vol,iUnit);
  }

  if (status != flOK)
  {
     DEBUG_PRINT(("Debug: NFTL failed while formating the binary partition.\r\n"));
  }
  else
  {
     DEBUG_PRINT(("Debug: finished NFTL format.\r\n"));
  }

  dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
  return status;
}

#endif /* FORMAT_VOLUME */

/*----------------------------------------------------------------------*/
/*                      N F T L I n f o                                 */
/*                                                                      */
/* get NFTL information.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*  volNo       : Volume serial no.                                     */
/*  tlInfo      : Address of TLInfo record                              */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise                        */
/*----------------------------------------------------------------------*/

static FLStatus  NFTLInfo(Anand vol, TLInfo *tlInfo)
{
  tlInfo->sectorsInVolume = vol.virtualSectors;
  tlInfo->bootAreaSize    = (unsigned long)vol.bootUnits << vol.unitSizeBits;
  tlInfo->eraseCycles     = vol.eraseSum;
  tlInfo->tlUnitBits      = vol.unitSizeBits;
  return flOK;
}

#ifndef NO_READ_BBT_CODE

/*----------------------------------------------------------------------*/
/*                      r e a d B B T                                   */
/*                                                                      */
/* Returns a pointer to the BBT of the device.                          */
/* Note: Bad unit are marked with a 4 bytes address of the unit.        */
/* Note: A unit can contain several blocks                              */
/*                                                                      */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive                                 */
/*  buf     : pointer to buffer to read into                            */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise                        */
/*  noOfBB      : returns the number of bad unit of the media           */
/*  meidaSize   : returns the media size in bytes                       */
/*----------------------------------------------------------------------*/
static FLStatus  readBBT(Anand vol, CardAddress FAR1 * buf,
               long FAR2 * mediaSize, unsigned FAR2 * noOfBB)
{
   ANANDUnitNo iUnit;
   ANANDUnitNo maxBad = vol.noOfUnits * ANAND_BAD_PERCENTAGE / 100;
   CardAddress FAR1* ptr = (CardAddress FAR1*) buf;

   *noOfBB = 0;

   for (iUnit=0;(iUnit<vol.noOfUnits);iUnit++)
   {
      if (vol.physicalUnits[iUnit] == UNIT_BAD_MOUNT)
      {
         if (*noOfBB <= maxBad)
         {
            *ptr = (CardAddress) iUnit << vol.unitSizeBits;
            (*noOfBB)++;
            ptr = (CardAddress FAR1*)flAddLongToFarPointer((byte FAR1 *)ptr,
                                     sizeof(CardAddress));
         }
         else
         {
            DEBUG_PRINT(("Debug: ERROR to many bad blocks.\r\n"));
            return flVolumeTooSmall;
         }
      }
   }
   *mediaSize = vol.noOfUnits << vol.unitSizeBits;
   return flOK;
}

#endif /* NO_READ_BBT_CODE */

/*----------------------------------------------------------------------*/
/*                      m o u n t N F T L                               */
/*                                                                      */
/* Mount the volume. Initialize data structures and conversion tables   */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo           : Volume serial no.                               */
/*    tl              : Mounted translation layer on exit               */
/*    flash           : Flash media mounted on this socket              */
/*    volForCallback  : Pointer to FLFlash structure for power on       */
/*                      callback routine.                               */
/*                                                                      */
/* update the tlType field of the TL record to NFTL                     */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus mountNFTL(unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback)
{
  Anand vol = &vols[volNo];
  ANANDUnitNo iUnit,virUnit,nextUnit;
  unsigned long currEraseCount=0;
  ANANDBootRecord bootRecord,spareBootRecord;
  FLStatus status;
#ifdef NFTL_CACHE
  unsigned long scacheSize = 0;
#endif /* NFTL_CACHE */
#ifdef EXTRA_LARGE
  int moreUnitBits;
#endif /* EXTRA_LARGE */

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  /* Default for NFTL is FL_UPS */
  flVerifyWrite[vol.socketNo][tl->partitionNo] = FL_UPS;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  tffsset(&bootRecord,0,sizeof(ANANDBootRecord));

  DEBUG_PRINT(("Debug: starting NFTL mount.\r\n"));

  checkStatus(initNFTL(&vol,flash));
  *volForCallback = vol.flash;
  vol.eraseSum = 0;
  /* Find the medium boot record */
  for (vol.orgUnit = 0; vol.orgUnit < vol.noOfUnits; vol.orgUnit++) {
    vol.flash->read(vol.flash,
           unitBaseAddress(&vol,vol.orgUnit),
           &bootRecord,
           sizeof bootRecord,
           0);
    if (tffscmp(bootRecord.bootRecordId,"ANAND",sizeof bootRecord.bootRecordId) == 0)
       break;
  }
  if (vol.orgUnit >= vol.noOfUnits) {
    DEBUG_PRINT(("Debug: not NFTL format.\r\n"));
    return flUnknownMedia;
  }

  for (vol.spareOrgUnit = vol.orgUnit + 1;
       vol.spareOrgUnit < vol.noOfUnits;
       vol.spareOrgUnit++) {
    vol.flash->read(vol.flash,
           unitBaseAddress(&vol,vol.spareOrgUnit),
           &spareBootRecord,
           sizeof spareBootRecord,
           0);
    if (tffscmp(spareBootRecord.bootRecordId,"ANAND",sizeof spareBootRecord.bootRecordId) == 0)
      break;
  }
  if (vol.spareOrgUnit >= vol.noOfUnits)
    vol.spareOrgUnit = ANAND_NO_UNIT;

  /* Get media information from unit header */
  vol.noOfUnits = LE2(bootRecord.noOfUnits);
  vol.bootUnits = LE2(bootRecord.bootUnits);
  vol.virtualSectors = (SectorNo)(UNAL4(bootRecord.virtualMediumSize) >> SECTOR_SIZE_BITS);
  vol.noOfUnits += vol.bootUnits;

#ifdef EXTRA_LARGE
  moreUnitBits = ~bootRecord.anandFlags & MORE_UNIT_BITS_MASK;
  if (moreUnitBits > 0) {
    vol.unitSizeBits += moreUnitBits;
    vol.orgUnit >>= moreUnitBits;
    if (vol.spareOrgUnit != ANAND_NO_UNIT)
      vol.spareOrgUnit >>= moreUnitBits;
  }
#endif /* EXTRA_LARGE */

  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.noOfVirtualUnits = (ANANDUnitNo)((vol.virtualSectors + vol.sectorsPerUnit - 1) / vol.sectorsPerUnit);

  if(((ANANDUnitNo)(vol.virtualSectors >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) >
      (vol.noOfUnits - vol.bootUnits)) ) {

    if( vol.spareOrgUnit != ANAND_NO_UNIT ) {
       vol.noOfUnits = LE2(spareBootRecord.noOfUnits);
       vol.bootUnits = LE2(spareBootRecord.bootUnits);
       vol.virtualSectors = (SectorNo)(UNAL4(spareBootRecord.virtualMediumSize) >> SECTOR_SIZE_BITS);
       vol.noOfUnits += vol.bootUnits;

#ifdef EXTRA_LARGE
       moreUnitBits = ~spareBootRecord.anandFlags & MORE_UNIT_BITS_MASK;
       if (moreUnitBits > 0) {
     vol.unitSizeBits += moreUnitBits;
     vol.orgUnit >>= moreUnitBits;
     if (vol.spareOrgUnit != ANAND_NO_UNIT)
        vol.spareOrgUnit >>= moreUnitBits;
       }
#endif /* EXTRA_LARGE */

       vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
       vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
       vol.noOfVirtualUnits = (ANANDUnitNo)((vol.virtualSectors + vol.sectorsPerUnit - 1) / vol.sectorsPerUnit);

       if ((ANANDUnitNo)(vol.virtualSectors >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) >
       (vol.noOfUnits - vol.bootUnits))
     return flBadFormat;
    }
    else
      return flBadFormat;
  }

  checkStatus(initTables(&vol));


  /* Read bad unit table from boot record */
  status = vol.flash->read(vol.flash,
              unitBaseAddress(&vol,vol.orgUnit) + SECTOR_SIZE,
              vol.physicalUnits,
              vol.noOfUnits * sizeof(ANANDPhysUnit),
              EDC);
  if( status != flOK ) {
    if( vol.spareOrgUnit != ANAND_NO_UNIT ) {
      status = vol.flash->read(vol.flash,
              unitBaseAddress(&vol,vol.spareOrgUnit) + SECTOR_SIZE,
              vol.physicalUnits,
              vol.noOfUnits * sizeof(ANANDPhysUnit),
              EDC);
      if( status != flOK ) {
    dismountNFTL(&vol); /* Free tables must be done after call to initTables */
    return status;
      }
    }
    else
      return status;
  }
  /* Exclude boot-image units */
  for (iUnit = 0; iUnit < vol.noOfVirtualUnits; iUnit++)
    vol.virtualUnits[iUnit] = ANAND_NO_UNIT;

  /* Translate bad unit table to internal representation */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    /* Exclude bad & protected units */
    if (iUnit < vol.bootUnits || iUnit == vol.orgUnit || iUnit == vol.spareOrgUnit ||
        vol.physicalUnits[iUnit] != ANAND_UNIT_FREE) {
      if (vol.physicalUnits[iUnit] != ANAND_UNIT_FREE) {
        vol.physicalUnits[iUnit] = UNIT_BAD_MOUNT;
            }
      else {
        vol.physicalUnits[iUnit] = UNIT_UNAVAIL;
            }
        }
  }

  /* Mount all units */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    if ((vol.physicalUnits[iUnit] != UNIT_UNAVAIL) && (vol.physicalUnits[iUnit] != UNIT_BAD_MOUNT)) {
      status = mountUnit(&vol,iUnit,&currEraseCount);
      if(status!=flOK) {
        dismountNFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
      }
      vol.eraseSum+=currEraseCount;
    }
  }

  /* Scan for orphan units, and count free units */
  vol.freeUnits = 0;
  for (iUnit = vol.bootUnits; iUnit < vol.noOfUnits; iUnit++) {
    ANANDPhysUnit FAR1 *pU = &vol.physicalUnits[iUnit];

    if (*pU == UNIT_ORPHAN ||
    *pU == (UNIT_REPLACED | UNIT_ORPHAN)) {
       formatChain(&vol,iUnit);                 /* Get rid of orphan */
       if(iUnit == vol.invalidReplacement)
          vol.invalidReplacement = ANAND_NO_UNIT;
    }
    else
      if (*pU == (ANAND_UNIT_FREE & ~UNIT_ORPHAN))
    *pU = ANAND_UNIT_FREE;    /* Reference to free unit. That's OK */
  }
  /* Calculate Free Units again after formatChain */
  vol.freeUnits = 0;
  for (iUnit = vol.bootUnits; iUnit < vol.noOfUnits; iUnit++) {
    if( vol.physicalUnits[iUnit] == ANAND_UNIT_FREE )
      vol.freeUnits++;
  }

  /* Initialize allocation rover */
  vol.roverUnit = vol.bootUnits;

  /* Initialize statistics */
  vol.sectorsRead = vol.sectorsWritten = vol.sectorsDeleted = 0;
  vol.parasiteWrites = vol.unitsFolded = 0;

#ifndef FL_READ_ONLY
  /*
   * Make sure no unit chain with an invalid replacemenet unit
   * pointer on the last unit
   */

  if(vol.invalidReplacement != ANAND_NO_UNIT)
  {
     getUnitData(&vol,vol.invalidReplacement,&virUnit,&nextUnit);
     virUnit = virUnit&(~ANAND_REPLACING_UNIT);
     if(virUnit >= vol.noOfVirtualUnits)
     {
         DEBUG_PRINT(("ERROR - a bad unit header encountered.\r\n"));
         dismountNFTL(&vol);
         return  flBadFormat;
     }

     iUnit = vol.virtualUnits[virUnit];
     if(iUnit >= vol.noOfUnits)
     {
         DEBUG_PRINT(("ERROR - a bad unit header encountered.\r\n"));
         dismountNFTL(&vol);
         return  flBadFormat;
     }
     setUnavail(iUnit);
     checkStatus(foldUnit(&vol,virUnit,TRUE));
  }

  /* Make sure there is at least 1 free unit */
  if(vol.freeUnits == 0)
     foldBestChain(&vol,&iUnit);  /* make free units by folding the best chain */

#endif /* FL_READ_ONLY */

  /* Set TL routine */
  tl->rec = &vol;
  tl->mapSector = mapSector;
#ifndef FL_READ_ONLY
  tl->writeSector = writeSector;
  tl->deleteSector = deleteSector;
#ifdef DEFRAGMENT_VOLUME
  tl->defragment = defragment;
#endif
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  tl->checkVolume      = checkVolume;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#endif /* FL_READ_ONLY */
  tl->sectorsInVolume = sectorsInVolume;
  tl->getTLInfo = NFTLInfo;
  tl->tlSetBusy = tlSetBusy;
  tl->dismount  = dismountNFTL;
#ifndef NO_READ_BBT_CODE
  tl->readBBT   = readBBT;
#endif /* NO_READ_BBT_CODE */
  tl->writeMultiSector = NULL;
  tl->readSectors = NULL;

  DEBUG_PRINT(("Debug: finished NFTL mount.\r\n"));

#ifdef NFTL_CACHE

  /* create and initialize ANANDUnitHeader cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif
  {
#ifdef FL_MALLOC
  vol.ucache = (ucacheEntry FAR1*) FL_FAR_MALLOC (vol.noOfUnits * sizeof(ucacheEntry));
#else
  vol.ucache = vol.ucacheBuf;
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
    vol.ucache = NULL;
#endif
  if (vol.ucache != NULL) {
    for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
      vol.ucache[iUnit].virtualUnitNo     = 0xDEAD;
      vol.ucache[iUnit].replacementUnitNo = 0xDEAD;
    }
  }
  else {
    DEBUG_PRINT(("Debug: NFTL runs without U-cache\r\n"));
  }

  /* create and initialize SectorFlags cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif
  {
  scacheSize = (unsigned long)vol.noOfUnits << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2);
#ifdef FL_MALLOC
  if( (sizeof(unsigned) < sizeof(scacheSize)) &&
      (scacheSize >= 0x10000L) )            /* Out of Segment Boundary */
    vol.scache = NULL;
  else
    vol.scache = (unsigned char FAR1*) FL_FAR_MALLOC (scacheSize);
#else
  vol.scache = vol.scacheBuf;
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
    vol.scache = NULL;
#endif
  if (vol.scache != NULL) {
    /*
     * Whenever SECTOR_IGNORE is found in Sector Flags cache it is double
     * checked by reading actual sector flags from flash-> This is way
     * all the cache entries are initially set to SECTOR_IGNORE.
     */
    unsigned char val = (S_CACHE_SECTOR_IGNORE << 6) | (S_CACHE_SECTOR_IGNORE << 4) |
            (S_CACHE_SECTOR_IGNORE << 2) |  S_CACHE_SECTOR_IGNORE;
    unsigned long iC;

    for(iC=0;( iC < scacheSize );iC++)
      vol.scache[iC] = val;
  }
  else {
    DEBUG_PRINT(("Debug: NFTL runs without S-cache\r\n"));
  }

#endif /* NFTL_CACHE */

  vol.badFormat = FALSE;
  vol.wearLevel.alarm = (unsigned char)(vol.eraseSum % WLnow);
  vol.wearLevel.currUnit = (ANANDUnitNo)(vol.eraseSum % vol.noOfVirtualUnits);

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                   f l R e g i s t e r N F T L                        */
/*                                                                      */
/* Register this translation layer                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    None                                                              */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failure                     */
/*----------------------------------------------------------------------*/

FLStatus flRegisterNFTL(void)
{
#ifdef FL_MALLOC
  unsigned i;
#endif

  if (noOfTLs >= TLS)
    return flTooManyComponents;

  tlTable[noOfTLs].mountRoutine = mountNFTL;

#ifdef FORMAT_VOLUME
  tlTable[noOfTLs].formatRoutine = formatNFTL;
#else
  tlTable[noOfTLs].formatRoutine = noFormat;
#endif
  noOfTLs++;

#ifdef FL_MALLOC
  for(i=0;( i < VOLUMES );i++) {
    vols[i].physicalUnits = NULL;
    vols[i].virtualUnits = NULL;
#ifdef NFTL_CACHE
    vols[i].ucache = NULL;
    vols[i].scache = NULL;
#endif /* NFTL_CACHE */
  }
#endif /* FL_MALLOC */
  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                      m a r k A s I g n o r e d                       */
/*                                                                      */
/* Mark sector at given address as ignored.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      addr            : Physical address of the sector                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void markAsIgnored(Anand vol,CardAddress addr)
{
#ifndef RAM_MTD
    static const
#endif /* RAM_MTD */
    byte sectorFlags[2] = {SECTOR_IGNORE,SECTOR_IGNORE};

    DEBUG_PRINT(("markAsIgnored : A sector is being marked as ignored\r\n"));

    /* Force remapping of internal catched sector */
    vol.flash->socket->remapped = TRUE;

#ifdef NFTL_CACHE
    setSectorFlagsCache(&vol, addr, SECTOR_IGNORE);
#endif /* NFTL_CACHE */
     vol.flash->write(vol.flash,addr+SECTOR_DATA_OFFSET,sectorFlags,sizeof(sectorFlags),EXTRA);

#if MAKE_SURE_IGNORE_HAS_BAD_EDC
     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Make sure EDC is wrong - a slite problem with PPP */
     if(vol.flash->read(vol.flash,addr,nftlBuffer,sizeof(nftlBuffer),EDC)==flOK)
     {
        tffsset(nftlBuffer,0,sizeof(nftlBuffer));
        vol.flash->write(vol.flash,addr,nftlBuffer,sizeof(nftlBuffer),0);
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
        /* Set all ff's for verifySector routine */
        tffsset(nftlBuffer,0xff,sizeof(nftlBuffer));
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
     }
#endif /* MAKE_SURE_IGNORE_HAS_BAD_EDC */
}


#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))

/*----------------------------------------------------------------------*/
/*                        v e r i f y S e c t o r s                     */
/*                                                                      */
/* Verify sectors for power failures simptoms and fix if neccesary.     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorCount     : No of sectors to verify                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

FLStatus verifySectors(Anand vol, dword sectorCount)
{
   FLStatus    status;

   ANANDUnitNo virUnitNo;
   ANANDUnitNo unitNo;
   dword       curRead;
   CardAddress unitOffset;
   CardAddress startSectorAddress;
   CardAddress sourceSectorAddress;
   CardAddress nextFreeSectorAddress;
   byte        index,sectorFlags;
   byte FAR1*  buffer;

   if (vol.verifiedSectorNo >= vol.virtualSectors)
      return flOK;

   /* Initialize variables */
   buffer      = flReadBackBufferOf(vol.socketNo);
   if(buffer==NULL)
   {
       DEBUG_PRINT(("\nDebug : Can not verify sectors since no buffer was allocated\r\n"));
       return flOK;
   }
   virUnitNo   = (ANANDUnitNo)(vol.verifiedSectorNo / vol.sectorsPerUnit);
   sectorCount = TFFSMIN(vol.virtualSectors - vol.verifiedSectorNo,sectorCount);
   /* Force remapping of internal catched sector */
   vol.flash->socket->remapped = TRUE;
   tffsset(nftlBuffer,0xff,sizeof(nftlBuffer));

   /* Run over required number of virtual sectors */
   for (; sectorCount > 0 ; virUnitNo++ ,sectorCount -= curRead)
   {
      /* Calculate needed number of sector in this unit */
      unitOffset = (word)((vol.verifiedSectorNo % vol.sectorsPerUnit) << SECTOR_SIZE_BITS);
      curRead    = TFFSMIN(sectorCount,((1UL<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS);
      unitNo     = vol.virtualUnits[virUnitNo];

      if(unitNo == ANAND_NO_UNIT) /* Unit is empty */
      {
         vol.verifiedSectorNo += ((1<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS;
         continue;
      }

      /* Check all sector of unit or until required sectors */
      startSectorAddress  = unitBaseAddress(&vol,unitNo)+unitOffset;

      for (index = 0 ; index < curRead ;
           index++, vol.verifiedSectorNo++)
      {
         nextFreeSectorAddress = ANAND_UNASSIGNED_ADDRESS; /* Search end addr */
         sourceSectorAddress = virtual2Physical(&vol,
                                                vol.verifiedSectorNo,
                                                &nextFreeSectorAddress);

         if(sourceSectorAddress == ANAND_UNASSIGNED_ADDRESS) /* No written sector */
            sourceSectorAddress = startSectorAddress +
                                  ((CardAddress)index << SECTOR_SIZE_BITS);

         sectorFlags = getSectorFlags(&vol,sourceSectorAddress);
         if(sectorFlags == SECTOR_FREE)
         {
            checkStatus(vol.flash->read(vol.flash,sourceSectorAddress,buffer,SECTOR_SIZE,0));
            if (tffscmp(nftlBuffer,buffer,SECTOR_SIZE)!=0)
               markAsIgnored(&vol,sourceSectorAddress);
            continue;
         }
         else /* Used sector */
         {
            status = vol.flash->read(vol.flash,sourceSectorAddress,buffer,SECTOR_SIZE,EDC);
            switch (status)
            {
               case flDataError:
                  markAsIgnored(&vol,sourceSectorAddress);
                  createUnitCount(&vol,virUnitNo);
                  break;         /* Mark as ignored   */
               case flOK:
                  break;         /* Sector OK         */
               default:
                  return status; /* Report error      */
            }
         }
         /* Check the next free sector to make sure it is erased */
         if(nextFreeSectorAddress != ANAND_UNASSIGNED_ADDRESS)
         {
            checkStatus(vol.flash->read(vol.flash,nextFreeSectorAddress,buffer,SECTOR_SIZE,0));
            if (tffscmp(nftlBuffer,buffer,SECTOR_SIZE)!=0)
               markAsIgnored(&vol,nextFreeSectorAddress);
         }
      } /* Loop over all sector of unit or until required sectors */
   } /* Loop over all required sectors */
   return flOK;
}


/*----------------------------------------------------------------------*/
/*                        c h e c k V o l u m e                         */
/*                                                                      */
/* Scanthe entire media for partialy written sectors.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus checkVolume(Anand vol)
{
   return verifySectors(&vol, 0xffffffff);
}

#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

/*----------------------------------------------------------------------*/
/*                     c h e c k F o l d i n g                          */
/*                                                                      */
/* Check folding status and if needed fold again.                       */
/*                                                                      */
/* Parameters:                                                          */
/*    vol           : Pointer identifying drive                         */
/*    virtualUnitNo : Virtual unit number to re-fold                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

static FLStatus checkFolding(Anand vol, ANANDUnitNo virtualUnitNo)
{
   ANANDUnitNo tmp;

   if(vol.freeUnits == 0)
      checkStatus(foldBestChain(&vol, &tmp));
   return foldUnit(&vol,virtualUnitNo,TRUE);
}


#endif /* FL_READ_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\tffsport.h ===
#ifndef TFFSPORT_H
#define TFFSPORT_H

#include "wmilib.h"
#include "wmistr.h"

#define VENDORSTRING    "MSystems"
#define PRODUCTSTRING   "DiskOnChip2000  "
#define REVISIONSTRING  "1.00"
#define SERIALSTRING    "0001"

#define VENDORSTRINGSIZE    8
#define PRODUCTSTRINGSIZE   16
#define REVISIONSTRINGSIZE  4
#define SERIALSTRINGSIZE    4

#define DISKONCHIP_WINDOW_SIZE  0x2000
#define START_SEARCH_ADDRESS    0xc8000L
#define END_SEARCH_ADDRESS      0xda000L
#define DISKONCHIP_INTERFACE    Isa
#define DISKONCHIP_BUSNUMBER    0

#define d_SEARCH_ADDRESS    0xd0000L
#define dd_SEARCH_ADDRESS      0xd4000L

#define TFFS_MEMORY_SPACE    0
#define TFFS_IO_SPACE        1

#define MAX_TRANSFER_SIZE_PER_SRB   (0x10000)
#define MODE_DATA_SIZE              192

#define DEVICE_DEFAULT_IDLE_TIMEOUT   0xffffffff
#define DEVICE_VERY_LONG_IDLE_TIMEOUT 0xfffffffe

// Device state flags
#define DEVICE_FLAG_STOPPED                 0x00000001
#define DEVICE_FLAG_REMOVED                 0x00000002
#define DEVICE_FLAG_CLAIMED                 0x00000004
#define DEVICE_FLAG_QUERY_STOP_REMOVE       0x00000008
#define DEVICE_FLAG_STARTED                 0x00000010
#define DEVICE_FLAG_HOLD_IRPS               0x00000020
#define DEVICE_FLAG_CHILD_REMOVED           0x00000040

// Removed WE DONT NEED THIS FLAG
// instead examine the threadObject .. that object gets nulled
// when the thread has exited.
// #define DEVICE_FLAG_THREAD                  0x00000080

#define DRIVER_PARAMETER_SUBKEY     "Parameters"
#define LEGACY_DETECTION            L"LegacyDetection"
#define DRIVER_OBJECT_EXTENSION_ID  DriverEntry

#define NUM_WMI_MINOR_FUNCTION      (0xa)



typedef struct _TempINFO{
    long baseAddress;
    unsigned char nextPartition;
}TempINFO;

typedef struct      /*  represents DOC 2000 & Millenium memory window  */
{
           UCHAR   IPLpart1[0x800];     /* read   not used here */
  volatile UCHAR   IPLpart2[0x800];     /* read     IO for MDOC */
  volatile UCHAR   chipId;              /* read       */
  volatile UCHAR   DOCstatus;           /* read       */
  volatile UCHAR   DOCcontrol;          /*      write */
  volatile UCHAR   ASICselect;          /* read write */
  volatile UCHAR   signals;             /* read write */
  volatile UCHAR   deviceSelector;      /* read write */
  volatile UCHAR   ECCconfig;           /*      write */
  volatile UCHAR   ECCstatus;           /* read       */
  volatile UCHAR   test[5];             /*        not used here */
  volatile UCHAR   slowIO;              /* read write */
           UCHAR   filler1[2];          /*  --    --  */
  volatile UCHAR   syndrom[6];          /* read       */
           UCHAR   filler2[5];          /*  --    --  */
  volatile UCHAR   aliasResolution;     /* read write MDOC only */
  volatile UCHAR   configInput;         /* read write   - || -  */
  volatile UCHAR   readPipeInit;        /* read         - || -  */
  volatile UCHAR   writePipeTerm;       /*      write   - || -  */
  volatile UCHAR   readLastData;        /* read write   - || -  */
  volatile UCHAR   NOPreg;              /* read write   - || -  */
           UCHAR   filler3[0x1D];       /*  --    --  */
  volatile UCHAR   ROMwriteEnable;      /*      write DOC only  */
  volatile UCHAR   foudaryTest;         /*      write */
           UCHAR   filler4[0x800-0x40]; /*  --    --  */
  volatile UCHAR   io[0x800];           /* read write */
} DOC2window;

typedef struct      /*  represents MDOC PLUS memory window  */
{
           unsigned char   IPLpart1[0x800];     /* 0000-07ff    */
  volatile unsigned char   io1[0x800];          /* 0800-0fff    */
  volatile unsigned char   chipId;              /* 1000         */
           unsigned char   filler1;             /*  --    --    */
  volatile unsigned char   NopReg;              /* 1002         */
           unsigned char   filler2;             /*  --    --    */
  volatile unsigned char   AliasResolution;     /* 1004         */
           unsigned char   filler3;             /*  --    --    */
  volatile unsigned char   DOCcontrol;          /* 1006         */
           unsigned char   filler4;             /*  --    --    */
  volatile unsigned char   DeviceIDselect;      /* 1008         */
           unsigned char   filler5;             /*  --    --    */
  volatile unsigned char   ConfigReg;           /* 100A         */
           unsigned char   filler6;             /*  --    --    */
  volatile unsigned char   OutputReg;           /* 100C         */
           unsigned char   filler7;             /*  --    --    */
  volatile unsigned char   IntCntReg;           /* 100E         */
           unsigned char   filler8;             /*  --    --    */
  volatile unsigned char   IntVecReg;           /* 1010         */
           unsigned char   filler9;             /*  --    --    */
  volatile unsigned char   OutputEnableReg;     /* 1012         */
           unsigned char   filler10[0xB];       /*  --    --    */
  volatile unsigned char   FlSlowReg[2];        /* 101E - 101F  */
  volatile unsigned char   FlCntReg;            /* 1020         */
           unsigned char   filler11;            /*  --    --    */
  volatile unsigned char   FlSelectReg;         /* 1022         */
           unsigned char   filler12;            /*  --    --    */
  volatile unsigned char   FlCmdReg;            /* 1024         */
           unsigned char   filler13;            /*  --    --    */
  volatile unsigned char   FlAddressReg;        /* 1026         */
           unsigned char   filler14;            /*  --    --    */
  volatile unsigned char   FlDataReg[2];        /* 1028-1029    */
  volatile unsigned char   readPipeInit;        /* 102A         */
           unsigned char   filler15;            /*  --    --    */
  volatile unsigned char   readLastData[2];     /* 102C-102D    */
  volatile unsigned char   WritePipeTerm;       /* 102E         */
           unsigned char   filler16[17];       /*  --    -- */
  volatile unsigned char   syndrom[6];          /* 1040-1045    */
  volatile unsigned char   EccCntReg;           /* 1046         */
           unsigned char   filler17;            /*  --    --    */
  volatile unsigned char   CotpReg;             /* 1048         */
           unsigned char   filler18[17];        /*  --    --    */
  volatile unsigned char   FlGeometryReg;       /* 105A         */
           unsigned char   filler19;            /*  --    --    */
  volatile unsigned char   DataProtect[0x17];   /* 105C-1072    */
           unsigned char   filler20;            /*  --    --    */
  volatile unsigned char   DownloadReg;         /* 1074         */
           unsigned char   filler21;            /*  --    --    */
  volatile unsigned char   DocCntConfirmReg;    /* 1076         */
           unsigned char   filler22;            /*  --    --    */
  volatile unsigned char   ProtectionReg;       /* 1078         */
           unsigned char   filler23[0x6];       /*  --    --    */
  volatile unsigned char   foundryTest;         /* 107E         */
           unsigned char   filler24;            /*  --    --    */
           unsigned char   filler25[0x77F];         /*  --    --    */
  volatile unsigned char   io2[0x7FF];          /* 1800-1FFF    */
  volatile unsigned char   PowerDownReg;         /* 1FFF            */
} MDOCPwindow;
/* MDOC PLUS */


typedef struct _NTpcicParams {
    PHYSICAL_ADDRESS phWindowBase;
    ULONGLONG        physWindow;
    ULONG            windowSize;
    ULONG            addressSpace;
    PVOID            windowBase;
    INTERFACE_TYPE   InterfaceType;
    ULONG            BusNumber;
}  NTpcicParams;

typedef struct _TRUEFFSDRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;

} TRUEFFSDRIVER_EXTENSION, *PTRUEFFSDRIVER_EXTENSION;


#define EXTENSION_COMMON_HEADER     PDEVICE_OBJECT DeviceObject; \
                                    PDEVICE_OBJECT LowerDeviceObject; \
                                    PDRIVER_OBJECT DriverObject; \
                                    DEVICE_POWER_STATE DevicePowerState; \
                                    SYSTEM_POWER_STATE SystemPowerState; \
                                    ULONG PagingPathCount; \
                                    ULONG HiberPathCount; \
                                    ULONG CrashDumpPathCount; \
                                    WMILIB_CONTEXT WmiLibInfo

typedef struct _DEVICE_EXTENSION_HEADER {

    EXTENSION_COMMON_HEADER;

} DEVICE_EXTENSION_HEADER, * PDEVICE_EXTENSION_HEADER;

typedef struct _DEVICE_EXTENSION {
    EXTENSION_COMMON_HEADER;
    PDEVICE_OBJECT MainPdo;
    PDEVICE_OBJECT ChildPdo;
    ULONG DeviceFlags;
    ULONG Cylinders;
    ULONG NumberOfHeads;
    ULONG SectorsPerTrack;
    ULONG BytesPerSector;
    ULONG noOfHiddenSectors;
    ULONG totalSectors;
    PSCSI_REQUEST_BLOCK CurrentSrb;
    PUSHORT DataBuffer;
    BOOLEAN SymbolicLinkCreated;
    ULONG TrueffsDeviceNumber;
    ULONG UnitNumber;
    ULONG ScsiPortNumber;
    UCHAR ScsiDeviceType;
    KSPIN_LOCK ExtensionDataSpinLock;
    LIST_ENTRY listEntry;
    KSEMAPHORE requestSemaphore;
    KSPIN_LOCK listSpinLock;
    LONG threadReferenceCount;
    KEVENT PendingIRPEvent;
    BOOLEAN removableMedia;
    ULONG NumberOfDisksPoweredUp;
    NTpcicParams pcmciaParams;
    PKTHREAD TffsportThreadObject;
        BOOLEAN  IsPartitonTableWritten;
        BOOLEAN  IsWriteProtected;
        UCHAR        PartitonTable[0x200];
        BOOLEAN  IsSWWriteProtected;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _PDO_EXTENSION {
    EXTENSION_COMMON_HEADER;
    PDEVICE_EXTENSION Pext;    // parent device extension
    PIRP PendingPowerIrp;
    PULONG IdleCounter;
} PDO_EXTENSION, *PPDO_EXTENSION;

typedef struct _TFFS_DEVICE_TYPE {
    PCSTR DeviceTypeString;
    PCSTR CompatibleIdString;
    PCSTR PeripheralIdString;
} TFFS_DEVICE_TYPE, * PTFFS_DEVICE_TYPE;

typedef struct _FDO_POWER_CONTEXT {
   POWER_STATE_TYPE   PowerType;
   POWER_STATE        PowerState;
} FDO_POWER_CONTEXT, *PFDO_POWER_CONTEXT;

#define IS_FDO(devExtension)  (devExtension->LowerDeviceObject != NULL)

typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );

typedef
BOOLEAN
(*PDUMP_DRIVER_OPEN) (
    IN LARGE_INTEGER PartitionOffset
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE) (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );


typedef
VOID
(*PDUMP_DRIVER_FINISH) (
    VOID
    );

struct _ADAPTER_OBJECT;

//
// This is the information passed from the system to the disk dump driver
// during the driver's initialization.
//

typedef struct _INITIALIZATION_CONTEXT {
    ULONG Length;
    ULONG DiskSignature;
    PVOID MemoryBlock;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PSTALL_ROUTINE StallRoutine;
    PDUMP_DRIVER_OPEN OpenRoutine;
    PDUMP_DRIVER_WRITE WriteRoutine;
    PDUMP_DRIVER_FINISH FinishRoutine;
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID PortConfiguration;
    BOOLEAN CrashDump;
    ULONG MaximumTransferSize;
    ULONG CommonBufferSize;
    PVOID TargetAddress; //Opaque pointer to target address structure
} INITIALIZATION_CONTEXT, *PINITIALIZATION_CONTEXT;

typedef struct _CRASHDUMP_INIT_DATA {

    PDEVICE_EXTENSION cdFdoExtension;

} CRASHDUMP_INIT_DATA, *PCRASHDUMP_INIT_DATA;

typedef struct _CRASHDUMP_DATA {
    PCRASHDUMP_INIT_DATA    CrashInitData;
    LARGE_INTEGER           PartitionOffset;
    PSTALL_ROUTINE          StallRoutine;
    SCSI_REQUEST_BLOCK      Srb;
    DEVICE_EXTENSION        fdoExtension;
    ULONG                   MaxBlockSize;
} CRASHDUMP_DATA, *PCRASHDUMP_DATA;

typedef struct _WMI_FLASH_DISK_INFO {
    ULONG Number;
    ULONG Address;
    ULONG Size;
} WMI_FLASH_DISK_INFO, *PWMI_FLASH_DISK_INFO;

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
TrueffsFetchKeyValue(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING  RegistryPath,
        IN PWSTR                        KeyName,
        IN OUT ULONG*               KeyValue
);

NTSTATUS
TrueffsDetectRegistryValues(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
TrueffsDetectDiskOnChip(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
TrueffsTranslateAddress(
    IN INTERFACE_TYPE     InterfaceType,
    IN ULONG              BusNumber,
    IN PHYSICAL_ADDRESS   StartAddress,
    IN LONG               Length,
    IN OUT PULONG         AddressSpace,
    OUT PVOID             *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS TranslatedMemoryAddress
    );

VOID
TrueffsFreeTranslatedAddress(
    IN PVOID TranslatedAddress,
    IN LONG  Length,
    IN ULONG AddressSpace
    );

NTSTATUS
TrueffsAddDevice(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT Pdo
    );

NTSTATUS
TrueffsCreateDevObject(
    IN PDRIVER_OBJECT     DriverObject,
    IN PDEVICE_OBJECT     Pdo,
    OUT PDEVICE_EXTENSION *FdoExtension
    );

NTSTATUS
TrueffsStartDevice(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PCM_RESOURCE_LIST ResourceList,
    IN BOOLEAN           CheckResources
    );

NTSTATUS
TrueffsMountMedia(
     IN PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
TrueffsStopRemoveDevice(
    PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
TrueffsCreateSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    );

NTSTATUS
TrueffsDeleteSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    );

NTSTATUS
TrueffsDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TrueffsDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
TrueffsQueryProperty(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP QueryIrp
    );

NTSTATUS
TrueffsScsiRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TrueffsCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
TrueffsPnpDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
TrueffsPowerControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
TrueffsUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
TrueffsStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
TrueffsThread(
    PVOID Context
    );

NTSTATUS
QueueIrpToThread(
    IN OUT PIRP Irp,
    IN OUT PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
TrueffsTranslateSRBStatus(
    ULONG status
    );

NTSTATUS
TrueffsDeviceQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    );

PWSTR
DeviceBuildBusId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    );

PWSTR
DeviceBuildInstanceId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    );
PWSTR
DeviceBuildCompatibleId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
);

PWSTR
DeviceBuildHardwareId(
    IN PDEVICE_EXTENSION deviceExtension,
    BOOLEAN Fdo
    );

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG  Count,
    IN UCHAR  Change
    );

PCSTR
TrueffsGetDeviceTypeString (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetCompatibleIdString (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetPeripheralIdString (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetDeviceTypeStringFDO (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetCompatibleIdStringFDO (
    IN ULONG DeviceType
    );

PCSTR
TrueffsGetPeripheralIdStringFDO (
    IN ULONG DeviceType
    );

NTSTATUS
TrueffsQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    BOOLEAN Fdo
    );

BOOLEAN
TrueffsOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
TrueffsGetParameterFromServiceSubKey (
    IN  PDRIVER_OBJECT DriverObject,
    IN  PWSTR          ParameterName,
    IN  ULONG          ParameterType,
    IN  BOOLEAN        Read,
    OUT PVOID          *ParameterValue,
    IN  ULONG          ParameterValueWriteSize
    );

NTSTATUS
TrueffsRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

HANDLE
TrueffsOpenServiceSubKey (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING SubKeyPath
    );

VOID
TrueffsCloseServiceSubKey (
    IN HANDLE SubServiceKey
    );

NTSTATUS
TrueffsFindDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    IN BOOLEAN          StartSearch,
    OUT PVOID           *WindowBase
    );

NTSTATUS
TrueffsCheckDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    OUT PVOID           *WindowBase,
    OUT PULONG          AddressSpace
    );

VOID
TrueffsResetDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize
    );

PPDO_EXTENSION
AllocatePdo(
    IN PDEVICE_EXTENSION FdoExtension
    );

NTSTATUS
FreePdo(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
flBuildGeometry(dword capacity,
                                dword FAR2 *cylinders,
                                dword FAR2 *heads,
                                dword FAR2 *sectors,
                                FLBoolean oldFormat);

NTSTATUS
TrueffsSetPdoDevicePowerState( IN PDEVICE_OBJECT Pdo,
                               IN OUT PIRP Irp
                              );

NTSTATUS
TrueffsSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
TrueffsSetPdoPowerState(
                      IN PDEVICE_OBJECT Pdo,
                      IN OUT PIRP Irp
                      );

NTSTATUS
TrueffsSetFdoPowerState (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN OUT PIRP Irp
                       );

NTSTATUS
TrueffsFdoDevicePowerIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID contextIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
TrueffsFdoPowerCompletionRoutine (
                                IN PDEVICE_OBJECT DeviceObject,
                                IN PIRP Irp,
                                IN PVOID Context
                                );

VOID
TrueffsPdoCompletePowerIrp (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          );

VOID
TrueffsPdoRequestPowerCompletionRoutine(
                                      IN PDEVICE_OBJECT Pdo,
                                      IN UCHAR MinorFunction,
                                      IN POWER_STATE PowerState,
                                      IN PVOID Context,
                                      IN PIO_STATUS_BLOCK IoStatus
                                      );
NTSTATUS
TrueffsFdoChildRequestPowerUp (
                             IN PDEVICE_EXTENSION FdoExtension,
                             IN PPDO_EXTENSION    PdoExtension,
                             IN PIRP              Irp
                             );

NTSTATUS
TrueffsFdoChildRequestPowerUpCompletionRoutine (
                                              IN PDEVICE_OBJECT   DeviceObject,
                                              IN UCHAR            MinorFunction,
                                              IN POWER_STATE      PowerState,
                                              IN PVOID            Context,
                                              IN PIO_STATUS_BLOCK IoStatus
                                              );

NTSTATUS
TrueffsParentPowerUpCompletionRoutine(
                                    IN PVOID Context,
                                    IN NTSTATUS FdoStatus
                                    );

VOID
TrueffsFdoChildReportPowerDown (
                              IN PDEVICE_EXTENSION FdoExtension
                              );

NTSTATUS
TrueffsDeviceQueryCapabilities(IN PDEVICE_EXTENSION    deviceExtension,
                               IN PDEVICE_CAPABILITIES Capabilities
                                 );

NTSTATUS
updateDocSocketParams(PDEVICE_EXTENSION fdoExtension);

NTSTATUS updatePcmciaSocketParams(PDEVICE_EXTENSION fdoExtension);


NTSTATUS
TrueffsSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
TrueffsSyncSendIrpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
TrueffsCallDriverSync(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
TrueffsCallDriverSyncCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

ULONG
TrueffsCrashDumpDriverEntry (
    PVOID Context
    );

BOOLEAN
TrueffsCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    );

NTSTATUS
TrueffsCrashDumpWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );

VOID
TrueffsCrashDumpFinish (
    VOID
    );

VOID
TrueffsWmiInit (
    VOID
    );

NTSTATUS
TrueffsWmiRegister(
    PDEVICE_EXTENSION_HEADER DevExtension
    );

NTSTATUS
TrueffsWmiDeregister(
    PDEVICE_EXTENSION_HEADER DevExtension
    );

NTSTATUS
TrueffsWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
TrueffsQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
TrueffsQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
TrueffsSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
TrueffsSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );


#if DBG

#define TffsDebugPrint(X) TrueffsDebugPrint X

#define TFFS_DEB_ALL       0x0000FFFF
#define TFFS_DEB_INFO      0x00000001
#define TFFS_DEB_WARN      0x00000002
#define TFFS_DEB_ERROR     0x00000004

VOID
TrueffsDebugPrint(ULONG DebugPrintLevel, PCHAR DebugMessage, ...);

#else

#define TffsDebugPrint(X)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\driver\volsnap.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    volsnap.h

Abstract:

    This file provides the internal data structures for the volume snapshot
    driver.

Author:

    Norbert P. Kusters  (norbertk)  22-Jan-1999

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool #assert(FALSE)
#define ExAllocatePoolWithQuota #assert(FALSE)
#endif

#define VOLSNAP_TAG_APP_INFO    'aSoV'  // VoSa - Application information allocations
#define VOLSNAP_TAG_BUFFER      'bSoV'  // VoSb - Buffer allocations
#define VOLSNAP_TAG_CONTEXT     'cSoV'  // VoSc - Snapshot context allocations
#define VOLSNAP_TAG_DIFF_VOLUME 'dSoV'  // VoSd - Diff area volume allocations
#define VOLSNAP_TAG_DIFF_FILE   'fSoV'  // VoSf - Diff area file allocations
#define VOLSNAP_TAG_BIT_HISTORY 'hSoV'  // VoSh - Bit history allocations
#define VOLSNAP_TAG_IO_STATUS   'iSoV'  // VoSi - Io status block allocations
#define VOLSNAP_TAG_LOOKUP      'lSoV'  // VoSl - Snasphot lookup table entry
#define VOLSNAP_TAG_BITMAP      'mSoV'  // VoSm - Bitmap allocations
#define VOLSNAP_TAG_OLD_HEAP    'oSoV'  // VoSo - Old heap entry allocations
#define VOLSNAP_TAG_PNP_ID      'pSoV'  // VoSp - Pnp id allocations
#define VOLSNAP_TAG_RELATIONS   'rSoV'  // VoSr - Device relations allocations
#define VOLSNAP_TAG_SHORT_TERM  'sSoV'  // VoSs - Short term allocations
#define VOLSNAP_TAG_TEMP_TABLE  'tSoV'  // VoSt - Temp table allocations
#define VOLSNAP_TAG_WORK_QUEUE  'wSoV'  // VoSw - Work queue allocations
#define VOLSNAP_TAG_DISPATCH    'xSoV'  // VoSx - Dispatch context allocations
#define VOLSNAP_TAG_COPY        'CSoV'  // VoSx - Copy On Write Structures

#define NUMBER_OF_THREAD_POOLS  (3)

struct _VSP_CONTEXT;
typedef struct _VSP_CONTEXT VSP_CONTEXT, *PVSP_CONTEXT;

class FILTER_EXTENSION;
typedef FILTER_EXTENSION* PFILTER_EXTENSION;

class VOLUME_EXTENSION;
typedef VOLUME_EXTENSION* PVOLUME_EXTENSION;

//
// Write context buffer.
//

typedef struct _VSP_WRITE_CONTEXT {
    LIST_ENTRY          ListEntry;
    PFILTER_EXTENSION   Filter;
    PVOLUME_EXTENSION   Extension;
    PIRP                Irp;
    LIST_ENTRY          CompletionRoutines;
} VSP_WRITE_CONTEXT, *PVSP_WRITE_CONTEXT;

//
// Copy On Write List Entry.
//

typedef struct _VSP_COPY_ON_WRITE {
    LIST_ENTRY  ListEntry;
    LONGLONG    RoundedStart;
    PVOID       Buffer;
} VSP_COPY_ON_WRITE, *PVSP_COPY_ON_WRITE;

struct _TEMP_TRANSLATION_TABLE_ENTRY;
typedef struct _TEMP_TRANSLATION_TABLE_ENTRY TEMP_TRANSLATION_TABLE_ENTRY,
*PTEMP_TRANSLATION_TABLE_ENTRY;

typedef struct _DO_EXTENSION {

    //
    // Pointer to the driver object.
    //

    PDRIVER_OBJECT DriverObject;

    //
    // List of volume filters in they system.  Protect with 'Semaphore'.
    //

    LIST_ENTRY FilterList;

    //
    // HOLD/RELEASE Data.  Protect with cancel spin lock.
    //

    LONG HoldRefCount;
    GUID HoldInstanceGuid;
    ULONG SecondsToHoldFsTimeout;
    ULONG SecondsToHoldIrpTimeout;
    LIST_ENTRY HoldIrps;
    KTIMER HoldTimer;
    KDPC HoldTimerDpc;

    //
    // A semaphore for synchronization.
    //

    KSEMAPHORE Semaphore;

    //
    // Worker Thread.  Protect with 'SpinLock'.
    // Protect 'WorkerThreadObjects' and 'Wait*' with
    // 'ThreadsRefCountSemaphore'.
    //

    LIST_ENTRY WorkerQueue[NUMBER_OF_THREAD_POOLS];
    KSEMAPHORE WorkerSemaphore[NUMBER_OF_THREAD_POOLS];
    KSPIN_LOCK SpinLock[NUMBER_OF_THREAD_POOLS];
    PVOID* WorkerThreadObjects;
    BOOLEAN WaitForWorkerThreadsToExitWorkItemInUse;
    WORK_QUEUE_ITEM WaitForWorkerThreadsToExitWorkItem;

    //
    // Low-Priority Queue for sending stuff to the DelayedWorkQueue in a
    // single threaded manner.  Protect with 'ESpinLock'.
    //

    LIST_ENTRY LowPriorityQueue;
    BOOLEAN WorkerItemInUse;
    WORK_QUEUE_ITEM LowPriorityWorkItem;
    PWORK_QUEUE_ITEM ActualLowPriorityWorkItem;

    //
    // The threads ref count.  Protect with 'ThreadsRefCountSemaphore'.
    //

    LONG ThreadsRefCount;
    KSEMAPHORE ThreadsRefCountSemaphore;

    //
    // Notification entry.
    //

    PVOID NotificationEntry;

    //
    // Lookaside list for contexts.
    //

    NPAGED_LOOKASIDE_LIST ContextLookasideList;

    //
    // Emergency Context.  Protect with 'ESpinLock'.
    //

    PVSP_CONTEXT EmergencyContext;
    BOOLEAN EmergencyContextInUse;
    LIST_ENTRY IrpWaitingList;
    LONG IrpWaitingListNeedsChecking;
    KSPIN_LOCK ESpinLock;

    //
    // Lookaside list for write context buffers.
    //

    NPAGED_LOOKASIDE_LIST WriteContextLookasideList;

    //
    // Emergency Write Context Buffer.  Protect with 'ESpinLock'.
    //

    PVSP_WRITE_CONTEXT EmergencyWriteContext;
    BOOLEAN EmergencyWriteContextInUse;
    LIST_ENTRY WriteContextIrpWaitingList;
    LONG WriteContextIrpWaitingListNeedsChecking;

    //
    // Lookaside list for temp table entries.
    //

    NPAGED_LOOKASIDE_LIST TempTableEntryLookasideList;

    //
    // Emergency Temp Table Entry.  Protect with 'ESpinLock'.
    //

    PVOID EmergencyTableEntry;
    BOOLEAN EmergencyTableEntryInUse;
    LIST_ENTRY WorkItemWaitingList;
    LONG WorkItemWaitingListNeedsChecking;

    //
    // Stack count for allocating IRPs.  Use InterlockedExchange to update
    // along with Root->Semaphore.  Then, can be read for use in allocating
    // copy irps.
    //

    LONG StackSize;

    //
    // Is the code locked?  Protect with interlocked and 'Semaphore'.
    //

    LONG IsCodeLocked;

    //
    // Copy of registry path input to DriverEntry.
    //

    UNICODE_STRING RegistryPath;

    //
    // Queue for AdjustBitmap operations.  Just one at at time in the delayed
    // work queue.  Protect with 'ESpinLock'.
    //

    LIST_ENTRY AdjustBitmapQueue;
    BOOLEAN AdjustBitmapInProgress;

    //
    // Are we past re-init?
    //

    LONG PastReinit;

    //
    // Are we part boot-re-init?
    //

    KEVENT PastBootReinit;

    //
    // Keep a table of persistent information to facilitate matching
    // up a snapshot with its diff area.  Protect with 'LookupTableMutex'.
    //

    RTL_GENERIC_TABLE PersistentSnapshotLookupTable;
    KMUTEX LookupTableMutex;

    //
    // Remember whether or not this is SETUP.
    //

    BOOLEAN IsSetup;

    //
    // Indicates that the volumes in the system are safe for write access.
    //

    LONG VolumesSafeForWriteAccess;

    //
    // Supplies the next volume number to be used for a snapshot.
    // Protect with InterlockedIncrement.
    //

    LONG NextVolumeNumber;

    //
    // Keep a table of used devnode numbers.  Protect with 'Semaphore'.
    //

    RTL_GENERIC_TABLE UsedDevnodeNumbers;

} DO_EXTENSION, *PDO_EXTENSION;

#define DEVICE_EXTENSION_VOLUME (0)
#define DEVICE_EXTENSION_FILTER (1)

struct DEVICE_EXTENSION {

    //
    // Pointer to the device object for this extension.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to the root device extension.
    //

    PDO_EXTENSION Root;

    //
    // The type of device extension.
    //

    ULONG DeviceExtensionType;

    //
    // A spinlock for synchronization.
    //

    KSPIN_LOCK SpinLock;

};

typedef DEVICE_EXTENSION* PDEVICE_EXTENSION;

struct _VSP_DIFF_AREA_FILE;
typedef struct _VSP_DIFF_AREA_FILE VSP_DIFF_AREA_FILE, *PVSP_DIFF_AREA_FILE;

class VOLUME_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // A pointer to the filter for the volume that we are snapshotting.
        //

        PFILTER_EXTENSION Filter;

        //
        // Local state to handle PNP's START and REMOVE.
        // Protect 'IsStarted' with 'InterlockedExchange'.
        // Protect 'DeadToPnp' with 'InterlockedExchange'.
        // Protect 'DeviceDeleted' with 'InterlockedExchange'.
        // Write protect 'IsDead' with 'InterlockedExchange' and
        //     'Root->Semaphore.'.  'IsDead' indicates that this device is really
        //     dead now.  It is illegal to turn IsStarted to TRUE.
        // Protect 'AliveToPnp' with 'InterlockedExchange'.
        // Protect 'IsOffline' with 'InterlockedExchange'.
        //

        LONG IsStarted;
        LONG DeadToPnp;
        LONG DeviceDeleted;
        LONG IsDead;
        LONG AliveToPnp;
        LONG IsOffline;

        //
        // Keep track of all requests outstanding in order to support
        // remove.
        // Protect 'RefCount' with 'InterlockedIncrement/Decrement'.
        // Write protect 'HoldIncomingRequests' with 'SpinLock' and
        //  'InterlockedExchange'.
        // Protect 'HoldQueue' with 'SpinLock'.
        // Protect 'ZeroRefEvent' with the setting of 'HoldIncomingRequests'
        //  from 0 to 1.
        //

        LONG RefCount;
        LONG HoldIncomingRequests;
        KEVENT ZeroRefEvent;

        //
        // Post Commit Processing has occurred.  Protect with 'Root->Semaphore'.
        // Don't return this device in BusRelations until this is TRUE.
        //

        BOOLEAN HasEndCommit;

        //
        // Indicates that this device has been installed.  Protect with
        // 'Root->Semaphore'.
        //

        BOOLEAN IsInstalled;

        //
        // Indicates that this is a persistent snapshot.
        //

        BOOLEAN IsPersistent;

        //
        // Indicates that this persistent snapshot was detected, not created.
        //

        BOOLEAN IsDetected;

        //
        // Indicates that there we a need to grow the diff area found when
        // the snapshot was detected.
        //

        BOOLEAN DetectedNeedForGrow;

        //
        // Indicates that the persistent on disk structure has been
        // committed.  Protect with 'NonPagedResource'.
        //

        BOOLEAN OnDiskNotCommitted;

        //
        // Indicates that the device is visible.  Protect with
        //     'Root->Semaphore'.
        //

        BOOLEAN IsVisible;

        //
        // Indicates that no diff area fill is necessary for this persistent
        //     snapshot.

        BOOLEAN NoDiffAreaFill;

        //
        // Indicates that the root semaphore is held.
        //

        BOOLEAN RootSemaphoreHeld;

        //
        // Indicates that this device object is a pre-exposure.
        // Protect with 'Root->Semaphore'.
        //

        BOOLEAN IsPreExposure;

        //
        // Indictates that this snapshot is keeping a reference to
        // 'IgnoreCopyData'.  Protect with 'Root->Semaphore'.
        //

        BOOLEAN IgnoreCopyDataReference;

        //
        // Indicates that the grow failed and whether or not the limit
        // was user imposed.
        //

        BOOLEAN UserImposedLimit;
        LONG GrowFailed;

        //
        // Keep an event here for waiting for the pre-exposure.
        //

        KEVENT PreExposureEvent;

        //
        // Indicates that growing the diff area file is now safe.
        // Protect with 'InterlockedExchange'.
        //

        LONG OkToGrowDiffArea;

        //
        // Time stamp when commit took place.
        //

        LARGE_INTEGER CommitTimeStamp;

        //
        // A list entry for 'Filter->VolumeList'.
        // Write protect with 'Filter->SpinLock', 'Root->Semaphore', and
        //  'Filter->RefCount == 0'.
        // Blink points to an older snapshot.
        // Flink points to a newer snapshot.
        //

        LIST_ENTRY ListEntry;

        //
        // The volume number.
        //

        ULONG VolumeNumber;

        //
        // The devnode number.
        //

        ULONG DevnodeNumber;

        //
        // The volume snapshot GUID.
        //

        GUID SnapshotGuid;

        //
        // The snapshot order number.  Set at commit time.
        //

        LONGLONG SnapshotOrderNumber;

        //
        // A table to translate volume offset to backing store offset.
        // Protect with 'PagedResource'.
        //

        RTL_GENERIC_TABLE VolumeBlockTable;
        RTL_GENERIC_TABLE CopyBackPointerTable;

        //
        // A table to store entries in flight.  This table is non-paged.
        // Protect with 'NonPagedResource'.
        //

        RTL_GENERIC_TABLE TempVolumeBlockTable;
        ULONG MaximumNumberOfTempEntries;
        ULONG DiffAreaFileIncrease;

        //
        // The Diff Area File for this snapshot.
        // Write protect 'DiffAreaFile' pointer with 'NonPagedResource',
        //      'Root->Semaphore', 'RefCount == 0', and
        //      'extension->Filter->RefCount == 0'.
        //

        PVSP_DIFF_AREA_FILE DiffAreaFile;

        //
        // Memory mapped section of a diff area file to be used for a heap.
        // Protect with 'PagedResource'.
        //

        PVOID DiffAreaFileMap;
        ULONG DiffAreaFileMapSize;
        PVOID DiffAreaFileMapProcess;
        ULONG NextAvailable;
        PVOID NextDiffAreaFileMap;
        ULONG NextDiffAreaFileMapSize;
        LIST_ENTRY OldHeaps;

        //
        // A bitmap of blocks that do not need to be copy on writed.
        // Protect with 'SpinLock'.
        //

        PRTL_BITMAP VolumeBlockBitmap;

        //
        // A bitmap product of ignorable blocks from previous snapshots.
        // Protect with 'SpinLock'.
        //

        PRTL_BITMAP IgnorableProduct;

        //
        // Application Information.  Protect with 'PagedResource'.
        //

        ULONG ApplicationInformationSize;
        PVOID ApplicationInformation;

        //
        // Volume size.
        //

        LONGLONG VolumeSize;

        //
        // Emergency copy irp.  Protect with 'SpinLock'.
        //

        PIRP EmergencyCopyIrp;
        LONG EmergencyCopyIrpInUse;
        LIST_ENTRY EmergencyCopyIrpQueue;

        //
        // This field is used to pass a buffer to the TempTableAllocateRoutine.
        // Protect with 'NonPagedResource'.
        //

        PVOID TempTableEntry;

        //
        // These fields are there to help with the lag in creating new
        // page file space.  Non paged pool can be used until the page file
        // space can be acquired.  Protect 'PageFileSpaceCreatePending' and
        // 'WaitingForPageFileSpace' with 'SpinLock'.
        //

        LONG PageFileSpaceCreatePending;
        LIST_ENTRY WaitingForPageFileSpace;

        //
        // Mounted device interface name.
        //

        UNICODE_STRING MountedDeviceInterfaceName;

        //
        // These fields are there to help with the lag in creating new
        // diff area space.  If the diff area volume does not have any
        // snapshots present on it, then a copy on write can block
        // on the arrival on new diff area space.
        //

        BOOLEAN GrowDiffAreaFilePending;
        BOOLEAN PastFileSystemOperations;
        LIST_ENTRY WaitingForDiffAreaSpace;

        //
        // States whether or not this snapshot has the crashdump file.
        //

        BOOLEAN ContainsCrashdumpFile;

        //
        // States whether or not this snapshot has copy on writed the hiber
        // file.  Protect with 'InterlockedExchange'.
        //

        LONG HiberFileCopied;
        LONG PageFileCopied;

        //
        // Keep a list of Write Contexts.  Protect with 'SpinLock'.
        //

        LIST_ENTRY WriteContextList;

        //
        // List entry for deleting the device objects.
        //

        LIST_ENTRY AnotherListEntry;

};

typedef
VOID
(*ZERO_REF_CALLBACK)(
    IN  PFILTER_EXTENSION   Filter
    );

struct _VSP_CONTEXT {

    ULONG           Type;
    WORK_QUEUE_ITEM WorkItem;

    union {
        struct {
            PVOLUME_EXTENSION   Extension;
            PIRP                OriginalReadIrp;
            ULONG_PTR           OriginalReadIrpOffset;
            LONGLONG            OriginalVolumeOffset;
            ULONG               BlockOffset;
            ULONG               Length;
            PDEVICE_OBJECT      TargetObject;
            BOOLEAN             IsCopyTarget;
            LONGLONG            TargetOffset;
        } ReadSnapshot;

        struct {
            PDO_EXTENSION   RootExtension;
            ULONG           QueueNumber;
        } ThreadCreation;

        struct {
            PIO_WORKITEM    IoWorkItem;
            PIRP            Irp;
        } Dispatch;

        struct {
            PVOLUME_EXTENSION   Extension;
            PIRP                Irp;
        } Extension;

        struct {
            PFILTER_EXTENSION   Filter;
            PIRP                Irp;
        } Filter;

        struct {
            PVOLUME_EXTENSION   Extension;
            LIST_ENTRY          ExtentList;
            LONGLONG            Current;
            ULONG               Increase;
            KSPIN_LOCK          SpinLock;
            PLIST_ENTRY         CurrentEntry;
            ULONG               CurrentEntryOffset;
            PDEVICE_OBJECT      TargetObject;
            NTSTATUS            ResultStatus;
            KEVENT              Event;
            LONG                RefCount;
        } GrowDiffArea;

        struct {
            KEVENT  Event;
        } Event;

        struct {
            PVOLUME_EXTENSION   Extension;
            PFILTER_EXTENSION   DiffAreaFilter;
            NTSTATUS            SpecificIoStatus;
            NTSTATUS            FinalStatus;
            ULONG               UniqueErrorValue;
        } ErrorLog;

        struct {
            PDO_EXTENSION   RootExtension;
        } RootExtension;

        struct {
            PVOLUME_EXTENSION   Extension;
            PIRP                Irp;
            LONGLONG            RoundedStart;
        } WriteVolume;

        struct {
            PFILTER_EXTENSION   Filter;
            PKTIMER             Timer;
            PKDPC               Dpc;
        } DeleteDiffAreaFiles;

        struct {
            PFILTER_EXTENSION   Filter;
            BOOLEAN             KeepOnDisk;
            BOOLEAN             SynchronousCall;
        } DestroyAllSnapshots;

        struct {
            PVOLUME_EXTENSION   Extension;
            PIRP                Irp;
            LIST_ENTRY          ExtentList;
            BOOLEAN             HiberfileIncluded;
            BOOLEAN             PagefileIncluded;
        } CopyExtents;

        struct {
            PFILTER_EXTENSION   Filter;
            HANDLE              Handle1;
            HANDLE              Handle2;
        } CloseHandles;

        struct {
            PFILTER_EXTENSION   Filter;
            PIRP                Irp;
        } DismountCleanupOnWrite;

        struct {
            PFILTER_EXTENSION   Filter;
            KDPC                TimerDpc;
            PKTIMER             Timer;
        } PnpWaitTimer;

        struct {
            PFILTER_EXTENSION   Filter;
            PIRP                Irp;
            LONGLONG            RoundedStart;
            LONGLONG            RoundedEnd;
        } CopyOnWrite;
    };
};

#define VSP_CONTEXT_TYPE_READ_SNAPSHOT      (1)
#define VSP_CONTEXT_TYPE_THREAD_CREATION    (2)
#define VSP_CONTEXT_TYPE_DISPATCH           (3)
#define VSP_CONTEXT_TYPE_EXTENSION          (4)
#define VSP_CONTEXT_TYPE_FILTER             (5)
#define VSP_CONTEXT_TYPE_GROW_DIFF_AREA     (6)
#define VSP_CONTEXT_TYPE_EVENT              (7)
#define VSP_CONTEXT_TYPE_ERROR_LOG          (8)
#define VSP_CONTEXT_TYPE_ROOT_EXTENSION     (9)
#define VSP_CONTEXT_TYPE_WRITE_VOLUME       (10)
#define VSP_CONTEXT_TYPE_DELETE_DA_FILES    (11)
#define VSP_CONTEXT_TYPE_DESTROY_SNAPSHOTS  (12)
#define VSP_CONTEXT_TYPE_COPY_EXTENTS       (13)
#define VSP_CONTEXT_TYPE_CLOSE_HANDLES      (14)
#define VSP_CONTEXT_TYPE_DISMOUNT_CLEANUP   (15)
#define VSP_CONTEXT_TYPE_PNP_WAIT_TIMER     (16)
#define VSP_CONTEXT_TYPE_COPY_ON_WRITE      (17)

class FILTER_EXTENSION : public DEVICE_EXTENSION {

    public:

        //
        // The target object for this filter.
        //

        PDEVICE_OBJECT TargetObject;

        //
        // The PDO for this filter.
        //

        PDEVICE_OBJECT Pdo;

        //
        // Do we have any snapshots?  Are they persistent?
        // Write protect with 'InterlockedExchange' and 'Root->Semaphore'.
        //

        LONG SnapshotsPresent;
        LONG PersistentSnapshots;

        //
        // Persistent only fields.
        // Protect 'FirstControlBlockVolumeOffset' with 'NonPagedResource'.
        // Protect 'ControlBlockFileHandle' with 'InterlockedExchange'.
        // Protect 'SnapshotOnDiskIrp' and control file contents with
        //   'NonPagedResource'.
        // Protect '*LookupTableEntries' with 'NonPagedResource'.
        //

        LONGLONG FirstControlBlockVolumeOffset;
        HANDLE ControlBlockFileHandle;
        KSEMAPHORE ControlBlockFileHandleSemaphore;
        PIRP SnapshotOnDiskIrp;
        LIST_ENTRY SnapshotLookupTableEntries;
        LIST_ENTRY DiffAreaLookupTableEntries;
        KEVENT ControlBlockFileHandleReady;

        //
        // Keep track of I/Os so that freeze/thaw is possible.
        // Protect 'RefCount' with 'InterlockedIncrement/Decrement'.
        // Write Protect 'HoldIncomingWrites' with InterlockedIncrement and
        //  'SpinLock'.
        // Protect 'HoldQueue' with 'SpinLock'.
        // Protect 'ZeroRefCallback', 'ZeroRefContext' with the setting
        //  of 'ExternalWaiter' to 1 and 'SpinLock'.
        //

        LONG RefCount;
        LONG HoldIncomingWrites;
        LIST_ENTRY HoldQueue;
        BOOLEAN ExternalWaiter;
        ZERO_REF_CALLBACK ZeroRefCallback;
        PVOID ZeroRefContext;
        KEVENT ZeroRefEvent;
        KSEMAPHORE ZeroRefSemaphore;

        KTIMER HoldWritesTimer;
        KDPC HoldWritesTimerDpc;
        ULONG HoldWritesTimeout;

        //
        // The flush and hold irp is kept here while it is cancellable.
        // Protect with the cancel spin lock.
        //

        PIRP FlushAndHoldIrp;

        //
        // This event indicates that the end commit process is completed.
        // This means that PNP has kicked into gear and that the ignorable
        // bitmap computation has taken place.
        //

        KEVENT EndCommitProcessCompleted;

        //
        // Keep a notification entry on this object to watch for a
        // dismount.  Protect with 'Root->Semaphore'.
        //

        PVOID TargetDeviceNotificationEntry;

        //
        // A list entry for 'Root->FilterList'.
        // Protect these with 'Root->Semaphore'.
        //

        LIST_ENTRY ListEntry;
        BOOLEAN NotInFilterList;

        //
        // Keep a list of snapshot volumes.
        // Write protect with 'Root->Semaphore', 'RefCount == 0', and
        //   'SpinLock'.
        // Flink points to the oldest snapshot.
        // Blink points to the newest snapshot.
        //

        LIST_ENTRY VolumeList;

        //
        // Cache the prepared snapshot for committing later.
        // Write protect with 'SpinLock' and 'Root->Semaphore'.
        //

        PVOLUME_EXTENSION PreparedSnapshot;

        //
        // A semaphore preventing 2 simultaneous critical operations.
        //

        KSEMAPHORE CriticalOperationSemaphore;

        //
        // List of dead snapshot volumes.  Protect with 'Root->Semaphore'.
        //

        LIST_ENTRY DeadVolumeList;

        //
        // List of volume snapshots which depend on this filter for
        // diff area support.  This will serve as removal relations.
        // Protect with 'Root->Semaphore' and 'SpinLock'.
        //

        LIST_ENTRY DiffAreaFilesOnThisFilter;

        //
        // The designated diff area volume that makes up the Diff Area for this
        // volume.
        // Protect with 'Root->Semaphore'.
        //

        PFILTER_EXTENSION DiffAreaVolume;

        //
        // Diff area sizes information total for all diff area files.
        // Protect with 'SpinLock'.
        // Additionally protect 'MaximumVolumeSpace' with 'NonPagedResource'.
        //

        LONGLONG UsedVolumeSpace;
        LONGLONG AllocatedVolumeSpace;
        LONGLONG MaximumVolumeSpace;

        //
        // Timer for completing END_COMMIT if device doesn't install.
        //

        KTIMER EndCommitTimer;
        KDPC EndCommitTimerDpc;

        //
        // File object for AUTO_CLEANUP.  Protect with cancel spin lock.
        //

        PFILE_OBJECT AutoCleanupFileObject;

        //
        // Is a delete all snapshots pending.  Protect with
        // 'InterlockedExchange'.
        //

        LONG DestroyAllSnapshotsPending;
        VSP_CONTEXT DestroyContext;

        //
        // Resource to use for protection.  Don't page when holding this
        // resource.  Protect the queueing with 'SpinLock'.
        //

        LIST_ENTRY NonPagedResourceList;
        BOOLEAN NonPagedResourceInUse;

        //
        // Page resource to use for protection.  It is ok to page when
        // holding this resource.  Protect the queueing with 'SpinLock'.
        //

        LIST_ENTRY PagedResourceList;
        BOOLEAN PagedResourceInUse;

        //
        // Indicates that a snapshot discovery is still pending.  The
        // snapshot discovery will end upon the first write if not
        // all of the pieces make it in time.  Protect with
        // 'InterlockedExchange' and 'RefCount == 0'.
        //

        LONG SnapshotDiscoveryPending;

        //
        // Remember whether or not the underlying volume is online.
        // Protect with 'Root->Semaphore'.
        //

        LONG IsOnline;

        //
        // Remember whether or not remove has been processed.  Protect with
        // 'Root->Semaphore'.
        //

        BOOLEAN IsRemoved;

        //
        // Remember whether or not this volume is used for crashdump.
        // Protect with 'Root->Semaphore'.
        //

        BOOLEAN UsedForCrashdump;

        //
        // Protect with 'InterlockedExchange'.
        //

        LONG UsedForPaging;

        //
        // In the persistent snapshot case on the boot volume, keep a handle
        // to \SystemRoot\bootstat.dat and pin it.  Protect with
        // 'InterlockedExchange'.
        //

        HANDLE BootStatHandle;

        //
        // Indicates that there is a hibernate action pending.  Protect with
        // 'InterlockedExchange'.
        //

        LONG HibernatePending;

        //
        // Indicates that COPY DATA ioctls should be ignored.  Protect with
        // 'InterlockedExchange'.
        //

        LONG IgnoreCopyData;

        //
        // Flag memory pressure to tweak commit and release error codes.
        //

        LONG LastReleaseDueToMemoryPressure;

        //
        // A bitmap that says, if a write comes here then delete all
        // snapshots using this volume.  Set value with 'InterlockedExchange'
        // and protect with 'SpinLock'.
        //

        PRTL_BITMAP ProtectedBlocksBitmap;

        //
        // A list of copy on writes should be kept in non-paged pool
        // for a spell until the diff area volumes all arrive.
        // Protect 'FirstWriteProcessed' with 'SpinLock' and 'Interlocked'
        // Protect 'CopyOnWriteList' with 'SpinLock'.
        // Protect 'PnpWaitTimerContext' with 'SpinLock'.
        // Protect 'ActivateStarted' with 'SpinLock'.
        //

        LONG FirstWriteProcessed;
        LONG ActivateStarted;
        LIST_ENTRY CopyOnWriteList;
        PVSP_CONTEXT PnpWaitTimerContext;

        //
        // A ref count to keep track of pending file system operations
        // on this filter.
        //

        LONG FSRefCount;

        //
        // The delete diff area files timer.  Protect with Critical.
        //

        PKTIMER DeleteTimer;

        //
        // Epic number to avoid queries
        //

        LONG EpicNumber;

};

typedef struct _VSP_WAIT_BLOCK {
    LONG    RefCount;
    KEVENT  Event;
} VSP_WAIT_BLOCK, *PVSP_WAIT_BLOCK;

#define BLOCK_SIZE                          (0x4000)
#define BLOCK_SHIFT                         (14)
#define MINIMUM_TABLE_HEAP_SIZE             (0x20000)
#define MEMORY_PRESSURE_CHECK_ALLOC_SIZE    (0x40000)
#define LARGEST_NTFS_CLUSTER                (0x10000)
#define SMALLEST_NTFS_CLUSTER               (0x200)
#define VSP_HIGH_PRIORITY                   (20)
#define VSP_LOWER_PRIORITY                  (10)
#define VSP_MAX_SNAPSHOTS                   (512)

#define NOMINAL_DIFF_AREA_FILE_GROWTH   (50*1024*1024)
#define MAXIMUM_DIFF_AREA_FILE_GROWTH   (1000*1024*1024)

#define VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY (0x1)

typedef struct _TRANSLATION_TABLE_ENTRY {
    LONGLONG            VolumeOffset;
    PDEVICE_OBJECT      TargetObject;
    ULONG               Flags;
    LONGLONG            TargetOffset;
} TRANSLATION_TABLE_ENTRY, *PTRANSLATION_TABLE_ENTRY;

//
// The structure below is used in the non-paged temp table.  'IsComplete' and
// 'WaitingQueueDpc' are protected with 'extension->SpinLock'.
//

struct _TEMP_TRANSLATION_TABLE_ENTRY {
    LONGLONG            VolumeOffset;
    PVOLUME_EXTENSION   Extension;
    PIRP                WriteIrp;
    PIRP                CopyIrp;
    PDEVICE_OBJECT      TargetObject;
    LONGLONG            TargetOffset;
    BOOLEAN             IsComplete;
    BOOLEAN             InTableUpdateQueue;
    BOOLEAN             IsMoveEntry;
    PKEVENT             WaitEvent;
    LIST_ENTRY          WaitingQueueDpc;    // These can run in arbitrary context.
    WORK_QUEUE_ITEM     WorkItem;

    //
    // Fields used for the persistent implementation.  Protect 'TableUpdate*'
    // with 'Extension->SpinLock'.
    //

    LIST_ENTRY          TableUpdateListEntry;
    LONGLONG            FileOffset;
};

//
// The structure below is used in the persistent snapshot lookup table.
// Protect everything with 'NonPagedResource'.
// Protect 'SnapshotFilter', 'DiffAreaFilter' with 'Root->LookupTableMutex'.
//

typedef struct _VSP_LOOKUP_TABLE_ENTRY {
    GUID                SnapshotGuid;
    PFILTER_EXTENSION   SnapshotFilter;
    PFILTER_EXTENSION   DiffAreaFilter;
    LIST_ENTRY          SnapshotFilterListEntry;
    LIST_ENTRY          DiffAreaFilterListEntry;
    LONGLONG            VolumeSnapshotSize;
    LONGLONG            SnapshotOrderNumber;
    ULONGLONG           SnapshotControlItemFlags;
    LARGE_INTEGER       SnapshotTime;
    LONGLONG            DiffAreaStartingVolumeOffset;
    LONGLONG            ApplicationInfoStartingVolumeOffset;
    LONGLONG            DiffAreaLocationDescriptionVolumeOffset;
    LONGLONG            InitialBitmapVolumeOffset;
    HANDLE              DiffAreaHandle;
} VSP_LOOKUP_TABLE_ENTRY, *PVSP_LOOKUP_TABLE_ENTRY;

//
// Write protect 'VolumeListEntry' with 'NonPagedResource' and
//      'Root->Semaphore'.
// Protect 'FilterListEntry*' with 'Root->Semaphore' and 'Filter->SpinLock'.
// Protect 'NextAvailable' with 'NonPagedResource'
// Write Protect 'AllocatedFileSize' with 'NonPagedResource' and
//      'Root->Semaphore'.
// Protect 'UnusedAllocationList' with 'NonPagedResource'.
//

struct _VSP_DIFF_AREA_FILE {
    LIST_ENTRY          FilterListEntry;
    BOOLEAN             FilterListEntryBeingUsed;
    PVOLUME_EXTENSION   Extension;
    PFILTER_EXTENSION   Filter;
    HANDLE              FileHandle;
    LONGLONG            NextAvailable;
    LONGLONG            AllocatedFileSize;
    LIST_ENTRY          UnusedAllocationList;
    LIST_ENTRY          ListEntry;

    //
    // Fields used for the persistent implementation.  Protect
    // 'TableUpdateQueue' and 'TableUpdateInProgress' with 'Extension->SpinLock'.
    // Whoever sets 'TableUpdateInProgress' to TRUE owns 'TableUpdateIrp',
    // 'NextFreeTableOffset', 'TableTargetOffset', and 'OldTableTargetOffset'.
    // Protect 'IrpNeeded' with 'Extension->SpinLock'.
    // Protect the initialization of 'IrpReady' with non-paged resource.
    // Protect 'ValidateHandleNeeded' with 'Root->Semaphore'.
    //

    PIRP                TableUpdateIrp;
    ULONG               NextFreeTableEntryOffset;
    LONGLONG            ApplicationInfoTargetOffset;
    LONGLONG            DiffAreaLocationDescriptionTargetOffset;
    LONGLONG            InitialBitmapVolumeOffset;
    LONGLONG            FirstTableTargetOffset;
    LONGLONG            TableTargetOffset;
    LONGLONG            NextTableTargetOffset;
    LONGLONG            NextTableFileOffset;
    LIST_ENTRY          TableUpdateQueue;
    BOOLEAN             TableUpdateInProgress;
    BOOLEAN             IrpNeeded;
    BOOLEAN             ValidateHandleNeeded;
    BOOLEAN             NextBlockAllocationInProgress;
    BOOLEAN             NextBlockAllocationComplete;
    NTSTATUS            StatusOfNextBlockAllocate;
    LIST_ENTRY          TableUpdatesInProgress;
    WORK_QUEUE_ITEM     WorkItem;
    KEVENT              IrpReady;
};

typedef struct _DIFF_AREA_FILE_ALLOCATION {
    LIST_ENTRY  ListEntry;
    LONGLONG    Offset;
    LONGLONG    NLength;    // Negative values indicate that the length is unusable.
} DIFF_AREA_FILE_ALLOCATION, *PDIFF_AREA_FILE_ALLOCATION;

typedef struct _OLD_HEAP_ENTRY {
    LIST_ENTRY  ListEntry;
    PVOID       DiffAreaFileMap;
} OLD_HEAP_ENTRY, *POLD_HEAP_ENTRY;

//
// {3808876B-C176-4e48-B7AE-04046E6CC752}
// This GUID is used to decorate the names of the diff area files for
// uniqueness.  This GUID has been included in the list of files not to be
// backed up by NTBACKUP.  If this GUID is changed, or if other GUIDs are
// added, then this change should also be reflected in the NTBACKUP file
// not to be backed up.
//

DEFINE_GUID(VSP_DIFF_AREA_FILE_GUID, 0x3808876b, 0xc176, 0x4e48, 0xb7, 0xae, 0x4, 0x4, 0x6e, 0x6c, 0xc7, 0x52);

//
// The following definitions are for the persistent volume snapshot on disk
// data structures.
//

#define VOLSNAP_PERSISTENT_VERSION  (1)

//
// Block type definitions.
//

#define VSP_BLOCK_TYPE_START                            (1)
#define VSP_BLOCK_TYPE_CONTROL                          (2)
#define VSP_BLOCK_TYPE_DIFF_AREA                        (3)
#define VSP_BLOCK_TYPE_APP_INFO                         (4)
#define VSP_BLOCK_TYPE_DIFF_AREA_LOCATION_DESCRIPTION   (5)
#define VSP_BLOCK_TYPE_INITIAL_BITMAP                   (6)

//
// Common header for all block types.
//

typedef struct _VSP_BLOCK_HEADER {
    GUID        Signature;          // Equal to VSP_DIFF_AREA_FILE_GUID.
    ULONG       Version;            // Equal to VOLSNAP_PERSISTENT_VERSION.
    ULONG       BlockType;          // The type of block.
    LONGLONG    ThisFileOffset;     // The file offset of this block.
    LONGLONG    ThisVolumeOffset;   // The volume offset of this block.
    LONGLONG    NextVolumeOffset;   // The volume offset of the next block.
} VSP_BLOCK_HEADER, *PVSP_BLOCK_HEADER;

//
// Start block definition.  This will be stored in the last sector of the
// NTFS boot file.
//

#define BYTES_IN_BOOT_AREA      (0x2000)
#define VSP_START_BLOCK_OFFSET  (0x1E00)

typedef struct _VSP_BLOCK_START {
    VSP_BLOCK_HEADER    Header;
    LONGLONG            FirstControlBlockVolumeOffset;
    LONGLONG            MaximumDiffAreaSpace;
} VSP_BLOCK_START, *PVSP_BLOCK_START;

//
// Control Item types definition.
//

#define VSP_CONTROL_ITEM_TYPE_END       (0)
#define VSP_CONTROL_ITEM_TYPE_FREE      (1)
#define VSP_CONTROL_ITEM_TYPE_SNAPSHOT  (2)
#define VSP_CONTROL_ITEM_TYPE_DIFF_AREA (3)

//
// Snapshot flags.
//

#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_REVERT_MASTER        (0x1)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_READ_WRITE           (0x2)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_VISIBLE              (0x4)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_CRASHDUMP      (0x8)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_HIBERFIL_COPIED      (0x10)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_PAGEFILE_COPIED      (0x20)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_NO_DIFF_AREA_FILL    (0x40)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_DETECTION      (0x80)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_OFFLINE              (0x100)
#define VSP_SNAPSHOT_CONTROL_ITEM_FLAG_ALL                  (0x1FC)

//
// Control Item for snapshot.
//

typedef struct _VSP_CONTROL_ITEM_SNAPSHOT {
    ULONG           ControlItemType;        // Set to VSP_CONTROL_ITEM_TYPE_SNAPSHOT.
    ULONG           Reserved;
    LONGLONG        VolumeSnapshotSize;
    GUID            SnapshotGuid;
    LONGLONG        SnapshotOrderNumber;
    ULONGLONG       SnapshotControlItemFlags;
    LARGE_INTEGER   SnapshotTime;
} VSP_CONTROL_ITEM_SNAPSHOT, *PVSP_CONTROL_ITEM_SNAPSHOT;

//
// Control Item for diff area file.
//

typedef struct _VSP_CONTROL_ITEM_DIFF_AREA {
    ULONG       ControlItemType;                // Set to VSP_CONTROL_ITEM_TYPE_DIFF_AREA.
    ULONG       Reserved;
    LONGLONG    DiffAreaStartingVolumeOffset;
    GUID        SnapshotGuid;
    LONGLONG    ApplicationInfoStartingVolumeOffset;
    LONGLONG    DiffAreaLocationDescriptionVolumeOffset;
    LONGLONG    InitialBitmapVolumeOffset;
} VSP_CONTROL_ITEM_DIFF_AREA, *PVSP_CONTROL_ITEM_DIFF_AREA;

//
// Number of bytes per control information structure.
//

#define VSP_BYTES_PER_CONTROL_ITEM  (0x80)

//
// Global snapshot flags.
//

#define VSP_CONTROL_BLOCK_FLAG_REVERT_IN_PROGRESS   (0x1)

//
// Control block definition.  These will stored consecutively
// as clusters in "\System Volume Information\{VSP_DIFF_AREA_FILE_GUID}".
//

typedef struct _VSP_BLOCK_CONTROL {
    VSP_BLOCK_HEADER    Header;
} VSP_BLOCK_CONTROL, *PVSP_BLOCK_CONTROL;

//
// The following is the persistent table definition within a diff area file.
//

#define VSP_DIFF_AREA_TABLE_ENTRY_FLAG_MOVE_ENTRY   (0x1)

typedef struct _VSP_BLOCK_DIFF_AREA_TABLE_ENTRY {
    LONGLONG    SnapshotVolumeOffset;
    LONGLONG    DiffAreaFileOffset;
    LONGLONG    DiffAreaVolumeOffset;
    ULONGLONG   Flags;
} VSP_BLOCK_DIFF_AREA_TABLE_ENTRY, *PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY;

//
// Diff area block structure.  The first of these will be stored as the
// second block of the diff area file named
// "\System Volume Information\{SnapshotGuid}{VSP_DIFF_AREA_FILE_GUID}".
//

#define VSP_OFFSET_TO_FIRST_TABLE_ENTRY (0x80)

typedef struct _VSP_BLOCK_DIFF_AREA {
    VSP_BLOCK_HEADER    Header;
} VSP_BLOCK_DIFF_AREA, *PVSP_BLOCK_DIFF_AREA;

//
// App info block structure.  This block will be stored as a block
// of the diff area file named
// "\System Volume Information\{SnapshotGuid}{VSP_DIFF_AREA_FILE_GUID}".
//

#define VSP_OFFSET_TO_APP_INFO          (0x80)
#define VSP_MAX_APP_INFO_SIZE           (BLOCK_SIZE - VSP_OFFSET_TO_APP_INFO)

typedef struct _VSP_BLOCK_APP_INFO {
    VSP_BLOCK_HEADER    Header;
    ULONG               AppInfoSize;
} VSP_BLOCK_APP_INFO, *PVSP_BLOCK_APP_INFO;

//
// The following is the definition of a Diff Area Location Descriptor.
//

typedef struct _VSP_DIFF_AREA_LOCATION_DESCRIPTOR {
    LONGLONG    VolumeOffset;
    LONGLONG    FileOffset;
    LONGLONG    Length;
} VSP_DIFF_AREA_LOCATION_DESCRIPTOR, *PVSP_DIFF_AREA_LOCATION_DESCRIPTOR;

//
// Diff Area File Location Description block structure.  This block will
// be stored as a block of the diff area file named
// "\System Volume Information\{SnapshotGuid}{VSP_DIFF_AREA_FILE_GUID}".
//

#define VSP_OFFSET_TO_FIRST_LOCATION_DESCRIPTOR (0x80)

typedef struct _VSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION {
    VSP_BLOCK_HEADER    Header;
} VSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION, *PVSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION;

//
// Initial Bitmap block structure.  This block will be stored as a block of
// the diff area file named
// "\System Volume Information\{SnapshotGuid}{VSP_DIFF_AREA_FILE_GUID}".
//

#define VSP_OFFSET_TO_START_OF_BITMAP           (0x80)

typedef struct _VSP_BLOCK_INITIAL_BITMAP {
    VSP_BLOCK_HEADER    Header;
} VSP_BLOCK_INITIAL_BITMAP, *PVSP_BLOCK_INITIAL_BITMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\driver\volsnap.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    volsnap.cxx

Abstract:

    This driver provides volume snapshot capabilities.

Author:

    Norbert P. Kusters  (norbertk)  22-Jan-1999

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {

#define RTL_USE_AVL_TABLES 0

#include <stdio.h>
#include <ntosp.h>
#include <zwapi.h>
#include <snaplog.h>
#include <initguid.h>
#include <ntddsnap.h>
#include <volsnap.h>
#include <mountdev.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <ioevent.h>
#include <wdmguid.h>

#ifndef IRP_HIGH_PRIORITY_PAGING_IO
#define IRP_HIGH_PRIORITY_PAGING_IO     0x00008000
#endif

#if defined(_WIN64)
#define ERROR_LOG_ENTRY_SIZE    (0x30)
#else
#define ERROR_LOG_ENTRY_SIZE    (0x20)
#endif

static const SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTKERNELAPI
KPRIORITY
KeQueryPriorityThread (
    IN PKTHREAD Thread
    );

BOOLEAN
VspIsSetup(
    );

}

#define OLD_IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS      CTL_CODE(VOLSNAPCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
#define OLD_IOCTL_VOLSNAP_QUERY_DIFF_AREA               CTL_CODE(VOLSNAPCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS)
#define OLD_IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES         CTL_CODE(VOLSNAPCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define OLD_IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME    CTL_CODE(VOLSNAPCONTROLTYPE, 100, METHOD_BUFFERED, FILE_READ_ACCESS)
#define OLD_IOCTL_VOLSNAP_QUERY_CONFIG_INFO             CTL_CODE(VOLSNAPCONTROLTYPE, 101, METHOD_BUFFERED, FILE_READ_ACCESS)
#define OLD_IOCTL_VOLSNAP_QUERY_APPLICATION_INFO        CTL_CODE(VOLSNAPCONTROLTYPE, 103, METHOD_BUFFERED, FILE_READ_ACCESS)

ULONG VsErrorLogSequence = 0;

VOID
VspWriteVolume(
    IN  PVOID   Context
    );

VOID
VspWorkerThread(
    IN  PVOID   RootExtension
    );

VOID
VspCleanupInitialSnapshot(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             NeedLock,
    IN  BOOLEAN             IsFinalRemove
    );

VOID
VspWriteVolumePhase1(
    IN  PVOID   TableEntry
    );

VOID
VspFreeCopyIrp(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                CopyIrp
    );

NTSTATUS
VspAbortPreparedSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  BOOLEAN             NeedLock,
    IN  BOOLEAN             IsFinalRemove
    );

NTSTATUS
VspReleaseWrites(
    IN  PFILTER_EXTENSION   Filter
    );

NTSTATUS
VspSetApplicationInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
VspWriteContextCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Filter
    );

NTSTATUS
VspRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Filter
    );

VOID
VspCleanupFilter(
    IN  PFILTER_EXTENSION   Filter,
    IN  BOOLEAN             IsOffline,
    IN  BOOLEAN             IsFinalRemove
    );

VOID
VspDecrementRefCount(
    IN  PFILTER_EXTENSION   Filter
    );

NTSTATUS
VspSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    );

NTSTATUS
VspMarkFreeSpaceInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              UseThisHandle,
    IN  PRTL_BITMAP         BitmapToSet
    );

VOID
VspAndBitmaps(
    IN OUT  PRTL_BITMAP BaseBitmap,
    IN      PRTL_BITMAP FactorBitmap
    );

NTSTATUS
VspDeleteOldestSnapshot(
    IN      PFILTER_EXTENSION   Filter,
    IN OUT  PLIST_ENTRY         ListOfDiffAreaFilesToClose,
    IN OUT  PLIST_ENTRY         LisfOfDeviceObjectsToDelete,
    IN      BOOLEAN             KeepOnDisk,
    IN      BOOLEAN             DontWakePnp
    );

VOID
VspCloseDiffAreaFiles(
    IN  PLIST_ENTRY ListOfDiffAreaFilesToClose,
    IN  PLIST_ENTRY ListOfDeviceObjectsToDelete
    );

NTSTATUS
VspComputeIgnorableProduct(
    IN  PVOLUME_EXTENSION   Extension
    );

NTSTATUS
VspIoControlItem(
    IN      PFILTER_EXTENSION   Filter,
    IN      ULONG               ControlItemType,
    IN      GUID*               SnapshotGuid,
    IN      BOOLEAN             IsSet,
    IN OUT  PVOID               ControlItem,
    IN      BOOLEAN             AcquireLock
    );

NTSTATUS
VspCleanupControlItemsForSnapshot(
    IN  PVOLUME_EXTENSION   Extension
    );

VOID
VspWriteTableUpdates(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    );

VOID
VspKillTableUpdates(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    );

NTSTATUS
VspAllocateDiffAreaSpace(
    IN      PVOLUME_EXTENSION           Extension,
    OUT     PLONGLONG                   TargetOffset,
    OUT     PLONGLONG                   FileOffset,
    IN OUT  PDIFF_AREA_FILE_ALLOCATION* CurrentFileAllocation,
    IN OUT  PLONGLONG                   CurrentOffset
    );

VOID
VspResumeVolumeIo(
    IN  PFILTER_EXTENSION   Filter
    );

VOID
VspPauseVolumeIo(
    IN  PFILTER_EXTENSION   Filter
    );

NTSTATUS
VspCreateDiffAreaFileName(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PVOLUME_EXTENSION   Extension,
    OUT PUNICODE_STRING     DiffAreaFileName,
    IN  BOOLEAN             ValidateSystemVolumeInformationFolder,
    IN  GUID*               SnapshotGuid
    );

VOID
VspDeleteDiffAreaFilesTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
VspAcquireNonPagedResource(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PWORK_QUEUE_ITEM    WorkItem,
    IN  BOOLEAN             AlwaysPost
    );

VOID
VspReleaseNonPagedResource(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
VspDeleteControlItemsWithGuid(
    IN  PFILTER_EXTENSION   Filter,
    IN  GUID*               SnapshotGuid,
    IN  BOOLEAN             NonPagedResourceHeld
    );

NTSTATUS
VspCreateStartBlock(
    IN  PFILTER_EXTENSION   Filter,
    IN  LONGLONG            ControlBlockOffset,
    IN  LONGLONG            MaximumDiffAreaSpace
    );

NTSTATUS
VspPinFile(
    IN  PDEVICE_OBJECT  TargetObject,
    IN  HANDLE          FileHandle
    );

NTSTATUS
VspReadDiffAreaTable(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    );

PVSP_LOOKUP_TABLE_ENTRY
VspFindLookupTableItem(
    IN  PDO_EXTENSION   RootExtension,
    IN  GUID*           SnapshotGuid
    );

BOOLEAN
VspIsNtfsBootSector(
    IN  PFILTER_EXTENSION   Filter,
    IN  PVOID               BootSector
    );

NTSTATUS
VspIsNtfs(
    IN  HANDLE      FileHandle,
    OUT PBOOLEAN    IsNtfs
    );

NTSTATUS
VspOptimizeDiffAreaFileLocation(
    IN  PFILTER_EXTENSION   Filter,
    IN  HANDLE              FileHandle,
    IN  PVOLUME_EXTENSION   BitmapExtension,
    IN  LONGLONG            StartingOffset,
    IN  LONGLONG            FileSize
    );

VOID
VspReadSnapshotPhase1(
    IN  PVOID   Context
    );

VOID
VspWriteVolumePhase12(
    IN  PVOID   TableEntry
    );

NTSTATUS
VspComputeIgnorableBitmap(
    IN      PVOLUME_EXTENSION   Extension,
    IN OUT  PRTL_BITMAP         Bitmap
    );

NTSTATUS
VspMarkFileAllocationInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              FileHandle,
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile,
    IN  PRTL_BITMAP         BitmapToSet
    );

NTSTATUS
VolSnapWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
VspStartCopyOnWrite(
    IN  PVOID   Context
    );

VOID
VspOnlineWorker(
    IN  PVOID   Context
    );

VOID
VspOfflineWorker(
    IN  PVOID   Context
    );

VOID
VspStartCopyOnWriteCache(
    IN  PVOID   Filter
    );

VOID
VspQueueLowPriorityWorkItem(
    IN  PDO_EXTENSION       RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    );

VOID
VspCleanupPreamble(
    IN  PFILTER_EXTENSION   Filter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, VspIsSetup)
#endif

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif


VOID
VspAcquire(
    IN  PDO_EXTENSION   RootExtension
    )

{
    KeWaitForSingleObject(&RootExtension->Semaphore, Executive, KernelMode,
                          FALSE, NULL);
}

VOID
VspRelease(
    IN  PDO_EXTENSION   RootExtension
    )

{
    KeReleaseSemaphore(&RootExtension->Semaphore, IO_NO_INCREMENT, 1, FALSE);
}

VOID
VspAcquireCritical(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KeWaitForSingleObject(&Filter->CriticalOperationSemaphore, Executive,
                          KernelMode, FALSE, NULL);
}

VOID
VspReleaseCritical(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KeReleaseSemaphore(&Filter->CriticalOperationSemaphore, IO_NO_INCREMENT, 1, FALSE);
}

PVSP_CONTEXT
VspAllocateContext(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PVSP_CONTEXT    context;

    context = (PVSP_CONTEXT) ExAllocateFromNPagedLookasideList(
              &RootExtension->ContextLookasideList);

    return context;
}

VOID
VspFreeContext(
    IN  PDO_EXTENSION   RootExtension,
    IN  PVSP_CONTEXT    Context
    )

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    if (RootExtension->EmergencyContext == Context) {
        KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
        RootExtension->EmergencyContextInUse = FALSE;
        if (IsListEmpty(&RootExtension->IrpWaitingList)) {
            InterlockedExchange(&RootExtension->IrpWaitingListNeedsChecking,
                                FALSE);
            KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
            return;
        }
        l = RemoveHeadList(&RootExtension->IrpWaitingList);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        RootExtension->DriverObject->MajorFunction[irpSp->MajorFunction](
                irpSp->DeviceObject, irp);
        return;
    }

    ExFreeToNPagedLookasideList(&RootExtension->ContextLookasideList,
                                Context);

    if (!RootExtension->IrpWaitingListNeedsChecking) {
        return;
    }

    KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
    if (IsListEmpty(&RootExtension->IrpWaitingList)) {
        InterlockedExchange(&RootExtension->IrpWaitingListNeedsChecking,
                            FALSE);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
        return;
    }
    l = RemoveHeadList(&RootExtension->IrpWaitingList);
    KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

    irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
    irpSp = IoGetCurrentIrpStackLocation(irp);
    RootExtension->DriverObject->MajorFunction[irpSp->MajorFunction](
            irpSp->DeviceObject, irp);
}

PVSP_WRITE_CONTEXT
VspAllocateWriteContext(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PVSP_WRITE_CONTEXT  writeContext;

    writeContext = (PVSP_WRITE_CONTEXT) ExAllocateFromNPagedLookasideList(
                   &RootExtension->WriteContextLookasideList);

    return writeContext;
}

VOID
VspFreeWriteContext(
    IN  PDO_EXTENSION       RootExtension,
    IN  PVSP_WRITE_CONTEXT  WriteContext
    )

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    if (RootExtension->EmergencyWriteContext == WriteContext) {
        KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
        RootExtension->EmergencyWriteContextInUse = FALSE;
        if (IsListEmpty(&RootExtension->WriteContextIrpWaitingList)) {
            InterlockedExchange(
                    &RootExtension->WriteContextIrpWaitingListNeedsChecking,
                    FALSE);
            KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
            return;
        }
        l = RemoveHeadList(&RootExtension->WriteContextIrpWaitingList);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        RootExtension->DriverObject->MajorFunction[irpSp->MajorFunction](
                irpSp->DeviceObject, irp);
        return;
    }

    ExFreeToNPagedLookasideList(&RootExtension->WriteContextLookasideList,
                                WriteContext);

    if (!RootExtension->WriteContextIrpWaitingListNeedsChecking) {
        return;
    }

    KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
    if (IsListEmpty(&RootExtension->WriteContextIrpWaitingList)) {
        InterlockedExchange(
                &RootExtension->WriteContextIrpWaitingListNeedsChecking,
                FALSE);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
        return;
    }
    l = RemoveHeadList(&RootExtension->WriteContextIrpWaitingList);
    KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

    irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
    irpSp = IoGetCurrentIrpStackLocation(irp);
    RootExtension->DriverObject->MajorFunction[irpSp->MajorFunction](
            irpSp->DeviceObject, irp);
}

PVOID
VspAllocateTempTableEntry(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PVOID   tempTableEntry;

    tempTableEntry = ExAllocateFromNPagedLookasideList(
                     &RootExtension->TempTableEntryLookasideList);

    return tempTableEntry;
}

VOID
VspQueueWorkItem(
    IN  PDO_EXTENSION       RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem,
    IN  ULONG               QueueNumber
    )

{
    KIRQL   irql;

    ASSERT(QueueNumber < NUMBER_OF_THREAD_POOLS);

    KeAcquireSpinLock(&RootExtension->SpinLock[QueueNumber], &irql);
    InsertTailList(&RootExtension->WorkerQueue[QueueNumber], &WorkItem->List);
    KeReleaseSpinLock(&RootExtension->SpinLock[QueueNumber], irql);

    KeReleaseSemaphore(&RootExtension->WorkerSemaphore[QueueNumber],
                       IO_NO_INCREMENT, 1, FALSE);
}

VOID
VspFreeTempTableEntry(
    IN  PDO_EXTENSION   RootExtension,
    IN  PVOID           TempTableEntry
    )

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    if (RootExtension->EmergencyTableEntry == TempTableEntry) {
        KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
        RootExtension->EmergencyTableEntryInUse = FALSE;
        if (IsListEmpty(&RootExtension->WorkItemWaitingList)) {
            InterlockedExchange(
                    &RootExtension->WorkItemWaitingListNeedsChecking, FALSE);
            KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
            return;
        }
        l = RemoveHeadList(&RootExtension->WorkItemWaitingList);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        VspQueueWorkItem(RootExtension, workItem, 2);
        return;
    }

    ExFreeToNPagedLookasideList(&RootExtension->TempTableEntryLookasideList,
                                TempTableEntry);

    if (!RootExtension->WorkItemWaitingListNeedsChecking) {
        return;
    }

    KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
    if (IsListEmpty(&RootExtension->WorkItemWaitingList)) {
        InterlockedExchange(&RootExtension->WorkItemWaitingListNeedsChecking,
                            FALSE);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
        return;
    }
    l = RemoveHeadList(&RootExtension->WorkItemWaitingList);
    KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    VspQueueWorkItem(RootExtension, workItem, 2);
}

VOID
VspLogErrorWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION       extension = context->ErrorLog.Extension;
    PFILTER_EXTENSION       diffAreaFilter = context->ErrorLog.DiffAreaFilter;
    PFILTER_EXTENSION       filter;
    NTSTATUS                status;
    UNICODE_STRING          filterDosName, diffAreaFilterDosName;
    USHORT                  systemStringLength, myStringLength, allocSize;
    USHORT                  allStringsLimit;
    USHORT                  limit;
    WCHAR                   buffer[100];
    UNICODE_STRING          deviceName;
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    PWCHAR                  p;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_ERROR_LOG);

    if (extension) {
        filter = extension->Filter;
    } else {
        filter = diffAreaFilter;
        diffAreaFilter = NULL;
    }

    status = IoVolumeDeviceToDosName(filter->DeviceObject, &filterDosName);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }
    myStringLength = filterDosName.Length + sizeof(WCHAR);

    if (diffAreaFilter) {
        status = IoVolumeDeviceToDosName(diffAreaFilter->DeviceObject,
                                         &diffAreaFilterDosName);
        if (!NT_SUCCESS(status)) {
            ExFreePool(filterDosName.Buffer);
            goto Cleanup;
        }
        myStringLength += diffAreaFilterDosName.Length + sizeof(WCHAR);
    }

    systemStringLength = 8*sizeof(WCHAR); // Space required for VOLSNAP driver name.

    if (extension) {
        swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&deviceName, buffer);
        systemStringLength += deviceName.Length + sizeof(WCHAR);
    } else {
        systemStringLength += sizeof(WCHAR);
    }

    limit = ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET);
    allStringsLimit = IO_ERROR_LOG_MESSAGE_LENGTH -
                      sizeof(IO_ERROR_LOG_MESSAGE) - ERROR_LOG_ENTRY_SIZE;

    ASSERT(allStringsLimit > systemStringLength);

    if (limit > allStringsLimit - systemStringLength) {
        limit = allStringsLimit - systemStringLength;
    }

    if (myStringLength > limit) {
        if (diffAreaFilter) {
            limit /= 2;
        }
        limit &= ~1;
        limit -= sizeof(WCHAR);

        if (filterDosName.Length > limit) {
            filterDosName.Buffer[3] = '.';
            filterDosName.Buffer[4] = '.';
            filterDosName.Buffer[5] = '.';

            RtlMoveMemory(&filterDosName.Buffer[6],
                          (PCHAR) filterDosName.Buffer + filterDosName.Length -
                          limit + 6*sizeof(WCHAR), limit - 6*sizeof(WCHAR));

            filterDosName.Length = limit;
            filterDosName.Buffer[filterDosName.Length/sizeof(WCHAR)] = 0;
        }

        if (diffAreaFilter && diffAreaFilterDosName.Length > limit) {
            diffAreaFilterDosName.Buffer[3] = '.';
            diffAreaFilterDosName.Buffer[4] = '.';
            diffAreaFilterDosName.Buffer[5] = '.';

            RtlMoveMemory(&diffAreaFilterDosName.Buffer[6],
                          (PCHAR) diffAreaFilterDosName.Buffer +
                          diffAreaFilterDosName.Length - limit +
                          6*sizeof(WCHAR), limit - 6*sizeof(WCHAR));

            diffAreaFilterDosName.Length = limit;
            diffAreaFilterDosName.Buffer[
                    diffAreaFilterDosName.Length/sizeof(WCHAR)] = 0;
        }
    }

    errorLogPacket = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(extension ?
                     extension->DeviceObject : filter->DeviceObject,
                     ERROR_LOG_MAXIMUM_SIZE);
    if (!errorLogPacket) {
        if (diffAreaFilter) {
            ExFreePool(diffAreaFilterDosName.Buffer);
        }
        ExFreePool(filterDosName.Buffer);
        goto Cleanup;
    }

    errorLogPacket->ErrorCode = context->ErrorLog.SpecificIoStatus;
    errorLogPacket->SequenceNumber = VsErrorLogSequence++;
    errorLogPacket->FinalStatus = context->ErrorLog.FinalStatus;
    errorLogPacket->UniqueErrorValue = context->ErrorLog.UniqueErrorValue;
    errorLogPacket->DumpDataSize = 0;
    errorLogPacket->RetryCount = 0;

    errorLogPacket->NumberOfStrings = 1;
    errorLogPacket->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET));
    RtlCopyMemory(p, filterDosName.Buffer, filterDosName.Length);
    p[filterDosName.Length/sizeof(WCHAR)] = 0;

    if (diffAreaFilter) {
        errorLogPacket->NumberOfStrings = 2;
        p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET) +
                      filterDosName.Length + sizeof(WCHAR));
        RtlCopyMemory(p, diffAreaFilterDosName.Buffer,
                      diffAreaFilterDosName.Length);
        p[diffAreaFilterDosName.Length/sizeof(WCHAR)] = 0;
    }

    IoWriteErrorLogEntry(errorLogPacket);

    if (diffAreaFilter) {
        ExFreePool(diffAreaFilterDosName.Buffer);
    }

    ExFreePool(filterDosName.Buffer);

Cleanup:
    VspFreeContext(filter->Root, context);
    if (extension) {
        ObDereferenceObject(extension->DeviceObject);
    }
    ObDereferenceObject(filter->TargetObject);
    ObDereferenceObject(filter->DeviceObject);
    if (diffAreaFilter) {
        ObDereferenceObject(diffAreaFilter->TargetObject);
        ObDereferenceObject(diffAreaFilter->DeviceObject);
    }
}

VOID
VspLogError(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PFILTER_EXTENSION   DiffAreaFilter,
    IN  NTSTATUS            SpecificIoStatus,
    IN  NTSTATUS            FinalStatus,
    IN  ULONG               UniqueErrorValue,
    IN  BOOLEAN             PerformSynchronously
    )

{
    PDO_EXTENSION   root;
    PVSP_CONTEXT    context;

    if (FinalStatus == STATUS_DEVICE_OFF_LINE) {
        return;
    }

    if (Extension) {
        root = Extension->Root;
    } else {
        root = DiffAreaFilter->Root;
    }

    context = VspAllocateContext(root);
    if (!context) {
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_ERROR_LOG;
    context->ErrorLog.Extension = Extension;
    context->ErrorLog.DiffAreaFilter = DiffAreaFilter;
    context->ErrorLog.SpecificIoStatus = SpecificIoStatus;
    context->ErrorLog.FinalStatus = FinalStatus;
    context->ErrorLog.UniqueErrorValue = UniqueErrorValue;

    if (Extension) {
        ObReferenceObject(Extension->DeviceObject);
        ObReferenceObject(Extension->Filter->DeviceObject);
        ObReferenceObject(Extension->Filter->TargetObject);
    }

    if (DiffAreaFilter) {
        ObReferenceObject(DiffAreaFilter->DeviceObject);
        ObReferenceObject(DiffAreaFilter->TargetObject);
    }

    if (PerformSynchronously) {
        VspLogErrorWorker(context);
        return;
    }

    ExInitializeWorkItem(&context->WorkItem, VspLogErrorWorker, context);
    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

VOID
VspWaitForWorkerThreadsToExit(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PVOID   threadObject;
    CCHAR   i, j;

    if (!RootExtension->WorkerThreadObjects ||
        RootExtension->ThreadsRefCount) {

        return;
    }

    threadObject = RootExtension->WorkerThreadObjects[0];
    KeWaitForSingleObject(threadObject, Executive, KernelMode, FALSE, NULL);
    ObDereferenceObject(threadObject);

    for (i = 1; i < NUMBER_OF_THREAD_POOLS; i++) {
        for (j = 0; j < KeNumberProcessors; j++) {
            threadObject = RootExtension->WorkerThreadObjects[
                           (i - 1)*KeNumberProcessors + j + 1];
            KeWaitForSingleObject(threadObject, Executive, KernelMode, FALSE,
                                  NULL);
            ObDereferenceObject(threadObject);
        }
    }

    ExFreePool(RootExtension->WorkerThreadObjects);
    RootExtension->WorkerThreadObjects = NULL;
}

NTSTATUS
VspCreateWorkerThread(
    IN  PDO_EXTENSION   RootExtension
    )

/*++

Routine Description:

    This routine will create a new thread for a new volume snapshot.  Since
    a minimum of 2 threads are needed to prevent deadlocks, if there are
    no threads then 2 threads will be created by this routine.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    NTSTATUS

Notes:

    The caller must be holding 'Root->Semaphore'.

--*/

{
    OBJECT_ATTRIBUTES   oa;
    PVSP_CONTEXT        context;
    NTSTATUS            status;
    HANDLE              handle;
    PVOID               threadObject;
    CCHAR               i, j, k;

    KeWaitForSingleObject(&RootExtension->ThreadsRefCountSemaphore,
                          Executive, KernelMode, FALSE, NULL);

    if (RootExtension->ThreadsRefCount) {
        RootExtension->ThreadsRefCount++;
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    VspWaitForWorkerThreadsToExit(RootExtension);

    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    context = VspAllocateContext(RootExtension);
    if (!context) {
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_THREAD_CREATION;
    context->ThreadCreation.RootExtension = RootExtension;
    context->ThreadCreation.QueueNumber = 0;

    ASSERT(!RootExtension->WorkerThreadObjects);
    RootExtension->WorkerThreadObjects = (PVOID*)
            ExAllocatePoolWithTag(NonPagedPool,
                                  (KeNumberProcessors*2 + 1)*sizeof(PVOID),
                                  VOLSNAP_TAG_IO_STATUS);
    if (!RootExtension->WorkerThreadObjects) {
        VspFreeContext(RootExtension, context);
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = PsCreateSystemThread(&handle, 0, &oa, 0, NULL, VspWorkerThread,
                                  context);
    if (!NT_SUCCESS(status)) {
        ExFreePool(RootExtension->WorkerThreadObjects);
        RootExtension->WorkerThreadObjects = NULL;
        VspFreeContext(RootExtension, context);
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    status = ObReferenceObjectByHandle(handle, THREAD_ALL_ACCESS, NULL,
                                       KernelMode, &threadObject, NULL);
    if (!NT_SUCCESS(status)) {
        KeReleaseSemaphore(&RootExtension->WorkerSemaphore[0],
                           IO_NO_INCREMENT, 1, FALSE);
        ZwWaitForSingleObject(handle, FALSE, NULL);
        ExFreePool(RootExtension->WorkerThreadObjects);
        RootExtension->WorkerThreadObjects = NULL;
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }
    RootExtension->WorkerThreadObjects[0] = threadObject;
    ZwClose(handle);

    for (i = 1; i < NUMBER_OF_THREAD_POOLS; i++) {
        for (j = 0; j < KeNumberProcessors; j++) {
            context = VspAllocateContext(RootExtension);
            if (!context) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                handle = NULL;
                break;
            }

            context->Type = VSP_CONTEXT_TYPE_THREAD_CREATION;
            context->ThreadCreation.RootExtension = RootExtension;
            context->ThreadCreation.QueueNumber = i;

            status = PsCreateSystemThread(&handle, 0, &oa, 0, NULL,
                                          VspWorkerThread, context);
            if (!NT_SUCCESS(status)) {
                VspFreeContext(RootExtension, context);
                handle = NULL;
                break;
            }

            status = ObReferenceObjectByHandle(
                     handle, THREAD_ALL_ACCESS, NULL, KernelMode,
                     &threadObject, NULL);

            if (!NT_SUCCESS(status)) {
                break;
            }

            RootExtension->WorkerThreadObjects[
                    KeNumberProcessors*(i - 1) + j + 1] = threadObject;
            ZwClose(handle);
        }
        if (j < KeNumberProcessors) {
            KeReleaseSemaphore(&RootExtension->WorkerSemaphore[i],
                               IO_NO_INCREMENT, j, FALSE);
            if (handle) {
                KeReleaseSemaphore(&RootExtension->WorkerSemaphore[i],
                                   IO_NO_INCREMENT, 1, FALSE);
                ZwWaitForSingleObject(handle, FALSE, NULL);
                ZwClose(handle);
            }
            for (k = 0; k < j; k++) {
                threadObject = RootExtension->WorkerThreadObjects[
                               KeNumberProcessors*(i - 1) + k + 1];
                KeWaitForSingleObject(threadObject, Executive, KernelMode,
                                      FALSE, NULL);
                ObDereferenceObject(threadObject);
            }
            break;
        }
    }
    if (i < NUMBER_OF_THREAD_POOLS) {
        for (k = 1; k < i; k++) {
            KeReleaseSemaphore(&RootExtension->WorkerSemaphore[k],
                               IO_NO_INCREMENT, KeNumberProcessors, FALSE);
            for (j = 0; j < KeNumberProcessors; j++) {
                threadObject = RootExtension->WorkerThreadObjects[
                               KeNumberProcessors*(k - 1) + j + 1];
                KeWaitForSingleObject(threadObject, Executive, KernelMode,
                                      FALSE, NULL);
                ObDereferenceObject(threadObject);
            }
        }

        KeReleaseSemaphore(&RootExtension->WorkerSemaphore[0],
                           IO_NO_INCREMENT, 1, FALSE);
        threadObject = RootExtension->WorkerThreadObjects[0];
        KeWaitForSingleObject(threadObject, Executive, KernelMode, FALSE, NULL);
        ObDereferenceObject(threadObject);

        ExFreePool(RootExtension->WorkerThreadObjects);
        RootExtension->WorkerThreadObjects = NULL;

        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);

        return status;
    }

    RootExtension->ThreadsRefCount++;

    KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);

    return STATUS_SUCCESS;
}

VOID
VspWaitForWorkerThreadsToExitWorker(
    IN  PVOID   RootExtension
    )

{
    PDO_EXTENSION   rootExtension = (PDO_EXTENSION) RootExtension;

    KeWaitForSingleObject(&rootExtension->ThreadsRefCountSemaphore,
                          Executive, KernelMode, FALSE, NULL);
    VspWaitForWorkerThreadsToExit(rootExtension);
    rootExtension->WaitForWorkerThreadsToExitWorkItemInUse = FALSE;
    KeReleaseSemaphore(&rootExtension->ThreadsRefCountSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);
}

NTSTATUS
VspDeleteWorkerThread(
    IN  PDO_EXTENSION   RootExtension
    )

/*++

Routine Description:

    This routine will delete a worker thread.

Arguments:

    RootExtension   - Supplies the root extension.

Return Value:

    NTSTATUS

Notes:

    The caller must be holding 'Root->Semaphore'.

--*/

{
    CCHAR   i, j;

    KeWaitForSingleObject(&RootExtension->ThreadsRefCountSemaphore,
                          Executive, KernelMode, FALSE, NULL);

    RootExtension->ThreadsRefCount--;
    if (RootExtension->ThreadsRefCount) {
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    KeReleaseSemaphore(&RootExtension->WorkerSemaphore[0], IO_NO_INCREMENT, 1,
                       FALSE);

    for (i = 1; i < NUMBER_OF_THREAD_POOLS; i++) {
        KeReleaseSemaphore(&RootExtension->WorkerSemaphore[i], IO_NO_INCREMENT,
                           KeNumberProcessors, FALSE);
    }

    if (RootExtension->WaitForWorkerThreadsToExitWorkItemInUse) {
        KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    RootExtension->WaitForWorkerThreadsToExitWorkItemInUse = TRUE;
    ExInitializeWorkItem(&RootExtension->WaitForWorkerThreadsToExitWorkItem,
                         VspWaitForWorkerThreadsToExitWorker, RootExtension);
    ExQueueWorkItem(&RootExtension->WaitForWorkerThreadsToExitWorkItem,
                    DelayedWorkQueue);

    KeReleaseSemaphore(&RootExtension->ThreadsRefCountSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);

    return STATUS_SUCCESS;
}

VOID
VspQueryDiffAreaFileIncrease(
    IN  PVOLUME_EXTENSION   Extension,
    OUT PULONG              Increase
    )

{
    LONGLONG    r;

    r = (LONGLONG) Extension->MaximumNumberOfTempEntries;
    r <<= BLOCK_SHIFT;
    r = (r + LARGEST_NTFS_CLUSTER - 1)&(~(LARGEST_NTFS_CLUSTER - 1));
    if (r < NOMINAL_DIFF_AREA_FILE_GROWTH) {
        r = NOMINAL_DIFF_AREA_FILE_GROWTH;
    } else if (r > MAXIMUM_DIFF_AREA_FILE_GROWTH) {
        r = MAXIMUM_DIFF_AREA_FILE_GROWTH;
    }

    *Increase = (ULONG) r;
}

NTSTATUS
VolSnapDefaultDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the default dispatch which passes down to the next layer.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    if (irpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {
        status = Irp->IoStatus.Status;
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

BOOLEAN
VspAreBitsClear(
    IN  PRTL_BITMAP Bitmap,
    IN  PIRP        Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    LONGLONG            start;
    ULONG               startBlock, endBlock;
    BOOLEAN             b;

    start = irpSp->Parameters.Read.ByteOffset.QuadPart;
    if (start < 0) {
        return FALSE;
    }

    startBlock = (ULONG) (start >> BLOCK_SHIFT);
    endBlock = (ULONG) ((start + irpSp->Parameters.Read.Length - 1) >>
                        BLOCK_SHIFT);

    b = RtlAreBitsClear(Bitmap, startBlock, endBlock - startBlock + 1);

    return b;
}

BOOLEAN
VspAreBitsSet(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    LONGLONG            start;
    ULONG               startBlock, endBlock;
    BOOLEAN             b;

    if (!Extension->VolumeBlockBitmap) {
        return FALSE;
    }

    start = irpSp->Parameters.Read.ByteOffset.QuadPart;
    if (start < 0) {
        return FALSE;
    }

    startBlock = (ULONG) (start >> BLOCK_SHIFT);
    endBlock = (ULONG) ((start + irpSp->Parameters.Read.Length - 1) >>
                        BLOCK_SHIFT);

    b = RtlAreBitsSet(Extension->VolumeBlockBitmap, startBlock,
                      endBlock - startBlock + 1);

    return b;
}

VOID
VspDecrementVolumeRefCount(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    if (InterlockedDecrement(&Extension->RefCount)) {
        return;
    }

    ASSERT(Extension->HoldIncomingRequests);

    KeSetEvent(&Extension->ZeroRefEvent, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
VspIncrementVolumeRefCount(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    InterlockedIncrement(&Extension->RefCount);

    if (Extension->IsDead) {
        VspDecrementVolumeRefCount(Extension);
        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(!Extension->HoldIncomingRequests);

    return STATUS_SUCCESS;
}

VOID
VspSignalContext(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT    context = (PVSP_CONTEXT) Context;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EVENT);

    KeSetEvent(&context->Event.Event, IO_NO_INCREMENT, FALSE);
}

VOID
VspAcquirePagedResource(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    KIRQL               irql;
    VSP_CONTEXT         context;
    BOOLEAN             synchronousCall;

    if (WorkItem) {
        synchronousCall = FALSE;
    } else {
        WorkItem = &context.WorkItem;
        context.Type = VSP_CONTEXT_TYPE_EVENT;
        KeInitializeEvent(&context.Event.Event, NotificationEvent, FALSE);
        ExInitializeWorkItem(&context.WorkItem, VspSignalContext, &context);
        synchronousCall = TRUE;
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (filter->PagedResourceInUse) {
        InsertTailList(&filter->PagedResourceList, &WorkItem->List);
        KeReleaseSpinLock(&filter->SpinLock, irql);
        if (synchronousCall) {
            KeWaitForSingleObject(&context.Event.Event, Executive,
                                  KernelMode, FALSE, NULL);
        }
        return;
    }
    filter->PagedResourceInUse = TRUE;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (!synchronousCall) {
        VspQueueWorkItem(filter->Root, WorkItem, 1);
    }
}

VOID
VspReleasePagedResource(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (IsListEmpty(&filter->PagedResourceList)) {
        filter->PagedResourceInUse = FALSE;
        KeReleaseSpinLock(&filter->SpinLock, irql);
        return;
    }
    l = RemoveHeadList(&filter->PagedResourceList);
    KeReleaseSpinLock(&filter->SpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    if (workItem->WorkerRoutine == VspSignalContext) {
        workItem->WorkerRoutine(workItem->Parameter);
    } else {
        VspQueueWorkItem(Extension->Root, workItem, 1);
    }
}

NTSTATUS
VspQueryListOfExtents(
    IN  HANDLE              FileHandle,
    IN  LONGLONG            FileOffset,
    OUT PLIST_ENTRY         ExtentList,
    IN  PVOLUME_EXTENSION   BitmapExtension,
    IN  BOOLEAN             ReturnRawValues
    )

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bpc;
    STARTING_VCN_INPUT_BUFFER   input;
    RETRIEVAL_POINTERS_BUFFER   output;
    LONGLONG                    start, length, delta, end, roundedStart, roundedEnd, s;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PLIST_ENTRY                 l;
    KIRQL                       irql;
    BOOLEAN                     isNegative, isNtfs;

    InitializeListHead(ExtentList);

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus,
                                          &fsSize, sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        while (!IsListEmpty(ExtentList)) {
            l = RemoveHeadList(ExtentList);
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }
        return status;
    }

    bpc = fsSize.BytesPerSector*fsSize.SectorsPerAllocationUnit;
    input.StartingVcn.QuadPart = FileOffset/bpc;

    for (;;) {

        status = ZwFsControlFile(FileHandle, NULL, NULL, NULL, &ioStatus,
                                 FSCTL_GET_RETRIEVAL_POINTERS, &input,
                                 sizeof(input), &output, sizeof(output));

        if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW) {
            if (status == STATUS_END_OF_FILE) {
                status = STATUS_SUCCESS;
            }
            break;
        }

        if (!output.ExtentCount) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (output.Extents[0].Lcn.QuadPart == -1) {
            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }
            input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
            continue;
        }

        delta = input.StartingVcn.QuadPart - output.StartingVcn.QuadPart;
        start = (output.Extents[0].Lcn.QuadPart + delta)*bpc;
        length = (output.Extents[0].NextVcn.QuadPart -
                  input.StartingVcn.QuadPart)*bpc;
        end = start + length;

        if (ReturnRawValues) {
            diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                     ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(DIFF_AREA_FILE_ALLOCATION),
                                     VOLSNAP_TAG_BIT_HISTORY);
            if (!diffAreaFileAllocation) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            diffAreaFileAllocation->Offset = start;
            diffAreaFileAllocation->NLength = length;
            InsertTailList(ExtentList, &diffAreaFileAllocation->ListEntry);

            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }

            input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
            continue;
        }

        roundedStart = start&(~(BLOCK_SIZE - 1));
        roundedEnd = end&(~(BLOCK_SIZE - 1));

        if (start != roundedStart) {
            roundedStart += BLOCK_SIZE;
        }

        if (roundedStart > start) {
            diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                     ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(DIFF_AREA_FILE_ALLOCATION),
                                     VOLSNAP_TAG_BIT_HISTORY);
            if (!diffAreaFileAllocation) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            diffAreaFileAllocation->Offset = start;
            diffAreaFileAllocation->NLength = -(roundedStart - start);
            if (roundedStart > end) {
                diffAreaFileAllocation->NLength += roundedStart - end;
            }
            ASSERT(diffAreaFileAllocation->NLength);
            InsertTailList(ExtentList, &diffAreaFileAllocation->ListEntry);
        }

        diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                 ExAllocatePoolWithTag(NonPagedPool,
                                 sizeof(DIFF_AREA_FILE_ALLOCATION),
                                 VOLSNAP_TAG_BIT_HISTORY);
        if (!diffAreaFileAllocation) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        diffAreaFileAllocation->Offset = roundedStart;
        diffAreaFileAllocation->NLength = 0;

        for (s = roundedStart; s < roundedEnd; s += BLOCK_SIZE) {

            isNegative = FALSE;
            if (BitmapExtension) {
                KeAcquireSpinLock(&BitmapExtension->SpinLock, &irql);
                if (BitmapExtension->VolumeBlockBitmap &&
                    !RtlCheckBit(BitmapExtension->VolumeBlockBitmap,
                                 s>>BLOCK_SHIFT)) {

                    isNegative = TRUE;
                }
                KeReleaseSpinLock(&BitmapExtension->SpinLock, irql);
            }

            if (isNegative) {
                if (diffAreaFileAllocation->NLength <= 0) {
                    diffAreaFileAllocation->NLength -= BLOCK_SIZE;
                } else {
                    InsertTailList(ExtentList,
                                   &diffAreaFileAllocation->ListEntry);
                    diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                            ExAllocatePoolWithTag(NonPagedPool,
                            sizeof(DIFF_AREA_FILE_ALLOCATION),
                            VOLSNAP_TAG_BIT_HISTORY);
                    if (!diffAreaFileAllocation) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    diffAreaFileAllocation->Offset = s;
                    diffAreaFileAllocation->NLength = -BLOCK_SIZE;
                }
            } else {
                if (diffAreaFileAllocation->NLength >= 0) {
                    diffAreaFileAllocation->NLength += BLOCK_SIZE;
                } else {
                    InsertTailList(ExtentList,
                                   &diffAreaFileAllocation->ListEntry);
                    diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                            ExAllocatePoolWithTag(NonPagedPool,
                            sizeof(DIFF_AREA_FILE_ALLOCATION),
                            VOLSNAP_TAG_BIT_HISTORY);
                    if (!diffAreaFileAllocation) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    diffAreaFileAllocation->Offset = s;
                    diffAreaFileAllocation->NLength = BLOCK_SIZE;
                }
            }
        }

        if (s < roundedEnd) {
            break;
        }

        if (diffAreaFileAllocation->NLength) {
            InsertTailList(ExtentList, &diffAreaFileAllocation->ListEntry);
        } else {
            ExFreePool(diffAreaFileAllocation);
        }

        if (end > roundedEnd && roundedEnd >= roundedStart) {

            diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                     ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(DIFF_AREA_FILE_ALLOCATION),
                                     VOLSNAP_TAG_BIT_HISTORY);
            if (!diffAreaFileAllocation) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            diffAreaFileAllocation->Offset = roundedEnd;
            diffAreaFileAllocation->NLength = -(end - roundedEnd);
            InsertTailList(ExtentList, &diffAreaFileAllocation->ListEntry);
        }

        if (status != STATUS_BUFFER_OVERFLOW) {
            break;
        }
        input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
    }

    if (!NT_SUCCESS(status)) {
        while (!IsListEmpty(ExtentList)) {
            l = RemoveHeadList(ExtentList);
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }
    }

    return status;
}

NTSTATUS
VspQueryFileSize(
    IN  HANDLE      FileHandle,
    IN  PLONGLONG   FileSize
    )

{
    FILE_STANDARD_INFORMATION   allocInfo;
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;

    status = ZwQueryInformationFile(FileHandle, &ioStatus,
                                    &allocInfo, sizeof(allocInfo),
                                    FileStandardInformation);

    *FileSize = allocInfo.AllocationSize.QuadPart;

    return status;
}

NTSTATUS
VspSetFileSize(
    IN  HANDLE      FileHandle,
    IN  LONGLONG    FileSize
    )

{
    FILE_ALLOCATION_INFORMATION     allocInfo;
    FILE_END_OF_FILE_INFORMATION    eofInfo;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 ioStatus;

    allocInfo.AllocationSize.QuadPart = FileSize;
    eofInfo.EndOfFile.QuadPart = FileSize;

    status = ZwSetInformationFile(FileHandle, &ioStatus,
                                  &eofInfo, sizeof(eofInfo),
                                  FileEndOfFileInformation);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwSetInformationFile(FileHandle, &ioStatus,
                                  &allocInfo, sizeof(allocInfo),
                                  FileAllocationInformation);

    return status;
}

NTSTATUS
VspSynchronousIo(
    IN  PIRP            Irp,
    IN  PDEVICE_OBJECT  TargetObject,
    IN  UCHAR           MajorFunction,
    IN  LONGLONG        Offset,
    IN  ULONG           Length
    )

{
    PIO_STACK_LOCATION  nextSp;
    KEVENT              event;

    if (!Length) {
        Length = BLOCK_SIZE;
    }

    nextSp = IoGetNextIrpStackLocation(Irp);
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Read.ByteOffset.QuadPart = Offset;
    nextSp->Parameters.Read.Length = Length;
    nextSp->MajorFunction = MajorFunction;
    nextSp->DeviceObject = TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoSetCompletionRoutine(Irp, VspSignalCompletion, &event, TRUE,
                           TRUE, TRUE);
    IoCallDriver(nextSp->DeviceObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    return Irp->IoStatus.Status;
}

VOID
VspFreeUsedDiffAreaSpaceFromPointers(
    IN  PVOLUME_EXTENSION           Extension,
    IN  PDIFF_AREA_FILE_ALLOCATION  CurrentFileAllocation,
    IN  LONGLONG                    CurrentOffset
    )

{
    PVSP_DIFF_AREA_FILE         diffAreaFile = Extension->DiffAreaFile;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;

    ASSERT(diffAreaFile);

    for (;;) {

        if (IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
            return;
        }

        l = diffAreaFile->UnusedAllocationList.Flink;
        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        if (diffAreaFileAllocation == CurrentFileAllocation) {
            break;
        }

        RemoveEntryList(l);
        ExFreePool(diffAreaFileAllocation);
    }

    ASSERT(diffAreaFileAllocation->NLength >= 0 || !CurrentOffset);

    diffAreaFileAllocation->Offset += CurrentOffset;
    diffAreaFileAllocation->NLength -= CurrentOffset;

    ASSERT(diffAreaFileAllocation->NLength >= 0 || !CurrentOffset);
}

NTSTATUS
VspAddLocationDescription(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile,
    IN  LONGLONG            OldAllocatedFileSize
    )

{
    PVOLUME_EXTENSION                           extension = DiffAreaFile->Extension;
    LONGLONG                                    fileOffset, t, f;
    PLIST_ENTRY                                 l;
    PDIFF_AREA_FILE_ALLOCATION                  diffAreaFileAllocation;
    PVSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION   locationBlock;
    PVSP_DIFF_AREA_LOCATION_DESCRIPTOR          locationDescriptor;
    ULONG                                       blockOffset;
    ULONG                                       totalNumEntries, numEntriesPerBlock, numBlocks, i;
    PLONGLONG                                   fileOffsetArray, targetOffsetArray;
    NTSTATUS                                    status;
    PDIFF_AREA_FILE_ALLOCATION                  allocationBlock;
    LONGLONG                                    allocationOffset;

    fileOffset = DiffAreaFile->NextAvailable;
    for (l = DiffAreaFile->UnusedAllocationList.Flink;
         l != &DiffAreaFile->UnusedAllocationList; l = l->Flink) {

        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);

        if (fileOffset == OldAllocatedFileSize) {
            break;
        }

        if (diffAreaFileAllocation->NLength < 0) {
            fileOffset -= diffAreaFileAllocation->NLength;
        } else {
            fileOffset += diffAreaFileAllocation->NLength;
        }
    }

    ASSERT(l != &DiffAreaFile->UnusedAllocationList);

    locationBlock = (PVSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION)
            MmGetMdlVirtualAddress(DiffAreaFile->TableUpdateIrp->MdlAddress);

    allocationOffset = 0;
    allocationBlock = CONTAINING_RECORD(
                      DiffAreaFile->UnusedAllocationList.Flink,
                      DIFF_AREA_FILE_ALLOCATION, ListEntry);

    for (;;) {

        status = VspSynchronousIo(
                 DiffAreaFile->TableUpdateIrp,
                 DiffAreaFile->Filter->TargetObject,
                 IRP_MJ_READ,
                 DiffAreaFile->DiffAreaLocationDescriptionTargetOffset, 0);
        if (!NT_SUCCESS(status)) {
            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, DiffAreaFile->Filter,
                            VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 1, FALSE);
            }
            VspFreeUsedDiffAreaSpaceFromPointers(extension, allocationBlock,
                                                 allocationOffset);
            return status;
        }

        for (blockOffset = VSP_OFFSET_TO_FIRST_LOCATION_DESCRIPTOR;
             blockOffset + sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR) <= BLOCK_SIZE;
             blockOffset += sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR)) {

            locationDescriptor = (PVSP_DIFF_AREA_LOCATION_DESCRIPTOR)
                                 ((PCHAR) locationBlock + blockOffset);

            if (locationDescriptor->VolumeOffset) {
                continue;
            }

            while (diffAreaFileAllocation->NLength <= 0) {
                fileOffset -= diffAreaFileAllocation->NLength;
                l = l->Flink;
                if (l == &DiffAreaFile->UnusedAllocationList) {
                    break;
                }
                diffAreaFileAllocation = CONTAINING_RECORD(l,
                                         DIFF_AREA_FILE_ALLOCATION, ListEntry);
            }

            if (l == &DiffAreaFile->UnusedAllocationList) {
                break;
            }

            locationDescriptor->VolumeOffset = diffAreaFileAllocation->Offset;
            locationDescriptor->FileOffset = fileOffset;
            locationDescriptor->Length = diffAreaFileAllocation->NLength;
            fileOffset += locationDescriptor->Length;

            l = l->Flink;
            if (l == &DiffAreaFile->UnusedAllocationList) {
                break;
            }
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
        }

        status = VspSynchronousIo(
                 DiffAreaFile->TableUpdateIrp,
                 DiffAreaFile->Filter->TargetObject,
                 IRP_MJ_WRITE,
                 DiffAreaFile->DiffAreaLocationDescriptionTargetOffset, 0);
        if (!NT_SUCCESS(status)) {
            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, DiffAreaFile->Filter,
                            VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 22, FALSE);
            }
            VspFreeUsedDiffAreaSpaceFromPointers(extension, allocationBlock,
                                                 allocationOffset);
            return status;
        }

        if (l == &DiffAreaFile->UnusedAllocationList) {
            break;
        }

        status = VspAllocateDiffAreaSpace(extension, &t, &f, &allocationBlock,
                                          &allocationOffset);
        if (!NT_SUCCESS(status)) {
            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, NULL,
                            VS_ABORT_SNAPSHOTS_OUT_OF_DIFF_AREA,
                            STATUS_SUCCESS, 5, FALSE);
            }
            VspFreeUsedDiffAreaSpaceFromPointers(extension, allocationBlock,
                                                 allocationOffset);
            return status;
        }

        RtlZeroMemory(locationBlock, BLOCK_SIZE);

        locationBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
        locationBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
        locationBlock->Header.BlockType =
                VSP_BLOCK_TYPE_DIFF_AREA_LOCATION_DESCRIPTION;
        locationBlock->Header.ThisFileOffset = f;
        locationBlock->Header.ThisVolumeOffset = t;

        status = VspSynchronousIo(
                 DiffAreaFile->TableUpdateIrp,
                 DiffAreaFile->Filter->TargetObject,
                 IRP_MJ_WRITE, t, 0);
        if (!NT_SUCCESS(status)) {
            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, DiffAreaFile->Filter,
                            VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 23, FALSE);
            }
            VspFreeUsedDiffAreaSpaceFromPointers(extension, allocationBlock,
                                                 allocationOffset);
            return status;
        }

        status = VspSynchronousIo(
                 DiffAreaFile->TableUpdateIrp,
                 DiffAreaFile->Filter->TargetObject,
                 IRP_MJ_READ,
                 DiffAreaFile->DiffAreaLocationDescriptionTargetOffset, 0);
        if (!NT_SUCCESS(status)) {
            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, DiffAreaFile->Filter,
                            VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 24, FALSE);
            }
            VspFreeUsedDiffAreaSpaceFromPointers(extension, allocationBlock,
                                                 allocationOffset);
            return status;
        }

        locationBlock->Header.NextVolumeOffset = t;

        status = VspSynchronousIo(
                 DiffAreaFile->TableUpdateIrp,
                 DiffAreaFile->Filter->TargetObject,
                 IRP_MJ_WRITE,
                 DiffAreaFile->DiffAreaLocationDescriptionTargetOffset, 0);
        if (!NT_SUCCESS(status)) {
            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, DiffAreaFile->Filter,
                            VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 25, FALSE);
            }
            VspFreeUsedDiffAreaSpaceFromPointers(extension, allocationBlock,
                                                 allocationOffset);
            return status;
        }

        DiffAreaFile->DiffAreaLocationDescriptionTargetOffset = t;
    }

    VspFreeUsedDiffAreaSpaceFromPointers(extension, allocationBlock,
                                         allocationOffset);

    status = VspSynchronousIo(
             DiffAreaFile->TableUpdateIrp, DiffAreaFile->Filter->TargetObject,
             IRP_MJ_READ, DiffAreaFile->TableTargetOffset, 0);
    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, DiffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 26, FALSE);
        }
        return status;
    }

    return STATUS_SUCCESS;
}

VOID
VspReleaseDiffAreaSpaceWaiters(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL               irql;
    BOOLEAN             emptyQueue;
    LIST_ENTRY          q;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (Extension->GrowDiffAreaFilePending) {
        Extension->GrowDiffAreaFilePending = FALSE;
        if (IsListEmpty(&Extension->WaitingForDiffAreaSpace)) {
            emptyQueue = FALSE;
        } else {
            emptyQueue = TRUE;
            q = Extension->WaitingForDiffAreaSpace;
            InitializeListHead(&Extension->WaitingForDiffAreaSpace);
        }
    } else {
        emptyQueue = FALSE;
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (emptyQueue) {
        q.Flink->Blink = &q;
        q.Blink->Flink = &q;
        while (!IsListEmpty(&q)) {
            l = RemoveHeadList(&q);
            workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
            VspAcquireNonPagedResource(Extension, workItem, FALSE);
        }
    }
}

VOID
VspGrowDiffAreaPhase2(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION           extension = context->GrowDiffArea.Extension;
    PVSP_DIFF_AREA_FILE         diffAreaFile = extension->DiffAreaFile;
    PFILTER_EXTENSION           filter = extension->Filter;
    PLIST_ENTRY                 extentList = &context->GrowDiffArea.ExtentList;
    LONGLONG                    current = context->GrowDiffArea.Current;
    ULONG                       increase = context->GrowDiffArea.Increase;
    NTSTATUS                    status = context->GrowDiffArea.ResultStatus;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    KIRQL                       irql;
    BOOLEAN                     dontNeedWrite;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_GROW_DIFF_AREA);

    if (!NT_SUCCESS(status)) {
        VspReleaseNonPagedResource(extension);
        VspFreeContext(extension->Root, context);
        VspReleaseDiffAreaSpaceWaiters(extension);
        VspDecrementVolumeRefCount(extension);
        return;
    }

    while (!IsListEmpty(extentList)) {
        l = RemoveHeadList(extentList);
        InsertTailList(&diffAreaFile->UnusedAllocationList, l);
    }

    diffAreaFile->AllocatedFileSize += increase;

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    filter->AllocatedVolumeSpace += increase;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (extension->IsPersistent && diffAreaFile->TableUpdateIrp) {

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        dontNeedWrite = diffAreaFile->TableUpdateInProgress;
        diffAreaFile->TableUpdateInProgress = TRUE;
        if (dontNeedWrite) {
            KeInitializeEvent(&diffAreaFile->IrpReady, NotificationEvent, FALSE);
            ASSERT(!diffAreaFile->IrpNeeded);
            diffAreaFile->IrpNeeded = TRUE;
        }
        KeReleaseSpinLock(&extension->SpinLock, irql);

        if (dontNeedWrite) {
            KeWaitForSingleObject(&diffAreaFile->IrpReady, Executive,
                                  KernelMode, FALSE, NULL);
        }

        status = VspAddLocationDescription(diffAreaFile, current);
        if (NT_SUCCESS(status)) {
            VspWriteTableUpdates(diffAreaFile);
        } else {
            VspKillTableUpdates(diffAreaFile);
        }
    }

    VspReleaseNonPagedResource(extension);

    VspFreeContext(extension->Root, context);
    VspReleaseDiffAreaSpaceWaiters(extension);
    VspDecrementVolumeRefCount(extension);
}

NTSTATUS
VspDiffAreaFileFillCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    LONGLONG                    offset = 0;
    KIRQL                       irql;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaAllocation;
    PIO_STACK_LOCATION          nextSp;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_GROW_DIFF_AREA);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        KeAcquireSpinLock(&context->GrowDiffArea.SpinLock, &irql);
        context->GrowDiffArea.CurrentEntry = &context->GrowDiffArea.ExtentList;
        context->GrowDiffArea.CurrentEntryOffset = 0;
        KeReleaseSpinLock(&context->GrowDiffArea.SpinLock, irql);

        context->GrowDiffArea.ResultStatus = Irp->IoStatus.Status;
    }

    KeAcquireSpinLock(&context->GrowDiffArea.SpinLock, &irql);
    for (l = context->GrowDiffArea.CurrentEntry;
         l != &context->GrowDiffArea.ExtentList; l = l->Flink) {

        diffAreaAllocation = CONTAINING_RECORD(l, DIFF_AREA_FILE_ALLOCATION,
                                               ListEntry);

        if (diffAreaAllocation->NLength <= 0) {
            ASSERT(!context->GrowDiffArea.CurrentEntryOffset);
            continue;
        }

        if (context->GrowDiffArea.CurrentEntryOffset ==
            diffAreaAllocation->NLength) {

            context->GrowDiffArea.CurrentEntryOffset = 0;
            continue;
        }

        ASSERT(context->GrowDiffArea.CurrentEntryOffset <
               diffAreaAllocation->NLength);

        offset = diffAreaAllocation->Offset +
                 context->GrowDiffArea.CurrentEntryOffset;
        context->GrowDiffArea.CurrentEntryOffset += BLOCK_SIZE;
        break;
    }
    context->GrowDiffArea.CurrentEntry = l;
    KeReleaseSpinLock(&context->GrowDiffArea.SpinLock, irql);

    if (l == &context->GrowDiffArea.ExtentList) {
        if (!InterlockedDecrement(&context->GrowDiffArea.RefCount)) {
            ExFreePool(MmGetMdlVirtualAddress(Irp->MdlAddress));
            IoFreeMdl(Irp->MdlAddress);
            VspAcquireNonPagedResource(context->GrowDiffArea.Extension,
                                       &context->WorkItem, TRUE);
        }
        IoFreeIrp(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    nextSp = IoGetNextIrpStackLocation(Irp);
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Write.ByteOffset.QuadPart = offset;
    nextSp->Parameters.Write.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = context->GrowDiffArea.TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;
    IoSetCompletionRoutine(Irp, VspDiffAreaFileFillCompletion, context, TRUE,
                           TRUE, TRUE);
    IoCallDriver(nextSp->DeviceObject, Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspLaunchDiffAreaFill(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    ULONG               i;
    PVOID               buffer;
    PMDL                mdl;
    PIRP                irp;
    PIO_STACK_LOCATION  nextSp;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_GROW_DIFF_AREA);

    context->GrowDiffArea.ResultStatus = STATUS_SUCCESS;

    buffer = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE,
                                   VOLSNAP_TAG_BUFFER);
    if (!buffer) {
        context->GrowDiffArea.ResultStatus = STATUS_INSUFFICIENT_RESOURCES;
        VspAcquireNonPagedResource(context->GrowDiffArea.Extension,
                                   &context->WorkItem, TRUE);
        return;
    }

    mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buffer);
        context->GrowDiffArea.ResultStatus = STATUS_INSUFFICIENT_RESOURCES;
        VspAcquireNonPagedResource(context->GrowDiffArea.Extension,
                                   &context->WorkItem, TRUE);
        return;
    }

    MmBuildMdlForNonPagedPool(mdl);

    ASSERT(SMALLEST_NTFS_CLUSTER < BLOCK_SIZE);

    RtlZeroMemory(buffer, BLOCK_SIZE);
    for (i = 0; i < BLOCK_SIZE; i += SMALLEST_NTFS_CLUSTER) {
        RtlCopyMemory((PCHAR) buffer + i, &VSP_DIFF_AREA_FILE_GUID,
                      sizeof(GUID));
    }

    context->GrowDiffArea.RefCount = 1;
    for (i = 0; i < 32; i++) {

        irp = IoAllocateIrp(
              (CCHAR) context->GrowDiffArea.Extension->Root->StackSize, FALSE);
        if (!irp) {
            if (!i) {
                context->GrowDiffArea.ResultStatus =
                        STATUS_INSUFFICIENT_RESOURCES;
            }
            break;
        }

        irp->MdlAddress = mdl;
        irp->IoStatus.Status = STATUS_SUCCESS;

        InterlockedIncrement(&context->GrowDiffArea.RefCount);

        VspDiffAreaFileFillCompletion(NULL, irp, context);
    }

    if (!InterlockedDecrement(&context->GrowDiffArea.RefCount)) {
        ExFreePool(buffer);
        IoFreeMdl(mdl);
        VspAcquireNonPagedResource(context->GrowDiffArea.Extension,
                                   &context->WorkItem, TRUE);
    }
}

VOID
VspGrowDiffArea(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION           extension = context->GrowDiffArea.Extension;
    PVSP_DIFF_AREA_FILE         diffAreaFile = extension->DiffAreaFile;
    PFILTER_EXTENSION           filter = extension->Filter;
    LONGLONG                    usableSpace = 0;
    PFILTER_EXTENSION           diffFilter;
    HANDLE                      handle, h;
    NTSTATUS                    status, status2;
    KIRQL                       irql;
    LIST_ENTRY                  extentList;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    ULONG                       increase, increaseDelta;
    LONGLONG                    current;
    PVOLUME_EXTENSION           bitmapExtension;
    LIST_ENTRY                  listOfDiffAreaFilesToClose;
    LIST_ENTRY                  listOfDeviceObjectsToDelete;
    BOOLEAN                     reduceIncreaseOk;
    PVOLUME_EXTENSION           e;
    KPRIORITY                   oldPriority;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_GROW_DIFF_AREA);

    status = VspIncrementVolumeRefCount(extension);
    if (!NT_SUCCESS(status)) {
        VspFreeContext(extension->Root, context);
        VspReleaseDiffAreaSpaceWaiters(extension);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    ASSERT(diffAreaFile);

    current = diffAreaFile->AllocatedFileSize;
    increaseDelta = extension->DiffAreaFileIncrease;
    increase = 2*increaseDelta;
    diffFilter = diffAreaFile->Filter;
    handle = diffAreaFile->FileHandle;

    reduceIncreaseOk = TRUE;
    for (;;) {

        KeAcquireSpinLock(&diffFilter->SpinLock, &irql);
        if (filter->MaximumVolumeSpace &&
            filter->AllocatedVolumeSpace + increase >
            filter->MaximumVolumeSpace) {

            KeReleaseSpinLock(&diffFilter->SpinLock, irql);
            status = STATUS_DISK_FULL;
            extension->UserImposedLimit = TRUE;
        } else {
            KeReleaseSpinLock(&diffFilter->SpinLock, irql);

            status = ZwDuplicateObject(NtCurrentProcess(), handle,
                                       NtCurrentProcess(), &h, 0, 0,
                                       DUPLICATE_SAME_ACCESS |
                                       DUPLICATE_SAME_ATTRIBUTES);
            if (NT_SUCCESS(status)) {
                ObReferenceObject(diffFilter->DeviceObject);
                InterlockedIncrement(&diffFilter->FSRefCount);
                VspDecrementVolumeRefCount(extension);
                status = VspSetFileSize(h, current + increase);
                ZwClose(h);
                InterlockedDecrement(&diffFilter->FSRefCount);
                ObDereferenceObject(diffFilter->DeviceObject);
                status2 = VspIncrementVolumeRefCount(extension);
                if (!NT_SUCCESS(status2)) {
                    VspFreeContext(extension->Root, context);
                    VspReleaseDiffAreaSpaceWaiters(extension);
                    ObDereferenceObject(extension->DeviceObject);
                    return;
                }
            }
            if (NT_SUCCESS(status)) {
                break;
            }
            extension->UserImposedLimit = FALSE;
        }

        if (increaseDelta > NOMINAL_DIFF_AREA_FILE_GROWTH &&
            reduceIncreaseOk) {

            increase = 2*NOMINAL_DIFF_AREA_FILE_GROWTH;
            increaseDelta = NOMINAL_DIFF_AREA_FILE_GROWTH;
            reduceIncreaseOk = FALSE;
            continue;
        }

        VspDecrementVolumeRefCount(extension);
        VspReleaseDiffAreaSpaceWaiters(extension);

        VspAcquire(extension->Root);
        if (extension->IsDead) {
            InterlockedExchange(&extension->GrowFailed, TRUE);
            VspRelease(extension->Root);
            VspFreeContext(extension->Root, context);
            ObDereferenceObject(extension->DeviceObject);
            return;
        }

        if (status != STATUS_DISK_FULL) {
            InterlockedExchange(&extension->GrowFailed, TRUE);
            VspLogError(extension, diffFilter,
                        VS_GROW_DIFF_AREA_FAILED, status, 1, FALSE);
            VspRelease(extension->Root);
            VspFreeContext(extension->Root, context);
            ObDereferenceObject(extension->DeviceObject);
            return;
        }

        if (extension->ListEntry.Blink == &filter->VolumeList) {
            InterlockedExchange(&extension->GrowFailed, TRUE);
            if (extension->UserImposedLimit) {
                VspLogError(extension, diffFilter,
                            VS_GROW_DIFF_AREA_FAILED_LOW_DISK_SPACE_USER_IMPOSED,
                            STATUS_DISK_FULL, 0, FALSE);
            } else {
                VspLogError(extension, diffFilter,
                            VS_GROW_DIFF_AREA_FAILED_LOW_DISK_SPACE,
                            STATUS_DISK_FULL, 0, FALSE);
            }
            VspRelease(extension->Root);
            VspFreeContext(extension->Root, context);
            ObDereferenceObject(extension->DeviceObject);
            return;
        }

        e = CONTAINING_RECORD(filter->VolumeList.Flink, VOLUME_EXTENSION,
                              ListEntry);
        VspLogError(e, NULL, VS_DELETE_TO_TRIM_SPACE, STATUS_SUCCESS, 1,
                    TRUE);

        InitializeListHead(&listOfDiffAreaFilesToClose);
        InitializeListHead(&listOfDeviceObjectsToDelete);

        VspDeleteOldestSnapshot(filter, &listOfDiffAreaFilesToClose,
                                &listOfDeviceObjectsToDelete, FALSE,
                                FALSE);

        VspRelease(extension->Root);

        VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                              &listOfDeviceObjectsToDelete);

        status = VspIncrementVolumeRefCount(extension);
        if (!NT_SUCCESS(status)) {
            VspFreeContext(extension->Root, context);
            ObDereferenceObject(extension->DeviceObject);
            return;
        }
    }

    VspDecrementVolumeRefCount(extension);

    if (extension->IsDead) {
        VspFreeContext(extension->Root, context);
        VspReleaseDiffAreaSpaceWaiters(extension);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    KeAcquireSpinLock(&diffFilter->SpinLock, &irql);
    if (IsListEmpty(&diffFilter->VolumeList)) {
        bitmapExtension = NULL;
    } else {
        bitmapExtension = CONTAINING_RECORD(diffFilter->VolumeList.Blink,
                                            VOLUME_EXTENSION, ListEntry);
        if (bitmapExtension->IsDead) {
            bitmapExtension = NULL;
        } else {
            ObReferenceObject(bitmapExtension->DeviceObject);
        }
    }
    KeReleaseSpinLock(&diffFilter->SpinLock, irql);

    status = VspIncrementVolumeRefCount(extension);
    if (!NT_SUCCESS(status)) {
        if (bitmapExtension) {
            ObDereferenceObject(bitmapExtension->DeviceObject);
        }
        VspFreeContext(extension->Root, context);
        VspReleaseDiffAreaSpaceWaiters(extension);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    status = VspQueryListOfExtents(handle, current, &extentList,
                                   bitmapExtension, FALSE);

    if (!NT_SUCCESS(status)) {
        if (bitmapExtension) {
            ObDereferenceObject(bitmapExtension->DeviceObject);
        }
        VspFreeContext(extension->Root, context);
        VspReleaseDiffAreaSpaceWaiters(extension);
        VspDecrementVolumeRefCount(extension);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    usableSpace = 0;
    for (l = extentList.Flink; l != &extentList; l = l->Flink) {

        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);

        if (diffAreaFileAllocation->NLength > 0) {
            usableSpace += diffAreaFileAllocation->NLength;
        }
    }

    if (usableSpace < increaseDelta) {

        while (!IsListEmpty(&extentList)) {
            l = RemoveHeadList(&extentList);
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }

        oldPriority = KeQueryPriorityThread(KeGetCurrentThread());
        KeSetPriorityThread(KeGetCurrentThread(), VSP_LOWER_PRIORITY);

        VspOptimizeDiffAreaFileLocation(diffFilter, handle, bitmapExtension,
                                        current, current + increase);

        status = VspQueryListOfExtents(handle, current, &extentList,
                                       bitmapExtension, FALSE);

        KeSetPriorityThread(KeGetCurrentThread(), oldPriority);

        if (!NT_SUCCESS(status)) {
            if (bitmapExtension) {
                ObDereferenceObject(bitmapExtension->DeviceObject);
            }
            VspFreeContext(extension->Root, context);
            VspReleaseDiffAreaSpaceWaiters(extension);
            VspDecrementVolumeRefCount(extension);
            ObDereferenceObject(extension->DeviceObject);
            return;
        }

        usableSpace = 0;
        for (l = extentList.Flink; l != &extentList; l = l->Flink) {

            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);

            if (diffAreaFileAllocation->NLength > 0) {
                usableSpace += diffAreaFileAllocation->NLength;
            }
        }

        if (!usableSpace) {
            if (bitmapExtension) {
                ObDereferenceObject(bitmapExtension->DeviceObject);
            }
            VspFreeContext(extension->Root, context);
            VspReleaseDiffAreaSpaceWaiters(extension);
            VspDecrementVolumeRefCount(extension);
            ObDereferenceObject(extension->DeviceObject);
            return;
        }
    }

    if (bitmapExtension) {
        ObDereferenceObject(bitmapExtension->DeviceObject);
    }

    ObDereferenceObject(extension->DeviceObject);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    extension->PastFileSystemOperations = TRUE;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    ExInitializeWorkItem(&context->WorkItem, VspGrowDiffAreaPhase2, context);
    ASSERT(!IsListEmpty(&extentList));
    context->GrowDiffArea.ExtentList = extentList;
    context->GrowDiffArea.ExtentList.Flink->Blink =
            &context->GrowDiffArea.ExtentList;
    context->GrowDiffArea.ExtentList.Blink->Flink =
            &context->GrowDiffArea.ExtentList;
    context->GrowDiffArea.Current = current;
    context->GrowDiffArea.Increase = increase;
    context->GrowDiffArea.ResultStatus = STATUS_SUCCESS;

    if (extension->IsPersistent && !extension->NoDiffAreaFill) {
        KeInitializeSpinLock(&context->GrowDiffArea.SpinLock);
        context->GrowDiffArea.CurrentEntry =
                context->GrowDiffArea.ExtentList.Flink;
        context->GrowDiffArea.CurrentEntryOffset = 0;
        context->GrowDiffArea.TargetObject = diffFilter->TargetObject;
        VspLaunchDiffAreaFill(context);
        return;
    }

    VspAcquireNonPagedResource(extension, &context->WorkItem, FALSE);
}

VOID
VspWaitForInstall(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->GrowDiffArea.Extension;
    PFILTER_EXTENSION   filter = extension->Filter;
    NTSTATUS            status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_GROW_DIFF_AREA);

    KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    status = VspIncrementVolumeRefCount(extension);
    if (!NT_SUCCESS(status)) {
        VspFreeContext(extension->Root, context);
        VspReleaseDiffAreaSpaceWaiters(extension);
        ObDereferenceObject(extension->DeviceObject);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    if (!extension->OkToGrowDiffArea) {
        VspLogError(extension, extension->DiffAreaFile->Filter,
                    VS_GROW_BEFORE_FREE_SPACE, STATUS_SUCCESS, 1, FALSE);
        VspDecrementVolumeRefCount(extension);
        VspFreeContext(extension->Root, context);
        VspReleaseDiffAreaSpaceWaiters(extension);
        ObDereferenceObject(extension->DeviceObject);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    ExInitializeWorkItem(&context->WorkItem, VspGrowDiffArea, context);
    VspQueueWorkItem(filter->Root, &context->WorkItem, 0);

    VspDecrementVolumeRefCount(extension);

    ObDereferenceObject(filter->DeviceObject);
}

NTSTATUS
VspAllocateDiffAreaSpace(
    IN      PVOLUME_EXTENSION           Extension,
    OUT     PLONGLONG                   TargetOffset,
    OUT     PLONGLONG                   FileOffset,
    IN OUT  PDIFF_AREA_FILE_ALLOCATION* CurrentFileAllocation,
    IN OUT  PLONGLONG                   CurrentOffset
    )

/*++

Routine Description:

    This routine allocates file space in a diff area file.  The algorithm
    for this allocation is round robin which means that different size
    allocations can make the various files grow to be different sizes.  The
    earmarked file is used and grown as necessary to get the space desired.
    Only if it is impossible to use the current file would the allocator go
    to the next one.  If a file needs to be grown, the allocator will
    try to grow by 10 MB.

Arguments:

    Extension       - Supplies the volume extension.

    DiffAreaFile    - Returns the diff area file used in the allocation.

    FileOffset      - Returns the file offset in the diff area file used.

Return Value:

    NTSTATUS

Notes:

    Callers of this routine must be holding 'NonPagedResource'.

--*/

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    LONGLONG                    targetOffset;
    PVSP_DIFF_AREA_FILE         diffAreaFile;
    LONGLONG                    delta;
    PLIST_ENTRY                 l;
    PVSP_CONTEXT                context;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    KIRQL                       irql;

    targetOffset = 0;
    diffAreaFile = Extension->DiffAreaFile;
    ASSERT(diffAreaFile);

    delta = 0;
    if (CurrentFileAllocation) {
        diffAreaFileAllocation = *CurrentFileAllocation;
        for (;;) {
            if (diffAreaFileAllocation->NLength - *CurrentOffset <= 0) {
                delta -= diffAreaFileAllocation->NLength - *CurrentOffset;
                *CurrentOffset = 0;
                l = diffAreaFileAllocation->ListEntry.Flink;
                if (l == &diffAreaFile->UnusedAllocationList) {
                    break;
                }
                diffAreaFileAllocation = CONTAINING_RECORD(l,
                                         DIFF_AREA_FILE_ALLOCATION, ListEntry);
                continue;
            }
            targetOffset = diffAreaFileAllocation->Offset + *CurrentOffset;
            *CurrentFileAllocation = diffAreaFileAllocation;
            *CurrentOffset += BLOCK_SIZE;
            break;
        }
    } else {
        while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
            l = diffAreaFile->UnusedAllocationList.Flink;
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);

            if (diffAreaFileAllocation->NLength <= 0) {
                delta -= diffAreaFileAllocation->NLength;
                RemoveEntryList(l);
                ExFreePool(diffAreaFileAllocation);
                continue;
            }

            targetOffset = diffAreaFileAllocation->Offset;
            diffAreaFileAllocation->Offset += BLOCK_SIZE;
            diffAreaFileAllocation->NLength -= BLOCK_SIZE;
            break;
        }
    }

    if (diffAreaFile->NextAvailable + delta + BLOCK_SIZE +
        Extension->DiffAreaFileIncrease <=
        diffAreaFile->AllocatedFileSize) {

        goto Finish;
    }

    if (diffAreaFile->NextAvailable + Extension->DiffAreaFileIncrease >
        diffAreaFile->AllocatedFileSize) {

        goto Finish;
    }

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        if (!Extension->OkToGrowDiffArea) {
            VspLogError(Extension, diffAreaFile->Filter,
                        VS_GROW_BEFORE_FREE_SPACE, STATUS_SUCCESS, 2, FALSE);
        }
        goto Finish;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ASSERT(!Extension->GrowDiffAreaFilePending);
    ASSERT(IsListEmpty(&Extension->WaitingForDiffAreaSpace));
    Extension->PastFileSystemOperations = FALSE;
    Extension->GrowDiffAreaFilePending = TRUE;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    context->Type = VSP_CONTEXT_TYPE_GROW_DIFF_AREA;
    ExInitializeWorkItem(&context->WorkItem, VspGrowDiffArea, context);
    context->GrowDiffArea.Extension = Extension;
    ObReferenceObject(Extension->DeviceObject);

    if (!Extension->OkToGrowDiffArea) {
        ObReferenceObject(filter->DeviceObject);
        ExInitializeWorkItem(&context->WorkItem, VspWaitForInstall, context);
        ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
        goto Finish;
    }

    VspQueueWorkItem(Extension->Root, &context->WorkItem, 0);

Finish:

    if (targetOffset) {
        *TargetOffset = targetOffset;
        *FileOffset = diffAreaFile->NextAvailable + delta;
    }

    diffAreaFile->NextAvailable += delta;
    if (targetOffset) {
        diffAreaFile->NextAvailable += BLOCK_SIZE;
    }
    KeAcquireSpinLock(&filter->SpinLock, &irql);
    filter->UsedVolumeSpace += delta;
    if (targetOffset) {
        filter->UsedVolumeSpace += BLOCK_SIZE;
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    return targetOffset ? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES;
}

VOID
VspDecrementVolumeIrpRefCount(
    IN  PVOID   Irp
    )

{
    PIRP                irp = (PIRP) Irp;
    PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(irp);
    PIO_STACK_LOCATION  irpSp;
    PVOLUME_EXTENSION   extension;

    if (InterlockedDecrement((PLONG) &nextSp->Parameters.Read.Length)) {
        return;
    }

    irpSp = IoGetCurrentIrpStackLocation(irp);
    extension = (PVOLUME_EXTENSION) irpSp->DeviceObject->DeviceExtension;
    ASSERT(extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    IoCompleteRequest(irp, IO_DISK_INCREMENT);
    VspDecrementVolumeRefCount(extension);
}

VOID
VspDecrementIrpRefCount(
    IN  PVOID   Irp
    )

{
    PIRP                irp = (PIRP) Irp;
    PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(irp);
    PIO_STACK_LOCATION  irpSp;
    PFILTER_EXTENSION   filter;
    PVOLUME_EXTENSION   extension;
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    KIRQL               irql;
    PVSP_WRITE_CONTEXT  writeContext;
    PDO_EXTENSION       rootExtension;

    if (InterlockedDecrement((PLONG) &nextSp->Parameters.Read.Length)) {
        return;
    }

    irpSp = IoGetCurrentIrpStackLocation(irp);
    filter = (PFILTER_EXTENSION) irpSp->DeviceObject->DeviceExtension;
    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER);
    extension = CONTAINING_RECORD(filter->VolumeList.Blink,
                                  VOLUME_EXTENSION, ListEntry);

    diffAreaFile = extension->DiffAreaFile;
    ASSERT(diffAreaFile);
    VspDecrementRefCount(diffAreaFile->Filter);

    if (!irp->MdlAddress) {
        IoCompleteRequest(irp, IO_NO_INCREMENT);
        VspDecrementRefCount(filter);
        return;
    }

    writeContext = VspAllocateWriteContext(filter->Root);
    if (!writeContext) {
        rootExtension = filter->Root;
        KeAcquireSpinLock(&rootExtension->ESpinLock, &irql);
        if (rootExtension->EmergencyWriteContextInUse) {
            InsertTailList(&rootExtension->WriteContextIrpWaitingList,
                           &irp->Tail.Overlay.ListEntry);
            if (!rootExtension->WriteContextIrpWaitingListNeedsChecking) {
                InterlockedExchange(
                &rootExtension->WriteContextIrpWaitingListNeedsChecking,
                TRUE);
            }
            KeReleaseSpinLock(&rootExtension->ESpinLock, irql);
            VspDecrementRefCount(filter);
            return;
        }
        rootExtension->EmergencyWriteContextInUse = TRUE;
        KeReleaseSpinLock(&rootExtension->ESpinLock, irql);

        writeContext = rootExtension->EmergencyWriteContext;
    }

    writeContext->Filter = filter;
    writeContext->Extension = extension;
    writeContext->Irp = irp;
    InitializeListHead(&writeContext->CompletionRoutines);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    InsertTailList(&extension->WriteContextList, &writeContext->ListEntry);
    KeReleaseSpinLock(&extension->SpinLock, irql);

    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine(irp, VspWriteContextCompletionRoutine,
                           writeContext, TRUE, TRUE, TRUE);
    IoCallDriver(filter->TargetObject, irp);
}

VOID
VspDecrementIrpRefCountWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    PIRP                irp = context->Extension.Irp;

    if (context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME) {
        ExInitializeWorkItem(&context->WorkItem, VspWriteVolume, context);
        VspAcquireNonPagedResource(extension, &context->WorkItem, TRUE);
    } else {
        ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);
        VspFreeContext(extension->Root, context);
    }

    VspDecrementIrpRefCount(irp);
}

VOID
VspSignalCallback(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KeSetEvent((PKEVENT) Filter->ZeroRefContext, IO_NO_INCREMENT, FALSE);
}

VOID
VspCleanupVolumeSnapshot(
    IN      PVOLUME_EXTENSION   Extension,
    IN OUT  PLIST_ENTRY         ListOfDiffAreaFilesToClose,
    IN      BOOLEAN             KeepOnDisk
    )

/*++

Routine Description:

    This routine kills an existing volume snapshot.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

Notes:

    Root->Semaphore required for calling this routine.

--*/

{
    PFILTER_EXTENSION               filter = Extension->Filter;
    PLIST_ENTRY                     l, ll;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    KIRQL                           irql;
    POLD_HEAP_ENTRY                 oldHeapEntry;
    NTSTATUS                        status;
    PDIFF_AREA_FILE_ALLOCATION      diffAreaFileAllocation;
    PVOID                           p;
    FILE_DISPOSITION_INFORMATION    dispInfo;
    IO_STATUS_BLOCK                 ioStatus;
    PVSP_LOOKUP_TABLE_ENTRY         lookupEntry;

    VspAcquirePagedResource(Extension, NULL);

    if (Extension->DiffAreaFileMap) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->DiffAreaFileMap = NULL;
    }

    if (Extension->NextDiffAreaFileMap) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->NextDiffAreaFileMap = NULL;
    }

    while (!IsListEmpty(&Extension->OldHeaps)) {

        l = RemoveHeadList(&Extension->OldHeaps);
        oldHeapEntry = CONTAINING_RECORD(l, OLD_HEAP_ENTRY, ListEntry);

        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      oldHeapEntry->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(oldHeapEntry);
    }

    VspReleasePagedResource(Extension);

    if (Extension->IsPersistent && !KeepOnDisk) {
        VspCleanupControlItemsForSnapshot(Extension);
    }

    if (Extension->DiffAreaFile) {

        diffAreaFile = Extension->DiffAreaFile;
        Extension->DiffAreaFile = NULL;

        KeAcquireSpinLock(&diffAreaFile->Filter->SpinLock, &irql);
        if (diffAreaFile->FilterListEntryBeingUsed) {
            RemoveEntryList(&diffAreaFile->FilterListEntry);
            diffAreaFile->FilterListEntryBeingUsed = FALSE;
        }
        KeReleaseSpinLock(&diffAreaFile->Filter->SpinLock, irql);

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        filter->AllocatedVolumeSpace -= diffAreaFile->AllocatedFileSize;
        filter->UsedVolumeSpace -= diffAreaFile->NextAvailable;
        KeReleaseSpinLock(&filter->SpinLock, irql);

        while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
            ll = RemoveHeadList(&diffAreaFile->UnusedAllocationList);
            diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }

        if (diffAreaFile->TableUpdateIrp) {
            ExFreePool(MmGetMdlVirtualAddress(
                       diffAreaFile->TableUpdateIrp->MdlAddress));
            IoFreeMdl(diffAreaFile->TableUpdateIrp->MdlAddress);
            IoFreeIrp(diffAreaFile->TableUpdateIrp);
        }

        if (ListOfDiffAreaFilesToClose) {
            if (KeepOnDisk && Extension->IsPersistent) {
                lookupEntry = VspFindLookupTableItem(
                              Extension->Root, &Extension->SnapshotGuid);
                ASSERT(lookupEntry);

                lookupEntry->DiffAreaHandle = diffAreaFile->FileHandle;

                ExFreePool(diffAreaFile);

            } else {
                InsertTailList(ListOfDiffAreaFilesToClose,
                               &diffAreaFile->ListEntry);
            }

        } else {
            ASSERT(!diffAreaFile->FileHandle);
            ExFreePool(diffAreaFile);
        }
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (Extension->VolumeBlockBitmap) {
        ExFreePool(Extension->VolumeBlockBitmap->Buffer);
        ExFreePool(Extension->VolumeBlockBitmap);
        Extension->VolumeBlockBitmap = NULL;
    }
    if (Extension->IgnorableProduct) {
        ExFreePool(Extension->IgnorableProduct->Buffer);
        ExFreePool(Extension->IgnorableProduct);
        Extension->IgnorableProduct = NULL;
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    VspAcquirePagedResource(Extension, NULL);

    if (Extension->ApplicationInformation) {
        Extension->ApplicationInformationSize = 0;
        ExFreePool(Extension->ApplicationInformation);
        Extension->ApplicationInformation = NULL;
    }

    VspReleasePagedResource(Extension);

    if (Extension->EmergencyCopyIrp) {
        ExFreePool(MmGetMdlVirtualAddress(
                   Extension->EmergencyCopyIrp->MdlAddress));
        IoFreeMdl(Extension->EmergencyCopyIrp->MdlAddress);
        IoFreeIrp(Extension->EmergencyCopyIrp);
        Extension->EmergencyCopyIrp = NULL;
    }

    VspDeleteWorkerThread(filter->Root);

    if (Extension->IgnoreCopyDataReference) {
        Extension->IgnoreCopyDataReference = FALSE;
        InterlockedDecrement(&filter->IgnoreCopyData);
    }
}

VOID
VspEmptyIrpQueue(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PLIST_ENTRY     IrpQueue
    )

{
    PLIST_ENTRY         l;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;

    while (!IsListEmpty(IrpQueue)) {
        l = RemoveHeadList(IrpQueue);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(irp);
        DriverObject->MajorFunction[irpSp->MajorFunction](irpSp->DeviceObject,
                                                          irp);
    }
}

VOID
VspEmptyWorkerQueue(
    IN  PLIST_ENTRY     WorkerQueue
    )

{
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    while (!IsListEmpty(WorkerQueue)) {
        l = RemoveHeadList(WorkerQueue);
        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        workItem->WorkerRoutine(workItem->Parameter);
    }
}

VOID
VspResumeSnapshotIo(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    InterlockedIncrement(&Extension->RefCount);
    InterlockedExchange(&Extension->HoldIncomingRequests, FALSE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);
}

VOID
VspPauseSnapshotIo(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    KIRQL   irql;

    VspReleaseWrites(Extension->Filter);

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ASSERT(!Extension->HoldIncomingRequests);
    KeInitializeEvent(&Extension->ZeroRefEvent, NotificationEvent, FALSE);
    InterlockedExchange(&Extension->HoldIncomingRequests, TRUE);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    VspDecrementVolumeRefCount(Extension);

    KeWaitForSingleObject(&Extension->ZeroRefEvent, Executive, KernelMode,
                          FALSE, NULL);
}

NTSTATUS
VspDeleteOldestSnapshot(
    IN      PFILTER_EXTENSION   Filter,
    IN OUT  PLIST_ENTRY         ListOfDiffAreaFilesToClose,
    IN OUT  PLIST_ENTRY         LisfOfDeviceObjectsToDelete,
    IN      BOOLEAN             KeepOnDisk,
    IN      BOOLEAN             DontWakePnp
    )

/*++

Routine Description:

    This routine deletes the oldest volume snapshot on the given volume.

Arguments:

    Filter   - Supplies the filter extension.

Return Value:

    NTSTATUS

Notes:

    This routine assumes that Root->Semaphore is being held.

--*/

{
    PFILTER_EXTENSION   filter = Filter;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;

    if (IsListEmpty(&filter->VolumeList)) {
        return STATUS_INVALID_PARAMETER;
    }

    l = filter->VolumeList.Flink;
    extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    InterlockedExchange(&extension->IsDead, TRUE);
    InterlockedExchange(&extension->IsStarted, FALSE);
    KeReleaseSpinLock(&extension->SpinLock, irql);

    VspPauseSnapshotIo(extension);
    VspResumeSnapshotIo(extension);

    VspPauseVolumeIo(filter);

    ObReferenceObject(extension->DeviceObject);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    RemoveEntryList(&extension->ListEntry);
    if (IsListEmpty(&filter->VolumeList)) {
        InterlockedExchange(&filter->SnapshotsPresent, FALSE);
    }
    InterlockedIncrement(&Filter->EpicNumber);
    KeReleaseSpinLock(&filter->SpinLock, irql);

    VspResumeVolumeIo(filter);

    VspCleanupVolumeSnapshot(extension, ListOfDiffAreaFilesToClose,
                             KeepOnDisk);

    if (extension->AliveToPnp) {
        InsertTailList(&filter->DeadVolumeList, &extension->ListEntry);
        if (!DontWakePnp) {
            IoInvalidateDeviceRelations(filter->Pdo, BusRelations);
        }
    } else {
        RtlDeleteElementGenericTable(&filter->Root->UsedDevnodeNumbers,
                                     &extension->DevnodeNumber);
        IoDeleteDevice(extension->DeviceObject);
    }

    InsertTailList(LisfOfDeviceObjectsToDelete, &extension->AnotherListEntry);

    return STATUS_SUCCESS;
}

VOID
VspCloseDiffAreaFiles(
    IN  PLIST_ENTRY ListOfDiffAreaFilesToClose,
    IN  PLIST_ENTRY ListOfDeviceObjectsToDelete
    )

{
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PVOLUME_EXTENSION   extension;

    while (!IsListEmpty(ListOfDiffAreaFilesToClose)) {

        l = RemoveHeadList(ListOfDiffAreaFilesToClose);
        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE, ListEntry);

        ZwClose(diffAreaFile->FileHandle);

        ExFreePool(diffAreaFile);
    }

    while (!IsListEmpty(ListOfDeviceObjectsToDelete)) {

        l = RemoveHeadList(ListOfDeviceObjectsToDelete);
        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, AnotherListEntry);

        ObDereferenceObject(extension->DeviceObject);
    }
}

VOID
VspDestroyAllSnapshotsWorker(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine will delete all of the snapshots in the system.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->DestroyAllSnapshots.Filter;
    BOOLEAN             keepOnDisk = context->DestroyAllSnapshots.KeepOnDisk;
    BOOLEAN             synchronousCall = context->DestroyAllSnapshots.SynchronousCall;
    LIST_ENTRY          listOfDiffAreaFilesToClose;
    LIST_ENTRY          listOfDeviceObjectToDelete;
    BOOLEAN             b;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DESTROY_SNAPSHOTS);

    if (!synchronousCall) {
        KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                              KernelMode, FALSE, NULL);
    }

    InitializeListHead(&listOfDiffAreaFilesToClose);
    InitializeListHead(&listOfDeviceObjectToDelete);

    VspAcquire(filter->Root);

    b = FALSE;
    while (!IsListEmpty(&filter->VolumeList)) {
        VspDeleteOldestSnapshot(filter, &listOfDiffAreaFilesToClose,
                                &listOfDeviceObjectToDelete, keepOnDisk,
                                TRUE);
        b = TRUE;
    }
    if (b) {
        IoInvalidateDeviceRelations(filter->Pdo, BusRelations);
    }

    InterlockedExchange(&filter->DestroyAllSnapshotsPending, FALSE);

    VspRelease(filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                          &listOfDeviceObjectToDelete);

    ObDereferenceObject(filter->DeviceObject);
}

VOID
VspAbortTableEntryWorker(
    IN  PVOID   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PIRP                            irp;
    PKEVENT                         event;

    if (extension->IsPersistent) {
        VspDeleteControlItemsWithGuid(extension->Filter, NULL, TRUE);
    }

    VspEmptyWorkerQueue(&tableEntry->WaitingQueueDpc);

    irp = tableEntry->WriteIrp;
    tableEntry->WriteIrp = NULL;

    if (irp) {
        VspDecrementIrpRefCount(irp);
    }

    event = tableEntry->WaitEvent;

    RtlDeleteElementGenericTable(&extension->TempVolumeBlockTable,
                                 tableEntry);

    if (event) {
        KeSetEvent(event, IO_NO_INCREMENT, FALSE);
    }

    VspReleaseNonPagedResource(extension);

    ObDereferenceObject(extension->Filter->DeviceObject);
    ObDereferenceObject(extension->DeviceObject);
}

BOOLEAN
VspDestroyAllSnapshots(
    IN  PFILTER_EXTENSION               Filter,
    IN  PTEMP_TRANSLATION_TABLE_ENTRY   TableEntry,
    IN  BOOLEAN                         KeepOnDisk,
    IN  BOOLEAN                         PerformSynchronously
    )

/*++

Routine Description:

    This routine will delete all of the snapshots in the system.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    None.

--*/

{
    LONG                destroyInProgress;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    PWORK_QUEUE_ITEM    workItem;
    NTSTATUS            status;
    PVSP_CONTEXT        context;

    destroyInProgress = InterlockedExchange(
                        &Filter->DestroyAllSnapshotsPending, TRUE);

    if (!destroyInProgress) {
        KeAcquireSpinLock(&Filter->SpinLock, &irql);
        for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
             l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            InterlockedExchange(&extension->IsStarted, FALSE);
            InterlockedExchange(&extension->IsDead, TRUE);
        }
        KeReleaseSpinLock(&Filter->SpinLock, irql);
    }

    if (TableEntry) {

        extension = TableEntry->Extension;

        if (TableEntry->IsMoveEntry) {
            ASSERT(TableEntry->WaitEvent);
            KeSetEvent(TableEntry->WaitEvent, IO_NO_INCREMENT, FALSE);
        } else {

            if (TableEntry->CopyIrp) {
                VspFreeCopyIrp(extension, TableEntry->CopyIrp);
                TableEntry->CopyIrp = NULL;
            }

            KeAcquireSpinLock(&extension->SpinLock, &irql);
            RtlSetBit(extension->VolumeBlockBitmap,
                      (ULONG) (TableEntry->VolumeOffset>>BLOCK_SHIFT));
            TableEntry->IsComplete = TRUE;
            if (TableEntry->InTableUpdateQueue) {
                TableEntry->InTableUpdateQueue = FALSE;
                RemoveEntryList(&TableEntry->TableUpdateListEntry);
            }
            KeReleaseSpinLock(&extension->SpinLock, irql);

            ObReferenceObject(extension->DeviceObject);
            ObReferenceObject(extension->Filter->DeviceObject);

            workItem = &TableEntry->WorkItem;
            ExInitializeWorkItem(workItem, VspAbortTableEntryWorker,
                                 TableEntry);
            VspAcquireNonPagedResource(extension, workItem, TRUE);
        }
    }

    if (destroyInProgress) {
        return FALSE;
    }

    context = &Filter->DestroyContext;
    context->Type = VSP_CONTEXT_TYPE_DESTROY_SNAPSHOTS;
    context->DestroyAllSnapshots.Filter = Filter;
    context->DestroyAllSnapshots.KeepOnDisk = KeepOnDisk;
    context->DestroyAllSnapshots.SynchronousCall = PerformSynchronously;

    ObReferenceObject(Filter->DeviceObject);
    ExInitializeWorkItem(&context->WorkItem, VspDestroyAllSnapshotsWorker,
                         context);

    if (PerformSynchronously) {
        VspDestroyAllSnapshotsWorker(context);
    } else {
        ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
    }

    return TRUE;
}

VOID
VspWriteVolumePhase5(
    IN  PVOID   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PKEVENT                         event;

    event = tableEntry->WaitEvent;
    RtlDeleteElementGenericTable(&extension->TempVolumeBlockTable,
                                 tableEntry);
    if (event) {
        KeSetEvent(event, IO_NO_INCREMENT, FALSE);
    }

    VspReleaseNonPagedResource(extension);
    VspDecrementVolumeRefCount(extension);
}

VOID
VspWriteVolumePhase4(
    IN  PVOID   TableEntry
    )

/*++

Routine Description:

    This routine is queued from the completion of writting a block to
    make up a table entry for the write.  This routine will create and
    insert the table entry.

Arguments:

    Context - Supplies the context.

Return Value:

    None.

--*/

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    TRANSLATION_TABLE_ENTRY         keyTableEntry;
    PTRANSLATION_TABLE_ENTRY        backPointer, finalTableEntry;
    PVOID                           r;
    PVOID                           nodeOrParent;
    TABLE_SEARCH_RESULT             searchResult;
    KIRQL                           irql;

    RtlZeroMemory(&keyTableEntry, sizeof(TRANSLATION_TABLE_ENTRY));
    keyTableEntry.VolumeOffset = tableEntry->VolumeOffset;
    keyTableEntry.TargetObject = tableEntry->TargetObject;
    keyTableEntry.TargetOffset = tableEntry->TargetOffset;

    _try {

        backPointer = (PTRANSLATION_TABLE_ENTRY)
            RtlLookupElementGenericTable(&extension->CopyBackPointerTable,
                                         &keyTableEntry);

        if (backPointer) {
            keyTableEntry.VolumeOffset = backPointer->TargetOffset;
        }

        r = RtlLookupElementGenericTableFull(&extension->VolumeBlockTable,
                                             &keyTableEntry, &nodeOrParent,
                                             &searchResult);

        ASSERT(!backPointer || r);

        if (r) {
            ASSERT(backPointer);
            RtlDeleteElementGenericTable(&extension->CopyBackPointerTable,
                                         backPointer);
            finalTableEntry = (PTRANSLATION_TABLE_ENTRY) r;
            ASSERT(finalTableEntry->Flags&
                   VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY);
            finalTableEntry->TargetObject = tableEntry->TargetObject;
            finalTableEntry->Flags &=
                    ~VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY;
            finalTableEntry->TargetOffset = tableEntry->TargetOffset;
        } else {
            r = RtlInsertElementGenericTableFull(
                &extension->VolumeBlockTable, &keyTableEntry,
                sizeof(TRANSLATION_TABLE_ENTRY), NULL, nodeOrParent,
                searchResult);
        }
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        r = NULL;
    }

    VspReleasePagedResource(extension);

    if (!r) {
        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->PageFileSpaceCreatePending) {
            ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase4,
                                 tableEntry);
            InsertTailList(&extension->WaitingForPageFileSpace,
                           &tableEntry->WorkItem.List);
            KeReleaseSpinLock(&extension->SpinLock, irql);
            return;
        }
        KeReleaseSpinLock(&extension->SpinLock, irql);

        if (VspDestroyAllSnapshots(filter, tableEntry, FALSE, FALSE)) {
            VspLogError(extension, NULL, VS_ABORT_SNAPSHOTS_NO_HEAP,
                        STATUS_SUCCESS, 0, FALSE);
        }

        VspDecrementVolumeRefCount(extension);
        return;
    }

    ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase5,
                         tableEntry);
    VspAcquireNonPagedResource(extension, &tableEntry->WorkItem, FALSE);
}

VOID
VspWriteVolumePhase35(
    IN  PTEMP_TRANSLATION_TABLE_ENTRY   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    KIRQL                           irql;
    BOOLEAN                         emptyQueue;
    PLIST_ENTRY                     l;
    PWORK_QUEUE_ITEM                workItem;
    PVSP_CONTEXT                    context;
    PIRP                            irp;
    NTSTATUS                        status;

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    RtlSetBit(extension->VolumeBlockBitmap,
              (ULONG) (tableEntry->VolumeOffset>>BLOCK_SHIFT));
    tableEntry->IsComplete = TRUE;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    while (!IsListEmpty(&tableEntry->WaitingQueueDpc)) {
        l = RemoveHeadList(&tableEntry->WaitingQueueDpc);
        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        context = (PVSP_CONTEXT) workItem->Parameter;
        if (context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT) {
            context->ReadSnapshot.TargetObject = tableEntry->TargetObject;
            context->ReadSnapshot.IsCopyTarget = FALSE;
            context->ReadSnapshot.TargetOffset = tableEntry->TargetOffset;
        }
        workItem->WorkerRoutine(workItem->Parameter);
    }

    irp = tableEntry->WriteIrp;
    tableEntry->WriteIrp = NULL;

    status = VspIncrementVolumeRefCount(extension);
    if (!NT_SUCCESS(status)) {
        VspDestroyAllSnapshots(filter, tableEntry, FALSE, FALSE);
        VspDecrementIrpRefCount(irp);
        return;
    }

    VspDecrementIrpRefCount(irp);

    ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase4,
                         tableEntry);
    VspAcquirePagedResource(extension, &tableEntry->WorkItem);
}

VOID
VspKillTableUpdates(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

{
    PVSP_DIFF_AREA_FILE             diffAreaFile = DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    KIRQL                           irql;
    LIST_ENTRY                      q;
    PLIST_ENTRY                     l;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry;

    ObReferenceObject(extension->DeviceObject);

    for (;;) {

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (IsListEmpty(&diffAreaFile->TableUpdateQueue)) {
            diffAreaFile->TableUpdateInProgress = FALSE;
            KeReleaseSpinLock(&extension->SpinLock, irql);
            break;
        }
        l = RemoveHeadList(&diffAreaFile->TableUpdateQueue);
        tableEntry = CONTAINING_RECORD(l, TEMP_TRANSLATION_TABLE_ENTRY,
                                       TableUpdateListEntry);
        tableEntry->InTableUpdateQueue = FALSE;
        KeReleaseSpinLock(&extension->SpinLock, irql);

        VspDestroyAllSnapshots(extension->Filter, tableEntry, FALSE, FALSE);
    }

    VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, FALSE);

    ObDereferenceObject(extension->DeviceObject);
}

NTSTATUS
VspReadNextDiffAreaBlockCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           DiffAreaFile
    )

/*++

Routine Description:

    This routine is the completion for a read of the next diff area file table
    block.

Arguments:

    DiffAreaFile    - Supplies the diff area file.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    NTSTATUS                status = Irp->IoStatus.Status;
    PVSP_DIFF_AREA_FILE     diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;

    if (!NT_SUCCESS(status)) {
        if (!diffAreaFile->Extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(diffAreaFile->Extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 8, FALSE);

        }
        VspKillTableUpdates(diffAreaFile);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    diffAreaFile->NextFreeTableEntryOffset = VSP_OFFSET_TO_FIRST_TABLE_ENTRY;

    VspWriteTableUpdates(diffAreaFile);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspWriteTableUpdatesCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           DiffAreaFile
    )

/*++

Routine Description:

    This routine is the completion for a write to the diff area file table.

Arguments:

    Context - Supplies the context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PVSP_DIFF_AREA_FILE             diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    NTSTATUS                        status = Irp->IoStatus.Status;
    PLIST_ENTRY                     l;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry;

    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 9, FALSE);
        }

        while (!IsListEmpty(&diffAreaFile->TableUpdatesInProgress)) {
            l = RemoveHeadList(&diffAreaFile->TableUpdatesInProgress);
            tableEntry = CONTAINING_RECORD(l, TEMP_TRANSLATION_TABLE_ENTRY,
                                           TableUpdateListEntry);
            VspDestroyAllSnapshots(extension->Filter, tableEntry, FALSE, FALSE);
        }

        VspKillTableUpdates(diffAreaFile);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    while (!IsListEmpty(&diffAreaFile->TableUpdatesInProgress)) {
        l = RemoveHeadList(&diffAreaFile->TableUpdatesInProgress);
        tableEntry = CONTAINING_RECORD(l, TEMP_TRANSLATION_TABLE_ENTRY,
                                       TableUpdateListEntry);
        if (tableEntry->IsMoveEntry) {
            ASSERT(tableEntry->WaitEvent);
            KeSetEvent(tableEntry->WaitEvent, IO_NO_INCREMENT, FALSE);
        } else {
            VspWriteVolumePhase35(tableEntry);
        }
    }

    VspWriteTableUpdates(diffAreaFile);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspCreateNewDiffAreaBlockPhase5(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           DiffAreaFile
    )

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PVSP_DIFF_AREA_FILE             diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;

    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 21, FALSE);
        }
        VspKillTableUpdates(diffAreaFile);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    VspWriteTableUpdates(diffAreaFile);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspCreateNewDiffAreaBlockPhase4(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           DiffAreaFile
    )

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PVSP_DIFF_AREA_FILE             diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;

    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 20, FALSE);
        }
        VspKillTableUpdates(diffAreaFile);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    diffAreaFile->TableTargetOffset = diffAreaFile->NextTableTargetOffset;
    diffAreaFile->NextFreeTableEntryOffset = VSP_OFFSET_TO_FIRST_TABLE_ENTRY;

    irp = diffAreaFile->TableUpdateIrp;
    nextSp = IoGetNextIrpStackLocation(irp);
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Read.ByteOffset.QuadPart =
            diffAreaFile->NextTableTargetOffset;
    nextSp->Parameters.Read.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = diffAreaFile->Filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspCreateNewDiffAreaBlockPhase5,
                           diffAreaFile, TRUE, TRUE, TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspCreateNewDiffAreaBlockPhase3(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           DiffAreaFile
    )

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PVSP_DIFF_AREA_FILE             diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    PVSP_BLOCK_DIFF_AREA            diffAreaBlock;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;

    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 19, FALSE);
        }
        VspKillTableUpdates(diffAreaFile);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    diffAreaBlock = (PVSP_BLOCK_DIFF_AREA)
            MmGetMdlVirtualAddress(diffAreaFile->TableUpdateIrp->MdlAddress);

    diffAreaBlock->Header.NextVolumeOffset =
            diffAreaFile->NextTableTargetOffset;

    irp = diffAreaFile->TableUpdateIrp;
    nextSp = IoGetNextIrpStackLocation(irp);
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Write.ByteOffset.QuadPart =
            diffAreaFile->TableTargetOffset;
    nextSp->Parameters.Write.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = diffAreaFile->Filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspCreateNewDiffAreaBlockPhase4,
                           diffAreaFile, TRUE, TRUE, TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspCreateNewDiffAreaBlockPhase2(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           DiffAreaFile
    )

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PVSP_DIFF_AREA_FILE             diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;

    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 18, FALSE);
        }
        VspKillTableUpdates(diffAreaFile);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    irp = diffAreaFile->TableUpdateIrp;
    nextSp = IoGetNextIrpStackLocation(irp);
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Read.ByteOffset.QuadPart =
            diffAreaFile->TableTargetOffset;
    nextSp->Parameters.Read.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = diffAreaFile->Filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspCreateNewDiffAreaBlockPhase3,
                           diffAreaFile, TRUE, TRUE, TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspCreateNewDiffAreaBlockPhase15(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           DiffAreaFile
    )

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PVSP_DIFF_AREA_FILE             diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    PVOID                           buffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
    ULONG                           i;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;
    PVSP_BLOCK_DIFF_AREA            diffAreaBlock;

    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 100, FALSE);
        }
        VspKillTableUpdates(diffAreaFile);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    for (i = 0; i < BLOCK_SIZE; i += SMALLEST_NTFS_CLUSTER) {
        if (RtlCompareMemory((PCHAR) buffer + i, &VSP_DIFF_AREA_FILE_GUID,
                             sizeof(GUID)) != sizeof(GUID)) {

            break;
        }
    }

    if (i < BLOCK_SIZE) {
        VspWriteTableUpdates(diffAreaFile);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    diffAreaBlock = (PVSP_BLOCK_DIFF_AREA)
            MmGetMdlVirtualAddress(diffAreaFile->TableUpdateIrp->MdlAddress);

    RtlZeroMemory(diffAreaBlock, BLOCK_SIZE);
    diffAreaBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
    diffAreaBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
    diffAreaBlock->Header.BlockType = VSP_BLOCK_TYPE_DIFF_AREA;
    diffAreaBlock->Header.ThisFileOffset = diffAreaFile->NextTableFileOffset;
    diffAreaBlock->Header.ThisVolumeOffset =
            diffAreaFile->NextTableTargetOffset;

    irp = diffAreaFile->TableUpdateIrp;
    nextSp = IoGetNextIrpStackLocation(irp);
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Write.ByteOffset.QuadPart =
            diffAreaFile->NextTableTargetOffset;
    nextSp->Parameters.Write.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = diffAreaFile->Filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspCreateNewDiffAreaBlockPhase2,
                           diffAreaFile, TRUE, TRUE, TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspCreateNewDiffAreaBlockPhase1(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

{
    PVSP_DIFF_AREA_FILE             diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION               extension = diffAreaFile->Extension;
    LONGLONG                        targetOffset = diffAreaFile->NextTableTargetOffset;
    LONGLONG                        fileOffset = diffAreaFile->NextTableFileOffset;
    PVSP_BLOCK_DIFF_AREA            diffAreaBlock;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;

    ASSERT(targetOffset);
    ASSERT(fileOffset);

    if (extension->IsDetected && !extension->OkToGrowDiffArea &&
        !extension->NoDiffAreaFill) {

        irp = diffAreaFile->TableUpdateIrp;
        nextSp = IoGetNextIrpStackLocation(irp);
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        nextSp->Parameters.Write.ByteOffset.QuadPart = targetOffset;
        nextSp->Parameters.Write.Length = BLOCK_SIZE;
        nextSp->MajorFunction = IRP_MJ_READ;
        nextSp->DeviceObject = diffAreaFile->Filter->TargetObject;
        nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

        IoSetCompletionRoutine(irp, VspCreateNewDiffAreaBlockPhase15,
                               diffAreaFile, TRUE, TRUE, TRUE);

        IoCallDriver(nextSp->DeviceObject, irp);
        return;
    }

    diffAreaBlock = (PVSP_BLOCK_DIFF_AREA)
            MmGetMdlVirtualAddress(diffAreaFile->TableUpdateIrp->MdlAddress);

    RtlZeroMemory(diffAreaBlock, BLOCK_SIZE);
    diffAreaBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
    diffAreaBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
    diffAreaBlock->Header.BlockType = VSP_BLOCK_TYPE_DIFF_AREA;
    diffAreaBlock->Header.ThisFileOffset = fileOffset;
    diffAreaBlock->Header.ThisVolumeOffset = targetOffset;

    irp = diffAreaFile->TableUpdateIrp;
    nextSp = IoGetNextIrpStackLocation(irp);
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Write.ByteOffset.QuadPart = targetOffset;
    nextSp->Parameters.Write.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = diffAreaFile->Filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspCreateNewDiffAreaBlockPhase2,
                           diffAreaFile, TRUE, TRUE, TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);
}

VOID
VspCreateNewDiffAreaBlockAllocate(
    IN  PVOID   DiffAreaFile
    )

{
    PVSP_DIFF_AREA_FILE diffAreaFile = (PVSP_DIFF_AREA_FILE) DiffAreaFile;
    PVOLUME_EXTENSION   extension = diffAreaFile->Extension;
    PFILTER_EXTENSION   filter;
    KIRQL               irql, irql2;
    BOOLEAN             dontNeedWrite;

    diffAreaFile->StatusOfNextBlockAllocate =
            VspAllocateDiffAreaSpace(extension,
                                     &diffAreaFile->NextTableTargetOffset,
                                     &diffAreaFile->NextTableFileOffset,
                                     NULL, NULL);
    VspReleaseNonPagedResource(extension);

    if (!NT_SUCCESS(diffAreaFile->StatusOfNextBlockAllocate)) {
        filter = extension->Filter;
        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->GrowDiffAreaFilePending) {
            KeAcquireSpinLock(&filter->SpinLock, &irql2);
            if ((IsListEmpty(&filter->DiffAreaFilesOnThisFilter) &&
                 !filter->FSRefCount &&
                 !diffAreaFile->Filter->SnapshotsPresent &&
                 !filter->UsedForPaging && extension->OkToGrowDiffArea) ||
                extension->PastFileSystemOperations) {

                InsertTailList(&extension->WaitingForDiffAreaSpace,
                               &diffAreaFile->WorkItem.List);
                KeReleaseSpinLock(&filter->SpinLock, irql2);
                KeReleaseSpinLock(&extension->SpinLock, irql);
                return;
            }
            KeReleaseSpinLock(&filter->SpinLock, irql2);
        }
        KeReleaseSpinLock(&extension->SpinLock, irql);
    }

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    dontNeedWrite = diffAreaFile->TableUpdateInProgress;
    diffAreaFile->NextBlockAllocationComplete = TRUE;
    diffAreaFile->TableUpdateInProgress = TRUE;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    if (!dontNeedWrite) {
        VspWriteTableUpdates(diffAreaFile);
    }
}

VOID
VspWriteTableUpdates(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

/*++

Routine Description:

    This routine adds the table entries into the diff area block and
    writes them to disk.  As needed this routine re-iterates and allocates
    new diff area blocks.

Arguments:

    DiffAreaFile    - Supplies the diff area file.

Return Value:

    None.

--*/

{
    PVOLUME_EXTENSION                   extension = DiffAreaFile->Extension;
    KIRQL                               irql;
    PVSP_BLOCK_DIFF_AREA                diffAreaBlock;
    PLIST_ENTRY                         l;
    PTEMP_TRANSLATION_TABLE_ENTRY       tableEntry;
    PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY    diffAreaTableEntry;
    PIRP                                irp;
    PIO_STACK_LOCATION                  nextSp;

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (DiffAreaFile->IrpNeeded) {
        DiffAreaFile->IrpNeeded = FALSE;
        KeReleaseSpinLock(&extension->SpinLock, irql);

        KeSetEvent(&DiffAreaFile->IrpReady, IO_NO_INCREMENT, FALSE);
        return;
    }
    if (IsListEmpty(&DiffAreaFile->TableUpdateQueue)) {
        DiffAreaFile->TableUpdateInProgress = FALSE;
        KeReleaseSpinLock(&extension->SpinLock, irql);
        return;
    }

    diffAreaBlock = (PVSP_BLOCK_DIFF_AREA)
            MmGetMdlVirtualAddress(DiffAreaFile->TableUpdateIrp->MdlAddress);

    if (DiffAreaFile->NextFreeTableEntryOffset +
        sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY) > BLOCK_SIZE) {

        if (DiffAreaFile->NextBlockAllocationComplete) {
            DiffAreaFile->NextBlockAllocationComplete = FALSE;
            ASSERT(DiffAreaFile->NextBlockAllocationInProgress);
            DiffAreaFile->NextBlockAllocationInProgress = FALSE;
            KeReleaseSpinLock(&extension->SpinLock, irql);

            if (!NT_SUCCESS(DiffAreaFile->StatusOfNextBlockAllocate)) {
                if (!extension->Filter->DestroyAllSnapshotsPending) {
                    VspLogError(extension, NULL,
                                VS_ABORT_SNAPSHOTS_OUT_OF_DIFF_AREA,
                                STATUS_SUCCESS, 1, FALSE);
                }
                VspKillTableUpdates(DiffAreaFile);
                return;
            }

            VspCreateNewDiffAreaBlockPhase1(DiffAreaFile);
            return;
        }

        DiffAreaFile->TableUpdateInProgress = FALSE;

        if (DiffAreaFile->NextBlockAllocationInProgress) {
            KeReleaseSpinLock(&extension->SpinLock, irql);
            return;
        }

        DiffAreaFile->NextBlockAllocationInProgress = TRUE;
        KeReleaseSpinLock(&extension->SpinLock, irql);

        ASSERT(!diffAreaBlock->Header.NextVolumeOffset);
        ExInitializeWorkItem(&DiffAreaFile->WorkItem,
                             VspCreateNewDiffAreaBlockAllocate,
                             DiffAreaFile);
        VspAcquireNonPagedResource(extension, &DiffAreaFile->WorkItem, TRUE);
        return;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    InitializeListHead(&DiffAreaFile->TableUpdatesInProgress);

    for (;;) {

        if (DiffAreaFile->NextFreeTableEntryOffset +
            sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY) > BLOCK_SIZE) {

            break;
        }

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (IsListEmpty(&DiffAreaFile->TableUpdateQueue)) {
            KeReleaseSpinLock(&extension->SpinLock, irql);
            break;
        }

        l = RemoveHeadList(&DiffAreaFile->TableUpdateQueue);
        tableEntry = CONTAINING_RECORD(l, TEMP_TRANSLATION_TABLE_ENTRY,
                                       TableUpdateListEntry);
        tableEntry->InTableUpdateQueue = FALSE;
        KeReleaseSpinLock(&extension->SpinLock, irql);

        InsertTailList(&DiffAreaFile->TableUpdatesInProgress, l);

        diffAreaTableEntry = (PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY)
                             ((PCHAR) diffAreaBlock +
                              DiffAreaFile->NextFreeTableEntryOffset);
        DiffAreaFile->NextFreeTableEntryOffset +=
                sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY);

        if (tableEntry->IsMoveEntry) {
            diffAreaTableEntry->SnapshotVolumeOffset =
                    tableEntry->FileOffset;
            diffAreaTableEntry->DiffAreaFileOffset =
                    tableEntry->VolumeOffset;
            diffAreaTableEntry->Flags |=
                    VSP_DIFF_AREA_TABLE_ENTRY_FLAG_MOVE_ENTRY;
        } else {
            diffAreaTableEntry->SnapshotVolumeOffset =
                    tableEntry->VolumeOffset;
            diffAreaTableEntry->DiffAreaFileOffset =
                    tableEntry->FileOffset;
            diffAreaTableEntry->DiffAreaVolumeOffset =
                    tableEntry->TargetOffset;
        }
    }

    irp = DiffAreaFile->TableUpdateIrp;
    nextSp = IoGetNextIrpStackLocation(irp);
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Write.ByteOffset.QuadPart =
            diffAreaBlock->Header.ThisVolumeOffset;
    ASSERT(diffAreaBlock->Header.ThisVolumeOffset ==
           DiffAreaFile->TableTargetOffset);
    nextSp->Parameters.Write.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = DiffAreaFile->Filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspWriteTableUpdatesCompletion, DiffAreaFile,
                           TRUE, TRUE, TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);
}

NTSTATUS
VspWriteVolumePhase3(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           TableEntry
    )

/*++

Routine Description:

    This routine is the completion for a write to the diff area file.

Arguments:

    Context - Supplies the context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    NTSTATUS                        status = Irp->IoStatus.Status;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    KIRQL                           irql;
    BOOLEAN                         dontNeedWrite;

    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, extension->DiffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 10, FALSE);
        }
        VspDestroyAllSnapshots(filter, tableEntry, FALSE, FALSE);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    VspFreeCopyIrp(extension, Irp);
    tableEntry->CopyIrp = NULL;

    if (extension->IsPersistent) {

        diffAreaFile = extension->DiffAreaFile;

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        InsertTailList(&diffAreaFile->TableUpdateQueue,
                       &tableEntry->TableUpdateListEntry);
        tableEntry->InTableUpdateQueue = TRUE;
        dontNeedWrite = diffAreaFile->TableUpdateInProgress;
        diffAreaFile->TableUpdateInProgress = TRUE;
        KeReleaseSpinLock(&extension->SpinLock, irql);

        if (!dontNeedWrite) {
            VspWriteTableUpdates(diffAreaFile);
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    VspWriteVolumePhase35(tableEntry);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspWriteVolumePhase25(
    IN  PVOID   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PIRP                            irp = tableEntry->CopyIrp;
    PIO_STACK_LOCATION              nextSp = IoGetNextIrpStackLocation(irp);
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    NTSTATUS                        status;
    PFILTER_EXTENSION               filter;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    KIRQL                           irql, irql2;

    status = VspAllocateDiffAreaSpace(extension, &tableEntry->TargetOffset,
                                      &tableEntry->FileOffset, NULL, NULL);
    VspReleaseNonPagedResource(extension);

    if (!NT_SUCCESS(status)) {
        diffAreaFile = extension->DiffAreaFile;
        filter = extension->Filter;

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (extension->GrowDiffAreaFilePending) {
            KeAcquireSpinLock(&filter->SpinLock, &irql2);
            if ((IsListEmpty(&filter->DiffAreaFilesOnThisFilter) &&
                 !filter->FSRefCount &&
                 !diffAreaFile->Filter->SnapshotsPresent &&
                 !filter->UsedForPaging && extension->OkToGrowDiffArea) ||
                extension->PastFileSystemOperations) {

                ExInitializeWorkItem(&tableEntry->WorkItem,
                                     VspWriteVolumePhase25,
                                     tableEntry);
                InsertTailList(&extension->WaitingForDiffAreaSpace,
                               &tableEntry->WorkItem.List);
                KeReleaseSpinLock(&filter->SpinLock, irql2);
                KeReleaseSpinLock(&extension->SpinLock, irql);
                return;
            }
            KeReleaseSpinLock(&filter->SpinLock, irql2);
        }
        KeReleaseSpinLock(&extension->SpinLock, irql);

        ObReferenceObject(extension->DeviceObject);
        ObReferenceObject(filter->DeviceObject);

        if (VspDestroyAllSnapshots(filter, tableEntry, FALSE, FALSE)) {
            if (extension->GrowFailed) {
                if (extension->UserImposedLimit) {
                    VspLogError(extension, NULL,
                                VS_ABORT_NO_DIFF_AREA_SPACE_USER_IMPOSED,
                                STATUS_SUCCESS, 2, FALSE);
                } else {
                    VspLogError(extension, NULL,
                                VS_ABORT_NO_DIFF_AREA_SPACE_GROW_FAILED,
                                STATUS_SUCCESS, 0, FALSE);
                }
            } else {
                VspLogError(extension, NULL,
                            VS_ABORT_SNAPSHOTS_OUT_OF_DIFF_AREA,
                            STATUS_SUCCESS, 3, FALSE);
            }
        }

        ObDereferenceObject(filter->DeviceObject);
        ObDereferenceObject(extension->DeviceObject);

        return;
    }

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp->Parameters.Write.ByteOffset.QuadPart = tableEntry->TargetOffset;
    nextSp->Parameters.Write.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = tableEntry->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspWriteVolumePhase3, tableEntry, TRUE, TRUE,
                           TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);
}

NTSTATUS
VspWriteVolumePhase2(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           TableEntry
    )

/*++

Routine Description:

    This routine is the completion for a read who's data will create
    the table entry for the block that is being written to.

Arguments:

    Context - Supplies the context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;

    if (!NT_SUCCESS(status)) {
        if (!extension->Filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, extension->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 11, FALSE);
        }
        VspDestroyAllSnapshots(extension->Filter, tableEntry, FALSE, FALSE);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (tableEntry->TargetOffset) {
        irp = tableEntry->CopyIrp;
        nextSp = IoGetNextIrpStackLocation(irp);
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        nextSp->Parameters.Write.ByteOffset.QuadPart =
                tableEntry->TargetOffset;
        nextSp->Parameters.Write.Length = BLOCK_SIZE;
        nextSp->MajorFunction = IRP_MJ_WRITE;
        nextSp->DeviceObject = tableEntry->TargetObject;
        nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

        IoSetCompletionRoutine(irp, VspWriteVolumePhase3, tableEntry, TRUE,
                               TRUE, TRUE);

        IoCallDriver(nextSp->DeviceObject, irp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase25,
                         tableEntry);
    VspAcquireNonPagedResource(extension, &tableEntry->WorkItem, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspWriteVolumePhase15(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           TableEntry
    )

{
    NTSTATUS                        status = Irp->IoStatus.Status;
    PIO_STACK_LOCATION              nextSp = IoGetNextIrpStackLocation(Irp);
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    PVOID                           buffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
    ULONG                           i;

    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, extension->DiffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_IO_FAILURE, status, 12, FALSE);
        }
        VspDestroyAllSnapshots(filter, tableEntry, FALSE, FALSE);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    for (i = 0; i < BLOCK_SIZE; i += SMALLEST_NTFS_CLUSTER) {
        if (RtlCompareMemory((PCHAR) buffer + i, &VSP_DIFF_AREA_FILE_GUID,
                             sizeof(GUID)) != sizeof(GUID)) {

            break;
        }
    }

    if (i < BLOCK_SIZE) {
        tableEntry->TargetOffset = 0;
        ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase12,
                             tableEntry);
        VspAcquireNonPagedResource(extension, &tableEntry->WorkItem, FALSE);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(Irp);
    nextSp->Parameters.Read.ByteOffset.QuadPart = tableEntry->VolumeOffset;
    nextSp->Parameters.Read.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    if (tableEntry->VolumeOffset + BLOCK_SIZE > extension->VolumeSize) {
        if (extension->VolumeSize > tableEntry->VolumeOffset) {
            nextSp->Parameters.Read.Length = (ULONG)
                    (extension->VolumeSize - tableEntry->VolumeOffset);
        }
    }

    IoSetCompletionRoutine(Irp, VspWriteVolumePhase2, tableEntry, TRUE, TRUE,
                           TRUE);

    IoCallDriver(nextSp->DeviceObject, Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspWriteVolumePhase12(
    IN  PVOID   TableEntry
    )

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    PIRP                            irp = tableEntry->CopyIrp;
    NTSTATUS                        status;
    PIO_STACK_LOCATION              nextSp;

    if (tableEntry->TargetOffset) {
        status = STATUS_SUCCESS;
    } else {
        status = VspAllocateDiffAreaSpace(extension, &tableEntry->TargetOffset,
                                          &tableEntry->FileOffset, NULL, NULL);
    }
    VspReleaseNonPagedResource(extension);

    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, NULL, VS_ABORT_SNAPSHOTS_OUT_OF_DIFF_AREA,
                        status, 4, FALSE);
        }
        VspDestroyAllSnapshots(filter, tableEntry, FALSE, FALSE);
        return;
    }

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(irp);
    nextSp->Parameters.Read.ByteOffset.QuadPart = tableEntry->TargetOffset;
    nextSp->Parameters.Read.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = tableEntry->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspWriteVolumePhase15, tableEntry, TRUE,
                           TRUE, TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);
}

VOID
VspWriteVolumePhase1(
    IN  PVOID   TableEntry
    )

/*++

Routine Description:

    This routine is the first phase of copying volume data to the diff
    area file.  An irp and buffer are created for the initial read of
    the block.

Arguments:

    Context - Supplies the context.

Return Value:

    None.

--*/

{
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) TableEntry;
    PVOLUME_EXTENSION               extension = tableEntry->Extension;
    PFILTER_EXTENSION               filter = extension->Filter;
    PIRP                            irp = tableEntry->CopyIrp;
    PIO_STACK_LOCATION              nextSp;

    irp->Flags &= ~(IRP_HIGH_PRIORITY_PAGING_IO | IRP_PAGING_IO);
    irp->Flags |= (tableEntry->WriteIrp->Flags&
                   (IRP_HIGH_PRIORITY_PAGING_IO | IRP_PAGING_IO));

    if (extension->IsDetected && !extension->OkToGrowDiffArea &&
        !extension->NoDiffAreaFill) {

        ExInitializeWorkItem(&tableEntry->WorkItem, VspWriteVolumePhase12,
                             tableEntry);
        VspAcquireNonPagedResource(extension, &tableEntry->WorkItem, FALSE);
        return;
    }

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(irp);
    nextSp->Parameters.Read.ByteOffset.QuadPart = tableEntry->VolumeOffset;
    nextSp->Parameters.Read.Length = BLOCK_SIZE;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = filter->TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    if (tableEntry->VolumeOffset + BLOCK_SIZE > extension->VolumeSize) {
        if (extension->VolumeSize > tableEntry->VolumeOffset) {
            nextSp->Parameters.Read.Length = (ULONG)
                    (extension->VolumeSize - tableEntry->VolumeOffset);
        }
    }

    IoSetCompletionRoutine(irp, VspWriteVolumePhase2, tableEntry, TRUE, TRUE,
                           TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);
}

VOID
VspUnmapNextDiffAreaFileMap(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    NTSTATUS            status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(extension->Root, context);

    if (extension->NextDiffAreaFileMap) {
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        extension->NextDiffAreaFileMap = NULL;
    }

    VspReleasePagedResource(extension);
    ObDereferenceObject(extension->Filter->DeviceObject);
    ObDereferenceObject(extension->DeviceObject);
}

NTSTATUS
VspTruncatePreviousDiffArea(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine takes the snapshot that occurred before this one and
    truncates its diff area file to the current used size since diff
    area files can't grow after a new snapshot is added on top.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    PLIST_ENTRY                 l, ll;
    PVOLUME_EXTENSION           extension;
    PVSP_DIFF_AREA_FILE         diffAreaFile;
    NTSTATUS                    status;
    LONGLONG                    diff;
    KIRQL                       irql;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PVSP_CONTEXT                context;

    l = Extension->ListEntry.Blink;
    if (l == &filter->VolumeList) {
        return STATUS_SUCCESS;
    }

    extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

    diffAreaFile = extension->DiffAreaFile;
    ASSERT(diffAreaFile);

    status = VspSetFileSize(diffAreaFile->FileHandle,
                            diffAreaFile->NextAvailable);

    VspAcquireNonPagedResource(extension, NULL, FALSE);

    if (NT_SUCCESS(status)) {
        diff = diffAreaFile->AllocatedFileSize - diffAreaFile->NextAvailable;
        diffAreaFile->AllocatedFileSize -= diff;
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        filter->AllocatedVolumeSpace -= diff;
        KeReleaseSpinLock(&filter->SpinLock, irql);
    }

    while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
        ll = RemoveHeadList(&diffAreaFile->UnusedAllocationList);
        diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        ExFreePool(diffAreaFileAllocation);
    }

    if (diffAreaFile->TableUpdateIrp) {
        ExFreePool(MmGetMdlVirtualAddress(
                   diffAreaFile->TableUpdateIrp->MdlAddress));
        IoFreeMdl(diffAreaFile->TableUpdateIrp->MdlAddress);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        diffAreaFile->TableUpdateIrp = NULL;
    }

    VspReleaseNonPagedResource(extension);

    if (extension->EmergencyCopyIrp) {
        ExFreePool(MmGetMdlVirtualAddress(
                   extension->EmergencyCopyIrp->MdlAddress));
        IoFreeMdl(extension->EmergencyCopyIrp->MdlAddress);
        IoFreeIrp(extension->EmergencyCopyIrp);
        extension->EmergencyCopyIrp = NULL;
    }

    context = VspAllocateContext(Extension->Root);
    if (context) {
        context->Type = VSP_CONTEXT_TYPE_EXTENSION;
        context->Extension.Extension = extension;
        ExInitializeWorkItem(&context->WorkItem, VspUnmapNextDiffAreaFileMap,
                             context);
        ObReferenceObject(extension->DeviceObject);
        ObReferenceObject(extension->Filter->DeviceObject);
        VspAcquirePagedResource(extension, &context->WorkItem);
    }

    if (extension->IgnoreCopyDataReference) {
        extension->IgnoreCopyDataReference = FALSE;
        InterlockedDecrement(&filter->IgnoreCopyData);
    }

    return STATUS_SUCCESS;
}

VOID
VspOrBitmaps(
    IN OUT  PRTL_BITMAP BaseBitmap,
    IN      PRTL_BITMAP FactorBitmap
    )

{
    ULONG   n, i;
    PULONG  p, q;

    n = (BaseBitmap->SizeOfBitMap + 8*sizeof(ULONG) - 1)/(8*sizeof(ULONG));
    p = BaseBitmap->Buffer;
    q = FactorBitmap->Buffer;

    for (i = 0; i < n; i++) {
        *p++ |= *q++;
    }
}

NTSTATUS
VspQueryFileOffset(
    IN  PLIST_ENTRY                 ExtentList,
    IN  LONGLONG                    VolumeOffset,
    IN  PDIFF_AREA_FILE_ALLOCATION  StartFileAllocation,
    IN  LONGLONG                    StartFileAllocationFileOffset,
    OUT PLONGLONG                   ResultFileOffset,
    OUT PDIFF_AREA_FILE_ALLOCATION* ResultFileAllocation,
    OUT PLONGLONG                   ResultFileAllocationFileOffset,
    OUT PLONGLONG                   Length
    )

{
    PLIST_ENTRY                 l, start;
    LONGLONG                    fileOffset, delta;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaAllocation;

    ASSERT(!IsListEmpty(ExtentList));

    if (!StartFileAllocation) {
        StartFileAllocation = CONTAINING_RECORD(ExtentList->Flink,
                                                DIFF_AREA_FILE_ALLOCATION,
                                                ListEntry);
        StartFileAllocationFileOffset = 0;
    }

    ASSERT(&StartFileAllocation->ListEntry != ExtentList);

    start = &StartFileAllocation->ListEntry;
    l = start;
    fileOffset = StartFileAllocationFileOffset;

    for (;;) {

        diffAreaAllocation = CONTAINING_RECORD(l, DIFF_AREA_FILE_ALLOCATION,
                                               ListEntry);

        if (diffAreaAllocation->NLength <= 0) {
            fileOffset -= diffAreaAllocation->NLength;
        } else {

            if (diffAreaAllocation->Offset <= VolumeOffset &&
                diffAreaAllocation->Offset + diffAreaAllocation->NLength >
                VolumeOffset) {

                delta = VolumeOffset - diffAreaAllocation->Offset;
                *ResultFileOffset = fileOffset + delta;
                *ResultFileAllocation = diffAreaAllocation;
                *ResultFileAllocationFileOffset = fileOffset;
                if (Length) {
                    *Length = diffAreaAllocation->NLength - delta;
                }

                return STATUS_SUCCESS;
            }

            fileOffset += diffAreaAllocation->NLength;
        }


        l = l->Flink;
        if (l == ExtentList) {
            fileOffset = 0;
            l = l->Flink;
        }
        if (l == start) {
            break;
        }
    }

    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
VspCheckBlockChainFileOffsets(
    IN  PFILTER_EXTENSION   Filter,
    IN  LONGLONG            StartingVolumeOffset,
    IN  PLIST_ENTRY         ExtentList
    )

{
    PVSP_BLOCK_HEADER           blockHeader;
    LONGLONG                    volumeOffset, fileOffset;
    NTSTATUS                    status;
    PDIFF_AREA_FILE_ALLOCATION  startFileAllocation, resultFileAllocation;
    LONGLONG                    startFileAllocationFileOffset;
    LONGLONG                    resultFileAllocationFileOffset;

    if (IsListEmpty(ExtentList) || !StartingVolumeOffset) {
        return STATUS_FILE_CORRUPT_ERROR;
    }

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    if (!Filter->SnapshotOnDiskIrp) {
        VspReleaseNonPagedResource(Filter);
        return STATUS_INVALID_PARAMETER;
    }

    blockHeader = (PVSP_BLOCK_HEADER) MmGetMdlVirtualAddress(
                  Filter->SnapshotOnDiskIrp->MdlAddress);
    volumeOffset = StartingVolumeOffset;
    startFileAllocation = NULL;
    startFileAllocationFileOffset = 0;

    while (volumeOffset) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  volumeOffset, 0);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            return status;
        }

        status = VspQueryFileOffset(ExtentList, volumeOffset,
                                    startFileAllocation,
                                    startFileAllocationFileOffset,
                                    &fileOffset, &resultFileAllocation,
                                    &resultFileAllocationFileOffset, NULL);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            return status;
        }

        if (fileOffset != blockHeader->ThisFileOffset) {
            ASSERT(FALSE);
            VspReleaseNonPagedResource(Filter);
            return STATUS_FILE_CORRUPT_ERROR;
        }

        volumeOffset = blockHeader->NextVolumeOffset;
        startFileAllocation = resultFileAllocation;
        startFileAllocationFileOffset = resultFileAllocationFileOffset;
    }

    VspReleaseNonPagedResource(Filter);

    return status;
}

NTSTATUS
VspCheckControlBlockFileLocation(
    IN  PFILTER_EXTENSION   Filter
    )

{
    HANDLE                      h = Filter->ControlBlockFileHandle;
    NTSTATUS                    status;
    LIST_ENTRY                  extentList;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;

    if (!h) {
        return STATUS_INVALID_PARAMETER;
    }

    status = VspQueryListOfExtents(h, 0, &extentList, NULL, FALSE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = VspCheckBlockChainFileOffsets(Filter,
             Filter->FirstControlBlockVolumeOffset, &extentList);

    while (!IsListEmpty(&extentList)) {
        l = RemoveHeadList(&extentList);
        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        ExFreePool(diffAreaFileAllocation);
    }

    return status;
}

VOID
VspWaitForVolumesSafeForWriteAccess(
    IN  PDO_EXTENSION   RootExtension
    )

{
    UNICODE_STRING      volumeSafeEventName;
    OBJECT_ATTRIBUTES   oa;
    KEVENT              event;
    LARGE_INTEGER       timeout;
    ULONG               i;
    NTSTATUS            status;
    HANDLE              volumeSafeEvent;

    if (RootExtension->IsSetup || RootExtension->VolumesSafeForWriteAccess) {
        return;
    }

    RtlInitUnicodeString(&volumeSafeEventName,
                         L"\\Device\\VolumesSafeForWriteAccess");
    InitializeObjectAttributes(&oa, &volumeSafeEventName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL,
                               NULL);
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    timeout.QuadPart = -10*1000*1000;   // 1 second

    for (i = 0; i < 1000; i++) {
        status = ZwOpenEvent(&volumeSafeEvent, EVENT_ALL_ACCESS, &oa);
        if (NT_SUCCESS(status)) {
            break;
        }
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &timeout);
        if (RootExtension->VolumesSafeForWriteAccess) {
            return;
        }
    }
    if (i == 1000) {
        return;
    }

    for (;;) {
        status = ZwWaitForSingleObject(volumeSafeEvent, FALSE, &timeout);
        if (status != STATUS_TIMEOUT) {
            InterlockedExchange(&RootExtension->VolumesSafeForWriteAccess,
                                TRUE);
            break;
        }
        if (RootExtension->VolumesSafeForWriteAccess) {
            break;
        }
    }

    ZwClose(volumeSafeEvent);
}

NTSTATUS
VspOpenControlBlockFile(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PFILTER_EXTENSION       filter = Filter;
    NTSTATUS                status;
    UNICODE_STRING          fileName;
    PWCHAR                  star;
    OBJECT_ATTRIBUTES       oa;
    HANDLE                  h;
    IO_STATUS_BLOCK         ioStatus;
    PLIST_ENTRY             l;
    PVSP_LOOKUP_TABLE_ENTRY lookupEntry;
    GUID                    snapshotGuid;
    ULONG                   i;
    LARGE_INTEGER           timeout;
    KEVENT                  event;

    if (filter->ControlBlockFileHandle) {
        return STATUS_SUCCESS;
    }

    VspWaitForVolumesSafeForWriteAccess(filter->Root);

    KeWaitForSingleObject(&filter->ControlBlockFileHandleSemaphore,
                          Executive, KernelMode, FALSE, NULL);

    if (filter->ControlBlockFileHandle) {
        KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_SUCCESS;
    }

    VspAcquireNonPagedResource(filter, NULL, FALSE);
    VspCreateStartBlock(filter, filter->FirstControlBlockVolumeOffset,
                        filter->MaximumVolumeSpace);
    VspReleaseNonPagedResource(filter);

    status = VspCreateDiffAreaFileName(filter->TargetObject, NULL,
                                       &fileName, FALSE, NULL);
    if (!NT_SUCCESS(status)) {
        KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    star = fileName.Buffer + fileName.Length/sizeof(WCHAR) - 39;

    RtlMoveMemory(star, star + 1, 38*sizeof(WCHAR));
    fileName.Length -= sizeof(WCHAR);
    fileName.Buffer[fileName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    timeout.QuadPart = -10*1000; // 1 millisecond.

    for (i = 0; i < 5000; i++) {
        status = ZwOpenFile(&h, FILE_GENERIC_READ | FILE_GENERIC_WRITE, &oa,
                            &ioStatus, 0, FILE_WRITE_THROUGH |
                            FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE |
                            FILE_NO_COMPRESSION);
        if (NT_SUCCESS(status)) {
            break;
        }

        // Wait for RAW to DISMOUNT or for the DISMOUNT handle to close.

        if (status != STATUS_INVALID_PARAMETER &&
            status != STATUS_ACCESS_DENIED) {

            break;
        }

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                              &timeout);
    }
    ExFreePool(fileName.Buffer);
    if (!NT_SUCCESS(status)) {
        KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    ASSERT(!filter->ControlBlockFileHandle);
    InterlockedExchangePointer(&filter->ControlBlockFileHandle, h);

    VspAcquire(filter->Root);
    if (filter->IsRemoved) {
        VspRelease(filter->Root);
        h = InterlockedExchangePointer(&filter->ControlBlockFileHandle,
                                       NULL);
        if (h) {
            ZwClose(h);
        }
        KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_UNSUCCESSFUL;
    }
    VspRelease(filter->Root);

    status = VspPinFile(filter->TargetObject, h);
    if (!NT_SUCCESS(status)) {
        h = InterlockedExchangePointer(&filter->ControlBlockFileHandle,
                                       NULL);
        if (h) {
            ZwClose(h);
        }
        KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    status = VspCheckControlBlockFileLocation(filter);
    if (!NT_SUCCESS(status)) {
        h = InterlockedExchangePointer(&filter->ControlBlockFileHandle,
                                       NULL);
        if (h) {
            ZwClose(h);
        }
        KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return status;
    }

    VspAcquireNonPagedResource(filter, NULL, FALSE);
    if (!filter->FirstControlBlockVolumeOffset) {
        h = InterlockedExchangePointer(&filter->ControlBlockFileHandle,
                                       NULL);
        VspReleaseNonPagedResource(filter);
        if (h) {
            ZwClose(h);
        }
        KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                           IO_NO_INCREMENT, 1, FALSE);
        return STATUS_UNSUCCESSFUL;
    }
    VspReleaseNonPagedResource(filter);

    KeReleaseSemaphore(&filter->ControlBlockFileHandleSemaphore,
                       IO_NO_INCREMENT, 1, FALSE);

    return STATUS_SUCCESS;
}
VOID
VspOpenControlBlockFileWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;
    NTSTATUS            status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_FILTER);

    KeWaitForSingleObject(&filter->Root->PastBootReinit, Executive,
                          KernelMode, FALSE, NULL);

    status = VspOpenControlBlockFile(filter);
    if (!NT_SUCCESS(status)) {
        VspAcquireNonPagedResource(filter, NULL, FALSE);
        VspCreateStartBlock(filter, 0, filter->MaximumVolumeSpace);
        filter->FirstControlBlockVolumeOffset = 0;
        VspReleaseNonPagedResource(filter);
    }

    VspFreeContext(filter->Root, context);
    ObDereferenceObject(filter->TargetObject);
    ObDereferenceObject(filter->DeviceObject);
}

NTSTATUS
VspCheckDiffAreaFileLocation(
    IN  PFILTER_EXTENSION   Filter,
    IN  HANDLE              FileHandle,
    IN  LONGLONG            ApplicationInfoOffset,
    IN  LONGLONG            FirstDiffAreaBlockOffset,
    IN  LONGLONG            LocationOffset,
    IN  LONGLONG            InitialBitmapOffset,
    IN  BOOLEAN             CheckUnused
    )

{
    NTSTATUS                            status;
    LIST_ENTRY                          extentList;
    PLIST_ENTRY                         l;
    PDIFF_AREA_FILE_ALLOCATION          diffAreaFileAllocation;
    PVSP_BLOCK_HEADER                   blockHeader;
    LONGLONG                            volumeOffset, fileOffset;
    PDIFF_AREA_FILE_ALLOCATION          startFileAllocation, resultFileAllocation;
    LONGLONG                            startFileAllocationFileOffset;
    LONGLONG                            resultFileAllocationFileOffset;
    PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY    diffAreaTableEntry;
    ULONG                               blockOffset;
    PVSP_DIFF_AREA_LOCATION_DESCRIPTOR  locationDescriptor;
    LONGLONG                            length;

    if (!FileHandle) {
        return STATUS_INVALID_PARAMETER;
    }

    status = VspQueryListOfExtents(FileHandle, 0, &extentList, NULL, FALSE);
    if (!NT_SUCCESS(status)) {
        ASSERT(FALSE);
        return status;
    }

    status = VspCheckBlockChainFileOffsets(Filter, ApplicationInfoOffset,
                                           &extentList);
    if (!NT_SUCCESS(status)) {
        goto Finish;
    }

    status = VspCheckBlockChainFileOffsets(Filter, FirstDiffAreaBlockOffset,
                                           &extentList);
    if (!NT_SUCCESS(status)) {
        goto Finish;
    }

    status = VspCheckBlockChainFileOffsets(Filter, LocationOffset,
                                           &extentList);
    if (!NT_SUCCESS(status)) {
        goto Finish;
    }

    if (InitialBitmapOffset) {
        status = VspCheckBlockChainFileOffsets(Filter, InitialBitmapOffset,
                                               &extentList);
        if (!NT_SUCCESS(status)) {
            goto Finish;
        }
    }

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    if (!Filter->SnapshotOnDiskIrp) {
        VspReleaseNonPagedResource(Filter);
        status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    blockHeader = (PVSP_BLOCK_HEADER) MmGetMdlVirtualAddress(
                  Filter->SnapshotOnDiskIrp->MdlAddress);
    volumeOffset = FirstDiffAreaBlockOffset;
    startFileAllocation = NULL;
    startFileAllocationFileOffset = 0;

    while (volumeOffset) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  volumeOffset, 0);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            goto Finish;
        }

        for (blockOffset = VSP_OFFSET_TO_FIRST_TABLE_ENTRY;
             blockOffset + sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY) <=
             BLOCK_SIZE;
             blockOffset += sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY)) {

            diffAreaTableEntry = (PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY)
                                 ((PCHAR) blockHeader + blockOffset);

            if (!diffAreaTableEntry->DiffAreaVolumeOffset) {
                continue;
            }

            status = VspQueryFileOffset(
                     &extentList, diffAreaTableEntry->DiffAreaVolumeOffset,
                     startFileAllocation, startFileAllocationFileOffset,
                     &fileOffset, &resultFileAllocation,
                     &resultFileAllocationFileOffset, NULL);
            if (!NT_SUCCESS(status)) {
                VspReleaseNonPagedResource(Filter);
                goto Finish;
            }

            if (fileOffset != diffAreaTableEntry->DiffAreaFileOffset) {
                status = STATUS_FILE_CORRUPT_ERROR;
                ASSERT(FALSE);
                VspReleaseNonPagedResource(Filter);
                goto Finish;
            }

            startFileAllocation = resultFileAllocation;
            startFileAllocationFileOffset =
                    resultFileAllocationFileOffset;
        }

        volumeOffset = blockHeader->NextVolumeOffset;
    }

    if (!CheckUnused) {
        VspReleaseNonPagedResource(Filter);
        goto Finish;
    }

    blockHeader = (PVSP_BLOCK_HEADER) MmGetMdlVirtualAddress(
                  Filter->SnapshotOnDiskIrp->MdlAddress);
    volumeOffset = LocationOffset;
    startFileAllocation = NULL;
    startFileAllocationFileOffset = 0;

    while (volumeOffset) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  volumeOffset, 0);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            goto Finish;
        }

        for (blockOffset = VSP_OFFSET_TO_FIRST_LOCATION_DESCRIPTOR;
             blockOffset + sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR) <=
             BLOCK_SIZE;
             blockOffset += sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR)) {

            locationDescriptor = (PVSP_DIFF_AREA_LOCATION_DESCRIPTOR)
                                 ((PCHAR) blockHeader + blockOffset);

            if (!locationDescriptor->VolumeOffset) {
                continue;
            }

            status = VspQueryFileOffset(
                     &extentList, locationDescriptor->VolumeOffset,
                     startFileAllocation, startFileAllocationFileOffset,
                     &fileOffset, &resultFileAllocation,
                     &resultFileAllocationFileOffset, &length);
            if (!NT_SUCCESS(status)) {
                VspReleaseNonPagedResource(Filter);
                goto Finish;
            }

            if (fileOffset != locationDescriptor->FileOffset ||
                length < locationDescriptor->Length) {

                status = STATUS_FILE_CORRUPT_ERROR;
                ASSERT(FALSE);
                VspReleaseNonPagedResource(Filter);
                goto Finish;
            }

            startFileAllocation = resultFileAllocation;
            startFileAllocationFileOffset =
                    resultFileAllocationFileOffset;
        }

        volumeOffset = blockHeader->NextVolumeOffset;
    }

    VspReleaseNonPagedResource(Filter);

Finish:
    while (!IsListEmpty(&extentList)) {
        l = RemoveHeadList(&extentList);
        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        ExFreePool(diffAreaFileAllocation);
    }

    return status;
}

NTSTATUS
VspOpenFilesAndValidateSnapshots(
    IN  PFILTER_EXTENSION   Filter
    )

{
    NTSTATUS            status;
    PLIST_ENTRY         l;
    UNICODE_STRING      fileName;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;
    PVOLUME_EXTENSION   extension;
    PFILTER_EXTENSION   diffAreaFilter;
    LONGLONG            appInfoOffset, firstDiffAreaBlockOffset, locationOffset, initialBitmapOffset;
    BOOLEAN             checkUnused;
    ULONG               i;
    LARGE_INTEGER       timeout;
    KEVENT              event;

    status = VspOpenControlBlockFile(Filter);
    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, Filter, VS_FAILURE_TO_OPEN_CRITICAL_FILE,
                    status, 1, FALSE);
        return status;
    }

    status = STATUS_SUCCESS;
    for (;;) {

        VspAcquire(Filter->Root);
        for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
             l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

            if (extension->DiffAreaFile &&
                !extension->DiffAreaFile->FileHandle) {

                break;
            }
        }

        if (l == &Filter->VolumeList) {
            VspRelease(Filter->Root);
            break;
        }

        diffAreaFilter = extension->DiffAreaFile->Filter;
        appInfoOffset = extension->DiffAreaFile->ApplicationInfoTargetOffset;
        locationOffset =
            extension->DiffAreaFile->DiffAreaLocationDescriptionTargetOffset;
        firstDiffAreaBlockOffset =
                extension->DiffAreaFile->FirstTableTargetOffset;
        initialBitmapOffset =
                extension->DiffAreaFile->InitialBitmapVolumeOffset;
        ObReferenceObject(extension->DeviceObject);
        ObReferenceObject(diffAreaFilter->DeviceObject);
        ObReferenceObject(diffAreaFilter->TargetObject);

        VspRelease(Filter->Root);

        status = VspCreateDiffAreaFileName(
                 diffAreaFilter->TargetObject, extension, &fileName, FALSE,
                 NULL);

        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_FAILURE_TO_OPEN_CRITICAL_FILE,
                        status, 2, FALSE);
            ObDereferenceObject(diffAreaFilter->TargetObject);
            ObDereferenceObject(diffAreaFilter->DeviceObject);
            ObDereferenceObject(extension->DeviceObject);
            break;
        }

        InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE |
                                   OBJ_KERNEL_HANDLE, NULL, NULL);

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        timeout.QuadPart = -10*1000; // 1 millisecond.

        for (i = 0; i < 5000; i++) {

            status = ZwOpenFile(&h, FILE_GENERIC_READ | FILE_GENERIC_WRITE, &oa,
                                &ioStatus, 0, FILE_WRITE_THROUGH |
                                FILE_SYNCHRONOUS_IO_NONALERT |
                                FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE |
                                FILE_NO_COMPRESSION);
            if (NT_SUCCESS(status)) {
                break;
            }

            if (status != STATUS_ACCESS_DENIED &&
                status != STATUS_INVALID_PARAMETER) {

                break;
            }

            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  &timeout);
        }

        ExFreePool(fileName.Buffer);

        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_FAILURE_TO_OPEN_CRITICAL_FILE,
                        status, 3, FALSE);
            ObDereferenceObject(diffAreaFilter->TargetObject);
            ObDereferenceObject(diffAreaFilter->DeviceObject);
            ObDereferenceObject(extension->DeviceObject);
            break;
        }

        status = VspPinFile(diffAreaFilter->TargetObject, h);

        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_FAILURE_TO_OPEN_CRITICAL_FILE,
                        status, 4, FALSE);
            ZwClose(h);
            ObDereferenceObject(diffAreaFilter->TargetObject);
            ObDereferenceObject(diffAreaFilter->DeviceObject);
            ObDereferenceObject(extension->DeviceObject);
            break;
        }

        if (extension->ListEntry.Flink == &Filter->VolumeList) {
            checkUnused = TRUE;
        } else {
            checkUnused = FALSE;
        }

        status = VspCheckDiffAreaFileLocation(diffAreaFilter, h,
                                              appInfoOffset,
                                              firstDiffAreaBlockOffset,
                                              locationOffset,
                                              initialBitmapOffset,
                                              checkUnused);
        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_FAILURE_TO_OPEN_CRITICAL_FILE,
                        status, 5, FALSE);
            ZwClose(h);
            ObDereferenceObject(diffAreaFilter->TargetObject);
            ObDereferenceObject(diffAreaFilter->DeviceObject);
            ObDereferenceObject(extension->DeviceObject);
            break;
        }

        VspAcquire(Filter->Root);
        if (extension->IsDead || !extension->DiffAreaFile) {
            VspRelease(Filter->Root);
            ZwClose(h);
            ObDereferenceObject(diffAreaFilter->TargetObject);
            ObDereferenceObject(diffAreaFilter->DeviceObject);
            ObDereferenceObject(extension->DeviceObject);
            continue;
        }

        ASSERT(!extension->DiffAreaFile->FileHandle);
        extension->DiffAreaFile->FileHandle = h;
        VspRelease(Filter->Root);

        ObDereferenceObject(diffAreaFilter->TargetObject);
        ObDereferenceObject(diffAreaFilter->DeviceObject);
        ObDereferenceObject(extension->DeviceObject);
    }

    return status;
}

VOID
VspCallDriver(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT    context = (PVSP_CONTEXT) Context;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_COPY_EXTENTS);

    IoCallDriver(context->CopyExtents.Extension->Filter->DeviceObject,
                 context->CopyExtents.Irp);
}

DECLSPEC_NOINLINE
VOID
VspClearDirtyCrashdumpFlag(
    IN  PVSP_CONTROL_ITEM_SNAPSHOT  SnapshotControlItem
    )

{
    SnapshotControlItem->SnapshotControlItemFlags &=
            ~VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_CRASHDUMP;
}

VOID
VspMarkCrashdumpClean(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION           extension = context->CopyExtents.Extension;
    PFILTER_EXTENSION           filter = extension->Filter;
    BOOLEAN                     hiberfile = context->CopyExtents.HiberfileIncluded;
    BOOLEAN                     pagefile = context->CopyExtents.PagefileIncluded;
    UCHAR                       controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT  snapshotControlItem;
    NTSTATUS                    status;
    LONG                        hibernate;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_COPY_EXTENTS);

    VspFreeContext(filter->Root, context);

    VspAcquire(filter->Root);
    if (IsListEmpty(&filter->VolumeList)) {
        VspRelease(filter->Root);
        if (hiberfile) {
            InterlockedExchange(&filter->HibernatePending, FALSE);
        }
        ObDereferenceObject(filter->DeviceObject);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    if (!extension->IsPersistent) {
        VspRelease(filter->Root);
        ASSERT(!pagefile);
        if (hiberfile) {
            InterlockedExchange(&extension->HiberFileCopied, TRUE);
            hibernate = InterlockedExchange(&filter->HibernatePending, FALSE);
            if (hibernate) {
                IoRaiseInformationalHardError(STATUS_VOLSNAP_HIBERNATE_READY,
                                              NULL, NULL);
            }
        }
        ObDereferenceObject(filter->DeviceObject);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    VspAcquireNonPagedResource(filter, NULL, FALSE);

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &extension->SnapshotGuid, FALSE,
                              controlItemBuffer, FALSE);
    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, filter, VS_ABORT_SNAPSHOTS_IO_FAILURE,
                        status, 14, FALSE);
        }
        VspReleaseNonPagedResource(filter);
        VspRelease(filter->Root);
        VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
        if (hiberfile) {
            InterlockedExchange(&filter->HibernatePending, FALSE);
        }
        ObDereferenceObject(filter->DeviceObject);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;
    if (hiberfile) {
        snapshotControlItem->SnapshotControlItemFlags |=
                VSP_SNAPSHOT_CONTROL_ITEM_FLAG_HIBERFIL_COPIED;
        InterlockedExchange(&extension->HiberFileCopied, TRUE);
    }

    if (pagefile) {
        VspClearDirtyCrashdumpFlag(snapshotControlItem);
        snapshotControlItem->SnapshotControlItemFlags |=
                VSP_SNAPSHOT_CONTROL_ITEM_FLAG_PAGEFILE_COPIED;
        InterlockedExchange(&extension->PageFileCopied, TRUE);
    }

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &extension->SnapshotGuid, TRUE,
                              controlItemBuffer, FALSE);
    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(extension, filter, VS_ABORT_SNAPSHOTS_IO_FAILURE,
                        status, 15, FALSE);
        }
        VspReleaseNonPagedResource(filter);
        VspRelease(filter->Root);
        VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
        if (hiberfile) {
            InterlockedExchange(&filter->HibernatePending, FALSE);
        }
        ObDereferenceObject(filter->DeviceObject);
        ObDereferenceObject(extension->DeviceObject);
        return;
    }

    VspReleaseNonPagedResource(filter);

    VspRelease(filter->Root);

    if (hiberfile) {
        hibernate = InterlockedExchange(&filter->HibernatePending, FALSE);

        if (hibernate) {
            IoRaiseInformationalHardError(STATUS_VOLSNAP_HIBERNATE_READY, NULL,
                                          NULL);
        }
    }

    ObDereferenceObject(filter->DeviceObject);
    ObDereferenceObject(extension->DeviceObject);
}

NTSTATUS
VspCopyExtentsCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION           extension = context->CopyExtents.Extension;
    PFILTER_EXTENSION           filter = extension->Filter;
    PIO_STACK_LOCATION          nextSp;
    PDIFF_AREA_FILE_ALLOCATION  fileExtent;
    LONGLONG                    offset;
    ULONG                       length;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_COPY_EXTENTS);
    ASSERT(!IsListEmpty(&context->CopyExtents.ExtentList));

    fileExtent = CONTAINING_RECORD(context->CopyExtents.ExtentList.Flink,
                                   DIFF_AREA_FILE_ALLOCATION, ListEntry);
    ASSERT(fileExtent->NLength >= 0);

    if (!fileExtent->NLength) {
        RemoveEntryList(&fileExtent->ListEntry);
        ExFreePool(fileExtent);
        if (IsListEmpty(&context->CopyExtents.ExtentList)) {
            ExInitializeWorkItem(&context->WorkItem, VspMarkCrashdumpClean,
                                 context);
            ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
            IoFreeIrp(Irp);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        fileExtent = CONTAINING_RECORD(context->CopyExtents.ExtentList.Flink,
                                       DIFF_AREA_FILE_ALLOCATION, ListEntry);
        ASSERT(fileExtent->NLength > 0);
    }

    length = 0x80000;   // 512 KB
    offset = fileExtent->Offset;

    if (length > fileExtent->NLength) {
        length = (ULONG) fileExtent->NLength;
    }

    fileExtent->Offset += length;
    fileExtent->NLength -= length;

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(Irp);
    nextSp->Parameters.Write.ByteOffset.QuadPart = offset;
    nextSp->Parameters.Write.Length = length;
    nextSp->MajorFunction = IRP_MJ_WRITE;
    nextSp->DeviceObject = filter->DeviceObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(Irp, VspCopyExtentsCompletionRoutine, context,
                           TRUE, TRUE, TRUE);

    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspCopyExtents(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PLIST_ENTRY         ExtentList,
    IN  BOOLEAN             HiberfileIncluded,
    IN  BOOLEAN             PagefileIncluded
    )

{
    PVSP_CONTEXT        context;
    PIRP                irp;
    PIO_STACK_LOCATION  nextSp;

    if (IsListEmpty(ExtentList)) {
        if (HiberfileIncluded) {
            InterlockedExchange(&Extension->Filter->HibernatePending, FALSE);
        }
        return STATUS_SUCCESS;
    }

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        if (HiberfileIncluded) {
            InterlockedExchange(&Extension->Filter->HibernatePending, FALSE);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp = IoAllocateIrp((CCHAR) Extension->Root->StackSize, FALSE);
    if (!irp) {
        if (HiberfileIncluded) {
            InterlockedExchange(&Extension->Filter->HibernatePending, FALSE);
        }
        VspFreeContext(Extension->Root, context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->MdlAddress = NULL;

    context->Type = VSP_CONTEXT_TYPE_COPY_EXTENTS;
    ExInitializeWorkItem(&context->WorkItem, VspCallDriver, context);
    context->CopyExtents.Extension = Extension;
    context->CopyExtents.Irp = irp;
    context->CopyExtents.ExtentList = *ExtentList;
    context->CopyExtents.ExtentList.Flink->Blink =
            &context->CopyExtents.ExtentList;
    context->CopyExtents.ExtentList.Blink->Flink =
            &context->CopyExtents.ExtentList;
    context->CopyExtents.HiberfileIncluded = HiberfileIncluded;
    context->CopyExtents.PagefileIncluded = PagefileIncluded;

    ObReferenceObject(Extension->DeviceObject);
    ObReferenceObject(Extension->Filter->DeviceObject);

    VspCopyExtentsCompletionRoutine(NULL, irp, context);

    return STATUS_SUCCESS;
}

VOID
VspSystemSid(
    IN OUT  SID*   Sid
    )

{
    Sid->Revision = SID_REVISION;
    Sid->SubAuthorityCount = 1;
    Sid->IdentifierAuthority = ntAuthority;
    Sid->SubAuthority[0] = SECURITY_LOCAL_SYSTEM_RID;
}

VOID
VspAdminSid(
    IN OUT  SID*   Sid
    )

{
    Sid->Revision = SID_REVISION;
    Sid->SubAuthorityCount = 2;
    Sid->IdentifierAuthority = ntAuthority;
    Sid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
    Sid->SubAuthority[1] = DOMAIN_ALIAS_RID_ADMINS;
}

BOOLEAN
VspHasStrongAcl(
    IN  HANDLE      Handle,
    OUT PNTSTATUS   Status
    )

{
    NTSTATUS                status;
    ULONG                   sdLength;
    PSECURITY_DESCRIPTOR    sd;
    PSID                    sid;
    BOOLEAN                 ownerDefaulted, daclPresent, daclDefaulted;
    PACL                    acl;
    ULONG                   i;
    PACCESS_ALLOWED_ACE     ace;
    PSID                    systemSid;
    UCHAR                   sidBuffer[2*sizeof(SID)];
    PSID                    adminSid;
    UCHAR                   sidBuffer2[2*sizeof(SID)];
    ULONG                   priviledgedBits;

    status = ZwQuerySecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION, NULL, 0,
                                   &sdLength);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        // The file system does not support security.
        return TRUE;
    }

    sd = ExAllocatePoolWithTag(PagedPool, sdLength, VOLSNAP_TAG_SHORT_TERM);
    if (!sd) {
        *Status = STATUS_INSUFFICIENT_RESOURCES;
        return FALSE;
    }

    status = ZwQuerySecurityObject(Handle, OWNER_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION, sd, sdLength,
                                   &sdLength);
    if (!NT_SUCCESS(status)) {
        ExFreePool(sd);
        *Status = status;
        return FALSE;
    }

    status = RtlGetDaclSecurityDescriptor(sd, &daclPresent, &acl,
                                          &daclDefaulted);
    if (!NT_SUCCESS(status)) {
        ExFreePool(sd);
        *Status = status;
        return FALSE;
    }

    status = RtlGetOwnerSecurityDescriptor(sd, &sid, &ownerDefaulted);
    if (!NT_SUCCESS(status)) {
        ExFreePool(sd);
        *Status = status;
        return FALSE;
    }

    systemSid = (PSID) sidBuffer;
    adminSid = (PSID) sidBuffer2;

    VspSystemSid((SID*) systemSid);
    VspAdminSid((SID*) adminSid);

    if (!sid) {
        ExFreePool(sd);
        *Status = STATUS_NO_SECURITY_ON_OBJECT;
        return FALSE;
    }

    if (!RtlEqualSid(sid, adminSid) && !RtlEqualSid(sid, systemSid)) {
        ExFreePool(sd);
        *Status = STATUS_NO_SECURITY_ON_OBJECT;
        return FALSE;
    }

    if (!daclPresent || (daclPresent && !acl)) {
        ExFreePool(sd);
        *Status = STATUS_NO_SECURITY_ON_OBJECT;
        return FALSE;
    }

    priviledgedBits = FILE_READ_DATA | WRITE_DAC | WRITE_OWNER |
                      ACCESS_SYSTEM_SECURITY | GENERIC_ALL | GENERIC_READ;

    for (i = 0; ; i++) {
        status = RtlGetAce(acl, i, (PVOID*) &ace);
        if (!NT_SUCCESS(status)) {
            ace = NULL;
        }
        if (!ace) {
            break;
        }

        if (ace->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) {
            continue;
        }

        sid = (PSID) &ace->SidStart;
        if (RtlEqualSid(sid, systemSid) || RtlEqualSid(sid, adminSid)) {
            continue;
        }

        if (ace->Mask&priviledgedBits) {
            ExFreePool(sd);
            *Status = STATUS_NO_SECURITY_ON_OBJECT;
            return FALSE;
        }
    }

    ExFreePool(sd);

    return TRUE;
}

VOID
VspAdjustBitmap(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION           extension = context->Extension.Extension;
    NTSTATUS                    status;
    LIST_ENTRY                  extentList;
    WCHAR                       nameBuffer[100];
    UNICODE_STRING              name;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      h;
    IO_STATUS_BLOCK             ioStatus;
    KIRQL                       irql;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    BOOLEAN                     isNtfs;
    PWORK_QUEUE_ITEM            workItem;
    PWORKER_THREAD_ROUTINE      workerRoutine;
    PVOID                       parameter;
    PVSP_DIFF_AREA_FILE         diffAreaFile;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(extension->Root, context);

    KeWaitForSingleObject(&extension->Root->PastBootReinit, Executive,
                          KernelMode, FALSE, NULL);

    if (extension->IsDetected) {

        status = VspOpenFilesAndValidateSnapshots(extension->Filter);
        if (!NT_SUCCESS(status)) {
            if (!extension->Filter->ControlBlockFileHandle) {
                VspAcquireNonPagedResource(extension, NULL, FALSE);
                VspCreateStartBlock(extension->Filter, 0,
                                    extension->Filter->MaximumVolumeSpace);
                extension->Filter->FirstControlBlockVolumeOffset = 0;
                VspReleaseNonPagedResource(extension);
            }
            VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, TRUE);
            goto Finish;
        }

    } else {

        if (extension->IsPersistent) {
            VspComputeIgnorableBitmap(extension, NULL);
        }

        KeSetEvent(&extension->Filter->EndCommitProcessCompleted,
                   IO_NO_INCREMENT, FALSE);

        swprintf(nameBuffer,
                 L"\\Device\\HarddiskVolumeShadowCopy%d\\pagefile.sys",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, nameBuffer);
        InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                                   OBJ_KERNEL_HANDLE, NULL, NULL);

        status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                            FILE_SHARE_READ | FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT);
        if (NT_SUCCESS(status)) {
            if (!VspHasStrongAcl(h, &status)) {
                ZwClose(h);
            }
        }
        if (NT_SUCCESS(status)) {
            VspMarkFileAllocationInBitmap(extension, h, NULL, NULL);

            if (extension->ContainsCrashdumpFile) {
                ASSERT(extension->IsPersistent);
                status = VspQueryListOfExtents(h, 0, &extentList, NULL, TRUE);
                if (NT_SUCCESS(status)) {

                    status = VspCopyExtents(extension, &extentList, FALSE,
                                            TRUE);
                    if (!NT_SUCCESS(status)) {
                        while (!IsListEmpty(&extentList)) {
                            l = RemoveHeadList(&extentList);
                            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                                     DIFF_AREA_FILE_ALLOCATION,
                                                     ListEntry);
                            ExFreePool(diffAreaFileAllocation);
                        }

                        VspLogError(NULL, extension->Filter,
                                    VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES,
                                    status, 4, FALSE);
                        VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, FALSE);
                    }

                } else {
                    VspLogError(NULL, extension->Filter,
                                VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES, status,
                                1, FALSE);
                    VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, FALSE);
                }
            }

            ZwClose(h);
        } else if (extension->ContainsCrashdumpFile) {
            VspLogError(NULL, extension->Filter,
                        VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES, status, 2,
                        FALSE);
            VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, FALSE);
        }

        swprintf(nameBuffer,
                 L"\\Device\\HarddiskVolumeShadowCopy%d\\hiberfil.sys",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, nameBuffer);
        InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                                   OBJ_KERNEL_HANDLE, NULL, NULL);

        status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                             FILE_SHARE_READ | FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT);
        if (NT_SUCCESS(status)) {
            if (!VspHasStrongAcl(h, &status)) {
                ZwClose(h);
            }
        }
        if (NT_SUCCESS(status)) {
            VspMarkFileAllocationInBitmap(extension, h, NULL, NULL);

            if (extension->IsPersistent) {
                status = STATUS_SUCCESS;
                isNtfs = TRUE;
            } else {
                status = VspIsNtfs(h, &isNtfs);
            }

            if (NT_SUCCESS(status) && isNtfs) {
                status = VspQueryListOfExtents(h, 0, &extentList, NULL, TRUE);
                if (NT_SUCCESS(status)) {
                    status = VspCopyExtents(extension, &extentList, TRUE,
                                            FALSE);
                    if (!NT_SUCCESS(status)) {
                        while (!IsListEmpty(&extentList)) {
                            l = RemoveHeadList(&extentList);
                            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
                            ExFreePool(diffAreaFileAllocation);
                        }

                        VspLogError(NULL, extension->Filter,
                                    VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES,
                                    status, 14, FALSE);
                        VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, FALSE);
                    }
                } else {
                    VspLogError(NULL, extension->Filter,
                                VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES, status,
                                3, FALSE);
                    VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, FALSE);
                }
            }

            ZwClose(h);
        }
    }

    status = VspComputeIgnorableProduct(extension);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (extension->IgnorableProduct) {
        if (NT_SUCCESS(status) && extension->VolumeBlockBitmap) {
            VspOrBitmaps(extension->VolumeBlockBitmap,
                         extension->IgnorableProduct);

        } else if (extension->VolumeBlockBitmap && extension->IsDetected) {
            KeReleaseSpinLock(&extension->SpinLock, irql);

            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, NULL,
                            VS_ABORT_SNAPSHOTS_FAILED_FREE_SPACE_DETECTION,
                            status, 1, FALSE);
            }

            VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, TRUE);

            goto Finish;
        }

        ExFreePool(extension->IgnorableProduct->Buffer);
        ExFreePool(extension->IgnorableProduct);
        extension->IgnorableProduct = NULL;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    if (extension->IsDetected) {
        InterlockedExchange(&extension->OkToGrowDiffArea, TRUE);

        if (extension->DetectedNeedForGrow) {
            context = VspAllocateContext(extension->Root);
            if (context) {
                KeAcquireSpinLock(&extension->SpinLock, &irql);
                ASSERT(!extension->GrowDiffAreaFilePending);
                ASSERT(IsListEmpty(&extension->WaitingForDiffAreaSpace));
                extension->PastFileSystemOperations = FALSE;
                extension->GrowDiffAreaFilePending = TRUE;
                KeReleaseSpinLock(&extension->SpinLock, irql);

                context->Type = VSP_CONTEXT_TYPE_GROW_DIFF_AREA;
                ExInitializeWorkItem(&context->WorkItem, VspGrowDiffArea,
                                     context);
                context->GrowDiffArea.Extension = extension;
                ObReferenceObject(extension->DeviceObject);

                VspQueueWorkItem(extension->Root, &context->WorkItem, 0);
            }
        }
    }

Finish:

    if (extension->IsDetected) {
        KeSetEvent(&extension->Filter->EndCommitProcessCompleted,
                   IO_NO_INCREMENT, FALSE);
    }

    VspAcquire(extension->Root);
    if (extension->IgnoreCopyDataReference) {
        extension->IgnoreCopyDataReference = FALSE;
        InterlockedDecrement(&extension->Filter->IgnoreCopyData);
    }
    VspRelease(extension->Root);

    KeAcquireSpinLock(&extension->Root->ESpinLock, &irql);
    ASSERT(extension->Root->AdjustBitmapInProgress);
    if (IsListEmpty(&extension->Root->AdjustBitmapQueue)) {
        extension->Root->AdjustBitmapInProgress = FALSE;
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);
    } else {
        l = RemoveHeadList(&extension->Root->AdjustBitmapQueue);
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);

        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);

        workerRoutine = workItem->WorkerRoutine;
        parameter = workItem->Parameter;
        ExInitializeWorkItem(workItem, workerRoutine, parameter);

        ExQueueWorkItem(workItem, DelayedWorkQueue);
    }

    ObDereferenceObject(extension->Filter->TargetObject);
    ObDereferenceObject(extension->Filter->DeviceObject);
    ObDereferenceObject(extension->DeviceObject);
}

VOID
VspSetIgnorableBlocksInBitmapWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    NTSTATUS            status;
    KIRQL               irql;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    if (!extension->IsDetected) {
        status = VspMarkFreeSpaceInBitmap(extension, NULL, NULL);
        if (NT_SUCCESS(status)) {
            InterlockedExchange(&extension->OkToGrowDiffArea, TRUE);
        } else {
            if (!extension->Filter->DestroyAllSnapshotsPending) {
                VspLogError(extension, NULL,
                            VS_ABORT_SNAPSHOTS_FAILED_FREE_SPACE_DETECTION,
                            status, 2, FALSE);
            }
            VspDestroyAllSnapshots(extension->Filter, NULL, FALSE, FALSE);
        }
    }

    ExInitializeWorkItem(&context->WorkItem, VspAdjustBitmap, context);

    KeAcquireSpinLock(&extension->Root->ESpinLock, &irql);
    if (extension->Root->AdjustBitmapInProgress) {
        InsertTailList(&extension->Root->AdjustBitmapQueue,
                       &context->WorkItem.List);
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);
    } else {
        extension->Root->AdjustBitmapInProgress = TRUE;
        KeReleaseSpinLock(&extension->Root->ESpinLock, irql);
        ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
    }
}

VOID
VspFreeCopyIrp(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                CopyIrp
    )

{
    KIRQL                           irql;
    PLIST_ENTRY                     l;
    PWORK_QUEUE_ITEM                workItem;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry;

    if (Extension->EmergencyCopyIrp == CopyIrp) {
        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (IsListEmpty(&Extension->EmergencyCopyIrpQueue)) {
            Extension->EmergencyCopyIrpInUse = FALSE;
            KeReleaseSpinLock(&Extension->SpinLock, irql);
            return;
        }
        l = RemoveHeadList(&Extension->EmergencyCopyIrpQueue);
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) workItem->Parameter;
        tableEntry->CopyIrp = CopyIrp;

        workItem->WorkerRoutine(workItem->Parameter);
        return;
    }

    if (!Extension->EmergencyCopyIrpInUse) {
        ExFreePool(MmGetMdlVirtualAddress(CopyIrp->MdlAddress));
        IoFreeMdl(CopyIrp->MdlAddress);
        IoFreeIrp(CopyIrp);
        return;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (IsListEmpty(&Extension->EmergencyCopyIrpQueue)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        ExFreePool(MmGetMdlVirtualAddress(CopyIrp->MdlAddress));
        IoFreeMdl(CopyIrp->MdlAddress);
        IoFreeIrp(CopyIrp);
        return;
    }
    l = RemoveHeadList(&Extension->EmergencyCopyIrpQueue);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY) workItem->Parameter;
    tableEntry->CopyIrp = CopyIrp;

    workItem->WorkerRoutine(workItem->Parameter);
}

VOID
VspApplyThresholdDelta(
    IN  PVOLUME_EXTENSION   Extension,
    IN  ULONG               IncreaseDelta
    )

{
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PVSP_CONTEXT        context;
    KIRQL               irql;

    ASSERT(Extension->DiffAreaFile);
    diffAreaFile = Extension->DiffAreaFile;

    if (diffAreaFile->NextAvailable + Extension->DiffAreaFileIncrease <=
        diffAreaFile->AllocatedFileSize) {

        return;
    }

    if (diffAreaFile->NextAvailable + Extension->DiffAreaFileIncrease -
        IncreaseDelta > diffAreaFile->AllocatedFileSize) {

        return;
    }

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        if (!Extension->OkToGrowDiffArea) {
            VspLogError(Extension, diffAreaFile->Filter,
                        VS_GROW_BEFORE_FREE_SPACE, STATUS_SUCCESS, 3, FALSE);
        }
        return;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ASSERT(!Extension->GrowDiffAreaFilePending);
    ASSERT(IsListEmpty(&Extension->WaitingForDiffAreaSpace));
    Extension->PastFileSystemOperations = FALSE;
    Extension->GrowDiffAreaFilePending = TRUE;
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    context->Type = VSP_CONTEXT_TYPE_GROW_DIFF_AREA;
    ExInitializeWorkItem(&context->WorkItem, VspGrowDiffArea, context);
    context->GrowDiffArea.Extension = Extension;
    ObReferenceObject(Extension->DeviceObject);

    if (!Extension->OkToGrowDiffArea) {
        ObReferenceObject(Extension->Filter->DeviceObject);
        ExInitializeWorkItem(&context->WorkItem, VspWaitForInstall, context);
        ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
        return;
    }

    VspQueueWorkItem(Extension->Root, &context->WorkItem, 0);
}

NTSTATUS
VspCheckOnDiskNotCommitted(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    NTSTATUS                    status;
    UCHAR                       controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT  snapshotControlItem;

    if (!Extension->OnDiskNotCommitted) {
        return STATUS_SUCCESS;
    }

    Extension->OnDiskNotCommitted = FALSE;

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, FALSE,
                              controlItemBuffer, FALSE);
    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(Extension, filter, VS_ABORT_SNAPSHOTS_IO_FAILURE,
                        status, 16, FALSE);
        }
        VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
        return status;
    }

    snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;
    snapshotControlItem->SnapshotOrderNumber =
            Extension->SnapshotOrderNumber;
    snapshotControlItem->SnapshotTime = Extension->CommitTimeStamp;

    if (Extension->ContainsCrashdumpFile) {
        snapshotControlItem->SnapshotControlItemFlags =
                VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_CRASHDUMP;
    }

    if (Extension->NoDiffAreaFill) {
        snapshotControlItem->SnapshotControlItemFlags |=
                VSP_SNAPSHOT_CONTROL_ITEM_FLAG_NO_DIFF_AREA_FILL;
    }

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, TRUE,
                              controlItemBuffer, FALSE);
    if (!NT_SUCCESS(status)) {
        if (!filter->DestroyAllSnapshotsPending) {
            VspLogError(Extension, filter, VS_ABORT_SNAPSHOTS_IO_FAILURE,
                        status, 17, FALSE);
        }
        VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
        return status;
    }

    return STATUS_SUCCESS;
}

VOID
VspWriteVolume(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine performs a volume write, making sure that all of the
    parts of the volume write have an old version of the data placed
    in the diff area for the snapshot.

Arguments:

    Irp - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION               extension = context->WriteVolume.Extension;
    PIRP                            irp = (PIRP) context->WriteVolume.Irp;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(irp);
    PIO_STACK_LOCATION              nextSp = IoGetNextIrpStackLocation(irp);
    PFILTER_EXTENSION               filter = extension->Filter;
    NTSTATUS                        status;
    PLIST_ENTRY                     l;
    LONGLONG                        start, end, roundedStart, roundedEnd;
    ULONG                           irpLength, increase, increaseDelta;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry;
    PVOID                           nodeOrParent;
    TABLE_SEARCH_RESULT             searchResult;
    KIRQL                           irql;
    CCHAR                           stackSize;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    PDO_EXTENSION                   rootExtension;
    PVOID                           buffer;
    PMDL                            mdl;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME);

    if (extension->OnDiskNotCommitted) {
        status = VspCheckOnDiskNotCommitted(extension);
        if (!NT_SUCCESS(status)) {
            VspFreeContext(filter->Root, context);
            VspReleaseNonPagedResource(extension);
            VspDecrementIrpRefCount(irp);
            return;
        }
    }

    start = irpSp->Parameters.Read.ByteOffset.QuadPart;
    irpLength = irpSp->Parameters.Read.Length;
    end = start + irpLength;
    if (context->WriteVolume.RoundedStart) {
        roundedStart = context->WriteVolume.RoundedStart;
    } else {
        roundedStart = start&(~(BLOCK_SIZE - 1));
    }
    roundedEnd = end&(~(BLOCK_SIZE - 1));
    if (roundedEnd != end) {
        roundedEnd += BLOCK_SIZE;
    }

    ASSERT(extension->VolumeBlockBitmap);

    for (; roundedStart < roundedEnd; roundedStart += BLOCK_SIZE) {

        if (roundedStart < 0 ||
            roundedStart >= extension->VolumeSize) {

            continue;
        }

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        if (RtlCheckBit(extension->VolumeBlockBitmap,
                        (ULONG) (roundedStart>>BLOCK_SHIFT))) {

            KeReleaseSpinLock(&extension->SpinLock, irql);
            continue;
        }
        KeReleaseSpinLock(&extension->SpinLock, irql);

        keyTableEntry.VolumeOffset = roundedStart;

        tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                     RtlLookupElementGenericTableFull(
                     &extension->TempVolumeBlockTable, &keyTableEntry,
                     &nodeOrParent, &searchResult);

        if (tableEntry) {

            context = VspAllocateContext(extension->Root);
            if (context) {
                context->Type = VSP_CONTEXT_TYPE_EXTENSION;
                context->Extension.Extension = extension;
                context->Extension.Irp = irp;
            } else {
                context = (PVSP_CONTEXT) Context;
                ASSERT(context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME);
                context->WriteVolume.RoundedStart = roundedStart;
            }
            ExInitializeWorkItem(&context->WorkItem,
                                 VspDecrementIrpRefCountWorker, context);

            KeAcquireSpinLock(&extension->SpinLock, &irql);
            if (tableEntry->IsComplete) {
                KeReleaseSpinLock(&extension->SpinLock, irql);
                if (context->Type == VSP_CONTEXT_TYPE_EXTENSION) {
                    VspFreeContext(extension->Root, context);
                }
                continue;
            }
            InterlockedIncrement((PLONG) &nextSp->Parameters.Write.Length);
            InsertTailList(&tableEntry->WaitingQueueDpc,
                           &context->WorkItem.List);
            KeReleaseSpinLock(&extension->SpinLock, irql);

            if (context == Context) {
                VspReleaseNonPagedResource(extension);
                return;
            }

            continue;
        }

        RtlZeroMemory(&keyTableEntry, sizeof(TEMP_TRANSLATION_TABLE_ENTRY));
        keyTableEntry.VolumeOffset = roundedStart;

        ASSERT(!extension->TempTableEntry);
        extension->TempTableEntry =
                VspAllocateTempTableEntry(extension->Root);
        if (!extension->TempTableEntry) {
            rootExtension = extension->Root;
            KeAcquireSpinLock(&rootExtension->ESpinLock, &irql);
            if (rootExtension->EmergencyTableEntryInUse) {
                context = (PVSP_CONTEXT) Context;
                ASSERT(context->Type == VSP_CONTEXT_TYPE_WRITE_VOLUME);
                context->WriteVolume.RoundedStart = roundedStart;
                InsertTailList(&rootExtension->WorkItemWaitingList,
                               &context->WorkItem.List);
                if (!rootExtension->WorkItemWaitingListNeedsChecking) {
                    InterlockedExchange(
                            &rootExtension->WorkItemWaitingListNeedsChecking,
                            TRUE);
                }
                KeReleaseSpinLock(&rootExtension->ESpinLock, irql);
                VspReleaseNonPagedResource(extension);
                return;
            }
            rootExtension->EmergencyTableEntryInUse = TRUE;
            KeReleaseSpinLock(&rootExtension->ESpinLock, irql);

            extension->TempTableEntry = rootExtension->EmergencyTableEntry;
        }

        tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                     RtlInsertElementGenericTableFull(
                     &extension->TempVolumeBlockTable, &keyTableEntry,
                     sizeof(TEMP_TRANSLATION_TABLE_ENTRY), NULL,
                     nodeOrParent, searchResult);
        ASSERT(tableEntry);

        if (extension->TempVolumeBlockTable.NumberGenericTableElements >
            extension->MaximumNumberOfTempEntries) {

            extension->MaximumNumberOfTempEntries =
                    extension->TempVolumeBlockTable.NumberGenericTableElements;
            VspQueryDiffAreaFileIncrease(extension, &increase);
            ASSERT(increase >= extension->DiffAreaFileIncrease);
            increaseDelta = increase - extension->DiffAreaFileIncrease;
            if (increaseDelta) {
                InterlockedExchange((PLONG) &extension->DiffAreaFileIncrease,
                                    (LONG) increase);
                VspApplyThresholdDelta(extension, increaseDelta);
            }
        }

        tableEntry->Extension = extension;
        tableEntry->WriteIrp = irp;
        diffAreaFile = extension->DiffAreaFile;
        ASSERT(diffAreaFile);
        tableEntry->TargetObject = diffAreaFile->Filter->TargetObject;
        tableEntry->IsComplete = FALSE;
        InitializeListHead(&tableEntry->WaitingQueueDpc);

        tableEntry->CopyIrp = IoAllocateIrp(
                              (CCHAR) extension->Root->StackSize, FALSE);
        buffer = ExAllocatePoolWithTagPriority(NonPagedPool, BLOCK_SIZE,
                                               VOLSNAP_TAG_BUFFER,
                                               LowPoolPriority);
        mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);

        if (!tableEntry->CopyIrp || !buffer || !mdl) {
            if (tableEntry->CopyIrp) {
                IoFreeIrp(tableEntry->CopyIrp);
                tableEntry->CopyIrp = NULL;
            }
            if (buffer) {
                ExFreePool(buffer);
            }
            if (mdl) {
                IoFreeMdl(mdl);
            }
            KeAcquireSpinLock(&extension->SpinLock, &irql);
            if (extension->EmergencyCopyIrpInUse) {
                InterlockedIncrement((PLONG) &nextSp->Parameters.Write.Length);
                ExInitializeWorkItem(&tableEntry->WorkItem,
                                     VspWriteVolumePhase1, tableEntry);
                InsertTailList(&extension->EmergencyCopyIrpQueue,
                               &tableEntry->WorkItem.List);
                KeReleaseSpinLock(&extension->SpinLock, irql);
                continue;
            }
            extension->EmergencyCopyIrpInUse = TRUE;
            KeReleaseSpinLock(&extension->SpinLock, irql);

            tableEntry->CopyIrp = extension->EmergencyCopyIrp;

        } else {
            MmBuildMdlForNonPagedPool(mdl);
            tableEntry->CopyIrp->MdlAddress = mdl;
        }

        InterlockedIncrement((PLONG) &nextSp->Parameters.Write.Length);

        VspAllocateDiffAreaSpace(extension, &tableEntry->TargetOffset,
                                 &tableEntry->FileOffset, NULL, NULL);

        VspWriteVolumePhase1(tableEntry);
    }

    context = (PVSP_CONTEXT) Context;
    VspFreeContext(filter->Root, context);

    VspReleaseNonPagedResource(extension);
    VspDecrementIrpRefCount(irp);
}

VOID
VspIrpsTimerDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) Context;
    KIRQL               irql;
    LIST_ENTRY          q;
    PLIST_ENTRY         l;
    BOOLEAN             emptyQueue;

    if (TimerDpc) {
        VspLogError(NULL, filter, VS_FLUSH_AND_HOLD_IRP_TIMEOUT,
                    STATUS_SUCCESS, 0, FALSE);
    }

    IoStopTimer(filter->DeviceObject);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    ASSERT(filter->ExternalWaiter);
    filter->ExternalWaiter = FALSE;
    InterlockedIncrement(&filter->RefCount);
    InterlockedDecrement(&filter->HoldIncomingWrites);
    if (filter->HoldIncomingWrites) {
        KeReleaseSpinLock(&filter->SpinLock, irql);
        VspDecrementRefCount(filter);
        return;
    }
    KeResetEvent(&filter->ZeroRefEvent);
    if (IsListEmpty(&filter->HoldQueue)) {
        emptyQueue = FALSE;
    } else {
        emptyQueue = TRUE;
        q = filter->HoldQueue;
        InitializeListHead(&filter->HoldQueue);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (emptyQueue) {
        q.Blink->Flink = &q;
        q.Flink->Blink = &q;
        VspEmptyIrpQueue(filter->Root->DriverObject, &q);
    }
}

VOID
VspEndCommitDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) Context;

    VspLogError(NULL, filter, VS_END_COMMIT_TIMEOUT, STATUS_CANCELLED, 0,
                FALSE);
    InterlockedExchange(&filter->HibernatePending, FALSE);
    KeSetEvent(&filter->EndCommitProcessCompleted, IO_NO_INCREMENT, FALSE);
    ObDereferenceObject(filter->DeviceObject);
}

NTSTATUS
VspCheckForMemoryPressure(
    IN  PFILTER_EXTENSION   Filter
    )

/*++

Routine Description:

    This routine will allocate 256 K of paged and non paged pool.  If these
    allocs succeed, it indicates that the system is not under memory pressure
    and so it is ok to hold write irps for the next second.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    NTSTATUS

--*/

{
    PVOID   p, np;

    p = ExAllocatePoolWithTagPriority(PagedPool,
            MEMORY_PRESSURE_CHECK_ALLOC_SIZE, VOLSNAP_TAG_SHORT_TERM,
            LowPoolPriority);
    if (!p) {
        VspLogError(NULL, Filter, VS_MEMORY_PRESSURE_DURING_LOVELACE,
                    STATUS_INSUFFICIENT_RESOURCES, 1, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    np = ExAllocatePoolWithTagPriority(NonPagedPool,
            MEMORY_PRESSURE_CHECK_ALLOC_SIZE, VOLSNAP_TAG_SHORT_TERM,
            LowPoolPriority);
    if (!np) {
        ExFreePool(p);
        VspLogError(NULL, Filter, VS_MEMORY_PRESSURE_DURING_LOVELACE,
                    STATUS_INSUFFICIENT_RESOURCES, 2, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExFreePool(np);
    ExFreePool(p);

    return STATUS_SUCCESS;
}

VOID
VspOneSecondTimerWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           WorkItem
    )

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_WORKITEM        workItem = (PIO_WORKITEM) WorkItem;
    NTSTATUS            status;

    status = VspCheckForMemoryPressure(filter);
    if (!NT_SUCCESS(status)) {
        InterlockedExchange(&filter->LastReleaseDueToMemoryPressure, TRUE);
        VspReleaseWrites(filter);
    }

    IoFreeWorkItem(workItem);
}

VOID
VspOneSecondTimer(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Filter
    )

/*++

Routine Description:

    This routine will get called once every second after an IoStartTimer.
    This routine checks for memory pressure and aborts the lovelace operation
    if any memory pressure is detected.

Arguments:

    DeviceObject    - Supplies the device object.

    Filter          - Supplies the filter extension.

Return Value:

    None.

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) Filter;
    PIO_WORKITEM        workItem;

    workItem = IoAllocateWorkItem(filter->DeviceObject);
    if (!workItem) {
        VspLogError(NULL, filter, VS_MEMORY_PRESSURE_DURING_LOVELACE,
                    STATUS_INSUFFICIENT_RESOURCES, 3, FALSE);
        VspReleaseWrites(filter);
        return;
    }

    IoQueueWorkItem(workItem, VspOneSecondTimerWorker, CriticalWorkQueue,
                    workItem);
}

NTSTATUS
VolSnapAddDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FILTER for the corresponding
    volume PDO.

Arguments:

    DriverObject            - Supplies the VOLSNAP driver object.

    PhysicalDeviceObject    - Supplies the volume PDO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject;
    PDO_EXTENSION           rootExtension;
    PFILTER_EXTENSION       filter;

    status = IoCreateDevice(DriverObject, sizeof(FILTER_EXTENSION),
                            NULL, FILE_DEVICE_UNKNOWN, 0, FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    rootExtension = (PDO_EXTENSION)
                    IoGetDriverObjectExtension(DriverObject, VolSnapAddDevice);
    if (!rootExtension) {
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    filter = (PFILTER_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(filter, sizeof(FILTER_EXTENSION));
    filter->DeviceObject = deviceObject;
    filter->Root = rootExtension;
    filter->DeviceExtensionType = DEVICE_EXTENSION_FILTER;
    KeInitializeSpinLock(&filter->SpinLock);

    filter->TargetObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if (!filter->TargetObject) {
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    filter->Pdo = PhysicalDeviceObject;
    KeInitializeSemaphore(&filter->ControlBlockFileHandleSemaphore, 1, 1);
    InitializeListHead(&filter->SnapshotLookupTableEntries);
    InitializeListHead(&filter->DiffAreaLookupTableEntries);
    KeInitializeEvent(&filter->ControlBlockFileHandleReady, NotificationEvent,
                      TRUE);
    filter->RefCount = 1;
    InitializeListHead(&filter->HoldQueue);
    KeInitializeEvent(&filter->ZeroRefEvent, NotificationEvent, FALSE);
    KeInitializeSemaphore(&filter->ZeroRefSemaphore, 1, 1);
    KeInitializeTimer(&filter->HoldWritesTimer);
    KeInitializeDpc(&filter->HoldWritesTimerDpc, VspIrpsTimerDpc, filter);
    KeInitializeEvent(&filter->EndCommitProcessCompleted, NotificationEvent,
                      TRUE);
    InitializeListHead(&filter->VolumeList);
    KeInitializeSemaphore(&filter->CriticalOperationSemaphore, 1, 1);
    InitializeListHead(&filter->DeadVolumeList);
    InitializeListHead(&filter->DiffAreaFilesOnThisFilter);
    InitializeListHead(&filter->CopyOnWriteList);

    filter->DiffAreaVolume = filter;

    KeInitializeTimer(&filter->EndCommitTimer);
    KeInitializeDpc(&filter->EndCommitTimerDpc, VspEndCommitDpc, filter);

    InitializeListHead(&filter->NonPagedResourceList);
    InitializeListHead(&filter->PagedResourceList);

    filter->EpicNumber = 1;

    status = IoInitializeTimer(deviceObject, VspOneSecondTimer, filter);
    if (!NT_SUCCESS(status)) {
        IoDetachDevice(filter->TargetObject);
        IoDeleteDevice(deviceObject);
        return status;
    }

    deviceObject->DeviceType = filter->TargetObject->DeviceType;

    deviceObject->Flags |= DO_DIRECT_IO;
    if (filter->TargetObject->Flags & DO_POWER_PAGABLE) {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }
    if (filter->TargetObject->Flags & DO_POWER_INRUSH) {
        deviceObject->Flags |= DO_POWER_INRUSH;
    }

    deviceObject->Characteristics |=
        (filter->Pdo->Characteristics&FILE_CHARACTERISTICS_PROPAGATED);

    VspAcquire(filter->Root);
    if (filter->TargetObject->StackSize > filter->Root->StackSize) {
        InterlockedExchange(&filter->Root->StackSize,
                            (LONG) filter->TargetObject->StackSize);
    }
    InsertTailList(&filter->Root->FilterList, &filter->ListEntry);
    VspRelease(filter->Root);

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapCreate(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CREATE.

Arguments:

    DeviceObject - Supplies the device object.

    Irp          - Supplies the IO request block.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

VOID
VspReadSnapshotPhase3(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION               extension = context->ReadSnapshot.Extension;
    PIRP                            irp = context->ReadSnapshot.OriginalReadIrp;
    PFILTER_EXTENSION               filter = extension->Filter;
    KIRQL                           irql;
    PVOLUME_EXTENSION               e;
    TRANSLATION_TABLE_ENTRY         keyTableEntry;
    NTSTATUS                        status;
    PTRANSLATION_TABLE_ENTRY        tableEntry;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTempTableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tempTableEntry;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    e = CONTAINING_RECORD(filter->VolumeList.Blink, VOLUME_EXTENSION,
                          ListEntry);
    KeReleaseSpinLock(&filter->SpinLock, irql);

    keyTableEntry.VolumeOffset = context->ReadSnapshot.OriginalVolumeOffset;
    status = STATUS_SUCCESS;

    _try {
        tableEntry = (PTRANSLATION_TABLE_ENTRY)
                RtlLookupElementGenericTable(&e->VolumeBlockTable,
                                             &keyTableEntry);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        tableEntry = NULL;
    }

    if (!NT_SUCCESS(status)) {
        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;
        VspReleasePagedResource(extension);
        VspFreeContext(extension->Root, context);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    if (tableEntry &&
        tableEntry->TargetObject != context->ReadSnapshot.TargetObject) {

        context->ReadSnapshot.TargetObject = tableEntry->TargetObject;
        if (tableEntry->Flags&VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY) {
            context->ReadSnapshot.IsCopyTarget = TRUE;
        } else {
            context->ReadSnapshot.IsCopyTarget = FALSE;
        }
        context->ReadSnapshot.TargetOffset = tableEntry->TargetOffset;
        VspReleasePagedResource(extension);
        VspReadSnapshotPhase1(context);
        return;
    }

    VspAcquireNonPagedResource(e, NULL, FALSE);
    keyTempTableEntry.VolumeOffset = context->ReadSnapshot.TargetOffset;
    tempTableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                     RtlLookupElementGenericTable(
                     &e->TempVolumeBlockTable, &keyTempTableEntry);
    if (tempTableEntry) {
        KeAcquireSpinLock(&e->SpinLock, &irql);
        if (!tempTableEntry->IsComplete) {
            ExInitializeWorkItem(&context->WorkItem, VspReadSnapshotPhase1,
                                 context);
            InsertTailList(&tempTableEntry->WaitingQueueDpc,
                           &context->WorkItem.List);
            KeReleaseSpinLock(&e->SpinLock, irql);

            VspReleaseNonPagedResource(e);
            VspReleasePagedResource(extension);
            return;
        }
        KeReleaseSpinLock(&e->SpinLock, irql);

        context->ReadSnapshot.TargetObject = tempTableEntry->TargetObject;
        context->ReadSnapshot.IsCopyTarget = FALSE;
        context->ReadSnapshot.TargetOffset = tempTableEntry->TargetOffset;
        VspReleaseNonPagedResource(e);
        VspReleasePagedResource(e);
        VspReadSnapshotPhase1(context);
        return;
    }
    VspReleaseNonPagedResource(e);

    VspReleasePagedResource(extension);

    VspFreeContext(extension->Root, context);
    VspDecrementVolumeIrpRefCount(irp);
}

NTSTATUS
VspReadSnapshotPhase2(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->ReadSnapshot.Extension;
    PIRP                irp = context->ReadSnapshot.OriginalReadIrp;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        irp->IoStatus = Irp->IoStatus;
    }

    IoFreeMdl(Irp->MdlAddress);
    IoFreeIrp(Irp);

    if (context->ReadSnapshot.IsCopyTarget) {
        ExInitializeWorkItem(&context->WorkItem, VspReadSnapshotPhase3,
                             context);
        VspAcquirePagedResource(extension, &context->WorkItem);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    VspFreeContext(extension->Root, context);

    VspDecrementVolumeIrpRefCount(irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspReadSnapshotPhase1(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine is called when a read snapshot routine is waiting for
    somebody else to finish updating the public area of a table entry.
    When this routine is called, the public area of the table entry is
    valid.

Arguments:

    Context - Supplies the context.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION               extension = context->ReadSnapshot.Extension;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTempTableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tempTableEntry;
    TRANSLATION_TABLE_ENTRY         keyTableEntry;
    PTRANSLATION_TABLE_ENTRY        tableEntry;
    NTSTATUS                        status;
    PIRP                            irp;
    PIO_STACK_LOCATION              nextSp;
    PCHAR                           vp;
    PMDL                            mdl;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT);

    if (!context->ReadSnapshot.TargetObject || !extension->IsStarted) {
        irp = context->ReadSnapshot.OriginalReadIrp;
        irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        irp->IoStatus.Information = 0;
        VspFreeContext(extension->Root, context);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    irp = IoAllocateIrp(context->ReadSnapshot.TargetObject->StackSize, FALSE);
    if (!irp) {
        irp = context->ReadSnapshot.OriginalReadIrp;
        irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        irp->IoStatus.Information = 0;
        VspFreeContext(extension->Root, context);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    vp = (PCHAR) MmGetMdlVirtualAddress(
                 context->ReadSnapshot.OriginalReadIrp->MdlAddress) +
         context->ReadSnapshot.OriginalReadIrpOffset;
    mdl = IoAllocateMdl(vp, context->ReadSnapshot.Length, FALSE, FALSE, NULL);
    if (!mdl) {
        IoFreeIrp(irp);
        irp = context->ReadSnapshot.OriginalReadIrp;
        irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        irp->IoStatus.Information = 0;
        VspFreeContext(extension->Root, context);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    IoBuildPartialMdl(context->ReadSnapshot.OriginalReadIrp->MdlAddress, mdl,
                      vp, context->ReadSnapshot.Length);

    irp->MdlAddress = mdl;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    nextSp = IoGetNextIrpStackLocation(irp);
    nextSp->Parameters.Read.ByteOffset.QuadPart =
            context->ReadSnapshot.TargetOffset +
            context->ReadSnapshot.BlockOffset;
    nextSp->Parameters.Read.Length = context->ReadSnapshot.Length;
    nextSp->MajorFunction = IRP_MJ_READ;
    nextSp->DeviceObject = context->ReadSnapshot.TargetObject;
    nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    IoSetCompletionRoutine(irp, VspReadSnapshotPhase2, context, TRUE, TRUE,
                           TRUE);

    IoCallDriver(nextSp->DeviceObject, irp);
}

VOID
VspReadSnapshot(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine kicks off a read snapshot.  First the table is searched
    to see if any of the data for this IRP resides in the diff area.  If not,
    then the Irp is sent directly to the original volume and then the diff
    area is checked again when it returns to fill in any gaps that may
    have been written while the IRP was in transit.

Arguments:

    Irp     - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION               extension = context->Extension.Extension;
    PIRP                            irp = context->Extension.Irp;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(irp);
    PIO_STACK_LOCATION              nextSp = IoGetNextIrpStackLocation(irp);
    PFILTER_EXTENSION               filter = extension->Filter;
    LONGLONG                        start, end, roundedStart, roundedEnd;
    ULONG                           irpOffset, irpLength, length, blockOffset;
    TRANSLATION_TABLE_ENTRY         keyTableEntry;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTempTableEntry;
    PVOLUME_EXTENSION               e;
    PTRANSLATION_TABLE_ENTRY        tableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tempTableEntry;
    KIRQL                           irql;
    NTSTATUS                        status;
    LONGLONG                        copyTarget;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(extension->Root, context);

    if (!extension->IsStarted) {
        irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        irp->IoStatus.Information = 0;
        VspReleasePagedResource(extension);
        VspDecrementVolumeIrpRefCount(irp);
        return;
    }

    start = irpSp->Parameters.Read.ByteOffset.QuadPart;
    irpLength = irpSp->Parameters.Read.Length;
    end = start + irpLength;
    roundedStart = start&(~(BLOCK_SIZE - 1));
    roundedEnd = end&(~(BLOCK_SIZE - 1));
    if (roundedEnd != end) {
        roundedEnd += BLOCK_SIZE;
    }
    irpOffset = 0;

    RtlZeroMemory(&keyTableEntry, sizeof(keyTableEntry));

    for (; roundedStart < roundedEnd; roundedStart += BLOCK_SIZE) {

        if (roundedStart < start) {
            blockOffset = (ULONG) (start - roundedStart);
        } else {
            blockOffset = 0;
        }
        copyTarget = 0;

        length = BLOCK_SIZE - blockOffset;
        if (irpLength < length) {
            length = irpLength;
        }

        keyTableEntry.VolumeOffset = roundedStart;
        e = extension;
        status = STATUS_SUCCESS;
        for (;;) {

            _try {
                tableEntry = (PTRANSLATION_TABLE_ENTRY)
                        RtlLookupElementGenericTable(&e->VolumeBlockTable,
                                                     &keyTableEntry);
            } _except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                tableEntry = NULL;
            }

            if (tableEntry) {
                if (!(tableEntry->Flags&
                      VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY)) {
                    break;
                }
                copyTarget = tableEntry->TargetOffset;
                keyTableEntry.VolumeOffset = copyTarget;
                tableEntry = NULL;
            }

            if (!NT_SUCCESS(status)) {
                irp->IoStatus.Status = status;
                irp->IoStatus.Information = 0;
                break;
            }

            KeAcquireSpinLock(&filter->SpinLock, &irql);
            if (e->ListEntry.Flink == &filter->VolumeList) {
                KeReleaseSpinLock(&filter->SpinLock, irql);
                break;
            }
            e = CONTAINING_RECORD(e->ListEntry.Flink,
                                  VOLUME_EXTENSION, ListEntry);
            KeReleaseSpinLock(&filter->SpinLock, irql);
        }

        if (!tableEntry) {
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (copyTarget) {
                keyTempTableEntry.VolumeOffset = copyTarget;
            } else {
                keyTempTableEntry.VolumeOffset = roundedStart;
            }

            VspAcquireNonPagedResource(e, NULL, FALSE);

            tempTableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                             RtlLookupElementGenericTable(
                             &e->TempVolumeBlockTable, &keyTempTableEntry);

            if (!tempTableEntry && !copyTarget) {
                VspReleaseNonPagedResource(e);
                irpOffset += length;
                irpLength -= length;
                continue;
            }
        }

        context = VspAllocateContext(extension->Root);
        if (!context) {
            if (!tableEntry) {
                VspReleaseNonPagedResource(e);
            }

            irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            irp->IoStatus.Information = 0;
            break;
        }

        context->Type = VSP_CONTEXT_TYPE_READ_SNAPSHOT;
        context->ReadSnapshot.Extension = extension;
        context->ReadSnapshot.OriginalReadIrp = irp;
        context->ReadSnapshot.OriginalReadIrpOffset = irpOffset;
        context->ReadSnapshot.OriginalVolumeOffset = roundedStart;
        context->ReadSnapshot.BlockOffset = blockOffset;
        context->ReadSnapshot.Length = length;
        context->ReadSnapshot.TargetObject = NULL;
        context->ReadSnapshot.IsCopyTarget = FALSE;
        context->ReadSnapshot.TargetOffset = 0;

        if (!tableEntry) {

            if (copyTarget) {
                VspReleaseNonPagedResource(e);
                context->ReadSnapshot.TargetObject = filter->TargetObject;
                context->ReadSnapshot.IsCopyTarget = TRUE;
                context->ReadSnapshot.TargetOffset = copyTarget;
                InterlockedIncrement((PLONG) &nextSp->Parameters.Read.Length);
                VspReadSnapshotPhase1(context);
                irpOffset += length;
                irpLength -= length;
                continue;
            }

            KeAcquireSpinLock(&e->SpinLock, &irql);
            if (!tempTableEntry->IsComplete) {
                InterlockedIncrement((PLONG) &nextSp->Parameters.Read.Length);
                ExInitializeWorkItem(&context->WorkItem, VspReadSnapshotPhase1,
                                     context);
                InsertTailList(&tempTableEntry->WaitingQueueDpc,
                               &context->WorkItem.List);
                KeReleaseSpinLock(&e->SpinLock, irql);

                VspReleaseNonPagedResource(e);

                irpOffset += length;
                irpLength -= length;
                continue;
            }
            KeReleaseSpinLock(&e->SpinLock, irql);

            context->ReadSnapshot.TargetObject = tempTableEntry->TargetObject;
            context->ReadSnapshot.IsCopyTarget = FALSE;
            context->ReadSnapshot.TargetOffset = tempTableEntry->TargetOffset;

            VspReleaseNonPagedResource(e);

            InterlockedIncrement((PLONG) &nextSp->Parameters.Read.Length);
            VspReadSnapshotPhase1(context);

            irpOffset += length;
            irpLength -= length;
            continue;
        }

        context->ReadSnapshot.TargetObject = tableEntry->TargetObject;
        context->ReadSnapshot.IsCopyTarget = FALSE;
        context->ReadSnapshot.TargetOffset = tableEntry->TargetOffset;

        InterlockedIncrement((PLONG) &nextSp->Parameters.Read.Length);
        VspReadSnapshotPhase1(context);

        irpOffset += length;
        irpLength -= length;
    }

    VspReleasePagedResource(extension);
    VspDecrementVolumeIrpRefCount(irp);
}

NTSTATUS
VspReadCompletionForReadSnapshot(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

/*++

Routine Description:

    This routine is the completion to a read of the filter in
    response to a snapshot read.  This completion routine queues
    a worker routine to look at the diff area table and fill in
    any parts of the original that have been invalidated.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

    Extension       - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;
    PIO_STACK_LOCATION  nextSp = IoGetNextIrpStackLocation(Irp);
    PVSP_CONTEXT        context;

    nextSp->Parameters.Read.Length = 1; // Use this for a ref count.

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        VspDecrementVolumeIrpRefCount(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    context = VspAllocateContext(extension->Root);
    if (!context) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;
        VspDecrementVolumeIrpRefCount(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = extension;
    context->Extension.Irp = Irp;
    ExInitializeWorkItem(&context->WorkItem, VspReadSnapshot, context);
    VspAcquirePagedResource(extension, &context->WorkItem);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

RTL_GENERIC_COMPARE_RESULTS
VspTableCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    PTRANSLATION_TABLE_ENTRY    first = (PTRANSLATION_TABLE_ENTRY) First;
    PTRANSLATION_TABLE_ENTRY    second = (PTRANSLATION_TABLE_ENTRY) Second;

    if (first->VolumeOffset < second->VolumeOffset) {
        return GenericLessThan;
    } else if (first->VolumeOffset > second->VolumeOffset) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}

VOID
VspCreateHeap(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    PIRP                irp = context->Extension.Irp;
    ULONG               increase;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    SIZE_T              size;
    LARGE_INTEGER       sectionSize, sectionOffset;
    HANDLE              h;
    PVOID               mapPointer;
    KIRQL               irql;
    BOOLEAN             emptyQueue;
    LIST_ENTRY          q;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);
    VspFreeContext(extension->Root, context);

    // First check that there is 5 MB of space available.  This driver
    // should not consume all available page file space.

    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    size = 5*1024*1024;
    sectionSize.QuadPart = size;
    status = ZwCreateSection(&h, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY |
                             SECTION_MAP_READ | SECTION_MAP_WRITE, &oa,
                             &sectionSize, PAGE_READWRITE, SEC_COMMIT,
                             NULL);
    if (!NT_SUCCESS(status)) {
        VspLogError(extension, NULL, VS_CANT_CREATE_HEAP, status, 1, FALSE);
        goto Finish;
    }

    sectionOffset.QuadPart = 0;
    mapPointer = NULL;
    status = ZwMapViewOfSection(h, NtCurrentProcess(), &mapPointer, 0, 0,
                                &sectionOffset, &size, ViewShare, 0,
                                PAGE_READWRITE);
    ZwClose(h);
    if (!NT_SUCCESS(status)) {
        VspLogError(extension, NULL, VS_CANT_CREATE_HEAP, status, 2, FALSE);
        goto Finish;
    }
    status = ZwUnmapViewOfSection(NtCurrentProcess(), mapPointer);
    ASSERT(NT_SUCCESS(status));

    // Now we have 5 MB, so go ahead and make the alloc.

    increase = extension->DiffAreaFileIncrease;
    increase >>= BLOCK_SHIFT;

    size = increase*(sizeof(TRANSLATION_TABLE_ENTRY) +
                     sizeof(RTL_BALANCED_LINKS));
    size = (size + 0xFFFF)&(~0xFFFF);
    ASSERT(size >= MINIMUM_TABLE_HEAP_SIZE);

    if (extension->RootSemaphoreHeld) {
        irp = (PIRP) 1;
    }

DoOver:
    sectionSize.QuadPart = size;
    status = ZwCreateSection(&h, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY |
                             SECTION_MAP_READ | SECTION_MAP_WRITE, &oa,
                             &sectionSize, PAGE_READWRITE, SEC_COMMIT,
                             NULL);
    if (!NT_SUCCESS(status)) {
        if (size > MINIMUM_TABLE_HEAP_SIZE) {
            size = MINIMUM_TABLE_HEAP_SIZE;
            goto DoOver;
        }
        VspLogError(extension, NULL, VS_CANT_CREATE_HEAP, status, 3, FALSE);
        goto Finish;
    }

    sectionOffset.QuadPart = 0;
    mapPointer = NULL;
    status = ZwMapViewOfSection(h, NtCurrentProcess(), &mapPointer, 0, 0,
                                &sectionOffset, &size, ViewShare, 0,
                                PAGE_READWRITE);
    ZwClose(h);
    if (!NT_SUCCESS(status)) {
        if (size > MINIMUM_TABLE_HEAP_SIZE) {
            size = MINIMUM_TABLE_HEAP_SIZE;
            goto DoOver;
        }
        VspLogError(extension, NULL, VS_CANT_CREATE_HEAP, status, 4, FALSE);
        goto Finish;
    }

    status = VspIncrementVolumeRefCount(extension);
    if (!NT_SUCCESS(status)) {
        status = ZwUnmapViewOfSection(NtCurrentProcess(), mapPointer);
        ASSERT(NT_SUCCESS(status));
        goto Finish;
    }

    VspAcquirePagedResource(extension, NULL);
    extension->NextDiffAreaFileMap = mapPointer;
    extension->NextDiffAreaFileMapSize = (ULONG) size;
    extension->DiffAreaFileMapProcess = NtCurrentProcess();
    VspReleasePagedResource(extension);

    VspDecrementVolumeRefCount(extension);

Finish:
    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (extension->PageFileSpaceCreatePending) {
        extension->PageFileSpaceCreatePending = FALSE;
        if (IsListEmpty(&extension->WaitingForPageFileSpace)) {
            emptyQueue = FALSE;
        } else {
            emptyQueue = TRUE;
            q = extension->WaitingForPageFileSpace;
            InitializeListHead(&extension->WaitingForPageFileSpace);
        }
    } else {
        emptyQueue = FALSE;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    if (emptyQueue) {
        q.Flink->Blink = &q;
        q.Blink->Flink = &q;
        while (!IsListEmpty(&q)) {
            l = RemoveHeadList(&q);
            workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
            VspAcquirePagedResource(extension, workItem);
        }
    }

    ObDereferenceObject(extension->DeviceObject);
}

PVOID
VspTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Table->TableContext;
    PVOID               p;
    POLD_HEAP_ENTRY     oldHeap;
    PVSP_CONTEXT        context;
    KIRQL               irql;

    if (extension->NextAvailable + Size <= extension->DiffAreaFileMapSize) {
        p = (PCHAR) extension->DiffAreaFileMap + extension->NextAvailable;
        extension->NextAvailable += Size;
        return p;
    }

    if (!extension->NextDiffAreaFileMap) {
        return NULL;
    }

    oldHeap = (POLD_HEAP_ENTRY)
              ExAllocatePoolWithTag(PagedPool, sizeof(OLD_HEAP_ENTRY),
                                    VOLSNAP_TAG_OLD_HEAP);
    if (!oldHeap) {
        return NULL;
    }

    context = VspAllocateContext(extension->Root);
    if (!context) {
        ExFreePool(oldHeap);
        return NULL;
    }

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    ASSERT(!extension->PageFileSpaceCreatePending);
    ASSERT(IsListEmpty(&extension->WaitingForPageFileSpace));
    extension->PageFileSpaceCreatePending = TRUE;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    oldHeap->DiffAreaFileMap = extension->DiffAreaFileMap;
    InsertTailList(&extension->OldHeaps, &oldHeap->ListEntry);

    extension->DiffAreaFileMap = extension->NextDiffAreaFileMap;
    extension->DiffAreaFileMapSize = extension->NextDiffAreaFileMapSize;
    extension->NextAvailable = 0;
    extension->NextDiffAreaFileMap = NULL;

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = extension;
    context->Extension.Irp = NULL;

    ObReferenceObject(extension->DeviceObject);
    ExInitializeWorkItem(&context->WorkItem, VspCreateHeap, context);
    if (extension->RootSemaphoreHeld) {
        ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
    } else {
        VspQueueWorkItem(extension->Root, &context->WorkItem, 0);
    }

    p = extension->DiffAreaFileMap;
    extension->NextAvailable += Size;

    return p;
}

VOID
VspTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    )

{
}

PVOID
VspTempTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Table->TableContext;
    PVOID               r;

    ASSERT(Size <= sizeof(RTL_BALANCED_LINKS) +
           sizeof(TEMP_TRANSLATION_TABLE_ENTRY));

    r = extension->TempTableEntry;
    extension->TempTableEntry = NULL;

    return r;
}

VOID
VspTempTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Table->TableContext;

    VspFreeTempTableEntry(extension->Root, Buffer);
}

PFILTER_EXTENSION
VspFindFilter(
    IN  PDO_EXTENSION       RootExtension,
    IN  PFILTER_EXTENSION   Filter,
    IN  PUNICODE_STRING     VolumeName,
    IN  PFILE_OBJECT        FileObject
    )

{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject, d;
    PLIST_ENTRY         l;
    PFILTER_EXTENSION   filter;

    if (VolumeName) {
        status = IoGetDeviceObjectPointer(VolumeName, FILE_READ_ATTRIBUTES,
                                          &FileObject, &deviceObject);
        if (!NT_SUCCESS(status)) {
            if (Filter) {
                VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                            status, 1, FALSE);
            }
            return NULL;
        }
    }

    deviceObject = IoGetAttachedDeviceReference(FileObject->DeviceObject);

    for (l = RootExtension->FilterList.Flink;
         l != &RootExtension->FilterList; l = l->Flink) {

        filter = CONTAINING_RECORD(l, FILTER_EXTENSION, ListEntry);
        d = IoGetAttachedDeviceReference(filter->DeviceObject);
        ObDereferenceObject(d);

        if (d == deviceObject) {
            break;
        }
    }

    ObDereferenceObject(deviceObject);

    if (VolumeName) {
        ObDereferenceObject(FileObject);
    }

    if (l != &RootExtension->FilterList) {
        return filter;
    }

    if (Filter) {
        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_NOT_FOUND, 2, FALSE);
    }

    return NULL;
}

NTSTATUS
VspIsNtfs(
    IN  HANDLE      FileHandle,
    OUT PBOOLEAN    IsNtfs
    )

{
    ULONG                           size;
    PFILE_FS_ATTRIBUTE_INFORMATION  fsAttributeInfo;
    NTSTATUS                        status;
    IO_STATUS_BLOCK                 ioStatus;

    size = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
           4*sizeof(WCHAR);

    fsAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)
                      ExAllocatePoolWithTag(PagedPool, size,
                                            VOLSNAP_TAG_SHORT_TERM);
    if (!fsAttributeInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus,
                                          fsAttributeInfo, size,
                                          FileFsAttributeInformation);
    if (status == STATUS_BUFFER_OVERFLOW) {
        *IsNtfs = FALSE;
        ExFreePool(fsAttributeInfo);
        return STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(fsAttributeInfo);
        return status;
    }

    if (fsAttributeInfo->FileSystemNameLength == 8 &&
        fsAttributeInfo->FileSystemName[0] == 'N' &&
        fsAttributeInfo->FileSystemName[1] == 'T' &&
        fsAttributeInfo->FileSystemName[2] == 'F' &&
        fsAttributeInfo->FileSystemName[3] == 'S') {

        ExFreePool(fsAttributeInfo);
        *IsNtfs = TRUE;

        return STATUS_SUCCESS;
    }

    ExFreePool(fsAttributeInfo);
    *IsNtfs = FALSE;

    return STATUS_SUCCESS;
}

LONGLONG
VspQueryVolumeSize(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PDEVICE_OBJECT              targetObject;
    KEVENT                      event;
    PIRP                        irp;
    GET_LENGTH_INFORMATION      lengthInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    targetObject = Filter->TargetObject;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_LENGTH_INFO,
                                        targetObject, NULL, 0, &lengthInfo,
                                        sizeof(lengthInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return 0;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    return lengthInfo.Length.QuadPart;
}

VOID
VspCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++

Routine Description:

    This routine is called on when the given IRP is cancelled.  It
    will dequeue this IRP off the work queue and complete the
    request as CANCELLED.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IRP.

Return Value:

    None.

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;

    ASSERT(Irp == filter->FlushAndHoldIrp);

    filter->FlushAndHoldIrp = NULL;
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

VOID
VspFsTimerDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PDO_EXTENSION               rootExtension = (PDO_EXTENSION) Context;
    KIRQL                       irql;
    PIRP                        irp;
    PFILTER_EXTENSION           filter;

    IoAcquireCancelSpinLock(&irql);

    while (!IsListEmpty(&rootExtension->HoldIrps)) {
        irp = CONTAINING_RECORD(rootExtension->HoldIrps.Flink, IRP,
                                Tail.Overlay.ListEntry);
        irp->CancelIrql = irql;
        IoSetCancelRoutine(irp, NULL);
        filter = (PFILTER_EXTENSION) IoGetCurrentIrpStackLocation(irp)->
                                     DeviceObject->DeviceExtension;
        ObReferenceObject(filter->DeviceObject);
        VspCancelRoutine(filter->DeviceObject, irp);
        VspLogError(NULL, filter, VS_FLUSH_AND_HOLD_FS_TIMEOUT,
                    STATUS_CANCELLED, 0, FALSE);
        ObDereferenceObject(filter->DeviceObject);
        IoAcquireCancelSpinLock(&irql);
    }

    rootExtension->HoldRefCount = 0;

    IoReleaseCancelSpinLock(irql);
}

VOID
VspZeroRefCallback(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PIRP            irp = (PIRP) Filter->ZeroRefContext;
    LARGE_INTEGER   timeout;

    timeout.QuadPart = -10*1000*1000*((LONGLONG) Filter->HoldWritesTimeout);
    KeSetTimer(&Filter->HoldWritesTimer, timeout, &Filter->HoldWritesTimerDpc);

    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_SOUND_INCREMENT);
}

VOID
VspFlushAndHoldWriteIrps(
    IN  PIRP    Irp,
    IN  ULONG   HoldWritesTimeout
    )

/*++

Routine Description:

    This routine waits for outstanding write requests to complete while
    holding incoming write requests.  This IRP will complete when all
    outstanding IRPs have completed.  A timer will be set for the given
    timeout value and held writes irps will be released after that point or
    when IOCTL_VOLSNAP_RELEASE_WRITES comes in, whichever is sooner.

Arguments:

    Irp                 - Supplies the I/O request packet.

    HoldWritesTimeout   - Supplies the maximum length of time in seconds that a
                          write IRP will be held up.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) irpSp->DeviceObject->DeviceExtension;
    KIRQL               irql;
    NTSTATUS            status;

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (filter->ExternalWaiter) {
        KeReleaseSpinLock(&filter->SpinLock, irql);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }
    filter->ExternalWaiter = TRUE;
    filter->ZeroRefCallback = VspZeroRefCallback;
    filter->ZeroRefContext = Irp;
    filter->HoldWritesTimeout = HoldWritesTimeout;
    if (filter->HoldIncomingWrites) {
        InterlockedIncrement(&filter->HoldIncomingWrites);
        InterlockedIncrement(&filter->RefCount);
    } else {
        InterlockedIncrement(&filter->HoldIncomingWrites);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    VspDecrementRefCount(filter);

    IoStartTimer(filter->DeviceObject);

    status = VspCheckForMemoryPressure(filter);
    if (!NT_SUCCESS(status)) {
        InterlockedExchange(&filter->LastReleaseDueToMemoryPressure, TRUE);
        VspReleaseWrites(filter);
    }
}

NTSTATUS
VspFlushAndHoldWrites(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called for multiple volumes at once.  On the first
    call the GUID is checked and if it is different than the current one
    then the current set is aborted.  If the GUID is new then subsequent
    calls are compared to the GUID passed in here until the required
    number of calls is completed.  A timer is used to wait until all
    of the IRPs have reached this driver and then another time out is used
    after all of these calls complete to wait for IOCTL_VOLSNAP_RELEASE_WRITES
    to be sent to all of the volumes involved.

Arguments:

    Filter  - Supplies the filter device extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PDO_EXTENSION                   rootExtension = Filter->Root;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_FLUSH_AND_HOLD_INPUT   input;
    KIRQL                           irql;
    LARGE_INTEGER                   timeout;
    LIST_ENTRY                      q;
    PLIST_ENTRY                     l;
    PIRP                            irp;
    PFILTER_EXTENSION               filter;
    ULONG                           irpTimeout;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_FLUSH_AND_HOLD_INPUT)) {

        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLSNAP_FLUSH_AND_HOLD_INPUT) Irp->AssociatedIrp.SystemBuffer;

    if (!input->NumberOfVolumesToFlush ||
        !input->SecondsToHoldFileSystemsTimeout ||
        !input->SecondsToHoldIrpsTimeout) {

        return STATUS_INVALID_PARAMETER;
    }

    IoAcquireCancelSpinLock(&irql);

    if (Filter->FlushAndHoldIrp) {
        IoReleaseCancelSpinLock(irql);
        VspLogError(NULL, Filter, VS_TWO_FLUSH_AND_HOLDS,
                    STATUS_INVALID_PARAMETER, 1, FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    if (rootExtension->HoldRefCount) {

        if (!IsEqualGUID(rootExtension->HoldInstanceGuid, input->InstanceId)) {
            IoReleaseCancelSpinLock(irql);
            VspLogError(NULL, Filter, VS_TWO_FLUSH_AND_HOLDS,
                        STATUS_INVALID_PARAMETER, 2, FALSE);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        if (IsEqualGUID(rootExtension->HoldInstanceGuid, input->InstanceId)) {
            IoReleaseCancelSpinLock(irql);
            return STATUS_INVALID_PARAMETER;
        }

        rootExtension->HoldRefCount = input->NumberOfVolumesToFlush + 1;
        rootExtension->HoldInstanceGuid = input->InstanceId;
        rootExtension->SecondsToHoldFsTimeout =
                input->SecondsToHoldFileSystemsTimeout;
        rootExtension->SecondsToHoldIrpTimeout =
                input->SecondsToHoldIrpsTimeout;

        timeout.QuadPart = -10*1000*1000*
                           ((LONGLONG) rootExtension->SecondsToHoldFsTimeout);

        KeSetTimer(&rootExtension->HoldTimer, timeout,
                   &rootExtension->HoldTimerDpc);
    }

    Filter->FlushAndHoldIrp = Irp;
    InsertTailList(&rootExtension->HoldIrps, &Irp->Tail.Overlay.ListEntry);
    IoSetCancelRoutine(Irp, VspCancelRoutine);
    IoMarkIrpPending(Irp);

    rootExtension->HoldRefCount--;

    if (rootExtension->HoldRefCount != 1) {
        IoReleaseCancelSpinLock(irql);
        return STATUS_PENDING;
    }

    InitializeListHead(&q);
    while (!IsListEmpty(&rootExtension->HoldIrps)) {
        l = RemoveHeadList(&rootExtension->HoldIrps);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        filter = (PFILTER_EXTENSION)
                 IoGetCurrentIrpStackLocation(irp)->DeviceObject->
                 DeviceExtension;
        InsertTailList(&q, l);
        filter->FlushAndHoldIrp = NULL;
        IoSetCancelRoutine(irp, NULL);
    }

    irpTimeout = rootExtension->SecondsToHoldIrpTimeout;

    if (KeCancelTimer(&rootExtension->HoldTimer)) {
        IoReleaseCancelSpinLock(irql);

        VspFsTimerDpc(&rootExtension->HoldTimerDpc,
                      rootExtension->HoldTimerDpc.DeferredContext,
                      rootExtension->HoldTimerDpc.SystemArgument1,
                      rootExtension->HoldTimerDpc.SystemArgument2);

    } else {
        IoReleaseCancelSpinLock(irql);
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        irp = CONTAINING_RECORD(l, IRP, Tail.Overlay.ListEntry);
        VspFlushAndHoldWriteIrps(irp, irpTimeout);
    }

    return STATUS_PENDING;
}

NTSTATUS
VspCreateDiffAreaFileName(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PVOLUME_EXTENSION   Extension,
    OUT PUNICODE_STRING     DiffAreaFileName,
    IN  BOOLEAN             ValidateSystemVolumeInformationFolder,
    IN  GUID*               SnapshotGuid
    )

/*++

Routine Description:

    This routine builds the diff area file name for the given diff area
    volume and the given volume snapshot number.  The name formed will
    look like <Diff Area Volume Name>\<Volume Snapshot Number><GUID>.

Arguments:

    Filter                  - Supplies the filter extension.

    VolumeSnapshotNumber    - Supplies the volume snapshot number.

    DiffAreaFileName        - Returns the name of the diff area file.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT              targetObject = DeviceObject;
    KEVENT                      event;
    PMOUNTDEV_NAME              name;
    UCHAR                       buffer[512];
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    UNICODE_STRING              sysvol, guidString, numberString, string;
    WCHAR                       numberBuffer[80];

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    name = (PMOUNTDEV_NAME) buffer;
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        targetObject, NULL, 0, name,
                                        500, FALSE, &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitUnicodeString(&sysvol, RTL_SYSTEM_VOLUME_INFORMATION_FOLDER);

    if (SnapshotGuid) {
        status = RtlStringFromGUID(*SnapshotGuid, &guidString);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        swprintf(numberBuffer, L"\\%s", guidString.Buffer);
        ExFreePool(guidString.Buffer);
    } else if (Extension) {
        if (Extension->IsPersistent) {
            status = RtlStringFromGUID(Extension->SnapshotGuid, &guidString);
            if (!NT_SUCCESS(status)) {
                return status;
            }
            swprintf(numberBuffer, L"\\%s", guidString.Buffer);
            ExFreePool(guidString.Buffer);
        } else {
            swprintf(numberBuffer, L"\\%d", Extension->VolumeNumber);
        }
    } else {
        swprintf(numberBuffer, L"\\*");
    }
    RtlInitUnicodeString(&numberString, numberBuffer);

    status = RtlStringFromGUID(VSP_DIFF_AREA_FILE_GUID, &guidString);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    string.MaximumLength = name->NameLength + sizeof(WCHAR) + sysvol.Length +
                           numberString.Length + guidString.Length +
                           sizeof(WCHAR);
    string.Length = 0;
    string.Buffer = (PWCHAR)
                    ExAllocatePoolWithTag(PagedPool, string.MaximumLength,
                                          VOLSNAP_TAG_SHORT_TERM);
    if (!string.Buffer) {
        ExFreePool(guidString.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    string.Length = name->NameLength;
    RtlCopyMemory(string.Buffer, name->Name, string.Length);
    string.Buffer[string.Length/sizeof(WCHAR)] = '\\';
    string.Length += sizeof(WCHAR);

    if (ValidateSystemVolumeInformationFolder) {
        RtlCreateSystemVolumeInformationFolder(&string);
    }

    RtlAppendUnicodeStringToString(&string, &sysvol);
    RtlAppendUnicodeStringToString(&string, &numberString);
    RtlAppendUnicodeStringToString(&string, &guidString);
    ExFreePool(guidString.Buffer);

    string.Buffer[string.Length/sizeof(WCHAR)] = 0;

    *DiffAreaFileName = string;

    return STATUS_SUCCESS;
}

NTSTATUS
VspCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    OUT PACL*                   Acl
    )

{
    PSECURITY_DESCRIPTOR    sd;
    NTSTATUS                status;
    ULONG                   aclLength;
    PACL                    acl;

    sd = (PSECURITY_DESCRIPTOR)
         ExAllocatePoolWithTag(PagedPool, sizeof(SECURITY_DESCRIPTOR),
                               VOLSNAP_TAG_SHORT_TERM);
    if (!sd) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(status)) {
        ExFreePool(sd);
        return status;
    }

    aclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                RtlLengthSid(SeExports->SeAliasAdminsSid) - sizeof(ULONG);

    acl = (PACL) ExAllocatePoolWithTag(PagedPool, aclLength,
                                       VOLSNAP_TAG_SHORT_TERM);
    if (!acl) {
        ExFreePool(sd);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlCreateAcl(acl, aclLength, ACL_REVISION);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        ExFreePool(sd);
        return status;
    }

    status = RtlAddAccessAllowedAce(acl, ACL_REVISION, DELETE,
                                    SeExports->SeAliasAdminsSid);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        ExFreePool(sd);
        return status;
    }

    status = RtlSetDaclSecurityDescriptor(sd, TRUE, acl, FALSE);
    if (!NT_SUCCESS(status)) {
        ExFreePool(acl);
        ExFreePool(sd);
        return status;
    }

    *SecurityDescriptor = sd;
    *Acl = acl;

    return STATUS_SUCCESS;
}

NTSTATUS
VspPinFile(
    IN  PDEVICE_OBJECT  TargetObject,
    IN  HANDLE          FileHandle
    )

/*++

Routine Description:

    This routine pins down the extents of the given diff area file so that
    defrag operations are disabled.

Arguments:

    DiffAreaFile    - Supplies the diff area file.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS            status;
    UNICODE_STRING      volumeName;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;
    MARK_HANDLE_INFO    markHandleInfo;

    status = VspCreateDiffAreaFileName(TargetObject, NULL, &volumeName,
                                       FALSE, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    // 66 characters back to take of \System Volume Information\*{guid}
    // resulting in the name of the volume.

    volumeName.Length -= 66*sizeof(WCHAR);
    volumeName.Buffer[volumeName.Length/sizeof(WCHAR)] = 0;

    InitializeObjectAttributes(&oa, &volumeName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    ExFreePool(volumeName.Buffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlZeroMemory(&markHandleInfo, sizeof(MARK_HANDLE_INFO));
    markHandleInfo.VolumeHandle = h;
    markHandleInfo.HandleInfo = MARK_HANDLE_PROTECT_CLUSTERS;

    status = ZwFsControlFile(FileHandle, NULL, NULL, NULL,
                             &ioStatus, FSCTL_MARK_HANDLE, &markHandleInfo,
                             sizeof(markHandleInfo), NULL, 0);

    ZwClose(h);

    return status;
}

NTSTATUS
VspOptimizeDiffAreaFileLocation(
    IN  PFILTER_EXTENSION   Filter,
    IN  HANDLE              FileHandle,
    IN  PVOLUME_EXTENSION   BitmapExtension,
    IN  LONGLONG            StartingOffset,
    IN  LONGLONG            FileSize
    )

/*++

Routine Description:

    This routine optimizes the location of the diff area file so that more
    of it can be used.

Arguments:

    Filter          - Supplies the filter extension where the diff area resides.

    FileHandle      - Provides a handle to the diff area.

    BitmapExtension - Supplies the extension of the active snapshot on the
                        given filter, if any.

    StartingOffset  - Supplies the starting point of where to optimize
                        the file.

    FileSize        - Supplies the allocated size of the file.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatus;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bitmapSize;
    PVOID                       bitmapBuffer;
    RTL_BITMAP                  bitmap;
    PMOUNTDEV_NAME              mountdevName;
    UCHAR                       buffer[512];
    KEVENT                      event;
    PIRP                        irp;
    UNICODE_STRING              fileName;
    OBJECT_ATTRIBUTES           oa;
    HANDLE                      h;
    KIRQL                       irql;
    ULONG                       numBitsToFind, bitIndex, bpc, bitsFound, chunk;
    MOVE_FILE_DATA              moveFileData;

    // Align the given file and if 'BitmapExtension' is available, try to
    // confine the file to the bits already set in the bitmap in
    // 'BitmapExtension'.

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus, &fsSize,
                                          sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    bitmapSize = (ULONG) (fsSize.TotalAllocationUnits.QuadPart*
                          fsSize.SectorsPerAllocationUnit*
                          fsSize.BytesPerSector/BLOCK_SIZE);
    bitmapBuffer = ExAllocatePoolWithTag(NonPagedPool,
                   (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
    if (!bitmapBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(&bitmap, (PULONG) bitmapBuffer, bitmapSize);
    RtlClearAllBits(&bitmap);

    mountdevName = (PMOUNTDEV_NAME) buffer;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        Filter->TargetObject, NULL, 0,
                                        mountdevName, 500, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ExFreePool(bitmapBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(bitmapBuffer);
        return status;
    }

    mountdevName->Name[mountdevName->NameLength/sizeof(WCHAR)] = 0;
    RtlInitUnicodeString(&fileName, mountdevName->Name);

    InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        ExFreePool(bitmapBuffer);
        return status;
    }

    status = VspMarkFreeSpaceInBitmap(NULL, h, &bitmap);
    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        ExFreePool(bitmapBuffer);
        return status;
    }

    if (BitmapExtension) {
        status = VspIncrementVolumeRefCount(BitmapExtension);
        if (NT_SUCCESS(status)) {
            KeAcquireSpinLock(&BitmapExtension->SpinLock, &irql);
            if (BitmapExtension->VolumeBlockBitmap) {

                if (BitmapExtension->VolumeBlockBitmap->SizeOfBitMap <
                    bitmap.SizeOfBitMap) {

                    bitmap.SizeOfBitMap =
                            BitmapExtension->VolumeBlockBitmap->SizeOfBitMap;
                }

                VspAndBitmaps(&bitmap, BitmapExtension->VolumeBlockBitmap);

                if (bitmap.SizeOfBitMap < bitmapSize) {
                    bitmap.SizeOfBitMap = bitmapSize;
                    RtlClearBits(&bitmap,
                            BitmapExtension->VolumeBlockBitmap->SizeOfBitMap,
                            bitmapSize -
                            BitmapExtension->VolumeBlockBitmap->SizeOfBitMap);
                }
            }
            KeReleaseSpinLock(&BitmapExtension->SpinLock, irql);

            VspDecrementVolumeRefCount(BitmapExtension);
        }
    }

    numBitsToFind = (ULONG) ((FileSize - StartingOffset)/BLOCK_SIZE);
    bpc = fsSize.SectorsPerAllocationUnit*fsSize.BytesPerSector;
    chunk = 64;

    while (numBitsToFind) {

        bitsFound = numBitsToFind;
        if (bitsFound > chunk) {
            bitsFound = chunk;
        }
        bitIndex = RtlFindSetBits(&bitmap, bitsFound, 0);
        if (bitIndex == (ULONG) -1) {
            if (chunk == 1) {
                ZwClose(h);
                ExFreePool(bitmapBuffer);
                return STATUS_DISK_FULL;
            }
            chunk /= 2;
            continue;
        }

        moveFileData.FileHandle = FileHandle;
        moveFileData.StartingVcn.QuadPart = StartingOffset/bpc;
        moveFileData.StartingLcn.QuadPart =
                (((LONGLONG) bitIndex)<<BLOCK_SHIFT)/bpc;
        moveFileData.ClusterCount = (ULONG) ((((LONGLONG) bitsFound)<<
                                              BLOCK_SHIFT)/bpc);

        InterlockedIncrement(&Filter->IgnoreCopyData);

        status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                                 FSCTL_MOVE_FILE, &moveFileData,
                                 sizeof(moveFileData), NULL, 0);

        InterlockedDecrement(&Filter->IgnoreCopyData);

        RtlClearBits(&bitmap, bitIndex, bitsFound);

        if (!NT_SUCCESS(status)) {
            continue;
        }

        numBitsToFind -= bitsFound;
        StartingOffset += ((LONGLONG) bitsFound)<<BLOCK_SHIFT;
    }

    ZwClose(h);
    ExFreePool(bitmapBuffer);

    return STATUS_SUCCESS;
}

NTSTATUS
VspOpenDiffAreaFile(
    IN OUT  PVSP_DIFF_AREA_FILE DiffAreaFile,
    IN      BOOLEAN             NoErrorLogOnDiskFull
    )

{
    LARGE_INTEGER                       diffAreaFileSize;
    NTSTATUS                            status;
    UNICODE_STRING                      diffAreaFileName;
    PSECURITY_DESCRIPTOR                securityDescriptor;
    PACL                                acl;
    OBJECT_ATTRIBUTES                   oa;
    IO_STATUS_BLOCK                     ioStatus;
    BOOLEAN                             isNtfs;
    PVOLUME_EXTENSION                   bitmapExtension;

    diffAreaFileSize.QuadPart = DiffAreaFile->AllocatedFileSize;

    status = VspCreateDiffAreaFileName(DiffAreaFile->Filter->TargetObject,
                                       DiffAreaFile->Extension,
                                       &diffAreaFileName, TRUE, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = VspCreateSecurityDescriptor(&securityDescriptor, &acl);
    if (!NT_SUCCESS(status)) {
        ExFreePool(diffAreaFileName.Buffer);
        return status;
    }

    InitializeObjectAttributes(&oa, &diffAreaFileName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL, securityDescriptor);

    status = ZwCreateFile(&DiffAreaFile->FileHandle, FILE_GENERIC_READ |
                          FILE_GENERIC_WRITE, &oa, &ioStatus,
                          &diffAreaFileSize, FILE_ATTRIBUTE_HIDDEN |
                          FILE_ATTRIBUTE_SYSTEM, 0, FILE_OVERWRITE_IF,
                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT |
                          FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE |
                          FILE_NO_COMPRESSION, NULL, 0);

    ExFreePool(acl);
    ExFreePool(securityDescriptor);
    ExFreePool(diffAreaFileName.Buffer);

    if (NT_SUCCESS(status)) {
        status = VspSetFileSize(DiffAreaFile->FileHandle,
                                diffAreaFileSize.QuadPart);
        if (!NT_SUCCESS(status)) {
            ZwClose(DiffAreaFile->FileHandle);
            DiffAreaFile->FileHandle = NULL;
        }
    }

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_DISK_FULL) {
            if (!NoErrorLogOnDiskFull) {
                VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                            VS_DIFF_AREA_CREATE_FAILED_LOW_DISK_SPACE, status,
                            0, FALSE);
            }
        } else {
            VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                        VS_DIFF_AREA_CREATE_FAILED, status, 0, FALSE);
        }
        return status;
    }

    status = VspIsNtfs(DiffAreaFile->FileHandle, &isNtfs);
    if (!NT_SUCCESS(status) || !isNtfs) {
        VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                    VS_NOT_NTFS, status, 0, FALSE);
        ZwClose(DiffAreaFile->FileHandle);
        DiffAreaFile->FileHandle = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    VspAcquire(DiffAreaFile->Filter->Root);
    if (IsListEmpty(&DiffAreaFile->Filter->VolumeList)) {
        bitmapExtension = NULL;
    } else {
        bitmapExtension = CONTAINING_RECORD(
                          DiffAreaFile->Filter->VolumeList.Blink,
                          VOLUME_EXTENSION, ListEntry);
        if (bitmapExtension->IsDead) {
            bitmapExtension = NULL;
        } else {
            ObReferenceObject(bitmapExtension->DeviceObject);
        }
    }
    VspRelease(DiffAreaFile->Filter->Root);

    status = VspOptimizeDiffAreaFileLocation(DiffAreaFile->Filter,
                                             DiffAreaFile->FileHandle,
                                             bitmapExtension, 0,
                                             DiffAreaFile->AllocatedFileSize);

    if (!NT_SUCCESS(status)) {
        if (status != STATUS_DISK_FULL || !NoErrorLogOnDiskFull) {
            if (status == STATUS_DISK_FULL) {
                if (bitmapExtension) {
                    if (bitmapExtension->IgnoreCopyDataReference) {
                        VspLogError(DiffAreaFile->Extension,
                        DiffAreaFile->Filter,
                        VS_INITIAL_DEFRAG_FAILED_BITMAP_ADJUSTMENT_IN_PROGRESS,
                        status, 0, FALSE);
                    } else {
                        VspLogError(DiffAreaFile->Extension,
                                    DiffAreaFile->Filter,
                                    VS_INITIAL_DEFRAG_FAILED, status, 0,
                                    FALSE);
                    }
                } else {
                    VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                                VS_INITIAL_DEFRAG_FAILED_STRICT_FRAGMENTATION,
                                status, 0, FALSE);
                }
            } else {
                VspLogError(DiffAreaFile->Extension, NULL,
                            VS_CANT_ALLOCATE_BITMAP, status, 5, FALSE);
            }
        }
        ZwClose(DiffAreaFile->FileHandle);
        DiffAreaFile->FileHandle = NULL;
        if (bitmapExtension) {
            ObDereferenceObject(bitmapExtension->DeviceObject);
        }
        return status;
    }

    if (bitmapExtension) {
        ObDereferenceObject(bitmapExtension->DeviceObject);
    }

    status = VspPinFile(DiffAreaFile->Filter->TargetObject,
                        DiffAreaFile->FileHandle);
    if (!NT_SUCCESS(status)) {
        VspLogError(DiffAreaFile->Extension, DiffAreaFile->Filter,
                    VS_PIN_DIFF_AREA_FAILED, status, 0, FALSE);
        ZwClose(DiffAreaFile->FileHandle);
        DiffAreaFile->FileHandle = NULL;
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspTrimOlderSnapshotBeforeCreate(
    IN      PFILTER_EXTENSION   Filter,
    IN OUT  PLONGLONG           DiffAreaSpaceDeleted
    )

{
    LIST_ENTRY          listOfDiffAreaFilesToClose;
    LIST_ENTRY          listOfDeviceObjectToDelete;
    PVOLUME_EXTENSION   extension;

    InitializeListHead(&listOfDiffAreaFilesToClose);
    InitializeListHead(&listOfDeviceObjectToDelete);

    VspAcquire(Filter->Root);

    if (IsListEmpty(&Filter->VolumeList)) {
        VspRelease(Filter->Root);
        return STATUS_UNSUCCESSFUL;
    }

    extension = CONTAINING_RECORD(Filter->VolumeList.Flink,
                                  VOLUME_EXTENSION, ListEntry);

    VspAcquireNonPagedResource(extension, NULL, FALSE);
    *DiffAreaSpaceDeleted += extension->DiffAreaFile->AllocatedFileSize;
    VspReleaseNonPagedResource(extension);

    VspLogError(extension, NULL, VS_DELETE_TO_TRIM_SPACE, STATUS_SUCCESS,
                3, TRUE);

    VspDeleteOldestSnapshot(Filter, &listOfDiffAreaFilesToClose,
                            &listOfDeviceObjectToDelete, FALSE, FALSE);

    VspRelease(Filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                          &listOfDeviceObjectToDelete);

    return STATUS_SUCCESS;
}

NTSTATUS
VspCreateInitialDiffAreaFile(
    IN  PVOLUME_EXTENSION   Extension,
    IN  LONGLONG            InitialDiffAreaAllocation
    )

/*++

Routine Description:

    This routine creates the initial diff area file entries for the
    given device extension.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION               filter = Extension->Filter;
    NTSTATUS                        status;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    KIRQL                           irql;
    PVOID                           buf;
    PMDL                            mdl;
    LONGLONG                        diffAreaSpaceDeleted;

    VspAcquire(Extension->Root);

    if (!filter->DiffAreaVolume) {
        VspRelease(Extension->Root);
        return STATUS_INVALID_PARAMETER;
    }

    status = STATUS_SUCCESS;

    diffAreaFile = (PVSP_DIFF_AREA_FILE)
                   ExAllocatePoolWithTag(NonPagedPool,
                   sizeof(VSP_DIFF_AREA_FILE), VOLSNAP_TAG_DIFF_FILE);
    if (!diffAreaFile) {
        VspRelease(Extension->Root);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(diffAreaFile, sizeof(VSP_DIFF_AREA_FILE));
    diffAreaFile->Extension = Extension;
    diffAreaFile->Filter = filter->DiffAreaVolume;
    diffAreaFile->AllocatedFileSize = InitialDiffAreaAllocation;
    Extension->DiffAreaFile = diffAreaFile;

    InitializeListHead(&diffAreaFile->UnusedAllocationList);

    if (Extension->IsPersistent) {

        diffAreaFile->TableUpdateIrp =
            IoAllocateIrp((CCHAR) Extension->Root->StackSize, FALSE);
        if (!diffAreaFile->TableUpdateIrp) {
            Extension->DiffAreaFile = NULL;
            ExFreePool(diffAreaFile);
            VspRelease(Extension->Root);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        buf = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE,
                                    VOLSNAP_TAG_BUFFER);
        if (!buf) {
            IoFreeIrp(diffAreaFile->TableUpdateIrp);
            Extension->DiffAreaFile = NULL;
            ExFreePool(diffAreaFile);
            VspRelease(Extension->Root);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlZeroMemory(buf, BLOCK_SIZE);

        mdl = IoAllocateMdl(buf, BLOCK_SIZE, FALSE, FALSE, NULL);
        if (!mdl) {
            ExFreePool(buf);
            IoFreeIrp(diffAreaFile->TableUpdateIrp);
            Extension->DiffAreaFile = NULL;
            ExFreePool(diffAreaFile);
            VspRelease(Extension->Root);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        MmBuildMdlForNonPagedPool(mdl);
        diffAreaFile->TableUpdateIrp->MdlAddress = mdl;
        InitializeListHead(&diffAreaFile->TableUpdateQueue);
    }

    VspRelease(Extension->Root);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    filter->AllocatedVolumeSpace += diffAreaFile->AllocatedFileSize;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    diffAreaSpaceDeleted = 0;
    for (;;) {
        status = VspOpenDiffAreaFile(diffAreaFile, TRUE);
        if (status != STATUS_DISK_FULL) {
            break;
        }

        if (diffAreaSpaceDeleted >= 2*InitialDiffAreaAllocation) {
            status = VspOpenDiffAreaFile(diffAreaFile, FALSE);
            break;
        }

        status = VspTrimOlderSnapshotBeforeCreate(filter,
                                                  &diffAreaSpaceDeleted);
        if (!NT_SUCCESS(status)) {
            status = VspOpenDiffAreaFile(diffAreaFile, FALSE);
            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    return status;

Cleanup:

    if (Extension->DiffAreaFile) {
        diffAreaFile = Extension->DiffAreaFile;
        Extension->DiffAreaFile = NULL;

        if (diffAreaFile->FileHandle) {
            ZwClose(diffAreaFile->FileHandle);
        }

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        filter->AllocatedVolumeSpace -= diffAreaFile->AllocatedFileSize;
        KeReleaseSpinLock(&filter->SpinLock, irql);

        if (diffAreaFile->TableUpdateIrp) {
            ExFreePool(MmGetMdlVirtualAddress(
                       diffAreaFile->TableUpdateIrp->MdlAddress));
            IoFreeMdl(diffAreaFile->TableUpdateIrp->MdlAddress);
            IoFreeIrp(diffAreaFile->TableUpdateIrp);
        }

        ASSERT(!diffAreaFile->FilterListEntryBeingUsed);
        ExFreePool(diffAreaFile);
    }

    return status;
}

VOID
VspDeleteInitialDiffAreaFile(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    PLIST_ENTRY                 l, ll;
    PVSP_DIFF_AREA_FILE         diffAreaFile;
    KIRQL                       irql;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;

    diffAreaFile = Extension->DiffAreaFile;
    Extension->DiffAreaFile = NULL;

    ASSERT(diffAreaFile);

    if (diffAreaFile->FileHandle) {
        ZwClose(diffAreaFile->FileHandle);
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    filter->AllocatedVolumeSpace -= diffAreaFile->AllocatedFileSize;
    filter->UsedVolumeSpace -= diffAreaFile->NextAvailable;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    while (!IsListEmpty(&diffAreaFile->UnusedAllocationList)) {
        ll = RemoveHeadList(&diffAreaFile->UnusedAllocationList);
        diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        ExFreePool(diffAreaFileAllocation);
    }

    KeAcquireSpinLock(&diffAreaFile->Filter->SpinLock, &irql);
    if (diffAreaFile->FilterListEntryBeingUsed) {
        RemoveEntryList(&diffAreaFile->FilterListEntry);
        diffAreaFile->FilterListEntryBeingUsed = FALSE;
    }
    KeReleaseSpinLock(&diffAreaFile->Filter->SpinLock, irql);

    if (diffAreaFile->TableUpdateIrp) {
        ExFreePool(MmGetMdlVirtualAddress(
                   diffAreaFile->TableUpdateIrp->MdlAddress));
        IoFreeMdl(diffAreaFile->TableUpdateIrp->MdlAddress);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        diffAreaFile->TableUpdateIrp = NULL;
    }

    ExFreePool(diffAreaFile);
}

VOID
VspDiffAreaFillCompletion(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT    context = (PVSP_CONTEXT) Context;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_GROW_DIFF_AREA);

    KeSetEvent(&context->GrowDiffArea.Event, IO_NO_INCREMENT, FALSE);
}

NTSTATUS
VspMarkFileAllocationInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              FileHandle,
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile,
    IN  PRTL_BITMAP         BitmapToSet
    )

{
    NTSTATUS                    status;
    BOOLEAN                     isNtfs;
    IO_STATUS_BLOCK             ioStatus;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bpc;
    STARTING_VCN_INPUT_BUFFER   input;
    RETRIEVAL_POINTERS_BUFFER   output;
    LONGLONG                    start, length, end, roundedStart, roundedEnd, s;
    ULONG                       startBit, numBits, i;
    KIRQL                       irql;
    PVOLUME_EXTENSION           bitmapExtension;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    BOOLEAN                     isNegative;
    PVSP_CONTEXT                context;

    status = VspIsNtfs(FileHandle, &isNtfs);
    if (!NT_SUCCESS(status) || !isNtfs) {
        return status;
    }

    status = ZwQueryVolumeInformationFile(FileHandle, &ioStatus,
                                          &fsSize, sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    bpc = fsSize.BytesPerSector*fsSize.SectorsPerAllocationUnit;
    input.StartingVcn.QuadPart = 0;

    for (;;) {

        status = ZwFsControlFile(FileHandle, NULL, NULL, NULL, &ioStatus,
                                 FSCTL_GET_RETRIEVAL_POINTERS, &input,
                                 sizeof(input), &output, sizeof(output));

        if (!NT_SUCCESS(status) && status != STATUS_BUFFER_OVERFLOW) {
            if (status == STATUS_END_OF_FILE) {
                status = STATUS_SUCCESS;
            }
            break;
        }

        if (!output.ExtentCount) {
            if (DiffAreaFile) {
                status = STATUS_INVALID_PARAMETER;
            } else {
                status = STATUS_SUCCESS;
            }
            break;
        }

        if (output.Extents[0].Lcn.QuadPart == -1) {
            ASSERT(!DiffAreaFile);
            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }
            input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
            continue;
        }

        start = output.Extents[0].Lcn.QuadPart*bpc;
        length = output.Extents[0].NextVcn.QuadPart -
                 output.StartingVcn.QuadPart;
        length *= bpc;
        end = start + length;

        roundedStart = start&(~(BLOCK_SIZE - 1));
        roundedEnd = end&(~(BLOCK_SIZE - 1));

        if (start != roundedStart) {
            roundedStart += BLOCK_SIZE;
        }

        if (DiffAreaFile) {

            if (IsListEmpty(&DiffAreaFile->Filter->VolumeList)) {
                bitmapExtension = NULL;
            } else {
                bitmapExtension = CONTAINING_RECORD(
                                  DiffAreaFile->Filter->VolumeList.Blink,
                                  VOLUME_EXTENSION, ListEntry);
                if (bitmapExtension->IsDead) {
                    bitmapExtension = NULL;
                }
            }

            if (roundedStart > start) {
                diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                         ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(DIFF_AREA_FILE_ALLOCATION),
                                         VOLSNAP_TAG_BIT_HISTORY);
                if (!diffAreaFileAllocation) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                diffAreaFileAllocation->Offset = start;
                diffAreaFileAllocation->NLength = -(roundedStart - start);
                if (roundedStart > end) {
                    diffAreaFileAllocation->NLength += roundedStart - end;
                }
                ASSERT(diffAreaFileAllocation->NLength);
                InsertTailList(&DiffAreaFile->UnusedAllocationList,
                               &diffAreaFileAllocation->ListEntry);
            }

            diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                     ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(DIFF_AREA_FILE_ALLOCATION),
                                     VOLSNAP_TAG_BIT_HISTORY);
            if (!diffAreaFileAllocation) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            diffAreaFileAllocation->Offset = roundedStart;
            diffAreaFileAllocation->NLength = 0;

            for (s = roundedStart; s < roundedEnd; s += BLOCK_SIZE) {

                isNegative = FALSE;
                if (bitmapExtension) {
                    KeAcquireSpinLock(&bitmapExtension->SpinLock, &irql);
                    if (bitmapExtension->VolumeBlockBitmap &&
                        !RtlCheckBit(bitmapExtension->VolumeBlockBitmap,
                                     s>>BLOCK_SHIFT)) {

                        isNegative = TRUE;
                    }
                    KeReleaseSpinLock(&bitmapExtension->SpinLock, irql);
                }

                if (isNegative) {
                    if (diffAreaFileAllocation->NLength <= 0) {
                        diffAreaFileAllocation->NLength -= BLOCK_SIZE;
                    } else {
                        InsertTailList(&DiffAreaFile->UnusedAllocationList,
                                       &diffAreaFileAllocation->ListEntry);
                        diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(DIFF_AREA_FILE_ALLOCATION),
                                VOLSNAP_TAG_BIT_HISTORY);
                        if (!diffAreaFileAllocation) {
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }
                        diffAreaFileAllocation->Offset = s;
                        diffAreaFileAllocation->NLength = -BLOCK_SIZE;
                    }
                } else {
                    if (diffAreaFileAllocation->NLength >= 0) {
                        diffAreaFileAllocation->NLength += BLOCK_SIZE;
                    } else {
                        InsertTailList(&DiffAreaFile->UnusedAllocationList,
                                       &diffAreaFileAllocation->ListEntry);
                        diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(DIFF_AREA_FILE_ALLOCATION),
                                VOLSNAP_TAG_BIT_HISTORY);
                        if (!diffAreaFileAllocation) {
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }
                        diffAreaFileAllocation->Offset = s;
                        diffAreaFileAllocation->NLength = BLOCK_SIZE;
                    }
                }
            }

            if (diffAreaFileAllocation->NLength) {
                InsertTailList(&DiffAreaFile->UnusedAllocationList,
                               &diffAreaFileAllocation->ListEntry);
            } else {
                ExFreePool(diffAreaFileAllocation);
            }

            if (end > roundedEnd && roundedEnd >= roundedStart) {

                diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                                         ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(DIFF_AREA_FILE_ALLOCATION),
                                         VOLSNAP_TAG_BIT_HISTORY);
                if (!diffAreaFileAllocation) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                diffAreaFileAllocation->Offset = roundedEnd;
                diffAreaFileAllocation->NLength = -(end - roundedEnd);
                InsertTailList(&DiffAreaFile->UnusedAllocationList,
                               &diffAreaFileAllocation->ListEntry);
            }

            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }
            input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
            continue;
        }

        if (roundedStart >= roundedEnd) {
            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }
            input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
            continue;
        }

        startBit = (ULONG) (roundedStart>>BLOCK_SHIFT);
        numBits = (ULONG) ((roundedEnd - roundedStart)>>BLOCK_SHIFT);

        if (BitmapToSet) {
            RtlSetBits(BitmapToSet, startBit, numBits);
        } else {
            KeAcquireSpinLock(&Extension->SpinLock, &irql);
            if (Extension->VolumeBlockBitmap) {
                if (Extension->IgnorableProduct) {
                    for (i = 0; i < numBits; i++) {
                        if (RtlCheckBit(Extension->IgnorableProduct,
                                        i + startBit)) {

                            RtlSetBit(Extension->VolumeBlockBitmap,
                                      i + startBit);
                        }
                    }
                } else {
                    RtlSetBits(Extension->VolumeBlockBitmap, startBit,
                               numBits);
                }
            }
            KeReleaseSpinLock(&Extension->SpinLock, irql);
        }

        if (status != STATUS_BUFFER_OVERFLOW) {
            break;
        }

        input.StartingVcn.QuadPart = output.Extents[0].NextVcn.QuadPart;
    }

    if (DiffAreaFile && Extension->IsPersistent &&
        !Extension->NoDiffAreaFill) {

        context = VspAllocateContext(Extension->Root);
        if (!context) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        context->Type = VSP_CONTEXT_TYPE_GROW_DIFF_AREA;
        ExInitializeWorkItem(&context->WorkItem, VspDiffAreaFillCompletion,
                             context);
        context->GrowDiffArea.Extension = Extension;
        context->GrowDiffArea.ExtentList = DiffAreaFile->UnusedAllocationList;
        ASSERT(!IsListEmpty(&DiffAreaFile->UnusedAllocationList));
        context->GrowDiffArea.ExtentList.Flink->Blink =
                &context->GrowDiffArea.ExtentList;
        context->GrowDiffArea.ExtentList.Blink->Flink =
                &context->GrowDiffArea.ExtentList;
        KeInitializeSpinLock(&context->GrowDiffArea.SpinLock);
        context->GrowDiffArea.CurrentEntry =
                context->GrowDiffArea.ExtentList.Flink;
        context->GrowDiffArea.CurrentEntryOffset = 0;
        context->GrowDiffArea.TargetObject =
                DiffAreaFile->Filter->TargetObject;
        ObReferenceObject(context->GrowDiffArea.TargetObject);

        KeInitializeEvent(&context->GrowDiffArea.Event, NotificationEvent,
                          FALSE);

        VspLaunchDiffAreaFill(context);

        KeWaitForSingleObject(&context->GrowDiffArea.Event, Executive,
                              KernelMode, FALSE, NULL);

        DiffAreaFile->UnusedAllocationList.Blink->Flink =
                &DiffAreaFile->UnusedAllocationList;
        DiffAreaFile->UnusedAllocationList.Flink->Blink =
                &DiffAreaFile->UnusedAllocationList;

        VspReleaseNonPagedResource(Extension);

        status = context->GrowDiffArea.ResultStatus;

        VspFreeContext(Extension->Root, context);
    }

    return status;
}

NTSTATUS
VspSetDiffAreaBlocksInBitmap(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PFILTER_EXTENSION   diffAreaFilter;
    KIRQL               irql;
    NTSTATUS            status, status2;
    PLIST_ENTRY         l;

    diffAreaFile = Extension->DiffAreaFile;
    ASSERT(diffAreaFile);
    diffAreaFilter = diffAreaFile->Filter;

    KeAcquireSpinLock(&diffAreaFilter->SpinLock, &irql);
    ASSERT(!diffAreaFile->FilterListEntryBeingUsed);
    InsertTailList(&diffAreaFilter->DiffAreaFilesOnThisFilter,
                   &diffAreaFile->FilterListEntry);
    diffAreaFile->FilterListEntryBeingUsed = TRUE;
    KeReleaseSpinLock(&diffAreaFilter->SpinLock, irql);

    status = VspMarkFileAllocationInBitmap(Extension,
                                           diffAreaFile->FileHandle,
                                           diffAreaFile, NULL);
    if (!NT_SUCCESS(status)) {
        VspLogError(Extension, diffAreaFilter, VS_CANT_MAP_DIFF_AREA_FILE,
                    status, 0, FALSE);
        KeAcquireSpinLock(&diffAreaFilter->SpinLock, &irql);
        RemoveEntryList(&diffAreaFile->FilterListEntry);
        diffAreaFile->FilterListEntryBeingUsed = FALSE;
        KeReleaseSpinLock(&diffAreaFilter->SpinLock, irql);
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspCreateInitialHeap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             CallerHoldingSemaphore
    )

{
    PVSP_CONTEXT    context;
    NTSTATUS        status;

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = Extension;
    if (CallerHoldingSemaphore) {
        context->Extension.Irp = (PIRP) 1;
    } else {
        context->Extension.Irp = NULL;
    }

    ObReferenceObject(Extension->DeviceObject);
    VspCreateHeap(context);

    if (!Extension->NextDiffAreaFileMap) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(!Extension->DiffAreaFileMap);
    Extension->DiffAreaFileMap = Extension->NextDiffAreaFileMap;
    Extension->DiffAreaFileMapSize = Extension->NextDiffAreaFileMapSize;
    Extension->NextAvailable = 0;
    Extension->NextDiffAreaFileMap = NULL;

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->DiffAreaFileMap = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = Extension;
    if (CallerHoldingSemaphore) {
        context->Extension.Irp = (PIRP) 1;
    } else {
        context->Extension.Irp = NULL;
    }


    ObReferenceObject(Extension->DeviceObject);
    VspCreateHeap(context);

    if (!Extension->NextDiffAreaFileMap) {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        Extension->DiffAreaFileMap = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspReadInitialBitmap(
    IN      PVOLUME_EXTENSION   Extension,
    IN OUT  PRTL_BITMAP         Bitmap
    )

{
    PVOID                       buffer;
    PMDL                        mdl;
    PIRP                        irp;
    LONGLONG                    offset;
    PDEVICE_OBJECT              targetObject;
    NTSTATUS                    status;
    PVSP_BLOCK_INITIAL_BITMAP   initialBitmap;
    LONGLONG                    bytesCopied, bytesToCopy, totalBytesToCopy;

    buffer = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE,
                                   VOLSNAP_TAG_BUFFER);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp = IoAllocateIrp((CCHAR) Extension->Root->StackSize, FALSE);
    if (!irp) {
        IoFreeMdl(mdl);
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->MdlAddress = mdl;
    MmBuildMdlForNonPagedPool(mdl);

    offset = Extension->DiffAreaFile->InitialBitmapVolumeOffset;
    targetObject = Extension->DiffAreaFile->Filter->TargetObject;
    status = STATUS_UNSUCCESSFUL;
    initialBitmap = (PVSP_BLOCK_INITIAL_BITMAP) buffer;
    bytesCopied = 0;
    totalBytesToCopy = (Bitmap->SizeOfBitMap + 7)/8;

    while (offset) {

        status = VspSynchronousIo(irp, targetObject, IRP_MJ_READ, offset, 0);
        if (!NT_SUCCESS(status)) {
            break;
        }

        if (!IsEqualGUID(initialBitmap->Header.Signature,
                         VSP_DIFF_AREA_FILE_GUID) ||
            initialBitmap->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
            initialBitmap->Header.BlockType != VSP_BLOCK_TYPE_INITIAL_BITMAP ||
            initialBitmap->Header.ThisVolumeOffset != offset ||
            initialBitmap->Header.NextVolumeOffset == offset) {

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        bytesToCopy = (BLOCK_SIZE - VSP_OFFSET_TO_START_OF_BITMAP);
        if (bytesToCopy + bytesCopied > totalBytesToCopy) {
            bytesToCopy = totalBytesToCopy - bytesCopied;
        }

        RtlCopyMemory((PCHAR) Bitmap->Buffer + bytesCopied,
                      (PCHAR) initialBitmap + VSP_OFFSET_TO_START_OF_BITMAP,
                      (ULONG) bytesToCopy);

        bytesCopied += bytesToCopy;

        offset = initialBitmap->Header.NextVolumeOffset;
    }

    ExFreePool(buffer);
    IoFreeMdl(mdl);
    IoFreeIrp(irp);

    return status;
}

VOID
VspWriteInitialBitmap(
    IN      PVOLUME_EXTENSION   Extension,
    IN OUT  PRTL_BITMAP         Bitmap
    )

{
    ULONG                       numBytesPerBlock, bitmapBytes, numBlocks, i;
    PLONGLONG                   volumeOffset, fileOffset;
    PVOID                       buffer;
    PMDL                        mdl;
    PIRP                        irp;
    NTSTATUS                    status;
    PVSP_BLOCK_INITIAL_BITMAP   initialBitmap;
    ULONG                       bytesCopied, bytesToCopy;
    PDEVICE_OBJECT              targetObject;
    CHAR                        controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_DIFF_AREA diffAreaControlItem;

    numBytesPerBlock = BLOCK_SIZE - VSP_OFFSET_TO_START_OF_BITMAP;
    bitmapBytes = (Bitmap->SizeOfBitMap + 7)/8;

    numBlocks = (bitmapBytes + numBytesPerBlock - 1)/numBytesPerBlock;
    ASSERT(numBlocks);

    volumeOffset = (PLONGLONG)
                   ExAllocatePoolWithTag(NonPagedPool,
                                         numBlocks*sizeof(LONGLONG),
                                         VOLSNAP_TAG_SHORT_TERM);
    if (!volumeOffset) {
        return;
    }

    fileOffset = (PLONGLONG)
                 ExAllocatePoolWithTag(NonPagedPool,
                                       numBlocks*sizeof(LONGLONG),
                                       VOLSNAP_TAG_SHORT_TERM);
    if (!fileOffset) {
        ExFreePool(volumeOffset);
        return;
    }

    buffer = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE,
                                   VOLSNAP_TAG_BUFFER);
    if (!buffer) {
        ExFreePool(fileOffset);
        ExFreePool(volumeOffset);
        return;
    }

    mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buffer);
        ExFreePool(fileOffset);
        ExFreePool(volumeOffset);
        return;
    }

    irp = IoAllocateIrp((CCHAR) Extension->Root->StackSize, FALSE);
    if (!irp) {
        IoFreeMdl(mdl);
        ExFreePool(buffer);
        ExFreePool(fileOffset);
        ExFreePool(volumeOffset);
        return;
    }

    irp->MdlAddress = mdl;
    MmBuildMdlForNonPagedPool(mdl);

    VspAcquireNonPagedResource(Extension, NULL, FALSE);

    for (i = 0; i < numBlocks; i++) {
        status = VspAllocateDiffAreaSpace(Extension, &volumeOffset[i],
                                          &fileOffset[i], NULL, NULL);
        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    if (i < numBlocks) {
        goto Cleanup;
    }

    initialBitmap = (PVSP_BLOCK_INITIAL_BITMAP) buffer;
    bytesCopied = 0;
    targetObject = Extension->DiffAreaFile->Filter->TargetObject;

    for (i = 0; i < numBlocks; i++) {

        RtlZeroMemory(initialBitmap, BLOCK_SIZE);

        initialBitmap->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
        initialBitmap->Header.Version = VOLSNAP_PERSISTENT_VERSION;
        initialBitmap->Header.BlockType = VSP_BLOCK_TYPE_INITIAL_BITMAP;
        initialBitmap->Header.ThisFileOffset = fileOffset[i];
        initialBitmap->Header.ThisVolumeOffset = volumeOffset[i];

        if (i + 1 < numBlocks) {
            initialBitmap->Header.NextVolumeOffset = volumeOffset[i + 1];
        } else {
            initialBitmap->Header.NextVolumeOffset = 0;
        }

        bytesToCopy = (BLOCK_SIZE - VSP_OFFSET_TO_START_OF_BITMAP);
        if (bytesToCopy + bytesCopied > bitmapBytes) {
            bytesToCopy = bitmapBytes - bytesCopied;
        }

        RtlCopyMemory((PCHAR) initialBitmap + VSP_OFFSET_TO_START_OF_BITMAP,
                      (PCHAR) Bitmap->Buffer + bytesCopied,
                      (ULONG) bytesToCopy);

        bytesCopied += bytesToCopy;

        status = VspSynchronousIo(irp, targetObject, IRP_MJ_WRITE,
                                  volumeOffset[i], 0);
        if (!NT_SUCCESS(status)) {
            goto Cleanup;
        }
    }

    status = VspIoControlItem(Extension->DiffAreaFile->Filter,
                              VSP_CONTROL_ITEM_TYPE_DIFF_AREA,
                              &Extension->SnapshotGuid, FALSE,
                              controlItemBuffer, FALSE);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    diffAreaControlItem = (PVSP_CONTROL_ITEM_DIFF_AREA) controlItemBuffer;
    diffAreaControlItem->InitialBitmapVolumeOffset = volumeOffset[0];

    status = VspIoControlItem(Extension->DiffAreaFile->Filter,
                              VSP_CONTROL_ITEM_TYPE_DIFF_AREA,
                              &Extension->SnapshotGuid, TRUE,
                              controlItemBuffer, FALSE);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    Extension->DiffAreaFile->InitialBitmapVolumeOffset = volumeOffset[0];

Cleanup:
    VspReleaseNonPagedResource(Extension);
    IoFreeIrp(irp);
    IoFreeMdl(mdl);
    ExFreePool(buffer);
    ExFreePool(fileOffset);
    ExFreePool(volumeOffset);
}

VOID
VspSetOfflineBit(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             BitState
    )

{
    NTSTATUS                    status;
    CHAR                        controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT  snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;

    VspAcquireNonPagedResource(Extension, NULL, FALSE);

    if (Extension->IsOffline) {
        if (BitState) {
            VspReleaseNonPagedResource(Extension);
            return;
        }
        InterlockedExchange(&Extension->IsOffline, FALSE);
    } else {
        if (!BitState) {
            VspReleaseNonPagedResource(Extension);
            return;
        }
        InterlockedExchange(&Extension->IsOffline, TRUE);
    }

    if (!Extension->IsPersistent) {
        VspReleaseNonPagedResource(Extension);
        return;
    }

    status = VspIoControlItem(Extension->Filter,
                              VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, FALSE,
                              controlItemBuffer, FALSE);
    if (!NT_SUCCESS(status)) {
        ASSERT(FALSE);
        VspReleaseNonPagedResource(Extension);
        return;
    }

    if (BitState) {
        snapshotControlItem->SnapshotControlItemFlags |=
                VSP_SNAPSHOT_CONTROL_ITEM_FLAG_OFFLINE;
    } else {
        snapshotControlItem->SnapshotControlItemFlags &=
                ~VSP_SNAPSHOT_CONTROL_ITEM_FLAG_OFFLINE;
    }

    status = VspIoControlItem(Extension->Filter,
                              VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, TRUE,
                              controlItemBuffer, FALSE);

    ASSERT(NT_SUCCESS(status));

    VspReleaseNonPagedResource(Extension);
}

NTSTATUS
VspComputeIgnorableBitmap(
    IN      PVOLUME_EXTENSION   Extension,
    IN OUT  PRTL_BITMAP         Bitmap
    )

{
    PFILTER_EXTENSION           filter = Extension->Filter;
    KIRQL                       irql;
    ULONG                       bitmapSize;
    PVOID                       bitmapBuffer;
    RTL_BITMAP                  bitmap;
    WCHAR                       nameBuffer[150];
    UNICODE_STRING              name, guidString;
    OBJECT_ATTRIBUTES           oa;
    NTSTATUS                    status;
    HANDLE                      h, fileHandle;
    IO_STATUS_BLOCK             ioStatus;
    CHAR                        buffer[200];
    PFILE_NAMES_INFORMATION     fileNamesInfo;
    BOOLEAN                     restartScan, moveEntries;
    PLIST_ENTRY                 l;
    PVOLUME_EXTENSION           e;
    PTRANSLATION_TABLE_ENTRY    p;

    VspAcquire(Extension->Root);
    if (Extension->IsDead) {
        VspRelease(Extension->Root);
        return STATUS_UNSUCCESSFUL;
    }

    if (Bitmap) {
        bitmapBuffer = NULL;
    } else {
        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (!Extension->VolumeBlockBitmap) {
            KeReleaseSpinLock(&Extension->SpinLock, irql);
            VspRelease(Extension->Root);
            return STATUS_INVALID_PARAMETER;
        }
        bitmapSize = Extension->VolumeBlockBitmap->SizeOfBitMap;
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        bitmapBuffer = ExAllocatePoolWithTag(
                       NonPagedPool, (bitmapSize + 8*sizeof(ULONG) - 1)/
                       (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
        if (!bitmapBuffer) {
            VspRelease(Extension->Root);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlInitializeBitMap(&bitmap, (PULONG) bitmapBuffer, bitmapSize);
        RtlClearAllBits(&bitmap);

        Bitmap = &bitmap;
    }

    if (Extension->DiffAreaFile->InitialBitmapVolumeOffset) {
        status = VspReadInitialBitmap(Extension, Bitmap);
        if (NT_SUCCESS(status)) {
            goto AddInTable;
        }
        RtlClearAllBits(Bitmap);
    }
    VspRelease(Extension->Root);

    if (Extension->IsOffline) {
        VspSetOfflineBit(Extension, FALSE);
    }

    swprintf(nameBuffer,
             L"\\Device\\HarddiskVolumeShadowCopy%d\\pagefile.sys",
             Extension->VolumeNumber);
    RtlInitUnicodeString(&name, nameBuffer);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT);
    if (NT_SUCCESS(status)) {
        if (!VspHasStrongAcl(h, &status)) {
            ZwClose(h);
        }
    }
    if (NT_SUCCESS(status)) {
        VspMarkFileAllocationInBitmap(NULL, h, NULL, Bitmap);
        ZwClose(h);
    }

    swprintf(nameBuffer,
             L"\\Device\\HarddiskVolumeShadowCopy%d\\hiberfil.sys",
             Extension->VolumeNumber);
    RtlInitUnicodeString(&name, nameBuffer);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT);
    if (NT_SUCCESS(status)) {
        if (!VspHasStrongAcl(h, &status)) {
            ZwClose(h);
        }
    }
    if (NT_SUCCESS(status)) {
        VspMarkFileAllocationInBitmap(NULL, h, NULL, Bitmap);
        ZwClose(h);
    }

    swprintf(nameBuffer,
        L"\\Device\\HarddiskVolumeShadowCopy%d\\System Volume Information\\",
        Extension->VolumeNumber);
    RtlInitUnicodeString(&name, nameBuffer);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, &oa,
                        &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = STATUS_SUCCESS;
        }
        if (bitmapBuffer) {
            ExFreePool(bitmapBuffer);
        }
        return status;
    }

    status = RtlStringFromGUID(VSP_DIFF_AREA_FILE_GUID, &guidString);
    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        if (bitmapBuffer) {
            ExFreePool(bitmapBuffer);
        }
        return status;
    }

    name.Buffer = nameBuffer;
    name.Length = sizeof(WCHAR) + guidString.Length;
    name.MaximumLength = name.Length + sizeof(WCHAR);

    name.Buffer[0] = '*';
    RtlCopyMemory(&name.Buffer[1], guidString.Buffer, guidString.Length);
    name.Buffer[name.Length/sizeof(WCHAR)] = 0;
    ExFreePool(guidString.Buffer);

    fileNamesInfo = (PFILE_NAMES_INFORMATION) buffer;

    restartScan = TRUE;
    for (;;) {

        status = ZwQueryDirectoryFile(h, NULL, NULL, NULL, &ioStatus,
                                      fileNamesInfo, 200,
                                      FileNamesInformation, TRUE,
                                      restartScan ? &name : NULL,
                                      restartScan);
        restartScan = FALSE;
        if (!NT_SUCCESS(status)) {
            break;
        }

        name.Length = name.MaximumLength =
                (USHORT) fileNamesInfo->FileNameLength;
        name.Buffer = fileNamesInfo->FileName;

        InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                                   OBJ_KERNEL_HANDLE, h, NULL);

        status = ZwOpenFile(&fileHandle, FILE_GENERIC_READ, &oa, &ioStatus,
                            FILE_SHARE_DELETE | FILE_SHARE_READ |
                            FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        VspMarkFileAllocationInBitmap(NULL, fileHandle, NULL, Bitmap);

        ZwClose(fileHandle);
    }

    ZwClose(h);

    status = VspMarkFreeSpaceInBitmap(Extension, NULL, Bitmap);
    if (!NT_SUCCESS(status)) {
        if (bitmapBuffer) {
            ExFreePool(bitmapBuffer);
        }
        return status;
    }

    VspAcquire(Extension->Root);
    if (Extension->IsDead) {
        VspRelease(Extension->Root);
        if (bitmapBuffer) {
            ExFreePool(bitmapBuffer);
        }
        return STATUS_UNSUCCESSFUL;
    }

    if (Extension->IsPersistent) {
        VspWriteInitialBitmap(Extension, Bitmap);
    }

AddInTable:

    for (l = &Extension->ListEntry; l != &filter->VolumeList; l = l->Flink) {

        e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        VspAcquirePagedResource(e, NULL);

        moveEntries = FALSE;

        _try {

            p = (PTRANSLATION_TABLE_ENTRY)
                RtlEnumerateGenericTable(&e->VolumeBlockTable, TRUE);

            while (p) {

                RtlSetBit(Bitmap, (ULONG) (p->VolumeOffset>>BLOCK_SHIFT));

                if (p->Flags&VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY) {
                    moveEntries = TRUE;
                }

                p = (PTRANSLATION_TABLE_ENTRY)
                    RtlEnumerateGenericTable(&e->VolumeBlockTable, FALSE);
            }

            if (moveEntries) {

                p = (PTRANSLATION_TABLE_ENTRY)
                    RtlEnumerateGenericTable(&e->VolumeBlockTable, TRUE);

                while (p) {

                    if (p->Flags&VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY) {
                        RtlClearBit(Bitmap,
                                    (ULONG) (p->TargetOffset>>BLOCK_SHIFT));
                    }

                    p = (PTRANSLATION_TABLE_ENTRY)
                        RtlEnumerateGenericTable(&e->VolumeBlockTable, FALSE);
                }
            }

        } _except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }

        VspReleasePagedResource(e);

        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    VspRelease(Extension->Root);

    if (bitmapBuffer) {
        ExFreePool(bitmapBuffer);
    }

    return status;
}

VOID
VspAndBitmaps(
    IN OUT  PRTL_BITMAP BaseBitmap,
    IN      PRTL_BITMAP FactorBitmap
    )

{
    ULONG   n, i;
    PULONG  p, q;

    n = (BaseBitmap->SizeOfBitMap + 8*sizeof(ULONG) - 1)/(8*sizeof(ULONG));
    p = BaseBitmap->Buffer;
    q = FactorBitmap->Buffer;

    for (i = 0; i < n; i++) {
        *p++ &= *q++;
    }
}

NTSTATUS
VspComputeIgnorableProduct(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    ULONG               bitmapSize;
    PVOID               bitmapBuffer;
    RTL_BITMAP          bitmap;
    ULONG               i, j;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   e;
    NTSTATUS            status;
    KIRQL               irql;

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    if (!Extension->IgnorableProduct) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        return STATUS_INVALID_PARAMETER;
    }
    bitmapSize = Extension->IgnorableProduct->SizeOfBitMap;
    RtlSetAllBits(Extension->IgnorableProduct);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    bitmapBuffer = ExAllocatePoolWithTag(
                   NonPagedPool, (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
    if (!bitmapBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(&bitmap, (PULONG) bitmapBuffer, bitmapSize);

    for (i = 1; ; i++) {

        RtlClearAllBits(&bitmap);

        VspAcquire(Extension->Root);

        l = filter->VolumeList.Blink;
        if (l != &Extension->ListEntry) {
            VspRelease(Extension->Root);
            ExFreePool(bitmapBuffer);
            return STATUS_INVALID_PARAMETER;
        }

        j = 0;
        for (;;) {
            if (l == &filter->VolumeList) {
                break;
            }
            j++;
            if (j == i) {
                break;
            }
            l = l->Blink;
        }

        if (j < i) {
            VspRelease(Extension->Root);
            break;
        }

        e = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        ObReferenceObject(e->DeviceObject);

        VspRelease(Extension->Root);

        status = VspComputeIgnorableBitmap(e, &bitmap);

        if (!NT_SUCCESS(status)) {
            VspAcquire(Extension->Root);
            if (e->IsDead) {
                VspRelease(Extension->Root);
                ObDereferenceObject(e->DeviceObject);
                ExFreePool(bitmapBuffer);
                return STATUS_SUCCESS;
            }
            VspRelease(Extension->Root);
            ObDereferenceObject(e->DeviceObject);
            ExFreePool(bitmapBuffer);
            return status;
        }

        ObDereferenceObject(e->DeviceObject);

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (Extension->IgnorableProduct) {
            VspAndBitmaps(Extension->IgnorableProduct, &bitmap);
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
    }

    ExFreePool(bitmapBuffer);

    return STATUS_SUCCESS;
}

VOID
VspQueryMinimumDiffAreaFileSize(
    IN  PDO_EXTENSION   RootExtension,
    OUT PLONGLONG       MinDiffAreaFileSize
    )

{
    ULONG                       zero, size;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"MinDiffAreaFileSize";
    queryTable[0].EntryContext = &size;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    RootExtension->RegistryPath.Buffer,
                                    queryTable, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        size = zero;
    }

    *MinDiffAreaFileSize = ((LONGLONG) size)*1024*1024;
}

NTSTATUS
VspCreateStartBlock(
    IN  PFILTER_EXTENSION   Filter,
    IN  LONGLONG            ControlBlockOffset,
    IN  LONGLONG            MaximumDiffAreaSpace
    )

/*++

Routine Description:

    This routine creates the start block in the NTFS boot code.

Arguments:

    Filter      - Supplies the filter extension.

Return Value:

    NTSTATUS

--*/

{
    PVOID                       buffer;
    KEVENT                      event;
    LARGE_INTEGER               byteOffset;
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;
    PVSP_BLOCK_START            startBlock;

    buffer = ExAllocatePoolWithTag(NonPagedPool, BYTES_IN_BOOT_AREA >
                                   PAGE_SIZE ? BYTES_IN_BOOT_AREA :
                                   PAGE_SIZE, VOLSNAP_TAG_BUFFER);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    byteOffset.QuadPart = 0;
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, Filter->TargetObject,
                                       buffer, BYTES_IN_BOOT_AREA,
                                       &byteOffset, &event, &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return status;
    }

    if (!VspIsNtfsBootSector(Filter, buffer)) {
        ExFreePool(buffer);
        return STATUS_SUCCESS;
    }

    startBlock = (PVSP_BLOCK_START) ((PCHAR) buffer +
                                     VSP_START_BLOCK_OFFSET);

    if (ControlBlockOffset || MaximumDiffAreaSpace) {
        startBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
        startBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
        startBlock->Header.BlockType = VSP_BLOCK_TYPE_START;
        startBlock->Header.ThisFileOffset = VSP_START_BLOCK_OFFSET;
        startBlock->Header.ThisVolumeOffset = VSP_START_BLOCK_OFFSET;
        startBlock->Header.NextVolumeOffset = 0;
        startBlock->FirstControlBlockVolumeOffset = ControlBlockOffset;
        startBlock->MaximumDiffAreaSpace = MaximumDiffAreaSpace;
    } else {
        RtlZeroMemory(startBlock, sizeof(VSP_BLOCK_START));
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    byteOffset.QuadPart = 0;
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_WRITE, Filter->TargetObject,
                                       buffer, BYTES_IN_BOOT_AREA,
                                       &byteOffset, &event, &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ExFreePool(buffer);

    return status;
}

VOID
VspCreateSnapshotOnDiskIrp(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PVOID   buffer;
    PMDL    mdl;

    ASSERT(!Filter->SnapshotOnDiskIrp);

    buffer = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE,
                                   VOLSNAP_TAG_BUFFER);
    if (!buffer) {
        return;
    }

    mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buffer);
        return;
    }
    MmBuildMdlForNonPagedPool(mdl);

    Filter->SnapshotOnDiskIrp = IoAllocateIrp(
                                (CCHAR) Filter->Root->StackSize, FALSE);
    if (!Filter->SnapshotOnDiskIrp) {
        IoFreeMdl(mdl);
        ExFreePool(buffer);
        return;
    }
    Filter->SnapshotOnDiskIrp->MdlAddress = mdl;
}

NTSTATUS
VspCreateInitialControlBlockFile(
    IN  PFILTER_EXTENSION   Filter
    )

/*++

Routine Description:

    This routine creates the initial control block file on the given filter.

Arguments:

    Filter      - Supplies the filter extension.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              fileName;
    PWCHAR                      star;
    OBJECT_ATTRIBUTES           oa;
    LARGE_INTEGER               fileSize;
    HANDLE                      h;
    IO_STATUS_BLOCK             ioStatus;
    LIST_ENTRY                  extentList;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PVSP_BLOCK_CONTROL          controlBlock;
    PVOLUME_EXTENSION           bitmapExtension;
    LONGLONG                    lastVolumeOffset;
    BOOLEAN                     isNtfs;
    PSECURITY_DESCRIPTOR        securityDescriptor;
    PACL                        acl;

    status = VspCreateDiffAreaFileName(Filter->TargetObject, NULL, &fileName,
                                       TRUE, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    star = fileName.Buffer + fileName.Length/sizeof(WCHAR) - 39;

    RtlMoveMemory(star, star + 1, 38*sizeof(WCHAR));
    fileName.Length -= sizeof(WCHAR);
    fileName.Buffer[fileName.Length/sizeof(WCHAR)] = 0;

    status = VspCreateSecurityDescriptor(&securityDescriptor, &acl);
    if (!NT_SUCCESS(status)) {
        ExFreePool(fileName.Buffer);
        return status;
    }

    InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, securityDescriptor);

    fileSize.QuadPart = LARGEST_NTFS_CLUSTER;
    ASSERT(LARGEST_NTFS_CLUSTER >= BLOCK_SIZE);

    KeWaitForSingleObject(&Filter->ControlBlockFileHandleReady, Executive,
                          KernelMode, FALSE, NULL);

    status = ZwCreateFile(&h, FILE_GENERIC_READ |
                          FILE_GENERIC_WRITE, &oa, &ioStatus,
                          &fileSize, FILE_ATTRIBUTE_HIDDEN |
                          FILE_ATTRIBUTE_SYSTEM, 0, FILE_OVERWRITE_IF,
                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT |
                          FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE |
                          FILE_NO_COMPRESSION, NULL, 0);
    ExFreePool(fileName.Buffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = VspSetFileSize(h, fileSize.QuadPart);
    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        return status;
    }

    status = VspIsNtfs(h, &isNtfs);
    if (!NT_SUCCESS(status) || !isNtfs) {
        ZwClose(h);
        return STATUS_INVALID_PARAMETER;
    }

    VspAcquire(Filter->Root);
    if (!IsListEmpty(&Filter->VolumeList)) {
        bitmapExtension = CONTAINING_RECORD(Filter->VolumeList.Blink,
                                            VOLUME_EXTENSION, ListEntry);
        ObReferenceObject(bitmapExtension->DeviceObject);
    } else {
        bitmapExtension = NULL;
    }
    VspRelease(Filter->Root);

    status = VspOptimizeDiffAreaFileLocation(Filter, h, bitmapExtension, 0,
                                             LARGEST_NTFS_CLUSTER);

    if (!NT_SUCCESS(status)) {
        if (bitmapExtension) {
            ObDereferenceObject(bitmapExtension->DeviceObject);
        }
        ZwClose(h);
        return status;
    }

    status = VspPinFile(Filter->TargetObject, h);
    if (!NT_SUCCESS(status)) {
        if (bitmapExtension) {
            ObDereferenceObject(bitmapExtension->DeviceObject);
        }
        ZwClose(h);
        return status;
    }

    status = VspQueryListOfExtents(h, 0, &extentList, bitmapExtension, FALSE);

    if (bitmapExtension) {
        ObDereferenceObject(bitmapExtension->DeviceObject);
    }

    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        return status;
    }

    for (l = extentList.Flink; l != &extentList; l = l->Flink) {
        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        if (diffAreaFileAllocation->NLength < 0) {
            ZwClose(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    if (!Filter->SnapshotOnDiskIrp) {
        VspCreateSnapshotOnDiskIrp(Filter);
        if (!Filter->SnapshotOnDiskIrp) {
            VspReleaseNonPagedResource(Filter);
            while (!IsListEmpty(&extentList)) {
                l = RemoveHeadList(&extentList);
                diffAreaFileAllocation = CONTAINING_RECORD(l,
                                         DIFF_AREA_FILE_ALLOCATION,
                                         ListEntry);
                ExFreePool(diffAreaFileAllocation);
            }
            ZwClose(h);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    controlBlock = (PVSP_BLOCK_CONTROL) MmGetMdlVirtualAddress(
                   Filter->SnapshotOnDiskIrp->MdlAddress);

    RtlZeroMemory(controlBlock, BLOCK_SIZE);
    controlBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
    controlBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
    controlBlock->Header.BlockType = VSP_BLOCK_TYPE_CONTROL;
    controlBlock->Header.ThisFileOffset = LARGEST_NTFS_CLUSTER;

    lastVolumeOffset = 0;
    l = extentList.Blink;
    while (l != &extentList) {

        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        if (!diffAreaFileAllocation->NLength) {
            l = l->Blink;
            continue;
        }

        diffAreaFileAllocation->NLength -= BLOCK_SIZE;
        controlBlock->Header.ThisFileOffset -= BLOCK_SIZE;
        controlBlock->Header.ThisVolumeOffset =
            diffAreaFileAllocation->Offset + diffAreaFileAllocation->NLength;
        controlBlock->Header.NextVolumeOffset = lastVolumeOffset;
        lastVolumeOffset = controlBlock->Header.ThisVolumeOffset;

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_WRITE,
                                  controlBlock->Header.ThisVolumeOffset, 0);

        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            while (!IsListEmpty(&extentList)) {
                l = RemoveHeadList(&extentList);
                diffAreaFileAllocation = CONTAINING_RECORD(l,
                                         DIFF_AREA_FILE_ALLOCATION,
                                         ListEntry);
                ExFreePool(diffAreaFileAllocation);
            }
            ZwClose(h);
            return status;
        }
    }

    VspReleaseNonPagedResource(Filter);

    diffAreaFileAllocation = CONTAINING_RECORD(extentList.Flink,
                                               DIFF_AREA_FILE_ALLOCATION,
                                               ListEntry);

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    status = VspCreateStartBlock(Filter, diffAreaFileAllocation->Offset,
                                 Filter->MaximumVolumeSpace);
    if (!NT_SUCCESS(status)) {
        VspReleaseNonPagedResource(Filter);
        while (!IsListEmpty(&extentList)) {
            l = RemoveHeadList(&extentList);
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }
        ZwClose(h);
        return status;
    }

    ASSERT(!Filter->ControlBlockFileHandle);

    Filter->FirstControlBlockVolumeOffset = diffAreaFileAllocation->Offset;

    VspReleaseNonPagedResource(Filter);

    InterlockedExchangePointer(&Filter->ControlBlockFileHandle, h);

    VspAcquire(Filter->Root);
    if (Filter->IsRemoved) {
        VspRelease(Filter->Root);
        h = InterlockedExchangePointer(&Filter->ControlBlockFileHandle,
                                       NULL);
        if (h) {
            ZwClose(h);
        }
    }
    VspRelease(Filter->Root);

    while (!IsListEmpty(&extentList)) {
        l = RemoveHeadList(&extentList);
        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        ExFreePool(diffAreaFileAllocation);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspAddControlBlocks(
    IN  PFILTER_EXTENSION   Filter,
    IN  LONGLONG            OffsetOfLastControlBlock
    )

/*++

Routine Description:

    This routine adds new control blocks to the control block list.

Arguments:

    Filter                      - Supplies the filter extension.

    OffsetOfLastControlBlock    - Supplies the offset of the last control
                                    block.

Return Value:

    NTSTATUS

--*/

{
    HANDLE                      handle;
    NTSTATUS                    status;
    LONGLONG                    fileSize;
    PVOLUME_EXTENSION           extension;
    LIST_ENTRY                  extentList;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;
    PVSP_BLOCK_CONTROL  controlBlock;

    handle = Filter->ControlBlockFileHandle;
    if (!handle) {
        return STATUS_INVALID_PARAMETER;
    }

    status = VspQueryFileSize(handle, &fileSize);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    ASSERT(fileSize);

    for (;;) {

        status = VspSetFileSize(handle, fileSize + LARGEST_NTFS_CLUSTER);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        VspAcquire(Filter->Root);
        if (IsListEmpty(&Filter->VolumeList)) {
            extension = NULL;
        } else {
            extension = CONTAINING_RECORD(Filter->VolumeList.Blink,
                                          VOLUME_EXTENSION, ListEntry);
            if (extension->IsDead) {
                extension = NULL;
            } else {
                ObReferenceObject(extension->DeviceObject);
            }
        }
        VspRelease(Filter->Root);

        VspOptimizeDiffAreaFileLocation(Filter, handle, extension, fileSize,
                                        fileSize + LARGEST_NTFS_CLUSTER);

        status = VspQueryListOfExtents(handle, fileSize, &extentList,
                                       extension, FALSE);
        if (extension) {
            ObDereferenceObject(extension->DeviceObject);
        }
        if (!NT_SUCCESS(status)) {
            return status;
        }

        for (l = extentList.Flink; l != &extentList; l = l->Flink) {
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            if (diffAreaFileAllocation->NLength > 0) {
                break;
            }
        }

        if (l != &extentList) {
            break;
        }

        while (!IsListEmpty(&extentList)) {
            l = RemoveHeadList(&extentList);
            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION,
                                     ListEntry);
            ExFreePool(diffAreaFileAllocation);
        }

        fileSize += LARGEST_NTFS_CLUSTER;
    }

    VspAcquireNonPagedResource(Filter, NULL, FALSE);
    if (!Filter->SnapshotOnDiskIrp) {
        VspReleaseNonPagedResource(Filter);
        return STATUS_INVALID_PARAMETER;
    }

    controlBlock = (PVSP_BLOCK_CONTROL) MmGetMdlVirtualAddress(
                   Filter->SnapshotOnDiskIrp->MdlAddress);

    l = extentList.Flink;
    while (l != &extentList) {

        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        if (diffAreaFileAllocation->NLength <= 0) {
            l = l->Flink;
            fileSize -= diffAreaFileAllocation->NLength;
            continue;
        }

        RtlZeroMemory(controlBlock, BLOCK_SIZE);
        controlBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
        controlBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
        controlBlock->Header.BlockType = VSP_BLOCK_TYPE_CONTROL;
        controlBlock->Header.ThisFileOffset = fileSize;
        controlBlock->Header.ThisVolumeOffset =
                diffAreaFileAllocation->Offset;
        controlBlock->Header.NextVolumeOffset = 0;

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_WRITE,
                                  controlBlock->Header.ThisVolumeOffset, 0);
        if (!NT_SUCCESS(status)) {
            break;
        }

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  OffsetOfLastControlBlock, 0);
        if (!NT_SUCCESS(status)) {
            break;
        }

        controlBlock->Header.NextVolumeOffset =
                diffAreaFileAllocation->Offset;

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_WRITE,
                                  controlBlock->Header.ThisVolumeOffset, 0);
        if (!NT_SUCCESS(status)) {
            break;
        }

        OffsetOfLastControlBlock = diffAreaFileAllocation->Offset;
        diffAreaFileAllocation->NLength -= BLOCK_SIZE;
        diffAreaFileAllocation->Offset += BLOCK_SIZE;
        fileSize += BLOCK_SIZE;
    }

    VspReleaseNonPagedResource(Filter);

    while (!IsListEmpty(&extentList)) {
        l = RemoveHeadList(&extentList);
        diffAreaFileAllocation = CONTAINING_RECORD(l,
                                                   DIFF_AREA_FILE_ALLOCATION,
                                                   ListEntry);
        ExFreePool(diffAreaFileAllocation);
    }

    return status;
}

NTSTATUS
VspAddControlItemInfoToLookupTable(
    IN  PFILTER_EXTENSION           Filter,
    IN  PVSP_CONTROL_ITEM_SNAPSHOT  ControlItem,
    IN  PBOOLEAN                    IsComplete
    )

{
    PVSP_CONTROL_ITEM_DIFF_AREA diffAreaControlItem;
    VSP_LOOKUP_TABLE_ENTRY      lookupEntryBuffer;
    PVSP_LOOKUP_TABLE_ENTRY     lookupEntry, le;
    PLIST_ENTRY                 l;

    if (IsComplete) {
        *IsComplete = FALSE;
    }

    if (ControlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_SNAPSHOT) {

        if (ControlItem->Reserved || ControlItem->VolumeSnapshotSize <= 0 ||
            ControlItem->SnapshotOrderNumber < 0 ||
            (ControlItem->SnapshotControlItemFlags&
             (~VSP_SNAPSHOT_CONTROL_ITEM_FLAG_ALL))) {

            return STATUS_INVALID_PARAMETER;
        }

    } else if (ControlItem->ControlItemType ==
               VSP_CONTROL_ITEM_TYPE_DIFF_AREA) {

        diffAreaControlItem = (PVSP_CONTROL_ITEM_DIFF_AREA) ControlItem;

        if (diffAreaControlItem->Reserved ||
            diffAreaControlItem->DiffAreaStartingVolumeOffset <= 0 ||
            (diffAreaControlItem->DiffAreaStartingVolumeOffset&
             (BLOCK_SIZE - 1)) ||
            diffAreaControlItem->ApplicationInfoStartingVolumeOffset <= 0 ||
            (diffAreaControlItem->ApplicationInfoStartingVolumeOffset&
             (BLOCK_SIZE - 1)) ||
            diffAreaControlItem->DiffAreaLocationDescriptionVolumeOffset <= 0 ||
            (diffAreaControlItem->DiffAreaLocationDescriptionVolumeOffset&
             (BLOCK_SIZE - 1)) ||
            diffAreaControlItem->InitialBitmapVolumeOffset < 0 ||
            (diffAreaControlItem->InitialBitmapVolumeOffset&(BLOCK_SIZE - 1))) {

            return STATUS_INVALID_PARAMETER;
        }

    } else {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(&lookupEntryBuffer, sizeof(lookupEntryBuffer));
    lookupEntryBuffer.SnapshotGuid = ControlItem->SnapshotGuid;
    KeWaitForSingleObject(&Filter->Root->LookupTableMutex, Executive,
                          KernelMode, FALSE, NULL);
    lookupEntry = (PVSP_LOOKUP_TABLE_ENTRY)
                  RtlLookupElementGenericTable(
                      &Filter->Root->PersistentSnapshotLookupTable,
                      &lookupEntryBuffer);
    if (!lookupEntry) {
        lookupEntry = (PVSP_LOOKUP_TABLE_ENTRY)
                      RtlInsertElementGenericTable(
                      &Filter->Root->PersistentSnapshotLookupTable,
                      &lookupEntryBuffer, sizeof(lookupEntryBuffer),
                      NULL);
        if (!lookupEntry) {
            KeReleaseMutex(&Filter->Root->LookupTableMutex, FALSE);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (ControlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_SNAPSHOT) {
        if (lookupEntry->SnapshotFilter) {
            KeReleaseMutex(&Filter->Root->LookupTableMutex, FALSE);
            return STATUS_UNSUCCESSFUL;
        }

        lookupEntry->SnapshotFilter = Filter;
        lookupEntry->VolumeSnapshotSize = ControlItem->VolumeSnapshotSize;
        lookupEntry->SnapshotOrderNumber = ControlItem->SnapshotOrderNumber;
        lookupEntry->SnapshotControlItemFlags =
                ControlItem->SnapshotControlItemFlags;
        lookupEntry->SnapshotTime = ControlItem->SnapshotTime;

        for (l = Filter->SnapshotLookupTableEntries.Flink;
             l != &Filter->SnapshotLookupTableEntries; l = l->Flink) {

            le = CONTAINING_RECORD(l, VSP_LOOKUP_TABLE_ENTRY,
                                   SnapshotFilterListEntry);

            if (le->SnapshotOrderNumber > lookupEntry->SnapshotOrderNumber) {
                break;
            }
        }

        InsertTailList(l, &lookupEntry->SnapshotFilterListEntry);

        if (lookupEntry->DiffAreaFilter && IsComplete) {
            *IsComplete = TRUE;
        }

    } else {

        ASSERT(ControlItem->ControlItemType ==
               VSP_CONTROL_ITEM_TYPE_DIFF_AREA);
        if (lookupEntry->DiffAreaFilter) {
            KeReleaseMutex(&Filter->Root->LookupTableMutex, FALSE);
            return STATUS_UNSUCCESSFUL;
        }
        lookupEntry->DiffAreaFilter = Filter;
        lookupEntry->DiffAreaStartingVolumeOffset =
                ((PVSP_CONTROL_ITEM_DIFF_AREA) ControlItem)->
                DiffAreaStartingVolumeOffset;
        lookupEntry->ApplicationInfoStartingVolumeOffset =
                ((PVSP_CONTROL_ITEM_DIFF_AREA) ControlItem)->
                ApplicationInfoStartingVolumeOffset;
        lookupEntry->DiffAreaLocationDescriptionVolumeOffset =
                ((PVSP_CONTROL_ITEM_DIFF_AREA) ControlItem)->
                DiffAreaLocationDescriptionVolumeOffset;
        lookupEntry->InitialBitmapVolumeOffset =
                ((PVSP_CONTROL_ITEM_DIFF_AREA) ControlItem)->
                InitialBitmapVolumeOffset;
        InsertTailList(&Filter->DiffAreaLookupTableEntries,
                       &lookupEntry->DiffAreaFilterListEntry);

        if (lookupEntry->SnapshotFilter && IsComplete) {
            *IsComplete = TRUE;
        }
    }

    KeReleaseMutex(&Filter->Root->LookupTableMutex, FALSE);

    return STATUS_SUCCESS;
}

VOID
VspRemoveControlItemInfoFromLookupTable(
    IN  PFILTER_EXTENSION           Filter,
    IN  PVSP_CONTROL_ITEM_SNAPSHOT  ControlItem
    )

{
    VSP_LOOKUP_TABLE_ENTRY  lookupEntryBuffer;
    PVSP_LOOKUP_TABLE_ENTRY lookupEntry;

    lookupEntryBuffer.SnapshotGuid = ControlItem->SnapshotGuid;
    KeWaitForSingleObject(&Filter->Root->LookupTableMutex, Executive,
                          KernelMode, FALSE, NULL);
    lookupEntry = (PVSP_LOOKUP_TABLE_ENTRY)
                  RtlLookupElementGenericTable(
                      &Filter->Root->PersistentSnapshotLookupTable,
                      &lookupEntryBuffer);
    if (!lookupEntry) {
        KeReleaseMutex(&Filter->Root->LookupTableMutex, FALSE);
        return;
    }

    if (ControlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_SNAPSHOT) {
        ASSERT(lookupEntry->SnapshotFilter == Filter);
        lookupEntry->SnapshotFilter = NULL;
        RemoveEntryList(&lookupEntry->SnapshotFilterListEntry);
    } else {
        ASSERT(ControlItem->ControlItemType ==
               VSP_CONTROL_ITEM_TYPE_DIFF_AREA);
        ASSERT(lookupEntry->DiffAreaFilter == Filter);
        lookupEntry->DiffAreaFilter = NULL;
        RemoveEntryList(&lookupEntry->DiffAreaFilterListEntry);
        if (lookupEntry->DiffAreaHandle) {
            ZwClose(lookupEntry->DiffAreaHandle);
            lookupEntry->DiffAreaHandle = NULL;
        }
    }

    if (!lookupEntry->SnapshotFilter && !lookupEntry->DiffAreaFilter) {
        ASSERT(!lookupEntry->DiffAreaHandle);
        RtlDeleteElementGenericTable(
                &Filter->Root->PersistentSnapshotLookupTable, lookupEntry);
    }

    KeReleaseMutex(&Filter->Root->LookupTableMutex, FALSE);
}

PVSP_LOOKUP_TABLE_ENTRY
VspFindLookupTableItem(
    IN  PDO_EXTENSION   RootExtension,
    IN  GUID*           SnapshotGuid
    )

{
    VSP_LOOKUP_TABLE_ENTRY  lookupEntryBuffer;
    PVSP_LOOKUP_TABLE_ENTRY lookupEntry;

    lookupEntryBuffer.SnapshotGuid = *SnapshotGuid;
    KeWaitForSingleObject(&RootExtension->LookupTableMutex, Executive,
                          KernelMode, FALSE, NULL);
    lookupEntry = (PVSP_LOOKUP_TABLE_ENTRY)
                  RtlLookupElementGenericTable(
                      &RootExtension->PersistentSnapshotLookupTable,
                      &lookupEntryBuffer);
    KeReleaseMutex(&RootExtension->LookupTableMutex, FALSE);

    return lookupEntry;
}

VOID
VspCloseHandlesWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->CloseHandles.Filter;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_CLOSE_HANDLES);

    if (context->CloseHandles.Handle1) {
        ZwClose(context->CloseHandles.Handle1);
    }

    if (context->CloseHandles.Handle2) {
        ZwClose(context->CloseHandles.Handle2);
    }

    KeSetEvent(&filter->ControlBlockFileHandleReady, IO_NO_INCREMENT, FALSE);
    VspFreeContext(filter->Root, context);
    ObDereferenceObject(filter->DeviceObject);
}

NTSTATUS
VspDeleteControlItemsWithGuid(
    IN  PFILTER_EXTENSION   Filter,
    IN  GUID*               SnapshotGuid,
    IN  BOOLEAN             NonPagedResourceHeld
    )

/*++

Routine Description:

    This routine adds a control item to the given master control block on
    the given filter.

Arguments:

    Filter      - Supplies the filter extension.

    ControlItem - Supplies the control item.

Return Value:

    NTSTATUS

--*/

{
    PVSP_BLOCK_CONTROL          controlBlock;
    LONGLONG                    byteOffset;
    NTSTATUS                    status;
    BOOLEAN                     needWrite, itemsLeft;
    ULONG                       offset;
    PVSP_CONTROL_ITEM_SNAPSHOT  controlItem;
    HANDLE                      h, hh;
    PVSP_CONTEXT                context;

    if (!NonPagedResourceHeld) {
        VspAcquireNonPagedResource(Filter, NULL, FALSE);
    }

    if (!Filter->FirstControlBlockVolumeOffset) {
        if (!NonPagedResourceHeld) {
            VspReleaseNonPagedResource(Filter);
        }
        return STATUS_SUCCESS;
    }

    ASSERT(Filter->SnapshotOnDiskIrp);

    controlBlock = (PVSP_BLOCK_CONTROL) MmGetMdlVirtualAddress(
                   Filter->SnapshotOnDiskIrp->MdlAddress);

    byteOffset = Filter->FirstControlBlockVolumeOffset;
    itemsLeft = FALSE;

    for (;;) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  byteOffset, 0);
        if (!NT_SUCCESS(status)) {
            if (!NonPagedResourceHeld) {
                VspReleaseNonPagedResource(Filter);
            }
            return status;
        }

        needWrite = FALSE;
        for (offset = VSP_BYTES_PER_CONTROL_ITEM; offset < BLOCK_SIZE;
             offset += VSP_BYTES_PER_CONTROL_ITEM) {

            controlItem = (PVSP_CONTROL_ITEM_SNAPSHOT)
                          ((PCHAR) controlBlock + offset);

            if (controlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_END) {
                break;
            }

            if (controlItem->ControlItemType > VSP_CONTROL_ITEM_TYPE_FREE) {
                if (SnapshotGuid) {
                    if (IsEqualGUID(controlItem->SnapshotGuid,
                                    *SnapshotGuid)) {

                        VspRemoveControlItemInfoFromLookupTable(
                                Filter, controlItem);

                        RtlZeroMemory(controlItem,
                                      VSP_BYTES_PER_CONTROL_ITEM);
                        controlItem->ControlItemType =
                                VSP_CONTROL_ITEM_TYPE_FREE;
                        needWrite = TRUE;
                    } else {
                        itemsLeft = TRUE;
                    }
                } else {
                    if (controlItem->ControlItemType ==
                        VSP_CONTROL_ITEM_TYPE_SNAPSHOT) {

                        VspRemoveControlItemInfoFromLookupTable(
                                Filter, controlItem);

                        RtlZeroMemory(controlItem,
                                      VSP_BYTES_PER_CONTROL_ITEM);
                        controlItem->ControlItemType =
                                VSP_CONTROL_ITEM_TYPE_FREE;
                        needWrite = TRUE;
                    } else {
                        itemsLeft = TRUE;
                    }
                }
            }
        }

        if (needWrite) {

            status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                      Filter->TargetObject, IRP_MJ_WRITE,
                                      byteOffset, 0);

            if (!NT_SUCCESS(status)) {
                if (!NonPagedResourceHeld) {
                    VspReleaseNonPagedResource(Filter);
                }
                return status;
            }
        }

        if (!controlBlock->Header.NextVolumeOffset) {
            break;
        }

        byteOffset = controlBlock->Header.NextVolumeOffset;
    }

    if (!itemsLeft) {
        if (NonPagedResourceHeld) {
            context = VspAllocateContext(Filter->Root);
            if (context) {
                h = InterlockedExchangePointer(&Filter->ControlBlockFileHandle,
                                               NULL);
                Filter->FirstControlBlockVolumeOffset = 0;
                VspCreateStartBlock(Filter, 0, Filter->MaximumVolumeSpace);
                hh = InterlockedExchangePointer(&Filter->BootStatHandle, NULL);
                if (!h && !hh) {
                    VspFreeContext(Filter->Root, context);
                }
            } else {
                h = NULL;
                hh = NULL;
            }
        } else {
            h = InterlockedExchangePointer(&Filter->ControlBlockFileHandle,
                                           NULL);
            Filter->FirstControlBlockVolumeOffset = 0;
            VspCreateStartBlock(Filter, 0, Filter->MaximumVolumeSpace);
            hh = InterlockedExchangePointer(&Filter->BootStatHandle, NULL);
        }
    } else {
        h = NULL;
        hh = NULL;
    }

    if (NonPagedResourceHeld) {
        if (h || hh) {
            ASSERT(context);
            context->Type = VSP_CONTEXT_TYPE_CLOSE_HANDLES;
            ExInitializeWorkItem(&context->WorkItem, VspCloseHandlesWorker,
                                 context);
            context->CloseHandles.Filter = Filter;
            context->CloseHandles.Handle1 = h;
            context->CloseHandles.Handle2 = hh;
            ObReferenceObject(Filter->DeviceObject);
            KeResetEvent(&Filter->ControlBlockFileHandleReady);
            ExQueueWorkItem(&context->WorkItem, CriticalWorkQueue);
        }
    } else {
        VspReleaseNonPagedResource(Filter);
        if (h) {
            ZwClose(h);
        }
        if (hh) {
            ZwClose(hh);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspIoControlItem(
    IN      PFILTER_EXTENSION   Filter,
    IN      ULONG               ControlItemType,
    IN      GUID*               SnapshotGuid,
    IN      BOOLEAN             IsSet,
    IN OUT  PVOID               ControlItem,
    IN      BOOLEAN             AcquireLock
    )

/*++

Routine Description:

    This routine returns the control item with the given control item type
    and snapshot guid.

Arguments:

    Filter          - Supplies the filter.

    ControlItemType - Supplies the control item type.

    SnapshotGuid    - Supplies the snapshot guid.

    ControlItem     - Returns the control item.

Return Value:

    NTSTATUS

--*/

{
    PVSP_BLOCK_CONTROL          controlBlock;
    LONGLONG                    byteOffset;
    NTSTATUS                    status;
    ULONG                       offset;
    PVSP_CONTROL_ITEM_SNAPSHOT  controlItem;
    PVSP_LOOKUP_TABLE_ENTRY     lookupEntry;
    PVSP_CONTROL_ITEM_DIFF_AREA daControlItem;

    if (AcquireLock) {
        VspAcquireNonPagedResource(Filter, NULL, FALSE);
    }

    if (!Filter->FirstControlBlockVolumeOffset) {
        if (AcquireLock) {
            VspReleaseNonPagedResource(Filter);
        }
        if (!IsSet) {
            return STATUS_UNSUCCESSFUL;
        }
        status = VspCreateInitialControlBlockFile(Filter);
        if (AcquireLock) {
            VspAcquireNonPagedResource(Filter, NULL, FALSE);
        }
        if (!Filter->FirstControlBlockVolumeOffset) {
            if (AcquireLock) {
                VspReleaseNonPagedResource(Filter);
            }
            if (NT_SUCCESS(status)) {
                status = STATUS_UNSUCCESSFUL;
            }
            return status;
        }
    }

    ASSERT(Filter->SnapshotOnDiskIrp);

    controlBlock = (PVSP_BLOCK_CONTROL) MmGetMdlVirtualAddress(
                   Filter->SnapshotOnDiskIrp->MdlAddress);

    byteOffset = Filter->FirstControlBlockVolumeOffset;

    for (;;) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  byteOffset, 0);

        if (!NT_SUCCESS(status)) {
            if (AcquireLock) {
                VspReleaseNonPagedResource(Filter);
            }
            return status;
        }

        for (offset = VSP_BYTES_PER_CONTROL_ITEM; offset < BLOCK_SIZE;
             offset += VSP_BYTES_PER_CONTROL_ITEM) {

            controlItem = (PVSP_CONTROL_ITEM_SNAPSHOT)
                          ((PCHAR) controlBlock + offset);

            if (ControlItemType == VSP_CONTROL_ITEM_TYPE_FREE) {
                if (controlItem->ControlItemType >
                    VSP_CONTROL_ITEM_TYPE_FREE) {

                    continue;
                }
            } else {
                if (controlItem->ControlItemType ==
                    VSP_CONTROL_ITEM_TYPE_END) {

                    break;
                }

                if (controlItem->ControlItemType != ControlItemType ||
                    !IsEqualGUID(controlItem->SnapshotGuid, *SnapshotGuid)) {

                    continue;
                }
            }

            if (!IsSet) {
                RtlCopyMemory(ControlItem, controlItem,
                              VSP_BYTES_PER_CONTROL_ITEM);

                if (AcquireLock) {
                    VspReleaseNonPagedResource(Filter);
                }
                return STATUS_SUCCESS;
            }

            RtlCopyMemory(controlItem, ControlItem,
                          VSP_BYTES_PER_CONTROL_ITEM);

            if (ControlItemType == VSP_CONTROL_ITEM_TYPE_FREE) {
                status = VspAddControlItemInfoToLookupTable(Filter,
                                                            controlItem,
                                                            NULL);
                if (!NT_SUCCESS(status)) {
                    if (AcquireLock) {
                        VspReleaseNonPagedResource(Filter);
                    }
                    return status;
                }
            } else if (ControlItemType == VSP_CONTROL_ITEM_TYPE_SNAPSHOT) {

                ASSERT(controlItem->ControlItemType == ControlItemType);

                lookupEntry = VspFindLookupTableItem(
                              Filter->Root, &controlItem->SnapshotGuid);
                ASSERT(lookupEntry);

                lookupEntry->VolumeSnapshotSize =
                        controlItem->VolumeSnapshotSize;
                lookupEntry->SnapshotOrderNumber =
                        controlItem->SnapshotOrderNumber;
                lookupEntry->SnapshotControlItemFlags =
                        controlItem->SnapshotControlItemFlags;
                lookupEntry->SnapshotTime = controlItem->SnapshotTime;
            } else {

                ASSERT(controlItem->ControlItemType == ControlItemType);
                lookupEntry = VspFindLookupTableItem(
                              Filter->Root, &controlItem->SnapshotGuid);
                ASSERT(lookupEntry);

                daControlItem = (PVSP_CONTROL_ITEM_DIFF_AREA) controlItem;
                lookupEntry->DiffAreaStartingVolumeOffset =
                        daControlItem->DiffAreaStartingVolumeOffset;
                lookupEntry->ApplicationInfoStartingVolumeOffset =
                        daControlItem->ApplicationInfoStartingVolumeOffset;
                lookupEntry->DiffAreaLocationDescriptionVolumeOffset =
                        daControlItem->DiffAreaLocationDescriptionVolumeOffset;
                lookupEntry->InitialBitmapVolumeOffset =
                        daControlItem->InitialBitmapVolumeOffset;
            }

            status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                      Filter->TargetObject, IRP_MJ_WRITE,
                                      byteOffset, 0);
            if (!NT_SUCCESS(status)) {
                VspRemoveControlItemInfoFromLookupTable(Filter, controlItem);
                if (AcquireLock) {
                    VspReleaseNonPagedResource(Filter);
                }
                return status;
            }

            if (AcquireLock) {
                VspReleaseNonPagedResource(Filter);
            }

            return STATUS_SUCCESS;
        }

        if (!controlBlock->Header.NextVolumeOffset) {
            if (ControlItemType == VSP_CONTROL_ITEM_TYPE_FREE) {
                if (AcquireLock) {
                    VspReleaseNonPagedResource(Filter);
                }

                status = VspAddControlBlocks(Filter, byteOffset);
                if (!NT_SUCCESS(status)) {
                    return status;
                }

                byteOffset = Filter->FirstControlBlockVolumeOffset;

                if (AcquireLock) {
                    VspAcquireNonPagedResource(Filter, NULL, FALSE);
                }
                continue;
            }
            break;
        }

        byteOffset = controlBlock->Header.NextVolumeOffset;
    }

    if (AcquireLock) {
        VspReleaseNonPagedResource(Filter);
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
VspAddControlItem(
    IN  PFILTER_EXTENSION   Filter,
    IN  PVOID               ControlItem,
    IN  BOOLEAN             AcquireLock
    )

/*++

Routine Description:

    This routine adds a control item to the given master control block on
    the given filter.

Arguments:

    Filter      - Supplies the filter extension.

    ControlItem - Supplies the control item.

Return Value:

    NTSTATUS

--*/

{
    GUID    zeroGuid;

    RtlZeroMemory(&zeroGuid, sizeof(zeroGuid));
    return VspIoControlItem(Filter, VSP_CONTROL_ITEM_TYPE_FREE, &zeroGuid,
                            TRUE, ControlItem, AcquireLock);
}

NTSTATUS
VspCleanupControlItemsForSnapshot(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine cleans up all of the control items associated with the
    given snapshot.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS            status;
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;

    status = VspDeleteControlItemsWithGuid(Extension->Filter,
                                           &Extension->SnapshotGuid, FALSE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (Extension->DiffAreaFile) {
        diffAreaFile = Extension->DiffAreaFile;

        status = VspDeleteControlItemsWithGuid(diffAreaFile->Filter,
                                               &Extension->SnapshotGuid,
                                               FALSE);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspLayDownOnDiskForSnapshot(
    IN  PVOLUME_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine lays down the on disk structure for the given snapshot,
    including the snapshot control item, diff area control items, and
    the initial diff area file blocks.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    UCHAR                                       controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT                  snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;
    PVSP_CONTROL_ITEM_DIFF_AREA                 diffAreaControlItem = (PVSP_CONTROL_ITEM_DIFF_AREA) controlItemBuffer;
    NTSTATUS                                    status;
    PVSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION   locationBlock;
    ULONG                                       totalNumEntries, numEntriesPerBlock, numBlocks, j;
    PLIST_ENTRY                                 l, ll;
    PVSP_DIFF_AREA_FILE                         diffAreaFile;
    PDIFF_AREA_FILE_ALLOCATION                  diffAreaFileAllocation;
    IO_STATUS_BLOCK                             ioStatus;
    KIRQL                                       irql;
    LONGLONG                                    targetOffset, fileOffset, fo;
    PLONGLONG                                   targetOffsetArray, fileOffsetArray;
    ULONG                                       blockOffset;
    PVSP_DIFF_AREA_LOCATION_DESCRIPTOR          locationDescriptor;
    PVSP_BLOCK_APP_INFO                         appInfoBlock;

    RtlZeroMemory(controlItemBuffer, VSP_BYTES_PER_CONTROL_ITEM);
    snapshotControlItem->ControlItemType = VSP_CONTROL_ITEM_TYPE_SNAPSHOT;
    snapshotControlItem->VolumeSnapshotSize = Extension->VolumeSize;
    snapshotControlItem->SnapshotGuid = Extension->SnapshotGuid;

    status = VspAddControlItem(Extension->Filter, snapshotControlItem, TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlZeroMemory(controlItemBuffer, VSP_BYTES_PER_CONTROL_ITEM);
    diffAreaControlItem->ControlItemType = VSP_CONTROL_ITEM_TYPE_DIFF_AREA;
    diffAreaControlItem->SnapshotGuid = Extension->SnapshotGuid;

    diffAreaFile = Extension->DiffAreaFile;
    ASSERT(diffAreaFile);

    totalNumEntries = 0;
    for (ll = diffAreaFile->UnusedAllocationList.Flink;
         ll != &diffAreaFile->UnusedAllocationList; ll = ll->Flink) {

        diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                 DIFF_AREA_FILE_ALLOCATION, ListEntry);
        if (diffAreaFileAllocation->NLength > 0) {
            totalNumEntries++;
        }
    }

    numEntriesPerBlock = (BLOCK_SIZE -
                          VSP_OFFSET_TO_FIRST_LOCATION_DESCRIPTOR)/
                         sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR);

    numBlocks = (totalNumEntries + numEntriesPerBlock - 1)/
                numEntriesPerBlock;
    numBlocks += 2;

    locationBlock = (PVSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION)
            MmGetMdlVirtualAddress(diffAreaFile->TableUpdateIrp->MdlAddress);

    targetOffsetArray = (PLONGLONG)
                        ExAllocatePoolWithTag(PagedPool,
                                              sizeof(LONGLONG)*numBlocks,
                                              VOLSNAP_TAG_SHORT_TERM);
    fileOffsetArray = (PLONGLONG)
                      ExAllocatePoolWithTag(PagedPool,
                                            sizeof(LONGLONG)*numBlocks,
                                            VOLSNAP_TAG_SHORT_TERM);
    if (!targetOffsetArray || !fileOffsetArray) {
        if (targetOffsetArray) {
            ExFreePool(targetOffsetArray);
        }
        if (fileOffsetArray) {
            ExFreePool(fileOffsetArray);
        }
        VspCleanupControlItemsForSnapshot(Extension);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (j = 0; j < numBlocks; j++) {
        status = VspAllocateDiffAreaSpace(Extension, &targetOffset,
                                          &fileOffset, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            ExFreePool(targetOffsetArray);
            ExFreePool(fileOffsetArray);
            VspCleanupControlItemsForSnapshot(Extension);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        targetOffsetArray[j] = targetOffset;
        fileOffsetArray[j] = fileOffset;
    }

    diffAreaFile->NextFreeTableEntryOffset = VSP_OFFSET_TO_FIRST_TABLE_ENTRY;
    diffAreaFile->ApplicationInfoTargetOffset = targetOffsetArray[0];
    diffAreaFile->FirstTableTargetOffset = targetOffsetArray[1];
    diffAreaFile->TableTargetOffset = targetOffsetArray[1];
    diffAreaFile->DiffAreaLocationDescriptionTargetOffset =
            targetOffsetArray[2];

    ll = diffAreaFile->UnusedAllocationList.Flink;
    fo = diffAreaFile->NextAvailable;

    for (j = 0; j < numBlocks; j++) {

        RtlZeroMemory(locationBlock, BLOCK_SIZE);
        locationBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
        locationBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
        locationBlock->Header.ThisFileOffset = fileOffsetArray[j];
        locationBlock->Header.ThisVolumeOffset = targetOffsetArray[j];

        if (j == 0) {
            locationBlock->Header.BlockType = VSP_BLOCK_TYPE_APP_INFO;
            if (Extension->ApplicationInformationSize) {
                appInfoBlock = (PVSP_BLOCK_APP_INFO) locationBlock;
                appInfoBlock->AppInfoSize =
                        Extension->ApplicationInformationSize;
                RtlCopyMemory((PCHAR) locationBlock + VSP_OFFSET_TO_APP_INFO,
                              Extension->ApplicationInformation,
                              Extension->ApplicationInformationSize);
            }
            status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                      diffAreaFile->Filter->TargetObject,
                                      IRP_MJ_WRITE,
                                      locationBlock->Header.ThisVolumeOffset,
                                      0);
            if (!NT_SUCCESS(status)) {
                ExFreePool(targetOffsetArray);
                ExFreePool(fileOffsetArray);
                VspCleanupControlItemsForSnapshot(Extension);
                return status;
            }
            continue;
        }

        if (j == 1) {
            locationBlock->Header.BlockType = VSP_BLOCK_TYPE_DIFF_AREA;
            status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                      diffAreaFile->Filter->TargetObject,
                                      IRP_MJ_WRITE,
                                      locationBlock->Header.ThisVolumeOffset,
                                      0);
            if (!NT_SUCCESS(status)) {
                ExFreePool(targetOffsetArray);
                ExFreePool(fileOffsetArray);
                VspCleanupControlItemsForSnapshot(Extension);
                return status;
            }
            continue;
        }

        locationBlock->Header.BlockType =
                VSP_BLOCK_TYPE_DIFF_AREA_LOCATION_DESCRIPTION;
        if (j + 1 < numBlocks) {
            locationBlock->Header.NextVolumeOffset =
                    targetOffsetArray[j + 1];
        }

        blockOffset = VSP_OFFSET_TO_FIRST_LOCATION_DESCRIPTOR;
        locationDescriptor = (PVSP_DIFF_AREA_LOCATION_DESCRIPTOR)
                             ((PCHAR) locationBlock + blockOffset);

        for (; ll != &diffAreaFile->UnusedAllocationList; ll = ll->Flink) {

            diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);
            if (diffAreaFileAllocation->NLength <= 0) {
                fo -= diffAreaFileAllocation->NLength;
                continue;
            }

            locationDescriptor->VolumeOffset = diffAreaFileAllocation->Offset;
            locationDescriptor->FileOffset = fo;
            locationDescriptor->Length = diffAreaFileAllocation->NLength;
            fo += locationDescriptor->Length;
            blockOffset += sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR);
            if (blockOffset + sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR) >
                BLOCK_SIZE) {

                ll = ll->Flink;
                break;
            }
            locationDescriptor = (PVSP_DIFF_AREA_LOCATION_DESCRIPTOR)
                                 ((PCHAR) locationBlock + blockOffset);
        }

        status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                  diffAreaFile->Filter->TargetObject,
                                  IRP_MJ_WRITE,
                                  locationBlock->Header.ThisVolumeOffset,
                                  0);
        if (!NT_SUCCESS(status)) {
            ExFreePool(targetOffsetArray);
            ExFreePool(fileOffsetArray);
            VspCleanupControlItemsForSnapshot(Extension);
            return status;
        }
    }

    ExFreePool(targetOffsetArray);
    ExFreePool(fileOffsetArray);

    status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                              diffAreaFile->Filter->TargetObject,
                              IRP_MJ_READ,
                              diffAreaFile->TableTargetOffset, 0);

    if (!NT_SUCCESS(status)) {
        VspCleanupControlItemsForSnapshot(Extension);
        return status;
    }

    diffAreaControlItem->DiffAreaStartingVolumeOffset =
            diffAreaFile->TableTargetOffset;
    diffAreaControlItem->ApplicationInfoStartingVolumeOffset =
            diffAreaFile->ApplicationInfoTargetOffset;
    diffAreaControlItem->DiffAreaLocationDescriptionVolumeOffset =
            diffAreaFile->DiffAreaLocationDescriptionTargetOffset;
    diffAreaControlItem->InitialBitmapVolumeOffset =
            diffAreaFile->InitialBitmapVolumeOffset;

    status = VspAddControlItem(diffAreaFile->Filter, diffAreaControlItem,
                               TRUE);
    if (!NT_SUCCESS(status)) {
        VspCleanupControlItemsForSnapshot(Extension);
        return status;
    }

    return STATUS_SUCCESS;
}

HANDLE
VspPinBootStat(
    IN  PFILTER_EXTENSION   Filter
    )

{
    UNICODE_STRING      name;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;

    RtlInitUnicodeString(&name, L"\\SystemRoot\\bootstat.dat");
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);
    status = ZwOpenFile(&h, SYNCHRONIZE, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        return NULL;
    }

    status = VspPinFile(Filter->TargetObject, h);
    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        return NULL;
    }

    return h;
}

BOOLEAN
VspQueryNoDiffAreaFill(
    IN  PDO_EXTENSION   RootExtension
    )

{
    ULONG                       zero, result;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"NoDiffAreaFill";
    queryTable[0].EntryContext = &result;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    RootExtension->RegistryPath.Buffer,
                                    queryTable, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        result = zero;
    }

    return result ? TRUE : FALSE;
}

VOID
VspPerformPreExposure(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    NTSTATUS        status;
    LARGE_INTEGER   timeout;

    VspAcquire(Extension->Root);
    if (Extension->Filter->IsRemoved) {
        VspRelease(Extension->Root);
        return;
    }
    IoInvalidateDeviceRelations(Extension->Filter->Pdo, BusRelations);
    VspRelease(Extension->Root);

    timeout.QuadPart = (LONGLONG) -10*1000*1000*120*10;   // 20 minutes.
    status = KeWaitForSingleObject(&Extension->PreExposureEvent, Executive,
                                   KernelMode, FALSE, &timeout);
    if (status == STATUS_TIMEOUT) {
        VspAcquire(Extension->Root);
        if (Extension->IsStarted) {
            Extension->IsInstalled = TRUE;
        }
        VspRelease(Extension->Root);
    }
}

ULONG
VspClaimNextDevnodeNumber(
    IN  PDO_EXTENSION   RootExtension
    )

{
    PULONG  p, c;
    ULONG   r;

    p = NULL;
    c = (PULONG)
        RtlEnumerateGenericTable(&RootExtension->UsedDevnodeNumbers, TRUE);
    while (c) {
        if (p) {
            if (*p + 1 < *c) {
                r = *p + 1;
                goto Finish;
            }
        } else {
            if (1 < *c) {
                r = 1;
                goto Finish;
            }
        }

        p = c;
        c = (PULONG)
        RtlEnumerateGenericTable(&RootExtension->UsedDevnodeNumbers, FALSE);
    }

    if (p) {
        r = *p + 1;
    } else {
        r = 1;
    }

Finish:

    if (!RtlInsertElementGenericTable(&RootExtension->UsedDevnodeNumbers, &r,
                                      sizeof(r), NULL)) {

        return 0;
    }

    return r;
}

VOID
VspPrepareForSnapshotWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )

{
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION       Filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIRP                    Irp = context->Dispatch.Irp;
    PDO_EXTENSION           rootExtension = Filter->Root;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_PREPARE_INFO   input = (PVOLSNAP_PREPARE_INFO) Irp->AssociatedIrp.SystemBuffer;
    BOOLEAN                 fallThrough = FALSE;
    BOOLEAN                 isInternal, isPersistent;
    PULONG                  pu;
    LONGLONG                minDiffAreaFileSize;
    KIRQL                   irql;
    ULONG                   volumeNumber;
    WCHAR                   buffer[100];
    UNICODE_STRING          volumeName;
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject;
    PVOLUME_EXTENSION       extension, e;
    ULONG                   bitmapSize, n;
    PVOID                   bitmapBuffer, p;
    PVOID                   buf;
    PMDL                    mdl;
    HANDLE                  h, hh;
    PLIST_ENTRY             l;
    PSECURITY_DESCRIPTOR    sd;
    BOOLEAN                 ma;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DISPATCH);

    InterlockedExchange(&rootExtension->VolumesSafeForWriteAccess, TRUE);

    KeWaitForSingleObject(&Filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    VspAcquireCritical(Filter);

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_PREPARE_INFO)) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength >=
        sizeof(VOLSNAP_PREPARE_INFO) + sizeof(ULONG)) {

        pu = (PULONG) (input + 1);
        if (*pu == 'NPK ') {
            isInternal = TRUE;
        } else {
            isInternal = FALSE;
        }
    } else {
        isInternal = FALSE;
    }

    if (input->Attributes&(~VOLSNAP_ALL_ATTRIBUTES)) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    if (input->Attributes&VOLSNAP_ATTRIBUTE_PERSISTENT) {
        isPersistent = TRUE;
    } else {
        isPersistent = FALSE;
    }

    KeWaitForSingleObject(&Filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    VspAcquire(Filter->Root);
    if (!Filter->DiffAreaVolume) {
        VspRelease(Filter->Root);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    if ((isPersistent && Filter->ProtectedBlocksBitmap) ||
        Filter->DiffAreaVolume->ProtectedBlocksBitmap) {

        VspRelease(Filter->Root);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto Finish;
    }

    if (Filter->SnapshotsPresent) {
        if (Filter->PersistentSnapshots) {
            isPersistent = TRUE;
        }
    }

    if (isPersistent && Filter->Pdo->Flags&DO_SYSTEM_BOOT_PARTITION &&
        !Filter->BootStatHandle) {

        VspRelease(Filter->Root);

        h = VspPinBootStat(Filter);

        VspAcquire(Filter->Root);
        if (h) {
            hh = InterlockedExchangePointer(&Filter->BootStatHandle, h);
            if (hh) {
                ZwClose(hh);
            }
        }
    }

    VspRelease(Filter->Root);

    VspQueryMinimumDiffAreaFileSize(Filter->Root, &minDiffAreaFileSize);

    if (input->InitialDiffAreaAllocation < 2*NOMINAL_DIFF_AREA_FILE_GROWTH) {
        input->InitialDiffAreaAllocation = 2*NOMINAL_DIFF_AREA_FILE_GROWTH;
    }

    if (input->InitialDiffAreaAllocation < minDiffAreaFileSize) {
        input->InitialDiffAreaAllocation = minDiffAreaFileSize;
    }

    volumeNumber = (ULONG)
                   InterlockedIncrement(&Filter->Root->NextVolumeNumber);
    swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d", volumeNumber);
    RtlInitUnicodeString(&volumeName, buffer);
    status = IoCreateDevice(rootExtension->DriverObject,
                            sizeof(VOLUME_EXTENSION), &volumeName,
                            FILE_DEVICE_VIRTUAL_DISK, 0, FALSE,
                            &deviceObject);

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    extension = (PVOLUME_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(VOLUME_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->Root = Filter->Root;
    extension->DeviceExtensionType = DEVICE_EXTENSION_VOLUME;
    KeInitializeSpinLock(&extension->SpinLock);
    extension->Filter = Filter;
    extension->RefCount = 1;
    InitializeListHead(&extension->WriteContextList);
    KeInitializeEvent(&extension->ZeroRefEvent, NotificationEvent, FALSE);
    extension->IsPersistent = isPersistent;
    extension->NoDiffAreaFill = VspQueryNoDiffAreaFill(extension->Root);
    if (isPersistent) {
        extension->OnDiskNotCommitted = TRUE;
    }

    extension->VolumeNumber = volumeNumber;
    status = ExUuidCreate(&extension->SnapshotGuid);
    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    RtlInitializeGenericTable(&extension->VolumeBlockTable,
                              VspTableCompareRoutine,
                              VspTableAllocateRoutine,
                              VspTableFreeRoutine, extension);

    RtlInitializeGenericTable(&extension->CopyBackPointerTable,
                              VspTableCompareRoutine,
                              VspTableAllocateRoutine,
                              VspTableFreeRoutine, extension);

    RtlInitializeGenericTable(&extension->TempVolumeBlockTable,
                              VspTableCompareRoutine,
                              VspTempTableAllocateRoutine,
                              VspTempTableFreeRoutine, extension);

    extension->DiffAreaFileIncrease = NOMINAL_DIFF_AREA_FILE_GROWTH;

    status = VspCreateInitialDiffAreaFile(extension,
                                          input->InitialDiffAreaAllocation);
    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    status = VspCreateWorkerThread(rootExtension);
    if (!NT_SUCCESS(status)) {
        VspLogError(extension, NULL, VS_CREATE_WORKER_THREADS_FAILED, status,
                    0, FALSE);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    extension->VolumeBlockBitmap = (PRTL_BITMAP)
                                   ExAllocatePoolWithTag(
                                   NonPagedPool, sizeof(RTL_BITMAP),
                                   VOLSNAP_TAG_BITMAP);
    if (!extension->VolumeBlockBitmap) {
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    extension->ApplicationInformationSize = 68;
    extension->ApplicationInformation =
            ExAllocatePoolWithTag(PagedPool,
                                  extension->ApplicationInformationSize,
                                  VOLSNAP_TAG_APP_INFO);
    if (!extension->ApplicationInformation) {
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    RtlZeroMemory(extension->ApplicationInformation,
                  extension->ApplicationInformationSize);
    RtlCopyMemory(extension->ApplicationInformation,
                  &VOLSNAP_APPINFO_GUID_SYSTEM_HIDDEN, sizeof(GUID));

    extension->VolumeSize = VspQueryVolumeSize(Filter);
    if (!extension->VolumeSize) {
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    bitmapSize = (ULONG) ((extension->VolumeSize + BLOCK_SIZE - 1)>>
                          BLOCK_SHIFT);
    bitmapBuffer = ExAllocatePoolWithTag(NonPagedPool,
                   (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);

    if (!bitmapBuffer) {
        VspLogError(extension, NULL, VS_CANT_ALLOCATE_BITMAP,
                    STATUS_INSUFFICIENT_RESOURCES, 1, FALSE);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    RtlInitializeBitMap(extension->VolumeBlockBitmap, (PULONG) bitmapBuffer,
                        bitmapSize);
    RtlClearAllBits(extension->VolumeBlockBitmap);

    status = VspCreateInitialHeap(extension, FALSE);
    if (!NT_SUCCESS(status)) {
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    InitializeListHead(&extension->OldHeaps);

    extension->EmergencyCopyIrp =
            IoAllocateIrp((CCHAR) extension->Root->StackSize, FALSE);
    if (!extension->EmergencyCopyIrp) {
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    buf = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE, VOLSNAP_TAG_BUFFER);
    if (!buf) {
        IoFreeIrp(extension->EmergencyCopyIrp);
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    mdl = IoAllocateMdl(buf, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buf);
        IoFreeIrp(extension->EmergencyCopyIrp);
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    MmBuildMdlForNonPagedPool(mdl);
    extension->EmergencyCopyIrp->MdlAddress = mdl;

    InitializeListHead(&extension->EmergencyCopyIrpQueue);
    InitializeListHead(&extension->WaitingForPageFileSpace);
    InitializeListHead(&extension->WaitingForDiffAreaSpace);

    VspAcquire(rootExtension);

    if (!IsListEmpty(&Filter->VolumeList)) {
        extension->IgnorableProduct = (PRTL_BITMAP)
                ExAllocatePoolWithTag(NonPagedPool, sizeof(RTL_BITMAP),
                                      VOLSNAP_TAG_BITMAP);
        if (!extension->IgnorableProduct) {
            VspRelease(rootExtension);
            ExFreePool(buf);
            IoFreeIrp(extension->EmergencyCopyIrp);
            IoFreeMdl(mdl);
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->DiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->NextDiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            ExFreePool(bitmapBuffer);
            ExFreePool(extension->VolumeBlockBitmap);
            extension->VolumeBlockBitmap = NULL;
            VspDeleteWorkerThread(rootExtension);
            VspDeleteInitialDiffAreaFile(extension);
            IoDeleteDevice(deviceObject);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Finish;
        }

        p = ExAllocatePoolWithTag(NonPagedPool,
                (bitmapSize + 8*sizeof(ULONG) - 1)/
                (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
        if (!p) {
            VspLogError(extension, NULL, VS_CANT_ALLOCATE_BITMAP,
                        STATUS_INSUFFICIENT_RESOURCES, 2, FALSE);
            ExFreePool(extension->IgnorableProduct);
            extension->IgnorableProduct = NULL;
            VspRelease(rootExtension);
            ExFreePool(buf);
            IoFreeMdl(mdl);
            IoFreeIrp(extension->EmergencyCopyIrp);
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->DiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                          extension->NextDiffAreaFileMap);
            ASSERT(NT_SUCCESS(status));
            ExFreePool(bitmapBuffer);
            ExFreePool(extension->VolumeBlockBitmap);
            extension->VolumeBlockBitmap = NULL;
            VspDeleteWorkerThread(rootExtension);
            VspDeleteInitialDiffAreaFile(extension);
            IoDeleteDevice(deviceObject);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Finish;
        }

        RtlInitializeBitMap(extension->IgnorableProduct, (PULONG) p,
                            bitmapSize);
        RtlSetAllBits(extension->IgnorableProduct);

        e = CONTAINING_RECORD(Filter->VolumeList.Blink, VOLUME_EXTENSION,
                              ListEntry);
        KeAcquireSpinLock(&e->SpinLock, &irql);
        if (e->VolumeBlockBitmap) {
            n = extension->IgnorableProduct->SizeOfBitMap;
            extension->IgnorableProduct->SizeOfBitMap =
                    e->VolumeBlockBitmap->SizeOfBitMap;
            VspAndBitmaps(extension->IgnorableProduct, e->VolumeBlockBitmap);
            extension->IgnorableProduct->SizeOfBitMap = n;
        }
        KeReleaseSpinLock(&e->SpinLock, irql);
    }

    status = VspSetDiffAreaBlocksInBitmap(extension);
    if (!NT_SUCCESS(status)) {
        if (extension->IgnorableProduct) {
            ExFreePool(extension->IgnorableProduct->Buffer);
            ExFreePool(extension->IgnorableProduct);
            extension->IgnorableProduct = NULL;
        }
        VspRelease(rootExtension);
        ExFreePool(buf);
        IoFreeMdl(mdl);
        IoFreeIrp(extension->EmergencyCopyIrp);
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    status = ObGetObjectSecurity(Filter->Pdo, &sd, &ma);
    if (NT_SUCCESS(status)) {
        status = ObSetSecurityObjectByPointer(deviceObject,
                                              DACL_SECURITY_INFORMATION, sd);
        ObReleaseObjectSecurity(sd, ma);
    }

    if (NT_SUCCESS(status)) {
        extension->DevnodeNumber =
                VspClaimNextDevnodeNumber(extension->Root);
        if (!extension->DevnodeNumber) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(status)) {
        if (extension->DiffAreaFile) {
            KeAcquireSpinLock(&extension->DiffAreaFile->Filter->SpinLock,
                              &irql);
            if (extension->DiffAreaFile->FilterListEntryBeingUsed) {
                RemoveEntryList(&extension->DiffAreaFile->FilterListEntry);
                extension->DiffAreaFile->FilterListEntryBeingUsed = FALSE;
            }
            KeReleaseSpinLock(&extension->DiffAreaFile->Filter->SpinLock,
                              irql);
        }
        if (extension->IgnorableProduct) {
            ExFreePool(extension->IgnorableProduct->Buffer);
            ExFreePool(extension->IgnorableProduct);
            extension->IgnorableProduct = NULL;
        }
        VspRelease(rootExtension);
        ExFreePool(buf);
        IoFreeMdl(mdl);
        IoFreeIrp(extension->EmergencyCopyIrp);
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                      extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        ExFreePool(bitmapBuffer);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspDeleteWorkerThread(rootExtension);
        VspDeleteInitialDiffAreaFile(extension);
        RtlDeleteElementGenericTable(&rootExtension->UsedDevnodeNumbers,
                                     &extension->DevnodeNumber);
        IoDeleteDevice(deviceObject);
        Irp->IoStatus.Status = status;
        goto Finish;
    }

    if (extension->IsPersistent) {

        VspRelease(rootExtension);

        status = VspLayDownOnDiskForSnapshot(extension);
        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_CANT_LAY_DOWN_ON_DISK, status, 0,
                        FALSE);
            VspAcquire(rootExtension);
            if (extension->DiffAreaFile) {
                KeAcquireSpinLock(&extension->DiffAreaFile->Filter->SpinLock,
                                  &irql);
                if (extension->DiffAreaFile->FilterListEntryBeingUsed) {
                    RemoveEntryList(&extension->DiffAreaFile->FilterListEntry);
                    extension->DiffAreaFile->FilterListEntryBeingUsed = FALSE;
                }
                KeReleaseSpinLock(&extension->DiffAreaFile->Filter->SpinLock,
                                  irql);
            }
            VspRelease(rootExtension);
            if (extension->IgnorableProduct) {
                ExFreePool(extension->IgnorableProduct->Buffer);
                ExFreePool(extension->IgnorableProduct);
                extension->IgnorableProduct = NULL;
            }
            ExFreePool(buf);
            IoFreeIrp(extension->EmergencyCopyIrp);
            ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                 extension->DiffAreaFileMap);
            ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                 extension->NextDiffAreaFileMap);
            ExFreePool(bitmapBuffer);
            ExFreePool(extension->VolumeBlockBitmap);
            extension->VolumeBlockBitmap = NULL;
            VspDeleteWorkerThread(rootExtension);
            VspDeleteInitialDiffAreaFile(extension);
            RtlDeleteElementGenericTable(&rootExtension->UsedDevnodeNumbers,
                                         &extension->DevnodeNumber);
            IoDeleteDevice(deviceObject);
            Irp->IoStatus.Status = status;
            goto Finish;
        }

        VspAcquire(rootExtension);
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    e = Filter->PreparedSnapshot;
    Filter->PreparedSnapshot = extension;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (!isInternal) {
        ObReferenceObject(extension->DeviceObject);
        extension->IsPreExposure = TRUE;
        KeInitializeEvent(&extension->PreExposureEvent, NotificationEvent,
                          FALSE);
    }

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->StackSize = (CCHAR) Filter->Root->StackSize + 1;
    deviceObject->AlignmentRequirement =
            extension->Filter->Pdo->AlignmentRequirement |
            extension->DiffAreaFile->Filter->Pdo->AlignmentRequirement;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    VspRelease(rootExtension);

    if (e) {
        VspCleanupInitialSnapshot(e, TRUE, FALSE);
    }

    fallThrough = TRUE;

Finish:
    VspReleaseCritical(Filter);

    if (fallThrough && !isInternal) {
        VspPerformPreExposure(extension);
        ObDereferenceObject(extension->DeviceObject);
    }

    IoFreeWorkItem(context->Dispatch.IoWorkItem);
    VspFreeContext(rootExtension, context);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
VspPrepareForSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine prepares a snapshot device object to be used later
    for a snapshot.  This phase is distict from commit snapshot because
    it can be called before IRPs are held.

    Besides creating the device object, this routine will also pre
    allocate some of the diff area.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PVSP_CONTEXT    context;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_DISPATCH;
    context->Dispatch.IoWorkItem = IoAllocateWorkItem(Filter->DeviceObject);
    if (!context->Dispatch.IoWorkItem) {
        VspFreeContext(Filter->Root, context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);
    context->Dispatch.Irp = Irp;

    IoQueueWorkItem(context->Dispatch.IoWorkItem,
                    VspPrepareForSnapshotWorker, DelayedWorkQueue, context);

    return STATUS_PENDING;
}

VOID
VspCleanupInitialMaps(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    NTSTATUS            status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                  extension->DiffAreaFileMap);
    ASSERT(NT_SUCCESS(status));
    status = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                  extension->NextDiffAreaFileMap);
    ASSERT(NT_SUCCESS(status));

    VspFreeContext(extension->Root, context);

    VspReleasePagedResource(extension);

    ObDereferenceObject(extension->DeviceObject);
}

VOID
VspCleanupInitialSnapshot(
    IN  PVOLUME_EXTENSION   Extension,
    IN  BOOLEAN             NeedLock,
    IN  BOOLEAN             IsFinalRemove
    )

{
    PVSP_CONTEXT    context;
    NTSTATUS        status;
    KIRQL           irql;

    if (Extension->IsPersistent) {
        VspCleanupControlItemsForSnapshot(Extension);
    }
    context = VspAllocateContext(Extension->Root);
    if (context) {
        context->Type = VSP_CONTEXT_TYPE_EXTENSION;
        context->Extension.Extension = Extension;
        context->Extension.Irp = NULL;
        ExInitializeWorkItem(&context->WorkItem, VspCleanupInitialMaps,
                             context);
        ObReferenceObject(Extension->DeviceObject);
        VspAcquirePagedResource(Extension, &context->WorkItem);
    } else {
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
        status = ZwUnmapViewOfSection(Extension->DiffAreaFileMapProcess,
                                      Extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status));
    }

    if (NeedLock) {
        VspAcquire(Extension->Root);
    }

    VspDeleteWorkerThread(Extension->Root);
    if (Extension->DiffAreaFile) {
        KeAcquireSpinLock(&Extension->DiffAreaFile->Filter->SpinLock, &irql);
        if (Extension->DiffAreaFile->FilterListEntryBeingUsed) {
            RemoveEntryList(&Extension->DiffAreaFile->FilterListEntry);
            Extension->DiffAreaFile->FilterListEntryBeingUsed = FALSE;
        }
        KeReleaseSpinLock(&Extension->DiffAreaFile->Filter->SpinLock, irql);

    }
    VspDeleteInitialDiffAreaFile(Extension);

    if (Extension->IsPreExposure) {
        KeSetEvent(&Extension->PreExposureEvent, IO_NO_INCREMENT, FALSE);
    }

    if (NeedLock) {
        VspRelease(Extension->Root);
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ExFreePool(Extension->VolumeBlockBitmap->Buffer);
    ExFreePool(Extension->VolumeBlockBitmap);
    Extension->VolumeBlockBitmap = NULL;
    if (Extension->IgnorableProduct) {
        ExFreePool(Extension->IgnorableProduct->Buffer);
        ExFreePool(Extension->IgnorableProduct);
        Extension->IgnorableProduct = NULL;
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    ExFreePool(MmGetMdlVirtualAddress(
               Extension->EmergencyCopyIrp->MdlAddress));
    IoFreeMdl(Extension->EmergencyCopyIrp->MdlAddress);
    IoFreeIrp(Extension->EmergencyCopyIrp);

    if (Extension->AliveToPnp) {
        InsertTailList(&Extension->Filter->DeadVolumeList,
                       &Extension->ListEntry);
        if (!IsFinalRemove) {
            IoInvalidateDeviceRelations(Extension->Filter->Pdo, BusRelations);
        }
    } else {
        if (NeedLock) {
            VspAcquire(Extension->Root);
        }
        RtlDeleteElementGenericTable(&Extension->Root->UsedDevnodeNumbers,
                                     &Extension->DevnodeNumber);
        if (NeedLock) {
            VspRelease(Extension->Root);
        }
        IoDeleteDevice(Extension->DeviceObject);
    }
}

NTSTATUS
VspMarkFreeSpaceInBitmap(
    IN  PVOLUME_EXTENSION   Extension,
    IN  HANDLE              UseThisHandle,
    IN  PRTL_BITMAP         BitmapToSet
    )

/*++

Routine Description:

    This routine opens the snapshot volume and marks off the free
    space in the NTFS bitmap as 'ignorable'.

Arguments:

    Extension   - Supplies the volume extension.

Return Value:

    NTSTATUS

--*/

{
    WCHAR                       buffer[100];
    KEVENT                      event;
    IO_STATUS_BLOCK             ioStatus;
    UNICODE_STRING              fileName;
    OBJECT_ATTRIBUTES           oa;
    NTSTATUS                    status;
    HANDLE                      h;
    LARGE_INTEGER               timeout;
    BOOLEAN                     isNtfs;
    FILE_FS_SIZE_INFORMATION    fsSize;
    ULONG                       bitmapSize;
    STARTING_LCN_INPUT_BUFFER   input;
    PVOLUME_BITMAP_BUFFER       output;
    RTL_BITMAP                  freeSpaceBitmap;
    ULONG                       bpc, f, numBits, startBit, s, n, i;
    KIRQL                       irql;
    ULONG                       r;

    if (UseThisHandle) {
        h = UseThisHandle;
    } else {

        swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
                 Extension->VolumeNumber);
        RtlInitUnicodeString(&fileName, buffer);

        InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE |
                                   OBJ_KERNEL_HANDLE, NULL, NULL);

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        timeout.QuadPart = -10*1000; // 1 millisecond.

        for (i = 0; i < 5000; i++) {
            status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                                FILE_SHARE_READ | FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                                FILE_SYNCHRONOUS_IO_NONALERT);
            if (NT_SUCCESS(status)) {
                break;
            }
            if (status != STATUS_NO_SUCH_DEVICE) {
                return status;
            }
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  &timeout);
        }

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    status = VspIsNtfs(h, &isNtfs);
    if (!NT_SUCCESS(status) || !isNtfs) {
        if (!UseThisHandle) {
            ZwClose(h);
        }
        return status;
    }

    status = ZwQueryVolumeInformationFile(h, &ioStatus, &fsSize,
                                          sizeof(fsSize),
                                          FileFsSizeInformation);
    if (!NT_SUCCESS(status)) {
        if (!UseThisHandle) {
            ZwClose(h);
        }
        return status;
    }

    bitmapSize = (ULONG) ((fsSize.TotalAllocationUnits.QuadPart+7)/8 +
                          FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer) + 3);
    input.StartingLcn.QuadPart = 0;

    output = (PVOLUME_BITMAP_BUFFER)
             ExAllocatePoolWithTag(PagedPool, bitmapSize, VOLSNAP_TAG_BITMAP);
    if (!output) {
        if (!UseThisHandle) {
            ZwClose(h);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwFsControlFile(h, NULL, NULL, NULL, &ioStatus,
                             FSCTL_GET_VOLUME_BITMAP, &input,
                             sizeof(input), output, bitmapSize);
    if (!UseThisHandle) {
        ZwClose(h);
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(output);
        return status;
    }

    ASSERT(output->BitmapSize.HighPart == 0);
    RtlInitializeBitMap(&freeSpaceBitmap, (PULONG) output->Buffer,
                        output->BitmapSize.LowPart);
    bpc = fsSize.BytesPerSector*fsSize.SectorsPerAllocationUnit;
    if (bpc < BLOCK_SIZE) {
        f = BLOCK_SIZE/bpc;
    } else {
        f = bpc/BLOCK_SIZE;
    }

    startBit = 0;
    for (;;) {

        if (startBit < freeSpaceBitmap.SizeOfBitMap) {
            numBits = RtlFindNextForwardRunClear(&freeSpaceBitmap, startBit,
                                                 &startBit);
        } else {
            numBits = 0;
        }
        if (!numBits) {
            break;
        }

        if (bpc == BLOCK_SIZE) {
            s = startBit;
            n = numBits;
        } else if (bpc < BLOCK_SIZE) {
            s = (startBit + f - 1)/f;
            r = startBit%f;
            if (r) {
                if (numBits > f - r) {
                    n = numBits - (f - r);
                } else {
                    n = 0;
                }
            } else {
                n = numBits;
            }
            n /= f;
        } else {
            s = startBit*f;
            n = numBits*f;
        }

        if (n) {
            if (BitmapToSet) {
                RtlSetBits(BitmapToSet, s, n);
            } else {
                KeAcquireSpinLock(&Extension->SpinLock, &irql);
                if (Extension->VolumeBlockBitmap) {
                    if (Extension->IgnorableProduct) {
                        for (i = 0; i < n; i++) {
                            if (RtlCheckBit(Extension->IgnorableProduct, i + s)) {
                                RtlSetBit(Extension->VolumeBlockBitmap, i + s);
                            }
                        }
                    } else {
                        RtlSetBits(Extension->VolumeBlockBitmap, s, n);
                    }
                }
                KeReleaseSpinLock(&Extension->SpinLock, irql);
            }
        }

        startBit += numBits;
    }

    ExFreePool(output);

    return STATUS_SUCCESS;
}

NTSTATUS
VspCommitSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine commits the prepared snapshot.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    KIRQL                   irql;
    PVOLUME_EXTENSION       extension, previousExtension;
    PLIST_ENTRY             l;
    PVSP_DIFF_AREA_FILE     diffAreaFile;

    InterlockedIncrement(&Filter->IgnoreCopyData);

    VspAcquire(Filter->Root);

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    extension = Filter->PreparedSnapshot;
    Filter->PreparedSnapshot = NULL;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (!extension) {
        VspRelease(Filter->Root);
        InterlockedDecrement(&Filter->IgnoreCopyData);
        return STATUS_INVALID_PARAMETER;
    }

    if (extension->DiffAreaFile->Filter->ProtectedBlocksBitmap) {
        VspRelease(Filter->Root);
        VspCleanupInitialSnapshot(extension, TRUE, FALSE);
        InterlockedDecrement(&Filter->IgnoreCopyData);
        return STATUS_INVALID_PARAMETER;
    }

    if (extension->IsPersistent &&
        extension->Filter->ProtectedBlocksBitmap) {

        VspRelease(Filter->Root);
        VspCleanupInitialSnapshot(extension, TRUE, FALSE);
        InterlockedDecrement(&Filter->IgnoreCopyData);
        return STATUS_INVALID_PARAMETER;
    }

    if (!Filter->HoldIncomingWrites) {
        VspRelease(Filter->Root);
        VspCleanupInitialSnapshot(extension, TRUE, FALSE);
        InterlockedDecrement(&Filter->IgnoreCopyData);
        return Filter->LastReleaseDueToMemoryPressure ?
               STATUS_INSUFFICIENT_RESOURCES : STATUS_INVALID_PARAMETER;
    }

    extension->IgnoreCopyDataReference = TRUE;

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    InterlockedExchange(&Filter->SnapshotsPresent, TRUE);
    if (extension->IsPersistent) {
        InterlockedExchange(&Filter->PersistentSnapshots, TRUE);
    } else {
        InterlockedExchange(&Filter->PersistentSnapshots, FALSE);
    }
    InsertTailList(&Filter->VolumeList, &extension->ListEntry);
    InterlockedIncrement(&Filter->EpicNumber);
    extension->IsPreExposure = FALSE;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    l = extension->ListEntry.Blink;
    if (l != &Filter->VolumeList) {
        previousExtension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        KeAcquireSpinLock(&previousExtension->SpinLock, &irql);
        ExFreePool(previousExtension->VolumeBlockBitmap->Buffer);
        ExFreePool(previousExtension->VolumeBlockBitmap);
        previousExtension->VolumeBlockBitmap = NULL;
        KeReleaseSpinLock(&previousExtension->SpinLock, irql);

        extension->SnapshotOrderNumber =
                previousExtension->SnapshotOrderNumber + 1;

    } else {
        extension->SnapshotOrderNumber = 1;
    }

    KeQuerySystemTime(&extension->CommitTimeStamp);

    if (Filter->UsedForCrashdump && extension->IsPersistent) {
        extension->ContainsCrashdumpFile = TRUE;
    }

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

VOID
VspCheckMaxSizeWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;
    ULONG               i, n;
    PLIST_ENTRY         l;
    KIRQL               irql;
    LIST_ENTRY          closeList, deleteList;
    PVOLUME_EXTENSION   extension;


    ASSERT(context->Type == VSP_CONTEXT_TYPE_FILTER);

    VspFreeContext(filter->Root, context);

    KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    VspAcquire(filter->Root);
    if (filter->IsRemoved) {
        VspRelease(filter->Root);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    i = 0;
    for (l = filter->VolumeList.Flink; l != &filter->VolumeList;
         l = l->Flink) {

        i++;
    }

    if (i > VSP_MAX_SNAPSHOTS) {
        n = i - VSP_MAX_SNAPSHOTS;
    } else {
        n = 0;
    }

    InitializeListHead(&closeList);
    InitializeListHead(&deleteList);

    for (i = 0; i < n; i++) {
        extension = CONTAINING_RECORD(filter->VolumeList.Flink,
                                      VOLUME_EXTENSION, ListEntry);
        VspLogError(extension, NULL, VS_DELETE_TO_MAX_NUMBER, STATUS_SUCCESS,
                    0, TRUE);
        VspDeleteOldestSnapshot(filter, &closeList, &deleteList, FALSE, FALSE);
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (!filter->MaximumVolumeSpace) {
        KeReleaseSpinLock(&filter->SpinLock, irql);
        VspRelease(filter->Root);
        VspCloseDiffAreaFiles(&closeList, &deleteList);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    while (filter->AllocatedVolumeSpace > filter->MaximumVolumeSpace) {
        KeReleaseSpinLock(&filter->SpinLock, irql);

        extension = CONTAINING_RECORD(filter->VolumeList.Flink,
                                      VOLUME_EXTENSION, ListEntry);

        VspLogError(extension, NULL, VS_DELETE_TO_TRIM_SPACE, STATUS_SUCCESS,
                    2, TRUE);

        VspDeleteOldestSnapshot(filter, &closeList, &deleteList, FALSE, FALSE);

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        if (!filter->MaximumVolumeSpace) {
            break;
        }
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    VspRelease(filter->Root);

    VspCloseDiffAreaFiles(&closeList, &deleteList);

    ObDereferenceObject(filter->DeviceObject);
}

VOID
VspCheckMaxSize(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PVSP_CONTEXT    context;

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return;
    }

    ObReferenceObject(Filter->DeviceObject);

    context->Type = VSP_CONTEXT_TYPE_FILTER;
    context->Filter.Filter = Filter;
    ExInitializeWorkItem(&context->WorkItem, VspCheckMaxSizeWorker,
                         context);
    VspQueueLowPriorityWorkItem(Filter->Root, &context->WorkItem);
}

NTSTATUS
VspEndCommitSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine commits the prepared snapshot.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    WCHAR               buffer[100];
    UNICODE_STRING      volumeName;
    PVOLSNAP_NAME       output;
    NTSTATUS            status;
    LARGE_INTEGER       timeout;
    PVSP_CONTEXT        context;

    VspAcquire(Filter->Root);

    l = Filter->VolumeList.Blink;
    if (l == &Filter->VolumeList) {
        VspRelease(Filter->Root);
        return STATUS_INVALID_PARAMETER;
    }

    extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

    if (extension->HasEndCommit) {
        VspRelease(Filter->Root);
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength) {
        status = VspSetApplicationInfo(extension, Irp);
        if (!NT_SUCCESS(status)) {
            if (extension->IgnoreCopyDataReference) {
                extension->IgnoreCopyDataReference = FALSE;
                InterlockedDecrement(&Filter->IgnoreCopyData);
            }
            VspRelease(Filter->Root);
            return status;
        }
    }

    swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
             extension->VolumeNumber);
    RtlInitUnicodeString(&volumeName, buffer);

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAME, Name) +
                                volumeName.Length + sizeof(WCHAR);
    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        if (extension->IgnoreCopyDataReference) {
            extension->IgnoreCopyDataReference = FALSE;
            InterlockedDecrement(&Filter->IgnoreCopyData);
        }
        VspRelease(Filter->Root);
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;
    output->NameLength = volumeName.Length;
    RtlCopyMemory(output->Name, volumeName.Buffer,
                  output->NameLength + sizeof(WCHAR));

    extension->HasEndCommit = TRUE;

    if (extension->IsPersistent) {
        VspAcquireNonPagedResource(extension, NULL, FALSE);
        status = VspCheckOnDiskNotCommitted(extension);
        VspReleaseNonPagedResource(extension);
    } else {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        VspTruncatePreviousDiffArea(extension);
    }

    if (!KeCancelTimer(&Filter->EndCommitTimer)) {
        ObReferenceObject(Filter->DeviceObject);
    }
    KeResetEvent(&Filter->EndCommitProcessCompleted);

    if (extension->IsInstalled) {

        context = VspAllocateContext(Filter->Root);
        if (!context) {
            InterlockedExchange(&Filter->HibernatePending, FALSE);
            KeSetEvent(&Filter->EndCommitProcessCompleted, IO_NO_INCREMENT,
                       FALSE);
            VspRelease(Filter->Root);
            ObDereferenceObject(Filter->DeviceObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ObReferenceObject(extension->DeviceObject);
        ObReferenceObject(Filter->TargetObject);

        VspRelease(Filter->Root);

        context->Type = VSP_CONTEXT_TYPE_EXTENSION;
        context->Extension.Extension = extension;
        context->Extension.Irp = NULL;
        ExInitializeWorkItem(&context->WorkItem,
                             VspSetIgnorableBlocksInBitmapWorker, context);
        VspQueueWorkItem(Filter->Root, &context->WorkItem, 0);

    } else {
        timeout.QuadPart = (LONGLONG) -10*1000*1000*120*10;   // 20 minutes.
        KeSetTimer(&Filter->EndCommitTimer, timeout,
                   &Filter->EndCommitTimerDpc);
        VspRelease(Filter->Root);
        IoInvalidateDeviceRelations(Filter->Pdo, BusRelations);
    }

    VspCheckMaxSize(Filter);

    return STATUS_SUCCESS;
}

NTSTATUS
VspVolumeRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

{
    PVOLUME_EXTENSION   extension = (PVOLUME_EXTENSION) Extension;

    VspDecrementVolumeRefCount(extension);
    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryNamesOfSnapshots(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the names of all of the snapshots for this filter.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAMES      output;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;
    WCHAR               buffer[100];
    UNICODE_STRING      name;
    PWCHAR              buf;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAMES, Names);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    KeWaitForSingleObject(&Filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    output = (PVOLSNAP_NAMES) Irp->AssociatedIrp.SystemBuffer;

    VspAcquire(Filter->Root);

    output->MultiSzLength = sizeof(WCHAR);

    for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, buffer);

        output->MultiSzLength += name.Length + sizeof(WCHAR);
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->MultiSzLength) {

        VspRelease(Filter->Root);
        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->MultiSzLength;
    buf = output->Names;

    for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        swprintf(buf, L"\\Device\\HarddiskVolumeShadowCopy%d",
                 extension->VolumeNumber);
        RtlInitUnicodeString(&name, buf);

        buf += name.Length/sizeof(WCHAR) + 1;
    }

    *buf = 0;

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspClearDiffArea(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine clears the list of diff areas used by this filter.  This
    call will fail if there are any snapshots in flight.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    VspAcquire(Filter->Root);
    Filter->DiffAreaVolume = NULL;
    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspAddVolumeToDiffArea(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine adds the given volume to the diff area for this volume.
    All snapshots get a new diff area file.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAME       input;
    UNICODE_STRING      volumeName;
    PFILTER_EXTENSION   filter;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_NAME)) {

        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_INVALID_PARAMETER, 3, FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    input = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        (ULONG) FIELD_OFFSET(VOLSNAP_NAME, Name) + input->NameLength) {

        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_INVALID_PARAMETER, 4, FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    volumeName.Length = volumeName.MaximumLength = input->NameLength;
    volumeName.Buffer = input->Name;

    VspAcquire(Filter->Root);

    filter = VspFindFilter(Filter->Root, Filter, &volumeName, NULL);
    if (!filter ||
        (filter->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA)) {

        VspRelease(Filter->Root);
        return STATUS_INVALID_PARAMETER;
    }

    if (Filter->DiffAreaVolume) {
        VspRelease(Filter->Root);

        VspLogError(NULL, Filter, VS_FAILURE_ADDING_DIFF_AREA,
                    STATUS_INVALID_PARAMETER, 5, FALSE);

        return STATUS_INVALID_PARAMETER;
    }

    Filter->DiffAreaVolume = filter;

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryDiffArea(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine the list of volumes that make up the diff area for this
    volume.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION       Filter = (PFILTER_EXTENSION) DeviceExtension;
    PVOLUME_EXTENSION       extension = (PVOLUME_EXTENSION) DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAMES          output;
    PLIST_ENTRY             l;
    PFILTER_EXTENSION       filter;
    KEVENT                  event;
    PMOUNTDEV_NAME          name;
    CHAR                    buffer[512];
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
    PWCHAR                  buf;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAMES, Names);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output = (PVOLSNAP_NAMES) Irp->AssociatedIrp.SystemBuffer;

    VspAcquire(Filter->Root);

    output->MultiSzLength = sizeof(WCHAR);

    if (Filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        filter = Filter->DiffAreaVolume;
    } else {
        ASSERT(extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);
        if (extension->DiffAreaFile) {
            filter = extension->DiffAreaFile->Filter;
        } else {
            filter = NULL;
        }
    }

    if (filter) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        name = (PMOUNTDEV_NAME) buffer;
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                            filter->TargetObject, NULL, 0,
                                            name, 500, FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(filter->TargetObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return status;
        }

        output->MultiSzLength += name->NameLength + sizeof(WCHAR);
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->MultiSzLength) {

        VspRelease(Filter->Root);
        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->MultiSzLength;
    buf = output->Names;

    if (Filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        filter = Filter->DiffAreaVolume;
    } else {
        ASSERT(extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);
        if (extension->DiffAreaFile) {
            filter = extension->DiffAreaFile->Filter;
        } else {
            filter = NULL;
        }
    }

    if (filter) {
        KeInitializeEvent(&event, NotificationEvent, FALSE);

        name = (PMOUNTDEV_NAME) buffer;
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                            filter->TargetObject, NULL, 0,
                                            name, 500, FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(filter->TargetObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS(status)) {
            VspRelease(Filter->Root);
            Irp->IoStatus.Information = 0;
            return status;
        }

        RtlCopyMemory(buf, name->Name, name->NameLength);
        buf += name->NameLength/sizeof(WCHAR);

        *buf++ = 0;
    }

    *buf = 0;

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryDiffAreaSizes(
    IN  PDEVICE_EXTENSION   DeviceExtension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the diff area sizes for this volume.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION           filter = (PFILTER_EXTENSION) DeviceExtension;
    PVOLUME_EXTENSION           extension = (PVOLUME_EXTENSION) DeviceExtension;
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_DIFF_AREA_SIZES    output = (PVOLSNAP_DIFF_AREA_SIZES) Irp->AssociatedIrp.SystemBuffer;
    KIRQL                       irql;

    Irp->IoStatus.Information = sizeof(VOLSNAP_DIFF_AREA_SIZES);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        output->UsedVolumeSpace = filter->UsedVolumeSpace;
        output->AllocatedVolumeSpace = filter->AllocatedVolumeSpace;
        output->MaximumVolumeSpace = filter->MaximumVolumeSpace;
        KeReleaseSpinLock(&filter->SpinLock, irql);
        return STATUS_SUCCESS;
    }

    ASSERT(extension->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    RtlZeroMemory(output, sizeof(VOLSNAP_DIFF_AREA_SIZES));

    VspAcquireNonPagedResource(extension, NULL, FALSE);
    if (extension->DiffAreaFile) {
        output->UsedVolumeSpace = extension->DiffAreaFile->NextAvailable;
        output->AllocatedVolumeSpace =
                extension->DiffAreaFile->AllocatedFileSize;
    }
    VspReleaseNonPagedResource(extension);

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryOriginalVolumeName(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the original volume name for the given volume
    snapshot.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_NAME       output = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;
    PMOUNTDEV_NAME      name;
    CHAR                buffer[512];
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_NAME, Name);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    name = (PMOUNTDEV_NAME) buffer;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        filter->TargetObject, NULL, 0,
                                        name, 500, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        Irp->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        return status;
    }

    output->NameLength = name->NameLength;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->NameLength) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->Name, name->Name, output->NameLength);

    Irp->IoStatus.Information += output->NameLength;

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryConfigInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the configuration information for this volume
    snapshot.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_CONFIG_INFO    output = (PVOLSNAP_CONFIG_INFO) Irp->AssociatedIrp.SystemBuffer;

    Irp->IoStatus.Information = sizeof(ULONG);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output->Attributes = 0;
    if (Extension->IsPersistent) {
        output->Attributes |= VOLSNAP_ATTRIBUTE_PERSISTENT;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >=
        sizeof(VOLSNAP_CONFIG_INFO)) {

        Irp->IoStatus.Information = sizeof(VOLSNAP_CONFIG_INFO);

        output->Reserved = 0;
        output->SnapshotCreationTime = Extension->CommitTimeStamp;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspWriteApplicationInfo(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    LONGLONG                            targetOffset, fileOffset;
    NTSTATUS                            status;
    PVSP_BLOCK_APP_INFO                 appInfoBlock;

    VspAcquireNonPagedResource(Extension, NULL, FALSE);

    targetOffset = Extension->DiffAreaFile->ApplicationInfoTargetOffset;
    ASSERT(targetOffset);

    status = VspSynchronousIo(Extension->Filter->SnapshotOnDiskIrp,
                              Extension->DiffAreaFile->Filter->TargetObject,
                              IRP_MJ_READ, targetOffset, 0);
    if (!NT_SUCCESS(status)) {
        VspReleaseNonPagedResource(Extension);
        return status;
    }

    appInfoBlock = (PVSP_BLOCK_APP_INFO)
            MmGetMdlVirtualAddress(Extension->Filter->SnapshotOnDiskIrp->
                                   MdlAddress);
    if (appInfoBlock->Header.Signature != VSP_DIFF_AREA_FILE_GUID ||
        appInfoBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
        appInfoBlock->Header.BlockType != VSP_BLOCK_TYPE_APP_INFO ||
        appInfoBlock->Header.ThisVolumeOffset != targetOffset ||
        appInfoBlock->Header.NextVolumeOffset) {

        VspReleaseNonPagedResource(Extension);
        return STATUS_INVALID_PARAMETER;
    }

    appInfoBlock->AppInfoSize = Extension->ApplicationInformationSize;

    RtlCopyMemory((PCHAR) appInfoBlock + VSP_OFFSET_TO_APP_INFO,
                  Extension->ApplicationInformation,
                  Extension->ApplicationInformationSize);

    status = VspSynchronousIo(Extension->Filter->SnapshotOnDiskIrp,
                              Extension->DiffAreaFile->Filter->TargetObject,
                              IRP_MJ_WRITE, targetOffset, 0);
    if (!NT_SUCCESS(status)) {
        VspReleaseNonPagedResource(Extension);
        return status;
    }

    VspReleaseNonPagedResource(Extension);

    return STATUS_SUCCESS;
}

NTSTATUS
VspSetApplicationInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine sets the application info.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_APPLICATION_INFO   input = (PVOLSNAP_APPLICATION_INFO) Irp->AssociatedIrp.SystemBuffer;
    PVOID                       newAppInfo, oldAppInfo;
    NTSTATUS                    status;

    Irp->IoStatus.Information = 0;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_APPLICATION_INFO)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->InformationLength > VSP_MAX_APP_INFO_SIZE) {
        return STATUS_INVALID_PARAMETER;
    }

    if (input->InformationLength < sizeof(GUID)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        (LONGLONG) FIELD_OFFSET(VOLSNAP_APPLICATION_INFO, Information) +
        input->InformationLength) {

        return STATUS_INVALID_PARAMETER;
    }

    newAppInfo = ExAllocatePoolWithQuotaTag((POOL_TYPE) (NonPagedPool |
                 POOL_QUOTA_FAIL_INSTEAD_OF_RAISE),
                 input->InformationLength, VOLSNAP_TAG_APP_INFO);
    if (!newAppInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(newAppInfo, input->Information, input->InformationLength);

    KeEnterCriticalRegion();
    VspAcquirePagedResource(Extension, NULL);

    Extension->ApplicationInformationSize = input->InformationLength;
    oldAppInfo = Extension->ApplicationInformation;
    Extension->ApplicationInformation = newAppInfo;

    VspReleasePagedResource(Extension);
    KeLeaveCriticalRegion();

    InterlockedIncrement(&Extension->Filter->EpicNumber);

    if (oldAppInfo) {
        ExFreePool(oldAppInfo);
    }

    if (Extension->IsPersistent) {
        status = VspWriteApplicationInfo(Extension);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryApplicationInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine queries the application info.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_APPLICATION_INFO   output = (PVOLSNAP_APPLICATION_INFO) Irp->AssociatedIrp.SystemBuffer;
    PVOID                       appInfo;

    Irp->IoStatus.Information = FIELD_OFFSET(VOLSNAP_APPLICATION_INFO,
                                             Information);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    KeEnterCriticalRegion();
    VspAcquirePagedResource(Extension, NULL);

    output->InformationLength = Extension->ApplicationInformationSize;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information + output->InformationLength) {

        VspReleasePagedResource(Extension);
        KeLeaveCriticalRegion();
        return STATUS_BUFFER_OVERFLOW;
    }

    Irp->IoStatus.Information += output->InformationLength;

    RtlCopyMemory(output->Information, Extension->ApplicationInformation,
                  output->InformationLength);

    VspReleasePagedResource(Extension);
    KeLeaveCriticalRegion();

    return STATUS_SUCCESS;
}

NTSTATUS
VspCheckSecurity(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    SECURITY_SUBJECT_CONTEXT    securityContext;
    BOOLEAN                     accessGranted;
    NTSTATUS                    status;
    ACCESS_MASK                 grantedAccess;

    SeCaptureSubjectContext(&securityContext);
    SeLockSubjectContext(&securityContext);

    accessGranted = FALSE;
    status = STATUS_ACCESS_DENIED;

    _try {

        accessGranted = SeAccessCheck(
                        Filter->Pdo->SecurityDescriptor,
                        &securityContext, TRUE, FILE_READ_DATA, 0, NULL,
                        IoGetFileObjectGenericMapping(), Irp->RequestorMode,
                        &grantedAccess, &status);

    } _finally {
        SeUnlockSubjectContext(&securityContext);
        SeReleaseSubjectContext(&securityContext);
    }

    if (!accessGranted) {
        return status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspAutoCleanup(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine remembers the given File Object so that when it is
    cleaned up, all snapshots will be cleaned up with it.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    KIRQL               irql;

    IoAcquireCancelSpinLock(&irql);
    if (Filter->AutoCleanupFileObject) {
        IoReleaseCancelSpinLock(irql);
        return STATUS_INVALID_PARAMETER;
    }
    Filter->AutoCleanupFileObject = irpSp->FileObject;
    IoReleaseCancelSpinLock(irql);

    return STATUS_SUCCESS;
}

VOID
VspDeleteSnapshotWorker(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PVOID           Context
    )

{
    PFILTER_EXTENSION       filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PVSP_CONTEXT            context = (PVSP_CONTEXT) Context;
    PIRP                    irp = context->Dispatch.Irp;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(irp);
    PVOLUME_EXTENSION       oldestExtension;
    PVOLSNAP_NAME           name;
    WCHAR                   buffer[100];
    UNICODE_STRING          name1, name2;
    LIST_ENTRY              listOfDiffAreaFileToClose;
    LIST_ENTRY              listOfDeviceObjectsToDelete;
    NTSTATUS                status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DISPATCH);

    KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    InitializeListHead(&listOfDiffAreaFileToClose);
    InitializeListHead(&listOfDeviceObjectsToDelete);

    VspAcquire(filter->Root);

    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_VOLSNAP_DELETE_SNAPSHOT) {

        if (IsListEmpty(&filter->VolumeList)) {
            status = STATUS_INVALID_PARAMETER;
        } else {

            oldestExtension = CONTAINING_RECORD(filter->VolumeList.Flink,
                                                VOLUME_EXTENSION, ListEntry);
            swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
                     oldestExtension->VolumeNumber);
            RtlInitUnicodeString(&name1, buffer);

            name = (PVOLSNAP_NAME) irp->AssociatedIrp.SystemBuffer;

            name2.Length = name2.MaximumLength = name->NameLength;
            name2.Buffer = name->Name;

            if (RtlEqualUnicodeString(&name1, &name2, TRUE)) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NOT_SUPPORTED;
            }
        }
    } else {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        status = VspDeleteOldestSnapshot(filter, &listOfDiffAreaFileToClose,
                                         &listOfDeviceObjectsToDelete,
                                         FALSE, FALSE);
    }

    VspRelease(filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFileToClose,
                          &listOfDeviceObjectsToDelete);

    IoFreeWorkItem(context->Dispatch.IoWorkItem);
    VspFreeContext(filter->Root, context);

    irp->IoStatus.Status = status;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

NTSTATUS
VspDeleteSnapshotPost(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVSP_CONTEXT        context;
    PVOLSNAP_NAME       name;

    Irp->IoStatus.Information = 0;

    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_VOLSNAP_DELETE_SNAPSHOT) {

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(VOLSNAP_NAME)) {

            return STATUS_INVALID_PARAMETER;
        }

        name = (PVOLSNAP_NAME) Irp->AssociatedIrp.SystemBuffer;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            (ULONG) FIELD_OFFSET(VOLSNAP_NAME, Name) + name->NameLength) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_DISPATCH;
    context->Dispatch.IoWorkItem = IoAllocateWorkItem(Filter->DeviceObject);
    if (!context->Dispatch.IoWorkItem) {
        VspFreeContext(Filter->Root, context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);
    context->Dispatch.Irp = Irp;

    IoQueueWorkItem(context->Dispatch.IoWorkItem,
                    VspDeleteSnapshotWorker, DelayedWorkQueue, context);

    return STATUS_PENDING;
}

VOID
VspCheckCodeLocked(
    IN  PDO_EXTENSION   RootExtension,
    IN  BOOLEAN         CallerHoldingSemaphore
    )

{
    if (RootExtension->IsCodeLocked) {
        return;
    }

    if (!CallerHoldingSemaphore) {
        VspAcquire(RootExtension);
    }

    if (RootExtension->IsCodeLocked) {
        if (!CallerHoldingSemaphore) {
            VspRelease(RootExtension);
        }
        return;
    }

    MmLockPagableCodeSection(VspCheckCodeLocked);
    InterlockedExchange(&RootExtension->IsCodeLocked, TRUE);

    if (!CallerHoldingSemaphore) {
        VspRelease(RootExtension);
    }
}

NTSTATUS
VspSetMaxDiffAreaSize(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_DIFF_AREA_SIZES    input = (PVOLSNAP_DIFF_AREA_SIZES) Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                    status;
    KIRQL                       irql;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLSNAP_DIFF_AREA_SIZES)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->MaximumVolumeSpace < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    status = VspCreateStartBlock(Filter,
                                 Filter->FirstControlBlockVolumeOffset,
                                 input->MaximumVolumeSpace);
    if (!NT_SUCCESS(status)) {
        VspReleaseNonPagedResource(Filter);
        return status;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    Filter->MaximumVolumeSpace = input->MaximumVolumeSpace;
    InterlockedIncrement(&Filter->EpicNumber);
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    VspReleaseNonPagedResource(Filter);

    VspCheckMaxSize(Filter);

    return STATUS_SUCCESS;
}

BOOLEAN
VspIsNtfsBootSector(
    IN  PFILTER_EXTENSION   Filter,
    IN  PVOID               BootSector
    )

{
    PUCHAR              p = (PUCHAR) BootSector;
    LONGLONG            numSectors;

    if (p[3] != 'N' || p[4] != 'T' || p[5] != 'F' || p[6] != 'S' &&
        p[510] != 0x55 || p[511] != 0xAA) {

        return FALSE;
    }

    numSectors = *((PLONGLONG) (p + 0x28));

    if (numSectors > VspQueryVolumeSize(Filter)) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
VspReadApplicationInfo(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

{
    PVOLUME_EXTENSION   extension = DiffAreaFile->Extension;
    LONGLONG            targetOffset;
    NTSTATUS            status;
    PVSP_BLOCK_APP_INFO appInfoBlock;

    targetOffset = DiffAreaFile->ApplicationInfoTargetOffset;
    if (!targetOffset) {
        return STATUS_SUCCESS;
    }

    status = VspSynchronousIo(DiffAreaFile->TableUpdateIrp,
                              DiffAreaFile->Filter->TargetObject,
                              IRP_MJ_READ, targetOffset, 0);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    appInfoBlock = (PVSP_BLOCK_APP_INFO)
            MmGetMdlVirtualAddress(DiffAreaFile->TableUpdateIrp->MdlAddress);
    if (!IsEqualGUID(appInfoBlock->Header.Signature,
                     VSP_DIFF_AREA_FILE_GUID) ||
        appInfoBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
        appInfoBlock->Header.BlockType != VSP_BLOCK_TYPE_APP_INFO ||
        appInfoBlock->Header.ThisVolumeOffset != targetOffset ||
        appInfoBlock->Header.NextVolumeOffset ||
        appInfoBlock->AppInfoSize > VSP_MAX_APP_INFO_SIZE) {

        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(!extension->ApplicationInformation);

    if (!appInfoBlock->AppInfoSize) {
        return STATUS_SUCCESS;
    }

    extension->ApplicationInformation =
            ExAllocatePoolWithTag(NonPagedPool, appInfoBlock->AppInfoSize,
                                  VOLSNAP_TAG_APP_INFO);
    if (!extension->ApplicationInformation) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(extension->ApplicationInformation,
                  (PCHAR) appInfoBlock + VSP_OFFSET_TO_APP_INFO,
                  appInfoBlock->AppInfoSize);

    extension->ApplicationInformationSize = appInfoBlock->AppInfoSize;

    return STATUS_SUCCESS;
}

NTSTATUS
VspCreateSnapshotExtension(
    IN  PFILTER_EXTENSION       Filter,
    IN  PVSP_LOOKUP_TABLE_ENTRY LookupEntry,
    IN  BOOLEAN                 IsNewestSnapshot
    )

{
    ULONG                   volumeNumber, i;
    WCHAR                   buffer[100];
    UNICODE_STRING          volumeName;
    NTSTATUS                status, status2;
    PDEVICE_OBJECT          deviceObject;
    PVOLUME_EXTENSION       extension;
    PVSP_DIFF_AREA_FILE     diffAreaFile;
    PVOID                   buf;
    PMDL                    mdl;
    KIRQL                   irql;
    PSECURITY_DESCRIPTOR    sd;
    BOOLEAN                 ma;

    if (IsNewestSnapshot && (LookupEntry->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_CRASHDUMP)) {

        VspLogError(NULL, Filter, VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES,
                    STATUS_SUCCESS, 5, FALSE);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (LookupEntry->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_DETECTION) {

        VspLogError(NULL, Filter, VS_ABORT_DIRTY_DETECTION, STATUS_SUCCESS,
                    0, FALSE);
        return STATUS_NO_SUCH_DEVICE;
    }

    volumeNumber = (ULONG)
                   InterlockedIncrement(&Filter->Root->NextVolumeNumber);
    swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d", volumeNumber);
    RtlInitUnicodeString(&volumeName, buffer);
    status = IoCreateDevice(Filter->Root->DriverObject,
                            sizeof(VOLUME_EXTENSION), &volumeName,
                            FILE_DEVICE_VIRTUAL_DISK, 0, FALSE,
                            &deviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    extension = (PVOLUME_EXTENSION) deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(VOLUME_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->Root = Filter->Root;
    extension->DeviceExtensionType = DEVICE_EXTENSION_VOLUME;
    KeInitializeSpinLock(&extension->SpinLock);
    extension->Filter = Filter;

    if (LookupEntry->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_OFFLINE) {

        extension->IsOffline = TRUE;
    }

    extension->RefCount = 1;
    InitializeListHead(&extension->WriteContextList);
    KeInitializeEvent(&extension->ZeroRefEvent, NotificationEvent, FALSE);
    extension->HasEndCommit = TRUE;
    extension->IsPersistent = TRUE;
    extension->IsDetected = TRUE;
    extension->RootSemaphoreHeld = TRUE;
    if (LookupEntry->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_VISIBLE) {
        extension->IsVisible = TRUE;
    }
    if (LookupEntry->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_NO_DIFF_AREA_FILL) {

        extension->NoDiffAreaFill = TRUE;
    }

    extension->CommitTimeStamp = LookupEntry->SnapshotTime;
    extension->VolumeNumber = volumeNumber;
    extension->SnapshotGuid = LookupEntry->SnapshotGuid;
    extension->SnapshotOrderNumber = LookupEntry->SnapshotOrderNumber;

    RtlInitializeGenericTable(&extension->VolumeBlockTable,
                              VspTableCompareRoutine,
                              VspTableAllocateRoutine,
                              VspTableFreeRoutine, extension);

    RtlInitializeGenericTable(&extension->TempVolumeBlockTable,
                              VspTableCompareRoutine,
                              VspTempTableAllocateRoutine,
                              VspTempTableFreeRoutine, extension);

    RtlInitializeGenericTable(&extension->CopyBackPointerTable,
                              VspTableCompareRoutine,
                              VspTableAllocateRoutine,
                              VspTableFreeRoutine, extension);

    extension->DiffAreaFileIncrease = NOMINAL_DIFF_AREA_FILE_GROWTH;

    diffAreaFile = (PVSP_DIFF_AREA_FILE)
                   ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(VSP_DIFF_AREA_FILE),
                                         VOLSNAP_TAG_DIFF_FILE);
    if (!diffAreaFile) {
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(diffAreaFile, sizeof(VSP_DIFF_AREA_FILE));
    diffAreaFile->Extension = extension;
    diffAreaFile->Filter = LookupEntry->DiffAreaFilter;
    diffAreaFile->FileHandle = LookupEntry->DiffAreaHandle;
    LookupEntry->DiffAreaHandle = NULL;
    InitializeListHead(&diffAreaFile->UnusedAllocationList);

    diffAreaFile->TableUpdateIrp =
            IoAllocateIrp((CCHAR) extension->Root->StackSize, FALSE);
    if (!diffAreaFile->TableUpdateIrp) {
        ExFreePool(diffAreaFile);
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    buf = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE,
                                VOLSNAP_TAG_BUFFER);
    if (!buf) {
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        ExFreePool(diffAreaFile);
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mdl = IoAllocateMdl(buf, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buf);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        ExFreePool(diffAreaFile);
        IoDeleteDevice(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool(mdl);
    diffAreaFile->TableUpdateIrp->MdlAddress = mdl;

    diffAreaFile->NextFreeTableEntryOffset = VSP_OFFSET_TO_FIRST_TABLE_ENTRY;
    diffAreaFile->ApplicationInfoTargetOffset =
            LookupEntry->ApplicationInfoStartingVolumeOffset;
    diffAreaFile->DiffAreaLocationDescriptionTargetOffset =
            LookupEntry->DiffAreaLocationDescriptionVolumeOffset;
    diffAreaFile->InitialBitmapVolumeOffset =
            LookupEntry->InitialBitmapVolumeOffset;
    diffAreaFile->FirstTableTargetOffset =
            LookupEntry->DiffAreaStartingVolumeOffset;
    diffAreaFile->TableTargetOffset =
            LookupEntry->DiffAreaStartingVolumeOffset;

    InitializeListHead(&diffAreaFile->TableUpdateQueue);
    InitializeListHead(&diffAreaFile->TableUpdatesInProgress);

    extension->DiffAreaFile = diffAreaFile;
    KeAcquireSpinLock(&diffAreaFile->Filter->SpinLock, &irql);
    InsertTailList(&diffAreaFile->Filter->DiffAreaFilesOnThisFilter,
                   &diffAreaFile->FilterListEntry);
    diffAreaFile->FilterListEntryBeingUsed = TRUE;
    KeReleaseSpinLock(&diffAreaFile->Filter->SpinLock, irql);

    InitializeListHead(&extension->OldHeaps);
    extension->VolumeSize = LookupEntry->VolumeSnapshotSize;
    InitializeListHead(&extension->EmergencyCopyIrpQueue);
    InitializeListHead(&extension->WaitingForPageFileSpace);
    InitializeListHead(&extension->WaitingForDiffAreaSpace);

    status = VspCreateWorkerThread(Filter->Root);
    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                    status, 1, FALSE);
        RemoveEntryList(&diffAreaFile->FilterListEntry);
        IoFreeMdl(mdl);
        ExFreePool(buf);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        ExFreePool(diffAreaFile);
        IoDeleteDevice(deviceObject);
        return status;
    }

    status = VspCreateInitialHeap(extension, TRUE);
    if (!NT_SUCCESS(status)) {
        VspDeleteWorkerThread(Filter->Root);
        RemoveEntryList(&diffAreaFile->FilterListEntry);
        IoFreeMdl(mdl);
        ExFreePool(buf);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        ExFreePool(diffAreaFile);
        IoDeleteDevice(deviceObject);
        return status;
    }

    status = VspReadApplicationInfo(diffAreaFile);
    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                    status, 2, FALSE);
        status2 = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                       extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status2));
        status2 = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                       extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status2));
        VspDeleteWorkerThread(Filter->Root);
        RemoveEntryList(&diffAreaFile->FilterListEntry);
        IoFreeMdl(mdl);
        ExFreePool(buf);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        ExFreePool(diffAreaFile);
        IoDeleteDevice(deviceObject);
        return status;
    }

    status = VspReadDiffAreaTable(diffAreaFile);
    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                    status, 3, FALSE);
        if (extension->ApplicationInformation) {
            ExFreePool(extension->ApplicationInformation);
        }
        status2 = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                       extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status2));
        status2 = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                       extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status2));
        VspDeleteWorkerThread(Filter->Root);
        RemoveEntryList(&diffAreaFile->FilterListEntry);
        IoFreeMdl(mdl);
        ExFreePool(buf);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        ExFreePool(diffAreaFile);
        IoDeleteDevice(deviceObject);
        return status;
    }

    status = ObGetObjectSecurity(Filter->Pdo, &sd, &ma);
    if (NT_SUCCESS(status)) {
        status = ObSetSecurityObjectByPointer(deviceObject,
                                              DACL_SECURITY_INFORMATION, sd);
        ObReleaseObjectSecurity(sd, ma);
    }

    if (NT_SUCCESS(status)) {
        extension->DevnodeNumber = VspClaimNextDevnodeNumber(extension->Root);
        if (!extension->DevnodeNumber) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                    status, 9, FALSE);
        if (extension->ApplicationInformation) {
            ExFreePool(extension->ApplicationInformation);
        }
        status2 = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                       extension->DiffAreaFileMap);
        ASSERT(NT_SUCCESS(status2));
        status2 = ZwUnmapViewOfSection(extension->DiffAreaFileMapProcess,
                                       extension->NextDiffAreaFileMap);
        ASSERT(NT_SUCCESS(status2));
        VspDeleteWorkerThread(Filter->Root);
        RemoveEntryList(&diffAreaFile->FilterListEntry);
        IoFreeMdl(mdl);
        ExFreePool(buf);
        IoFreeIrp(diffAreaFile->TableUpdateIrp);
        ExFreePool(diffAreaFile);
        RtlDeleteElementGenericTable(&extension->Root->UsedDevnodeNumbers,
                                     &extension->DevnodeNumber);
        IoDeleteDevice(deviceObject);
        return status;
    }

    if (LookupEntry->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_HIBERFIL_COPIED) {

        InterlockedExchange(&extension->HiberFileCopied, TRUE);
    }

    if (LookupEntry->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_PAGEFILE_COPIED) {

        InterlockedExchange(&extension->PageFileCopied, TRUE);
    }

    extension->DeviceObject->AlignmentRequirement =
            extension->Filter->Pdo->AlignmentRequirement |
            extension->DiffAreaFile->Filter->Pdo->AlignmentRequirement;

    InsertTailList(&Filter->VolumeList, &extension->ListEntry);

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceObject->StackSize = (CCHAR) Filter->Root->StackSize + 1;

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    extension->RootSemaphoreHeld = FALSE;

    return STATUS_SUCCESS;
}

BOOLEAN
VspAreSnapshotsComplete(
    IN  PFILTER_EXTENSION   Filter
    )

{
    LONGLONG                previousOrderNumber;
    PLIST_ENTRY             l;
    PVSP_LOOKUP_TABLE_ENTRY lookupEntry;

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    previousOrderNumber = 0;
    for (l = Filter->SnapshotLookupTableEntries.Flink;
         l != &Filter->SnapshotLookupTableEntries; l = l->Flink) {

        lookupEntry = CONTAINING_RECORD(l, VSP_LOOKUP_TABLE_ENTRY,
                                        SnapshotFilterListEntry);
        if (!lookupEntry->DiffAreaFilter) {
            VspReleaseNonPagedResource(Filter);
            return FALSE;
        }

        if (previousOrderNumber &&
            previousOrderNumber + 1 != lookupEntry->SnapshotOrderNumber) {

            VspReleaseNonPagedResource(Filter);
            ASSERT(FALSE);
            return FALSE;
        }

        previousOrderNumber = lookupEntry->SnapshotOrderNumber;
        ASSERT(previousOrderNumber);
    }

    VspReleaseNonPagedResource(Filter);

    return TRUE;
}

VOID
VspSignalWorker(
    IN  PVOID   Event
    )

{
    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
}

PVOID
VspInsertWithAllocateAndWait(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               TableEntry
    )

{
    NTSTATUS                    status = STATUS_SUCCESS;
    PTRANSLATION_TABLE_ENTRY    t1, t2;
    PVOID                       r;
    PVOID                       nodeOrParent;
    TABLE_SEARCH_RESULT         searchResult;
    KEVENT                      event;
    KIRQL                       irql;

    _try {
        t1 = (PTRANSLATION_TABLE_ENTRY)
             RtlLookupElementGenericTableFull(Table, TableEntry, &nodeOrParent,
                                              &searchResult);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    if (!NT_SUCCESS(status)) {
        return NULL;
    }

    if (t1) {
        t2 = (PTRANSLATION_TABLE_ENTRY) TableEntry;
        t1->TargetObject = t2->TargetObject;
        t1->Flags = t2->Flags;
        t1->TargetOffset = t2->TargetOffset;
        return t1;
    }

    _try {
        r = RtlInsertElementGenericTableFull(Table, TableEntry,
                                             sizeof(TRANSLATION_TABLE_ENTRY),
                                             NULL, nodeOrParent, searchResult);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        r = NULL;
    }

    if (!r) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (Extension->PageFileSpaceCreatePending) {
            ExInitializeWorkItem(&Extension->DiffAreaFile->WorkItem,
                                 VspSignalWorker, &event);
            InsertTailList(&Extension->WaitingForPageFileSpace,
                           &Extension->DiffAreaFile->WorkItem.List);
            KeReleaseSpinLock(&Extension->SpinLock, irql);

            KeWaitForSingleObject(&event, Executive, KernelMode,
                                  FALSE, NULL);

            VspReleasePagedResource(Extension);

        } else {
            KeReleaseSpinLock(&Extension->SpinLock, irql);
        }

        _try {
            r = RtlInsertElementGenericTableFull(Table, TableEntry,
                                                 sizeof(TRANSLATION_TABLE_ENTRY),
                                                 NULL, nodeOrParent,
                                                 searchResult);
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            r = NULL;
        }
    }

    return r;
}

NTSTATUS
VspReadDiffAreaTable(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

{
    PVOLUME_EXTENSION                   extension = DiffAreaFile->Extension;
    LONGLONG                            tableTargetOffset;
    LONGLONG                            highestFileOffset, tmp;
    TRANSLATION_TABLE_ENTRY             tableEntry;
    NTSTATUS                            status;
    PVSP_BLOCK_DIFF_AREA                diffAreaBlock;
    ULONG                               blockOffset;
    PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY    diffAreaTableEntry;
    PVOID                               r;
    KIRQL                               irql;
    PTRANSLATION_TABLE_ENTRY            backPointer;
    BOOLEAN                             b;
    LONGLONG                            initialBitmapTargetOffset;

    tableTargetOffset = DiffAreaFile->TableTargetOffset;
    highestFileOffset = 0;
    RtlZeroMemory(&tableEntry, sizeof(tableEntry));

    for (;;) {

        status = VspSynchronousIo(DiffAreaFile->TableUpdateIrp,
                                  DiffAreaFile->Filter->TargetObject,
                                  IRP_MJ_READ, tableTargetOffset, 0);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        diffAreaBlock = (PVSP_BLOCK_DIFF_AREA)
            MmGetMdlVirtualAddress(DiffAreaFile->TableUpdateIrp->MdlAddress);

        if (!IsEqualGUID(diffAreaBlock->Header.Signature,
                         VSP_DIFF_AREA_FILE_GUID) ||
            diffAreaBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
            diffAreaBlock->Header.BlockType != VSP_BLOCK_TYPE_DIFF_AREA ||
            diffAreaBlock->Header.ThisVolumeOffset != tableTargetOffset ||
            diffAreaBlock->Header.NextVolumeOffset == tableTargetOffset) {

            return STATUS_INVALID_PARAMETER;
        }

        if (diffAreaBlock->Header.ThisFileOffset > highestFileOffset) {
            highestFileOffset = diffAreaBlock->Header.ThisFileOffset;
        }

        for (blockOffset = VSP_OFFSET_TO_FIRST_TABLE_ENTRY;
             blockOffset + sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY) <=
             BLOCK_SIZE;
             blockOffset += sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY)) {

            diffAreaTableEntry = (PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY)
                                 ((PCHAR) diffAreaBlock + blockOffset);

            if (!diffAreaTableEntry->DiffAreaVolumeOffset &&
                !diffAreaTableEntry->Flags) {

                break;
            }

            if (diffAreaTableEntry->SnapshotVolumeOffset >=
                        extension->VolumeSize ||
                diffAreaTableEntry->SnapshotVolumeOffset < 0 ||
                (diffAreaTableEntry->SnapshotVolumeOffset&(BLOCK_SIZE - 1)) ||
                diffAreaTableEntry->DiffAreaFileOffset < 0 ||
                diffAreaTableEntry->DiffAreaVolumeOffset < 0 ||
                (diffAreaTableEntry->DiffAreaVolumeOffset&(BLOCK_SIZE - 1))) {

                return STATUS_INVALID_PARAMETER;
            }

            if (diffAreaTableEntry->Flags&
                (~VSP_DIFF_AREA_TABLE_ENTRY_FLAG_MOVE_ENTRY)) {

                return STATUS_INVALID_PARAMETER;
            }

            if (diffAreaTableEntry->Flags) {

                tableEntry.VolumeOffset =
                        diffAreaTableEntry->SnapshotVolumeOffset;
                tableEntry.TargetObject = extension->Filter->TargetObject;
                tableEntry.Flags =
                        VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY;
                tableEntry.TargetOffset =
                        diffAreaTableEntry->DiffAreaFileOffset;

            } else {

                if (diffAreaTableEntry->DiffAreaFileOffset >
                    highestFileOffset) {

                    highestFileOffset =
                            diffAreaTableEntry->DiffAreaFileOffset;
                }

                tableEntry.VolumeOffset =
                        diffAreaTableEntry->SnapshotVolumeOffset;
                tableEntry.TargetObject = DiffAreaFile->Filter->TargetObject;
                tableEntry.Flags = 0;
                tableEntry.TargetOffset =
                        diffAreaTableEntry->DiffAreaVolumeOffset;

            }

            _try {
                backPointer = (PTRANSLATION_TABLE_ENTRY)
                              RtlLookupElementGenericTable(
                              &extension->CopyBackPointerTable,
                              &tableEntry);
            } _except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }

            if (!NT_SUCCESS(status)) {
                return status;
            }

            if (backPointer) {
                tmp = backPointer->TargetOffset;
                _try {
                    b = RtlDeleteElementGenericTable(
                        &extension->CopyBackPointerTable, &tableEntry);
                    if (!b) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                } _except (EXCEPTION_EXECUTE_HANDLER) {
                    b = FALSE;
                    status = GetExceptionCode();
                }

                if (!b) {
                    return status;
                }

                tableEntry.VolumeOffset = tmp;
            }

            r = VspInsertWithAllocateAndWait(extension,
                                             &extension->VolumeBlockTable,
                                             &tableEntry);
            if (!r) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            if (diffAreaTableEntry->Flags) {

                tmp = tableEntry.VolumeOffset;
                tableEntry.VolumeOffset = tableEntry.TargetOffset;
                tableEntry.TargetOffset = tmp;

                r = VspInsertWithAllocateAndWait(
                        extension, &extension->CopyBackPointerTable,
                        &tableEntry);

                if (!r) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        if (!diffAreaBlock->Header.NextVolumeOffset) {
            break;
        }

        tableTargetOffset = diffAreaBlock->Header.NextVolumeOffset;
    }

    initialBitmapTargetOffset = DiffAreaFile->InitialBitmapVolumeOffset;

    while (initialBitmapTargetOffset) {

        status = VspSynchronousIo(DiffAreaFile->TableUpdateIrp,
                                  DiffAreaFile->Filter->TargetObject,
                                  IRP_MJ_READ, initialBitmapTargetOffset, 0);
        if (!NT_SUCCESS(status)) {
            break;
        }

        diffAreaBlock = (PVSP_BLOCK_DIFF_AREA)
            MmGetMdlVirtualAddress(DiffAreaFile->TableUpdateIrp->MdlAddress);

        if (!IsEqualGUID(diffAreaBlock->Header.Signature,
                         VSP_DIFF_AREA_FILE_GUID) ||
            diffAreaBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
            diffAreaBlock->Header.BlockType !=
                    VSP_BLOCK_TYPE_INITIAL_BITMAP ||
            diffAreaBlock->Header.ThisVolumeOffset !=
                    initialBitmapTargetOffset ||
            diffAreaBlock->Header.NextVolumeOffset ==
                    initialBitmapTargetOffset) {

            break;
        }

        if (diffAreaBlock->Header.ThisFileOffset > highestFileOffset) {
            highestFileOffset = diffAreaBlock->Header.ThisFileOffset;
        }

        initialBitmapTargetOffset = diffAreaBlock->Header.NextVolumeOffset;
    }

    DiffAreaFile->TableTargetOffset = tableTargetOffset;
    DiffAreaFile->NextAvailable = highestFileOffset + BLOCK_SIZE;
    DiffAreaFile->AllocatedFileSize = DiffAreaFile->NextAvailable;
    DiffAreaFile->NextFreeTableEntryOffset = blockOffset;

    KeAcquireSpinLock(&extension->Filter->SpinLock, &irql);
    extension->Filter->UsedVolumeSpace += DiffAreaFile->NextAvailable;
    extension->Filter->AllocatedVolumeSpace += DiffAreaFile->AllocatedFileSize;
    KeReleaseSpinLock(&extension->Filter->SpinLock, irql);

    return STATUS_SUCCESS;
}

NTSTATUS
VspInitializeUnusedAllocationLists(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PVSP_DIFF_AREA_FILE                         diffAreaFile;
    NTSTATUS                                    status;
    LONGLONG                                    tableTargetOffset;
    LONGLONG                                    nextFileOffset;
    PVSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION   locationBlock;
    ULONG                                       blockOffset;
    PVSP_DIFF_AREA_LOCATION_DESCRIPTOR          locationDescriptor;
    PDIFF_AREA_FILE_ALLOCATION                  diffAreaFileAllocation;
    LONGLONG                                    delta;
    KIRQL                                       irql;

    diffAreaFile = Extension->DiffAreaFile;
    ASSERT(diffAreaFile);

    tableTargetOffset = diffAreaFile->DiffAreaLocationDescriptionTargetOffset;
    nextFileOffset = diffAreaFile->NextAvailable;
    locationBlock = (PVSP_BLOCK_DIFF_AREA_LOCATION_DESCRIPTION)
        MmGetMdlVirtualAddress(diffAreaFile->TableUpdateIrp->MdlAddress);

    for (;;) {

        status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                  diffAreaFile->Filter->TargetObject,
                                  IRP_MJ_READ, tableTargetOffset, 0);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!IsEqualGUID(locationBlock->Header.Signature,
                         VSP_DIFF_AREA_FILE_GUID) ||
            locationBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
            locationBlock->Header.BlockType !=
                    VSP_BLOCK_TYPE_DIFF_AREA_LOCATION_DESCRIPTION ||
            locationBlock->Header.ThisVolumeOffset != tableTargetOffset ||
            locationBlock->Header.NextVolumeOffset == tableTargetOffset) {

            return STATUS_INVALID_PARAMETER;
        }

        for (blockOffset = VSP_OFFSET_TO_FIRST_LOCATION_DESCRIPTOR;
             blockOffset + sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR) <=
             BLOCK_SIZE;
             blockOffset += sizeof(VSP_DIFF_AREA_LOCATION_DESCRIPTOR)) {

            locationDescriptor = (PVSP_DIFF_AREA_LOCATION_DESCRIPTOR)
                                 ((PCHAR) locationBlock + blockOffset);

            if (!locationDescriptor->VolumeOffset) {
                break;
            }

            if (locationDescriptor->VolumeOffset < 0 ||
                locationDescriptor->FileOffset < 0 ||
                locationDescriptor->Length <= 0) {

                return STATUS_INVALID_PARAMETER;
            }

            if (locationDescriptor->FileOffset +
                locationDescriptor->Length < nextFileOffset) {

                continue;
            }

            if (locationDescriptor->FileOffset < nextFileOffset) {
                delta = nextFileOffset - locationDescriptor->FileOffset;
                locationDescriptor->Length -= delta;
                locationDescriptor->VolumeOffset += delta;
                locationDescriptor->FileOffset = nextFileOffset;
            }

            if (locationDescriptor->FileOffset > nextFileOffset) {
                diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                        ExAllocatePoolWithTag(NonPagedPool,
                        sizeof(DIFF_AREA_FILE_ALLOCATION),
                        VOLSNAP_TAG_BIT_HISTORY);
                if (!diffAreaFileAllocation) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                diffAreaFileAllocation->Offset = 0;
                diffAreaFileAllocation->NLength =
                        nextFileOffset - locationDescriptor->FileOffset;

                InsertTailList(&diffAreaFile->UnusedAllocationList,
                               &diffAreaFileAllocation->ListEntry);
                nextFileOffset = locationDescriptor->FileOffset;
            }

            ASSERT(nextFileOffset == locationDescriptor->FileOffset);

            diffAreaFileAllocation = (PDIFF_AREA_FILE_ALLOCATION)
                    ExAllocatePoolWithTag(NonPagedPool,
                    sizeof(DIFF_AREA_FILE_ALLOCATION),
                    VOLSNAP_TAG_BIT_HISTORY);
            if (!diffAreaFileAllocation) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            diffAreaFileAllocation->Offset = locationDescriptor->VolumeOffset;
            diffAreaFileAllocation->NLength = locationDescriptor->Length;

            InsertTailList(&diffAreaFile->UnusedAllocationList,
                           &diffAreaFileAllocation->ListEntry);
            nextFileOffset += locationDescriptor->Length;
        }

        if (!locationBlock->Header.NextVolumeOffset) {
            break;
        }

        tableTargetOffset = locationBlock->Header.NextVolumeOffset;
    }

    delta = nextFileOffset - diffAreaFile->AllocatedFileSize;
    diffAreaFile->AllocatedFileSize += delta;

    KeAcquireSpinLock(&Extension->Filter->SpinLock, &irql);
    Extension->Filter->AllocatedVolumeSpace += delta;
    KeReleaseSpinLock(&Extension->Filter->SpinLock, irql);

    status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                              diffAreaFile->Filter->TargetObject,
                              IRP_MJ_READ, diffAreaFile->TableTargetOffset, 0);

    return status;
}

VOID
VspCleanupDetectedSnapshots(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PVOLUME_EXTENSION   extension;

    while (!IsListEmpty(&Filter->VolumeList)) {

        KeAcquireSpinLock(&Filter->SpinLock, &irql);
        l = RemoveHeadList(&Filter->VolumeList);
        KeReleaseSpinLock(&Filter->SpinLock, irql);

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);

        KeAcquireSpinLock(&extension->SpinLock, &irql);
        InterlockedExchange(&extension->IsDead, TRUE);
        KeReleaseSpinLock(&extension->SpinLock, irql);

        VspCleanupVolumeSnapshot(extension, NULL, FALSE);

        RtlDeleteElementGenericTable(&extension->Root->UsedDevnodeNumbers,
                                     &extension->DevnodeNumber);

        IoDeleteDevice(extension->DeviceObject);
    }
}

NTSTATUS
VspProcessInMemoryCopyOnWrites(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION                   filter = Extension->Filter;
    PVSP_DIFF_AREA_FILE                 diffAreaFile = Extension->DiffAreaFile;
    PFILTER_EXTENSION                   diffFilter = diffAreaFile->Filter;
    PLIST_ENTRY                         l;
    PVSP_COPY_ON_WRITE                  copyOnWrite;
    LONGLONG                            volumeOffset, targetOffset, fileOffset, tmp;
    PIRP                                irp;
    PMDL                                mdl;
    LONGLONG                            t, f;
    PVSP_BLOCK_DIFF_AREA                diffAreaBlock;
    PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY    diffAreaTableEntry;
    TRANSLATION_TABLE_ENTRY             tableEntry;
    PVOID                               r;
    PTRANSLATION_TABLE_ENTRY            backPointer;
    BOOLEAN                             b;
    NTSTATUS                            status;
    CHAR                                controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT          snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;

    diffAreaBlock = (PVSP_BLOCK_DIFF_AREA) MmGetMdlVirtualAddress(
                    diffAreaFile->TableUpdateIrp->MdlAddress);

    while (!IsListEmpty(&filter->CopyOnWriteList)) {

        l = RemoveHeadList(&filter->CopyOnWriteList);
        copyOnWrite = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE, ListEntry);
        volumeOffset = copyOnWrite->RoundedStart;

        if (RtlCheckBit(Extension->VolumeBlockBitmap,
                        volumeOffset>>BLOCK_SHIFT)) {

            ExFreePool(copyOnWrite->Buffer);
            ExFreePool(copyOnWrite);
            continue;
        }

        status = VspAllocateDiffAreaSpace(Extension, &targetOffset,
                                          &fileOffset, NULL, NULL);
        if (!NT_SUCCESS(status)) {
            ExFreePool(copyOnWrite->Buffer);
            ExFreePool(copyOnWrite);
            goto ErrorOut;
        }

        mdl = IoAllocateMdl(copyOnWrite->Buffer, BLOCK_SIZE, FALSE, FALSE,
                            NULL);
        if (!mdl) {
            ExFreePool(copyOnWrite->Buffer);
            ExFreePool(copyOnWrite);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorOut;
        }
        irp = IoAllocateIrp(diffFilter->TargetObject->StackSize, FALSE);
        if (!irp) {
            IoFreeMdl(mdl);
            ExFreePool(copyOnWrite->Buffer);
            ExFreePool(copyOnWrite);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorOut;
        }
        irp->MdlAddress = mdl;
        MmBuildMdlForNonPagedPool(mdl);

        status = VspSynchronousIo(irp, diffFilter->TargetObject,
                                  IRP_MJ_WRITE, targetOffset, 0);
        IoFreeIrp(irp);
        IoFreeMdl(mdl);
        ExFreePool(copyOnWrite->Buffer);
        ExFreePool(copyOnWrite);
        if (!NT_SUCCESS(status)) {
            goto ErrorOut;
        }

        if (diffAreaFile->NextFreeTableEntryOffset +
            sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY) > BLOCK_SIZE) {

            status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                      diffFilter->TargetObject,
                                      IRP_MJ_WRITE,
                                      diffAreaFile->TableTargetOffset, 0);
            if (!NT_SUCCESS(status)) {
                goto ErrorOut;
            }

            status = VspAllocateDiffAreaSpace(Extension, &t, &f, NULL, NULL);
            if (!NT_SUCCESS(status)) {
                goto ErrorOut;
            }

            RtlZeroMemory(diffAreaBlock, BLOCK_SIZE);
            diffAreaBlock->Header.Signature = VSP_DIFF_AREA_FILE_GUID;
            diffAreaBlock->Header.Version = VOLSNAP_PERSISTENT_VERSION;
            diffAreaBlock->Header.BlockType = VSP_BLOCK_TYPE_DIFF_AREA;
            diffAreaBlock->Header.ThisFileOffset = f;
            diffAreaBlock->Header.ThisVolumeOffset = t;

            status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                      diffFilter->TargetObject,
                                      IRP_MJ_WRITE, t, 0);
            if (!NT_SUCCESS(status)) {
                goto ErrorOut;
            }

            status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                      diffFilter->TargetObject,
                                      IRP_MJ_READ,
                                      diffAreaFile->TableTargetOffset, 0);
            if (!NT_SUCCESS(status)) {
                goto ErrorOut;
            }

            diffAreaBlock->Header.NextVolumeOffset = t;

            status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                      diffFilter->TargetObject,
                                      IRP_MJ_WRITE,
                                      diffAreaFile->TableTargetOffset, 0);
            if (!NT_SUCCESS(status)) {
                goto ErrorOut;
            }

            diffAreaFile->TableTargetOffset = t;

            status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                                      diffFilter->TargetObject,
                                      IRP_MJ_READ,
                                      diffAreaFile->TableTargetOffset, 0);
            if (!NT_SUCCESS(status)) {
                goto ErrorOut;
            }

            diffAreaFile->NextFreeTableEntryOffset =
                    VSP_OFFSET_TO_FIRST_TABLE_ENTRY;
        }

        diffAreaTableEntry = (PVSP_BLOCK_DIFF_AREA_TABLE_ENTRY)
                             ((PCHAR) diffAreaBlock +
                              diffAreaFile->NextFreeTableEntryOffset);
        diffAreaFile->NextFreeTableEntryOffset +=
                sizeof(VSP_BLOCK_DIFF_AREA_TABLE_ENTRY);

        diffAreaTableEntry->SnapshotVolumeOffset = volumeOffset;
        diffAreaTableEntry->DiffAreaFileOffset = fileOffset;
        diffAreaTableEntry->DiffAreaVolumeOffset = targetOffset;
        diffAreaTableEntry->Flags = 0;

        RtlZeroMemory(&tableEntry, sizeof(TRANSLATION_TABLE_ENTRY));
        tableEntry.VolumeOffset = volumeOffset;
        tableEntry.TargetObject = diffAreaFile->Filter->TargetObject;
        tableEntry.TargetOffset = targetOffset;

        _try {
            backPointer = (PTRANSLATION_TABLE_ENTRY)
                          RtlLookupElementGenericTable(
                          &Extension->CopyBackPointerTable,
                          &tableEntry);
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }

        if (!NT_SUCCESS(status)) {
            goto ErrorOut;
        }

        if (backPointer) {
            tmp = backPointer->TargetOffset;
            _try {
                b = RtlDeleteElementGenericTable(
                    &Extension->CopyBackPointerTable, &tableEntry);
                if (!b) {
                    status = STATUS_INVALID_PARAMETER;
                }
            } _except (EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
                status = GetExceptionCode();
            }

            if (!b) {
                goto ErrorOut;
            }

            tableEntry.VolumeOffset = tmp;
        }

        r = VspInsertWithAllocateAndWait(Extension,
                                         &Extension->VolumeBlockTable,
                                         &tableEntry);
        if (!r) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ErrorOut;
        }

        RtlSetBit(Extension->VolumeBlockBitmap,
                  (ULONG) (volumeOffset>>BLOCK_SHIFT));
    }

    status = VspSynchronousIo(diffAreaFile->TableUpdateIrp,
                              diffFilter->TargetObject,
                              IRP_MJ_WRITE,
                              diffAreaFile->TableTargetOffset, 0);
    if (!NT_SUCCESS(status)) {
        goto ErrorOut;
    }

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, FALSE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        goto ErrorOut;
    }

    snapshotControlItem->SnapshotControlItemFlags &=
            ~VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_DETECTION;

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, TRUE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        goto ErrorOut;
    }

    return STATUS_SUCCESS;

ErrorOut:

    while (!IsListEmpty(&filter->CopyOnWriteList)) {
        l = RemoveHeadList(&filter->CopyOnWriteList);
        copyOnWrite = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE, ListEntry);
        ExFreePool(copyOnWrite->Buffer);
        ExFreePool(copyOnWrite);
    }

    return status;
}

NTSTATUS
VspActivateSnapshots(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PLIST_ENTRY                 l;
    PVSP_LOOKUP_TABLE_ENTRY     lookupEntry;
    BOOLEAN                     newest;
    NTSTATUS                    status;
    PVOLUME_EXTENSION           extension;
    PVSP_DIFF_AREA_FILE         diffAreaFile;
    ULONG                       bitmapSize;
    PVOID                       bitmapBuffer;
    PTRANSLATION_TABLE_ENTRY    p;
    PVOID                       buffer;
    PMDL                        mdl;
    LARGE_INTEGER               timeout;
    BOOLEAN                     moveEntries;

    for (l = Filter->SnapshotLookupTableEntries.Flink;
         l != &Filter->SnapshotLookupTableEntries; l = l->Flink) {

        lookupEntry = CONTAINING_RECORD(l, VSP_LOOKUP_TABLE_ENTRY,
                                        SnapshotFilterListEntry);
        ASSERT(lookupEntry->DiffAreaFilter);

        if (l->Flink == &Filter->SnapshotLookupTableEntries) {
            newest = TRUE;
        } else {
            newest = FALSE;
        }

        status = VspCreateSnapshotExtension(Filter, lookupEntry, newest);
        if (!NT_SUCCESS(status)) {
            VspDeleteControlItemsWithGuid(Filter, NULL, FALSE);
            VspCleanupDetectedSnapshots(Filter);
            return status;
        }

        if (!newest) {
            extension = CONTAINING_RECORD(Filter->VolumeList.Blink,
                                          VOLUME_EXTENSION, ListEntry);
            diffAreaFile = extension->DiffAreaFile;

            if (extension->NextDiffAreaFileMap) {
                status = ZwUnmapViewOfSection(
                         extension->DiffAreaFileMapProcess,
                         extension->NextDiffAreaFileMap);
                ASSERT(NT_SUCCESS(status));
                extension->NextDiffAreaFileMap = NULL;
            }

            if (diffAreaFile->TableUpdateIrp) {
                ExFreePool(MmGetMdlVirtualAddress(
                           diffAreaFile->TableUpdateIrp->MdlAddress));
                IoFreeMdl(diffAreaFile->TableUpdateIrp->MdlAddress);
                IoFreeIrp(diffAreaFile->TableUpdateIrp);
                diffAreaFile->TableUpdateIrp = NULL;
            }
        }
    }

    extension = CONTAINING_RECORD(Filter->VolumeList.Blink, VOLUME_EXTENSION,
                                  ListEntry);

    extension->VolumeBlockBitmap = (PRTL_BITMAP)
                                   ExAllocatePoolWithTag(
                                   NonPagedPool, sizeof(RTL_BITMAP),
                                   VOLSNAP_TAG_BITMAP);
    if (!extension->VolumeBlockBitmap) {
        VspCleanupDetectedSnapshots(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    bitmapSize = (ULONG) ((extension->VolumeSize + BLOCK_SIZE - 1)>>
                          BLOCK_SHIFT);
    bitmapBuffer = ExAllocatePoolWithTag(NonPagedPool,
                   (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);

    if (!bitmapBuffer) {
        VspLogError(extension, NULL, VS_CANT_ALLOCATE_BITMAP,
                    STATUS_INSUFFICIENT_RESOURCES, 3, FALSE);
        ExFreePool(extension->VolumeBlockBitmap);
        extension->VolumeBlockBitmap = NULL;
        VspCleanupDetectedSnapshots(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(extension->VolumeBlockBitmap, (PULONG) bitmapBuffer,
                        bitmapSize);
    RtlClearAllBits(extension->VolumeBlockBitmap);

    moveEntries = FALSE;
    status = STATUS_SUCCESS;

    _try {

        p = (PTRANSLATION_TABLE_ENTRY)
            RtlEnumerateGenericTable(&extension->VolumeBlockTable, TRUE);
        while (p) {

            RtlSetBit(extension->VolumeBlockBitmap,
                      (ULONG) (p->VolumeOffset>>BLOCK_SHIFT));

            if (p->Flags&VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY) {
                moveEntries = TRUE;
            }

            p = (PTRANSLATION_TABLE_ENTRY)
                RtlEnumerateGenericTable(&extension->VolumeBlockTable, FALSE);
        }

        if (moveEntries) {

            p = (PTRANSLATION_TABLE_ENTRY)
                RtlEnumerateGenericTable(&extension->VolumeBlockTable, TRUE);

            while (p) {

                if (p->Flags&VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY) {
                    RtlClearBit(extension->VolumeBlockBitmap,
                                (ULONG) (p->TargetOffset>>BLOCK_SHIFT));
                }

                p = (PTRANSLATION_TABLE_ENTRY)
                    RtlEnumerateGenericTable(&extension->VolumeBlockTable,
                                             FALSE);
            }
        }

    } _except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    if (!NT_SUCCESS(status)) {
        VspCleanupDetectedSnapshots(Filter);
        return status;
    }

    extension->IgnorableProduct = (PRTL_BITMAP)
                                  ExAllocatePoolWithTag(
                                  NonPagedPool, sizeof(RTL_BITMAP),
                                  VOLSNAP_TAG_BITMAP);
    if (!extension->IgnorableProduct) {
        VspCleanupDetectedSnapshots(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    bitmapBuffer = ExAllocatePoolWithTag(NonPagedPool,
                   (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);

    if (!bitmapBuffer) {
        VspLogError(extension, NULL, VS_CANT_ALLOCATE_BITMAP,
                    STATUS_INSUFFICIENT_RESOURCES, 4, FALSE);
        ExFreePool(extension->IgnorableProduct);
        extension->IgnorableProduct = NULL;
        VspCleanupDetectedSnapshots(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(extension->IgnorableProduct, (PULONG) bitmapBuffer,
                        bitmapSize);
    RtlSetAllBits(extension->IgnorableProduct);

    extension->EmergencyCopyIrp =
            IoAllocateIrp((CCHAR) extension->Root->StackSize, FALSE);
    if (!extension->EmergencyCopyIrp) {
        VspCleanupDetectedSnapshots(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    buffer = ExAllocatePoolWithTag(NonPagedPool,
                                   BLOCK_SIZE, VOLSNAP_TAG_BUFFER);
    if (!buffer) {
        IoFreeIrp(extension->EmergencyCopyIrp);
        extension->EmergencyCopyIrp = NULL;
        VspCleanupDetectedSnapshots(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        ExFreePool(buffer);
        IoFreeIrp(extension->EmergencyCopyIrp);
        extension->EmergencyCopyIrp = NULL;
        VspCleanupDetectedSnapshots(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool(mdl);
    extension->EmergencyCopyIrp->MdlAddress = mdl;

    status = VspInitializeUnusedAllocationLists(extension);
    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                    status, 4, FALSE);
        VspCleanupDetectedSnapshots(Filter);
        return status;
    }

    diffAreaFile = extension->DiffAreaFile;
    if (diffAreaFile->NextAvailable + extension->DiffAreaFileIncrease >
        diffAreaFile->AllocatedFileSize) {

        extension->DetectedNeedForGrow = TRUE;
    }

    if (Filter->FirstWriteProcessed) {
        status = VspProcessInMemoryCopyOnWrites(extension);
        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                        status, 8, FALSE);
            VspCleanupDetectedSnapshots(Filter);
            return status;
        }
    }

    InterlockedExchange(&Filter->SnapshotsPresent, TRUE);
    InterlockedExchange(&Filter->PersistentSnapshots, TRUE);

    Filter->DiffAreaVolume = extension->DiffAreaFile->Filter;

    ObReferenceObject(Filter->DeviceObject);

    timeout.QuadPart = (LONGLONG) -10*1000*1000*120*10;   // 20 minutes.
    KeSetTimer(&Filter->EndCommitTimer, timeout, &Filter->EndCommitTimerDpc);

    IoInvalidateDeviceRelations(Filter->Pdo, BusRelations);

    VspCheckMaxSize(Filter);

    return STATUS_SUCCESS;
}

VOID
VspRemoveLookupEntries(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PLIST_ENTRY             l;
    PVSP_LOOKUP_TABLE_ENTRY lookupEntry;

    KeWaitForSingleObject(&Filter->Root->LookupTableMutex, Executive,
                          KernelMode, FALSE, NULL);

    while (!IsListEmpty(&Filter->SnapshotLookupTableEntries)) {
        l = RemoveHeadList(&Filter->SnapshotLookupTableEntries);
        lookupEntry = CONTAINING_RECORD(l, VSP_LOOKUP_TABLE_ENTRY,
                                        SnapshotFilterListEntry);
        ASSERT(lookupEntry->SnapshotFilter);
        lookupEntry->SnapshotFilter = NULL;
        if (!lookupEntry->DiffAreaFilter) {
            ASSERT(!lookupEntry->DiffAreaHandle);
            RtlDeleteElementGenericTable(
                    &Filter->Root->PersistentSnapshotLookupTable,
                    lookupEntry);
        }
    }

    while (!IsListEmpty(&Filter->DiffAreaLookupTableEntries)) {
        l = RemoveHeadList(&Filter->DiffAreaLookupTableEntries);
        lookupEntry = CONTAINING_RECORD(l, VSP_LOOKUP_TABLE_ENTRY,
                                        DiffAreaFilterListEntry);
        ASSERT(lookupEntry->DiffAreaFilter);
        lookupEntry->DiffAreaFilter = NULL;
        if (lookupEntry->DiffAreaHandle) {
            ZwClose(lookupEntry->DiffAreaHandle);
            lookupEntry->DiffAreaHandle = NULL;
        }

        if (!lookupEntry->SnapshotFilter) {
            RtlDeleteElementGenericTable(
                    &Filter->Root->PersistentSnapshotLookupTable,
                    lookupEntry);
        }
    }

    KeReleaseMutex(&Filter->Root->LookupTableMutex, FALSE);
}

VOID
VspCleanupControlFile(
    IN  PFILTER_EXTENSION   Filter
    )

{
    LONGLONG                    controlBlockOffset;
    PVSP_BLOCK_CONTROL          controlBlock;
    NTSTATUS                    status;
    ULONG                       offset;
    PVSP_CONTROL_ITEM_SNAPSHOT  controlItem;

    controlBlockOffset = Filter->FirstControlBlockVolumeOffset;
    controlBlock = (PVSP_BLOCK_CONTROL) MmGetMdlVirtualAddress(
                   Filter->SnapshotOnDiskIrp->MdlAddress);

    while (controlBlockOffset) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  controlBlockOffset, 0);
        if (!NT_SUCCESS(status)) {
            break;
        }

        if (!IsEqualGUID(controlBlock->Header.Signature,
                         VSP_DIFF_AREA_FILE_GUID) ||
            controlBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
            controlBlock->Header.BlockType != VSP_BLOCK_TYPE_CONTROL ||
            controlBlock->Header.ThisVolumeOffset != controlBlockOffset ||
            controlBlock->Header.NextVolumeOffset == controlBlockOffset) {

            break;
        }

        for (offset = VSP_BYTES_PER_CONTROL_ITEM; offset < BLOCK_SIZE;
             offset += VSP_BYTES_PER_CONTROL_ITEM) {

            controlItem = (PVSP_CONTROL_ITEM_SNAPSHOT)
                          ((PCHAR) controlBlock + offset);

            if (controlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_END) {
                break;
            }

            if (controlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_FREE) {
                continue;
            }

            VspRemoveControlItemInfoFromLookupTable(Filter, controlItem);
        }

        controlBlockOffset = controlBlock->Header.NextVolumeOffset;

        if (!controlBlockOffset) {
            break;
        }
    }

    VspAcquireNonPagedResource(Filter, NULL, FALSE);
    VspCreateStartBlock(Filter, 0, Filter->MaximumVolumeSpace);
    Filter->FirstControlBlockVolumeOffset = 0;
    VspReleaseNonPagedResource(Filter);
}

VOID
VspWriteTriggerDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->DeleteDiffAreaFiles.Filter;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PVSP_COPY_ON_WRITE  copyOnWrite;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_PNP_WAIT_TIMER);

    ExFreePool(context->PnpWaitTimer.Timer);
    VspFreeContext(filter->Root, context);

    if (!filter->HoldIncomingWrites || !filter->SnapshotDiscoveryPending) {
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (filter->ActivateStarted || filter->FirstWriteProcessed) {
        KeReleaseSpinLock(&filter->SpinLock, irql);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }
    InterlockedExchange(&filter->FirstWriteProcessed, TRUE);
    while (!IsListEmpty(&filter->CopyOnWriteList)) {
        l = RemoveHeadList(&filter->CopyOnWriteList);
        copyOnWrite = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE, ListEntry);
        ExFreePool(copyOnWrite->Buffer);
        ExFreePool(copyOnWrite);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    ExInitializeWorkItem(&filter->DestroyContext.WorkItem,
                         VspStartCopyOnWriteCache, filter);
    ExQueueWorkItem(&filter->DestroyContext.WorkItem, DelayedWorkQueue);
}

VOID
VspScheduleWriteTrigger(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PKTIMER         timer;
    PVSP_CONTEXT    context;
    LARGE_INTEGER   timeout;

    timer = (PKTIMER) ExAllocatePoolWithTag(NonPagedPool, sizeof(KTIMER),
                                            VOLSNAP_TAG_SHORT_TERM);
    if (!timer) {
        return;
    }

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        ExFreePool(timer);
        return;
    }

    ObReferenceObject(Filter->DeviceObject);
    KeInitializeTimer(timer);

    context->Type = VSP_CONTEXT_TYPE_PNP_WAIT_TIMER;
    context->PnpWaitTimer.Filter = Filter;
    KeInitializeDpc(&context->PnpWaitTimer.TimerDpc, VspWriteTriggerDpc,
                    context);
    context->PnpWaitTimer.Timer = timer;

    timeout.QuadPart = (LONGLONG) 10*(-10*1000*1000); // 10 seconds.
    KeSetTimer(timer, timeout, &context->PnpWaitTimer.TimerDpc);
}

VOID
VspDiscoverSnapshots(
    IN  PFILTER_EXTENSION   Filter,
    OUT PBOOLEAN            NoControlItems
    )

{
    NTSTATUS                    status;
    PVOID                       buffer;
    PVSP_BLOCK_START            startBlock;
    LONGLONG                    controlBlockOffset;
    PVSP_BLOCK_CONTROL          controlBlock;
    ULONG                       offset;
    PVSP_CONTROL_ITEM_SNAPSHOT  controlItem;
    BOOLEAN                     diffAreasFound, snapshotsFound, isComplete;
    PLIST_ENTRY                 l;
    PFILTER_EXTENSION           f;
    KIRQL                       irql;

    *NoControlItems = TRUE;

    if (!Filter->SnapshotOnDiskIrp) {
        VspCreateSnapshotOnDiskIrp(Filter);
        if (!Filter->SnapshotOnDiskIrp) {
            VspResumeVolumeIo(Filter);
            return;
        }
    }

    status = VspSynchronousIo(Filter->SnapshotOnDiskIrp, Filter->TargetObject,
                              IRP_MJ_READ, 0, 0);
    if (!NT_SUCCESS(status)) {
        VspResumeVolumeIo(Filter);
        return;
    }

    buffer = MmGetMdlVirtualAddress(Filter->SnapshotOnDiskIrp->MdlAddress);
    if (!VspIsNtfsBootSector(Filter, buffer)) {
        VspResumeVolumeIo(Filter);
        return;
    }

    startBlock = (PVSP_BLOCK_START) ((PCHAR) buffer + VSP_START_BLOCK_OFFSET);
    if (!IsEqualGUID(startBlock->Header.Signature, VSP_DIFF_AREA_FILE_GUID)) {
        VspResumeVolumeIo(Filter);
        return;
    }

    if (startBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
        startBlock->Header.BlockType != VSP_BLOCK_TYPE_START) {

        VspAcquireNonPagedResource(Filter, NULL, FALSE);
        VspCreateStartBlock(Filter, 0, 0);
        Filter->FirstControlBlockVolumeOffset = 0;
        Filter->MaximumVolumeSpace = 0;
        VspReleaseNonPagedResource(Filter);

        VspResumeVolumeIo(Filter);
        return;
    }

    if (startBlock->MaximumDiffAreaSpace >= 0) {
        Filter->MaximumVolumeSpace = startBlock->MaximumDiffAreaSpace;
    }

    controlBlockOffset = startBlock->FirstControlBlockVolumeOffset;
    if (!controlBlockOffset || controlBlockOffset < 0 ||
        (controlBlockOffset&(BLOCK_SIZE - 1))) {

        VspResumeVolumeIo(Filter);
        return;
    }

    Filter->FirstControlBlockVolumeOffset = controlBlockOffset;

    controlBlock = (PVSP_BLOCK_CONTROL) buffer;

    diffAreasFound = snapshotsFound = FALSE;
    for (;;) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  controlBlockOffset, 0);
        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                        status, 5, FALSE);
            VspCleanupControlFile(Filter);
            break;
        }

        if (!IsEqualGUID(controlBlock->Header.Signature,
                         VSP_DIFF_AREA_FILE_GUID) ||
            controlBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
            controlBlock->Header.BlockType != VSP_BLOCK_TYPE_CONTROL ||
            controlBlock->Header.ThisVolumeOffset != controlBlockOffset ||
            controlBlock->Header.NextVolumeOffset == controlBlockOffset) {

            VspLogError(NULL, Filter, VS_ABORT_SNAPSHOTS_DURING_DETECTION,
                        STATUS_INVALID_PARAMETER, 6, FALSE);
            VspCleanupControlFile(Filter);
            break;
        }

        for (offset = VSP_BYTES_PER_CONTROL_ITEM; offset < BLOCK_SIZE;
             offset += VSP_BYTES_PER_CONTROL_ITEM) {

            controlItem = (PVSP_CONTROL_ITEM_SNAPSHOT)
                          ((PCHAR) controlBlock + offset);

            if (controlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_END) {
                break;
            }

            if (controlItem->ControlItemType == VSP_CONTROL_ITEM_TYPE_FREE) {
                continue;
            }

            VspCheckCodeLocked(Filter->Root, TRUE);

            if (controlItem->ControlItemType ==
                VSP_CONTROL_ITEM_TYPE_SNAPSHOT &&
                !controlItem->SnapshotOrderNumber) {

                VspLogError(NULL, Filter, VS_PARTIAL_CREATE_REVERTED,
                            STATUS_SUCCESS, 0, FALSE);

                RtlZeroMemory(controlItem, VSP_BYTES_PER_CONTROL_ITEM);
                controlItem->ControlItemType = VSP_CONTROL_ITEM_TYPE_FREE;
                VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                 Filter->TargetObject, IRP_MJ_WRITE,
                                 controlBlockOffset, 0);
                continue;
            }

            status = VspAddControlItemInfoToLookupTable(Filter, controlItem,
                                                        &isComplete);
            if (!NT_SUCCESS(status)) {

                VspLogError(NULL, Filter, VS_LOSS_OF_CONTROL_ITEM, status,
                            0, FALSE);

                RtlZeroMemory(controlItem, VSP_BYTES_PER_CONTROL_ITEM);
                controlItem->ControlItemType = VSP_CONTROL_ITEM_TYPE_FREE;
                VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                 Filter->TargetObject, IRP_MJ_WRITE,
                                 controlBlockOffset, 0);
                continue;
            }

            if (controlItem->ControlItemType ==
                VSP_CONTROL_ITEM_TYPE_SNAPSHOT) {

                snapshotsFound = TRUE;
                if (isComplete) {
                    diffAreasFound = TRUE;
                }
            } else {
                ASSERT(controlItem->ControlItemType ==
                       VSP_CONTROL_ITEM_TYPE_DIFF_AREA);
                diffAreasFound = TRUE;
            }
        }

        controlBlockOffset = controlBlock->Header.NextVolumeOffset;

        if (!controlBlockOffset) {
            break;
        }
    }

    if (snapshotsFound) {
        InterlockedExchange(&Filter->SnapshotDiscoveryPending, TRUE);
        KeResetEvent(&Filter->EndCommitProcessCompleted);
        *NoControlItems = FALSE;
        VspScheduleWriteTrigger(Filter);
    } else {
        VspResumeVolumeIo(Filter);
    }

    if (!diffAreasFound) {
        return;
    }

    *NoControlItems = FALSE;

    for (l = Filter->Root->FilterList.Flink; l != &Filter->Root->FilterList;
         l = l->Flink) {

        f = CONTAINING_RECORD(l, FILTER_EXTENSION, ListEntry);
        if (f->SnapshotDiscoveryPending) {
            if (VspAreSnapshotsComplete(f)) {
                KeAcquireSpinLock(&f->SpinLock, &irql);
                f->ActivateStarted = TRUE;
                if (f->FirstWriteProcessed) {
                    KeReleaseSpinLock(&f->SpinLock, irql);
                    VspPauseVolumeIo(f);
                } else {
                    KeReleaseSpinLock(&f->SpinLock, irql);
                }
                status = VspActivateSnapshots(f);
                InterlockedExchange(&f->SnapshotDiscoveryPending, FALSE);
                if (!NT_SUCCESS(status)) {
                    KeSetEvent(&f->EndCommitProcessCompleted,
                               IO_NO_INCREMENT, FALSE);
                }
                VspResumeVolumeIo(f);
            }
        }
    }
}

VOID
VspLaunchOpenControlBlockFileWorker(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PVSP_CONTEXT    context;
    NTSTATUS        status;

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return;
    }

    ObReferenceObject(Filter->DeviceObject);
    ObReferenceObject(Filter->TargetObject);
    context->Type = VSP_CONTEXT_TYPE_FILTER;
    context->Filter.Filter = Filter;
    ExInitializeWorkItem(&context->WorkItem, VspOpenControlBlockFileWorker,
                         context);
    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

NTSTATUS
VspQueryDeviceName(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    WCHAR               nameBuffer[100];
    UNICODE_STRING      nameString;
    PMOUNTDEV_NAME      name;

    if (!Extension->IsPersistent) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_NAME)) {

        return STATUS_INVALID_PARAMETER;
    }

    swprintf(nameBuffer, L"\\Device\\HarddiskVolumeShadowCopy%d",
             Extension->VolumeNumber);
    RtlInitUnicodeString(&nameString, nameBuffer);

    name = (PMOUNTDEV_NAME) Irp->AssociatedIrp.SystemBuffer;
    name->NameLength = nameString.Length;
    Irp->IoStatus.Information = name->NameLength + sizeof(USHORT);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(name->Name, nameString.Buffer, name->NameLength);

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryUniqueId(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called to query the unique id for this volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_UNIQUE_ID output;

    if (!Extension->IsPersistent) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_UNIQUE_ID)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PMOUNTDEV_UNIQUE_ID) Irp->AssociatedIrp.SystemBuffer;
    output->UniqueIdLength = sizeof(GUID);

    Irp->IoStatus.Information = sizeof(USHORT) + output->UniqueIdLength;

    if (Irp->IoStatus.Information >
        irpSp->Parameters.DeviceIoControl.OutputBufferLength) {

        Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
        return STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory(output->UniqueId, &Extension->SnapshotGuid, sizeof(GUID));

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryStableGuid(
    IN OUT  PVOLUME_EXTENSION   Extension,
    IN OUT  PIRP                Irp
    )

/*++

Routine Description:

    This routine is called to query the stable guid for this volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PMOUNTDEV_STABLE_GUID   output;

    if (!Extension->IsPersistent) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_STABLE_GUID)) {

        return STATUS_INVALID_PARAMETER;
    }

    output = (PMOUNTDEV_STABLE_GUID) Irp->AssociatedIrp.SystemBuffer;
    output->StableGuid = Extension->SnapshotGuid;
    Irp->IoStatus.Information = sizeof(MOUNTDEV_STABLE_GUID);

    return STATUS_SUCCESS;
}

NTSTATUS
VspSetGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION  input = (PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    CHAR                                    controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT              snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;
    NTSTATUS                                status;
    BOOLEAN                                 visible;

    status = VspCheckSecurity(Extension->Filter, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (!Extension->IsPersistent) {
        return STATUS_INVALID_PARAMETER;
    }

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VOLUME_SET_GPT_ATTRIBUTES_INFORMATION)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (input->Reserved1 || input->Reserved2 || input->RevertOnClose ||
        input->ApplyToAllConnectedVolumes) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!(input->GptAttributes&GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER)) {
        return STATUS_INVALID_PARAMETER;
    }

    input->GptAttributes &= ~GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER;

    if (!(input->GptAttributes&GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY)) {
        return STATUS_INVALID_PARAMETER;
    }

    input->GptAttributes &= ~GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY;

    if (input->GptAttributes&GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) {
        visible = FALSE;
    } else {
        visible = TRUE;
    }

    input->GptAttributes &= ~GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;

    if (input->GptAttributes) {
        return STATUS_INVALID_PARAMETER;
    }

    VspAcquire(Extension->Root);

    if (visible == Extension->IsVisible) {
        VspRelease(Extension->Root);
        return STATUS_SUCCESS;
    }

    status = VspIoControlItem(Extension->Filter,
                              VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, FALSE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        VspRelease(Extension->Root);
        return status;
    }

    if (visible) {
        snapshotControlItem->SnapshotControlItemFlags |=
                VSP_SNAPSHOT_CONTROL_ITEM_FLAG_VISIBLE;
    } else {
        snapshotControlItem->SnapshotControlItemFlags &=
                ~VSP_SNAPSHOT_CONTROL_ITEM_FLAG_VISIBLE;
    }

    status = VspIoControlItem(Extension->Filter,
                              VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, TRUE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        VspRelease(Extension->Root);
        return status;
    }

    Extension->IsVisible = visible;

    if (Extension->IsVisible) {
        ASSERT(!Extension->MountedDeviceInterfaceName.Buffer);
        status = IoRegisterDeviceInterface(
                 Extension->DeviceObject,
                 &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                 &Extension->MountedDeviceInterfaceName);
        if (NT_SUCCESS(status)) {
            IoSetDeviceInterfaceState(
                &Extension->MountedDeviceInterfaceName, TRUE);
        }
    } else {
        ASSERT(Extension->MountedDeviceInterfaceName.Buffer);
        IoSetDeviceInterfaceState(&Extension->MountedDeviceInterfaceName,
                                  FALSE);
        ExFreePool(Extension->MountedDeviceInterfaceName.Buffer);
        Extension->MountedDeviceInterfaceName.Buffer = NULL;
    }

    VspRelease(Extension->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspGetGptAttributes(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine returns the current GPT attributes definitions for the volume.

Arguments:

    Extension   - Supplies the volume extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION                      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION  output = (PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    Irp->IoStatus.Information =
            sizeof(VOLUME_GET_GPT_ATTRIBUTES_INFORMATION);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output->GptAttributes = GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER |
                            GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY;

    if (!Extension->IsVisible) {
        output->GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspGetLengthInfo(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PGET_LENGTH_INFORMATION output = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    Irp->IoStatus.Information = sizeof(GET_LENGTH_INFORMATION);

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output->Length.QuadPart = Extension->VolumeSize;

    return STATUS_SUCCESS;
}

VOID
VspDecrementWaitBlock(
    IN  PVOID   WaitBlock
    )

{
    PVSP_WAIT_BLOCK waitBlock = (PVSP_WAIT_BLOCK) WaitBlock;

    if (InterlockedDecrement(&waitBlock->RefCount)) {
        return;
    }

    KeSetEvent(&waitBlock->Event, IO_NO_INCREMENT, FALSE);
}

VOID
VspReleaseTableEntry(
    IN  PTEMP_TRANSLATION_TABLE_ENTRY   TableEntry
    )

{
    PVOLUME_EXTENSION   extension = TableEntry->Extension;
    ULONG               targetBit = (ULONG) (TableEntry->VolumeOffset>>BLOCK_SHIFT);
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;
    PVSP_CONTEXT        context;

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    RtlSetBit(extension->VolumeBlockBitmap, targetBit);
    TableEntry->IsComplete = TRUE;
    KeReleaseSpinLock(&extension->SpinLock, irql);

    while (!IsListEmpty(&TableEntry->WaitingQueueDpc)) {
        l = RemoveHeadList(&TableEntry->WaitingQueueDpc);
        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        context = (PVSP_CONTEXT) workItem->Parameter;
        if (context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT) {
            context->ReadSnapshot.TargetObject = TableEntry->TargetObject;
            context->ReadSnapshot.IsCopyTarget = FALSE;
            context->ReadSnapshot.TargetOffset = TableEntry->TargetOffset;
        }
        workItem->WorkerRoutine(workItem->Parameter);
    }

    VspAcquireNonPagedResource(extension, NULL, FALSE);
    RtlDeleteElementGenericTable(&extension->TempVolumeBlockTable,
                                 TableEntry);
    VspReleaseNonPagedResource(extension);
}

NTSTATUS
VspCopyBlock(
    IN  PVOLUME_EXTENSION   Extension,
    IN  LONGLONG            Source,
    IN  LONGLONG            Target,
    IN  ULONG               Length,
    IN  PIRP                Irp,
    OUT PBOOLEAN            DontDecrement
    )

{
    PFILTER_EXTENSION               filter = Extension->Filter;
    NTSTATUS                        status, status2;
    ULONG                           sourceBit, targetBit;
    KIRQL                           irql;
    PMDL                            mdl;
    TEMP_TRANSLATION_TABLE_ENTRY    keyTableEntry;
    PTEMP_TRANSLATION_TABLE_ENTRY   tableEntry;
    PVOID                           nodeOrParent;
    TABLE_SEARCH_RESULT             searchResult;
    VSP_WAIT_BLOCK                  waitBlock;
    PVSP_WRITE_CONTEXT              writeContext;
    PWORK_QUEUE_ITEM                workItem;
    PIO_STACK_LOCATION              irpSp;
    LONGLONG                        start, end;
    PLIST_ENTRY                     l;
    TRANSLATION_TABLE_ENTRY         key;
    PVOID                           r, r2;
    BOOLEAN                         b;
    LIST_ENTRY                      q;
    PVSP_CONTEXT                    context;
    KEVENT                          event;
    PTRANSLATION_TABLE_ENTRY        sourceBackPointer;
    LONGLONG                        sourceSource;
    PTRANSLATION_TABLE_ENTRY        sourceTableEntry;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    BOOLEAN                         dontNeedWrite;

    *DontDecrement = FALSE;

    status = VspSynchronousIo(Irp, filter->DeviceObject, IRP_MJ_READ,
                              Source, Length);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (Length < BLOCK_SIZE) {
        VspDecrementRefCount(filter);
        status = VspSynchronousIo(Irp, filter->DeviceObject, IRP_MJ_WRITE,
                                  Target, Length);
        InterlockedIncrement(&filter->RefCount);
        if (filter->HoldIncomingWrites || !filter->SnapshotsPresent) {
            *DontDecrement = TRUE;
            VspDecrementRefCount(filter);
            return STATUS_INVALID_PARAMETER;
        }
        return status;
    }

    ASSERT(Length == BLOCK_SIZE);
    ASSERT(!(Source&(BLOCK_SIZE - 1)));
    ASSERT(!(Target&(BLOCK_SIZE - 1)));

    sourceBit = (ULONG) (Source>>BLOCK_SHIFT);
    targetBit = (ULONG) (Target>>BLOCK_SHIFT);

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ASSERT(Extension->VolumeBlockBitmap);
    if (RtlCheckBit(Extension->VolumeBlockBitmap, sourceBit)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        VspDecrementRefCount(filter);
        status = VspSynchronousIo(Irp, filter->DeviceObject, IRP_MJ_WRITE,
                                  Target, Length);
        InterlockedIncrement(&filter->RefCount);
        if (filter->HoldIncomingWrites || !filter->SnapshotsPresent) {
            *DontDecrement = TRUE;
            VspDecrementRefCount(filter);
            return STATUS_INVALID_PARAMETER;
        }
        return status;
    }

    if (RtlCheckBit(Extension->VolumeBlockBitmap, targetBit)) {
        KeReleaseSpinLock(&Extension->SpinLock, irql);
    } else {
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        VspDecrementRefCount(filter);
        mdl = Irp->MdlAddress;
        Irp->MdlAddress = NULL;
        status = VspSynchronousIo(Irp, filter->DeviceObject, IRP_MJ_WRITE,
                                  Target, Length);
        Irp->MdlAddress = mdl;
        InterlockedIncrement(&filter->RefCount);
        if (filter->HoldIncomingWrites || !filter->SnapshotsPresent) {
            *DontDecrement = TRUE;
            VspDecrementRefCount(filter);
            return STATUS_INVALID_PARAMETER;
        }
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    RtlZeroMemory(&keyTableEntry, sizeof(TEMP_TRANSLATION_TABLE_ENTRY));
    keyTableEntry.VolumeOffset = Target;
    keyTableEntry.Extension = Extension;
    keyTableEntry.TargetObject = filter->TargetObject;
    keyTableEntry.TargetOffset = Target;
    InitializeListHead(&keyTableEntry.WaitingQueueDpc);
    keyTableEntry.IsMoveEntry = TRUE;
    keyTableEntry.FileOffset = Source;

    VspAcquireNonPagedResource(Extension, NULL, FALSE);
    tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                 RtlLookupElementGenericTableFull(
                 &Extension->TempVolumeBlockTable, &keyTableEntry,
                 &nodeOrParent, &searchResult);
    if (tableEntry) {
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        tableEntry->WaitEvent = &event;
        VspReleaseNonPagedResource(Extension);

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        VspAcquireNonPagedResource(Extension, NULL, FALSE);

        tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                     RtlLookupElementGenericTableFull(
                     &Extension->TempVolumeBlockTable, &keyTableEntry,
                     &nodeOrParent, &searchResult);
        ASSERT(!tableEntry);
    }

    ASSERT(!Extension->TempTableEntry);
    Extension->TempTableEntry =
            VspAllocateTempTableEntry(Extension->Root);
    if (!Extension->TempTableEntry) {
        VspReleaseNonPagedResource(Extension);
        VspDecrementRefCount(filter);
        status = VspSynchronousIo(Irp, filter->DeviceObject, IRP_MJ_WRITE,
                                  Target, Length);
        InterlockedIncrement(&filter->RefCount);
        if (filter->HoldIncomingWrites || !filter->SnapshotsPresent) {
            *DontDecrement = TRUE;
            VspDecrementRefCount(filter);
            return STATUS_INVALID_PARAMETER;
        }
        return status;
    }

    tableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                 RtlInsertElementGenericTableFull(
                 &Extension->TempVolumeBlockTable, &keyTableEntry,
                 sizeof(TEMP_TRANSLATION_TABLE_ENTRY), NULL,
                 nodeOrParent, searchResult);
    ASSERT(tableEntry);

    InitializeListHead(&tableEntry->WaitingQueueDpc);
    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    RtlClearBit(Extension->VolumeBlockBitmap, targetBit);
    if (Extension->IgnorableProduct) {
        RtlClearBit(Extension->IgnorableProduct, targetBit);
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    VspReleaseNonPagedResource(Extension);

    waitBlock.RefCount = 1;
    KeInitializeEvent(&waitBlock.Event, NotificationEvent, FALSE);

    status = STATUS_SUCCESS;
    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    for (l = Extension->WriteContextList.Flink;
         l != &Extension->WriteContextList; l = l->Flink) {

        writeContext = CONTAINING_RECORD(l, VSP_WRITE_CONTEXT, ListEntry);
        irpSp = IoGetCurrentIrpStackLocation(writeContext->Irp);
        start = irpSp->Parameters.Write.ByteOffset.QuadPart;
        end = start + irpSp->Parameters.Write.Length;
        if (start >= Target + Length || Target >= end) {
            continue;
        }

        workItem = (PWORK_QUEUE_ITEM)
                   ExAllocatePoolWithTag(NonPagedPool, sizeof(WORK_QUEUE_ITEM),
                                         VOLSNAP_TAG_SHORT_TERM);
        if (!workItem) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        InterlockedIncrement(&waitBlock.RefCount);
        ExInitializeWorkItem(workItem, VspDecrementWaitBlock, &waitBlock);
        InsertTailList(&writeContext->CompletionRoutines, &workItem->List);
    }
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (InterlockedDecrement(&waitBlock.RefCount)) {
        KeWaitForSingleObject(&waitBlock.Event, Executive, KernelMode, FALSE,
                              NULL);
    }

    if (!NT_SUCCESS(status)) {
        VspReleaseTableEntry(tableEntry);
        return status;
    }

    status = VspSynchronousIo(Irp, filter->TargetObject, IRP_MJ_WRITE,
                              Target, Length);
    if (!NT_SUCCESS(status)) {
        VspReleaseTableEntry(tableEntry);
        return status;
    }

    RtlZeroMemory(&key, sizeof(TRANSLATION_TABLE_ENTRY));
    key.VolumeOffset = Source;
    key.TargetObject = filter->TargetObject;
    key.Flags = VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY;
    key.TargetOffset = Target;

    VspAcquirePagedResource(Extension, NULL);

    _try {
        sourceBackPointer = (PTRANSLATION_TABLE_ENTRY)
                RtlLookupElementGenericTable(&Extension->CopyBackPointerTable,
                                             &key);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    if (!NT_SUCCESS(status)) {
        VspReleasePagedResource(Extension);
        VspReleaseTableEntry(tableEntry);
        return status;
    }

    if (sourceBackPointer) {
        sourceSource = sourceBackPointer->TargetOffset;

        if (sourceSource == Target) {
            VspReleasePagedResource(Extension);
            VspReleaseTableEntry(tableEntry);
            return STATUS_SUCCESS;
        }

        _try {
            b = RtlDeleteElementGenericTable(&Extension->CopyBackPointerTable,
                                             &key);
            ASSERT(b);
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }

        if (!NT_SUCCESS(status)) {
            VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
            VspReleasePagedResource(Extension);
            VspReleaseTableEntry(tableEntry);
            return status;
        }

        key.VolumeOffset = Target;
        key.TargetOffset = sourceSource;

        _try {
            r2 = RtlInsertElementGenericTable(&Extension->CopyBackPointerTable,
                                              &key, sizeof(key), NULL);
            if (!r2) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            r2 = NULL;
            status = GetExceptionCode();
        }

        if (!r2) {
            VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
            VspReleasePagedResource(Extension);
            VspReleaseTableEntry(tableEntry);
            return status;
        }

        key.VolumeOffset = sourceSource;
        key.TargetOffset = Target;

        _try {
            sourceTableEntry = (PTRANSLATION_TABLE_ENTRY)
                    RtlLookupElementGenericTable(&Extension->VolumeBlockTable,
                                                 &key);
            ASSERT(sourceTableEntry);
            if (!sourceTableEntry) {
                status = STATUS_INVALID_PARAMETER;
            }
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            sourceTableEntry = NULL;
            status = GetExceptionCode();
        }

        if (!sourceTableEntry) {
            VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
            VspReleasePagedResource(Extension);
            VspReleaseTableEntry(tableEntry);
            return status;
        }

        ASSERT(sourceTableEntry->Flags&
               VSP_TRANSLATION_TABLE_ENTRY_FLAG_COPY_ENTRY);
        ASSERT(sourceTableEntry->TargetOffset == Source);
        sourceTableEntry->TargetOffset = Target;

    } else {

        _try {
            r = RtlLookupElementGenericTableFull(&Extension->VolumeBlockTable,
                                                 &key, &nodeOrParent,
                                                 &searchResult);
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            r = (PVOID) 1;
        }

        if (r) {
            VspReleasePagedResource(Extension);
            VspReleaseTableEntry(tableEntry);
            return STATUS_SUCCESS;
        }

        _try {
            r = RtlInsertElementGenericTableFull(&Extension->VolumeBlockTable,
                                                 &key,
                                                 sizeof(TRANSLATION_TABLE_ENTRY),
                                                 NULL, nodeOrParent, searchResult);
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            r = NULL;
        }

        if (!r) {
            VspReleasePagedResource(Extension);
            VspReleaseTableEntry(tableEntry);
            return STATUS_SUCCESS;
        }

        key.VolumeOffset = Target;
        key.TargetOffset = Source;

        _try {
            r2 = RtlInsertElementGenericTable(&Extension->CopyBackPointerTable,
                                              &key,
                                              sizeof(TRANSLATION_TABLE_ENTRY),
                                              NULL);
        } _except (EXCEPTION_EXECUTE_HANDLER) {
            r2 = NULL;
        }

        if (!r2) {
            _try {
                b = RtlDeleteElementGenericTable(&Extension->VolumeBlockTable, r);
            } _except (EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
            }
            if (!b) {
                VspDestroyAllSnapshots(Extension->Filter, NULL, FALSE, FALSE);
            }
            VspReleasePagedResource(Extension);
            VspReleaseTableEntry(tableEntry);
            return STATUS_SUCCESS;
        }
    }

    keyTableEntry.VolumeOffset = Source;

    VspAcquireNonPagedResource(Extension, NULL, FALSE);

    r = RtlLookupElementGenericTable(&Extension->TempVolumeBlockTable,
                                     &keyTableEntry);
    if (!r) {
        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        ASSERT(Extension->VolumeBlockBitmap);
        if (RtlCheckBit(Extension->VolumeBlockBitmap, sourceBit)) {
            r = (PVOID) 1;
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
    }

    diffAreaFile = Extension->DiffAreaFile;

    if (r) {
        VspReleaseNonPagedResource(Extension);

        if (sourceBackPointer) {
            sourceTableEntry->TargetOffset = Source;

            _try {
                b = RtlDeleteElementGenericTable(
                        &Extension->CopyBackPointerTable, r2);
                if (b) {
                    key.VolumeOffset = Source;
                    key.TargetOffset = sourceSource;
                    r = RtlInsertElementGenericTable(
                        &Extension->CopyBackPointerTable, &key, sizeof(key),
                        NULL);
                    b = r ? TRUE : FALSE;
                }
            } _except (EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
            }

        } else {
            _try {
                b = RtlDeleteElementGenericTable(&Extension->VolumeBlockTable,
                                                 r);
                if (b) {
                    b = RtlDeleteElementGenericTable(
                        &Extension->CopyBackPointerTable, r2);
                }
            } _except (EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
            }
        }

        if (!b) {
            VspDestroyAllSnapshots(Extension->Filter, NULL, FALSE, FALSE);
        }

        VspReleasePagedResource(Extension);
        VspReleaseTableEntry(tableEntry);

        return STATUS_SUCCESS;
    }

    KeAcquireSpinLock(&Extension->SpinLock, &irql);
    ASSERT(Extension->VolumeBlockBitmap);
    RtlSetBit(Extension->VolumeBlockBitmap, sourceBit);
    KeReleaseSpinLock(&Extension->SpinLock, irql);

    if (Extension->IsPersistent) {
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        tableEntry->WaitEvent = &event;

        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        InsertTailList(&diffAreaFile->TableUpdateQueue,
                       &tableEntry->TableUpdateListEntry);
        tableEntry->InTableUpdateQueue = TRUE;
        dontNeedWrite = diffAreaFile->TableUpdateInProgress;
        diffAreaFile->TableUpdateInProgress = TRUE;
        KeReleaseSpinLock(&Extension->SpinLock, irql);

        if (!dontNeedWrite) {
            VspWriteTableUpdates(diffAreaFile);
        }

        VspReleaseNonPagedResource(Extension);

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

        VspAcquireNonPagedResource(Extension, NULL, FALSE);
    }

    if (IsListEmpty(&tableEntry->WaitingQueueDpc)) {
        InitializeListHead(&q);
    } else {
        q = tableEntry->WaitingQueueDpc;
        q.Blink->Flink = &q;
        q.Flink->Blink = &q;
    }

    RtlDeleteElementGenericTable(&Extension->TempVolumeBlockTable,
                                 tableEntry);

    VspReleaseNonPagedResource(Extension);
    VspReleasePagedResource(Extension);

    status2 = STATUS_SUCCESS;
    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&tableEntry->WaitingQueueDpc);
        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        context = (PVSP_CONTEXT) workItem->Parameter;
        if (context->Type == VSP_CONTEXT_TYPE_READ_SNAPSHOT) {
            context->ReadSnapshot.TargetObject = tableEntry->TargetObject;
            context->ReadSnapshot.IsCopyTarget = FALSE;
            context->ReadSnapshot.TargetOffset = tableEntry->TargetOffset;
            workItem->WorkerRoutine(workItem->Parameter);
        } else {
            if (NT_SUCCESS(status2)) {
                VspDecrementRefCount(filter);
            }
            mdl = Irp->MdlAddress;
            Irp->MdlAddress = NULL;
            status = VspSynchronousIo(Irp, filter->DeviceObject,
                                      IRP_MJ_WRITE, Target, Length);
            Irp->MdlAddress = mdl;
            if (!NT_SUCCESS(status)) {
                VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
            }
            if (NT_SUCCESS(status2)) {
                InterlockedIncrement(&filter->RefCount);
                if (filter->HoldIncomingWrites || !filter->SnapshotsPresent) {
                    *DontDecrement = TRUE;
                    VspDecrementRefCount(filter);
                    status2 = STATUS_INVALID_PARAMETER;
                }
            }
            workItem->WorkerRoutine(workItem->Parameter);
        }
    }

    return status2;
}

VOID
VspCopyDataWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION           extension = context->Extension.Extension;
    PFILTER_EXTENSION           filter = extension->Filter;
    PIRP                        originalIrp = context->Extension.Irp;
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(originalIrp);
    PDISK_COPY_DATA_PARAMETERS  input = (PDISK_COPY_DATA_PARAMETERS) originalIrp->AssociatedIrp.SystemBuffer;
    PVOID                       buffer = NULL;
    PMDL                        mdl = NULL;
    PIRP                        irp = NULL;
    BOOLEAN                     dontDecrement = FALSE;
    LONGLONG                    sourceStart, sourceEnd, targetStart, targetEnd;
    NTSTATUS                    status;
    ULONG                       delta;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(filter->Root, context);

    buffer = ExAllocatePoolWithTag(NonPagedPool,
                                   BLOCK_SIZE, VOLSNAP_TAG_BUFFER);
    if (!buffer) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);
    if (!mdl) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    irp = IoAllocateIrp(filter->DeviceObject->StackSize, FALSE);
    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Finish;
    }

    MmBuildMdlForNonPagedPool(mdl);
    irp->MdlAddress = mdl;

    sourceStart = input->SourceOffset.QuadPart;
    sourceEnd = sourceStart + input->CopyLength.QuadPart;
    targetStart = input->DestinationOffset.QuadPart;
    targetEnd = targetStart + input->CopyLength.QuadPart;

    ASSERT(sourceStart < sourceEnd);

    status = STATUS_SUCCESS;
    while (sourceStart < sourceEnd) {

        if (sourceStart&(BLOCK_SIZE - 1)) {
            delta = (ULONG) (((sourceStart + BLOCK_SIZE)&(~(BLOCK_SIZE - 1))) -
                             sourceStart);
        } else {
            delta = BLOCK_SIZE;
        }

        if (sourceStart + delta > sourceEnd) {
            delta = (ULONG) (sourceEnd - sourceStart);
        }

        status = VspCopyBlock(extension, sourceStart, targetStart, delta, irp,
                              &dontDecrement);
        if (!NT_SUCCESS(status)) {
            break;
        }

        sourceStart += delta;
        targetStart += delta;
    }

Finish:
    if (irp) {
        IoFreeIrp(irp);
    }
    if (mdl) {
        IoFreeMdl(mdl);
    }
    if (buffer) {
        ExFreePool(buffer);
    }

    if (!dontDecrement) {
        VspDecrementRefCount(filter);
    }

    originalIrp->IoStatus.Information = 0;
    originalIrp->IoStatus.Status = status;
    IoCompleteRequest(originalIrp, IO_NO_INCREMENT);
}

NTSTATUS
VspCopyData(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDISK_COPY_DATA_PARAMETERS  input = (PDISK_COPY_DATA_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;
    LONGLONG                    sourceStart, sourceEnd, targetStart, targetEnd;
    PVOLUME_EXTENSION           extension;
    PVSP_CONTEXT                context;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DISK_COPY_DATA_PARAMETERS)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Filter->IgnoreCopyData || Filter->ProtectedBlocksBitmap) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (input->Reserved || input->CopyLength.QuadPart < BLOCK_SIZE) {
        return STATUS_INVALID_PARAMETER;
    }

    sourceStart = input->SourceOffset.QuadPart;
    sourceEnd = sourceStart + input->CopyLength.QuadPart;
    targetStart = input->DestinationOffset.QuadPart;
    targetEnd = targetStart + input->CopyLength.QuadPart;

    if (sourceStart < 0 || targetStart < 0 ||
        input->CopyLength.QuadPart <= 0) {

        return STATUS_INVALID_PARAMETER;
    }

    if (sourceStart < targetEnd && targetStart < sourceEnd) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!Filter->SnapshotsPresent) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((sourceStart&(BLOCK_SIZE - 1)) != (targetStart&(BLOCK_SIZE - 1))) {
        return STATUS_INVALID_PARAMETER;
    }

    InterlockedIncrement(&Filter->RefCount);
    if (Filter->HoldIncomingWrites || !Filter->SnapshotsPresent) {
        VspDecrementRefCount(Filter);
        return STATUS_INVALID_PARAMETER;
    }

    extension = CONTAINING_RECORD(Filter->VolumeList.Blink, VOLUME_EXTENSION,
                                  ListEntry);

    if (sourceEnd > extension->VolumeSize ||
        targetEnd > extension->VolumeSize) {

        VspDecrementRefCount(Filter);
        return STATUS_INVALID_PARAMETER;
    }

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        VspDecrementRefCount(Filter);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    ExInitializeWorkItem(&context->WorkItem, VspCopyDataWorker, context);
    context->Extension.Extension = extension;
    context->Extension.Irp = Irp;

    IoMarkIrpPending(Irp);

    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);

    return STATUS_PENDING;
}

NTSTATUS
VspQueryEpic(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVOLSNAP_EPIC       output = (PVOLSNAP_EPIC) Irp->AssociatedIrp.SystemBuffer;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(VOLSNAP_EPIC)) {

        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    output->EpicNumber = Filter->EpicNumber;
    Irp->IoStatus.Information = sizeof(VOLSNAP_EPIC);

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryOffline(
    IN  PFILTER_EXTENSION   Filter
    )

/*++

Routine Description:

    This routine returns whether or not the given volume can be taken offline
    without any resulting volume snapshots being deleted.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    STATUS_SUCCESS      - The volume may be taken offline without any
                            snapshots being deleted.
    STATUS_UNSUCCESSFUL - The volume being taken offline will result in the
                            destruction of volume snapshots.

--*/

{
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PVOLUME_EXTENSION   extension;

    VspAcquire(Filter->Root);

    for (l = Filter->DiffAreaFilesOnThisFilter.Flink;
         l != &Filter->DiffAreaFilesOnThisFilter; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         FilterListEntry);
        extension = diffAreaFile->Extension;
        ASSERT(extension);
        ASSERT(extension->Filter);

        if (extension->Filter != Filter &&
            extension->Filter->PreparedSnapshot != extension) {

            VspRelease(Filter->Root);
            return STATUS_UNSUCCESSFUL;
        }
    }

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_DEVICE_CONTROL.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION       filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;
    PVOLUME_EXTENSION       extension;
    KEVENT                  event;
    BOOLEAN                 noControlItems;
    PPARTITION_INFORMATION  partInfo;
    PVSP_CONTEXT            context;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {

        if (filter->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(filter->TargetObject, Irp);
        }

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

            case IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspFlushAndHoldWrites(filter, Irp);
                break;

            case IOCTL_VOLSNAP_RELEASE_WRITES:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspReleaseWrites(filter);
                break;

            case IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspPrepareForSnapshot(filter, Irp);
                break;

            case IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT:
                VspCheckCodeLocked(filter->Root, FALSE);
                VspAcquireCritical(filter);
                status = VspAbortPreparedSnapshot(filter, TRUE, FALSE);
                VspReleaseCritical(filter);
                break;

            case IOCTL_VOLSNAP_COMMIT_SNAPSHOT:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspCommitSnapshot(filter, Irp);
                break;

            case IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT:
                VspCheckCodeLocked(filter->Root, FALSE);
                VspAcquireCritical(filter);
                status = VspEndCommitSnapshot(filter, Irp);
                VspReleaseCritical(filter);
                break;

            case IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS:
            case OLD_IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS:
                status = VspCheckSecurity(filter, Irp);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspQueryNamesOfSnapshots(filter, Irp);
                break;

            case IOCTL_VOLSNAP_CLEAR_DIFF_AREA:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspClearDiffArea(filter, Irp);
                break;

            case IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspAddVolumeToDiffArea(filter, Irp);
                break;

            case IOCTL_VOLSNAP_QUERY_DIFF_AREA:
            case OLD_IOCTL_VOLSNAP_QUERY_DIFF_AREA:
                status = VspCheckSecurity(filter, Irp);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspQueryDiffArea(filter, Irp);
                break;

            case IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspSetMaxDiffAreaSize(filter, Irp);
                break;

            case IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES:
            case OLD_IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES:
                status = VspCheckSecurity(filter, Irp);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspQueryDiffAreaSizes(filter, Irp);
                break;

            case IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT:
            case IOCTL_VOLSNAP_DELETE_SNAPSHOT:
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspDeleteSnapshotPost(filter, Irp);
                break;

            case IOCTL_VOLSNAP_AUTO_CLEANUP:
                status = VspCheckSecurity(filter, Irp);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                VspCheckCodeLocked(filter->Root, FALSE);
                status = VspAutoCleanup(filter, Irp);
                break;

            case IOCTL_VOLSNAP_QUERY_EPIC:
                status = VspQueryEpic(filter, Irp);
                break;

            case IOCTL_VOLSNAP_QUERY_OFFLINE:
                VspCheckCodeLocked(filter->Root, FALSE);
                Irp->IoStatus.Information = 0;
                status = VspQueryOffline(filter);
                break;

            case IOCTL_VOLUME_ONLINE:
                VspAcquireCritical(filter);
                VspAcquire(filter->Root);
                if (filter->IsOnline) {
                    VspRelease(filter->Root);
                    KeInitializeEvent(&event, NotificationEvent, FALSE);
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    IoSetCompletionRoutine(Irp, VspSignalCompletion, &event,
                                           TRUE, TRUE, TRUE);
                    IoCallDriver(filter->TargetObject, Irp);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                          NULL);
                    VspReleaseCritical(filter);
                    status = Irp->IoStatus.Status;
                    break;
                }

                context = VspAllocateContext(filter->Root);
                if (!context) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    VspRelease(filter->Root);
                    VspReleaseCritical(filter);
                    break;
                }

                IoMarkIrpPending(Irp);
                status = STATUS_PENDING;
                context->Type = VSP_CONTEXT_TYPE_FILTER;
                ExInitializeWorkItem(&context->WorkItem, VspOnlineWorker,
                                     context);
                context->Filter.Filter = filter;
                context->Filter.Irp = Irp;
                ExQueueWorkItem(&context->WorkItem, CriticalWorkQueue);
                break;

            case IOCTL_VOLUME_OFFLINE:
                VspAcquireCritical(filter);
                VspAcquire(filter->Root);
                if (!filter->IsOnline) {
                    VspRelease(filter->Root);
                    KeInitializeEvent(&event, NotificationEvent, FALSE);
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    IoSetCompletionRoutine(Irp, VspSignalCompletion, &event,
                                           TRUE, TRUE, TRUE);
                    IoCallDriver(filter->TargetObject, Irp);
                    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                          NULL);
                    VspReleaseCritical(filter);
                    status = Irp->IoStatus.Status;
                    break;
                }

                context = VspAllocateContext(filter->Root);
                if (!context) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    VspRelease(filter->Root);
                    VspReleaseCritical(filter);
                    break;
                }

                IoMarkIrpPending(Irp);
                status = STATUS_PENDING;
                context->Type = VSP_CONTEXT_TYPE_FILTER;
                ExInitializeWorkItem(&context->WorkItem, VspOfflineWorker,
                                     context);
                context->Filter.Filter = filter;
                context->Filter.Irp = Irp;
                ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
                break;

            case IOCTL_DISK_COPY_DATA:
                status = VspCopyData(filter, Irp);
                break;

            default:
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(filter->TargetObject, Irp);

        }

        if (status == STATUS_PENDING) {
            return status;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    extension = (PVOLUME_EXTENSION) filter;

    if (!extension->IsStarted || extension->IsPreExposure) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    status = VspIncrementVolumeRefCount(extension);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME:
        case OLD_IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME:
            status = VspCheckSecurity(extension->Filter, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }
            status = VspQueryOriginalVolumeName(extension, Irp);
            break;

        case IOCTL_VOLSNAP_QUERY_CONFIG_INFO:
        case OLD_IOCTL_VOLSNAP_QUERY_CONFIG_INFO:
            status = VspCheckSecurity(extension->Filter, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }
            status = VspQueryConfigInfo(extension, Irp);
            break;

        case IOCTL_VOLSNAP_SET_APPLICATION_INFO:
            status = VspSetApplicationInfo(extension, Irp);
            break;

        case IOCTL_VOLSNAP_QUERY_APPLICATION_INFO:
        case OLD_IOCTL_VOLSNAP_QUERY_APPLICATION_INFO:
            status = VspCheckSecurity(extension->Filter, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }
            status = VspQueryApplicationInfo(extension, Irp);
            break;

        case IOCTL_VOLSNAP_QUERY_DIFF_AREA:
        case OLD_IOCTL_VOLSNAP_QUERY_DIFF_AREA:
            status = VspCheckSecurity(extension->Filter, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }
            status = VspQueryDiffArea(extension, Irp);
            break;

        case IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES:
        case OLD_IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES:
            status = VspCheckSecurity(extension->Filter, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }
            status = VspQueryDiffAreaSizes(extension, Irp);
            break;

        case IOCTL_DISK_SET_PARTITION_INFO:
            status = STATUS_SUCCESS;
            break;

        case IOCTL_DISK_VERIFY:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        case IOCTL_DISK_CHECK_VERIFY:
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, VspVolumeRefCountCompletionRoutine,
                                   extension, TRUE, TRUE, TRUE);
            IoMarkIrpPending(Irp);

            IoCallDriver(extension->Filter->TargetObject, Irp);

            return STATUS_PENDING;

        case IOCTL_DISK_GET_LENGTH_INFO:
            status = VspGetLengthInfo(extension, Irp);
            break;

        case IOCTL_DISK_GET_PARTITION_INFO:
            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, VspSignalCompletion, &event,
                                   TRUE, TRUE, TRUE);
            IoCallDriver(extension->Filter->TargetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  NULL);

            status = Irp->IoStatus.Status;
            if (!NT_SUCCESS(status)) {
                break;
            }

            partInfo = (PPARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
            partInfo->PartitionLength.QuadPart = extension->VolumeSize;
            break;

        case IOCTL_DISK_IS_WRITABLE:
            status = STATUS_MEDIA_WRITE_PROTECTED;
            break;

        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
            status = VspQueryDeviceName(extension, Irp);
            break;

        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
            status = VspQueryUniqueId(extension, Irp);
            break;

        case IOCTL_MOUNTDEV_QUERY_STABLE_GUID:
            status = VspQueryStableGuid(extension, Irp);
            break;

        case IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE:
            status = STATUS_SUCCESS;
            break;

        case IOCTL_VOLUME_ONLINE:
            if (extension->IsOffline) {
                VspSetOfflineBit(extension, FALSE);
            }
            status = STATUS_SUCCESS;
            break;

        case IOCTL_VOLUME_OFFLINE:
            if (!extension->IsOffline) {
                VspSetOfflineBit(extension, TRUE);
            }
            status = STATUS_SUCCESS;
            break;

        case IOCTL_VOLUME_IS_OFFLINE:
            if (extension->IsOffline) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        case IOCTL_VOLUME_SET_GPT_ATTRIBUTES:
            status = VspSetGptAttributes(extension, Irp);
            break;

        case IOCTL_VOLUME_GET_GPT_ATTRIBUTES:
            status = VspGetGptAttributes(extension, Irp);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

    VspDecrementVolumeRefCount(extension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
VspQueryBusRelations(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    ULONG               numVolumes;
    PLIST_ENTRY         l;
    NTSTATUS            status;
    PDEVICE_RELATIONS   deviceRelations, newRelations;
    ULONG               size, i;
    PVOLUME_EXTENSION   extension;

    if (Filter->SnapshotDiscoveryPending) {
        numVolumes = 0;
    } else {
        numVolumes = 0;
        for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
             l = l->Flink) {

            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            if (l == Filter->VolumeList.Blink &&
                !extension->HasEndCommit && !extension->IsInstalled) {

                continue;
            }
            InterlockedExchange(&extension->AliveToPnp, TRUE);
            numVolumes++;
        }
        if (Filter->PreparedSnapshot &&
            Filter->PreparedSnapshot->IsPreExposure) {

            InterlockedExchange(&Filter->PreparedSnapshot->AliveToPnp, TRUE);
            numVolumes++;
        }
    }

    status = Irp->IoStatus.Status;

    if (!numVolumes) {
        if (NT_SUCCESS(status)) {
            return status;
        }

        newRelations = (PDEVICE_RELATIONS)
                       ExAllocatePoolWithTag(PagedPool,
                                             sizeof(DEVICE_RELATIONS),
                                             VOLSNAP_TAG_RELATIONS);
        if (!newRelations) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(newRelations, sizeof(DEVICE_RELATIONS));
        newRelations->Count = 0;
        Irp->IoStatus.Information = (ULONG_PTR) newRelations;

        while (!IsListEmpty(&Filter->DeadVolumeList)) {
            l = RemoveHeadList(&Filter->DeadVolumeList);
            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            InterlockedExchange(&extension->DeadToPnp, TRUE);
        }

        return STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
        size = FIELD_OFFSET(DEVICE_RELATIONS, Objects) +
               (numVolumes + deviceRelations->Count)*sizeof(PDEVICE_OBJECT);
        newRelations = (PDEVICE_RELATIONS)
                       ExAllocatePoolWithTag(PagedPool, size,
                                             VOLSNAP_TAG_RELATIONS);
        if (!newRelations) {
            for (i = 0; i < deviceRelations->Count; i++) {
                ObDereferenceObject(deviceRelations->Objects[i]);
            }
            ExFreePool(deviceRelations);
            Irp->IoStatus.Information = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        newRelations->Count = numVolumes + deviceRelations->Count;
        RtlCopyMemory(newRelations->Objects, deviceRelations->Objects,
                      deviceRelations->Count*sizeof(PDEVICE_OBJECT));
        i = deviceRelations->Count;
        ExFreePool(deviceRelations);

    } else {

        size = sizeof(DEVICE_RELATIONS) + numVolumes*sizeof(PDEVICE_OBJECT);
        newRelations = (PDEVICE_RELATIONS)
                       ExAllocatePoolWithTag(PagedPool, size,
                                             VOLSNAP_TAG_RELATIONS);
        if (!newRelations) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        newRelations->Count = numVolumes;
        i = 0;
    }

    numVolumes = 0;
    for (l = Filter->VolumeList.Flink; l != &Filter->VolumeList;
         l = l->Flink) {

        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        if (l == Filter->VolumeList.Blink &&
            !extension->HasEndCommit && !extension->IsInstalled) {

            continue;
        }
        newRelations->Objects[i + numVolumes++] = extension->DeviceObject;
        ObReferenceObject(extension->DeviceObject);
    }
    if (Filter->PreparedSnapshot &&
        Filter->PreparedSnapshot->IsPreExposure) {

        newRelations->Objects[i + numVolumes++] =
                Filter->PreparedSnapshot->DeviceObject;
        ObReferenceObject(Filter->PreparedSnapshot->DeviceObject);
    }

    Irp->IoStatus.Information = (ULONG_PTR) newRelations;

    while (!IsListEmpty(&Filter->DeadVolumeList)) {
        l = RemoveHeadList(&Filter->DeadVolumeList);
        extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
        InterlockedExchange(&extension->DeadToPnp, TRUE);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspQueryId(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    UNICODE_STRING      string;
    NTSTATUS            status;
    WCHAR               buffer[100];
    PWSTR               id;

    switch (irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            RtlInitUnicodeString(&string, L"STORAGE\\VolumeSnapshot");
            break;

        case BusQueryHardwareIDs:
            RtlInitUnicodeString(&string, L"STORAGE\\VolumeSnapshot");
            break;

        case BusQueryInstanceID:
            swprintf(buffer, L"HarddiskVolumeSnapshot%d",
                     Extension->DevnodeNumber);
            RtlInitUnicodeString(&string, buffer);
            break;

        default:
            return STATUS_NOT_SUPPORTED;

    }

    id = (PWSTR) ExAllocatePoolWithTag(PagedPool,
                                       string.Length + 2*sizeof(WCHAR),
                                       VOLSNAP_TAG_PNP_ID);
    if (!id) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(id, string.Buffer, string.Length);
    id[string.Length/sizeof(WCHAR)] = 0;
    id[string.Length/sizeof(WCHAR) + 1] = 0;

    Irp->IoStatus.Information = (ULONG_PTR) id;

    return STATUS_SUCCESS;
}

VOID
VspDeleteDiffAreaFilesWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT                    context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION               filter = context->DeleteDiffAreaFiles.Filter;
    NTSTATUS                        status;
    UNICODE_STRING                  name, fileName;
    OBJECT_ATTRIBUTES               oa;
    HANDLE                          h, fileHandle;
    IO_STATUS_BLOCK                 ioStatus;
    PFILE_NAMES_INFORMATION         fileNamesInfo;
    CHAR                            buffer[200];
    FILE_DISPOSITION_INFORMATION    dispInfo;
    BOOLEAN                         restartScan, filesLeft, filesDeleted;
    GUID                            guid;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DELETE_DA_FILES);

    KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    VspAcquireCritical(filter);
    if (filter->DeleteTimer != context->DeleteDiffAreaFiles.Timer) {
        VspReleaseCritical(filter);
        ExFreePool(context->DeleteDiffAreaFiles.Timer);
        ExFreePool(context->DeleteDiffAreaFiles.Dpc);
        VspFreeContext(filter->Root, context);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    KeWaitForSingleObject(&filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    filter->DeleteTimer = NULL;

    ExFreePool(context->DeleteDiffAreaFiles.Timer);
    ExFreePool(context->DeleteDiffAreaFiles.Dpc);
    VspFreeContext(filter->Root, context);

    VspAcquire(filter->Root);
    if (filter->IsRemoved) {
        VspRelease(filter->Root);
        VspReleaseCritical(filter);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    ObReferenceObject(filter->TargetObject);
    VspRelease(filter->Root);

    status = VspCreateDiffAreaFileName(filter->TargetObject, NULL, &name,
                                       FALSE, NULL);

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(filter->TargetObject);
        VspReleaseCritical(filter);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    name.Length -= 39*sizeof(WCHAR);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(filter->TargetObject);
        VspReleaseCritical(filter);
        ObDereferenceObject(filter->DeviceObject);
        ExFreePool(name.Buffer);
        return;
    }

    fileName.Buffer = &name.Buffer[name.Length/sizeof(WCHAR)];
    fileName.Length = 39*sizeof(WCHAR);
    fileName.MaximumLength = fileName.Length + sizeof(WCHAR);

    fileNamesInfo = (PFILE_NAMES_INFORMATION) buffer;
    dispInfo.DeleteFile = TRUE;

    restartScan = TRUE;
    filesLeft = FALSE;
    filesDeleted = FALSE;
    for (;;) {

        status = ZwQueryDirectoryFile(h, NULL, NULL, NULL, &ioStatus,
                                      fileNamesInfo, 200, FileNamesInformation,
                                      TRUE, restartScan ? &fileName : NULL,
                                      restartScan);

        if (!NT_SUCCESS(status)) {
            break;
        }

        restartScan = FALSE;

        fileName.Length = fileName.MaximumLength =
                (USHORT) fileNamesInfo->FileNameLength;
        fileName.Buffer = fileNamesInfo->FileName;

        InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE |
                                   OBJ_KERNEL_HANDLE, h, NULL);

        status = ZwOpenFile(&fileHandle, DELETE, &oa, &ioStatus,
                            FILE_SHARE_DELETE | FILE_SHARE_READ |
                            FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE);
        if (!NT_SUCCESS(status)) {
            filesLeft = TRUE;
            continue;
        }

        filesDeleted = TRUE;

        if (fileName.Buffer[0] == '{') {
            fileName.Length = 38*sizeof(WCHAR);
            status = RtlGUIDFromString(&fileName, &guid);
            if (NT_SUCCESS(status)) {
                VspCheckCodeLocked(filter->Root, FALSE);
                VspDeleteControlItemsWithGuid(filter, &guid, FALSE);
            }
        }

        ZwSetInformationFile(fileHandle, &ioStatus, &dispInfo,
                             sizeof(dispInfo), FileDispositionInformation);

        ZwClose(fileHandle);
    }

    ZwClose(h);
    ExFreePool(name.Buffer);

    if (!filesLeft && filesDeleted) {
        VspAcquireNonPagedResource(filter, NULL, FALSE);
        ASSERT(!filter->ControlBlockFileHandle);
        filter->FirstControlBlockVolumeOffset = 0;
        VspCreateStartBlock(filter, 0, filter->MaximumVolumeSpace);
        VspReleaseNonPagedResource(filter);
    }

    ObDereferenceObject(filter->TargetObject);
    VspReleaseCritical(filter);
    ObDereferenceObject(filter->DeviceObject);
}

NTSTATUS
VspPnpStart(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION       filter = Extension->Filter;
    LONG                    pastReinit;
    NTSTATUS                status;
    DEVICE_INSTALL_STATE    deviceInstallState;
    ULONG                   bytes;
    KIRQL                   irql;
    PVSP_CONTEXT            context;
    PKEVENT                 event;

    if (Extension->IsDead) {
        return STATUS_INVALID_PARAMETER;
    }

    InterlockedExchange(&Extension->IsStarted, TRUE);

    pastReinit = Extension->Root->PastReinit;

    if (pastReinit && !filter->Root->IsSetup) {
        status = IoGetDeviceProperty(Extension->DeviceObject,
                                     DevicePropertyInstallState,
                                     sizeof(deviceInstallState),
                                     &deviceInstallState, &bytes);
        if (!NT_SUCCESS(status) ||
            deviceInstallState != InstallStateInstalled) {

            return STATUS_SUCCESS;
        }
    }

    VspAcquire(Extension->Root);
    if (Extension->IsVisible) {
        ASSERT(!Extension->MountedDeviceInterfaceName.Buffer);
        status = IoRegisterDeviceInterface(
                 Extension->DeviceObject,
                 &MOUNTDEV_MOUNTED_DEVICE_GUID, NULL,
                 &Extension->MountedDeviceInterfaceName);
        if (NT_SUCCESS(status)) {
            IoSetDeviceInterfaceState(
                &Extension->MountedDeviceInterfaceName, TRUE);
        }
    }

    if (Extension->IsInstalled) {
        VspRelease(Extension->Root);
        return STATUS_SUCCESS;
    }

    Extension->IsInstalled = TRUE;

    if (Extension->IsPreExposure) {
        KeSetEvent(&Extension->PreExposureEvent, IO_NO_INCREMENT, FALSE);
        VspRelease(Extension->Root);
        return STATUS_SUCCESS;
    }

    if (Extension->ListEntry.Flink != &filter->VolumeList) {
        KeAcquireSpinLock(&Extension->SpinLock, &irql);
        if (Extension->IgnorableProduct) {
            ExFreePool(Extension->IgnorableProduct->Buffer);
            ExFreePool(Extension->IgnorableProduct);
            Extension->IgnorableProduct = NULL;
        }
        KeReleaseSpinLock(&Extension->SpinLock, irql);
        VspRelease(Extension->Root);
        return STATUS_SUCCESS;
    }

    if (!KeCancelTimer(&filter->EndCommitTimer)) {
        VspRelease(Extension->Root);
        return STATUS_SUCCESS;
    }

    if (filter->IsRemoved) {
        VspRelease(Extension->Root);
        InterlockedExchange(&filter->HibernatePending, FALSE);
        KeSetEvent(&filter->EndCommitProcessCompleted, IO_NO_INCREMENT,
                   FALSE);
        ObDereferenceObject(filter->DeviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    ObReferenceObject(filter->TargetObject);

    VspRelease(Extension->Root);

    context = VspAllocateContext(filter->Root);
    if (!context) {
        InterlockedExchange(&filter->HibernatePending, FALSE);
        KeSetEvent(&filter->EndCommitProcessCompleted, IO_NO_INCREMENT,
                   FALSE);
        ObDereferenceObject(filter->TargetObject);
        ObDereferenceObject(filter->DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ObReferenceObject(Extension->DeviceObject);

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    context->Extension.Extension = Extension;
    context->Extension.Irp = NULL;
    ExInitializeWorkItem(&context->WorkItem,
                         VspSetIgnorableBlocksInBitmapWorker, context);
    VspQueueWorkItem(filter->Root, &context->WorkItem, 0);

    return STATUS_SUCCESS;
}

NTSTATUS
VspGetDeviceObjectPointer(
    IN  PUNICODE_STRING VolumeName,
    IN  ACCESS_MASK     DesiredAccess,
    OUT PFILE_OBJECT*   FileObject,
    OUT PDEVICE_OBJECT* DeviceObject
    )

{
    OBJECT_ATTRIBUTES   oa;
    HANDLE              h;
    PFILE_OBJECT        fileObject;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;

    InitializeObjectAttributes(&oa, VolumeName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, DesiredAccess, &oa, &ioStatus, FILE_SHARE_READ |
                        FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ObReferenceObjectByHandle(h, 0, *IoFileObjectType, KernelMode,
                                       (PVOID *) &fileObject, NULL);
    if (!NT_SUCCESS(status)) {
        ZwClose(h);
        return status;
    }

    *FileObject = fileObject;
    *DeviceObject = IoGetRelatedDeviceObject(fileObject);

    ZwClose(h);

    return status;
}

NTSTATUS
VspTakeSnapshot(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KEVENT                          event;
    PMOUNTDEV_NAME                  name;
    UCHAR                           buffer[512];
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;
    UNICODE_STRING                  volumeName;
    PFILE_OBJECT                    fileObject;
    PDEVICE_OBJECT                  targetObject;
    VOLSNAP_PREPARE_INFO            prepareInfo[2];
    PULONG                          p;
    PIRP                            irp;
    PIO_STACK_LOCATION              irpSp;
    VOLSNAP_FLUSH_AND_HOLD_INPUT    flushInput;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    name = (PMOUNTDEV_NAME) buffer;
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        Filter->TargetObject, NULL, 0,
                                        name, 500, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    volumeName.Buffer = name->Name;
    volumeName.Length = name->NameLength;
    volumeName.MaximumLength = name->NameLength;

    status = VspGetDeviceObjectPointer(&volumeName, FILE_READ_DATA,
                                       &fileObject, &targetObject);
    if (!NT_SUCCESS(status)) {
        if (status != STATUS_FILE_LOCK_CONFLICT) {
            return status;
        }

        // Contention with AUTOCHK.  Open FILE_READ_ATTRIBUTES.
        status = VspGetDeviceObjectPointer(&volumeName, FILE_READ_ATTRIBUTES,
                                           &fileObject, &targetObject);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    RtlZeroMemory(prepareInfo, sizeof(VOLSNAP_PREPARE_INFO));
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    p = (PULONG) (prepareInfo + 1);
    *p = 'NPK ';

    irp = IoBuildDeviceIoControlRequest(
          IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT, targetObject, prepareInfo,
          sizeof(VOLSNAP_PREPARE_INFO) + sizeof(ULONG), NULL, 0, FALSE, &event,
          &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(fileObject);
        return status;
    }

    status = ExUuidCreate(&flushInput.InstanceId);
    if (!NT_SUCCESS(status)) {
        VspAbortPreparedSnapshot(Filter, TRUE, FALSE);
        ObDereferenceObject(fileObject);
        return status;
    }

    flushInput.NumberOfVolumesToFlush = 1;
    flushInput.SecondsToHoldFileSystemsTimeout = 60;
    flushInput.SecondsToHoldIrpsTimeout = 10;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(
          IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES, targetObject, &flushInput,
          sizeof(flushInput), NULL, 0, FALSE, &event, &ioStatus);
    if (!irp) {
        VspAbortPreparedSnapshot(Filter, TRUE, FALSE);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        VspAbortPreparedSnapshot(Filter, TRUE, FALSE);
        ObDereferenceObject(fileObject);
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(
          IOCTL_VOLSNAP_COMMIT_SNAPSHOT, targetObject, NULL, 0, NULL,
          0, FALSE, &event, &ioStatus);
    if (!irp) {
        VspReleaseWrites(Filter);
        VspAbortPreparedSnapshot(Filter, TRUE, FALSE);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    VspReleaseWrites(Filter);

    if (!NT_SUCCESS(status)) {
        VspAbortPreparedSnapshot(Filter, TRUE, FALSE);
        ObDereferenceObject(fileObject);
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(
          IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT, targetObject, NULL, 0, buffer,
          200, FALSE, &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    status = IoCallDriver(targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(fileObject);

    return status;
}

VOID
VspCantHibernatePopUp(
    IN  PFILTER_EXTENSION   Filter
    )

{
    NTSTATUS        status;
    UNICODE_STRING  dosName;

    status = IoVolumeDeviceToDosName(Filter->DeviceObject, &dosName);
    if (NT_SUCCESS(status)) {
        IoRaiseInformationalHardError(STATUS_VOLSNAP_PREPARE_HIBERNATE,
                                      &dosName, NULL);
        ExFreePool(dosName.Buffer);
    }

    InterlockedExchange(&Filter->HibernatePending, TRUE);

    status = VspTakeSnapshot(Filter);
    if (!NT_SUCCESS(status)) {
        InterlockedExchange(&Filter->HibernatePending, FALSE);
    }
}

NTSTATUS
VspCompareFileIds(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PUNICODE_STRING     FileName
    )

{
    PFILTER_EXTENSION               filter = Extension->Filter;
    KEVENT                          event;
    PMOUNTDEV_NAME                  name;
    UCHAR                           buffer[512];
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;
    UNICODE_STRING                  dirName;
    OBJECT_ATTRIBUTES               oa;
    HANDLE                          h;
    PFILE_ID_FULL_DIR_INFORMATION   fileIdDirInfo;
    LARGE_INTEGER                   fileId1, fileId2;
    PWCHAR                          wstring;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    name = (PMOUNTDEV_NAME) buffer;
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        filter->TargetObject, NULL, 0,
                                        name, 500, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    dirName.Length = name->NameLength;
    dirName.Buffer = name->Name;
    dirName.Buffer[dirName.Length/sizeof(WCHAR)] = '\\';
    dirName.Length += sizeof(WCHAR);
    dirName.Buffer[dirName.Length/sizeof(WCHAR)] = 0;
    dirName.MaximumLength = dirName.Length + sizeof(WCHAR);

    InitializeObjectAttributes(&oa, &dirName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, &oa,
                        &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    fileIdDirInfo = (PFILE_ID_FULL_DIR_INFORMATION) buffer;
    status = ZwQueryDirectoryFile(h, NULL, NULL, NULL, &ioStatus,
                                  fileIdDirInfo, 512,
                                  FileIdFullDirectoryInformation,
                                  TRUE, FileName, TRUE);
    ZwClose(h);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    fileId1 = fileIdDirInfo->FileId;

    if (Extension->IsOffline) {
        VspSetOfflineBit(Extension, FALSE);
    }

    wstring = (PWCHAR) buffer;
    swprintf(wstring, L"\\Device\\HarddiskVolumeShadowCopy%d\\",
             Extension->VolumeNumber);
    RtlInitUnicodeString(&dirName, wstring);

    InitializeObjectAttributes(&oa, &dirName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, &oa,
                        &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    fileIdDirInfo = (PFILE_ID_FULL_DIR_INFORMATION) buffer;
    status = ZwQueryDirectoryFile(h, NULL, NULL, NULL, &ioStatus,
                                  fileIdDirInfo, 512,
                                  FileIdFullDirectoryInformation,
                                  TRUE, FileName, TRUE);
    ZwClose(h);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    fileId2 = fileIdDirInfo->FileId;

    if (fileId1.QuadPart != fileId2.QuadPart) {
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspMarkCrashdumpDirty(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    NTSTATUS                    status;
    CHAR                        controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT  snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;

    status = VspIoControlItem(Extension->Filter,
                              VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, FALSE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    snapshotControlItem->SnapshotControlItemFlags |=
            VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_CRASHDUMP;

    status = VspIoControlItem(Extension->Filter,
                              VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &Extension->SnapshotGuid, TRUE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    return STATUS_SUCCESS;
}

VOID
VspTakeSnapshotWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;
    NTSTATUS            status;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_FILTER);
    VspFreeContext(filter->Root, context);

    status = VspTakeSnapshot(filter);
    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, filter, VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES,
                    status, 16, FALSE);
        VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
    }

    ObDereferenceObject(filter->DeviceObject);
}

NTSTATUS
VspHandleDumpUsageNotification(
    IN  PFILTER_EXTENSION   Filter,
    IN  BOOLEAN             InPath
    )

{
    PVOLUME_EXTENSION   extension;
    UNICODE_STRING      fileName;
    NTSTATUS            status;
    PVSP_CONTEXT        context;

    VspAcquire(Filter->Root);

    if (!InPath) {
        Filter->UsedForCrashdump = FALSE;
        VspRelease(Filter->Root);
        return STATUS_SUCCESS;
    }

    if (Filter->UsedForCrashdump) {
        VspRelease(Filter->Root);
        return STATUS_SUCCESS;
    }

    Filter->UsedForCrashdump = TRUE;

    if (!Filter->SnapshotsPresent || !Filter->PersistentSnapshots ||
        IsListEmpty(&Filter->VolumeList)) {

        VspRelease(Filter->Root);
        return STATUS_SUCCESS;
    }

    extension = CONTAINING_RECORD(Filter->VolumeList.Blink, VOLUME_EXTENSION,
                                  ListEntry);
    ASSERT(extension->IsPersistent);
    ObReferenceObject(extension->DeviceObject);
    VspRelease(Filter->Root);

    if (extension->PageFileCopied) {
        RtlInitUnicodeString(&fileName, L"pagefile.sys");
        status = VspCompareFileIds(extension, &fileName);
        if (!NT_SUCCESS(status)) {
            InterlockedExchange(&extension->PageFileCopied, FALSE);
        }
    }

    if (!extension->PageFileCopied) {
        status = VspMarkCrashdumpDirty(extension);
        if (NT_SUCCESS(status)) {
            context = VspAllocateContext(Filter->Root);
            if (context) {
                context->Type = VSP_CONTEXT_TYPE_FILTER;
                ExInitializeWorkItem(&context->WorkItem, VspTakeSnapshotWorker,
                                     context);
                context->Filter.Filter = Filter;
                ObReferenceObject(Filter->DeviceObject);
                ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (!NT_SUCCESS(status)) {
            VspLogError(NULL, Filter, VS_ABORT_COPY_ON_WRITE_CRASHDUMP_FILES,
                        status, 6, FALSE);
            VspDestroyAllSnapshots(Filter, NULL, FALSE, FALSE);
        }
    }

    ObDereferenceObject(extension->DeviceObject);

    return STATUS_SUCCESS;
}

VOID
VspCleanupFilterWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_FILTER);
    VspFreeContext(filter->Root, context);

    VspAcquireCritical(filter);
    VspAcquire(filter->Root);
    VspCleanupPreamble(filter);
    VspRelease(filter->Root);
    VspCleanupFilter(filter, FALSE, TRUE);
    VspReleaseCritical(filter);

    ObDereferenceObject(filter->TargetObject);
    ObDereferenceObject(filter->DeviceObject);
}

VOID
VspPostCleanupFilter(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PVSP_CONTEXT    context;

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_FILTER;
    ExInitializeWorkItem(&context->WorkItem, VspCleanupFilterWorker, context);
    context->Filter.Filter = Filter;

    ObReferenceObject(Filter->DeviceObject);
    ObReferenceObject(Filter->TargetObject);

    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

NTSTATUS
VolSnapPnp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION       filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT          targetObject;
    KEVENT                  event;
    NTSTATUS                status;
    PVOLUME_EXTENSION       extension;
    BOOLEAN                 deletePdo;
    PDEVICE_RELATIONS       deviceRelations;
    PDEVICE_CAPABILITIES    capabilities;
    PKEVENT                 pevent;
    PLONG                   p;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {

        if (filter->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {

            targetObject = filter->TargetObject;

            switch (irpSp->MinorFunction) {
                case IRP_MN_REMOVE_DEVICE:
                    VspAcquire(filter->Root);
                    if (!filter->NotInFilterList) {
                        RemoveEntryList(&filter->ListEntry);
                        filter->NotInFilterList = TRUE;
                    }
                    VspRelease(filter->Root);

                    IoDetachDevice(targetObject);
                    IoDeleteDevice(filter->DeviceObject);

                    //
                    // Fall through.
                    //

                case IRP_MN_START_DEVICE:
                case IRP_MN_QUERY_REMOVE_DEVICE:
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                case IRP_MN_STOP_DEVICE:
                case IRP_MN_QUERY_STOP_DEVICE:
                case IRP_MN_CANCEL_STOP_DEVICE:
                case IRP_MN_SURPRISE_REMOVAL:
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            }

            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(targetObject, Irp);
        }

        switch (irpSp->MinorFunction) {

            case IRP_MN_REMOVE_DEVICE:
            case IRP_MN_SURPRISE_REMOVAL:
                targetObject = filter->TargetObject;

                if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                    VspPostCleanupFilter(filter);
                    IoDetachDevice(targetObject);
                    IoDeleteDevice(filter->DeviceObject);
                } else {
                    VspAcquireCritical(filter);
                    VspAcquire(filter->Root);
                    VspCleanupPreamble(filter);
                    VspRelease(filter->Root);
                    VspCleanupFilter(filter, FALSE, FALSE);
                    VspReleaseCritical(filter);
                }

                Irp->IoStatus.Status = STATUS_SUCCESS;

                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(targetObject, Irp);

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                switch (irpSp->Parameters.QueryDeviceRelations.Type) {
                    case BusRelations:
                        break;

                    default:
                        IoSkipCurrentIrpStackLocation(Irp);
                        return IoCallDriver(filter->TargetObject, Irp);
                }

                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, VspSignalCompletion,
                                       &event, TRUE, TRUE, TRUE);
                IoCallDriver(filter->TargetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                VspAcquire(filter->Root);
                switch (irpSp->Parameters.QueryDeviceRelations.Type) {
                    case BusRelations:
                        status = VspQueryBusRelations(filter, Irp);
                        break;

                }
                VspRelease(filter->Root);
                break;

            case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                KeInitializeEvent(&event, NotificationEvent, FALSE);
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp, VspSignalCompletion,
                                       &event, TRUE, TRUE, TRUE);
                IoCallDriver(filter->TargetObject, Irp);
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                      NULL);

                status = Irp->IoStatus.Status;

                if (!NT_SUCCESS(status)) {
                    break;
                }

                switch (irpSp->Parameters.UsageNotification.Type) {
                    case DeviceUsageTypePaging:
                        if (irpSp->Parameters.UsageNotification.InPath) {
                            InterlockedExchange(&filter->UsedForPaging, TRUE);
                        } else {
                            InterlockedExchange(&filter->UsedForPaging, FALSE);
                        }
                        break;

                    case DeviceUsageTypeDumpFile:
                        status = VspHandleDumpUsageNotification(filter,
                                 irpSp->Parameters.UsageNotification.InPath);
                        break;

                }
                break;

            case IRP_MN_START_DEVICE:
            case IRP_MN_QUERY_REMOVE_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:
            case IRP_MN_STOP_DEVICE:
            case IRP_MN_QUERY_STOP_DEVICE:
            case IRP_MN_CANCEL_STOP_DEVICE:

                Irp->IoStatus.Status = STATUS_SUCCESS;

                //
                // Fall through.
                //

            default:
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(filter->TargetObject, Irp);

        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);
    extension = (PVOLUME_EXTENSION) filter;

    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
            status = VspPnpStart(extension);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            if (extension->Root->IsSetup) {
                status = STATUS_INVALID_DEVICE_REQUEST;
            } else {
                status = STATUS_SUCCESS;
            }
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL:
            InterlockedExchange(&extension->IsStarted, FALSE);

            VspAcquire(extension->Root);

            if (extension->MountedDeviceInterfaceName.Buffer) {
                IoSetDeviceInterfaceState(
                        &extension->MountedDeviceInterfaceName, FALSE);
                ExFreePool(extension->MountedDeviceInterfaceName.Buffer);
                extension->MountedDeviceInterfaceName.Buffer = NULL;
            }

            VspRelease(extension->Root);

            if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                if (extension->DeadToPnp && !extension->DeviceDeleted) {
                    InterlockedExchange(&extension->DeviceDeleted, TRUE);
                    deletePdo = TRUE;
                } else {
                    deletePdo = FALSE;
                }
            } else {
                deletePdo = FALSE;
            }

            if (deletePdo) {
                VspAcquire(extension->Root);
                RtlDeleteElementGenericTable(
                        &extension->Root->UsedDevnodeNumbers,
                        &extension->DevnodeNumber);
                VspRelease(extension->Root);
                IoDeleteDevice(extension->DeviceObject);
            }
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            if (irpSp->Parameters.QueryDeviceRelations.Type !=
                TargetDeviceRelation) {

                status = STATUS_NOT_SUPPORTED;
                break;
            }

            deviceRelations = (PDEVICE_RELATIONS)
                              ExAllocatePoolWithTag(PagedPool,
                                                    sizeof(DEVICE_RELATIONS),
                                                    VOLSNAP_TAG_RELATIONS);
            if (!deviceRelations) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            ObReferenceObject(DeviceObject);
            deviceRelations->Count = 1;
            deviceRelations->Objects[0] = DeviceObject;
            Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            capabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
            capabilities->SilentInstall = 1;
            capabilities->SurpriseRemovalOK = 1;
            capabilities->RawDeviceOK = 1;
            capabilities->UniqueID = 1;
            capabilities->Address = extension->VolumeNumber;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_ID:
            status = VspQueryId(extension, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Irp->IoStatus.Information = PNP_DEVICE_DONT_DISPLAY_IN_UI;
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            status = STATUS_NOT_SUPPORTED;
            break;

    }

    if (status == STATUS_NOT_SUPPORTED) {
        status = Irp->IoStatus.Status;
    } else {
        Irp->IoStatus.Status = status;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
VspWorkerThread(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This is a worker thread to process work queue items.

Arguments:

    RootExtension   - Supplies the root device extension.

Return Value:

    None.

--*/

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PDO_EXTENSION       rootExtension = context->ThreadCreation.RootExtension;
    ULONG               queueNumber = context->ThreadCreation.QueueNumber;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    queueItem;

    ASSERT(queueNumber < NUMBER_OF_THREAD_POOLS);
    ASSERT(context->Type == VSP_CONTEXT_TYPE_THREAD_CREATION);

    VspFreeContext(rootExtension, context);

    if (!queueNumber) {
        KeSetPriorityThread(KeGetCurrentThread(), VSP_HIGH_PRIORITY);
    }

    for (;;) {

        KeWaitForSingleObject(&rootExtension->WorkerSemaphore[queueNumber],
                              Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&rootExtension->SpinLock[queueNumber], &irql);
        if (IsListEmpty(&rootExtension->WorkerQueue[queueNumber])) {
            KeReleaseSpinLock(&rootExtension->SpinLock[queueNumber], irql);
            ASSERT(!rootExtension->ThreadsRefCount);
            PsTerminateSystemThread(STATUS_SUCCESS);
            return;
        }
        l = RemoveHeadList(&rootExtension->WorkerQueue[queueNumber]);
        KeReleaseSpinLock(&rootExtension->SpinLock[queueNumber], irql);

        queueItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        queueItem->WorkerRoutine(queueItem->Parameter);
    }
}

NTSTATUS
VspAddChainToBitmap(
    IN      PFILTER_EXTENSION   Filter,
    IN      LONGLONG            ChainOffset,
    IN OUT  PRTL_BITMAP         Bitmap
    )

{
    PVSP_BLOCK_HEADER   header;
    NTSTATUS            status;

    header = (PVSP_BLOCK_HEADER)
             MmGetMdlVirtualAddress(Filter->SnapshotOnDiskIrp->MdlAddress);

    while (ChainOffset) {

        status = VspSynchronousIo(Filter->SnapshotOnDiskIrp,
                                  Filter->TargetObject, IRP_MJ_READ,
                                  ChainOffset, 0);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!IsEqualGUID(header->Signature, VSP_DIFF_AREA_FILE_GUID) ||
            header->Version != VOLSNAP_PERSISTENT_VERSION ||
            header->ThisVolumeOffset != ChainOffset ||
            header->NextVolumeOffset == ChainOffset) {

            return STATUS_INVALID_PARAMETER;
        }

        RtlSetBit(Bitmap, (ULONG) (ChainOffset>>BLOCK_SHIFT));

        ChainOffset = header->NextVolumeOffset;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VspProtectDiffAreaClusters(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PRTL_BITMAP                     bitmap;
    ULONG                           bitmapSize;
    PVOID                           bitmapBuffer;
    NTSTATUS                        status;
    PLIST_ENTRY                     l, ll;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    PVOLUME_EXTENSION               extension;
    PDIFF_AREA_FILE_ALLOCATION      diffAreaFileAllocation;
    PTEMP_TRANSLATION_TABLE_ENTRY   tempTableEntry;
    PTRANSLATION_TABLE_ENTRY        tableEntry;
    KIRQL                           irql;

    VspAcquireCritical(Filter);
    Filter->DeleteTimer = NULL;
    VspReleaseCritical(Filter);

    InterlockedExchange(&Filter->Root->VolumesSafeForWriteAccess, TRUE);

    KeWaitForSingleObject(&Filter->EndCommitProcessCompleted, Executive,
                          KernelMode, FALSE, NULL);

    bitmap = (PRTL_BITMAP) ExAllocatePoolWithTag(NonPagedPool,
                                                 sizeof(RTL_BITMAP),
                                                 VOLSNAP_TAG_BITMAP);
    if (!bitmap) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    bitmapSize = (ULONG)
                 ((VspQueryVolumeSize(Filter) + BLOCK_SIZE - 1)>>BLOCK_SHIFT);
    if (!bitmapSize) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    bitmapBuffer = ExAllocatePoolWithTag(NonPagedPool,
                   (bitmapSize + 8*sizeof(ULONG) - 1)/
                   (8*sizeof(ULONG))*sizeof(ULONG), VOLSNAP_TAG_BITMAP);
    if (!bitmapBuffer) {
        ExFreePool(bitmap);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitializeBitMap(bitmap, (PULONG) bitmapBuffer, bitmapSize);
    RtlClearAllBits(bitmap);

    VspAcquire(Filter->Root);

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    if (Filter->FirstControlBlockVolumeOffset) {
        status = VspAddChainToBitmap(Filter,
                                     Filter->FirstControlBlockVolumeOffset,
                                     bitmap);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            VspRelease(Filter->Root);
            ExFreePool(bitmapBuffer);
            ExFreePool(bitmap);
            return status;
        }
    }

    VspReleaseNonPagedResource(Filter);

    for (l = Filter->DiffAreaFilesOnThisFilter.Flink;
         l != &Filter->DiffAreaFilesOnThisFilter; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         FilterListEntry);
        if (!diffAreaFile->Extension->IsPersistent) {
            continue;
        }

        extension = diffAreaFile->Extension;

        VspAcquireNonPagedResource(Filter, NULL, FALSE);

        ASSERT(diffAreaFile->ApplicationInfoTargetOffset);
        status = VspAddChainToBitmap(Filter, diffAreaFile->
                                     ApplicationInfoTargetOffset, bitmap);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            VspRelease(Filter->Root);
            ExFreePool(bitmapBuffer);
            ExFreePool(bitmap);
            return status;
        }

        ASSERT(diffAreaFile->DiffAreaLocationDescriptionTargetOffset);
        status = VspAddChainToBitmap(Filter, diffAreaFile->
                                     DiffAreaLocationDescriptionTargetOffset,
                                     bitmap);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            VspRelease(Filter->Root);
            ExFreePool(bitmapBuffer);
            ExFreePool(bitmap);
            return status;
        }

        if (diffAreaFile->InitialBitmapVolumeOffset) {
            status = VspAddChainToBitmap(Filter, diffAreaFile->
                                         InitialBitmapVolumeOffset, bitmap);
            if (!NT_SUCCESS(status)) {
                VspReleaseNonPagedResource(Filter);
                VspRelease(Filter->Root);
                ExFreePool(bitmapBuffer);
                ExFreePool(bitmap);
                return status;
            }
        }

        ASSERT(diffAreaFile->FirstTableTargetOffset);
        status = VspAddChainToBitmap(Filter, diffAreaFile->
                                     FirstTableTargetOffset, bitmap);
        if (!NT_SUCCESS(status)) {
            VspReleaseNonPagedResource(Filter);
            VspRelease(Filter->Root);
            ExFreePool(bitmapBuffer);
            ExFreePool(bitmap);
            return status;
        }

        VspReleaseNonPagedResource(Filter);

        VspAcquireNonPagedResource(extension, NULL, FALSE);

        for (ll = diffAreaFile->UnusedAllocationList.Flink;
             ll != &diffAreaFile->UnusedAllocationList; ll = ll->Flink) {

            diffAreaFileAllocation = CONTAINING_RECORD(ll,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);

            if (diffAreaFileAllocation->NLength <= 0) {
                continue;
            }

            ASSERT((diffAreaFileAllocation->NLength&(BLOCK_SIZE - 1)) == 0);

            RtlSetBits(bitmap,
                       (ULONG) (diffAreaFileAllocation->Offset>>BLOCK_SHIFT),
                       (ULONG) (diffAreaFileAllocation->NLength>>BLOCK_SHIFT));
        }

        tempTableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                         RtlEnumerateGenericTable(
                         &extension->TempVolumeBlockTable, TRUE);
        while (tempTableEntry) {

            if (!tempTableEntry->IsMoveEntry && tempTableEntry->TargetOffset) {
                RtlSetBit(bitmap,
                          (ULONG) (tempTableEntry->TargetOffset>>BLOCK_SHIFT));
            }

            tempTableEntry = (PTEMP_TRANSLATION_TABLE_ENTRY)
                             RtlEnumerateGenericTable(
                             &extension->TempVolumeBlockTable, FALSE);
        }

        VspReleaseNonPagedResource(extension);

        status = STATUS_SUCCESS;
        VspAcquirePagedResource(extension, NULL);
        _try {

            tableEntry = (PTRANSLATION_TABLE_ENTRY)
                         RtlEnumerateGenericTable(
                         &extension->VolumeBlockTable, TRUE);
            while (tableEntry) {

                if (!tableEntry->Flags) {
                    RtlSetBit(bitmap, (
                              ULONG) (tableEntry->TargetOffset>>BLOCK_SHIFT));
                }

                tableEntry = (PTRANSLATION_TABLE_ENTRY)
                             RtlEnumerateGenericTable(
                             &extension->VolumeBlockTable, FALSE);
            }

        } _except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }
        VspReleasePagedResource(extension);

        if (!NT_SUCCESS(status)) {
            VspRelease(Filter->Root);
            ExFreePool(bitmapBuffer);
            ExFreePool(bitmap);
            return status;
        }
    }

    VspPauseVolumeIo(Filter);

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    InterlockedExchangePointer((PVOID*) &Filter->ProtectedBlocksBitmap,
                               bitmap);
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    VspResumeVolumeIo(Filter);

    VspRelease(Filter->Root);

    return STATUS_SUCCESS;
}

NTSTATUS
VspOpenAndValidateDiffAreaFiles(
    IN  PFILTER_EXTENSION   Filter
    )

{
    NTSTATUS            status;
    PVOID               buffer;
    PVSP_BLOCK_START    startBlock;
    HANDLE              h, hh;
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    UNICODE_STRING      fileName;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     ioStatus;
    BOOLEAN             checkUnused;
    PVOLUME_EXTENSION   extension;
    PVSP_CONTEXT        context;
    KIRQL               irql;

    h = InterlockedExchangePointer(&Filter->ControlBlockFileHandle, NULL);
    if (h) {
        ZwClose(h);
    }

    if (!Filter->FirstControlBlockVolumeOffset) {
        return STATUS_SUCCESS;
    }

    status = VspOpenControlBlockFile(Filter);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    status = VspSynchronousIo(Filter->SnapshotOnDiskIrp, Filter->TargetObject,
                              IRP_MJ_READ, 0, 0);
    if (!NT_SUCCESS(status)) {
        VspReleaseNonPagedResource(Filter);
        return status;
    }

    buffer = MmGetMdlVirtualAddress(Filter->SnapshotOnDiskIrp->MdlAddress);
    if (!VspIsNtfsBootSector(Filter, buffer)) {
        VspReleaseNonPagedResource(Filter);
        return STATUS_INVALID_PARAMETER;
    }

    startBlock = (PVSP_BLOCK_START) ((PCHAR) buffer + VSP_START_BLOCK_OFFSET);
    if (!IsEqualGUID(startBlock->Header.Signature, VSP_DIFF_AREA_FILE_GUID) ||
        startBlock->Header.Version != VOLSNAP_PERSISTENT_VERSION ||
        startBlock->Header.BlockType != VSP_BLOCK_TYPE_START) {

        VspReleaseNonPagedResource(Filter);
        return STATUS_INVALID_PARAMETER;
    }

    VspReleaseNonPagedResource(Filter);

    h = VspPinBootStat(Filter);

    if (h) {
        hh = InterlockedExchangePointer(&Filter->BootStatHandle, h);
        if (hh) {
            ZwClose(hh);
        }
    }

    VspAcquire(Filter->Root);

    for (l = Filter->DiffAreaFilesOnThisFilter.Flink;
         l != &Filter->DiffAreaFilesOnThisFilter; l = l->Flink) {

        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         FilterListEntry);
        diffAreaFile->ValidateHandleNeeded = TRUE;
    }

    VspRelease(Filter->Root);

    for (;;) {

        VspAcquire(Filter->Root);

        for (l = Filter->DiffAreaFilesOnThisFilter.Flink;
             l != &Filter->DiffAreaFilesOnThisFilter; l = l->Flink) {

            diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                             FilterListEntry);
            if (diffAreaFile->ValidateHandleNeeded) {
                diffAreaFile->ValidateHandleNeeded = FALSE;
                break;
            }
        }

        if (l == &Filter->DiffAreaFilesOnThisFilter) {
            VspRelease(Filter->Root);
            break;
        }

        extension = diffAreaFile->Extension;

        status = VspIncrementVolumeRefCount(extension);
        if (!NT_SUCCESS(status)) {
            VspRelease(Filter->Root);
            continue;
        }

        VspRelease(Filter->Root);

        status = VspCreateDiffAreaFileName(Filter->TargetObject, extension,
                                           &fileName, FALSE, NULL);
        if (!NT_SUCCESS(status)) {
            VspDecrementVolumeRefCount(extension);
            return status;
        }

        ZwClose(diffAreaFile->FileHandle);

        InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE |
                                   OBJ_KERNEL_HANDLE, NULL, NULL);

        status = ZwOpenFile(&h, FILE_GENERIC_READ | FILE_GENERIC_WRITE, &oa,
                            &ioStatus, 0, FILE_WRITE_THROUGH |
                            FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE |
                            FILE_NO_COMPRESSION);
        ExFreePool(fileName.Buffer);

        if (!NT_SUCCESS(status)) {
            VspAcquire(Filter->Root);
            diffAreaFile->FileHandle = NULL;
            VspRelease(Filter->Root);
            VspDecrementVolumeRefCount(extension);
            return status;
        }

        status = VspPinFile(Filter->TargetObject, h);

        if (!NT_SUCCESS(status)) {
            ZwClose(h);
            VspAcquire(Filter->Root);
            diffAreaFile->FileHandle = NULL;
            VspRelease(Filter->Root);
            VspDecrementVolumeRefCount(extension);
            return status;
        }

        KeAcquireSpinLock(&extension->Filter->SpinLock, &irql);
        if (extension->ListEntry.Flink == &extension->Filter->VolumeList) {
            checkUnused = TRUE;
        } else {
            checkUnused = FALSE;
        }
        KeReleaseSpinLock(&extension->Filter->SpinLock, irql);

        status = VspCheckDiffAreaFileLocation(
                 Filter, h, diffAreaFile->ApplicationInfoTargetOffset,
                 diffAreaFile->FirstTableTargetOffset,
                 diffAreaFile->DiffAreaLocationDescriptionTargetOffset,
                 diffAreaFile->InitialBitmapVolumeOffset, checkUnused);
        if (!NT_SUCCESS(status)) {
            ZwClose(h);
            VspAcquire(Filter->Root);
            diffAreaFile->FileHandle = NULL;
            VspRelease(Filter->Root);
            VspDecrementVolumeRefCount(extension);
            return status;
        }

        InterlockedExchangePointer(&diffAreaFile->FileHandle, h);

        if (InterlockedExchange(&extension->GrowFailed, FALSE)) {
            context = VspAllocateContext(extension->Root);
            if (context) {
                KeAcquireSpinLock(&extension->SpinLock, &irql);
                ASSERT(!extension->GrowDiffAreaFilePending);
                ASSERT(IsListEmpty(&extension->WaitingForDiffAreaSpace));
                extension->GrowDiffAreaFilePending = TRUE;
                extension->PastFileSystemOperations = FALSE;
                KeReleaseSpinLock(&extension->SpinLock, irql);

                context->Type = VSP_CONTEXT_TYPE_GROW_DIFF_AREA;
                ExInitializeWorkItem(&context->WorkItem, VspGrowDiffArea,
                                     context);
                context->GrowDiffArea.Extension = extension;
                ObReferenceObject(extension->DeviceObject);

                ASSERT(extension->OkToGrowDiffArea);

                VspQueueWorkItem(extension->Root, &context->WorkItem, 0);
            }
        }

        VspDecrementVolumeRefCount(extension);
    }

    return STATUS_SUCCESS;
}

BOOLEAN
VspIsFileSystemLocked(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KEVENT              event;
    PMOUNTDEV_NAME      name;
    CHAR                buffer[512];
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    UNICODE_STRING      volumeName;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              h;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    name = (PMOUNTDEV_NAME) buffer;
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        Filter->TargetObject, NULL, 0,
                                        name, 500, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return FALSE;
    }

    status = IoCallDriver(Filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    volumeName.Length = volumeName.MaximumLength = name->NameLength;
    volumeName.Buffer = name->Name;

    InitializeObjectAttributes(&oa, &volumeName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_GENERIC_READ, &oa, &ioStatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (NT_SUCCESS(status)) {
        ZwClose(h);
    }

    if (status == STATUS_ACCESS_DENIED) {
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
VolSnapTargetDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   Filter
    )

{
    PTARGET_DEVICE_REMOVAL_NOTIFICATION notification = (PTARGET_DEVICE_REMOVAL_NOTIFICATION) NotificationStructure;
    PFILTER_EXTENSION                   filter = (PFILTER_EXTENSION) Filter;
    BOOLEAN                             cleanupBitmap = FALSE;
    NTSTATUS                            status;
    KIRQL                               irql;
    PRTL_BITMAP                         bitmap;
    PLIST_ENTRY                         l;
    PVSP_DIFF_AREA_FILE                 diffAreaFile;
    PFILTER_EXTENSION                   f;
    LIST_ENTRY                          listOfDiffAreaFilesToClose;
    LIST_ENTRY                          listOfDeviceObjectsToDelete;
    HANDLE                              h, hh;
    PVOLUME_EXTENSION                   extension;
    BOOLEAN                             b, persistentOk;

    if (IsEqualGUID(notification->Event,
                    GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        if (filter->TargetDeviceNotificationEntry) {
            IoUnregisterPlugPlayNotification(
                    filter->TargetDeviceNotificationEntry);
            filter->TargetDeviceNotificationEntry = NULL;
        }
        return STATUS_SUCCESS;
    }

    if (IsEqualGUID(notification->Event, GUID_IO_VOLUME_MOUNT)) {
        if (!filter->ProtectedBlocksBitmap) {
            return STATUS_SUCCESS;
        }

        status = VspOpenAndValidateDiffAreaFiles(filter);
        if (!NT_SUCCESS(status)) {
            persistentOk = FALSE;
            cleanupBitmap = TRUE;
            goto DeleteSnapshots;
        }

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        bitmap = (PRTL_BITMAP) InterlockedExchangePointer(
                               (PVOID*) &filter->ProtectedBlocksBitmap, NULL);
        if (bitmap) {
            ExFreePool(bitmap->Buffer);
            ExFreePool(bitmap);
        }
        KeReleaseSpinLock(&filter->SpinLock, irql);

        return STATUS_SUCCESS;
    }

    if (!IsEqualGUID(notification->Event, GUID_IO_VOLUME_DISMOUNT)) {
        return STATUS_SUCCESS;
    }

    if (VspIsFileSystemLocked(filter)) {
        return STATUS_SUCCESS;
    }

    if (filter->FirstControlBlockVolumeOffset) {
        persistentOk = TRUE;
    } else {
        persistentOk = FALSE;
    }

    if (persistentOk) {
        if (!filter->ProtectedBlocksBitmap) {
            status = VspProtectDiffAreaClusters(filter);
            if (!NT_SUCCESS(status)) {
                persistentOk = FALSE;
            }
        }
    }

DeleteSnapshots:

    InitializeListHead(&listOfDiffAreaFilesToClose);
    InitializeListHead(&listOfDeviceObjectsToDelete);

    VspAcquire(filter->Root);

    for (;;) {

        for (l = filter->DiffAreaFilesOnThisFilter.Flink;
             l != &filter->DiffAreaFilesOnThisFilter; l = l->Flink) {

            diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                             FilterListEntry);
            if (!persistentOk || !diffAreaFile->Extension->IsPersistent) {
                break;
            }
        }

        if (l == &filter->DiffAreaFilesOnThisFilter) {
            break;
        }

        f = diffAreaFile->Extension->Filter;

        VspLogError(diffAreaFile->Extension, diffAreaFile->Filter,
                    VS_ABORT_SNAPSHOTS_DISMOUNT, STATUS_SUCCESS, 1, TRUE);

        VspAbortPreparedSnapshot(f, FALSE, FALSE);

        b = FALSE;
        while (!IsListEmpty(&f->VolumeList)) {
            extension = CONTAINING_RECORD(f->VolumeList.Flink,
                                          VOLUME_EXTENSION, ListEntry);
            if (persistentOk && extension->IsPersistent) {
                break;
            }
            VspDeleteOldestSnapshot(f, &listOfDiffAreaFilesToClose,
                                    &listOfDeviceObjectsToDelete, FALSE, TRUE);
            b = TRUE;
        }
        if (b) {
            IoInvalidateDeviceRelations(f->Pdo, BusRelations);
        }
    }

    VspAbortPreparedSnapshot(filter, FALSE, FALSE);

    if (filter->PersistentSnapshots && !persistentOk &&
        !IsListEmpty(&filter->VolumeList)) {

        extension = CONTAINING_RECORD(filter->VolumeList.Blink,
                                      VOLUME_EXTENSION, ListEntry);
        VspLogError(extension, extension->Filter,
                    VS_ABORT_SNAPSHOTS_DISMOUNT_ORIGINAL, STATUS_SUCCESS, 2,
                    TRUE);

        b = FALSE;
        while (!IsListEmpty(&filter->VolumeList)) {
            VspDeleteOldestSnapshot(filter, &listOfDiffAreaFilesToClose,
                                    &listOfDeviceObjectsToDelete, FALSE, TRUE);
            b = TRUE;
        }
        if (b) {
            IoInvalidateDeviceRelations(filter->Pdo, BusRelations);
        }
    }

    if (persistentOk) {
        hh = NULL;
    } else {
        hh = InterlockedExchangePointer(&filter->BootStatHandle, NULL);
    }

    if (cleanupBitmap) {
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        bitmap = (PRTL_BITMAP) InterlockedExchangePointer(
                               (PVOID*) &filter->ProtectedBlocksBitmap, NULL);
        if (bitmap) {
            ExFreePool(bitmap->Buffer);
            ExFreePool(bitmap);
        }
        KeReleaseSpinLock(&filter->SpinLock, irql);
    }

    VspRelease(filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                          &listOfDeviceObjectsToDelete);

    if (persistentOk) {
        h = NULL;
    } else {
        h = InterlockedExchangePointer(&filter->ControlBlockFileHandle, NULL);

        VspAcquireNonPagedResource(filter, NULL, FALSE);
        filter->FirstControlBlockVolumeOffset = 0;
        if (h) {
            VspCreateStartBlock(filter, 0, filter->MaximumVolumeSpace);
        }
        VspReleaseNonPagedResource(filter);
    }

    if (h) {
        ZwClose(h);
    }

    if (hh) {
        ZwClose(hh);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapVolumeDeviceNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   RootExtension
    )

/*++

Routine Description:

    This routine is called whenever a volume comes or goes.

Arguments:

    NotificationStructure   - Supplies the notification structure.

    RootExtension           - Supplies the root extension.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   notification = (PDEVICE_INTERFACE_CHANGE_NOTIFICATION) NotificationStructure;
    PDO_EXTENSION                           root = (PDO_EXTENSION) RootExtension;
    BOOLEAN                                 errorMode;
    NTSTATUS                                status;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;
    PFILTER_EXTENSION                       filter;

    if (!IsEqualGUID(notification->Event, GUID_DEVICE_INTERFACE_ARRIVAL)) {
        return STATUS_SUCCESS;
    }

    errorMode = PsGetThreadHardErrorsAreDisabled(PsGetCurrentThread());
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), TRUE);

    status = IoGetDeviceObjectPointer(notification->SymbolicLinkName,
                                      FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);
        return STATUS_SUCCESS;
    }

    if (fileObject->DeviceObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject(fileObject);
        PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);
        return STATUS_SUCCESS;
    }

    VspAcquire(root);

    filter = VspFindFilter(root, NULL, NULL, fileObject);
    if (!filter || filter->TargetDeviceNotificationEntry) {
        ObDereferenceObject(fileObject);
        PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);
        VspRelease(root);
        return STATUS_SUCCESS;
    }

    ObReferenceObject(filter->DeviceObject);

    VspRelease(root);

    status = IoRegisterPlugPlayNotification(
             EventCategoryTargetDeviceChange, 0, fileObject,
             root->DriverObject, VolSnapTargetDeviceNotification, filter,
             &filter->TargetDeviceNotificationEntry);

    ObDereferenceObject(filter->DeviceObject);
    ObDereferenceObject(fileObject);
    PsSetThreadHardErrorsAreDisabled(PsGetCurrentThread(), errorMode);

    return STATUS_SUCCESS;
}

VOID
VspWaitToRegisterWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PDO_EXTENSION       rootExtension = context->RootExtension.RootExtension;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_ROOT_EXTENSION);

    VspFreeContext(rootExtension, context);

    VspWaitForVolumesSafeForWriteAccess(rootExtension);

    if (rootExtension->NotificationEntry) {
        return;
    }

    IoRegisterPlugPlayNotification(
            EventCategoryDeviceInterfaceChange,
            PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
            (PVOID) &GUID_IO_VOLUME_DEVICE_INTERFACE,
            rootExtension->DriverObject, VolSnapVolumeDeviceNotification,
            rootExtension, &rootExtension->NotificationEntry);
}

VOID
VspDriverBootReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           RootExtension,
    IN  ULONG           Count
    )

/*++

Routine Description:

    This routine is called after all of the boot drivers are loaded and it
    checks to make sure that we did not boot off of the stale half of a
    mirror.

Arguments:

    DriverObject    - Supplies the drive object.

    RootExtension   - Supplies the root extension.

    Count           - Supplies the count.

Return Value:

    None.

--*/

{
    PDO_EXTENSION   rootExtension = (PDO_EXTENSION) RootExtension;
    PVSP_CONTEXT    context;

    KeSetEvent(&rootExtension->PastBootReinit, IO_NO_INCREMENT,
               FALSE);
}

VOID
VspDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           RootExtension,
    IN  ULONG           Count
    )

/*++

Routine Description:

    This routine is called after all of the boot drivers are loaded and it
    checks to make sure that we did not boot off of the stale half of a
    mirror.

Arguments:

    DriverObject    - Supplies the drive object.

    RootExtension   - Supplies the root extension.

    Count           - Supplies the count.

Return Value:

    None.

--*/

{
    PDO_EXTENSION       rootExtension = (PDO_EXTENSION) RootExtension;
    PLIST_ENTRY         l;
    PFILTER_EXTENSION   filter;
    HANDLE              h, hh;
    PVSP_CONTEXT        context;

    VspAcquire(rootExtension);

    for (l = rootExtension->FilterList.Flink;
         l != &rootExtension->FilterList; l = l->Flink) {

        filter = CONTAINING_RECORD(l, FILTER_EXTENSION, ListEntry);
        if (filter->Pdo->Flags&DO_SYSTEM_BOOT_PARTITION) {
            break;
        }
    }

    if (l == &rootExtension->FilterList ||
        IsListEmpty(&filter->VolumeList)) {

        VspRelease(rootExtension);
    } else {
        VspRelease(rootExtension);

        h = VspPinBootStat(filter);

        if (h) {
            hh = InterlockedExchangePointer(&filter->BootStatHandle, h);
            if (hh) {
                ZwClose(hh);
            }
        }
    }

    InterlockedExchange(&rootExtension->PastReinit, TRUE);

    context = VspAllocateContext(rootExtension);
    if (!context) {
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_ROOT_EXTENSION;
    context->RootExtension.RootExtension = rootExtension;
    ExInitializeWorkItem(&context->WorkItem, VspWaitToRegisterWorker, context);

    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

RTL_GENERIC_COMPARE_RESULTS
VspSnapshotLookupCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    SIZE_T  r;
    PUCHAR  p, q;

    r = RtlCompareMemory(First, Second, sizeof(GUID));
    if (r == sizeof(GUID)) {
        return GenericEqual;
    }

    p = (PUCHAR) First;
    q = (PUCHAR) Second;
    if (p[r] < q[r]) {
        return GenericLessThan;
    }

    return GenericGreaterThan;
}

RTL_GENERIC_COMPARE_RESULTS
VspUsedDevnodeCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    PULONG  f = (PULONG) First;
    PULONG  s = (PULONG) Second;

    if (*f == *s) {
        return GenericEqual;
    }
    if (*f < *s) {
        return GenericLessThan;
    }
    return GenericGreaterThan;
}

VOID
VspSnapshotLookupFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    )

{
    ExFreePool(Buffer);
}

PVOID
VspSnapshotLookupAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    )

{
    return ExAllocatePoolWithTag(PagedPool, Size, VOLSNAP_TAG_LOOKUP);
}

NTSTATUS
VspCheckForNtfs(
    IN  PVOLUME_EXTENSION   Extension
    )

{
    WCHAR               buffer[100];
    UNICODE_STRING      dirName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              h;
    IO_STATUS_BLOCK     ioStatus;
    BOOLEAN             isNtfs;

    if (Extension->IsOffline) {
        VspSetOfflineBit(Extension, FALSE);
    }

    swprintf(buffer, L"\\Device\\HarddiskVolumeShadowCopy%d\\",
             Extension->VolumeNumber);
    RtlInitUnicodeString(&dirName, buffer);

    InitializeObjectAttributes(&oa, &dirName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenFile(&h, FILE_LIST_DIRECTORY | SYNCHRONIZE, &oa,
                        &ioStatus, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = VspIsNtfs(h, &isNtfs);
    ZwClose(h);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    return isNtfs ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

VOID
VspHandleHibernatePost(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PVOLUME_EXTENSION   extension = context->Extension.Extension;
    PIRP                irp = context->Extension.Irp;
    PFILTER_EXTENSION   filter = extension->Filter;
    NTSTATUS            status;
    UNICODE_STRING      fileName;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_EXTENSION);

    VspFreeContext(extension->Root, context);

    status = VspCheckForNtfs(extension);
    if (!NT_SUCCESS(status)) {
        VspLogError(NULL, filter, VS_ABORT_NON_NTFS_HIBER_VOLUME, status, 0,
                    FALSE);
        VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);
        status = STATUS_SUCCESS;
        goto Finish;
    }

    if (extension->HiberFileCopied) {
        RtlInitUnicodeString(&fileName, L"hiberfil.sys");
        status = VspCompareFileIds(extension, &fileName);
        if (NT_SUCCESS(status)) {
            goto Finish;
        }
    }

    VspCantHibernatePopUp(filter);

    status = STATUS_INVALID_DEVICE_REQUEST;

Finish:
    irp->IoStatus.Status = status;
    PoStartNextPowerIrp(irp);
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

NTSTATUS
VspHandleHibernateNotification(
    IN  PVOLUME_EXTENSION   Extension,
    IN  PIRP                Irp
    )

{
    PFILTER_EXTENSION   filter = Extension->Filter;
    KIRQL               irql;
    PVSP_CONTEXT        context;

    if (!(filter->Pdo->Flags&DO_SYSTEM_BOOT_PARTITION)) {
        return STATUS_SUCCESS;
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (Extension->ListEntry.Flink != &filter->VolumeList) {
        KeReleaseSpinLock(&filter->SpinLock, irql);
        return STATUS_SUCCESS;
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    context = VspAllocateContext(Extension->Root);
    if (!context) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);

    context->Type = VSP_CONTEXT_TYPE_EXTENSION;
    ExInitializeWorkItem(&context->WorkItem, VspHandleHibernatePost, context);
    context->Extension.Extension = Extension;
    context->Extension.Irp = Irp;

    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);

    return STATUS_PENDING;
}

VOID
VspDismountCleanupOnWrite(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->DismountCleanupOnWrite.Filter;
    PIRP                irp = context->DismountCleanupOnWrite.Irp;
    PVOLUME_EXTENSION   e;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PFILTER_EXTENSION   f, df;
    PRTL_BITMAP         bitmap;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DISMOUNT_CLEANUP);

    for (;;) {

        f = df = NULL;
        e = NULL;
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        for (l = filter->DiffAreaFilesOnThisFilter.Flink;
             l != &filter->DiffAreaFilesOnThisFilter; l = l->Flink) {

            diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                             FilterListEntry);
            f = diffAreaFile->Extension->Filter;
            if (f->SnapshotsPresent && !f->DestroyAllSnapshotsPending) {
                e = diffAreaFile->Extension;
                df = diffAreaFile->Filter;
                ObReferenceObject(f->DeviceObject);
                ObReferenceObject(e->DeviceObject);
                ObReferenceObject(df->DeviceObject);
                break;
            }
        }
        KeReleaseSpinLock(&filter->SpinLock, irql);

        if (l == &filter->DiffAreaFilesOnThisFilter) {
            break;
        }

        if (VspDestroyAllSnapshots(f, NULL, FALSE, FALSE)) {
            VspLogError(e, df, VS_ABORT_SNAPSHOTS_DISMOUNT, STATUS_SUCCESS, 2,
                        FALSE);
            VspDeleteControlItemsWithGuid(f, NULL, TRUE);
        }

        ObDereferenceObject(f->DeviceObject);
        ObDereferenceObject(e->DeviceObject);
        ObDereferenceObject(df->DeviceObject);
    }

    if (filter->SnapshotsPresent && !filter->DestroyAllSnapshotsPending) {
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        if (IsListEmpty(&filter->VolumeList)) {
            KeReleaseSpinLock(&filter->SpinLock, irql);
        } else {
            e = CONTAINING_RECORD(filter->VolumeList.Blink, VOLUME_EXTENSION,
                                  ListEntry);
            ObReferenceObject(e->DeviceObject);
            KeReleaseSpinLock(&filter->SpinLock, irql);

            if (VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE)) {
                VspLogError(e, e->Filter, VS_ABORT_SNAPSHOTS_DISMOUNT_ORIGINAL,
                            STATUS_SUCCESS, 1, FALSE);
                VspDeleteControlItemsWithGuid(filter, NULL, TRUE);
            }
            ObDereferenceObject(e->DeviceObject);
        }
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    bitmap = (PRTL_BITMAP) InterlockedExchangePointer(
                           (PVOID*) &filter->ProtectedBlocksBitmap, NULL);
    if (bitmap) {
        ExFreePool(bitmap->Buffer);
        ExFreePool(bitmap);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    VspReleaseNonPagedResource(filter);

    VspDecrementRefCount(filter);

    VolSnapWrite(filter->DeviceObject, irp);
}

VOID
VspCreateStartBlockWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;
    PIRP                irp = context->Filter.Irp;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_FILTER);

    VspCreateStartBlock(filter, filter->FirstControlBlockVolumeOffset,
                        filter->MaximumVolumeSpace);
    VspReleaseNonPagedResource(filter);

    VspDecrementRefCount(filter);

    IoCompleteRequest(irp, IO_DISK_INCREMENT);
}

NTSTATUS
VspWriteContextCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           WriteContext
    )

{
    PVSP_WRITE_CONTEXT  writeContext = (PVSP_WRITE_CONTEXT) WriteContext;
    PFILTER_EXTENSION   filter = writeContext->Filter;
    PVOLUME_EXTENSION   extension = writeContext->Extension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;
    PVSP_CONTEXT        context;

    ASSERT(Irp == writeContext->Irp);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    RemoveEntryList(&writeContext->ListEntry);
    KeReleaseSpinLock(&extension->SpinLock, irql);

    while (!IsListEmpty(&writeContext->CompletionRoutines)) {
        l = RemoveHeadList(&writeContext->CompletionRoutines);
        workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
        workItem->WorkerRoutine(workItem->Parameter);
        ExFreePool(workItem);
    }

    VspFreeWriteContext(filter->Root, writeContext);

    if (!filter->ProtectedBlocksBitmap &&
        irpSp->Parameters.Write.ByteOffset.QuadPart <=
        VSP_START_BLOCK_OFFSET &&
        irpSp->Parameters.Write.ByteOffset.QuadPart +
        irpSp->Parameters.Write.Length > VSP_START_BLOCK_OFFSET) {

        context = VspAllocateContext(filter->Root);
        if (context) {
            context->Type = VSP_CONTEXT_TYPE_FILTER;
            ExInitializeWorkItem(&context->WorkItem, VspCreateStartBlockWorker,
                                 context);
            context->Filter.Filter = filter;
            context->Filter.Irp = Irp;

            VspAcquireNonPagedResource(filter, &context->WorkItem, TRUE);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    }

    VspDecrementRefCount(filter);

    return STATUS_SUCCESS;
}

VOID
VspCleanupDanglingSnapshots(
    IN  PVOID       Filter,
    IN  NTSTATUS    LogStatus,
    IN  ULONG       LogUniqueId
    )

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) Filter;
    NTSTATUS            status;

    VspLogError(NULL, filter, VS_ABORT_NO_DIFF_AREA_VOLUME,
                LogStatus, LogUniqueId, FALSE);

    ObReferenceObject(filter->DeviceObject);
    ObReferenceObject(filter->TargetObject);

    VspDeleteControlItemsWithGuid(filter, NULL, FALSE);

    InterlockedExchange(&filter->SnapshotDiscoveryPending, FALSE);
    KeSetEvent(&filter->EndCommitProcessCompleted, IO_NO_INCREMENT,
               FALSE);
    ASSERT(filter->FirstWriteProcessed);

    VspResumeVolumeIo(filter);

    KeWaitForSingleObject(&filter->Root->PastBootReinit, Executive,
                          KernelMode, FALSE, NULL);

    status = VspOpenControlBlockFile(filter);
    if (!NT_SUCCESS(status)) {
        VspAcquireNonPagedResource(filter, NULL, FALSE);
        VspCreateStartBlock(filter, 0, filter->MaximumVolumeSpace);
        filter->FirstControlBlockVolumeOffset = 0;
        VspReleaseNonPagedResource(filter);
    }

    ObDereferenceObject(filter->TargetObject);
    ObDereferenceObject(filter->DeviceObject);
}

VOID
VspPnpCleanupDangling(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->PnpWaitTimer.Filter;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PVSP_COPY_ON_WRITE  copyOnWrite;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_PNP_WAIT_TIMER);

    VspFreeContext(filter->Root, context);

    VspPauseVolumeIo(filter);

    if (filter->SnapshotDiscoveryPending) {
        VspCleanupDanglingSnapshots(filter, STATUS_SUCCESS, 1);
    } else {
        VspResumeVolumeIo(filter);
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    while (!IsListEmpty(&filter->CopyOnWriteList)) {
        l = RemoveHeadList(&filter->CopyOnWriteList);
        copyOnWrite = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE, ListEntry);
        ExFreePool(copyOnWrite->Buffer);
        ExFreePool(copyOnWrite);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    ObDereferenceObject(filter->DeviceObject);
}

VOID
VspPnpTimerDpc(
    IN  PKDPC   TimerDpc,
    IN  PVOID   Context,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->PnpWaitTimer.Filter;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PVSP_COPY_ON_WRITE  copyOnWrite;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_PNP_WAIT_TIMER);

    ExFreePool(context->PnpWaitTimer.Timer);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    filter->PnpWaitTimerContext = NULL;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (!filter->SnapshotDiscoveryPending) {
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        while (!IsListEmpty(&filter->CopyOnWriteList)) {
            l = RemoveHeadList(&filter->CopyOnWriteList);
            copyOnWrite = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE, ListEntry);
            ExFreePool(copyOnWrite->Buffer);
            ExFreePool(copyOnWrite);
        }
        KeReleaseSpinLock(&filter->SpinLock, irql);
        VspFreeContext(filter->Root, context);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    ExInitializeWorkItem(&context->WorkItem, VspPnpCleanupDangling,
                         context);
    ExQueueWorkItem(&context->WorkItem, DelayedWorkQueue);
}

VOID
VspStartCopyOnWriteCache(
    IN  PVOID   Filter
    )

{
    PFILTER_EXTENSION           filter = (PFILTER_EXTENSION) Filter;
    PVSP_LOOKUP_TABLE_ENTRY     lookupEntry;
    NTSTATUS                    status;
    CHAR                        controlItemBuffer[VSP_BYTES_PER_CONTROL_ITEM];
    PVSP_CONTROL_ITEM_SNAPSHOT  snapshotControlItem = (PVSP_CONTROL_ITEM_SNAPSHOT) controlItemBuffer;
    PVSP_CONTEXT                context;
    LARGE_INTEGER               timeout;
    KIRQL                       irql;

    ASSERT(!IsListEmpty(&filter->SnapshotLookupTableEntries));

    lookupEntry = CONTAINING_RECORD(filter->SnapshotLookupTableEntries.Blink,
                                    VSP_LOOKUP_TABLE_ENTRY,
                                    SnapshotFilterListEntry);

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &lookupEntry->SnapshotGuid, FALSE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        VspCleanupDanglingSnapshots(Filter, status, 2);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    if (snapshotControlItem->SnapshotControlItemFlags&
        VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_DETECTION) {

        VspCleanupDanglingSnapshots(Filter, STATUS_SUCCESS, 3);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    snapshotControlItem->SnapshotControlItemFlags |=
            VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_DETECTION;

    status = VspIoControlItem(filter, VSP_CONTROL_ITEM_TYPE_SNAPSHOT,
                              &lookupEntry->SnapshotGuid, TRUE,
                              controlItemBuffer, TRUE);
    if (!NT_SUCCESS(status)) {
        VspCleanupDanglingSnapshots(Filter, status, 4);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    ASSERT(lookupEntry->SnapshotControlItemFlags&
           VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_DETECTION);

    lookupEntry->SnapshotControlItemFlags &=
            ~VSP_SNAPSHOT_CONTROL_ITEM_FLAG_DIRTY_DETECTION;

    context = VspAllocateContext(filter->Root);
    if (!context) {
        VspCleanupDanglingSnapshots(Filter, STATUS_INSUFFICIENT_RESOURCES, 5);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_PNP_WAIT_TIMER;
    context->PnpWaitTimer.Filter = filter;
    KeInitializeDpc(&context->PnpWaitTimer.TimerDpc,
                    VspPnpTimerDpc, context);
    context->PnpWaitTimer.Timer = (PKTIMER)
            ExAllocatePoolWithTag(NonPagedPool, sizeof(KTIMER),
                                  VOLSNAP_TAG_SHORT_TERM);
    if (!context->PnpWaitTimer.Timer) {
        VspFreeContext(filter->Root, context);
        VspCleanupDanglingSnapshots(Filter, STATUS_INSUFFICIENT_RESOURCES, 6);
        ObDereferenceObject(filter->DeviceObject);
        return;
    }
    KeInitializeTimer(context->PnpWaitTimer.Timer);

    ObReferenceObject(filter->DeviceObject);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    filter->PnpWaitTimerContext = context;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    timeout.QuadPart = (LONGLONG) -10*1000*1000*30;    // 30 seconds.
    KeSetTimer(context->PnpWaitTimer.Timer, timeout,
               &context->PnpWaitTimer.TimerDpc);

    VspResumeVolumeIo(filter);

    ObDereferenceObject(filter->DeviceObject);
}

VOID
VspAbortCopyOnWrites(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    KIRQL   irql;

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    if (Filter->PnpWaitTimerContext &&
        KeCancelTimer(Filter->PnpWaitTimerContext->PnpWaitTimer.Timer)) {

        KeReleaseSpinLock(&Filter->SpinLock, irql);

        VspPnpTimerDpc(NULL, Filter->PnpWaitTimerContext, NULL, NULL);

    } else {
        KeReleaseSpinLock(&Filter->SpinLock, irql);
    }

    if (!Irp->MdlAddress) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        VspDecrementRefCount(Filter);
        return;
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, VspRefCountCompletionRoutine, Filter, TRUE,
                           TRUE, TRUE);
    IoCallDriver(Filter->TargetObject, Irp);
}

NTSTATUS
VspCopyOnWriteReadCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->CopyOnWrite.Filter;
    PIRP                irp = context->CopyOnWrite.Irp;
    NTSTATUS            status = Irp->IoStatus.Status;
    PVSP_COPY_ON_WRITE  copyOnWrite, cow;
    KIRQL               irql;
    PLIST_ENTRY         l;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_COPY_ON_WRITE);

    if (!NT_SUCCESS(status)) {
        VspFreeContext(filter->Root, context);
        ExFreePool(MmGetMdlVirtualAddress(Irp->MdlAddress));
        IoFreeMdl(Irp->MdlAddress);
        IoFreeIrp(Irp);
        VspAbortCopyOnWrites(filter, irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    copyOnWrite = (PVSP_COPY_ON_WRITE)
                  ExAllocatePoolWithTag(NonPagedPool,
                                        sizeof(VSP_COPY_ON_WRITE),
                                        VOLSNAP_TAG_COPY);
    if (!copyOnWrite) {
        VspFreeContext(filter->Root, context);
        ExFreePool(MmGetMdlVirtualAddress(Irp->MdlAddress));
        IoFreeMdl(Irp->MdlAddress);
        IoFreeIrp(Irp);
        VspAbortCopyOnWrites(filter, irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    copyOnWrite->RoundedStart = context->CopyOnWrite.RoundedStart;
    copyOnWrite->Buffer = MmGetMdlVirtualAddress(Irp->MdlAddress);
    IoFreeMdl(Irp->MdlAddress);
    IoFreeIrp(Irp);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    for (l = filter->CopyOnWriteList.Flink; l != &filter->CopyOnWriteList;
         l = l->Flink) {

        cow = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE, ListEntry);
        if (copyOnWrite->RoundedStart == cow->RoundedStart) {
            break;
        }
    }
    if (l == &filter->CopyOnWriteList) {
        InsertTailList(&filter->CopyOnWriteList, &copyOnWrite->ListEntry);
    } else {
        ExFreePool(copyOnWrite->Buffer);
        ExFreePool(copyOnWrite);
    }
    KeReleaseSpinLock(&filter->SpinLock, irql);

    context->CopyOnWrite.RoundedStart += BLOCK_SIZE;

    VspStartCopyOnWrite(context);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
VspStartCopyOnWrite(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->CopyOnWrite.Filter;
    LONGLONG            roundedStart = context->CopyOnWrite.RoundedStart;
    LONGLONG            roundedEnd = context->CopyOnWrite.RoundedEnd;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PVSP_COPY_ON_WRITE  copyOnWrite;
    PIRP                irp;
    PMDL                mdl;
    PVOID               buffer;
    PIO_STACK_LOCATION  nextSp;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_COPY_ON_WRITE);

    for (; roundedStart < roundedEnd; roundedStart += BLOCK_SIZE) {

        KeAcquireSpinLock(&filter->SpinLock, &irql);
        for (l = filter->CopyOnWriteList.Flink;
             l != &filter->CopyOnWriteList; l = l->Flink) {

            copyOnWrite = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE, ListEntry);
            if (copyOnWrite->RoundedStart == roundedStart) {
                break;
            }
        }
        KeReleaseSpinLock(&filter->SpinLock, irql);

        if (l != &filter->CopyOnWriteList) {
            continue;
        }

        irp = IoAllocateIrp(filter->TargetObject->StackSize, FALSE);
        buffer = ExAllocatePoolWithTag(NonPagedPool, BLOCK_SIZE,
                                       VOLSNAP_TAG_BUFFER);
        mdl = IoAllocateMdl(buffer, BLOCK_SIZE, FALSE, FALSE, NULL);
        if (!irp || !buffer || !mdl) {
            if (irp) {
                IoFreeIrp(irp);
            }
            if (mdl) {
                IoFreeMdl(mdl);
            }
            if (buffer) {
                ExFreePool(buffer);
            }
            irp = context->CopyOnWrite.Irp;
            VspFreeContext(filter->Root, context);
            VspAbortCopyOnWrites(filter, irp);
            return;
        }

        context->CopyOnWrite.RoundedStart = roundedStart;
        MmBuildMdlForNonPagedPool(mdl);
        irp->MdlAddress = mdl;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        nextSp = IoGetNextIrpStackLocation(irp);
        nextSp->Parameters.Read.ByteOffset.QuadPart = roundedStart;
        nextSp->Parameters.Read.Length = BLOCK_SIZE;
        nextSp->MajorFunction = IRP_MJ_READ;
        nextSp->DeviceObject = filter->TargetObject;
        nextSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

        IoSetCompletionRoutine(irp, VspCopyOnWriteReadCompletion,
                               context, TRUE, TRUE, TRUE);

        IoCallDriver(nextSp->DeviceObject, irp);
        return;
    }

    irp = context->CopyOnWrite.Irp;
    VspFreeContext(filter->Root, context);

    if (!irp->MdlAddress) {
        irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        irp->IoStatus.Information = 0;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
        VspDecrementRefCount(filter);
        return;
    }

    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine(irp, VspRefCountCompletionRoutine, filter,
                           TRUE, TRUE, TRUE);
    IoCallDriver(filter->TargetObject, irp);
}

VOID
VspCopyOnWriteToNonPagedPool(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PVSP_CONTEXT        context;

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        VspAbortCopyOnWrites(Filter, Irp);
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_COPY_ON_WRITE;
    context->CopyOnWrite.Filter = Filter;
    context->CopyOnWrite.Irp = Irp;
    context->CopyOnWrite.RoundedStart =
            irpSp->Parameters.Write.ByteOffset.QuadPart&(~(BLOCK_SIZE - 1));
    context->CopyOnWrite.RoundedEnd =
            (irpSp->Parameters.Write.ByteOffset.QuadPart +
             irpSp->Parameters.Write.Length + BLOCK_SIZE - 1)&
            (~(BLOCK_SIZE - 1));

    VspStartCopyOnWrite(context);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

#if DBG

VOID
VspCheckDiffAreaFile(
    IN  PVSP_DIFF_AREA_FILE DiffAreaFile
    )

{
    LONGLONG                    fileOffset;
    PLIST_ENTRY                 l;
    PDIFF_AREA_FILE_ALLOCATION  diffAreaFileAllocation;

    _try {

        fileOffset = DiffAreaFile->NextAvailable;
        for (l = DiffAreaFile->UnusedAllocationList.Flink;
             l != &DiffAreaFile->UnusedAllocationList; l = l->Flink) {

            diffAreaFileAllocation = CONTAINING_RECORD(l,
                                     DIFF_AREA_FILE_ALLOCATION, ListEntry);

            if (diffAreaFileAllocation->NLength < 0) {
                fileOffset -= diffAreaFileAllocation->NLength;
            } else {
                fileOffset += diffAreaFileAllocation->NLength;
            }
        }

        ASSERT(fileOffset == DiffAreaFile->AllocatedFileSize);

    } _except (EXCEPTION_EXECUTE_HANDLER) {
    }
}

#endif


VOID
VspLowPriorityWorkItem(
    IN  PVOID   RootExtension
    )

{
    PDO_EXTENSION       root = (PDO_EXTENSION) RootExtension;
    KIRQL               irql;
    PLIST_ENTRY         l;

    for (;;) {

        root->ActualLowPriorityWorkItem->WorkerRoutine(
                root->ActualLowPriorityWorkItem->Parameter);

        KeAcquireSpinLock(&root->ESpinLock, &irql);
        if (IsListEmpty(&root->LowPriorityQueue)) {
            root->WorkerItemInUse = FALSE;
            KeReleaseSpinLock(&root->ESpinLock, irql);
            return;
        }
        l = RemoveHeadList(&root->LowPriorityQueue);
        KeReleaseSpinLock(&root->ESpinLock, irql);

        root->ActualLowPriorityWorkItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM,
                                                            List);
    }
}

VOID
VspQueueLowPriorityWorkItem(
    IN  PDO_EXTENSION       RootExtension,
    IN  PWORK_QUEUE_ITEM    WorkItem
    )

{
    KIRQL   irql;

    KeAcquireSpinLock(&RootExtension->ESpinLock, &irql);
    if (RootExtension->WorkerItemInUse) {
        InsertTailList(&RootExtension->LowPriorityQueue, &WorkItem->List);
        KeReleaseSpinLock(&RootExtension->ESpinLock, irql);
        return;
    }
    RootExtension->WorkerItemInUse = TRUE;
    KeReleaseSpinLock(&RootExtension->ESpinLock, irql);

    RootExtension->ActualLowPriorityWorkItem = WorkItem;

    ExInitializeWorkItem(&RootExtension->LowPriorityWorkItem,
                         VspLowPriorityWorkItem, RootExtension);
    ExQueueWorkItem(&RootExtension->LowPriorityWorkItem, DelayedWorkQueue);
}

VOID
VspCleanupPreamble(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KIRQL   irql;

    if (!Filter->IsOnline) {
        return;
    }

    Filter->IsOnline = FALSE;

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    if (Filter->SnapshotDiscoveryPending && !Filter->ActivateStarted &&
        !Filter->FirstWriteProcessed) {

        InterlockedExchange(&Filter->SnapshotDiscoveryPending, FALSE);
        InterlockedExchange(&Filter->FirstWriteProcessed, TRUE);

        KeReleaseSpinLock(&Filter->SpinLock, irql);
    } else {
        KeReleaseSpinLock(&Filter->SpinLock, irql);

        VspPauseVolumeIo(Filter);
    }

    VspResumeVolumeIo(Filter);
}

VOID
VspOfflineWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;
    PIRP                irp = context->Filter.Irp;
    KEVENT              event;
    KIRQL               irql;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_FILTER);
    VspFreeContext(filter->Root, context);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine(irp, VspSignalCompletion, &event, TRUE, TRUE,
                           TRUE);
    IoCallDriver(filter->TargetObject, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(irp->IoStatus.Status)) {
        VspRelease(filter->Root);
        VspReleaseCritical(filter);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
        return;
    }

    VspCleanupPreamble(filter);

    VspRelease(filter->Root);

    VspCleanupFilter(filter, TRUE, FALSE);

    VspReleaseCritical(filter);

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

VOID
VspStartDiffAreaFileCleanupTimer(
    IN  PFILTER_EXTENSION   Filter
    )

{
    PKTIMER         timer;
    PKDPC           dpc;
    PVSP_CONTEXT    context;
    LARGE_INTEGER   timeout;

    timer = (PKTIMER) ExAllocatePoolWithTag(NonPagedPool, sizeof(KTIMER),
                                            VOLSNAP_TAG_SHORT_TERM);
    if (!timer) {
        return;
    }

    dpc = (PKDPC) ExAllocatePoolWithTag(NonPagedPool, sizeof(KDPC),
                                        VOLSNAP_TAG_SHORT_TERM);
    if (!dpc) {
        ExFreePool(timer);
        return;
    }

    context = VspAllocateContext(Filter->Root);
    if (!context) {
        ExFreePool(dpc);
        ExFreePool(timer);
        return;
    }

    context->Type = VSP_CONTEXT_TYPE_DELETE_DA_FILES;
    context->DeleteDiffAreaFiles.Filter = Filter;
    context->DeleteDiffAreaFiles.Timer = timer;
    context->DeleteDiffAreaFiles.Dpc = dpc;

    ObReferenceObject(Filter->DeviceObject);
    KeInitializeTimer(timer);
    KeInitializeDpc(dpc, VspDeleteDiffAreaFilesTimerDpc, context);

    Filter->DeleteTimer = timer;

    timeout.QuadPart = (LONGLONG) 21*60*(-10*1000*1000); // 21 minutes.
    KeSetTimer(timer, timeout, dpc);
}

BOOLEAN
FtpSupportsOnlineOffline(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KEVENT          event;
    PIRP            irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE,
                                        Filter->TargetObject, NULL, 0,
                                        NULL, 0, FALSE, &event, &ioStatus);
    if (!irp) {
        return FALSE;
    }

    status = IoCallDriver(Filter->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;
}

VOID
VspOnlineWorker(
    IN  PVOID   Context
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) Context;
    PFILTER_EXTENSION   filter = context->Filter.Filter;
    PIRP                irp = context->Filter.Irp;
    KEVENT              event;
    BOOLEAN             noControlItems;
    KIRQL               irql;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_FILTER);
    VspFreeContext(filter->Root, context);

    filter->IsOnline = TRUE;
    filter->IsRemoved = FALSE;

    VspPauseVolumeIo(filter);

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    InterlockedExchange(&filter->FirstWriteProcessed, FALSE);
    filter->ActivateStarted = FALSE;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine(irp, VspSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(filter->TargetObject, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(irp->IoStatus.Status)) {
        if (FtpSupportsOnlineOffline(filter)) {
            filter->IsOnline = FALSE;
            VspResumeVolumeIo(filter);
            VspRelease(filter->Root);
            VspReleaseCritical(filter);
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            return;
        }
    }

    VspDiscoverSnapshots(filter, &noControlItems);

    if (!filter->SnapshotDiscoveryPending) {
        if (filter->FirstControlBlockVolumeOffset &&
            !filter->SnapshotsPresent && !noControlItems) {

            VspLaunchOpenControlBlockFileWorker(filter);
        }
    }

    VspRelease(filter->Root);

    VspStartDiffAreaFileCleanupTimer(filter);

    VspReleaseCritical(filter);

    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

NTSTATUS
VspAbortPreparedSnapshot(
    IN  PFILTER_EXTENSION   Filter,
    IN  BOOLEAN             NeedLock,
    IN  BOOLEAN             IsFinalRemove
    )

/*++

Routine Description:

    This routine aborts the prepared snapshot.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    NTSTATUS

--*/

{
    KIRQL               irql;
    PVOLUME_EXTENSION   extension;

    if (NeedLock) {
        VspAcquire(Filter->Root);
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    extension = Filter->PreparedSnapshot;
    Filter->PreparedSnapshot = NULL;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (NeedLock) {
        VspRelease(Filter->Root);
    }

    if (!extension) {
        return STATUS_INVALID_PARAMETER;
    }

    VspCleanupInitialSnapshot(extension, NeedLock, IsFinalRemove);

    return STATUS_SUCCESS;
}

VOID
VspAcquireNonPagedResource(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PWORK_QUEUE_ITEM    WorkItem,
    IN  BOOLEAN             AlwaysPost
    )

{
    PFILTER_EXTENSION   filter;
    KIRQL               irql;
    VSP_CONTEXT         context;
    BOOLEAN             synchronousCall;

    if (Extension->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        filter = (PFILTER_EXTENSION) Extension;
    } else {
        filter = ((PVOLUME_EXTENSION) Extension)->Filter;
    }

    if (WorkItem) {
        synchronousCall = FALSE;
    } else {
        WorkItem = &context.WorkItem;
        context.Type = VSP_CONTEXT_TYPE_EVENT;
        KeInitializeEvent(&context.Event.Event, NotificationEvent, FALSE);
        ExInitializeWorkItem(&context.WorkItem, VspSignalContext, &context);
        synchronousCall = TRUE;
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);
    if (filter->NonPagedResourceInUse) {
        InsertTailList(&filter->NonPagedResourceList, &WorkItem->List);
        KeReleaseSpinLock(&filter->SpinLock, irql);
        if (synchronousCall) {
            KeWaitForSingleObject(&context.Event.Event, Executive,
                                  KernelMode, FALSE, NULL);
        }
        return;
    }
    filter->NonPagedResourceInUse = TRUE;
    KeReleaseSpinLock(&filter->SpinLock, irql);

    if (!synchronousCall) {
        if (AlwaysPost) {
            VspQueueWorkItem(filter->Root, WorkItem, 2);
        } else {
            WorkItem->WorkerRoutine(WorkItem->Parameter);
        }
    }
}

VOID
VspReleaseNonPagedResource(
    IN  PDEVICE_EXTENSION   Extension
    )

{
    PFILTER_EXTENSION   filter;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PWORK_QUEUE_ITEM    workItem;
    PVOLUME_EXTENSION   extension;

    if (Extension->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        filter = (PFILTER_EXTENSION) Extension;
    } else {
        filter = ((PVOLUME_EXTENSION) Extension)->Filter;
    }

    KeAcquireSpinLock(&filter->SpinLock, &irql);

#if DBG
    if (!IsListEmpty(&filter->VolumeList)) {
        extension = CONTAINING_RECORD(filter->VolumeList.Blink,
                                      VOLUME_EXTENSION, ListEntry);
        if (extension->DiffAreaFile) {
            VspCheckDiffAreaFile(extension->DiffAreaFile);
        }
    }
#endif

    if (IsListEmpty(&filter->NonPagedResourceList)) {
        filter->NonPagedResourceInUse = FALSE;
        KeReleaseSpinLock(&filter->SpinLock, irql);
        return;
    }
    l = RemoveHeadList(&filter->NonPagedResourceList);
    KeReleaseSpinLock(&filter->SpinLock, irql);

    workItem = CONTAINING_RECORD(l, WORK_QUEUE_ITEM, List);
    if (workItem->WorkerRoutine == VspSignalContext) {
        workItem->WorkerRoutine(workItem->Parameter);
    } else {
        VspQueueWorkItem(Extension->Root, workItem, 2);
    }
}

VOID
VspDeleteDiffAreaFilesTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

{
    PVSP_CONTEXT        context = (PVSP_CONTEXT) DeferredContext;
    PFILTER_EXTENSION   filter = context->DeleteDiffAreaFiles.Filter;

    ASSERT(context->Type == VSP_CONTEXT_TYPE_DELETE_DA_FILES);

    ExInitializeWorkItem(&context->WorkItem, VspDeleteDiffAreaFilesWorker,
                         context);
    VspQueueLowPriorityWorkItem(filter->Root, &context->WorkItem);
}

VOID
VspResumeVolumeIo(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KIRQL       irql;
    BOOLEAN     emptyQueue;
    LIST_ENTRY  q;

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    ASSERT(Filter->HoldIncomingWrites);
    InterlockedIncrement(&Filter->RefCount);
    InterlockedDecrement(&Filter->HoldIncomingWrites);
    if (Filter->HoldIncomingWrites) {
        KeReleaseSpinLock(&Filter->SpinLock, irql);
        VspDecrementRefCount(Filter);
        KeReleaseSemaphore(&Filter->ZeroRefSemaphore, IO_NO_INCREMENT, 1,
                           FALSE);
        return;
    }
    if (IsListEmpty(&Filter->HoldQueue)) {
        emptyQueue = FALSE;
    } else {
        emptyQueue = TRUE;
        q = Filter->HoldQueue;
        InitializeListHead(&Filter->HoldQueue);
    }
    KeResetEvent(&Filter->ZeroRefEvent);
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    KeReleaseSemaphore(&Filter->ZeroRefSemaphore, IO_NO_INCREMENT, 1, FALSE);

    if (emptyQueue) {
        q.Blink->Flink = &q;
        q.Flink->Blink = &q;
        VspEmptyIrpQueue(Filter->Root->DriverObject, &q);
    }
}

VOID
VspPauseVolumeIo(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KIRQL   irql;

    KeWaitForSingleObject(&Filter->ZeroRefSemaphore, Executive, KernelMode,
                          FALSE, NULL);

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    if (Filter->HoldIncomingWrites) {
        InterlockedIncrement(&Filter->HoldIncomingWrites);
        KeReleaseSpinLock(&Filter->SpinLock, irql);
    } else {
        InterlockedIncrement(&Filter->HoldIncomingWrites);
        KeReleaseSpinLock(&Filter->SpinLock, irql);
        VspDecrementRefCount(Filter);
    }

    KeWaitForSingleObject(&Filter->ZeroRefEvent, Executive, KernelMode, FALSE,
                          NULL);
}

NTSTATUS
VspSignalCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    )

{
    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
VspReleaseWrites(
    IN  PFILTER_EXTENSION   Filter
    )

/*++

Routine Description:

    This routine releases previously queued writes.  If the writes have
    already been dequeued by a timeout of have never actually been queued
    for some other reason then this routine fails.

Arguments:

    Filter  - Supplies the filter extension.

    Irp     - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    KIRQL               irql;
    LONG                r;
    LIST_ENTRY          q;
    PLIST_ENTRY         l;
    PIRP                irp;
    BOOLEAN             emptyQueue;

    if (!KeCancelTimer(&Filter->HoldWritesTimer)) {
        r = InterlockedExchange(&Filter->LastReleaseDueToMemoryPressure,
                                FALSE);
        return r ? STATUS_INSUFFICIENT_RESOURCES : STATUS_INVALID_PARAMETER;
    }

    VspIrpsTimerDpc(NULL, Filter, NULL, NULL);

    return STATUS_SUCCESS;
}

VOID
VspDecrementRefCount(
    IN  PFILTER_EXTENSION   Filter
    )

{
    KIRQL               irql;
    ZERO_REF_CALLBACK   callback;

    if (InterlockedDecrement(&Filter->RefCount)) {
        return;
    }

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    callback = Filter->ZeroRefCallback;
    Filter->ZeroRefCallback = NULL;
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    if (callback) {
        callback(Filter);
    }

    KeSetEvent(&Filter->ZeroRefEvent, IO_NO_INCREMENT, FALSE);
}

VOID
VspCleanupFilter(
    IN  PFILTER_EXTENSION   Filter,
    IN  BOOLEAN             IsOffline,
    IN  BOOLEAN             IsFinalRemove
    )

/*++

Routine Description:

    This routine cleans up filter extension data because of an IRP_MN_REMOVE.

Arguments:

    Filter  - Supplies the filter extension.

Return Value:

    None.

--*/

{
    KIRQL                           irql;
    PIRP                            irp;
    PRTL_BITMAP                     bitmap;
    PLIST_ENTRY                     l, ll;
    PVSP_DIFF_AREA_FILE             diffAreaFile;
    PFILTER_EXTENSION               f;
    LIST_ENTRY                      listOfDiffAreaFilesToClose;
    LIST_ENTRY                      listOfDeviceObjectsToDelete;
    HANDLE                          h, hh;
    FILE_DISPOSITION_INFORMATION    dispInfo;
    IO_STATUS_BLOCK                 ioStatus;
    PVOLUME_EXTENSION               extension;
    BOOLEAN                         b;

    Filter->DeleteTimer = NULL;

    IoAcquireCancelSpinLock(&irql);
    irp = Filter->FlushAndHoldIrp;
    if (irp) {
        irp->CancelIrql = irql;
        IoSetCancelRoutine(irp, NULL);
        VspCancelRoutine(Filter->DeviceObject, irp);
    } else {
        IoReleaseCancelSpinLock(irql);
    }

    VspReleaseWrites(Filter);

    VspAcquire(Filter->Root);

    Filter->IsRemoved = TRUE;
    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    bitmap = (PRTL_BITMAP) InterlockedExchangePointer(
                           (PVOID*) &Filter->ProtectedBlocksBitmap, NULL);
    if (bitmap) {
        ExFreePool(bitmap->Buffer);
        ExFreePool(bitmap);
    }
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    VspRelease(Filter->Root);

    VspAbortPreparedSnapshot(Filter, TRUE, IsFinalRemove);

    InitializeListHead(&listOfDiffAreaFilesToClose);
    InitializeListHead(&listOfDeviceObjectsToDelete);

    VspAcquire(Filter->Root);

    b = FALSE;
    while (!IsListEmpty(&Filter->VolumeList)) {
        VspDeleteOldestSnapshot(Filter, &listOfDiffAreaFilesToClose,
                                &listOfDeviceObjectsToDelete, TRUE, TRUE);
        b = TRUE;
    }
    if (b && !IsFinalRemove) {
        IoInvalidateDeviceRelations(Filter->Pdo, BusRelations);
    }

    if (!IsOffline && !Filter->NotInFilterList) {
        RemoveEntryList(&Filter->ListEntry);
        Filter->NotInFilterList = TRUE;
    }

    if (!IsOffline) {
        Filter->DiffAreaVolume = NULL;

        for (l = Filter->Root->FilterList.Flink;
             l != &Filter->Root->FilterList; l = l->Flink) {

            f = CONTAINING_RECORD(l, FILTER_EXTENSION, ListEntry);

            if (f->DiffAreaVolume == Filter) {
                f->DiffAreaVolume = NULL;
            }
        }
    }

    while (!IsListEmpty(&Filter->DiffAreaFilesOnThisFilter)) {

        l = Filter->DiffAreaFilesOnThisFilter.Flink;
        diffAreaFile = CONTAINING_RECORD(l, VSP_DIFF_AREA_FILE,
                                         FilterListEntry);
        f = diffAreaFile->Extension->Filter;

        if (IsOffline) {
            VspLogError(diffAreaFile->Extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_OFFLINE, STATUS_SUCCESS, 0,
                        TRUE);
        } else {
            VspLogError(diffAreaFile->Extension, diffAreaFile->Filter,
                        VS_ABORT_SNAPSHOTS_DISMOUNT, STATUS_SUCCESS, 3,
                        TRUE);
        }

        VspAbortPreparedSnapshot(f, FALSE, FALSE);

        b = FALSE;
        while (!IsListEmpty(&f->VolumeList)) {
            VspDeleteOldestSnapshot(f, &listOfDiffAreaFilesToClose,
                                    &listOfDeviceObjectsToDelete, FALSE,
                                    TRUE);
            b = TRUE;
        }
        if (b) {
            IoInvalidateDeviceRelations(f->Pdo, BusRelations);
        }
    }

    h = InterlockedExchangePointer(&Filter->ControlBlockFileHandle, NULL);

    VspAcquireNonPagedResource(Filter, NULL, FALSE);

    Filter->FirstControlBlockVolumeOffset = 0;

    if (!IsOffline && Filter->SnapshotOnDiskIrp) {
        ExFreePool(MmGetMdlVirtualAddress(
                   Filter->SnapshotOnDiskIrp->MdlAddress));
        IoFreeMdl(Filter->SnapshotOnDiskIrp->MdlAddress);
        IoFreeIrp(Filter->SnapshotOnDiskIrp);
        Filter->SnapshotOnDiskIrp = NULL;
    }

    VspRemoveLookupEntries(Filter);

    VspReleaseNonPagedResource(Filter);

    hh = InterlockedExchangePointer(&Filter->BootStatHandle, NULL);

    if (!IsOffline) {
        while (!IsListEmpty(&Filter->DeadVolumeList)) {
            l = RemoveHeadList(&Filter->DeadVolumeList);
            extension = CONTAINING_RECORD(l, VOLUME_EXTENSION, ListEntry);
            InterlockedExchange(&extension->DeadToPnp, TRUE);
        }
    }

    VspRelease(Filter->Root);

    VspCloseDiffAreaFiles(&listOfDiffAreaFilesToClose,
                          &listOfDeviceObjectsToDelete);

    if (h) {
        dispInfo.DeleteFile = FALSE;
        ZwSetInformationFile(h, &ioStatus, &dispInfo, sizeof(dispInfo),
                             FileDispositionInformation);
        ZwClose(h);
    }

    if (hh) {
        ZwClose(hh);
    }
}

NTSTATUS
VolSnapPower(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PVOLUME_EXTENSION   extension;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    switch (irpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        case IRP_MN_SET_POWER:
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_POWER:
            if (irpSp->Parameters.Power.ShutdownType == PowerActionHibernate) {
                extension = (PVOLUME_EXTENSION) filter;
                if (extension->IsPreExposure) {
                    status = STATUS_SUCCESS;
                } else {
                    status = VspHandleHibernateNotification(extension, Irp);
                }
            } else {
                status = STATUS_SUCCESS;
            }
            break;

        default:
            status = Irp->IoStatus.Status;
            break;

    }

    if (status == STATUS_PENDING) {
        return STATUS_PENDING;
    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
VolSnapRead(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_READ.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS            status;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(filter->TargetObject, Irp);
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME);

    extension = (PVOLUME_EXTENSION) filter;
    filter = extension->Filter;

    if (!extension->IsStarted || extension->IsPreExposure) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (extension->IsOffline) {
        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_OFF_LINE;
    }

    status = VspIncrementVolumeRefCount(extension);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    IoMarkIrpPending(Irp);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (VspAreBitsSet(extension, Irp)) {
        KeReleaseSpinLock(&extension->SpinLock, irql);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = IoGetCurrentIrpStackLocation(Irp)->
                                    Parameters.Read.Length;
        VspReadCompletionForReadSnapshot(DeviceObject, Irp, extension);
        return STATUS_PENDING;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, VspReadCompletionForReadSnapshot,
                           extension, TRUE, TRUE, TRUE);
    IoCallDriver(filter->TargetObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
VspIncrementRefCount(
    IN  PFILTER_EXTENSION   Filter,
    IN  PIRP                Irp
    )

{
    KIRQL   irql;

    InterlockedIncrement(&Filter->RefCount);
    if (!Filter->HoldIncomingWrites) {
        return STATUS_SUCCESS;
    }

    VspDecrementRefCount(Filter);

    KeAcquireSpinLock(&Filter->SpinLock, &irql);
    if (!Filter->HoldIncomingWrites) {
        InterlockedIncrement(&Filter->RefCount);
        KeReleaseSpinLock(&Filter->SpinLock, irql);
        return STATUS_SUCCESS;
    }
    IoMarkIrpPending(Irp);
    InsertTailList(&Filter->HoldQueue, &Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&Filter->SpinLock, irql);

    return STATUS_PENDING;
}

NTSTATUS
VspRefCountCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Filter
    )

{
    VspDecrementRefCount((PFILTER_EXTENSION) Filter);
    return STATUS_SUCCESS;
}

NTSTATUS
VolSnapWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_WRITE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS            status;
    LONG                r;
    PVOLUME_EXTENSION   extension;
    KIRQL               irql, irql2;
    PLIST_ENTRY         l;
    PVSP_DIFF_AREA_FILE diffAreaFile;
    PIO_STACK_LOCATION  nextSp;
    PVSP_CONTEXT        context;
    PDO_EXTENSION       rootExtension;
    PVSP_WRITE_CONTEXT  writeContext;
    PVSP_COPY_ON_WRITE  copyOnWrite;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER);

    IoMarkIrpPending(Irp);

    status = VspIncrementRefCount(filter, Irp);
    if (status == STATUS_PENDING) {
        if (filter->SnapshotDiscoveryPending) {
            KeAcquireSpinLock(&filter->SpinLock, &irql);
            if (filter->ActivateStarted) {
                KeReleaseSpinLock(&filter->SpinLock, irql);
                return STATUS_PENDING;
            }
            if (filter->FirstWriteProcessed) {
                KeReleaseSpinLock(&filter->SpinLock, irql);
                return STATUS_PENDING;
            }
            InterlockedExchange(&filter->FirstWriteProcessed, TRUE);
            while (!IsListEmpty(&filter->CopyOnWriteList)) {
                l = RemoveHeadList(&filter->CopyOnWriteList);
                copyOnWrite = CONTAINING_RECORD(l, VSP_COPY_ON_WRITE,
                                                ListEntry);
                ExFreePool(copyOnWrite->Buffer);
                ExFreePool(copyOnWrite);
            }
            KeReleaseSpinLock(&filter->SpinLock, irql);

            ObReferenceObject(filter->DeviceObject);

            ExInitializeWorkItem(&filter->DestroyContext.WorkItem,
                                 VspStartCopyOnWriteCache, filter);
            ExQueueWorkItem(&filter->DestroyContext.WorkItem,
                            DelayedWorkQueue);
        }
        return STATUS_PENDING;
    }

    if (filter->ProtectedBlocksBitmap) {
        KeAcquireSpinLock(&filter->SpinLock, &irql);
        if (filter->ProtectedBlocksBitmap &&
            !VspAreBitsClear(filter->ProtectedBlocksBitmap, Irp)) {

            KeReleaseSpinLock(&filter->SpinLock, irql);

            context = VspAllocateContext(filter->Root);
            if (!context) {
                rootExtension = filter->Root;
                KeAcquireSpinLock(&rootExtension->ESpinLock, &irql);
                if (rootExtension->EmergencyContextInUse) {
                    InsertTailList(&rootExtension->IrpWaitingList,
                                   &Irp->Tail.Overlay.ListEntry);
                    if (!rootExtension->IrpWaitingListNeedsChecking) {
                        InterlockedExchange(
                                &rootExtension->IrpWaitingListNeedsChecking,
                                TRUE);
                    }
                    KeReleaseSpinLock(&rootExtension->ESpinLock, irql);
                    VspDecrementRefCount(filter);
                    return STATUS_PENDING;
                }
                rootExtension->EmergencyContextInUse = TRUE;
                KeReleaseSpinLock(&rootExtension->ESpinLock, irql);

                context = rootExtension->EmergencyContext;
            }

            context->Type = VSP_CONTEXT_TYPE_DISMOUNT_CLEANUP;
            ExInitializeWorkItem(&context->WorkItem,
                                 VspDismountCleanupOnWrite, context);
            context->DismountCleanupOnWrite.Filter = filter;
            context->DismountCleanupOnWrite.Irp = Irp;

            VspAcquireNonPagedResource(filter, &context->WorkItem, FALSE);

            return STATUS_PENDING;
        }
        KeReleaseSpinLock(&filter->SpinLock, irql);
    }

    if (filter->SnapshotDiscoveryPending) {
        VspCopyOnWriteToNonPagedPool(filter, Irp);
        return STATUS_PENDING;
    }

    if (!filter->SnapshotsPresent) {
        if (!Irp->MdlAddress) {
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            VspDecrementRefCount(filter);
            return STATUS_PENDING;
        }
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, VspRefCountCompletionRoutine, filter,
                               TRUE, TRUE, TRUE);
        IoCallDriver(filter->TargetObject, Irp);
        return STATUS_PENDING;
    }

    extension = CONTAINING_RECORD(filter->VolumeList.Blink,
                                  VOLUME_EXTENSION, ListEntry);

    KeAcquireSpinLock(&extension->SpinLock, &irql);
    if (VspAreBitsSet(extension, Irp)) {

        if (!Irp->MdlAddress) {
            KeReleaseSpinLock(&extension->SpinLock, irql);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            VspDecrementRefCount(filter);
            return STATUS_PENDING;
        }

        writeContext = VspAllocateWriteContext(filter->Root);
        if (!writeContext) {
            rootExtension = filter->Root;
            KeAcquireSpinLock(&rootExtension->ESpinLock, &irql2);
            if (rootExtension->EmergencyWriteContextInUse) {
                InsertTailList(&rootExtension->WriteContextIrpWaitingList,
                               &Irp->Tail.Overlay.ListEntry);
                if (!rootExtension->WriteContextIrpWaitingListNeedsChecking) {
                    InterlockedExchange(
                    &rootExtension->WriteContextIrpWaitingListNeedsChecking,
                    TRUE);
                }
                KeReleaseSpinLock(&rootExtension->ESpinLock, irql2);
                KeReleaseSpinLock(&extension->SpinLock, irql);
                VspDecrementRefCount(filter);
                return STATUS_PENDING;
            }
            rootExtension->EmergencyWriteContextInUse = TRUE;
            KeReleaseSpinLock(&rootExtension->ESpinLock, irql2);

            writeContext = rootExtension->EmergencyWriteContext;
        }

        writeContext->Filter = filter;
        writeContext->Extension = extension;
        writeContext->Irp = Irp;
        InitializeListHead(&writeContext->CompletionRoutines);

        InsertTailList(&extension->WriteContextList, &writeContext->ListEntry);
        KeReleaseSpinLock(&extension->SpinLock, irql);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, VspWriteContextCompletionRoutine,
                               writeContext, TRUE, TRUE, TRUE);
        IoCallDriver(filter->TargetObject, Irp);
        return STATUS_PENDING;
    }
    KeReleaseSpinLock(&extension->SpinLock, irql);

    context = VspAllocateContext(extension->Root);
    if (!context) {
        rootExtension = extension->Root;
        KeAcquireSpinLock(&rootExtension->ESpinLock, &irql);
        if (rootExtension->EmergencyContextInUse) {
            InsertTailList(&rootExtension->IrpWaitingList,
                           &Irp->Tail.Overlay.ListEntry);
            if (!rootExtension->IrpWaitingListNeedsChecking) {
                InterlockedExchange(
                        &rootExtension->IrpWaitingListNeedsChecking, TRUE);
            }
            KeReleaseSpinLock(&rootExtension->ESpinLock, irql);
            VspDecrementRefCount(filter);
            return STATUS_PENDING;
        }
        rootExtension->EmergencyContextInUse = TRUE;
        KeReleaseSpinLock(&rootExtension->ESpinLock, irql);

        context = rootExtension->EmergencyContext;
    }

    ASSERT(extension->DiffAreaFile);
    diffAreaFile = extension->DiffAreaFile;

    status = VspIncrementRefCount(diffAreaFile->Filter, Irp);
    if (status == STATUS_PENDING) {
        VspFreeContext(extension->Root, context);
        VspDecrementRefCount(filter);
        return STATUS_PENDING;
    }

    nextSp = IoGetNextIrpStackLocation(Irp);
    nextSp->Parameters.Write.Length = 1; // Use this for a ref count.

    context->Type = VSP_CONTEXT_TYPE_WRITE_VOLUME;
    context->WriteVolume.Extension = extension;
    context->WriteVolume.Irp = Irp;
    context->WriteVolume.RoundedStart = 0;
    ExInitializeWorkItem(&context->WorkItem, VspWriteVolume, context);
    if (extension->OnDiskNotCommitted) {
        VspAcquireNonPagedResource(extension, &context->WorkItem, TRUE);
    } else {
        VspAcquireNonPagedResource(extension, &context->WorkItem, FALSE);
    }

    return STATUS_PENDING;
}

NTSTATUS
VolSnapCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_CLEANUP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PFILTER_EXTENSION   filter = (PFILTER_EXTENSION) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT              event;
    KIRQL               irql;
    PIRP                irp;
    PVSP_CONTEXT        context;

    if (filter->DeviceExtensionType == DEVICE_EXTENSION_VOLUME) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(filter->DeviceExtensionType == DEVICE_EXTENSION_FILTER);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, VspSignalCompletion, &event, TRUE, TRUE,
                           TRUE);
    IoCallDriver(filter->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    IoAcquireCancelSpinLock(&irql);
    if (filter->FlushAndHoldIrp) {
        irp = filter->FlushAndHoldIrp;
        if (IoGetCurrentIrpStackLocation(irp)->FileObject ==
            irpSp->FileObject) {

            irp->CancelIrql = irql;
            IoSetCancelRoutine(irp, NULL);
            VspCancelRoutine(DeviceObject, irp);
        } else {
            IoReleaseCancelSpinLock(irql);
        }
    } else {
        IoReleaseCancelSpinLock(irql);
    }

    IoAcquireCancelSpinLock(&irql);
    if (filter->AutoCleanupFileObject == irpSp->FileObject) {
        filter->AutoCleanupFileObject = NULL;
        IoReleaseCancelSpinLock(irql);

        VspDestroyAllSnapshots(filter, NULL, FALSE, FALSE);

    } else {
        IoReleaseCancelSpinLock(irql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

BOOLEAN
VspIsSetup(
    )

{
    UNICODE_STRING              keyName;
    OBJECT_ATTRIBUTES           oa;
    NTSTATUS                    status;
    HANDLE                      h;
    ULONG                       zero, result;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];

    RtlInitUnicodeString(&keyName,
        L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\setupdd");

    InitializeObjectAttributes(&oa, &keyName, OBJ_CASE_INSENSITIVE |
                               OBJ_KERNEL_HANDLE, NULL, NULL);

    status = ZwOpenKey(&h, 0, &oa);
    if (NT_SUCCESS(status)) {
        ZwClose(h);
        return TRUE;
    }

    zero = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"SystemSetupInProgress";
    queryTable[0].EntryContext = &result;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\SYSTEM\\Setup",
                                    queryTable, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        result = zero;
    }

    return result ? TRUE : FALSE;
}

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called when the driver loads loads.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path.

Return Value:

    NTSTATUS

--*/

{
    ULONG               i;
    PDEVICE_OBJECT      deviceObject;
    NTSTATUS            status;
    PDO_EXTENSION       rootExtension;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = VolSnapDefaultDispatch;
    }

    DriverObject->DriverExtension->AddDevice = VolSnapAddDevice;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = VolSnapCreate;
    DriverObject->MajorFunction[IRP_MJ_READ] = VolSnapRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = VolSnapWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = VolSnapDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = VolSnapCleanup;
    DriverObject->MajorFunction[IRP_MJ_PNP] = VolSnapPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = VolSnapPower;

    status = IoAllocateDriverObjectExtension(DriverObject, VolSnapAddDevice,
                                             sizeof(DO_EXTENSION),
                                             (PVOID*) &rootExtension);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlZeroMemory(rootExtension, sizeof(DO_EXTENSION));
    rootExtension->DriverObject = DriverObject;
    InitializeListHead(&rootExtension->FilterList);
    InitializeListHead(&rootExtension->HoldIrps);
    KeInitializeTimer(&rootExtension->HoldTimer);
    KeInitializeDpc(&rootExtension->HoldTimerDpc, VspFsTimerDpc,
                    rootExtension);
    KeInitializeSemaphore(&rootExtension->Semaphore, 1, 1);

    for (i = 0; i < NUMBER_OF_THREAD_POOLS; i++) {
        InitializeListHead(&rootExtension->WorkerQueue[i]);
        KeInitializeSemaphore(&rootExtension->WorkerSemaphore[i], 0, MAXLONG);
        KeInitializeSpinLock(&rootExtension->SpinLock[i]);
    }

    KeInitializeSemaphore(&rootExtension->ThreadsRefCountSemaphore, 1, 1);

    InitializeListHead(&rootExtension->LowPriorityQueue);

    IoRegisterDriverReinitialization(DriverObject, VspDriverReinit,
                                     rootExtension);

    IoRegisterBootDriverReinitialization(DriverObject, VspDriverBootReinit,
                                         rootExtension);

    ExInitializeNPagedLookasideList(&rootExtension->ContextLookasideList,
                                    NULL, NULL, 0, sizeof(VSP_CONTEXT),
                                    VOLSNAP_TAG_CONTEXT, 32);

    rootExtension->EmergencyContext = VspAllocateContext(rootExtension);
    if (!rootExtension->EmergencyContext) {
        ExDeleteNPagedLookasideList(&rootExtension->ContextLookasideList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    InitializeListHead(&rootExtension->IrpWaitingList);
    KeInitializeSpinLock(&rootExtension->ESpinLock);

    ExInitializeNPagedLookasideList(
            &rootExtension->WriteContextLookasideList, NULL, NULL, 0,
            sizeof(VSP_WRITE_CONTEXT), VOLSNAP_TAG_CONTEXT, 32);

    rootExtension->EmergencyWriteContext =
            VspAllocateWriteContext(rootExtension);
    if (!rootExtension->EmergencyWriteContext) {
        ExDeleteNPagedLookasideList(&rootExtension->ContextLookasideList);
        ExDeleteNPagedLookasideList(&rootExtension->WriteContextLookasideList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    InitializeListHead(&rootExtension->WriteContextIrpWaitingList);

    ExInitializeNPagedLookasideList(&rootExtension->TempTableEntryLookasideList,
                                    NULL, NULL, 0, sizeof(RTL_BALANCED_LINKS) +
                                    sizeof(TEMP_TRANSLATION_TABLE_ENTRY),
                                    VOLSNAP_TAG_TEMP_TABLE, 32);

    rootExtension->EmergencyTableEntry =
            VspAllocateTempTableEntry(rootExtension);
    if (!rootExtension->EmergencyTableEntry) {
        ExFreeToNPagedLookasideList(&rootExtension->ContextLookasideList,
                                    rootExtension->EmergencyContext);
        ExDeleteNPagedLookasideList(&rootExtension->WriteContextLookasideList);
        ExDeleteNPagedLookasideList(
                &rootExtension->TempTableEntryLookasideList);
        ExDeleteNPagedLookasideList(&rootExtension->ContextLookasideList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    InitializeListHead(&rootExtension->WorkItemWaitingList);

    rootExtension->RegistryPath.Length = RegistryPath->Length;
    rootExtension->RegistryPath.MaximumLength =
            rootExtension->RegistryPath.Length + sizeof(WCHAR);
    rootExtension->RegistryPath.Buffer = (PWSTR)
                                         ExAllocatePoolWithTag(PagedPool,
                                         rootExtension->RegistryPath.MaximumLength,
                                         VOLSNAP_TAG_SHORT_TERM);
    if (!rootExtension->RegistryPath.Buffer) {
        VspFreeTempTableEntry(rootExtension,
                              rootExtension->EmergencyTableEntry);
        ExFreeToNPagedLookasideList(&rootExtension->ContextLookasideList,
                                    rootExtension->EmergencyContext);
        ExDeleteNPagedLookasideList(&rootExtension->WriteContextLookasideList);
        ExDeleteNPagedLookasideList(
                &rootExtension->TempTableEntryLookasideList);
        ExDeleteNPagedLookasideList(&rootExtension->ContextLookasideList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(rootExtension->RegistryPath.Buffer,
                  RegistryPath->Buffer, RegistryPath->Length);
    rootExtension->RegistryPath.Buffer[RegistryPath->Length/
                                       sizeof(WCHAR)] = 0;

    InitializeListHead(&rootExtension->AdjustBitmapQueue);

    KeInitializeEvent(&rootExtension->PastBootReinit, NotificationEvent,
                      FALSE);

    RtlInitializeGenericTable(&rootExtension->PersistentSnapshotLookupTable,
                              VspSnapshotLookupCompareRoutine,
                              VspSnapshotLookupAllocateRoutine,
                              VspSnapshotLookupFreeRoutine, NULL);
    KeInitializeMutex(&rootExtension->LookupTableMutex, 0);

    rootExtension->IsSetup = VspIsSetup();

    RtlInitializeGenericTable(&rootExtension->UsedDevnodeNumbers,
                              VspUsedDevnodeCompareRoutine,
                              VspSnapshotLookupAllocateRoutine,
                              VspSnapshotLookupFreeRoutine, NULL);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\utils\vsclrda\vsclrda.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                   driveName[10];
    HANDLE                  handle;
    BOOL                    b;
    DWORD                   bytes;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_CLEAR_DIFF_AREA,
                        NULL, 0, NULL, 0, &bytes, NULL);
    if (!b) {
        printf("Clear diff area failed with %d\n", GetLastError());
        return;
    }

    printf("Diff Area Cleared.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\utils\vsda\vsda.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                   driveName[10];
    HANDLE                  handle;
    BOOL                    b;
    DWORD                   bytes;
    PVOLSNAP_NAME           name;
    CHAR                    buffer[100];

    if (argc != 3) {
        printf("usage: %s drive: <diff area drive>:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    name = (PVOLSNAP_NAME) buffer;
    name->NameLength = 12;
    name->Name[0] = '\\';
    name->Name[1] = '?';
    name->Name[2] = '?';
    name->Name[3] = '\\';
    name->Name[4] = (WCHAR) toupper(argv[2][0]);
    name->Name[5] = ':';
    name->Name[6] = 0;

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA,
                        name, 100, NULL, 0, &bytes, NULL);
    if (!b) {
        printf("Add to diff area failed with %d\n", GetLastError());
        return;
    }

    printf("Added %c: to Diff Area for %c:\n", toupper(argv[2][0]),
           toupper(argv[1][0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\utils\vscreate\vscreate.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>
#include <objbase.h>

typedef struct _VSP_CONTEXT {
    HANDLE                          Handle;
    PVOLSNAP_FLUSH_AND_HOLD_INPUT   FlushInput;
} VSP_CONTEXT, *PVSP_CONTEXT;

DWORD
FlushAndHoldRoutine(
    PVOID   Context
    )

{
    PVSP_CONTEXT    context = Context;
    BOOL            b;
    DWORD           bytes;

    b = DeviceIoControl(context->Handle, IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES,
                        context->FlushInput,
                        sizeof(VOLSNAP_FLUSH_AND_HOLD_INPUT), NULL, 0, &bytes,
                        NULL);

    if (!b) {
        printf("Flush and hold failed with %d\n", GetLastError());
        return GetLastError();
    }

    return 0;
}

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                           driveName[10];
    HANDLE                          handle[100];
    VOLSNAP_PREPARE_INFO            prepareInfo;
    BOOL                            b, persistent;
    DWORD                           bytes;
    int                             i, j;
    VOLSNAP_FLUSH_AND_HOLD_INPUT    flushInput;
    PVOLSNAP_NAME                   name;
    WCHAR                           buffer[100];
    HANDLE                          threads[100];
    DWORD                           threadid;
    VSP_CONTEXT                     context[100];

    if (argc < 2) {
        printf("usage: %s [/p] drive: drive: ...\n", argv[0]);
        return;
    }

    if (argv[1][0] == '/' && (argv[1][1] == 'p' || argv[1][1] == 'P')) {
        persistent = TRUE;
        if (argc < 3) {
            printf("usage: %s /p drive: drive: ...\n", argv[0]);
            return;
        }
    } else {
        persistent = FALSE;
    }

    for (i = persistent ? 2 : 1; i < argc; i++) {
        swprintf(driveName, L"\\\\?\\%c:", toupper(argv[i][0]));

        handle[i] = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               INVALID_HANDLE_VALUE);
        if (handle[i] == INVALID_HANDLE_VALUE) {
            printf("Could not open volume %c:, error = %d\n", argv[i][0],
                   GetLastError());
            break;
        }

        if (persistent) {
            prepareInfo.Attributes = 1;
        } else {
            prepareInfo.Attributes = 0;
        }
        prepareInfo.InitialDiffAreaAllocation = 100*1024*1024;

        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT,
                            &prepareInfo, sizeof(prepareInfo), NULL, 0, &bytes,
                            NULL);
        if (!b) {
            printf("Prepare failed with %d\n", GetLastError());
            break;
        }

        CloseHandle(handle[i]);

        handle[i] = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               INVALID_HANDLE_VALUE);
        if (handle == INVALID_HANDLE_VALUE) {
            printf("Could not open volume %c:, error = %d\n", argv[i][0],
                   GetLastError());
            break;
        }
    }

    if (i < argc) {
        for (j = persistent ? 2 : 1; j < i; j++) {
            b = DeviceIoControl(handle[j],
                                IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT,
                                NULL, 0, NULL, 0, &bytes, NULL);
            if (!b) {
                printf("Abort of Prepared snapshot failed with %d\n", GetLastError());
            }
        }
        return;
    }

    CoCreateGuid(&flushInput.InstanceId);
    flushInput.NumberOfVolumesToFlush = argc - (persistent ? 2 : 1);
    flushInput.SecondsToHoldFileSystemsTimeout = 60;
    flushInput.SecondsToHoldIrpsTimeout = 10;

    for (i = persistent ? 2 : 1; i < argc; i++) {
        context[i].Handle = handle[i];
        context[i].FlushInput = &flushInput;
        threads[i] = CreateThread(NULL, 0, FlushAndHoldRoutine, &context[i],
                                  0, &threadid);
    }

    WaitForMultipleObjects(argc - (persistent ? 2 : 1),
                           &threads[persistent ? 2 : 1], TRUE, INFINITE);

    for (i = persistent ? 2 : 1; i < argc; i++) {

        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_COMMIT_SNAPSHOT, NULL, 0,
                            NULL, 0, &bytes, NULL);

        if (!b) {
            printf("Commit failed with %d\n", GetLastError());
            break;
        }
    }

    name = (PVOLSNAP_NAME) buffer;

    if (i < argc) {
        for (j = persistent ? 2 : 1; j < argc; j++) {
            b = DeviceIoControl(handle[j], IOCTL_VOLSNAP_RELEASE_WRITES,
                                NULL, 0, NULL, 0, &bytes, NULL);
        }

        for (j = persistent ? 2 : 1; j < i; j++) {
            b = DeviceIoControl(handle[j], IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT,
                                NULL, 0, name, 200, &bytes, NULL);
        }

        for (; j < argc; j++) {
            b = DeviceIoControl(handle[j],
                                IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT,
                                NULL, 0, NULL, 0, &bytes, NULL);
        }
        return;
    }

    for (i = persistent ? 2 : 1; i < argc; i++) {
        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_RELEASE_WRITES, NULL, 0, NULL,
                            0, &bytes, NULL);

        if (!b) {
            printf("Release writes failed with %d\n", GetLastError());
        }
    }

    for (i = persistent ? 2 : 1; i < argc; i++) {
        b = DeviceIoControl(handle[i], IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT, NULL, 0,
                            name, 200, &bytes, NULL);
        if (!b) {
            printf("End commit failed with %d\n", GetLastError());
        } else {
            name->Name[name->NameLength/sizeof(WCHAR)] = 0;
            printf("%ws  created.\n", name->Name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\utils\vsdelete\vsdelete.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>
#include <objbase.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                           driveName[10];
    HANDLE                          handle;
    BOOL                            b;
    DWORD                           bytes;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT,
                        NULL, 0, NULL, 0, &bytes, NULL);
    if (!b) {
        printf("Kill failed with %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\utils\vsinfo\vsinfo.c ===
#include <windows.h>
#include <winioctl.h>
#include <ntddsnap.h>
#include <stdio.h>
#include <objbase.h>

void __cdecl
main(
    int argc,
    char** argv
    )

{
    WCHAR                   driveName[10];
    HANDLE                  handle, h;
    BOOL                    b;
    DWORD                   bytes;
    PVOLSNAP_NAME           name;
    WCHAR                   buffer[MAX_PATH];
    WCHAR                   originalVolumeName[MAX_PATH];
    VOLSNAP_NAMES           names;
    PVOLSNAP_NAMES          pnames, pn;
    PWCHAR                  p;
    VOLSNAP_DIFF_AREA_SIZES sizes;
    WCHAR                   globalrootName[MAX_PATH];
    WCHAR                   diffAreaName[MAX_PATH];
    FILETIME                fileTime, localFileTime;
    SYSTEMTIME              systemTime;
    VOLSNAP_CONFIG_INFO     configInfo;

    if (argc != 2) {
        printf("usage: %s drive:\n", argv[0]);
        return;
    }

    swprintf(driveName, L"\\\\?\\%c:", toupper(argv[1][0]));

    handle = CreateFile(driveName, 0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        INVALID_HANDLE_VALUE);
    if (handle == INVALID_HANDLE_VALUE) {
        printf("Could not open the given volume %d\n", GetLastError());
        return;
    }

    pnames = &names;
    b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS,
                        NULL, 0, &names, sizeof(names), &bytes, NULL);
    if (!b && GetLastError() == ERROR_MORE_DATA) {
        pnames = LocalAlloc(0, names.MultiSzLength + sizeof(VOLSNAP_NAMES));
        b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS,
                            NULL, 0, pnames, names.MultiSzLength +
                            sizeof(VOLSNAP_NAMES), &bytes, NULL);
    }

    if (!b) {
        printf("Query names of snapshots failed with %d\n", GetLastError());
        return;
    }

    printf("Snapshots of this volume:\n\n");

    p = pnames->Names;
    while (*p) {
        swprintf(globalrootName, L"\\\\?\\GLOBALROOT%s", p);
        h = CreateFile(globalrootName, 0,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            printf("Could not open %ws, failed with %d\n", globalrootName,
                   GetLastError());
            return;
        }

        pn = (PVOLSNAP_NAMES) diffAreaName;
        b = DeviceIoControl(h, IOCTL_VOLSNAP_QUERY_DIFF_AREA, NULL, 0,
                            pn, MAX_PATH*sizeof(WCHAR), &bytes, NULL);
        if (!b) {
            printf("QUERY_DIFF_AREA failed with %d\n", GetLastError());
            return;
        }

        b = DeviceIoControl(h, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES,
                            NULL, 0, &sizes, sizeof(sizes), &bytes, NULL);
        if (!b) {
            printf("QUERY_DIFF_AREA_SIZES failed with %d\n", GetLastError());
            return;
        }

        b = DeviceIoControl(h, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, NULL, 0,
                            &configInfo, sizeof(configInfo), &bytes, NULL);
        if (!b) {
            printf("VOLSNAP_QUERY_CONFIG_INFO failed with %d\n", GetLastError());
            return;
        }

        CopyMemory(&fileTime, &configInfo.SnapshotCreationTime,
                   sizeof(fileTime));
        b = FileTimeToLocalFileTime(&fileTime, &localFileTime);
        if (!b) {
            printf("FileTimeToLocalFileTime failed with %d\n", GetLastError());
            return;
        }
        b = FileTimeToSystemTime(&localFileTime, &systemTime);
        if (!b) {
            printf("FileTimeToSystemTime failed with %d\n", GetLastError());
            return;
        }

        printf("    %ws", p);
        if (configInfo.Attributes&VOLSNAP_ATTRIBUTE_PERSISTENT) {
            printf(" (PERSISTENT)");
        } else {
            printf(" (VOLATILE)");
        }
        printf(" %02d/%02d/%d %02d:%02d:%02d\n",
               systemTime.wMonth, systemTime.wDay, systemTime.wYear,
               systemTime.wHour, systemTime.wMinute, systemTime.wSecond);
        printf("        %ws (%I64d, %I64d)\n\n", pn->Names,
               sizes.UsedVolumeSpace, sizes.AllocatedVolumeSpace);

        while (*p++) {
        }
    }

    printf("\n");

    pnames = &names;
    b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_DIFF_AREA,
                        NULL, 0, &names, sizeof(names), &bytes, NULL);
    if (!b && GetLastError() == ERROR_MORE_DATA) {
        pnames = LocalAlloc(0, names.MultiSzLength + sizeof(VOLSNAP_NAMES));
        b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_DIFF_AREA,
                            NULL, 0, pnames, names.MultiSzLength +
                            sizeof(VOLSNAP_NAMES), &bytes, NULL);
    }

    if (!b) {
        printf("Query diff area failed with %d\n", GetLastError());
        return;
    }

    printf("Next Diff Area for this volume:\n");

    p = pnames->Names;
    while (*p) {
        printf("    %ws\n", p);
        while (*p++) {
        }
    }

    printf("\n");

    b = DeviceIoControl(handle, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES,
                        NULL, 0, &sizes, sizeof(sizes), &bytes, NULL);
    if (!b) {
        printf("Query diff area sizes failed with %d\n", GetLastError());
        return;
    }

    printf("Total UsedVolumeSpace =      %I64d\n", sizes.UsedVolumeSpace);
    printf("Total AllocatedVolumeSpace = %I64d\n", sizes.AllocatedVolumeSpace);
    printf("Total MaximumVolumeSpace =   %I64d\n", sizes.MaximumVolumeSpace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\inc\build.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    build.h

Abstract:

    Declaration of the build number for VSS modules

Remark: 

    DO NOT edit this file!
    This file was generated by buildgen.pl. 
    Rerun buildgen for a new build version!

--*/

#define VSS_BUILD_NO 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\inc\sqlsnap.h ===
//
// sqlsnap.h  Define the interface to the nt/sql snapshot handler.
//
//	The idea here is for a pure interface, making it easy to keep the
// abstraction maximized (can move to COM later, if we like).
//
//  No C++ exceptions will be thrown across the interfaces.
//
//  To use this interface, the calling process must invoke:
//	InitSQLEnvironment - once to setup the environment, establishing
//		the error and trace loggers.
//		The trace logger is optional, but an error logger must be provided.
//      The loggers are created by deriving from CLogFacility and implementing
//		a "WriteImplementation" method.
//
//	Thereafter,	calls to "CreateSqlSnapshot" are used to create snapshot objects
//  which encapsulate the operations needed to support storage snapshots.
//
//  *****************************************
//     LIMITATIONS
//
//	- only SIMPLE databases can be snapshot (trunc on checkpoint = 'true')
//  - there is no serialization of services starting or adding/changing file lists during the snapshot
//  - servers which are not started when the snapshot starts are skipped (non-torn databases will be
//      backed up fine, torn databases won't be detected).
//  - sql7.0 databases which are "un"-useable will prevent snapshots (the list of files can't be obtained).
//
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCSQLSH"
//
////////////////////////////////////////////////////////////////////////

HRESULT InitSQLEnvironment();

// Caller must provide a path checker interface.
//
class CCheckPath
{
public:
	virtual bool IsPathInSnapshot (const WCHAR* path) throw () = 0;
};

//-------------------------------------------------------------
// A handler for snapshots.
//
class CSqlSnapshot
{
public:
	virtual ~CSqlSnapshot () throw () {};

	virtual HRESULT Prepare (
		CCheckPath*			checker) throw () = 0;

	virtual HRESULT Freeze () throw () = 0;

	virtual HRESULT Thaw () throw () = 0;

};

extern "C" CSqlSnapshot* CreateSqlSnapshot () throw ();

//-------------------------------------------------------------
// An enumerator for SQL objects.
//
// An object of this class can have only one active query at
// a time.  Requesting a new enumeration will close any previous
// partially fetched result.
//
#define MAX_SERVERNAME	128
#define MAX_DBNAME	128
struct ServerInfo
{
	bool	isOnline;				// true if the server is ready for connections
	WCHAR	name [MAX_SERVERNAME];	// null terminated name of server
};
struct DatabaseInfo
{
	bool	supportsFreeze;			// true if a freeze operation is supported
	WCHAR	name [MAX_DBNAME];		// null terminated name of database
};
struct DatabaseFileInfo
{
	bool	isLogFile;				// true if this is a log file
	WCHAR	name [MAX_PATH];
};


class CSqlEnumerator
{
public:
	virtual ~CSqlEnumerator () throw () {};

	virtual HRESULT FirstServer (
		ServerInfo*			pServer) throw () = 0;

	virtual HRESULT NextServer (
		ServerInfo*			pServer) throw () = 0;

	virtual HRESULT FirstDatabase (
		const WCHAR*		pServerName,
		DatabaseInfo*		pDbInfo) throw () = 0;

	virtual HRESULT NextDatabase (
		DatabaseInfo*		pDbInfo) throw () = 0;

	virtual HRESULT FirstFile (
		const WCHAR*		pServerName,
		const WCHAR*		pDbName,
		DatabaseFileInfo*	pFileInfo) throw () = 0;

	virtual HRESULT NextFile (
		DatabaseFileInfo*	pFileInfo) throw () = 0;
};

extern "C" CSqlEnumerator* CreateSqlEnumerator () throw ();


//------------------------------------------------------
// HRESULTS returned by the interface.
//
// WARNING: I used facility = x78 arbitrarily!
//
#define SQLLIB_ERROR(code) MAKE_HRESULT(SEVERITY_ERROR, 0x78, code)
#define SQLLIB_STATUS(code) MAKE_HRESULT(SEVERITY_SUCCESS, 0x78, code)

// Status codes
//
#define S_SQLLIB_NOSERVERS	SQLLIB_STATUS(1)	// no SQLServers of interest (from Prepare)

// Error codes
//
#define E_SQLLIB_GENERIC	SQLLIB_ERROR(1)		// something bad, check the errorlog

#define E_SQLLIB_TORN_DB	SQLLIB_ERROR(2)		// database would be torn by the snapshot

#define E_SQLLIB_NO_SUPPORT SQLLIB_ERROR(3)		// 6.5 doesn't support snapshots

#define E_SQLLIB_PROTO		SQLLIB_ERROR(4)		// protocol error (ex: freeze before prepare)

#define E_SQLLIB_NONSIMPLE	SQLLIB_ERROR(5)		// only simple databases are supported
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\inc\sqlwriter.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module sqlwriter.h | Declaration of the sql wrier
    @end

Author:

    Brian Berkowitz  [brianb]  04/17/2000

TBD:
	
	Add comments.

Revision History:

	Name		Date	    Comments
	brianb		04/17/2000  created
	brianb		05/05/2000  added OnIdentify support
	mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCSQLWH"
//
////////////////////////////////////////////////////////////////////////

#ifndef __SQLWRITER_H_
#define __SQLWRITER_H_

class CSqlWriter :
	public CVssWriter,
	public CCheckPath
	{
public:
	STDMETHODCALLTYPE CSqlWriter() :
				m_pSqlSnapshot(NULL),
				m_fFrozen(false)
	    {
	    }

	STDMETHODCALLTYPE ~CSqlWriter()
	    {
	    delete m_pSqlSnapshot;
	    }

	bool STDMETHODCALLTYPE OnIdentify(IVssCreateWriterMetadata *pMetadata);

	bool STDMETHODCALLTYPE OnPrepareSnapshot();

	bool STDMETHODCALLTYPE OnFreeze();

	bool STDMETHODCALLTYPE OnThaw();

	bool STDMETHODCALLTYPE OnAbort();

	bool IsPathInSnapshot(const WCHAR *path) throw();

	HRESULT STDMETHODCALLTYPE Initialize();

	HRESULT STDMETHODCALLTYPE Uninitialize();
private:
	CSqlSnapshot *m_pSqlSnapshot;

	void TranslateWriterError(HRESULT hr);

	bool m_fFrozen;
	};

// wrapper class used to create and destroy the writer
// used by coordinator
class CVssSqlWriterWrapper
	{
public:
	__declspec(dllexport)
	CVssSqlWriterWrapper();
	
	__declspec(dllexport)
	~CVssSqlWriterWrapper();

	__declspec(dllexport)
	HRESULT CreateSqlWriter();

	__declspec(dllexport)
	void DestroySqlWriter();
private:
	// initialization function
	static DWORD InitializeThreadFunc(VOID *pv);

	CSqlWriter *m_pSqlWriter;

	// result of initialization
	HRESULT m_hrInitialize;
	};


	
	
#endif // _SQLWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\inc\ijetwriter.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ijetwriter.h

Abstract:

    Definition of CVssIJetWriter class

	Brian Berkowitz  [brianb]  3/17/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/17/2000  Created
    mikejohn    04/03/2000  Added extra methods for OnIdentify()
    mikejohn	08/21/2000  165913: Deallocate memory on class destruction
			    161899: Add methods for matching paths in exclude list
    mikejohn	09/18/2000  176860: Added calling convention methods where missing

--*/

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCIJWRH"
//
////////////////////////////////////////////////////////////////////////

class CVssIJetWriter;

typedef CVssIJetWriter *PVSSIJETWRITER;


// actual writer class
class CVssIJetWriter : public CVssWriter
	{

// Constructors and destructors
public:
	virtual STDMETHODCALLTYPE ~CVssIJetWriter();

	STDMETHODCALLTYPE CVssIJetWriter() :
		m_wszWriterName(NULL),
		m_wszFilesToInclude(NULL),
		m_wszFilesToExclude(NULL)
		{
		InitializeListHead (&m_leFilesToIncludeEntries);
		InitializeListHead (&m_leFilesToExcludeEntries);
		}
	
	static HRESULT STDMETHODCALLTYPE Initialize
		(
		IN VSS_ID idWriter,
		IN LPCWSTR wszWriterName,
		IN bool bSystemService,
		IN bool bBootableSystemState,
		LPCWSTR wszFilesToInclude,
		LPCWSTR wszFilesToExclude,
		IN CVssJetWriter *pWriter,
		OUT void **ppInstanceCreated
		);

	static void STDMETHODCALLTYPE Uninitialize(IN PVSSIJETWRITER pInstance);

	// callback for identify event
	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	// callback for prepare backup event
	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	// called at Prepare to freeze
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	// called at freeze
	virtual bool STDMETHODCALLTYPE OnFreeze();

	// called at thaw
	virtual bool STDMETHODCALLTYPE OnThaw();

	// called at post snapshot
	virtual bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pComponent);

	// called when timeout occurs
	virtual bool STDMETHODCALLTYPE OnAbort();

	// callback on backup complete event
	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	// callback on prerestore event
	virtual bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponent);


	// callback on postrestore event
	virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);

private:

	HRESULT InternalInitialize
		(
		IN VSS_ID idWriter,
		IN LPCWSTR wszWriterName,
		IN bool bSystemService,
		IN bool bBootableSystemState,
		IN LPCWSTR wszFilesToInclude,
		IN LPCWSTR wszFilesToExclude
		);

	bool PreProcessIncludeExcludeLists  (bool bProcessingIncludeList);
	bool ProcessIncludeExcludeLists     (bool bProcessingIncludeList);
	void PostProcessIncludeExcludeLists (bool bProcessingIncludeList);

	bool ProcessJetInstance (JET_INSTANCE_INFO *pInstanceInfo);

	BOOL CheckExcludedFileListForMatch (LPCWSTR pwszDatabaseFilePath,
					    LPCWSTR pwszDatabaseFileSpec);

	bool FCheckInstanceVolumeDependencies
		(
		IN const JET_INSTANCE_INFO * pInstanceInfo
		) const;

	bool FCheckVolumeDependencies
		(
		IN unsigned long cInstanceInfo,
		IN JET_INSTANCE_INFO *aInstanceInfo
		) const;

	bool FCheckPathVolumeDependencies(IN const char * szPath) const;

	LPCWSTR GetApplicationName() const { return m_wszWriterName; }

	VSS_ID				 m_idWriter;
	LPWSTR				 m_wszWriterName;
	JET_OSSNAPID			 m_idJet;
	CVssJetWriter			*m_pwrapper;
	LPWSTR				 m_wszFilesToInclude;
	LPWSTR				 m_wszFilesToExclude;
	bool				 m_bSystemService;
	bool				 m_bBootableSystemState;
	IVssCreateWriterMetadata	*m_pIMetadata;
	LIST_ENTRY			 m_leFilesToIncludeEntries;
	LIST_ENTRY			 m_leFilesToExcludeEntries;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\inc\version.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    version.h

Abstract:

    Declaration of the version numbers for VSS modules
	Used by version.rc2

Revision History:

    Name        Date        Comments
    aoltean     03/12/99    Created with version 0.1.1, build number 1
    aoltean     09/09/1999  dss -> vss
	aoltean		03/09/2000  Uniform versioning

--*/

// general purpose macros
#define EVAL_MACRO(X) X
#define STRINGIZE_ARG(X) #X
#define STRINGIZE(X) EVAL_MACRO(STRINGIZE_ARG(X))


// Version and build number defines
#define VSS_MAJOR_VERSION  1
#define VSS_MINOR_VERSION  0
#define VSS_FIX_VERSION    0

// Definition for VSS_BUILD_NO
#include "build.h"

// Macros used in resource files
#define VSS_FILEVERSION            VSS_MAJOR_VERSION, VSS_MINOR_VERSION, VSS_FIX_VERSION, VSS_BUILD_NO
#define VSS_PRODUCTVERSION         VSS_MAJOR_VERSION, VSS_MINOR_VERSION, VSS_FIX_VERSION, VSS_BUILD_NO

#define VSS_FILE_VERSION_STR           \
    STRINGIZE(VSS_MAJOR_VERSION) ", "  \
    STRINGIZE(VSS_MINOR_VERSION) ", "  \
    STRINGIZE(VSS_FIX_VERSION) ", "    \
    STRINGIZE(VSS_BUILD_NO)            \
	"\0"

#define VSS_PRODUCT_VERSION_STR        \
    STRINGIZE(VSS_MAJOR_VERSION) ", "  \
    STRINGIZE(VSS_MINOR_VERSION) ", "  \
    STRINGIZE(VSS_FIX_VERSION) ", "    \
    STRINGIZE(VSS_BUILD_NO)            \
	"\0"

#define VSS_COMPANY_NAME		"Microsoft Corporation\0"
#define VSS_LEGAL_COPYRIGHT		"Copyright  2000 by Microsoft Corporation\0"
#define VSS_LEGAL_TRADEMARKS	"Microsoft is a registered trademark of Microsoft Corporation. \0"
#define VSS_PRODUCT_NAME		"Microsoft Windows 2000 Operating System\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\inc\vswrtimp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Writer.h | Declaration of Writer
    @end

Author:

    Adi Oltean  [aoltean]  08/18/1999

TBD:
	
	Add comments.

Revision History:

	Name		Date        Comments
	aoltean		08/18/1999  Created
	brianb		05/03/2000  Changed for new security model
	brianb		05/09/2000  fix problem with autolocks
	mikejohn	06/23/2000  Add connection for SetWriterFailure()
--*/


#ifndef __CVSS_WRITER_IMPL_H_
#define __CVSS_WRITER_IMPL_H_


// forward declarations
class CVssWriterImplStateMachine;
class CVssCreateWriterMetadata;
class CVssWriterComponents;
class IVssWriterComponentsInt;

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "INCWRMPH"
//
////////////////////////////////////////////////////////////////////////


// implementation class for writers
class IVssWriterImpl : public IVssWriter
	{
public:
	// initialize writer
	virtual void Initialize
		(
		VSS_ID writerId,
		LPCWSTR wszWriterName,
		VSS_USAGE_TYPE ut,
		VSS_SOURCE_TYPE st,
		VSS_APPLICATION_LEVEL nLevel,
		DWORD dwTimeout
		) = 0;

    // subscribe to events
	virtual void Subscribe
		(
		) = 0;

    // unsubscribe from events
	virtual void Unsubscribe
		(
		) = 0;

    // get array of volume names
	virtual LPCWSTR *GetCurrentVolumeArray() const = 0;

	// get # of volumes in volume array
	virtual UINT GetCurrentVolumeCount() const = 0;

	// get id of snapshot set
	virtual VSS_ID GetCurrentSnapshotSetId() const = 0;

	// determine which Freeze event writer responds to
	virtual VSS_APPLICATION_LEVEL GetCurrentLevel() const = 0;

	// determine if path is included in the snapshot
	virtual bool IsPathAffected(IN LPCWSTR wszPath) const = 0;

	// determine if bootable state is backed up
	virtual bool IsBootableSystemStateBackedUp() const = 0;

	// determine if the backup application is selecting components
	virtual bool AreComponentsSelected() const = 0;

	// determine the backup type for the backup
	virtual VSS_BACKUP_TYPE GetBackupType() const = 0;

	// let writer pass back indication of reason for failure
    virtual HRESULT SetWriterFailure(HRESULT hr) = 0;
	};


/////////////////////////////////////////////////////////////////////////////
// CVssWriterImpl


class ATL_NO_VTABLE CVssWriterImpl :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IVssWriterImpl
	{

public:
	friend class CVssWriterImplLock;

	// Constructors & Destructors
	CVssWriterImpl();

	~CVssWriterImpl();

// Exposed operations
public:
	// create a writer implementation for a specific writer
	static void CreateWriter
		(
		CVssWriter *pWriter,
		IVssWriterImpl **ppImpl
		);

	// set external writer object
    void SetWriter(CVssWriter *pWriter)
		{
		BS_ASSERT(pWriter);
		m_pWriter = pWriter;
		}

	// initialize class
	void Initialize
		(
		IN VSS_ID WriterID,
		IN LPCWSTR wszWriterName,
		IN VSS_USAGE_TYPE ut,
		IN VSS_SOURCE_TYPE st,
		IN VSS_APPLICATION_LEVEL nLevel,
		IN DWORD dwTimeoutFreeze
		);

    // subscribe to writer events
	void Subscribe
		(
		);

	// unsubscribe from writer events
	void Unsubscribe
		(
		);

    // get array of volume names
	LPCWSTR* GetCurrentVolumeArray() const { return (LPCWSTR *) m_ppwszVolumesArray; };

	// get count of volumes in array
	UINT GetCurrentVolumeCount() const { return m_nVolumesCount; };

	// get id of snapshot
	VSS_ID GetCurrentSnapshotSetId() const { return m_CurrentSnapshotSetId; };

	// get level at which freeze takes place
	VSS_APPLICATION_LEVEL GetCurrentLevel() const { return m_nLevel; };

	// determine if path is included in the snapshot
	bool IsPathAffected(IN	LPCWSTR wszPath) const;

	// determine if the backup is including bootable system state
	bool IsBootableSystemStateBackedUp() const
		{ return m_bBootableSystemStateBackup ? true : false; }

    // determine if the backup selects components
	bool AreComponentsSelected() const
		{ return m_bComponentsSelected ? true : false; }

	// return the type of backup
	VSS_BACKUP_TYPE GetBackupType() const { return m_backupType; }

	// indicate why the writer failed
	HRESULT SetWriterFailure(HRESULT hr);

// IVssWriter ovverides
public:

BEGIN_COM_MAP(CVssWriterImpl)
	COM_INTERFACE_ENTRY(IVssWriter)
END_COM_MAP()

	// request WRITER_METADATA or writer state
    STDMETHOD(RequestWriterInfo)(
        IN  	BSTR bstrSnapshotSetId,
		IN  	BOOL bWriterMetadata,
		IN  	BOOL bWriterState,
		IN  	IDispatch* pWriterCallback		
        );

    // prepare for backup event
    STDMETHOD(PrepareForBackup)(
        IN  	BSTR bstrSnapshotSetId,					
		IN  	IDispatch* pWriterCallback
        );

	// prepare for snapshot event
    STDMETHOD(PrepareForSnapshot)(
        IN  	BSTR bstrSnapshotSetId,					
        IN  	BSTR VolumeNamesList
        );

    // freeze event
    STDMETHOD(Freeze)(
        IN      BSTR bstrSnapshotSetId,
        IN      INT nApplicationLevel
        );

    // thaw event
    STDMETHOD(Thaw)(
        IN      BSTR bstrSnapshotSetId
        );

    // backup complete event
    STDMETHOD(BackupComplete)(
        IN      BSTR bstrSnapshotSetId,
		IN  	IDispatch* pWriterCallback
        );

	// backup shutdown event
    STDMETHOD(BackupShutdown)(
    	IN 	   BSTR bstrSnapshotSetId
    	);

    // abort event
    STDMETHOD(Abort)(
        IN      BSTR bstrSnapshotSetId
        );

    STDMETHOD(PostRestore)(
		IN  	IDispatch* pWriterCallback
        );

    STDMETHOD(PreRestore)(
		IN  	IDispatch* pWriterCallback
        );


    STDMETHOD(PostSnapshot)(
		IN		BSTR bstrSnapshotSestId,
		IN		IDispatch* pWriterCallback,
		IN		BSTR SnapshotDevicesList
		);




// Implementation - methods
private:
	enum VSS_EVENT_MASK
		{
		VSS_EVENT_PREPAREBACKUP		= 0x00000001,
		VSS_EVENT_PREPARESNAPSHOT	= 0x00000002,
		VSS_EVENT_FREEZE			= 0x00000004,
		VSS_EVENT_THAW				= 0x00000008,
		VSS_EVENT_ABORT				= 0x00000010,
		VSS_EVENT_BACKUPCOMPLETE	= 0x00000020,
		VSS_EVENT_REQUESTINFO		= 0x00000040,
		VSS_EVENT_RESTORE			= 0x00000080,
		VSS_EVENT_ALL				= 0xff,
		};

    // get WRITER callback from IDispatch
	void GetCallback
		(
		IN IDispatch *pWriterCallback,
		OUT IVssWriterCallback **ppCallback
		);

    // reset state machine
	void ResetSequence
		(
		IN bool bCalledFromTimerThread
		);

    // abort the current snapshot sequence
	void DoAbort
		(
		IN bool bCalledFromTimerThread
		);

    // obtain components for this writer
    void InternalGetWriterComponents
		(
		IN IVssWriterCallback *pCallback,
		OUT IVssWriterComponentsInt **ppWriter,
		bool bWriteable
		);

    // create WRITER_METADATA XML document
	CVssCreateWriterMetadata *CreateBasicWriterMetadata
		(
		);

	// startup routine for timer thread
    static DWORD StartTimerThread(void *pv);

	// function to run in timer thread
	void TimerFunc(VSS_ID id);

	// enter a state
	bool EnterState
		(
		IN const CVssWriterImplStateMachine &vwsm,
		IN BSTR bstrSnapshotSetId
		) throw(HRESULT);

	// leave a state
	void LeaveState
		(
		IN const CVssWriterImplStateMachine &vwsm,
		IN bool fSuccessful
		);

    // create a Handle to an event
    void SetupEvent
		(
		IN HANDLE *phevt
		) throw(HRESULT);

    // begin a sequence to create a snapshot
    void BeginSequence
		(
		IN CVssID &SnapshotSetId
		) throw(HRESULT);

    INT SearchForPreviousSequence(
        IN  VSS_ID& idSnapshotSet
        );

    // terminate timer thread
	void TerminateTimerThread();

	// lock critical section
	inline void Lock()
		{
		m_cs.Lock();
		m_bLocked = true;
		}

	// unlock critical section
	inline void Unlock()
		{
		m_bLocked = false;
		m_cs.Unlock();
		}

	// assert that critical section is locked
	inline void AssertLocked()
		{
		BS_ASSERT(m_bLocked);
		}

// Implementation - members
private:
    enum VSS_TIMER_COMMAND
        {
        VSS_TC_UNDEFINED,
		VSS_TC_ABORT_CURRENT_SEQUENCE,
        VSS_TC_TERMINATE_THREAD,
		VSS_TIMEOUT_FREEZE = 60*1000,			// 30 seconds
		VSS_STACK_SIZE = 256 * 1024			// 256K
        };

    enum
		{
		x_MAX_SUBSCRIPTIONS = 32
		};



	// data related to writer

	// writer class id
	VSS_ID m_WriterID;

	// writer instance id
	VSS_ID m_InstanceID;

	// usage type for writer
	VSS_USAGE_TYPE m_usage;

	// data source type for writer
	VSS_SOURCE_TYPE m_source;

	// writer name
	LPWSTR m_wszWriterName;

	// Data related to the current sequence

	// snapshot set id
	VSS_ID m_CurrentSnapshotSetId;

	// volume array list passed in as a string
	LPWSTR m_pwszLocalVolumeNameList;

	// # of volumes in volume array
	INT m_nVolumesCount;

	// volume array
	LPWSTR* m_ppwszVolumesArray;

	// pointer to writer callback
	CComPtr<IVssWriterCallback> m_pWriterCallback;

	// are we currently in a sequence
	bool m_bSequenceInProgress;

	// current state of the writer
    VSS_WRITER_STATE m_state;

	// Subscription-related data
	CComBSTR m_bstrSubscriptionName;

	// actual subscription ids
	CComBSTR m_rgbstrSubscriptionId[x_MAX_SUBSCRIPTIONS];

	// number of allocated subscription ids
	UINT m_cbstrSubscriptionId;
	
	// Data related with the Writer object

	// which freeze event is handled
	VSS_APPLICATION_LEVEL m_nLevel;

	// what events are subscribed to
	DWORD m_dwEventMask;

	// count of subscriptions
	INT m_nSubscriptionsCount;

	// Critical section or avoiding race between tasks
	CVssSafeCriticalSection				m_cs;

	// was critical section initialized
	bool m_bLockCreated;

	// flag indicating if critical section is locked
	bool m_bLocked;

    // timeout and queuing mechanisms
    HANDLE m_hevtTimerThread;       // event used to signal timer thread if timer is aborted
    HANDLE m_hmtxTimerThread;  		// mutex used to guarantee only one timer thread exists at a time
	HANDLE m_hThreadTimerThread;	// handle to timer thread
	VSS_TIMER_COMMAND m_command;	// timer command when it exits the wait
	DWORD m_dwTimeoutFreeze;		// timeout for freeze

	// actual writer implementation
	CVssWriter *m_pWriter;


	// state of backup components
	BOOL m_bBootableSystemStateBackup;
	BOOL m_bComponentsSelected;
	VSS_BACKUP_TYPE m_backupType;

	// indication why the writer failed
	HRESULT m_hrWriterFailure;
	
	// structures to keep track of writer status from previous snapshots
	enum
		{
		MAX_PREVIOUS_SNAPSHOTS = 8,
		INVALID_SEQUENCE_INDEX = -1
		};

	// snapshot ids of previous snapshots
	VSS_ID m_rgidPreviousSnapshots[MAX_PREVIOUS_SNAPSHOTS];

	// status from previous snapshots
	VSS_WRITER_STATE m_rgstatePreviousSnapshots[MAX_PREVIOUS_SNAPSHOTS];

	// failure reasons from previous snapshots
	HRESULT m_rghrWriterFailurePreviousSnapshots[MAX_PREVIOUS_SNAPSHOTS];

	// current slot for dumping a previous snapshots result
	UINT m_iPreviousSnapshots;

    // TRUE if an OnPrepareForBackup/Freeze/Thaw
    // was sent and without a corresponding OnAbort
	bool m_bOnAbortPermitted;

    // FALSE if an previous OnIdentify failed
    // TRUE if OnIdentify succeeded or was not called at all
	bool m_bFailedAtIdentify;
	};


// auto class for locks
class CVssWriterImplLock
	{
public:
	CVssWriterImplLock(CVssWriterImpl *pImpl) :
		m_pImpl(pImpl)
		{
		m_pImpl->Lock();
		}

	~CVssWriterImplLock()
		{
		m_pImpl->Unlock();
		}

private:
	CVssWriterImpl *m_pImpl;
	};




#endif //__CVSS_WRITER_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\cmxml.c ===
WCHAR g_ComponentMetadataXML[] = 
{L'<', L'r', L'o', L'o', L't', L'>', L'\n', L'<', L'S', L'c', 
L'h', L'e', L'm', L'a', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'V', L's', L's', L'C', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L'M', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'"', L' ', L'x', L'm', L'l', L'n', L's', L'=', L'"', 
L'u', L'r', L'n', L':', L's', L'c', L'h', L'e', L'm', L'a', 
L's', L'-', L'm', L'i', L'c', L'r', L'o', L's', L'o', L'f', 
L't', L'-', L'c', L'o', L'm', L':', L'x', L'm', L'l', L'-', 
L'd', L'a', L't', L'a', L'"', L' ', L'x', L'm', L'l', L'n', 
L's', L':', L'd', L't', L'=', L'"', L'u', L'r', L'n', L':', 
L's', L'c', L'h', L'e', L'm', L'a', L's', L'-', L'm', L'i', 
L'c', L'r', L'o', L's', L'o', L'f', L't', L'-', L'c', L'o', 
L'm', L':', L'd', L'a', L't', L'a', L't', L'y', L'p', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'f', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L'F', L'i', L'l', L'e', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'c', L'a', L't', L'i', L'o', L'n', L'.', 
L' ', L' ', L'C', L'a', L'n', L' ', L'i', L'n', L'c', L'l', 
L'u', L'd', L'e', L' ', L'w', L'i', L'l', L'd', L'c', L'a', 
L'r', L'd', L' ', L'c', L'h', L'a', L'r', L'a', L'c', L't', 
L'e', L'r', L's', L' ', L'?', L' ', L'a', L'n', L'd', L' ', 
L'*', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'p', L'a', L't', L'h', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'P', L'a', L't', L'h', L' ', L't', L'o', 
L' ', L'a', L' ', L'f', L'i', L'l', L'e', L'.', L' ', L' ', 
L'T', L'h', L'e', L' ', L'p', L'a', L't', L'h', L' ', L'c', 
L'a', L'n', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'e', 
L' ', L'e', L'n', L'v', L'i', L'r', L'o', L'n', L'm', L'e', 
L'n', L't', L' ', L'v', L'a', L'r', L'i', L'a', L'b', L'l', 
L'e', L's', L' ', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', 
L'v', L'a', L'l', L'u', L'e', L's', L' ', L'e', L'x', L't', 
L'r', L'a', L'c', L't', L'e', L'd', L' ', L'f', L'r', L'o', 
L'm', L' ', L'r', L'e', L'g', L'i', L's', L't', L'r', L'y', 
L' ', L'k', L'e', L'y', L's', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', 
L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'n', 
L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'I', L's', L' ', L'p', L'a', 
L't', L'h', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L' ', L'r', L'e', L'c', L'u', L'r', L's', L'i', 
L'v', L'e', L' ', L'o', L'r', L' ', L'l', L'i', L'm', L'i', 
L't', L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L' ', L'd', L'i', L'r', L'e', L'c', L't', L'o', L'r', L'y', 
L' ', L't', L'h', L'a', L't', L' ', L'i', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'f', L'i', L'e', L'd', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', 
L'P', L'a', L't', L'h', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', 
L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'A', 
L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'p', 
L'a', L't', L'h', L' ', L'i', L'n', L' ', L'w', L'h', L'i', 
L'c', L'h', L' ', L't', L'o', L' ', L'f', L'i', L'n', L'd', 
L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L'.', 
L' ', L' ', L'F', L'i', L'l', L'e', L's', L' ', L'i', L'n', 
L' ', L'a', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L' ', L'm', L'a', L'y', L'\r', L'\n', L' ', 
L' ', L' ', L'h', L'a', L'v', L'e', L' ', L'b', L'e', L'e', 
L'n', L' ', L'c', L'o', L'p', L'i', L'e', L'd', L' ', L't', 
L'o', L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'i', L'v', L'e', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L'b', L'y', L' ', L't', 
L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'.', 
L' ', L' ', L'B', L'a', L'c', L'k', L'u', L'p', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L'\r', L'\n', L' ', L' ', L' ', 
L'p', L'i', L'c', L'k', L' ', L'u', L'p', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'f', L'r', 
L'o', L'm', L' ', L't', L'h', L'e', L' ', L'a', L'l', L't', 
L'e', L'r', L'n', L'a', L't', L'i', L'v', L'e', L' ', L'l', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'i', L'n', 
L's', L't', L'e', L'a', L'd', L' ', L'o', L'f', L' ', L't', 
L'h', L'e', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', 
L'l', L'\r', L'\n', L' ', L' ', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L' ', L'b', L'u', L't', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L't', L'h', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L't', L'h', L'e', 
L'i', L'r', L' ', L'o', L'r', L'i', L'g', L'i', L'n', L'a', 
L'l', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', 
L'a', L't', L'h', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'L', L'o', 
L'g', L'i', L'c', L'a', L'l', L' ', L'p', L'a', L't', L'h', 
L' ', L'f', L'o', L'r', L' ', L'a', L' ', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', 
L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', L'p', L'.', 
L' ', L' ', L'T', L'h', L'i', L's', L' ', L'l', L'o', L'g', 
L'i', L'c', L'a', L'l', L' ', L'n', L'a', L'm', L'e', L' ', 
L'u', L's', L'e', L's', L' ', L'b', L'a', L'c', L'k', L's', 
L'l', L'a', L's', L'h', L'\r', L'\n', L' ', L' ', L' ', L'a', 
L's', L' ', L's', L'e', L'p', L'a', L'r', L'a', L't', L'o', 
L'r', L's', L' ', L't', L'o', L' ', L'f', L'o', L'r', L'm', 
L' ', L'a', L' ', L'l', L'o', L'g', L'i', L'c', L'a', L'l', 
L' ', L'n', L'a', L'm', L'e', L's', L'p', L'a', L'c', L'e', 
L' ', L'h', L'i', L'e', L'r', L'a', L'r', L'c', L'h', L'y', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L'N', L'a', L'm', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', 
L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', 
L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L'N', L'a', L'm', L'e', L' ', L'u', L's', L'e', L'd', 
L' ', L't', L'o', L' ', L'i', L'd', L'e', L'n', L't', L'i', 
L'f', L'y', L' ', L'a', L' ', L'd', L'a', L't', L'a', L'b', 
L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L'.', L' ', L' ', 
L'M', L'a', L'y', L' ', L'b', L'e', L' ', L'q', L'u', L'a', 
L'l', L'i', L'f', L'i', L'e', L'd', L' ', L'b', L'y', L' ', 
L'a', L'\r', L'\n', L' ', L' ', L' ', L'l', L'o', L'g', L'i', 
L'c', L'a', L'l', L' ', L'p', L'a', L't', L'h', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'v', L'e', L'r', L's', L'i', L'o', L'n', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'1', L'.', L'0', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'V', L'e', L'r', L's', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'a', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'd', L'o', L'c', 
L'u', L'm', L'e', L'n', L't', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'w', L'r', L'i', 
L't', L'e', L'r', L'I', L'd', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'U', 
L'n', L'i', L'q', L'u', L'e', L' ', L'i', L'd', L' ', L't', 
L'o', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', 
L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', 
L'r', L'.', L' ', L' ', L'N', L'o', L't', L'e', L' ', L't', 
L'h', L'a', L't', L' ', L't', L'h', L'i', L's', L' ', L'i', 
L'd', L'e', L'n', L't', L'i', L'f', L'i', L'e', L's', L' ', 
L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'c', L'l', L'a', L's', L's', 
L' ', L'r', L'a', L't', L'h', L'e', L'r', L' ', L't', L'h', 
L'a', L'n', L' ', L'a', L' ', L's', L'p', L'e', L'c', L'i', 
L'f', L'i', L'c', L' ', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'i', 
L'n', L's', L't', L'a', L'n', L'c', L'e', L'I', L'd', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L'u', L'u', L'i', L'd', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'U', L'n', L'i', L'q', L'u', L'e', L' ', L'i', 
L'd', L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'y', 
L'i', L'n', L'g', L' ', L't', L'h', L'e', L' ', L'i', L'n', 
L's', L't', L'a', L'n', L'c', L'e', L' ', L'o', L'f', L' ', 
L'a', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L'd', 
L'u', L'r', L'i', L'n', L'g', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L'.', L' ', L' ', L'I', L't', L'\r', L'\n', L' ', 
L' ', L' ', L'h', L'a', L's', L' ', L'n', L'o', L' ', L'm', 
L'e', L'a', L'n', L'i', L'n', L'g', L' ', L'd', L'u', L'r', 
L'i', L'n', L'g', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'C', 
L'O', L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'S', L'"', 
L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', 
L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', 
L'e', L'd', L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', 
L'"', L'm', L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'C', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', L' ', 
L't', L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', L'b', 
L'a', L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', L'o', 
L'r', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L'U', L's', L'e', L'd', 
L' ', L't', L'o', L' ', L'c', L'o', L'm', L'm', L'u', L'n', 
L'i', L'c', L'a', L't', L'e', L' ', L'b', L'e', L't', L'w', 
L'e', L'e', L'n', L' ', L't', L'h', L'e', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'a', L'n', L'd', L' ', L't', 
L'h', L'e', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L'\r', L'\n', 
L' ', L' ', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'n', L'd', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'C', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L's', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', 
L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'D', L'o', L'e', L's', L' ', L't', 
L'h', L'e', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L's', L'e', L'l', L'e', L'c', L't', L' ', L'i', 
L'n', L'd', L'i', L'v', L'i', L'd', L'u', L'a', L'l', L' ', 
L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L's', 
L' ', L'o', L'r', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'd', L'o', L'e', L's', L' ', L'i', L't', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'e', L'n', L't', L'i', 
L'r', L'e', L' ', L'v', L'o', L'l', L'u', L'm', L'e', L's', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'b', L'o', L'o', 
L't', L'a', L'b', L'l', L'e', L'S', L'y', L's', L't', L'e', 
L'm', L'S', L't', L'a', L't', L'e', L'B', L'a', L'c', L'k', 
L'u', L'p', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', 
L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'I', L's', L' ', L'b', L'a', L'c', 
L'k', L'u', L'p', L' ', L's', L'a', L'v', L'i', L'n', L'g', 
L' ', L't', L'h', L'e', L' ', L'b', L'o', L'o', L't', L'a', 
L'b', L'l', L'e', L' ', L's', L't', L'a', L't', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L's', L'y', L's', 
L't', L'e', L'm', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'b', L'a', L'c', L'k', L'u', L'p', L'T', L'y', L'p', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'f', L'u', L'l', L'l', 
L' ', L'd', L'i', L'f', L'f', L'e', L'r', L'e', L'n', L't', 
L'i', L'a', L'l', L' ', L'i', L'n', L'c', L'r', L'e', L'm', 
L'e', L'n', L't', L'a', L'l', L' ', L'o', L't', L'h', L'e', 
L'r', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'T', L'y', L'p', L'e', L' ', L'o', 
L'f', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'b', 
L'e', L'i', L'n', L'g', L' ', L'p', L'e', L'r', L'f', L'o', 
L'r', L'm', L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'v', L'e', 
L'r', L's', L'i', L'o', L'n', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L'e', L'l', L'e', L'c', L't', L'C', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L's', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'b', 
L'o', L'o', L't', L'a', L'b', L'l', L'e', L'S', L'y', L's', 
L't', L'e', L'm', L'S', L't', L'a', L't', L'e', L'B', L'a', 
L'c', L'k', L'u', L'p', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'b', L'a', 
L'c', L'k', L'u', L'p', L'T', L'y', L'p', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'W', L'R', L'I', L'T', L'E', L'R', L'_', L'C', L'O', L'M', 
L'P', L'O', L'N', L'E', L'N', L'T', L'S', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'W', 
L'R', L'I', L'T', L'E', L'R', L'_', L'C', L'O', L'M', L'P', 
L'O', L'N', L'E', L'N', L'T', L'S', L'"', L' ', L'c', L'o', 
L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', 
L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', 
L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'C', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L's', L' ', L't', L'h', L'a', 
L't', L' ', L'a', L'r', L'e', L' ', L'b', L'a', L'c', L'k', 
L'e', L'd', L' ', L'u', L'p', L' ', L'a', L'n', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', L'a', L's', 
L's', L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', 
L'i', L't', L'h', L' ', L'a', L'\r', L'\n', L' ', L' ', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L' ', L'i', L'n', L's', L't', 
L'a', L'n', L'c', L'e', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', 
L'I', L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'i', L'n', L's', L't', 
L'a', L'n', L'c', L'e', L'I', L'd', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'C', L'O', 
L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'C', 
L'O', L'M', L'P', L'O', L'N', L'E', L'N', L'T', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'o', L'p', L'e', L'n', L'"', 
L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', 
L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'b', 
L'a', L'c', L'k', L'u', L'p', L'S', L'u', L'c', L'c', L'e', 
L'e', L'd', L'e', L'd', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', 
L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', 
L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'y', 
L'e', L's', L' ', L'n', L'o', L'"', L' ', L'd', L'e', L'f', 
L'a', L'u', L'l', L't', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L'I', L'n', L'd', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', 
L'w', L'h', L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', 
L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', L'n', 
L't', L' ', L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', 
L'e', L'd', L' ', L'u', L'p', L' ', L's', L'u', L'c', L'c', 
L'e', L's', L's', L'f', L'u', L'l', L'l', L'y', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L'o', L'r', L' ', L'n', 
L'o', L't', L'.', L' ', L' ', L'T', L'h', L'i', L's', L' ', 
L's', L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', 
L's', L'e', L't', L' ', L'd', L'u', L'r', L'i', L'n', L'g', 
L' ', L't', L'h', L'e', L' ', L'B', L'a', L'c', L'k', L'u', 
L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', L' ', 
L'n', L'o', L't', L'i', L'f', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'c', 
L'o', L'm', L'p', L'o', L'n', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', 
L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', 
L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', 
L'a', L'l', L'u', L'e', L's', L'=', L'"', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L' ', L'f', L'i', L'l', L'e', 
L'g', L'r', L'o', L'u', L'p', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L'I', L'n', L'd', L'i', L'c', L'a', 
L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', L'w', L'h', 
L'e', L't', L'h', L'e', L'r', L' ', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L' ', L'i', L's', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'c', L'o', L'm', 
L'p', L'o', L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'b', L'a', L'c', L'k', L'u', L'p', 
L'S', L'u', L'c', L'c', L'e', L'e', L'd', L'e', L'd', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', 
L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'M', L'E', 
L'T', L'A', L'D', L'A', L'T', L'A', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'1', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'A', L'L', L'T', L'E', 
L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', L'A', 
L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', L'I', 
L'N', L'G', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'0', L'"', L' ', L'm', L'a', 
L'x', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'*', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', 
L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', 
L'_', L'M', L'A', L'P', L'P', L'I', L'N', L'G', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L'M', L'a', L'p', L'p', L'i', 
L'n', L'g', L' ', L'f', L'r', L'o', L'm', L' ', L'a', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L't', 
L'h', L'a', L't', L' ', L'w', L'a', L's', L' ', L'b', L'a', 
L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', L't', L'o', 
L' ', L'a', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L't', L'o', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L't', L'o', L'.', L'\r', L'\n', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', L'h', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', 
L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', L'u', L'r', 
L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'a', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L'P', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', 
L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', 
L'M', L'E', L'T', L'A', L'D', L'A', L'T', L'A', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'm', L'p', L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', 
L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'D', L'e', L'f', L'a', L'u', L'l', L't', 
L' ', L'm', L'e', L't', L'a', L'd', L'a', L't', L'a', L' ', 
L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L'f', L'o', 
L'r', L' ', L'b', L'a', L'c', L'k', L'u', L'p', L'.', L' ', 
L' ', L'C', L'o', L'n', L't', L'e', L'n', L't', L' ', L'i', 
L's', L' ', L'a', L' ', L'b', L'i', L'n', L'a', L'r', L'y', 
L' ', L'h', L'e', L'x', L' ', L's', L't', L'r', L'i', L'n', 
L'g', L'.', L'\r', L'\n', L' ', L' ', L' ', L'N', L'o', L't', 
L'e', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', L'e', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', L'c', L'a', 
L'n', L' ', L's', L't', L'o', L'r', L'e', L' ', L'w', L'h', 
L'a', L't', L'e', L'v', L'e', L'r', L' ', L'h', L'e', L' ', 
L'w', L'a', L'n', L't', L's', L' ', L'i', L'n', L' ', L't', 
L'h', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'.', L' ', L' ', L'T', L'h', L'i', L's', L'\r', 
L'\n', L' ', L' ', L' ', L'i', L's', L' ', L'j', L'u', L's', 
L't', L' ', L'a', L' ', L's', L'i', L'm', L'p', L'l', L'e', 
L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L' ', L'm', 
L'e', L'c', L'h', L'a', L'n', L'i', L's', L'm', L'.', L'\r', 
L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'm', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'M', L'e', L't', L'a', L'd', L'a', L't', L'a', L' ', 
L't', L'o', L' ', L'b', L'e', L' ', L'p', L'a', L's', L's', 
L'e', L'd', L' ', L'o', L'n', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'<', L'/', L'S', L'c', 
L'h', L'e', L'm', L'a', L'>', L'\r', L'\n', 
L'\n', L'<', L'/', L'r', L'o', L'o', L't', L'>', L'\n', L'\0'
};
const unsigned g_cwcComponentMetadataXML = 5626;


const unsigned g_iwcComponentMetadataXMLBegin = 7;


const unsigned g_iwcComponentMetadataXMLEnd = 5617;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\wmxml.c ===
WCHAR g_WriterMetadataXML[] = 
{
L'<', L'S', L'c', L'h', L'e', L'm', L'a', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'V', L's', L's', L'W', L'r', L'i', 
L't', L'e', L'r', L'M', L'e', L't', L'a', L'd', L'a', L't', 
L'a', L'I', L'n', L'f', L'o', L'"', L' ', L'x', L'm', L'l', 
L'n', L's', L'=', L'"', L'u', L'r', L'n', L':', L's', L'c', 
L'h', L'e', L'm', L'a', L's', L'-', L'm', L'i', L'c', L'r', 
L'o', L's', L'o', L'f', L't', L'-', L'c', L'o', L'm', L':', 
L'x', L'm', L'l', L'-', L'd', L'a', L't', L'a', L'"', L' ', 
L'x', L'm', L'l', L'n', L's', L':', L'd', L't', L'=', L'"', 
L'u', L'r', L'n', L':', L's', L'c', L'h', L'e', L'm', L'a', 
L's', L'-', L'm', L'i', L'c', L'r', L'o', L's', L'o', L'f', 
L't', L'-', L'c', L'o', L'm', L':', L'd', L'a', L't', L'a', 
L't', L'y', L'p', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'f', L'i', L'l', L'e', L's', L'p', L'e', L'c', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'F', L'i', L'l', L'e', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L'a', L't', 
L'i', L'o', L'n', L'.', L' ', L' ', L'C', L'a', L'n', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'w', L'i', 
L'l', L'd', L'c', L'a', L'r', L'd', L' ', L'c', L'h', L'a', 
L'r', L'a', L'c', L't', L'e', L'r', L's', L' ', L'?', L' ', 
L'a', L'n', L'd', L' ', L'*', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'P', L'a', L't', 
L'h', L' ', L't', L'o', L' ', L'a', L' ', L'f', L'i', L'l', 
L'e', L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'p', L'a', 
L't', L'h', L' ', L'c', L'a', L'n', L' ', L'i', L'n', L'c', 
L'l', L'u', L'd', L'e', L' ', L'e', L'n', L'v', L'i', L'r', 
L'o', L'n', L'm', L'e', L'n', L't', L' ', L'v', L'a', L'r', 
L'i', L'a', L'b', L'l', L'e', L's', L' ', L'o', L'r', L'\r', 
L'\n', L' ', L' ', L' ', L'v', L'a', L'l', L'u', L'e', L's', 
L' ', L'e', L'x', L't', L'r', L'a', L'c', L't', L'e', L'd', 
L' ', L'f', L'r', L'o', L'm', L' ', L'r', L'e', L'g', L'i', 
L's', L't', L'r', L'y', L' ', L'k', L'e', L'y', L's', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', 
L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', 
L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'I', 
L's', L' ', L'p', L'a', L't', L'h', L' ', L's', L'p', L'e', 
L'c', L'i', L'f', L'i', L'e', L'd', L' ', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L' ', L'o', L'r', L' ', 
L'l', L'i', L'm', L'i', L't', L'e', L'd', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L' ', L'd', L'i', L'r', L'e', L'c', 
L't', L'o', L'r', L'y', L' ', L't', L'h', L'a', L't', L' ', 
L'i', L's', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L'P', L'a', L't', L'h', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L' ', L' ', L' ', L'A', L'l', L't', L'e', L'r', L'n', L'a', 
L't', L'e', L' ', L'p', L'a', L't', L'h', L' ', L'i', L'n', 
L' ', L'w', L'h', L'i', L'c', L'h', L' ', L't', L'o', L' ', 
L'f', L'i', L'n', L'd', L' ', L't', L'h', L'e', L' ', L'f', 
L'i', L'l', L'e', L'.', L' ', L' ', L'F', L'i', L'l', L'e', 
L's', L' ', L'i', L'n', L' ', L'a', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L' ', L'm', L'a', 
L'y', L'\r', L'\n', L' ', L' ', L' ', L'h', L'a', L'v', L'e', 
L' ', L'b', L'e', L'e', L'n', L' ', L'c', L'o', L'p', L'i', 
L'e', L'd', L' ', L't', L'o', L' ', L'a', L'n', L' ', L'a', 
L'l', L't', L'e', L'r', L'n', L'a', L't', L'i', L'v', L'e', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', 
L'b', L'y', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L'.', L' ', L' ', L'B', L'a', L'c', L'k', 
L'u', L'p', L' ', L's', L'h', L'o', L'u', L'l', L'd', L'\r', 
L'\n', L' ', L' ', L' ', L'p', L'i', L'c', L'k', L' ', L'u', 
L'p', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', 
L' ', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'i', 
L'v', L'e', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'i', L'n', L's', L't', L'e', L'a', L'd', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L'\r', L'\n', L' ', L' ', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'b', 
L'u', L't', L' ', L's', L'h', L'o', L'u', L'l', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', 
L' ', L't', L'h', L'e', L'i', L'r', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'l', L'o', L'c', L'a', 
L't', L'i', L'o', L'n', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'l', L'o', L'g', L'i', 
L'c', L'a', L'l', L'P', L'a', L't', L'h', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'L', L'o', L'g', L'i', L'c', L'a', L'l', L' ', 
L'p', L'a', L't', L'h', L' ', L'f', L'o', L'r', L' ', L'a', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L'.', L' ', L' ', L'T', L'h', L'i', L's', 
L' ', L'l', L'o', L'g', L'i', L'c', L'a', L'l', L' ', L'n', 
L'a', L'm', L'e', L' ', L'u', L's', L'e', L's', L' ', L'b', 
L'a', L'c', L'k', L's', L'l', L'a', L's', L'h', L'\r', L'\n', 
L' ', L' ', L' ', L'a', L's', L' ', L's', L'e', L'p', L'a', 
L'r', L'a', L't', L'o', L'r', L's', L' ', L't', L'o', L' ', 
L'f', L'o', L'r', L'm', L' ', L'a', L' ', L'l', L'o', L'g', 
L'i', L'c', L'a', L'l', L' ', L'n', L'a', L'm', L'e', L's', 
L'p', L'a', L'c', L'e', L' ', L'h', L'i', L'e', L'r', L'a', 
L'r', L'c', L'h', L'y', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', 
L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', 
L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', 
L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', 
L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L'N', L'a', L'm', L'e', L' ', 
L'u', L's', L'e', L'd', L' ', L't', L'o', L' ', L'i', L'd', 
L'e', L'n', L't', L'i', L'f', L'y', L' ', L'a', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'.', L' ', L' ', L'M', L'a', L'y', L' ', L'b', L'e', 
L' ', L'q', L'u', L'a', L'l', L'i', L'f', L'i', L'e', L'd', 
L' ', L'b', L'y', L' ', L'a', L'\r', L'\n', L' ', L' ', L' ', 
L'l', L'o', L'g', L'i', L'c', L'a', L'l', L' ', L'p', L'a', 
L't', L'h', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L'M', L'e', L't', L'a', L'd', L'a', L't', L'a', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'R', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L' ', L'e', L'x', L'i', L's', L't', 
L's', L' ', L'f', L'o', L'r', L' ', L't', L'h', L'i', L's', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', 
L'o', L'u', L'p', L'.', L' ', L' ', L'B', L'a', L'c', L'k', 
L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', L'a', L'p', L'p', 
L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'c', L'a', L'p', L't', 
L'u', L'r', L'e', L' ', L't', L'h', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'm', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L' ', L'a', L'n', L'd', L' ', L'p', 
L'a', L's', L's', L' ', L'i', L't', L' ', L't', L'o', L' ', 
L't', L'h', L'e', L'\r', L'\n', L' ', L' ', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L'o', L'n', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'n', L'o', 
L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', L'c', L'k', 
L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', 
L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', 
L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', L'n', 
L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', 
L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'W', L'r', 
L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'b', L'e', L' ', L'n', L'o', L't', L'i', L'f', 
L'i', L'e', L'd', L' ', L'w', L'h', L'e', L'n', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'i', L's', L' ', L'c', 
L'o', L'm', L'p', L'l', L'e', L't', L'e', L' ', L'w', L'h', 
L'e', L't', L'h', L'e', L'r', L' ', L't', L'h', L'i', L's', 
L'\r', L'\n', L' ', L' ', L' ', L'd', L'a', L't', L'a', L'b', 
L'a', L's', L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', 
L'e', L' ', L'g', L'r', L'o', L'u', L'p', L' ', L'w', L'a', 
L's', L' ', L's', L'u', L'c', L'c', L'e', L's', L's', L'f', 
L'u', L'l', L'l', L'y', L' ', L'b', L'a', L'c', L'k', L'e', 
L'd', L' ', L'u', L'p', L' ', L'o', L'r', L' ', L'n', L'o', 
L't', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'c', L'a', L'p', L't', L'i', L'o', 
L'n', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'T', L'e', L'x', L't', 
L'u', L'a', L'l', L' ', L'D', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', L'd', 
L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'o', L'r', 
L' ', L'f', L'i', L'l', L'e', L' ', L'g', L'r', L'o', L'u', 
L'p', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', 
L'e', L'=', L'"', L'i', L'c', L'o', L'n', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L's', L't', 
L'r', L'i', L'n', L'g', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'n', L'o', L'"', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', 
L' ', L' ', L'I', L'c', L'o', L'n', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', 
L'e', L' ', L'o', L'r', L' ', L'f', L'i', L'l', L'e', L' ', 
L'g', L'r', L'o', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L's', L'e', L'l', 
L'e', L'c', L't', L'a', L'b', L'l', L'e', L'"', L' ', L'd', 
L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', 
L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', 
L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', L's', 
L'=', L'"', L'y', L'e', L's', L' ', L'n', L'o', L'"', L' ', 
L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', L'"', L'y', 
L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L'I', L's', L' ', L't', 
L'h', L'i', L's', L' ', L'c', L'o', L'm', L'p', L'o', L'n', 
L'e', L'n', L't', L' ', L's', L'e', L'l', L'e', L'c', L't', 
L'a', L'b', L'l', L'e', L' ', L'f', L'o', L'r', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'o', L'r', L' ', L'i', 
L's', L' ', L'i', L't', L' ', L'a', L'l', L'w', L'a', L'y', 
L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L'.', L'\r', L'\n', L' ', L' ', L' ', L'I', L'f', L' ', 
L'n', L'o', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', 
L'h', L'e', L' ', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L' ', L'i', L's', L' ', L'a', L'l', L'w', L'a', 
L'y', L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', 
L'u', L'p', L' ', L'i', L'f', L' ', L'a', L'n', L'y', L' ', 
L'o', L't', L'h', L'e', L'r', L' ', L'c', L'o', L'm', L'p', 
L'o', L'n', L'e', L'n', L't', L's', L' ', L'o', L'f', L'\r', 
L'\n', L' ', L' ', L' ', L't', L'h', L'e', L' ', L'a', L'p', 
L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', L'/', 
L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'a', L'r', 
L'e', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L'.', L' ', L' ', L'I', L'f', L' ', L'y', L'e', L's', 
L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L' ', L'm', L'a', L'y', L' ', L'b', 
L'e', L' ', L's', L'e', L'l', L'e', L'c', L't', L'i', L'v', 
L'e', L'l', L'y', L' ', L'b', L'a', L'c', L'k', L'e', L'd', 
L' ', L'u', L'p', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'v', L'e', L'r', L's', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'1', L'.', 
L'0', L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L'V', L'e', L'r', L's', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'a', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'c', L' ', L'd', L'o', L'c', L'u', L'm', L'e', L'n', L't', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'I', L'd', 
L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', L'=', 
L'"', L'u', L'u', L'i', L'd', L'"', L' ', L'r', L'e', L'q', 
L'u', L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L'U', L'n', L'i', L'q', L'u', L'e', 
L' ', L'i', L'd', L' ', L't', L'o', L' ', L'i', L'd', L'e', 
L'n', L't', L'i', L'f', L'y', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'.', L' ', L' ', L'N', 
L'o', L't', L'e', L' ', L't', L'h', L'a', L't', L' ', L't', 
L'h', L'i', L's', L' ', L'i', L'd', L'e', L'n', L't', L'i', 
L'f', L'i', L'e', L's', L' ', L't', L'h', L'e', L'\r', L'\n', 
L' ', L' ', L' ', L'w', L'r', L'i', L't', L'e', L'r', L' ', 
L'c', L'l', L'a', L's', L's', L' ', L'r', L'a', L't', L'h', 
L'e', L'r', L' ', L't', L'h', L'a', L'n', L' ', L'a', L' ', 
L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', L'i', 
L'n', L's', L't', L'a', L'n', L'c', L'e', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', L't', L'e', 
L'r', L'.', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'A', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L'I', L'd', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'u', L'u', L'i', L'd', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L'U', L'n', L'i', 
L'q', L'u', L'e', L' ', L'i', L'd', L' ', L'i', L'd', L'e', 
L'n', L't', L'i', L'f', L'y', L'i', L'n', L'g', L' ', L't', 
L'h', L'e', L' ', L'i', L'n', L's', L't', L'a', L'n', L'c', 
L'e', L' ', L'o', L'f', L' ', L'a', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L' ', L'd', L'u', L'r', L'i', L'n', L'g', 
L' ', L'b', L'a', L'c', L'k', L'u', L'p', L'.', L' ', L' ', 
L'I', L't', L'\r', L'\n', L' ', L' ', L' ', L'h', L'a', L's', 
L' ', L'n', L'o', L' ', L'm', L'e', L'a', L'n', L'i', L'n', 
L'g', L' ', L'd', L'u', L'r', L'i', L'n', L'g', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'W', L'R', L'I', 
L'T', L'E', L'R', L'_', L'M', L'E', L'T', L'A', L'D', L'A', 
L'T', L'A', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'l', L't', L'O', L'n', L'l', L'y', 
L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'o', 
L'p', L'e', L'n', L'"', L' ', L'o', L'r', L'd', L'e', L'r', 
L'=', L'"', L'o', L'n', L'e', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'I', L'n', L'f', L'o', L'r', L'm', L'a', L't', 
L'i', L'o', L'n', L' ', L'u', L's', L'e', L'd', L' ', L'b', 
L'y', L' ', L'B', L'a', L'c', L'k', L'u', L'p', L' ', L'a', 
L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', 
L' ', L't', L'o', L' ', L'b', L'a', L'c', L'k', L'u', L'p', 
L'/', L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'd', 
L'a', L't', L'a', L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'v', L'e', L'r', L's', L'i', L'o', L'n', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'I', L'D', L'E', L'N', L'T', L'I', L'F', L'I', 
L'C', L'A', L'T', L'I', L'O', L'N', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'B', L'A', 
L'C', L'K', L'U', L'P', L'_', L'L', L'O', L'C', L'A', L'T', 
L'I', L'O', L'N', L'S', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'M', L'E', 
L'T', L'H', L'O', L'D', L'"', L' ', L'm', L'i', L'n', L'O', 
L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', 
L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'I', L'D', L'E', L'N', L'T', L'I', L'F', L'I', L'C', L'A', 
L'T', L'I', L'O', L'N', L'"', L' ', L'c', L'o', L'n', L't', 
L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', 
L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', 
L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'I', L'd', L'e', L'n', L't', L'i', L'f', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', L' ', 
L'a', L' ', L's', L'e', L'r', L'v', L'i', L'c', L'e', L'/', 
L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', 
L'n', L' ', L'b', L'a', L'c', L'k', L'i', L'n', L'g', L' ', 
L'u', L'p', L' ', L'd', L'a', L't', L'a', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'f', L'r', L'i', L'e', L'n', L'd', L'l', L'y', L'N', 
L'a', L'm', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', 
L'"', L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', 
L'=', L'"', L'y', L'e', L's', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'F', L'r', L'i', L'e', L'n', L'd', L'l', 
L'y', L' ', L'n', L'a', L'm', L'e', L' ', L'u', L's', L'e', 
L'd', L' ', L't', L'o', L' ', L'd', L'e', L's', L'c', L'r', 
L'i', L'b', L'e', L' ', L't', L'h', L'e', L' ', L's', L'e', 
L'r', L'v', L'i', L'c', L'e', L' ', L'o', L'r', L' ', L'a', 
L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', L'o', L'n', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'u', L's', 
L'a', L'g', L'e', L'"', L' ', L'd', L't', L':', L't', L'y', 
L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', 
L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', 
L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'U', L'S', 
L'E', L'R', L'_', L'D', L'A', L'T', L'A', L' ', L'B', L'O', 
L'O', L'T', L'A', L'B', L'L', L'E', L'_', L'S', L'Y', L'S', 
L'T', L'E', L'M', L'_', L'S', L'T', L'A', L'T', L'E', L' ', 
L'S', L'Y', L'S', L'T', L'E', L'M', L'_', L'S', L'E', L'R', 
L'V', L'I', L'C', L'E', L' ', L'O', L'T', L'H', L'E', L'R', 
L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', L't', L'=', 
L'"', L'O', L'T', L'H', L'E', L'R', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'H', L'o', L'w', L' ', L't', L'h', 
L'e', L' ', L'd', L'a', L't', L'a', L' ', L'a', L's', L's', 
L'o', L'c', L'i', L'a', L't', L'e', L'd', L' ', L'w', L'i', 
L't', L'h', L' ', L't', L'h', L'e', L' ', L'w', L'r', L'i', 
L't', L'e', L'r', L' ', L'i', L's', L' ', L'u', L's', L'e', 
L'd', L'.', L' ', L' ', L'F', L'o', L'r', L' ', L'n', L'o', 
L'w', L' ', L'w', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'd', L'i', L's', L't', L'i', L'n', L'g', L'u', 
L'i', L's', L'h', L' ', L'u', L's', L'e', L'r', L' ', L'd', 
L'a', L't', L'a', L' ', L'a', L'n', L'd', L' ', L's', L'y', 
L's', L't', L'e', L'm', L' ', L's', L't', L'a', L't', L'e', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'd', L'a', 
L't', L'a', L'S', L'o', L'u', L'r', L'c', L'e', L'"', L' ', 
L'd', L't', L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', 
L'n', L'u', L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', 
L'"', L' ', L'd', L't', L':', L'v', L'a', L'l', L'u', L'e', 
L's', L'=', L'"', L'T', L'R', L'A', L'N', L'S', L'A', L'C', 
L'T', L'I', L'O', L'N', L'_', L'D', L'B', L' ', L'N', L'O', 
L'N', L'T', L'R', L'A', L'N', L'S', L'A', L'C', L'T', L'I', 
L'O', L'N', L'A', L'L', L'_', L'D', L'B', L' ', L'O', L'T', 
L'H', L'E', L'R', L'"', L' ', L'd', L'e', L'f', L'a', L'u', 
L'l', L't', L'=', L'"', L'O', L'T', L'H', L'E', L'R', L'"', 
L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'D', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L' ', L'o', 
L'f', L' ', L't', L'h', L'e', L' ', L'n', L'a', L't', L'u', 
L'r', L'e', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'd', L'a', L't', L'a', L' ', L'm', L'a', L'n', L'a', L'g', 
L'e', L'r', L'.', L' ', L' ', L'C', L'u', L'r', L'r', L'e', 
L'n', L't', L'l', L'y', L' ', L'o', L'n', L'l', L'y', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'd', L'a', L't', 
L'a', L'b', L'a', L's', L'e', L's', L' ', L'a', L'r', L'e', 
L' ', L'i', L'd', L'e', L'n', L't', L'i', L'f', L'i', L'e', 
L'd', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'<', 
L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'i', L'n', L's', L't', L'a', L'n', 
L'c', L'e', L'I', L'd', L'"', L' ', L'r', L'e', L'q', L'u', 
L'i', L'r', L'e', L'd', L'=', L'"', L'y', L'e', L's', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'w', L'r', L'i', L't', L'e', L'r', L'I', 
L'd', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'r', L'i', L'e', L'n', 
L'd', L'l', L'y', L'N', L'a', L'm', L'e', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'u', L's', L'a', L'g', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'd', L'a', L't', L'a', L'S', L'o', L'u', L'r', L'c', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', 
L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'B', L'A', L'C', L'K', L'U', L'P', L'_', L'L', 
L'O', L'C', L'A', L'T', L'I', L'O', L'N', L'S', L'"', L' ', 
L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', 
L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', L'o', 
L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', L'e', 
L'd', L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', 
L'm', L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L'F', L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'a', L'n', 
L'd', L' ', L'e', L'x', L'c', L'l', L'u', L'd', L'e', L' ', 
L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', 
L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', 
L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', 
L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'I', L'N', L'C', L'L', L'U', L'D', L'E', 
L'_', L'F', L'I', L'L', L'E', L'S', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', 
L'e', L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'E', L'X', L'C', L'L', L'U', L'D', L'E', L'_', 
L'F', L'I', L'L', L'E', L'S', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', 
L'm', L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'D', L'A', L'T', L'A', L'B', L'A', L'S', L'E', L'"', 
L' ', L'm', L'i', L'n', L'O', L'c', L'c', L'u', L'r', L's', 
L'=', L'"', L'0', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'F', L'I', L'L', L'E', L'_', 
L'G', L'R', L'O', L'U', L'P', L'"', L' ', L'm', L'i', L'n', 
L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'<', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'I', L'N', L'C', L'L', L'U', L'D', L'E', L'_', L'F', 
L'I', L'L', L'E', L'S', L'"', L' ', L'c', L'o', L'n', L't', 
L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', 
L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'F', L'i', L'l', 
L'e', L's', L' ', L't', L'o', L' ', L'i', L'n', L'c', L'l', 
L'u', L'd', L'e', L' ', L'i', L'n', L' ', L't', L'h', L'e', 
L' ', L'b', L'a', L'c', L'k', L'u', L'p', L',', L' ', L'e', 
L's', L's', L'e', L'n', L't', L'i', L'a', L'l', L'l', L'y', 
L' ', L'f', L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'i', L'f', L' ', 
L'y', L'o', L'u', L' ', L'w', L'a', L'n', L't', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L't', L'o', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L't', L'h', L'i', L's', 
L' ', L'a', L'p', L'p', L'l', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L'/', L's', L'e', L'r', L'v', L'i', L'c', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'p', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', 
L'l', L'e', L's', L'p', L'e', L'c', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'r', L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', 
L't', L'e', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', 
L't', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', 
L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', 
L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'E', L'X', 
L'C', L'L', L'U', L'D', L'E', L'_', L'F', L'I', L'L', L'E', 
L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', 
L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'F', L'i', L'l', L'e', L's', L' ', 
L't', L'h', L'a', L't', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'a', L'l', L'w', L'a', L'y', L's', L' ', L'b', 
L'e', L' ', L'e', L'x', L'c', L'l', L'u', L'd', L'e', L'd', 
L' ', L'f', L'r', L'o', L'm', L' ', L't', L'h', L'e', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L'\r', L'\n', L' ', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', L'h', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', L'p', 
L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', L'u', 
L'r', L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', 
L'A', L'B', L'A', L'S', L'E', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'L', L'i', 
L's', L't', L' ', L'o', L'f', L' ', L'd', L'a', L't', L'a', 
L'b', L'a', L's', L'e', L's', L' ', L'o', L'f', L' ', L'i', 
L'n', L't', L'e', L'r', L'e', L's', L't', L'.', L' ', L' ', 
L'T', L'h', L'i', L's', L' ', L'i', L's', L' ', L'u', L's', 
L'e', L'd', L' ', L't', L'o', L' ', L'a', L'l', L'l', L'o', 
L'w', L' ', L's', L'e', L'l', L'e', L'c', L't', L'i', L'v', 
L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'b', 
L'a', L'c', L'k', L'u', L'p', L' ', L'a', L'n', L'd', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L'o', L'f', 
L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', L'c', L' ', 
L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L's', L'.', 
L'\r', L'\n', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'l', L'o', L'g', L'i', L'c', L'a', L'l', L'P', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', 
L'n', L'e', L'n', L't', L'N', L'a', L'm', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'c', L'a', L'p', L't', L'i', L'o', L'n', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'i', L'c', L'o', L'n', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'r', L'e', L's', L't', L'o', L'r', L'e', L'M', L'e', 
L't', L'a', L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'n', L'o', L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', 
L'c', L'k', L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', 
L't', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', 
L'c', L't', L'a', L'b', L'l', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', L'A', 
L'T', L'A', L'B', L'A', L'S', L'E', L'_', L'F', L'I', L'L', 
L'E', L'S', L'"', L' ', L'm', L'i', L'n', L'O', L'c', L'c', 
L'u', L'r', L's', L'=', L'"', L'1', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', 
L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'D', L'A', 
L'T', L'A', L'B', L'A', L'S', L'E', L'_', L'L', L'O', L'G', 
L'F', L'I', L'L', L'E', L'S', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', 
L'A', L'B', L'A', L'S', L'E', L'_', L'F', L'I', L'L', L'E', 
L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', 
L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', L's', 
L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', 
L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', 
L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'L', 
L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', L'f', 
L' ', L'a', L' ', L's', L'e', L't', L' ', L'o', L'f', L' ', 
L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L'.', L' ', L' ', L'F', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L' ', L'c', L'a', L'n', L' ', 
L'i', L'n', L'c', L'l', L'u', L'd', L'e', L' ', L'w', L'i', 
L'l', L'd', L'c', L'a', L'r', L'd', L's', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'D', L'A', L'T', L'A', L'B', 
L'A', L'S', L'E', L'_', L'L', L'O', L'G', L'F', L'I', L'L', 
L'E', L'S', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'L', L'o', L'c', L'a', L't', L'i', L'o', L'n', L' ', L'o', 
L'f', L' ', L'a', L' ', L's', L'e', L't', L' ', L'o', L'f', 
L' ', L'd', L'a', L't', L'a', L'b', L'a', L's', L'e', L' ', 
L'l', L'o', L'g', L' ', L'f', L'i', L'l', L'e', L's', L'.', 
L' ', L' ', L'F', L'i', L'l', L'e', L's', L'p', L'e', L'c', 
L' ', L'c', L'a', L'n', L' ', L'i', L'n', L'c', L'l', L'u', 
L'd', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'w', L'i', L'l', L'd', L'c', L'a', L'r', L'd', L's', L'.', 
L' ', L' ', L'I', L'n', L'd', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'w', L'h', L'e', L't', 
L'h', L'e', L'r', L' ', L'd', L'a', L't', L'a', L'b', L'a', 
L's', L'e', L' ', L'l', L'o', L'g', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'a', L'r', L'e', L' ', L't', L'r', L'u', 
L'n', L'c', L'a', L't', L'e', L'd', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'F', L'I', L'L', L'E', L'_', 
L'G', L'R', L'O', L'U', L'P', L'"', L' ', L'c', L'o', L'n', 
L't', L'e', L'n', L't', L'=', L'"', L'e', L'l', L't', L'O', 
L'n', L'l', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', 
L'=', L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L' ', 
L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', L'a', L'n', 
L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'd', L'e', 
L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'A', L' ', 
L'n', L'a', L'm', L'e', L'd', L' ', L'g', L'r', L'o', L'u', 
L'p', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L'.', L' ', L' ', L'U', L's', L'e', L'd', L' ', L't', L'o', 
L' ', L'g', L'r', L'o', L'u', L'p', L' ', L's', L'e', L't', 
L's', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'i', L'n', L't', L'o', L' ', L'a', L' ', L'g', L'r', 
L'o', L'u', L'p', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L't', L'h', L'a', L't', L' ', L'a', L'r', L'e', L' ', 
L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', L'p', L' ', 
L't', L'o', L'g', L'e', L't', L'h', L'e', L'r', L'\r', L'\n', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'l', L'o', 
L'g', L'i', L'c', L'a', L'l', L'P', L'a', L't', L'h', L'"', 
L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', 
L'e', L'=', L'"', L'c', L'o', L'm', L'p', L'o', L'n', L'e', 
L'n', L't', L'N', L'a', L'm', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'c', L'a', L'p', L't', L'i', L'o', L'n', L'"', L'/', L'>', 
L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', 
L'"', L'i', L'c', L'o', L'n', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'M', L'e', L't', L'a', 
L'd', L'a', L't', L'a', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'n', L'o', 
L't', L'i', L'f', L'y', L'O', L'n', L'B', L'a', L'c', L'k', 
L'u', L'p', L'C', L'o', L'm', L'p', L'l', L'e', L't', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L's', L'e', L'l', L'e', L'c', L't', 
L'a', L'b', L'l', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'e', L'l', L'e', L'm', L'e', L'n', L't', L' ', 
L't', L'y', L'p', L'e', L'=', L'"', L'F', L'I', L'L', L'E', 
L'_', L'L', L'I', L'S', L'T', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', 
L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'F', L'I', L'L', 
L'E', L'_', L'L', L'I', L'S', L'T', L'"', L' ', L'c', L'o', 
L'n', L't', L'e', L'n', L't', L'=', L'"', L'e', L'm', L'p', 
L't', L'y', L'"', L' ', L'm', L'o', L'd', L'e', L'l', L'=', 
L'"', L'c', L'l', L'o', L's', L'e', L'd', L'"', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'L', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'a', L' ', L's', L'e', 
L't', L' ', L'o', L'f', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'i', L'n', L' ', L'a', L' ', L'F', L'I', L'L', L'E', 
L'_', L'G', L'R', L'O', L'U', L'P', L'.', L' ', L' ', L'F', 
L'i', L'l', L'e', L's', L'p', L'e', L'c', L' ', L'c', L'a', 
L'n', L' ', L'i', L'n', L'c', L'l', L'u', L'd', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'w', L'i', L'l', 
L'd', L'c', L'a', L'r', L'd', L's', L'.', L'\r', L'\n', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', L'a', L't', 
L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', 
L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', L'e', L's', 
L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', L'e', L'c', 
L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L'P', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'<', 
L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', L'y', 
L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', L'e', 
L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', L'n', 
L'a', L'm', L'e', L'=', L'"', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'M', L'E', L'T', L'H', L'O', L'D', L'"', 
L' ', L'c', L'o', L'n', L't', L'e', L'n', L't', L'=', L'"', 
L'e', L'l', L't', L'O', L'n', L'l', L'y', L'"', L' ', L'm', 
L'o', L'd', L'e', L'l', L'=', L'"', L'o', L'p', L'e', L'n', 
L'"', L' ', L'o', L'r', L'd', L'e', L'r', L'=', L'"', L'm', 
L'a', L'n', L'y', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L'H', L'o', L'w', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L' ', L's', L'h', 
L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'p', L'e', 
L'r', L'f', L'o', L'r', L'm', L'e', L'd', L'.', L' ', L' ', 
L'I', L'n', L'c', L'l', L'u', L'd', L'e', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'f', L'i', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L'o', L'f', L' ', L'h', L'o', L'w', L' ', 
L'f', L'i', L'l', L'e', L's', L'\r', L'\n', L' ', L' ', L's', 
L'h', L'o', L'u', L'l', L'd', L' ', L'b', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L'a', L's', 
L' ', L'w', L'e', L'l', L'l', L' ', L'a', L's', L' ', L's', 
L'p', L'e', L'c', L'i', L'a', L'l', L' ', L's', L't', L'e', 
L'p', L's', L' ', L't', L'h', L'a', L't', L' ', L's', L'h', 
L'o', L'u', L'l', L'd', L' ', L'o', L'c', L'c', L'u', L'r', 
L' ', L'i', L'n', L' ', L'o', L'r', L'd', L'e', L'r', L'\r', 
L'\n', L' ', L' ', L't', L'o', L' ', L'c', L'o', L'm', L'p', 
L'l', L'e', L't', L'e', L' ', L't', L'h', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'.', L'\r', L'\n', L' ', 
L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', 
L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', L'"', 
L'm', L'e', L't', L'h', L'o', L'd', L'"', L' ', L'd', L't', 
L':', L't', L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', 
L'm', L'e', L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'y', L'e', L's', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'R', L'E', L'S', L'T', 
L'O', L'R', L'E', L'_', L'I', L'F', L'_', L'N', L'O', L'N', 
L'E', L'_', L'T', L'H', L'E', L'R', L'E', L'\r', L'\n', L'\t', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', L'I', L'F', 
L'_', L'C', L'A', L'N', L'_', L'B', L'E', L'_', L'R', L'E', 
L'P', L'L', L'A', L'C', L'E', L'D', L'\r', L'\n', L'\t', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'S', 
L'T', L'O', L'P', L'_', L'R', L'E', L'S', L'T', L'A', L'R', 
L'T', L'_', L'S', L'E', L'R', L'V', L'I', L'C', L'E', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'P', L'L', L'A', L'C', L'E', L'_', 
L'A', L'T', L'_', L'R', L'E', L'B', L'O', L'O', L'T', L'\r', 
L'\n', L'\t', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'S', L'T', L'O', L'R', L'E', L'_', 
L'T', L'O', L'_', L'A', L'L', L'T', L'E', L'R', L'N', L'A', 
L'T', L'E', L'_', L'L', L'O', L'C', L'A', L'T', L'I', L'O', 
L'N', L'\r', L'\n', L'\t', L'\t', L'\t', L' ', L' ', L' ', L' ', 
L'C', L'U', L'S', L'T', L'O', L'M', L'"', L'>', L'\r', L'\n', 
L'\t', L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'I', L'F', L'_', L'N', L'O', L'N', L'E', 
L'_', L'T', L'H', L'E', L'R', L'E', L':', L' ', L'i', L'.', 
L'e', L'.', L',', L' ', L'c', L'a', L'n', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'd', L'a', L't', L'a', 
L' ', L'i', L'f', L' ', L'i', L't', L' ', L'i', L's', L' ', 
L'n', L'o', L't', L' ', L'a', L't', L' ', L't', L'h', L'e', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', 
L' ', L'w', L'h', L'e', L'r', L'e', L' ', L'i', L't', L' ', 
L'w', L'a', L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', 
L' ', L'u', L'p', L' ', L'f', L'r', L'o', L'm', L'.', L' ', 
L' ', L'T', L'h', L'i', L's', L' ', L'e', L's', L's', L'e', 
L'n', L't', L'i', L'a', L'l', L'l', L'y', L' ', L'a', L'l', 
L'l', L'o', L'w', L's', L'\r', L'\n', L'\t', L' ', L' ', L'd', 
L'a', L't', L'a', L' ', L't', L'o', L' ', L'b', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'o', L' ', L'a', L' ', L'c', L'l', L'e', L'a', L'n', L' ', 
L's', L'y', L's', L't', L'e', L'm', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', L'T', L'O', 
L'R', L'E', L'_', L'I', L'F', L'_', L'C', L'A', L'N', L'_', 
L'B', L'E', L'_', L'R', L'E', L'P', L'L', L'A', L'C', L'E', 
L'D', L':', L' ', L'R', L'e', L's', L't', L'o', L'r', L'e', 
L' ', L'd', L'a', L't', L'a', L' ', L'i', L'f', L' ', L'a', 
L'l', L'l', L' ', L'o', L'f', L' ', L't', L'h', L'e', L' ', 
L'f', L'i', L'l', L'e', L's', L' ', L'c', L'a', L'n', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'b', L'e', L' ', L'r', L'e', L'p', L'l', L'a', L'c', 
L'e', L'd', L' ', L'i', L'n', L' ', L't', L'h', L'e', L' ', 
L'o', L'r', L'g', L'i', L'g', L'i', L'n', L'a', L'l', L' ', 
L'b', L'a', L'c', L'k', L'u', L'p', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L' ', L' ', L'F', L'a', 
L'i', L'l', L's', L' ', L'i', L'f', L' ', L'a', L'n', L'y', 
L' ', L'o', L'f', L'\r', L'\n', L'\t', L' ', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', L'r', 
L'e', L' ', L'o', L'p', L'e', L'n', L'.', L' ', L' ', L'I', 
L'f', L' ', L'a', L'n', L' ', L'a', L'l', L't', L'e', L'r', 
L'n', L'a', L't', L'e', L' ', L'l', L'o', L'c', L'a', L't', 
L'i', L'o', L'n', L' ', L'i', L's', L' ', L'p', L'r', L'o', 
L'v', L'i', L'd', L'e', L'd', L',', L' ', L'f', L'i', L'l', 
L'e', L's', L'\r', L'\n', L'\t', L' ', L' ', L'w', L'i', L'l', 
L'l', L' ', L'b', L'e', L' ', L'p', L'l', L'a', L'c', L'e', 
L'd', L' ', L't', L'h', L'e', L'r', L'e', L' ', L'i', L'f', 
L' ', L't', L'h', L'e', L'y', L' ', L'c', L'a', L'n', L'n', 
L'o', L't', L' ', L'b', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'd', L' ', L't', L'o', L' ', L't', L'h', 
L'e', L'i', L'r', L' ', L'o', L'r', L'i', L'g', L'i', L'n', 
L'a', L'l', L'\r', L'\n', L'\t', L' ', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'S', L'T', L'O', L'P', L'_', 
L'R', L'E', L'S', L'T', L'A', L'R', L'T', L'_', L'S', L'E', 
L'R', L'V', L'I', L'C', L'E', L':', L' ', L's', L't', L'o', 
L'p', L' ', L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', 
L'(', L's', L'e', L'r', L'v', L'i', L'c', L'e', L' ', L'a', 
L't', L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L'm', 
L'u', L's', L't', L' ', L'b', L'e', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'e', L'd', L')', L'.', L' ', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L'o', L'r', L'i', 
L'g', L'i', L'n', L'a', L'l', L' ', L'b', L'a', L'c', L'k', 
L'u', L'p', L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', 
L'n', L'.', L'\r', L'\n', L'\t', L' ', L' ', L'R', L'e', L's', 
L't', L'a', L'r', L't', L' ', L's', L'e', L'r', L'v', L'i', 
L'c', L'e', L'.', L' ', L' ', L'F', L'a', L'i', L'l', L's', 
L' ', L'i', L'f', L' ', L'a', L'n', L'y', L' ', L'o', L'f', 
L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', L's', 
L' ', L'a', L'r', L'e', L' ', L'o', L'p', L'e', L'n', L' ', 
L'a', L'f', L't', L'e', L'r', L' ', L't', L'h', L'e', L'\r', 
L'\n', L'\t', L' ', L' ', L's', L'e', L'r', L'v', L'i', L'c', 
L'e', L' ', L'i', L's', L' ', L's', L't', L'o', L'p', L'p', 
L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L' ', L' ', L'R', L'E', L'P', L'L', L'A', L'C', L'E', L'_', 
L'A', L'T', L'_', L'R', L'E', L'B', L'O', L'O', L'T', L':', 
L' ', L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L't', L'o', L' ', L'a', L' ', 
L't', L'e', L'm', L'p', L'o', L'r', L'a', L'r', L'y', L' ', 
L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'.', L' ', 
L' ', L'U', L's', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L' ', L'M', L'o', L'v', L'e', 
L'F', L'i', L'l', L'e', L'E', L'x', L' ', L't', L'o', L' ', 
L'r', L'e', L'p', L'l', L'a', L'c', L'e', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'a', L't', 
L' ', L'r', L'e', L'b', L'o', L'o', L't', L'.', L'\r', L'\n', 
L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'R', L'E', L'S', 
L'T', L'O', L'R', L'E', L'_', L'T', L'O', L'_', L'A', L'L', 
L'T', L'E', L'R', L'N', L'A', L'T', L'I', L'V', L'E', L'_', 
L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', L':', L' ', 
L'R', L'e', L's', L't', L'o', L'r', L'e', L' ', L'f', L'i', 
L'l', L'e', L's', L' ', L't', L'o', L' ', L'a', L'n', L' ', 
L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', L'e', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L' ', 
L' ', L'l', L'o', L'c', L'a', L't', L'i', L'o', L'n', L'.', 
L' ', L' ', L'T', L'y', L'p', L'i', L'c', L'a', L'l', L'l', 
L'y', L' ', L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', 
L's', L't', L'o', L'r', L'e', L' ', L'w', L'i', L'l', L'l', 
L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', L'e', L' ', 
L't', L'h', L'a', L't', L' ', L't', L'h', L'e', L' ', L'w', 
L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L'\t', L' ', L' ', 
L'w', L'i', L'l', L'l', L' ', L'p', L'a', L'r', L't', L'i', 
L'c', L'i', L'p', L'a', L't', L'e', L' ', L'i', L'n', L' ', 
L't', L'h', L'e', L' ', L'r', L'e', L's', L't', L'o', L'r', 
L'e', L' ', L'p', L'r', L'o', L'c', L'e', L's', L's', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L' ', L'C', L'U', 
L'S', L'T', L'O', L'M', L':', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L' ', L'p', L'r', L'o', L'c', L'e', L's', 
L's', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', L'b', 
L'e', L' ', L'e', L'x', L'p', L'r', L'e', L's', L's', L'e', 
L'd', L' ', L'u', L's', L'i', L'n', L'g', L' ', L't', L'h', 
L'i', L's', L' ', L's', L'p', L'e', L'c', L'i', L'f', L'i', 
L'c', L'a', L't', L'i', L'o', L'n', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', 
L'c', L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', 
L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', 
L'm', L'e', L'=', L'"', L's', L'e', L'r', L'v', L'i', L'c', 
L'e', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L's', L't', L'r', L'i', L'n', L'g', L'"', L' ', 
L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', L'"', 
L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'M', L'u', L's', L't', L' ', L'b', L'e', L' ', L's', L'p', 
L'e', L'c', L'i', L'f', L'i', L'e', L'd', L' ', L'i', L'f', 
L' ', L'm', L'e', L't', L'h', L'o', L'd', L'=', L'"', L'S', 
L'T', L'O', L'P', L'_', L'R', L'E', L'S', L'T', L'A', L'R', 
L'T', L'_', L'S', L'E', L'R', L'V', L'I', L'C', L'E', L'"', 
L',', L' ', L'i', L'n', L'd', L'i', L'c', L'a', L't', L'e', 
L's', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L's', 
L'e', L'r', L'v', L'i', L'c', L'e', L' ', L't', L'o', L' ', 
L'b', L'e', L' ', L's', L't', L'o', L'p', L'p', L'e', L'd', 
L' ', L'b', L'e', L'f', L'o', L'r', L'e', L' ', L'r', L'e', 
L's', L't', L'o', L'r', L'i', L'n', L'g', L' ', L'f', L'i', 
L'l', L'e', L's', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', L'i', 
L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', L'=', 
L'"', L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', L's', 
L't', L'o', L'r', L'e', L'"', L' ', L'd', L't', L':', L't', 
L'y', L'p', L'e', L'=', L'"', L'e', L'n', L'u', L'm', L'e', 
L'r', L'a', L't', L'i', L'o', L'n', L'"', L' ', L'd', L't', 
L':', L'v', L'a', L'l', L'u', L'e', L's', L'=', L'"', L'a', 
L'l', L'w', L'a', L'y', L's', L' ', L'n', L'e', L'v', L'e', 
L'r', L' ', L'i', L'f', L'R', L'e', L'p', L'l', L'a', L'c', 
L'e', L'F', L'a', L'i', L'l', L's', L'"', L' ', L'd', L'e', 
L'f', L'a', L'u', L'l', L't', L'=', L'"', L'n', L'e', L'v', 
L'e', L'r', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', 
L'W', L'h', L'e', L't', L'h', L'e', L'r', L' ', L'w', L'r', 
L'i', L't', L'e', L'r', L' ', L's', L'h', L'o', L'u', L'l', 
L'd', L' ', L'b', L'e', L' ', L'i', L'n', L'v', L'o', L'k', 
L'e', L'd', L' ', L'a', L'f', L't', L'e', L'r', L' ', L'f', 
L'i', L'l', L'e', L's', L' ', L'a', L'r', L'e', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', L'o', 
L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'd', L'i', 
L's', L'k', L'.', L' ', L' ', L'O', L'p', L't', L'i', L'o', 
L'n', L's', L' ', L'a', L'r', L'e', L' ', L'a', L'l', L'w', 
L'a', L'y', L's', L',', L' ', L'n', L'e', L'v', L'e', L'r', 
L',', L' ', L'a', L'n', L'd', L' ', L'i', L'f', L'R', L'e', 
L'p', L'l', L'a', L'c', L'e', L'F', L'a', L'i', L'l', L's', 
L'.', L' ', L' ', L'T', L'h', L'e', L' ', L'l', L'a', L't', 
L't', L'e', L'r', L' ', L'm', L'e', L'a', L'n', L's', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L't', L'h', L'a', 
L't', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'w', L'i', L'l', L'l', L' ', L'b', L'e', L' ', 
L'r', L'e', L's', L't', L'o', L'r', L'e', L'd', L' ', L't', 
L'o', L' ', L't', L'h', L'e', L'i', L'r', L' ', L'o', L'r', 
L'i', L'g', L'i', L'n', L'a', L'l', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L'.', L' ', L' ', L'I', L'f', 
L' ', L'o', L'n', L'e', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L' ', L'o', L'r', L' ', L'm', L'o', L'r', L'e', L' ', 
L'o', L'f', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L' ', L'c', L'a', L'n', L'n', L'o', L't', L' ', 
L'b', L'e', L' ', L'r', L'e', L'p', L'l', L'a', L'c', L'e', 
L'd', L',', L' ', L't', L'h', L'e', L'n', L' ', L't', L'h', 
L'e', L' ', L'f', L'i', L'l', L'e', L's', L' ', L'w', L'i', 
L'l', L'l', L' ', L'b', L'e', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'r', L'e', L's', L't', L'o', L'r', L'e', 
L'd', L' ', L't', L'o', L' ', L'a', L'n', L' ', L'a', L'l', 
L't', L'e', L'r', L'n', L'a', L't', L'e', L' ', L'l', L'o', 
L'c', L'a', L't', L'i', L'o', L'n', L' ', L'(', L'm', L'u', 
L's', L't', L' ', L'b', L'e', L' ', L's', L'p', L'e', L'c', 
L'i', L'f', L'i', L'e', L'd', L' ', L'v', L'i', L'a', L'\r', 
L'\n', L' ', L' ', L' ', L' ', L' ', L' ', L'A', L'L', L'T', 
L'E', L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', 
L'A', L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', 
L'I', L'N', L'G', L'.', L' ', L' ', L'A', L'f', L't', L'e', 
L'r', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', L'e', 
L's', L' ', L'a', L'r', L'e', L' ', L'r', L'e', L's', L't', 
L'o', L'r', L'e', L'd', L',', L' ', L't', L'h', L'e', L' ', 
L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L' ', L' ', 
L' ', L' ', L' ', L' ', L'i', L's', L' ', L'i', L'n', L'v', 
L'o', L'k', L'e', L'd', L'.', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', L'r', 
L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', 
L'\t', L'<', L'A', L't', L't', L'r', L'i', L'b', L'u', L't', 
L'e', L'T', L'y', L'p', L'e', L' ', L'n', L'a', L'm', L'e', 
L'=', L'"', L'u', L's', L'e', L'r', L'P', L'r', L'o', L'c', 
L'e', L'd', L'u', L'r', L'e', L'"', L' ', L'd', L't', L':', 
L't', L'y', L'p', L'e', L'=', L'"', L'u', L'r', L'i', L'"', 
L' ', L'r', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'=', 
L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'\t', 
L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', 
L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L'D', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L' ', L'o', L'f', L' ', L'a', L'c', L't', L'i', L'o', 
L'n', L's', L' ', L't', L'h', L'a', L't', L' ', L't', L'h', 
L'e', L' ', L'u', L's', L'e', L'r', L' ', L's', L'h', L'o', 
L'u', L'l', L'd', L' ', L'p', L'e', L'r', L'f', L'o', L'r', 
L'm', L' ', L't', L'o', L' ', L'r', L'e', L's', L't', L'o', 
L'r', L'e', L' ', L't', L'h', L'e', L' ', L'f', L'i', L'l', 
L'e', L's', L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', 
L'T', L'h', L'e', L' ', L'f', L'o', L'r', L'm', L'a', L't', 
L' ', L'o', L'f', L' ', L't', L'h', L'i', L's', L' ', L's', 
L't', L'r', L'i', L'n', L'g', L' ', L'h', L'a', L's', L' ', 
L'y', L'e', L't', L' ', L't', L'o', L' ', L'b', L'e', L' ', 
L'd', L'e', L't', L'e', L'r', L'm', L'i', L'n', L'e', L'd', 
L'.', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L'<', L'/', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'/', L'A', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', 
L'e', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'A', L't', L't', 
L'r', L'i', L'b', L'u', L't', L'e', L'T', L'y', L'p', L'e', 
L' ', L'n', L'a', L'm', L'e', L'=', L'"', L'r', L'e', L'b', 
L'o', L'o', L't', L'R', L'e', L'q', L'u', L'i', L'r', L'e', 
L'd', L'"', L' ', L'd', L't', L':', L't', L'y', L'p', L'e', 
L'=', L'"', L'e', L'n', L'u', L'm', L'e', L'r', L'a', L't', 
L'i', L'o', L'n', L'"', L' ', L'd', L't', L':', L'v', L'a', 
L'l', L'u', L'e', L's', L'=', L'"', L'y', L'e', L's', L' ', 
L'n', L'o', L'"', L' ', L'd', L'e', L'f', L'a', L'u', L'l', 
L't', L'=', L'"', L'n', L'o', L'"', L'>', L'\r', L'\n', L'\t', 
L'\t', L'\t', L'<', L'd', L'e', L's', L'c', L'r', L'i', L'p', 
L't', L'i', L'o', L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', 
L' ', L' ', L'S', L'h', L'o', L'u', L'l', L'd', L' ', L'a', 
L' ', L'r', L'e', L'b', L'o', L'o', L't', L' ', L'b', L'e', 
L' ', L'p', L'e', L'r', L'f', L'o', L'r', L'm', L'e', L'd', 
L' ', L'a', L'f', L't', L'e', L'r', L' ', L'r', L'e', L's', 
L't', L'o', L'r', L'i', L'n', L'g', L' ', L't', L'h', L'e', 
L' ', L'd', L'a', L't', L'a', L' ', L'f', L'o', L'r', L' ', 
L't', L'h', L'i', L's', L'\r', L'\n', L' ', L' ', L' ', L' ', 
L' ', L'w', L'r', L'i', L't', L'e', L'r', L'\r', L'\n', L' ', 
L' ', L' ', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'/', L'A', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'm', 
L'e', L't', L'h', L'o', L'd', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L's', 
L'e', L'r', L'v', L'i', L'c', L'e', L'"', L'/', L'>', L'\r', 
L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', 
L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'w', L'r', L'i', L't', L'e', L'r', L'R', L'e', L's', L't', 
L'o', L'r', L'e', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'u', L's', L'e', 
L'r', L'P', L'r', L'o', L'c', L'e', L'd', L'u', L'r', L'e', 
L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', 
L't', L'r', L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', 
L'p', L'e', L'=', L'"', L'r', L'e', L'b', L'o', L'o', L't', 
L'R', L'e', L'q', L'u', L'i', L'r', L'e', L'd', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'e', L'l', L'e', L'm', 
L'e', L'n', L't', L' ', L't', L'y', L'p', L'e', L'=', L'"', 
L'A', L'L', L'T', L'E', L'R', L'N', L'A', L'T', L'E', L'_', 
L'L', L'O', L'C', L'A', L'T', L'I', L'O', L'N', L'_', L'M', 
L'A', L'P', L'P', L'I', L'N', L'G', L'"', L' ', L'm', L'i', 
L'n', L'O', L'c', L'c', L'u', L'r', L's', L'=', L'"', L'0', 
L'"', L' ', L'm', L'a', L'x', L'O', L'c', L'c', L'u', L'r', 
L's', L'=', L'"', L'*', L'"', L'/', L'>', L'\r', L'\n', L'\t', 
L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', L'T', 
L'y', L'p', L'e', L'>', L'\r', L'\n', L'\t', L'<', L'E', L'l', 
L'e', L'm', L'e', L'n', L't', L'T', L'y', L'p', L'e', L' ', 
L'n', L'a', L'm', L'e', L'=', L'"', L'A', L'L', L'T', L'E', 
L'R', L'N', L'A', L'T', L'E', L'_', L'L', L'O', L'C', L'A', 
L'T', L'I', L'O', L'N', L'_', L'M', L'A', L'P', L'P', L'I', 
L'N', L'G', L'"', L' ', L'c', L'o', L'n', L't', L'e', L'n', 
L't', L'=', L'"', L'e', L'm', L'p', L't', L'y', L'"', L' ', 
L'm', L'o', L'd', L'e', L'l', L'=', L'"', L'c', L'l', L'o', 
L's', L'e', L'd', L'"', L'>', L'\r', L'\n', L'\t', L'\t', L'<', 
L'd', L'e', L's', L'c', L'r', L'i', L'p', L't', L'i', L'o', 
L'n', L'>', L'\r', L'\n', L' ', L' ', L' ', L' ', L' ', L'M', 
L'a', L'p', L'p', L'i', L'n', L'g', L' ', L'f', L'r', L'o', 
L'm', L' ', L'a', L' ', L'l', L'o', L'c', L'a', L't', L'i', 
L'o', L'n', L' ', L't', L'h', L'a', L't', L' ', L'w', L'a', 
L's', L' ', L'b', L'a', L'c', L'k', L'e', L'd', L' ', L'u', 
L'p', L' ', L't', L'o', L' ', L'a', L' ', L'l', L'o', L'c', 
L'a', L't', L'i', L'o', L'n', L' ', L't', L'o', L' ', L'r', 
L'e', L's', L't', L'o', L'r', L'e', L' ', L't', L'o', L'.', 
L'\r', L'\n', L' ', L' ', L'<', L'/', L'd', L'e', L's', L'c', 
L'r', L'i', L'p', L't', L'i', L'o', L'n', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'p', 
L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', L'\t', L'\t', 
L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', L't', L'e', 
L' ', L't', L'y', L'p', L'e', L'=', L'"', L'f', L'i', L'l', 
L'e', L's', L'p', L'e', L'c', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'\t', L'<', L'a', L't', L't', L'r', L'i', L'b', L'u', 
L't', L'e', L' ', L't', L'y', L'p', L'e', L'=', L'"', L'r', 
L'e', L'c', L'u', L'r', L's', L'i', L'v', L'e', L'"', L'/', 
L'>', L'\r', L'\n', L'\t', L'\t', L'<', L'a', L't', L't', L'r', 
L'i', L'b', L'u', L't', L'e', L' ', L't', L'y', L'p', L'e', 
L'=', L'"', L'a', L'l', L't', L'e', L'r', L'n', L'a', L't', 
L'e', L'P', L'a', L't', L'h', L'"', L'/', L'>', L'\r', L'\n', 
L'\t', L'<', L'/', L'E', L'l', L'e', L'm', L'e', L'n', L't', 
L'T', L'y', L'p', L'e', L'>', L'\r', L'\n', L'<', L'/', L'S', 
L'c', L'h', L'e', L'm', L'a', L'>', L'\r', L'\n', L'\0'
};
const unsigned g_cwcWriterMetadataXML = 11978;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\base64coder.cpp ===
// Base64Coder.cpp: implementation of the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#include <stdafx.hxx>
#include "Base64Coder.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEB64CC"
//
////////////////////////////////////////////////////////////////////////

// Digits...
static char	Base64Digits[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";


BOOL Base64Coder::m_Init		= FALSE;
char Base64Coder::m_DecodeTable[256];

#ifndef PAGESIZE
#define PAGESIZE					4096
#endif

#ifndef ROUNDTOPAGE
#define ROUNDTOPAGE(a)			(((a/4096)+1)*4096)
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Base64Coder::Base64Coder() :
	m_pDBuffer(NULL),
	m_pEBuffer(NULL),
	m_nDBufLen(0),
	m_nEBufLen(0)
	{
	}

Base64Coder::~Base64Coder()
	{
	if(m_pDBuffer != NULL)
		delete [] m_pDBuffer;

	if(m_pEBuffer != NULL)
		delete [] m_pEBuffer;
	}

BYTE *Base64Coder::DecodedMessage() const
	{
	return m_pDBuffer;
	}

LPCWSTR Base64Coder::EncodedMessage() const
	{
	return m_pEBuffer;
	}

void Base64Coder::AllocEncode(UINT nSize)
	{
	if(m_nEBufLen < nSize)
		{
		if(m_pEBuffer != NULL)
			delete [] m_pEBuffer;

		m_nEBufLen = ROUNDTOPAGE(nSize);
		m_pEBuffer = new WCHAR[m_nEBufLen];
		if (m_pEBuffer == NULL)
			{
			// reset allocated size to 0
			m_nEBufLen = 0;
			throw(E_OUTOFMEMORY);
			}
		}

	::ZeroMemory(m_pEBuffer, m_nEBufLen*sizeof(WCHAR));
	m_nEDataLen = 0;
	}

void Base64Coder::AllocDecode(UINT nSize)
	{
	if(m_nDBufLen < nSize)
		{
		if(m_pDBuffer != NULL)
			delete [] m_pDBuffer;

		m_nDBufLen = ROUNDTOPAGE(nSize);
		m_pDBuffer = new BYTE[m_nDBufLen];
		if (m_pDBuffer == NULL)
			{
			// reset allocated size to 0
			m_nDBufLen = 0;
			throw(E_OUTOFMEMORY);
			}
		}

	::ZeroMemory(m_pDBuffer, m_nDBufLen);

	m_nDDataLen = 0;
	}

void Base64Coder::SetEncodeBuffer(const LPCWSTR pBuffer, UINT nBufLen)
	{
	UINT	i = 0;

	AllocEncode(nBufLen);
	while(i < nBufLen)
		{
		if(!_IsBadMimeChar(pBuffer[i]))
			{
			m_pEBuffer[m_nEDataLen] = pBuffer[i];
			m_nEDataLen++;
			}

		i++;
		}
	}

void Base64Coder::SetDecodeBuffer(const BYTE *pBuffer, UINT nBufLen)
	{
	AllocDecode(nBufLen + sizeof(nBufLen));
    ::CopyMemory(m_pDBuffer, &nBufLen, sizeof(nBufLen));
	::CopyMemory(m_pDBuffer + sizeof(nBufLen), pBuffer, nBufLen);
	m_nDDataLen = nBufLen + sizeof(nBufLen);
	}

void Base64Coder::Encode(const BYTE *pBuffer, UINT nBufLen)
	{
	SetDecodeBuffer(pBuffer, nBufLen);
    // include length
    nBufLen += sizeof(nBufLen);
	AllocEncode(nBufLen * 2);

	TempBucket			Raw;
	UINT					nIndex	= 0;

	while((nIndex + 3) <= nBufLen)
		{
		Raw.Clear();
		::CopyMemory(&Raw, m_pDBuffer + nIndex, 3);
		Raw.nSize = 3;
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		nIndex		+= 3;
		m_nEDataLen	+= 4;
		}

	if(nBufLen > nIndex)
		{
		Raw.Clear();
		Raw.nSize = (BYTE) (nBufLen - nIndex);
		::CopyMemory(&Raw, m_pDBuffer + nIndex, nBufLen - nIndex);
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		m_nEDataLen += 4;
		}
	}
	
void Base64Coder::Decode(const LPCWSTR pBuffer)
	{
	UINT dwBufLen = (UINT) wcslen(pBuffer);

	if(!Base64Coder::m_Init)
		_Init();

	SetEncodeBuffer(pBuffer, dwBufLen);

	AllocDecode(dwBufLen);

	TempBucket			Raw;

	UINT		nIndex = 0;

	while((nIndex + 4) <= m_nEDataLen)
		{
		Raw.Clear();
		Raw.nData[0] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex]];
		Raw.nData[1] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 1]];
		Raw.nData[2] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 2]];
		Raw.nData[3] = Base64Coder::m_DecodeTable[m_pEBuffer[nIndex + 3]];

		if(Raw.nData[2] == 255)
			Raw.nData[2] = 0;
		if(Raw.nData[3] == 255)
			Raw.nData[3] = 0;
		
		Raw.nSize = 4;
		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		nIndex += 4;
		m_nDDataLen += 3;
		}
	
   // If nIndex < m_nEDataLen, then we got a decode message without padding.
   // We may want to throw some kind of warning here, but we are still required
   // to handle the decoding as if it was properly padded.
	if(nIndex < m_nEDataLen)
		{
		Raw.Clear();
		for(UINT i = nIndex; i < m_nEDataLen; i++)
			{
			Raw.nData[i - nIndex] = Base64Coder::m_DecodeTable[m_pEBuffer[i]];
			Raw.nSize++;
			if(Raw.nData[i - nIndex] == 255)
				Raw.nData[i - nIndex] = 0;
			}

		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		m_nDDataLen += (m_nEDataLen - nIndex);
		}
	}

UINT Base64Coder::_DecodeToBuffer(const TempBucket &Decode, BYTE *pBuffer)
	{
	TempBucket	Data;
	UINT			nCount = 0;

	_DecodeRaw(Data, Decode);

	for(int i = 0; i < 3; i++)
		{
		pBuffer[i] = Data.nData[i];
		if(pBuffer[i] != 255)
			nCount++;
		}

	return nCount;
	}


void Base64Coder::_EncodeToBuffer(const TempBucket &Decode, LPWSTR pBuffer)
	{
	TempBucket	Data;

	_EncodeRaw(Data, Decode);

	for(int i = 0; i < 4; i++)
		pBuffer[i] = Base64Digits[Data.nData[i]];

	switch(Decode.nSize)
		{
		case 1:
			pBuffer[2] = '=';
		case 2:
			pBuffer[3] = '=';
			}
		}

void Base64Coder::_DecodeRaw(TempBucket &Data, const TempBucket &Decode)
	{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] <<= 2;

	nTemp = Decode.nData[1];
	nTemp >>= 4;
	nTemp &= 0x03;
	Data.nData[0] |= nTemp;

	Data.nData[1] = Decode.nData[1];
	Data.nData[1] <<= 4;

	nTemp = Decode.nData[2];
	nTemp >>= 2;
	nTemp &= 0x0F;
	Data.nData[1] |= nTemp;

	Data.nData[2] = Decode.nData[2];
	Data.nData[2] <<= 6;
	nTemp = Decode.nData[3];
	nTemp &= 0x3F;
	Data.nData[2] |= nTemp;
	}

void Base64Coder::_EncodeRaw(TempBucket &Data, const TempBucket &Decode)
	{
	BYTE		nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] >>= 2;
	
	Data.nData[1] = Decode.nData[0];
	Data.nData[1] <<= 4;
	nTemp = Decode.nData[1];
	nTemp >>= 4;
	Data.nData[1] |= nTemp;
	Data.nData[1] &= 0x3F;

	Data.nData[2] = Decode.nData[1];
	Data.nData[2] <<= 2;

	nTemp = Decode.nData[2];
	nTemp >>= 6;

	Data.nData[2] |= nTemp;
	Data.nData[2] &= 0x3F;

	Data.nData[3] = Decode.nData[2];
	Data.nData[3] &= 0x3F;
	}

BOOL Base64Coder::_IsBadMimeChar(WCHAR nData)
	{
	switch(nData)
		{
		case L'\r': case L'\n': case L'\t': case L' ' :
		case L'\b': case L'\a': case L'\f': case L'\v':
			return TRUE;
		default:
			return FALSE;
		}
	}

void Base64Coder::_Init()
	{
	// Initialize Decoding table.
	int	i;

	for(i = 0; i < 256; i++)
		Base64Coder::m_DecodeTable[i] = -2;

	for(i = 0; i < 64; i++)
		{
		Base64Coder::m_DecodeTable[Base64Digits[i]]			= (char) i;
		Base64Coder::m_DecodeTable[Base64Digits[i]|0x80]	= (char) i;
		}

	Base64Coder::m_DecodeTable['=']				= -1;
	Base64Coder::m_DecodeTable['='|0x80]		= -1;

	Base64Coder::m_Init = TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\base64coder.h ===
// Base64Coder.h: interface for the Base64Coder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
#define AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEB64CH"
//
////////////////////////////////////////////////////////////////////////

class Base64Coder
	{
	// Internal bucket class.
	class TempBucket
	{
	public:
		BYTE		nData[4];
		BYTE		nSize;
		void		Clear()
			{
			::ZeroMemory(nData, sizeof(nData));
			nSize = 0;
			}
	};

	PBYTE					m_pDBuffer;
	LPWSTR					m_pEBuffer;
	UINT					m_nDBufLen;
	UINT					m_nEBufLen;
	UINT					m_nDDataLen;
	UINT					m_nEDataLen;

public:
	Base64Coder();
	virtual ~Base64Coder();

public:
	virtual void		Encode(const BYTE *, UINT);
	virtual void		Decode(LPCWSTR);

	virtual BYTE *		DecodedMessage() const;
	virtual LPCWSTR		EncodedMessage() const;

	virtual void		AllocEncode(UINT);
	virtual void		AllocDecode(UINT);
	virtual void		SetEncodeBuffer(LPCWSTR pBuffer, UINT nBufLen);
	virtual void		SetDecodeBuffer(const BYTE *pBuffer, UINT nBufLen);

protected:
	virtual void		_EncodeToBuffer(const TempBucket &Decode, LPWSTR pBuffer);
	virtual UINT		_DecodeToBuffer(const TempBucket &Decode, BYTE *pBuffer);
	virtual void		_EncodeRaw(TempBucket &, const TempBucket &);
	virtual void		_DecodeRaw(TempBucket &, const TempBucket &);
	virtual BOOL		_IsBadMimeChar(WCHAR);

	static  char		m_DecodeTable[256];
	static  BOOL		m_Init;
	void				_Init();
	};

#endif // !defined(AFX_BASE64CODER_H__B2E45717_0625_11D2_A80A_00C04FB6794C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\mkschema\main.cpp ===
#include "stdafx.hxx"
#include "vs_inc.hxx"

static unsigned s_iwcDocBegin;
static unsigned s_iwcDocEnd;


unsigned PrintStringToFile(FILE *file, LPCWSTR wsz, bool bPrintRootElement)
	{
	const WCHAR *pwc = wsz;
	fputc('{', file);
	unsigned ich = 0;

	if (bPrintRootElement)
		{
		fputs("L'<', L'r', L'o', L'o', L't', L'>', L'\\n', ", file);
		ich = 7;
		}

	s_iwcDocBegin = ich;


	while(*pwc != L'\0')
		{
		if ((ich++ % 10) == 0)
			fputc('\n', file);

		fprintf(file, "L'");

		if (*pwc == L'\\')
			{
			fputc('\\', file);
			fputc('\\', file);
			}
		else if (*pwc == L'\n')
			{
			fputc('\\', file);
			fputc('n', file);
			}
		else if (*pwc == L'\r')
			{
			fputc('\\', file);
			fputc('r', file);
			}
		else if (*pwc == L'\t')
			{
			fputc('\\', file);
			fputc('t', file);
			}
		else
			fputc((char) *pwc, file);

		fprintf(file, "', ");
		pwc++;
		}

	s_iwcDocEnd = ich;

	if (bPrintRootElement)
		{
		fputc('\n', file);
		fputs("L'\\n', L'<', L'/', L'r', L'o', L'o', L't', L'>', L'\\n', ", file);
		ich += 9;
		}


	fprintf(file, "L'\\0'\n};");

	return ich;
	}

extern "C" __cdecl wmain(int, WCHAR **)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"main");

	CXMLDocument doc;

	try
		{
		ft.hr = CoInitialize(NULL);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"CoInitialize failed.  hr = 0x%08lx",
				ft.hr
				);

		if (!doc.LoadFromFile(L"writermetadata.xml"))
			{
			printf("Cannot load writermetadata.xml\n");
			exit(-1);
			}

		CComBSTR bstr = doc.SaveAsXML();
		FILE *f = fopen("wmxml.c", "w");
		if (f == NULL)
			{
			printf("create of wmxml.c failed\n");
			exit(-1);
			}

		fprintf(f, "WCHAR g_WriterMetadataXML[] = \n");
		unsigned cwc = PrintStringToFile(f, bstr, false);
		fprintf
			(
			f,
			"\nconst unsigned g_cwcWriterMetadataXML = %d;\n\n",
			cwc
			);

		bstr.Empty();
		fclose(f);

		if (!doc.LoadFromFile(L"componentmetadata.xml"))
			{
			printf("Cannot load componentmetadata.xml\n");
			exit(-1);
			}

		bstr = doc.SaveAsXML();
		f = fopen("cmxml.c", "w");
		if (f == NULL)
			{
			printf("create of cmxml.c failed\n");
			exit(-1);
			}

		fprintf(f, "WCHAR g_ComponentMetadataXML[] = \n");
		cwc = PrintStringToFile(f, bstr, true);
		fprintf
			(
			f,
			"\nconst unsigned g_cwcComponentMetadataXML = %d;\n\n",
			cwc
			);

		fprintf
			(
			f,
			"\nconst unsigned g_iwcComponentMetadataXMLBegin = %d;\n\n",
			s_iwcDocBegin
			);

		fprintf
			(
			f,
			"\nconst unsigned g_iwcComponentMetadataXMLEnd = %d;\n\n",
			s_iwcDocEnd
			);

		fclose(f);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		{
		printf("Unexpected exception, hr = 0x%08lx", ft.hr);
		exit(-1);
		}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\async.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async.cxx | Implementation of CVssAsyncBackup object
    @end

Author:

    brian berkowitz  [brianb]  04/10/2000

Revision History:

    Name        Date        Comments
    brianb      04/10/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_sec.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "worker.hxx"
#include "async.hxx"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEASYNC"
//
////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//  CVssAsyncBackup


// constructor
CVssAsyncBackup::CVssAsyncBackup():
	m_hrState(S_OK),
	m_state(VSS_AS_UNDEFINED),
	m_pBackupComponents(NULL),
	m_bOwned(NULL)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::CVssAsyncBackup");

	m_bcsInitialized = false;
	try
		{
		// Initialize the critical section
		m_cs.Init();
		m_bcsInitialized = true;
		}
	VSS_STANDARD_CATCH(ft)
	}


// destructor
CVssAsyncBackup::~CVssAsyncBackup()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::~CVssAsyncBackup");

	try
		{
		// Wait for the worker thread to finish, if running.
		// WARNING: FinalReleaseWorkerThreadObject uses virtual methods!
		// Virtual methods in classes derived from CVssAsync are now inaccessible!
		FinalReleaseWorkerThreadObject();
		}
	VSS_STANDARD_CATCH(ft)
	}


// do operation by creating a thread to do it and return an IVssAsync object
// for backup to use
IVssAsync* CVssAsyncBackup::CreateInstanceAndStartJob
	(
	IN	CVssBackupComponents *	pBackupComponents,
	VSS_ASYNC_STATE				state
	)
	{
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    try
		{
		BS_ASSERT(state == VSS_AS_PREPARE_FOR_BACKUP ||
				  state == VSS_AS_BACKUP_COMPLETE ||
				  state == VSS_AS_RESTORE ||
				  state == VSS_AS_GATHER_WRITER_METADATA ||
				  state == VSS_AS_GATHER_WRITER_STATUS);

		BS_ASSERT(pBackupComponents);

        // Allocate the COM object.
        CComObject<CVssAsyncBackup>* pObject;
        ft.hr = CComObject<CVssAsyncBackup>::CreateInstance(&pObject);
        if (ft.HrFailed())
            ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr
				);

        if (!pObject->m_bcsInitialized)
            ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Error initializing critical section"
				);


        BS_ASSERT(pObject);

		// Setting async object internal data
        pObject->m_pBackupComponents = pBackupComponents;
		pObject->m_pvbcReference = pBackupComponents;
		pObject->m_state = state;

        // Querying the IVssSnapshot interface. Now the ref count becomes 1.
        CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
        BS_ASSERT(pUnknown);
        ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
        if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IVSSASYNC_FAILED, VSSDBG_XML << ft.hr);
            ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"Error querying the IVssAsync interface. hr = 0x%08lx",
				ft.hr
				);
            }

		BS_ASSERT(pAsync);

		// Prepare job (thread created in resume state)
		ft.hr = pObject->PrepareJob();
        if (ft.HrFailed())
            ft.Throw
				(
				VSSDBG_XML,
				ft.hr,
				L"CVssAsyncBackup::PrepareJob failed.  hr = 0x%08lx.",
				ft.hr
				);

		// increment reference count so that it lives throughout lifetime
		// of async thread
		pObject->GetUnknown()->AddRef();
		pObject->SetOwned();

		// Start job
		ft.hr = pObject->StartJob();
        if (ft.HrFailed())
			{
			// release reference held for thread
			pObject->ClearOwned();
			pObject->GetUnknown()->Release();
            ft.Throw
				(
				VSSDBG_XML,
				ft.hr,
				L"Error starting the job. hr = 0x%08lx",
				ft.hr
				);
			}

		// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
		}
    VSS_STANDARD_CATCH(ft)

	return pAsync.Detach();	  // The ref count remains 1.
	}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


// do basic initialization
bool CVssAsyncBackup::OnInit()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnInit");

    try
		{
		if (m_pBackupComponents != NULL)
			{
			BS_ASSERT(m_hrState == S_OK);
			m_hrState = VSS_S_ASYNC_PENDING;
			}
		}
    VSS_STANDARD_CATCH(ft)

	return m_pBackupComponents != NULL;
	}


// execute PrepareForBackup or BackupComplete
void CVssAsyncBackup::OnRun()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnRun");

	bool bCoInitializeSucceeded = false;

	try
		{
		// Check if the backup components object is created.
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw(VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		ft.CheckForError(VSSDBG_XML, L"CoInitializeEx");

        bCoInitializeSucceeded = true;
		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).

		m_timestamp = m_pBackupComponents->m_timestampOperation + 1;

		
		// Call StartSnapshotSet on the given object.
		if (m_state == VSS_AS_PREPARE_FOR_BACKUP)
			{
			ft.hr = m_pBackupComponents->InternalPrepareForBackup();
			if (ft.HrFailed())
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal PrepareBackup failed. 0x%08lx",
					ft.hr
					);
            }
		else if (m_state == VSS_AS_BACKUP_COMPLETE)
			{
			ft.hr = m_pBackupComponents->InternalBackupComplete();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal BackupComplete failed. 0x%08lx",
					ft.hr
					);
			}
		else if (m_state == VSS_AS_RESTORE)
			{
			ft.hr = m_pBackupComponents->InternalPostRestore();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal BackupComplete failed. 0x%08lx",
					ft.hr
					);
            }
		else if (m_state == VSS_AS_GATHER_WRITER_METADATA)
			{
			// save previous state and timestamp that will be used
			// for gather writer metadata.  It is passed into
			// PostGatherWriterMetadata if Cancel is called.
			m_stateSaved = m_pBackupComponents->m_state;
			ft.hr = m_pBackupComponents->InternalGatherWriterMetadata();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal GatherWriterMetadata failed. 0x%08lx",
					ft.hr
					);
            }
		else
			{
			BS_ASSERT(m_state == VSS_AS_GATHER_WRITER_STATUS);

			// save previous state and timestamp that will be used
			// for gather writer metadata.  It is passed into
			// PostGatherWriterStatus if Cancel is called.
			m_stateSaved = m_pBackupComponents->m_state;

			ft.hr = m_pBackupComponents->InternalGatherWriterStatus();
			if (ft.hr != S_OK)
				ft.Trace
					(
					VSSDBG_XML,
					L"Internal GatherWriterStatus failed. 0x%08lx",
					ft.hr
					);
            }

		if (ft.hr != S_OK)
			// Put the error code into the
			m_hrState = ft.hr;
		}
	VSS_STANDARD_CATCH(ft)

	if (bCoInitializeSucceeded)
		CoUninitialize();
	}


void CVssAsyncBackup::OnFinish()	
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::OnFinish");

    try
		{
		if (m_hrState == VSS_S_ASYNC_PENDING)
			m_hrState = VSS_S_ASYNC_FINISHED;

        // Mark the thread as finished, as the last operation
		MarkAsFinished();
		}
	VSS_STANDARD_CATCH(ft)

	// release interface pointer owned by the thread
	BS_ASSERT(m_bOwned);
	m_bOwned = false;
	Release();
	}


void CVssAsyncBackup::OnTerminate()
    {
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsyncBackup::OnTerminate" );
    }



/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssAsyncBackup::Cancel()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncBackup::Cancel");

	try
		{
		// The critical section will be left automatically at the end of scope.
		CVssSafeAutomaticLock lock(m_cs);

		// Safety check
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw(VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL");
			}

		// If thread is already finished, return correct code.
		if (m_hrState == VSS_S_ASYNC_FINISHED ||
			m_hrState == VSS_S_ASYNC_CANCELLED)
			ft.hr = m_hrState;
		else
			{
			m_hrState = VSS_S_ASYNC_CANCELLED;
			switch(m_state)
				{
				default:
					BS_ASSERT(FALSE && "Invalid ASYNC state");
					break;

				case VSS_AS_PREPARE_FOR_BACKUP:
					m_pBackupComponents->PostPrepareForBackup(m_timestamp);
					break;

				case VSS_AS_BACKUP_COMPLETE:
					m_pBackupComponents->PostBackupComplete(m_timestamp);
					break;

				case VSS_AS_RESTORE:
					m_pBackupComponents->PostPostRestore(m_timestamp);
					break;

				case VSS_AS_GATHER_WRITER_STATUS:
					m_pBackupComponents->PostGatherWriterStatus
						(
						m_timestamp,
						m_stateSaved
						);

					break;

				case VSS_AS_GATHER_WRITER_METADATA:
					ft.hr = m_pBackupComponents->PostGatherWriterMetadata
						(
						m_timestamp,
						m_stateSaved
						);

                    if (FAILED(ft.hr))
						m_hrState = ft.hr;

					break;
				}
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


STDMETHODIMP CVssAsyncBackup::Wait(DWORD dwMilliseconds)
{
        UNREFERENCED_PARAMETER(dwMilliseconds);
        
	CVssFunctionTracer ft( VSSDBG_XML, L"CVssAsyncBackup::Wait" );

	try
		{
		// Safety check
		if (m_pBackupComponents == NULL)
			{
			BS_ASSERT(false);
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		// wait for thread to terminate
		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			{
			ft.LogError(VSS_ERROR_THREADHANDLE_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"invalid hThread");
			}

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
			{
			ft.LogError(VSS_ERROR_WAITFORSINGLEOBJECT, VSSDBG_XML << HRESULT_FROM_WIN32(GetLastError()));
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


STDMETHODIMP CVssAsyncBackup::QueryStatus
	(
	OUT     HRESULT* pHrResult,
	OUT     INT* pnReserved
	)
	{
	CVssFunctionTracer ft( VSSDBG_XML, L"CVssAsyncBackup::QueryStatus" );

	try
		{
		VssZeroOut(pHrResult);
		VssZeroOut(pnReserved);
		// Argument check
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL.");

		// The critical section will be left automatically at the end of scope.
		CVssSafeAutomaticLock lock(m_cs);

		// Safety check
		if (m_pBackupComponents == NULL)
			{
			ft.LogError(VSS_ERROR_BACKUPCOMPONENTS_NULL, VSSDBG_XML);
			ft.Throw( VSSDBG_XML, E_UNEXPECTED, L"BackupComponents object is NULL.");
			}

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_XML, L"Returning *pHrResult: 0x%08x", *pHrResult );		
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



/////////////////////////////////////////////////////////////////////////////
//  IVssAsync Cover implementation


void CVssAsyncCover::CreateInstance(
    IN  CVssBackupComponents* pBackupComponents,
    IN  IVssAsync* pAsyncInternal,
    OUT IVssAsync** ppAsync
    ) throw(HRESULT)

/*++

Description:

    Creates a cover for a given IVssAsync and a backup components object.

Comments:

    This object is used to intercept all calls to the internal async QueryStatus

--*/

{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::CreateInstance");

    BS_ASSERT(pBackupComponents);
    BS_ASSERT(pAsyncInternal);
    BS_ASSERT(ppAsync && (*ppAsync == NULL));
	
	// create cover async object
	CComObject<CVssAsyncCover>* pObject;
	ft.hr = CComObject<CVssAsyncCover>::CreateInstance(&pObject);
	if (ft.HrFailed())
		ft.Throw
		(
		VSSDBG_XML,
		E_OUTOFMEMORY,
		L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr
		);

    // Fill out the data members (the ref counts are incremented)
	pObject->m_pvbc = pBackupComponents;
	pObject->m_pvbcReference = pBackupComponents;
	pObject->m_pAsync = pAsyncInternal;

	// Get the IVssAsync interface
	CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
	BS_ASSERT(pUnknown);
	CComPtr<IVssAsync> ptrAsync;
	ft.hr = pUnknown->SafeQI(IVssAsync, &ptrAsync);
	if (ft.HrFailed())
		{
		BS_ASSERT(FALSE && "QI shouldn't fail");
		ft.LogError(VSS_ERROR_QI_IVSSASYNC_FAILED, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"Error querying the IVssAsync interface. hr = 0x%08lx",
			ft.hr
			);
		}

    // Copy the interface to the out parameter
    ptrAsync.CopyTo(ppAsync);
}


STDMETHODIMP CVssAsyncCover::Cancel()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::Cancel");

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	ft.hr = m_pAsync->Cancel();
	if (ft.hr == VSS_S_ASYNC_FINISHED)
		m_pvbc->m_state = x_StateDoSnapshotSucceeded;
	else
		m_pvbc->m_state = x_StateDoSnapshotFailed;

	return ft.hr;
	}


STDMETHODIMP CVssAsyncCover::Wait(DWORD dwMilliseconds)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::Wait");

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	ft.hr = m_pAsync->Wait(dwMilliseconds);

	return ft.hr;
	}


STDMETHODIMP CVssAsyncCover::QueryStatus
	(
	OUT     HRESULT* pHrResult,
	OUT     INT* pnPercentDone
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssAsyncCover::QueryStatus");

	if (pHrResult == NULL)
		return E_INVALIDARG;

	BS_ASSERT(m_pAsync);
	BS_ASSERT(m_pvbc);

	try
		{
		ft.hr = m_pAsync->QueryStatus(pHrResult, pnPercentDone);
		if (*pHrResult == VSS_E_BAD_STATE)
			m_pvbc->m_state = x_StateDoSnapshotFailedWithoutSendingAbort;
		else if (FAILED(ft.hr) ||
			FAILED(*pHrResult) ||
			*pHrResult == VSS_S_ASYNC_CANCELLED)
			m_pvbc->m_state = x_StateDoSnapshotFailed;
		else if (*pHrResult == VSS_S_ASYNC_FINISHED)
			 m_pvbc->m_state = x_StateDoSnapshotSucceeded;
		 }
	 VSS_STANDARD_CATCH(ft)

	 return ft.hr;
	 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\vs_xml.cxx ===
/////////////////////////////////////////////////////////////////////////////
// CXMLNode  implementation


#include "stdafx.hxx"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "vs_types.hxx"
#include "vs_str.hxx"
#include "vs_vol.hxx"
#include "vs_hash.hxx"
#include "vs_list.hxx"
#include "msxml2.h" //  #182584 - was msxml.h
#include "vs_xml.hxx"
#include "rpcdce.h"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEXMLC"
//
////////////////////////////////////////////////////////////////////////

// insert a node under the specified node
// The returned interface must be explicitely released.
IXMLDOMNode* CXMLNode::InsertChild
	(
	IN	IXMLDOMNode* pChildNode,	// node to insert
	IN  const CComVariant& vAfter	// node this comes after
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::InsertChild");

	// validate we have a parent node to insert under
	if (m_pNode == NULL || pChildNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	CComPtr<IXMLDOMNode> pInsertedNode;
	// insert node
	ft.hr = m_pNode->insertBefore(pChildNode, vAfter, &pInsertedNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::insertBefore");

    // return inserted node
	return pInsertedNode.Detach();
	}


// append a node as a child node of the node
// The returned interface must be explicitely released.
void CXMLNode::AppendChild
	(
	IN	CXMLNode& childNode,
	OUT	IXMLDOMNode** ppNewChildNode
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::AppendChild");

	// validate input arguments
	if ((m_pNode == NULL) || (childNode.m_pNode == NULL) )
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	if (ppNewChildNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

	// append child node
	ft.hr = m_pNode->appendChild( childNode.m_pNode, ppNewChildNode );
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::appendChild");
	}

// set a guid valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  GUID ValueId
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw( VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	LPWSTR wszUuid;
	// convert GUID to string
	RPC_STATUS status = UuidToString(&ValueId, &wszUuid);
	if (status != RPC_S_OK || wszUuid == NULL)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// convert string to BSTR
	CComBSTR bstrValueId = wszUuid;

	// free up RPC string created by UuidToString
	RpcStringFree(&wszUuid);
	if (!bstrValueId)
        ft.Throw( VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValueId;
	
	CComPtr<IXMLDOMElement> pElement;
    ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMElement to the node. 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set a string valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  LPCWSTR wszValue
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");
	if (m_pNode == NULL || wszAttributeName == NULL || wszValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrValue = wszValue;
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
        ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMNode to IXMLDOMElement. 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set an integer valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  INT nValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	// set attribute name as BSTR
	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw( VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = nValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying from IXMLDOMNode to IXMLDOMElement. hr = 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
	}


// set a DWORDLONG valued attribute
void CXMLNode::SetAttribute
	(
	IN  LPCWSTR wszAttributeName,
	IN  LONGLONG llValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetAttribute");

	const nTimestampBufferSize = 0x10;

	if (m_pNode == NULL || wszAttributeName == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument");

	CComBSTR bstrAttributeName = wszAttributeName;
	if (!bstrAttributeName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComBSTR bstrValue(nTimestampBufferSize + 1);
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// Print the LONGLONG value
	::_snwprintf(bstrValue, nTimestampBufferSize, L"%016I64x", llValue);

	CComVariant varValue = bstrValue;
	
	CComPtr<IXMLDOMElement> pElement;
	ft.hr = m_pNode->SafeQI(IXMLDOMElement, &pElement);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IXMLDOMNODE_TO_IXMLDOMELEMENT, VSSDBG_XML << ft.hr);
        ft.Throw
			(
			VSSDBG_XML,
			E_UNEXPECTED,
			L"IXMLDOMNode::SafeQI",
			L"Error querying IXMLDOMElement from the IXMLDOMNode. hr = 0x%08lx",
			ft.hr
			);
        }

	// Set the attribute
	ft.hr = pElement->setAttribute(bstrAttributeName, varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::setAttribute");
    }


// add text to a node
void CXMLNode::AddText
	(
	IN  LPCWSTR wszText
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::AddText");

	if (m_pNode == NULL || m_pDoc == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument.");

	CXMLDocument doc(m_pDoc);
	CComPtr<IXMLDOMNode> pTextNode;
	CXMLNode textNode = doc.CreateNode(NULL, NODE_TEXT);
	textNode.SetValue(wszText);
	InsertNode(textNode);
    }


void CXMLNode::SetValue
	(
	IN  LPCWSTR wszValue
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::SetValue");

	if (m_pNode == NULL || wszValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL input argument.");

	CComBSTR bstrValue = wszValue;
	if (!bstrValue)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	CComVariant varValue = bstrValue;
	
	// Set the attribute
	ft.hr = m_pNode->put_nodeValue(varValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::put_nodeValue");
    }


/////////////////////////////////////////////////////////////////////////////
// CXMLDocument  implementation


void CXMLDocument::Initialize
	(
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::Initialize");

	m_pDoc = NULL;

	ft.hr = m_pDoc.CoCreateInstance(CLSID_DOMDocument30);  //  #182584 - Was CLSID_DOMDocument26
	ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

	m_pNode = static_cast<IXMLDOMNode*>(m_pDoc);
	m_pNodeCur = m_pNode;
	m_level = 0;
	}


// create a node
CXMLNode CXMLDocument::CreateNode
	(
	IN  LPCWSTR wszName,
	IN  DOMNodeType nType
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::CreateNode");

	// Check if the document is properly initialized
	if (m_pDoc == NULL)
        ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL document");

    CComPtr<IXMLDOMNode> pNode;
    CComVariant vType = (INT)nType;
	CComBSTR bstrName = wszName;		// Duplicating the string.

	// Check if no errors when preparing the arguments
	if (!bstrName && wszName)
        ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Memory allocation error");

	// Create the node
    ft.hr = m_pDoc->createNode(vType, bstrName, NULL, &pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::createNode");

	BS_ASSERT(pNode != NULL);

	return CXMLNode(pNode, m_pDoc);
    }

// insert a node below the current one
CXMLNode CXMLNode::InsertNode
	(
	CXMLNode &node
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::InsertNode");

	CComPtr<IXMLDOMNode> pInsertedNode;
	pInsertedNode.Attach(InsertChild(node.GetNodeInterface()));

	return CXMLNode(pInsertedNode, m_pDoc);
	}



// position on next node
bool CXMLDocument::Next
	(
	IN bool fDescend,					// descend to child if one exists
	IN bool fAscendAllowed				// can ascend to parent?
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::Next");

	CComPtr<IXMLDOMNode> pNodeNext = NULL;
	m_pAttributeMap = NULL;

	while(TRUE)
		{
		// at end?
		if (m_pNodeCur == NULL)
			return FALSE;

		if (fDescend)
			{
			// get first child
			ft.hr = m_pNodeCur->get_firstChild(&pNodeNext);
			ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_firstChild");

			if (ft.hr == S_OK)
				{
				// child was found
				BS_ASSERT(pNodeNext != NULL);
				m_pNodeCur.Attach(pNodeNext.Detach());

				// decended a level
				m_level++;
				return TRUE;
				}
            }

		// move to sibling node
		ft.hr = m_pNodeCur->get_nextSibling(&pNodeNext);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nextSibling");

		if (ft.hr == S_OK)
			{
			// sibling was found
			BS_ASSERT(pNodeNext != NULL);
			m_pNodeCur.Attach(pNodeNext.Detach());
			return TRUE;
			}

		// check if ascend is allowed and that we are not at the toplevel of
		// the document
		if (!fAscendAllowed || m_level == 0)
			return FALSE;

		// get parent node
		ft.hr = m_pNodeCur->get_parentNode(&pNodeNext);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_parentNode");

	    m_pNodeCur.Attach(pNodeNext.Detach());
		// don't descend to back where we came from
		fDescend = FALSE;

		// move up one level
		m_level--;
		}
	}

// find a specific child attribute of the current node
bool CXMLDocument::FindAttribute
	(
	IN LPCWSTR wszAttrName,			// attriburte name
	OUT BSTR *pbstrAttrValue		// string value of attribute
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::FindAttribute");

	if (m_pNodeCur == NULL || wszAttrName == NULL || pbstrAttrValue == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL argument.");

	// create attribute map if one doesn't exist
	if (m_pAttributeMap == NULL)
		{
		ft.hr = m_pNodeCur->get_attributes(&m_pAttributeMap);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_attributes");
        }

	if (m_pAttributeMap == NULL)
		return FALSE;

	CComPtr<IXMLDOMNode> pNode = NULL;

	// get attribute
	ft.hr = m_pAttributeMap->getNamedItem((LPWSTR) wszAttrName, &pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNamedNodeMap::getNamedItem");

	if (ft.hr == S_FALSE)
		return false;

	ft.hr = pNode->get_text(pbstrAttrValue);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_text");

	return TRUE;
	}

// move to next attribute
IXMLDOMNode *CXMLDocument::NextAttribute()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::NextAttribute");

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Node.");

	if (m_pAttributeMap == NULL)
		{
		ft.hr = m_pNodeCur->get_attributes(&m_pAttributeMap);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_attributes");
        }

	if (m_pAttributeMap == NULL)
		return FALSE;

	IXMLDOMNode *pNode = NULL;
	// position at next attribute
	ft.hr = m_pAttributeMap->nextNode(&pNode);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNamedNode::nextNode");

	if (ft.hr == S_FALSE)
		return NULL;

	return pNode;
	}


// reset to top node in document
void CXMLDocument::ResetToDocument()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::ResetToDocument");

	m_pNodeCur = m_pNode;
	m_pAttributeMap = NULL;
	m_level = 0;
	}

// reset to parent node in the document
void CXMLDocument::ResetToParent() throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::ResetToParent");

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	// check to see that we are not at the top level of the document
	if (m_pNodeCur == m_pNode || m_level == 0)
		return;

	CComPtr<IXMLDOMNode> pNodeParent;
	// get parent node
	ft.hr = m_pNodeCur->get_parentNode(&pNodeParent);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_parentNode");

    BS_ASSERT(pNodeParent);
    m_pNodeCur.Attach(pNodeParent.Detach());
	m_pAttributeMap = NULL;

	// move up one level
	m_level--;
	}

// does current node match the specific atttribute type.
bool CXMLDocument::IsNodeMatch
	(
	LPCWSTR wszElementType
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::IsNodeMatch");
	DOMNodeType dnt;

	if (m_pNodeCur == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL node");

	ft.hr = m_pNodeCur->get_nodeType(&dnt);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_NodeType");

	 // check that node type is an element
     if (dnt == NODE_ELEMENT)
		{
		CComBSTR bstrName;

		// get node name
		ft.hr = m_pNodeCur->get_nodeName(&bstrName);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_NodeName");

        // check for match
		if (wcscmp(bstrName, wszElementType) == 0)
			return TRUE;
		}

	return false;
	}

// find a specific child or sibling node
bool CXMLDocument::FindElement
	(
	IN LPCWSTR wszElementType,		// element type to loo for
	IN bool bGotoChild = TRUE		// whether to look for a child node
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::FindElement");

	bool bDescend = bGotoChild;

	// save current level so that we don't ascend above this
	unsigned levelStart = m_level;

	// look for node
	while(Next(bDescend, TRUE))
		{
		bDescend = FALSE;
		if (IsNodeMatch(wszElementType))
			return true;
		}

	// if we descended to the child level, reset to parent level
	if (bGotoChild && m_level > levelStart)
		ResetToParent();

	return FALSE;
	}

// save document as an XML string
BSTR CXMLNode::SaveAsXML
	(
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLNode::saveAsXML");
	BSTR bstrOut;

	if (m_pNode == NULL)
		ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL document.");

	ft.hr = m_pNode->get_xml(&bstrOut);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_xml");

    return bstrOut;
	}

// load document from an XML string
bool CXMLDocument::LoadFromXML
	(
	IN BSTR bstrXML
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::LoadFromXML");

	m_pDoc = NULL;
	Initialize();
	BS_ASSERT(m_pDoc != NULL);
	VARIANT_BOOL bSuccessful;
	ft.hr = m_pDoc->loadXML(bstrXML, &bSuccessful);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::loadXML");
		
	return bSuccessful ? TRUE : FALSE;
	}

// load document from a file
bool CXMLDocument::LoadFromFile
	(
	IN LPCWSTR wszFile
	) throw(HRESULT)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CXMLDocument::LoadFromFile");

	// reinitialize the document
	m_pDoc = NULL;
	Initialize();
	BS_ASSERT(m_pDoc != NULL);

	// setup arguments for the Load call
	VARIANT_BOOL bSuccessful;
	VARIANT varFile;
	VariantInit(&varFile);
	varFile.bstrVal = SysAllocString(wszFile);
	varFile.vt = VT_BSTR;

	ft.hr = m_pDoc->load(varFile, &bSuccessful);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::load");

    // return whether load was successful or not
	return bSuccessful ? TRUE : FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\vs_wmxml.cxx ===
/*++
Module Name:

    vs_wmxml.cxx

Abstract:

    Implementation of Writer Metadata XML wrapper classes

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/13/2000  Created
    brianb      03/22/2000  Added support CVssGatherWriterMetadata
    brianb	04/04/2000  Removed debug printf
    mikejohn	04/11/2000  Fix some loop iteration problems
    brianb      04/21/2000  code cleanup
    mikejohn	06/13/2000  minor tracing changes

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"

#include "vs_idl.hxx"
#include "vssmsg.h"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "base64coder.h"


#include "rpcdce.h"

#include "wmxml.c"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEWXMLC"
//
////////////////////////////////////////////////////////////////////////

static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementWriterMetadata = L"WRITER_METADATA";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssWriterMetadataInfo";
static LPCWSTR x_wszDocProlog = L"<root>";
static LPCWSTR x_wszDocEpilog = L"</root>";

// identification element and its attributes
static LPCWSTR x_wszElementIdentification = L"IDENTIFICATION";
static LPCWSTR x_wszAttrWriterId = L"writerId";
static LPCWSTR x_wszAttrInstanceId = L"instanceId";
static LPCWSTR x_wszAttrFriendlyName = L"friendlyName";
static LPCWSTR x_wszAttrUsage = L"usage";
static LPCWSTR x_wszAttrDataSource = L"dataSource";

// backup location elements
static LPCWSTR x_wszElementBackupLocations = L"BACKUP_LOCATIONS";
static LPCWSTR x_wszElementIncludeFiles = L"INCLUDE_FILES";
static LPCWSTR x_wszElementExcludeFiles = L"EXCLUDE_FILES";
static LPCWSTR x_wszElementDatabase = L"DATABASE";
static LPCWSTR x_wszElementFilegroup = L"FILE_GROUP";

// RESTORE_METHOD element and it's attributes
static LPCWSTR x_wszElementRestoreMethod = L"RESTORE_METHOD";
static LPCWSTR x_wszAttrMethod = L"method";
static LPCWSTR x_wszAttrService = L"service";
static LPCWSTR x_wszAttrUserProcedure = L"userProcedure";
static LPCWSTR x_wszAttrWriterRestore = L"writerRestore";
static LPCWSTR x_wszAttrRebootRequired = L"rebootRequired";
static LPCWSTR x_wszElementAlternateMapping = L"ALTERNATE_LOCATION_MAPPING";

// attributes and elements associated with DATABASE and FILE_GROUP components
static LPCWSTR x_wszAttrLogicalPath = L"logicalPath";
static LPCWSTR x_wszAttrComponentName = L"componentName";
static LPCWSTR x_wszAttrCaption = L"caption";
static LPCWSTR x_wszAttrRestoreMetadata = L"restoreMetadata";
static LPCWSTR x_wszAttrNotifyOnBackupComplete = L"notifyOnBackupComplete";
static LPCWSTR x_wszAttrIcon = L"icon";
static LPCWSTR x_wszAttrSelectable = L"selectable";
static LPCWSTR x_wszElementDatabaseFiles = L"DATABASE_FILES";
static LPCWSTR x_wszElementDatabaseLogfiles = L"DATABASE_LOGFILES";
static LPCWSTR x_wszElementFilelist = L"FILE_LIST";

// attributes for a FILE_LIST, INCLUDE_FILES, EXCLUDE_FILES,
// or ALTERNATE_DESTINATION_MAPPING elements

static LPCWSTR x_wszAttrPath = L"path";
static LPCWSTR x_wszAttrFilespec = L"filespec";
static LPCWSTR x_wszAttrRecursive = L"recursive";
static LPCWSTR x_wszAttrAlternatePath = L"alternatePath";

// various attributes and values associated with toplevel WRITER_METADATA
// element
static LPCWSTR x_wszAttrVersion = L"version";
static LPCWSTR x_wszVersionNo = L"1.0";

bool CVssExamineWriterMetadata::LoadDocument(BSTR bstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::LoadDocument");

	BSTR bstr = NULL;

	try
		{
		// compute length of supplied XML document
		UINT cwcXML = (UINT) wcslen(bstrXML);

		// compute length of constructed document consisting of
		// a root node, schema, and supplied document
		UINT cwcDoc = cwcXML +
						  (UINT) g_cwcWriterMetadataXML +
                          (UINT) wcslen(x_wszDocProlog) +
                          (UINT) wcslen(x_wszDocEpilog);

        // allocate string
        bstr = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root>
	    wcscpy(pwc, x_wszDocProlog);
		pwc += wcslen(x_wszDocProlog);

		// copy in schema
		memcpy(pwc, g_WriterMetadataXML, g_cwcWriterMetadataXML* sizeof(WCHAR));
		pwc += g_cwcWriterMetadataXML;

		// copy in supplied WRITER_METADATA element
		memcpy(pwc, bstrXML, cwcXML * sizeof(WCHAR));
		pwc += cwcXML;

		// copy in </root>
		wcscpy(pwc, x_wszDocEpilog);

		// load document from string
		bool bLoaded = m_doc.LoadFromXML(bstr);

		// free allocated string
		SysFreeString(bstr);
		bstr = NULL;

		// check load success
		if (!bLoaded)
			return false;

		// find root element
		if (!m_doc.FindElement(x_wszElementRoot, TRUE))
			return false;

		// find WRITER_METADATA element
		if (!m_doc.FindElement(x_wszElementWriterMetadata, TRUE))
			return false;

		// set toplevel node to WRITER_METADATA element
		m_doc.SetToplevel();
		return true;
		}
	catch(...)
		{
		// free allocated string
		if (bstr != NULL)
			SysFreeString(bstr);

		throw;
		}
	}




// initialize metadata document from an XML string.  Return S_FALSE if
// the document is not correctly formed.
bool CVssExamineWriterMetadata::Initialize
	(
	IN BSTR bstrXML					// WRITER_METADATA element
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::Initialize");

	// temporary string containing XML document including schema
	InitializeHelper(ft);
	return LoadDocument(bstrXML);
	}

// obtain information from the IDENTIFICATION element
// implements IVssExamineWriterMetadata::GetIdentity
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either pidInstance, pidWriter, pbstrWriterName, pUsage,
//			or pSource is NULL
//		VSS_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetIdentity
	(
	OUT VSS_ID *pidInstance,		// instance id
	OUT VSS_ID *pidWriter,			// id of writer class
	OUT BSTR *pbstrWriterName,		// name of writer
	OUT VSS_USAGE_TYPE *pUsage,		// usage type for writer
	OUT VSS_SOURCE_TYPE *pSource    // type of data source for writer
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetIdentity"
		);

	try
		{
        // null output parameters
		if (pUsage)
			*pUsage = VSS_UT_UNDEFINED;

		if (pSource)
			*pSource = VSS_ST_UNDEFINED;

		VssZeroOut(pidInstance);
        VssZeroOut(pidWriter);
        VssZeroOut(pbstrWriterName);

		// check arguments
		if (pidInstance == NULL ||
			pidWriter == NULL ||
			pbstrWriterName == NULL ||
			pUsage == NULL ||
			pSource == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"NULL output parameter."
				);


		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
        m_doc.ResetToDocument();

		// look for child IDENTIFICATION element
		if (!m_doc.FindElement(x_wszElementIdentification, TRUE))
			MissingElement(ft, x_wszElementIdentification);

        VSS_ID idInstance;
		VSS_ID idWriter;
		CComBSTR bstrWriterName;
		VSS_USAGE_TYPE usage;
		VSS_SOURCE_TYPE source;


        // obtain instanceId attribute value
        get_VSS_IDValue(ft, x_wszAttrInstanceId, &idInstance);

		// obtain writerId attribute value
        get_VSS_IDValue(ft, x_wszAttrWriterId, &idWriter);

		// obtain friendlyName attribute value
		get_stringValue(x_wszAttrFriendlyName, &bstrWriterName);

        CComBSTR bstrVal;

		// extract usage Attribute value
        if (!m_doc.FindAttribute(x_wszAttrUsage, &bstrVal))
			MissingAttribute(ft, x_wszAttrUsage);

        // convert string value to VSS_USAGE_TYPE
		usage = ConvertToUsageType(ft, bstrVal);
		bstrVal.Empty();

		// extract source attribute value
		if (!m_doc.FindAttribute(x_wszAttrDataSource, &bstrVal))
			MissingAttribute(ft, x_wszAttrDataSource);

        // convert string to VSS_SOURCE_TYPE
		source = ConvertToSourceType(ft, bstrVal);

        // assign output parameters
        *pUsage = usage;
        *pSource = source;
        *pidInstance = idInstance;
        *pidWriter = idWriter;
        *pbstrWriterName = bstrWriterName.Detach();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}




// get count of components, files to include and files to exclude.
// implements IVssExamineWriterMetadata::GetFileCounts
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcIncludeFiles, pcExcludeFiles, or pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetFileCounts
	(
	OUT UINT *pcIncludeFiles,		// count of INCLUDE_FILES elements
	OUT UINT *pcExcludeFiles,		// count of EXCLUDE_FILES elements
	OUT UINT *pcComponents			// count of DATABASE and FILE_GROUP elements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetFileCounts"
		);

	try
		{
		VssZeroOut(pcExcludeFiles);
		VssZeroOut(pcComponents);

        // check output parametrs
		if (pcIncludeFiles == NULL ||
			pcExcludeFiles == NULL ||
			pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // initalize output parameters
		*pcIncludeFiles = 0;

		CVssSafeAutomaticLock lock(m_csDOM);
        // reposition to top of document
		m_doc.ResetToDocument();
        // position on first BACKUP_LOCATIONS child element
		if (m_doc.FindElement(x_wszElementBackupLocations, TRUE) &&
			m_doc.Next())
			{
			UINT cIncludeFiles = 0;
			UINT cExcludeFiles = 0;
			UINT cComponents = 0;
			do
				{
				// get current node
				CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

				DOMNodeType dnt;

				// get node type
				ft.hr = pNode->get_nodeType(&dnt);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

				// if node type is not element, then skip it
				if (dnt != NODE_ELEMENT)
					continue;

				// get node name
				CComBSTR bstrName;
				ft.hr = pNode->get_nodeName(&bstrName);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

				// update counts based on element type
				if (wcscmp(bstrName, x_wszElementIncludeFiles) == 0)
					cIncludeFiles += 1;
				else if (wcscmp(bstrName, x_wszElementExcludeFiles) == 0)
					cExcludeFiles += 1;
				else if (wcscmp(bstrName, x_wszElementDatabase) == 0 ||
						 wcscmp(bstrName, x_wszElementFilegroup) == 0)
					cComponents += 1;
				} while(m_doc.Next(FALSE, FALSE));

			*pcIncludeFiles = cIncludeFiles;
			*pcExcludeFiles = cExcludeFiles;
			*pcComponents = cComponents;
			}
		}
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}

// obtain a specific kind of file INCLUDE_FILES or EXCLUDE_FILES
HRESULT CVssExamineWriterMetadata::GetFileType
	(
	CVssFunctionTracer &ft,
	IN UINT iFile,							// which element to extract
	IN LPCWSTR wszFileType,					// which elements to filter
	OUT IVssWMFiledesc **ppFiledesc			// file descriptor
	)
	{
	CVssWMFiledesc *pFiledesc = NULL;
	try
		{
        // check output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // null output parameter
        *ppFiledesc = NULL;
		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find BACKUP_LOCATIONS element
		if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"BACKUP_LOCATIONS element was not found."
				);

        // find element type within BACKUP_LOCATIONS
		if (!m_doc.FindElement(wszFileType, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"%s element was not found",
				wszFileType
				);

        // skip to selected element
		for(UINT i = 0; i < iFile; i++)
			{
			if (!m_doc.FindElement(wszFileType, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"%s element was not found"
					);
			}

        // construct Filedesc for selected element
		pFiledesc = new CVssWMFiledesc(m_doc.GetCurrentNode());

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Can't create CVssWMFiledesc due to allocation failure."
				);

        // 2nd phase of construction
        pFiledesc->Initialize(ft);

		// transfer ownership of pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
		((IVssWMFiledesc *) pFiledesc)->AddRef();

		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// return an INCLUDE_FILES element
// implements IVssExamineWriterMetadata::GetIncludeFile
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified exclude file doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetIncludeFile
	(
	IN UINT iFile,						// which element to select
	OUT IVssWMFiledesc **ppFiledesc		// output constructed Filedesc
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetIncludeFile"
		);

    // call helper routine
	return GetFileType(ft, iFile, x_wszElementIncludeFiles, ppFiledesc);
	}


// return an EXCLUDE_FILES element
// implements IVssExamineWriterMetadata::GetExcludeFile
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified exclude file doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetExcludeFile
	(
	IN UINT iFile,
	OUT IVssWMFiledesc **ppFiledesc
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetExcludeFile"
		);

	return GetFileType(ft, iFile, x_wszElementExcludeFiles, ppFiledesc);
	}

// obtain a component (DATABASE or FILE_GROUP)
// implements IVssExamineWriterMetadata::GetComponent
// caller is responsible for calling IVssWMComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified component is not found
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is corrupt
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetComponent
	(
	IN UINT iComponent,						// which component to select
	OUT IVssWMComponent **ppComponent		// returned component
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetComponent"
		);


	CVssWMComponent *pComponent = NULL;

    try
		{
        // check output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // set output parameter to NULL
        *ppComponent = NULL;


		CVssSafeAutomaticLock lock(m_csDOM);

        // reset position to top of document
		m_doc.ResetToDocument();

        // position on BACKUP_LOCATIONS element
		if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"BACKUP_LOCATIONS element was not found"
				);

        // position on first child element of BACKUP_LOCATIONS
        if (!m_doc.Next(TRUE, FALSE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Component was not found"
				);

        // current node
		CComPtr<IXMLDOMNode> pNode = NULL;
		for(UINT i = 0; i <= iComponent; )
			{
			DOMNodeType dnt;

            // obtain current node
            pNode = m_doc.GetCurrentNode();

            // obtain node type
            ft.hr = pNode->get_nodeType(&dnt);
			ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

            // skip node if not an ELEMENT
			if (dnt == NODE_ELEMENT)
				{
                // get element name
				CComBSTR bstrName;
				ft.hr = pNode->get_nodeName(&bstrName);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

                // check that element is a copmonent (either DATABASE
				// or FILE_GROUP)
				if (wcscmp(bstrName, x_wszElementDatabase) == 0 ||
					wcscmp(bstrName, x_wszElementFilegroup) == 0)
					{
                    // increment count of components found and determine
                    // it this is the selected component
					i++;
					if (i > iComponent)
						break;
					}
				}

            // position on next element
			if(!m_doc.Next(FALSE, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Component %d was not found",
                    iComponent
					);
            }


		pComponent = new CVssWMComponent((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pComponent == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot allocate CVssWMComponent due to allocation failure."
				);

        // 2nd phase of initialization
        pComponent->Initialize(ft);

		// move pointer to output parameter
        *ppComponent = (IVssWMComponent *) pComponent;

		// set reference count to 1.
        ((IVssWMComponent *) pComponent)->AddRef();
		pComponent = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pComponent;

	return ft.hr;
	}


// get RESTORE_METHOD element info.  Return S_FALSE if not found
// implements IVssExamineWriterMetadata::GetRestoreMethod
// caller is responsible for calling SysFreeString on pbstrService
// and pbstrUserProcedure
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if there is no restore method
//		E_INVALIDARG if any of the output parameters are NULL.
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetRestoreMethod
	(
	OUT VSS_RESTOREMETHOD_ENUM *pMethod,		// method enumeration
	OUT BSTR *pbstrService,						// service name (valid for VSS_RME_STOP_RESTORE_RESTART
	OUT BSTR *pbstrUserProcedure,				// URL/URI to a user procedure to be performed manually
	OUT VSS_WRITERRESTORE_ENUM *pWriterRestore,	// whether writer particpates in the restore
	OUT bool *pbRebootRequired,					// is a reboot after restore required
    OUT UINT *pcMappings						// # of ALTERNATE_LOCATION_MAPPING elements
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetRestoreMethod"
		);

	try
		{

        // initialize output parameters
		if (pWriterRestore)
			*pWriterRestore = VSS_WRE_UNDEFINED;

		if (pbRebootRequired)
			*pbRebootRequired = false;

		VssZeroOut(pbstrUserProcedure);
		VssZeroOut(pbstrService);
        VssZeroOut(pcMappings);

        // check output parameters
		if (pMethod == NULL ||
			pbstrService == NULL ||
			pbstrUserProcedure == NULL ||
			pWriterRestore == NULL ||
			pbRebootRequired == NULL ||
            pcMappings == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*pMethod = VSS_RME_UNDEFINED;


		VSS_RESTOREMETHOD_ENUM method;
		VSS_WRITERRESTORE_ENUM writerRestore;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		unsigned cMappings = 0;
		bool bRebootRequired;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition at top of the document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element, return S_FALSE if not found
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.hr = S_FALSE;
		else
			{
			// get "method" attribute
			CComBSTR bstrVal = NULL;
			if (!m_doc.FindAttribute(x_wszAttrMethod, &bstrVal))
				MissingAttribute(ft, x_wszAttrMethod);

			// convert string to VSS_RESTOREMETHOD_ENUM
			method = ConvertToRestoreMethod(ft, bstrVal);
			bstrVal.Empty();

			// extract service attribute value
			get_stringValue(x_wszAttrService, &bstrService);

			// extract userProcedure attribute value
			get_stringValue(x_wszAttrUserProcedure, &bstrUserProcedure);

			// extract writerRestore attribute value as a string
			get_stringValue(x_wszAttrWriterRestore, &bstrVal);

			// convert string to VSS_WRITERRESTORE_ENUM
			writerRestore = ConvertToWriterRestore(ft, bstrVal);

			// extract rebootRequired attribute
			get_boolValue(ft, x_wszAttrRebootRequired, &bRebootRequired);

			// get first ALTERNATE_LOCATION_MAPPING elemnent
			if (m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
				{
				// count number of elements
				do
					{
					// increment count of mappings
					cMappings += 1;
					} while(m_doc.FindElement(x_wszElementAlternateMapping, FALSE));
                }

			// assign output parameters
			*pMethod = method;
			*pWriterRestore = writerRestore;
			*pbstrUserProcedure = bstrUserProcedure.Detach();
			*pbstrService = bstrService.Detach();
			*pcMappings = cMappings;
			*pbRebootRequired = bRebootRequired;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get a specific alternative location mapping
// implements IVssExamineWriterMetadata::GetAlternateLocationMapping
// caller is responsible for calling IVssWMFiledesc::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified alternate location mapping
//			is not found.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetAlternateLocationMapping
	(
	IN UINT iMapping,					// which mapping to extract
	OUT IVssWMFiledesc **ppFiledesc		// file descriptor for mapping
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::GetAlternateLocationMapping"
		);

	CVssWMFiledesc *pFiledesc = NULL;

    try
		{
        // check output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // set output parameter to NULL
		*ppFiledesc = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find RESTORE_METHOD element"
				);

        // find first ALTERNATIVE_LOCATION_MAPPING element
        if (!m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find ALTERNATE_LOCATION_MAPPING element"
				);

        // search for selected element
		for(UINT i = 0; i < iMapping; i++)
			{
			if (!m_doc.FindElement(x_wszElementAlternateMapping, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find ALTERNATE_LOCATION_MAPPING element"
					);
            }

		// obtain current node
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

        // return mapping as a CVssWMFiledesc
		pFiledesc = new CVssWMFiledesc((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssAlternateLocationMapping due to allocation failure."
				);

		// call 2nd phase of construction
		pFiledesc->Initialize(ft);

		// transfer pointer to output parameter
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
        ((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

STDMETHODIMP CVssExamineWriterMetadata::GetBackupSchema
    (
    OUT DWORD *pdwSchemaMask
    )
    {
	UNREFERENCED_PARAMETER(pdwSchemaMask);
    return E_NOTIMPL;
    }

// obtain the XML document itself
// implements IVssExamineWriterMetadata::GetDocument
// caller is responsible for calling IXMLDOMDocument::Release on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALDARG if ppDoc is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::GetDocument(IXMLDOMDocument **ppDoc)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssExamineWriterMetadata::GetDocument");

	try
		{
		// validate output parameter
		if (ppDoc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// set output parameter
		*ppDoc = m_doc.GetInterface();

		BS_ASSERT(*ppDoc);

		// increment reference count on output parameter
		m_doc.GetInterface()->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// save writer metadata as XML string
// implements IVssExamineWriterMetadata::SaveAsXML
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::SaveAsXML"
		);

    try
		{
        // validate output parametr
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // set output parameter to NULL
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

		// construct XML string
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// load document from XLM string
// implements IVssExamineWriterMetadata::LoadFromXML
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the document failed to load.
//		E_INVALIDARG if bstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssExamineWriterMetadata::LoadFromXML(BSTR bstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssExamineWriterMetadata::LoadFromXML"
		);

    try
		{
		if (bstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Required input parameter is NULL.");

		CVssSafeAutomaticLock lock(m_csDOM);
		bool f = LoadDocument(bstrXML);

		ft.hr = f ? S_OK : S_FALSE;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// IUnknown::QueryInterface
STDMETHODIMP CVssExamineWriterMetadata::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssExamineWriterMetadata::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssExamineWriterMetadata::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}



// return basic information about the component
// implements IVssWMComponent::GetComponentInfo
// caller must call IVssWMComponent::FreeComponentInfo on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppInfo is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetComponentInfo(PVSSCOMPONENTINFO *ppInfo)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetComponentInfo"
		);

	// constructed component info
    VSS_COMPONENTINFO *pInfo = NULL;

    try
		{
        // validate output parameter
		if (ppInfo == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // set output parameter to NULL
        *ppInfo = NULL;

        // allocate structure
		pInfo = (VSS_COMPONENTINFO *) CoTaskMemAlloc(sizeof(VSS_COMPONENTINFO));

        // check for allocation failure
		if (pInfo == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Failed to create VSS_COMPONENTINFO"
				);

        // initialize structure
        memset(pInfo, 0, sizeof(*pInfo));

		CVssSafeAutomaticLock lock(m_csDOM);

        // obtain current node
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

        // get node name
		CComBSTR bstrName = NULL;
		ft.hr = pNode->get_nodeName(&bstrName);
		ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

        // convert string to VSS_COMPONENT_TYPE
        pInfo->type = ConvertToComponentType(ft, bstrName, false);

        // obtain logical path
		get_stringValue(x_wszAttrLogicalPath, &pInfo->bstrLogicalPath);

        // obtain component name
        get_stringValue(x_wszAttrComponentName, &pInfo->bstrComponentName);

        // obtain component description
		get_stringValue(x_wszAttrCaption, &pInfo->bstrCaption);

		CComBSTR bstrIcon;
		if (get_stringValue(x_wszAttrIcon, &bstrIcon))
			{
			Base64Coder coder;
			coder.Decode(bstrIcon);
			UINT cbIcon;
			BYTE *pbIcon = coder.DecodedMessage();
			cbIcon = *(UINT *) pbIcon;
			pInfo->pbIcon = (BYTE *) CoTaskMemAlloc(cbIcon);
			if (pInfo->pbIcon == NULL)
				ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate pbIcon.");

			pInfo->cbIcon = cbIcon;
			memcpy(pInfo->pbIcon, pbIcon + sizeof(UINT), cbIcon);
			}

        // get boolean restoreMetadata attribute value
		get_boolValue(ft, x_wszAttrRestoreMetadata, &pInfo->bRestoreMetadata);

		// get boolean notifyOnBackupComplete attribute value
		get_boolValue(ft, x_wszAttrNotifyOnBackupComplete, &pInfo->bNotifyOnBackupComplete);

		// get boolean selectable attribute value
		get_boolValue(ft, x_wszAttrSelectable, &pInfo->bSelectable);

        // count subElements DATABASE_FILES, DATABASE_LOGFILES, and FILE_LIST

        // descend to first child element

		CXMLDocument doc(m_doc.GetCurrentNode(), m_doc.GetInterface());
		if (doc.Next(TRUE, FALSE))
			{
			do
				{
                // get current node
				CComPtr<IXMLDOMNode> pNode = doc.GetCurrentNode();
				DOMNodeType dnt;

                // determine node type
				ft.hr = pNode->get_nodeType(&dnt);
				ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeType");

                // skip node if not an element
				if (dnt == NODE_ELEMENT)
					{
					CComBSTR bstrName = NULL;

					ft.hr = pNode->get_nodeName(&bstrName);
					ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::get_nodeName");

                    // update counters based on element type
					if(wcscmp(bstrName, x_wszElementDatabaseFiles) == 0)
						pInfo->cDatabases += 1;
					else if (wcscmp(bstrName, x_wszElementDatabaseLogfiles) == 0)
						pInfo->cLogFiles += 1;
					else if (wcscmp(bstrName, x_wszElementFilelist) == 0)
						pInfo->cFileCount += 1;
					}
				} while (doc.Next(FALSE, FALSE));
            }

        // set output parameter
		*ppInfo = pInfo;
		}
	VSS_STANDARD_CATCH(ft);

    // free structure if there is any failure
	if (FAILED(ft.hr) && pInfo != NULL)
		FreeComponentInfo(pInfo);

	return ft.hr;
	}

// free up component info structure
// implements IVssWMComponent::FreeComponentInfo
// frees information returned by IVssWMComponent::GetComponentInfo
//
// Returns:
//		S_OK if the operation is successful

STDMETHODIMP CVssWMComponent::FreeComponentInfo(PVSSCOMPONENTINFO pInfoC)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWMComponent::FreeComponentInfo");

	VSS_COMPONENTINFO *pInfo = (VSS_COMPONENTINFO *) pInfoC;

	if (pInfo != NULL)
		{
		try
			{
			if (pInfo->bstrLogicalPath)
				{
				SysFreeString(pInfo->bstrLogicalPath);
				pInfo->bstrLogicalPath = NULL;
				}

			if (pInfo->bstrComponentName)
				{
				SysFreeString(pInfo->bstrComponentName);
				pInfo->bstrComponentName = NULL;
				}

			if (pInfo->bstrCaption)
				{
				SysFreeString(pInfo->bstrCaption);
				pInfo->bstrCaption = NULL;
				}

			if (pInfo->pbIcon)
				{
				CoTaskMemFree(pInfo->pbIcon);
				pInfo->pbIcon = NULL;
				}

			CoTaskMemFree(pInfo);
			}
		VSS_STANDARD_CATCH(ft)
		}

	return ft.hr;
	}

// obtain a FILE_LIST element
// implements IVssWMComponent::GetFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetFile
	(
	IN UINT iFile,						// selected file in file group
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetFile"
		);

	return GetComponentFile(ft, x_wszElementFilelist, iFile, ppFiledesc);
	}

// obtain a DATABASE_FILES element
// implements IVssWMComponent::GetDatabaseFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetDatabaseFile
	(
	IN UINT iDBFile,					// selected DATABASE_FILE element in DATABASE
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetDatabaseFile"
		);

	return GetComponentFile(ft, x_wszElementDatabaseFiles, iDBFile, ppFiledesc);
	}

// obtain a DATABASE_LOGFILES element
// implements IVssWMComponent::GetDatabaseLogFile
// caller must call IVssWMFiledesc::Release on the output parameter.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL.
//		VSS_E_OBJECT_NOT_FOUND if specified log file is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMComponent::GetDatabaseLogFile
	(
	IN UINT iDbLogFile,					// selected DATABASE_LOG_FILE element in DATABASE
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMComponent::GetDatabaseLogFile"
		);

	return GetComponentFile(ft, x_wszElementDatabaseLogfiles, iDbLogFile, ppFiledesc);
	}

STDMETHODIMP CVssWMComponent::GetDependency
        (
        IN UINT iDependency,
        OUT IVssWMDependency **ppDependency
        )
{
    UNREFERENCED_PARAMETER(iDependency);
    UNREFERENCED_PARAMETER(ppDependency);

    return E_NOTIMPL;
}

// obtain a DATABASE_FILES, DATABASE_LOGFILES or FILE_LIST element
// internal function used by GetDatabaseFile, GetDatabaseLogFile, and GetFile
HRESULT CVssWMComponent::GetComponentFile
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElementName,			// element to retrieve DATABASE_FILE, DATABASE_LOG_FILE, or FILE_LIST
	IN UINT iFile,						// which element to retrieve
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{

	CVssWMFiledesc *pFiledesc = NULL;

	try
		{
        // validate output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

        // initialize output parameter
		*ppFiledesc = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of component
		m_doc.ResetToDocument();

        // find first child element
		if (!m_doc.FindElement(wszElementName, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find %s element",
				wszElementName
				);

        // skip to selected element
        for(UINT i = 0; i < iFile; i++)
			{
			if (!m_doc.FindElement(wszElementName, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find element %s.",
					wszElementName
					);
            }

        // get selected element
		CComPtr<IXMLDOMNode> pNode = m_doc.GetCurrentNode();

	
        // create CVssWMFiledesc from selected element
		pFiledesc = new CVssWMFiledesc((IXMLDOMNode *) pNode);

        // check for allocation failure
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssWMFiledesc due to allocation failure."
				);

		// 2nd phase of construction
		pFiledesc->Initialize(ft);

		// transfer pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		// set reference count to 1
        ((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

	return ft.hr;
	}

// IUnknown::QueryInterface
STDMETHODIMP CVssWMComponent::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWMComponent::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssWMComponent::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);
	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return cRef;
	}


// obtain path attribute
// implements IVssWMFiledesc::GetPath
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetPath(OUT BSTR *pbstrPath)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetPath"
		);

    CVssSafeAutomaticLock lock(m_csDOM);
    return GetStringAttributeValue(ft, x_wszAttrPath, false, pbstrPath);
	}

// obtain filespec attribute
// implements IVssWMFiledesc::GetFilespec
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrFilespec is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetFilespec(OUT BSTR *pbstrFilespec)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetFilespec"
		);

    CVssSafeAutomaticLock lock(m_csDOM);
    return GetStringAttributeValue(ft, x_wszAttrFilespec, true, pbstrFilespec);
	}

// obtain recursive attribute
// implements IVssWMFiledesc::GetRecursive
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbRecursive is NULL
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetRecursive(OUT bool *pbRecursive)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetRecursive"
		);

    CVssSafeAutomaticLock lock(m_csDOM);
    return GetBooleanAttributeValue(ft, x_wszAttrRecursive, false, pbRecursive);
	}

// obtain alternatePath attribute
// implements IVssWMFiledesc::GetAlternateLocation
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrAlternateLocation is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWMFiledesc::GetAlternateLocation(OUT BSTR *pbstrAlternateLocation)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWMFiledesc::GetAlternateLocation"
		);


    CVssSafeAutomaticLock lock(m_csDOM);
	return GetStringAttributeValue(ft, x_wszAttrAlternatePath, false, pbstrAlternateLocation);
      }

STDMETHODIMP CVssWMFiledesc::GetBackupTypeMask(OUT DWORD *pdwSchemaMask)
{
    UNREFERENCED_PARAMETER(pdwSchemaMask);

    return E_NOTIMPL;
}

// IUnknown::QueryInterface
STDMETHODIMP CVssWMFiledesc::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWMFiledesc::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release
STDMETHODIMP_(ULONG) CVssWMFiledesc::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}


// initialize the document by creating a toplevel WRITER_METADATA and
// child IDENTIFICATION element
// implemetns IVssCreateWriterMetadata::Initialize
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if usage or source are invalid or if wszFriendlyName is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

HRESULT CVssCreateWriterMetadata::Initialize
	(
	IN VSS_ID idInstance,				// GUID of instance
	IN VSS_ID idWriter,					// GUID of writer class
	IN LPCWSTR wszFriendlyName,			// friendly name of writer
	IN VSS_USAGE_TYPE usage,			// usage attribute
	IN VSS_SOURCE_TYPE source			// source attribute
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::Initialize"
		);

    try
		{
		LPCWSTR wszUsage;
		LPCWSTR wszSource;

        // validate input argument
		if (wszFriendlyName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL string input parameter");

        wszUsage = WszFromUsageType(ft, usage);
        wszSource = WszFromSourceType(ft, source);
		CXMLDocument doc;

		InitializeHelper(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.Initialize();
		CXMLNode nodeDoc(m_doc.GetInterface(), m_doc.GetInterface());

        // create toplevel WRITER_METADATA node
		CXMLNode nodeTop = m_doc.CreateNode
							(
							x_wszElementWriterMetadata,
							NODE_ELEMENT
							);

		// setup schema attribute
		nodeTop.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);

        // setup version attribute
		nodeTop.SetAttribute(x_wszAttrVersion, x_wszVersionNo);

        // create IDENTIFICATION node
		CXMLNode nodeId = m_doc.CreateNode
							(
							x_wszElementIdentification,
							NODE_ELEMENT
							);

        // set writerId attribute
		nodeId.SetAttribute(x_wszAttrWriterId, idWriter);

        // set instanceId attribue
		nodeId.SetAttribute(x_wszAttrInstanceId, idInstance);

        // set friendlyName attribute
		nodeId.SetAttribute(x_wszAttrFriendlyName, wszFriendlyName);

        // set usage attribute
		nodeId.SetAttribute(x_wszAttrUsage, wszUsage);

        // set dataSource attribute
		nodeId.SetAttribute(x_wszAttrDataSource, wszSource);

		// insert identification node in toplevel node
		nodeTop.InsertNode(nodeId);

		// insert toplevel node in document and set it as
		// the toplevel node for navigation purposes
		CXMLNode nodeToplevel = nodeDoc.InsertNode(nodeTop);
        m_doc.SetToplevelNode(nodeToplevel);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add an INCLUDE_FILES element
// implements IVssCreateWriterMetadata::AddIncludeFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszPath or wszFilespec is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddIncludeFiles
	(
	IN LPCWSTR wszPath,						// path to root directory
	IN LPCWSTR wszFilespec,					// file specification
	IN bool bRecursive,						// is entire subtree or just directory included
	IN LPCWSTR wszAlternateLocation			// alternate location
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddIncludeFiles"
		);

    try
		{
        // validate input parameters
		if (wszPath == NULL || wszFilespec == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		CVssSafeAutomaticLock lock(m_csDOM);

        // create/obtain BACKUP_LOCATIONS element
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();

        // create child INCLUDE_FILES element
		CXMLNode nodeInclude = m_doc.CreateNode
								(
								x_wszElementIncludeFiles,
								NODE_ELEMENT
								);

        // set path attribute
		nodeInclude.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
		nodeInclude.SetAttribute(x_wszAttrFilespec, wszFilespec);

		// set recursive attribute
		nodeInclude.SetAttribute
			(
			x_wszAttrRecursive,
			WszFromBoolean(bRecursive)
			);

        // set alternatePath attribute if specified
		if (wszAlternateLocation)
			nodeInclude.SetAttribute(x_wszAttrAlternatePath, wszAlternateLocation);

		// insert INCLUDE_FILES node in BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(nodeInclude);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add an EXCLUDE_FILES element
// implements IVssCreateWriterMetadata::AddExcludeFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszPath or wszFilespec is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddExcludeFiles
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilespec,
	IN bool bRecursive
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddExcludeFiles"
		);

    try
		{
        // validate input parameters
		if (wszPath == NULL || wszFilespec == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");


		CVssSafeAutomaticLock lock(m_csDOM);

        // create/obtain the BACKUP_LOCATIONS eleement
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();

        // add an EXCLUDE_FILES element
		CXMLNode nodeExclude = m_doc.CreateNode
								(
								x_wszElementExcludeFiles,
								NODE_ELEMENT
								);

		// set path attribute
		nodeExclude.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
		nodeExclude.SetAttribute(x_wszAttrFilespec, wszFilespec);

		// set recursive attribute
		nodeExclude.SetAttribute
			(
			x_wszAttrRecursive,
			WszFromBoolean(bRecursive)
			);

		// insert EXCLUDE_FILES node in BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(nodeExclude);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// internal routine to find or create the BACKUP_LOCATIONS element
// caller should have helper DOM locked
CXMLNode CVssCreateWriterMetadata::GetBackupLocationsNode()
	{
    // reposition to top of document
	m_doc.ResetToDocument();

	CXMLNode nodeTop(m_doc.GetCurrentNode(), NULL);

    // find BACKUP_LOCATIONS element.  If it exists return it
	if (m_doc.FindElement(x_wszElementBackupLocations, TRUE))
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

    // create BACKUP_LOCATIONS element under WRITER_METADATA element
	CXMLNode node = m_doc.CreateNode
						(
						x_wszElementBackupLocations,
						NODE_ELEMENT
						);

	return nodeTop.InsertNode(node);
	}

// create a component
// implements IVssCreateWriterMetadata::AddComponent
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszComponentName is NULL or the specified component type is invalid.
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddComponent
	(
	IN VSS_COMPONENT_TYPE ct,			// either VSS_CT_DATABASE or VSS_CT_FILEGROUP
	IN LPCWSTR wszLogicalPath,			// logical path to component
	IN LPCWSTR wszComponentName,		// component name
	IN LPCWSTR wszCaption,				// description of component
	IN const BYTE * pbIcon,				// icon
	IN UINT cbIcon,						// size of icon
	IN bool bRestoreMetadata,			// is restore metadata supplied
	IN bool bNotifyOnBackupComplete,	// does writer expect to be notified on BackupComplete
	IN bool bSelectable,					// is component selectable
    IN bool bSelectableForRestore,
    IN DWORD dwComponentFlags
	)
	{
	UNREFERENCED_PARAMETER(bSelectableForRestore);
       UNREFERENCED_PARAMETER(dwComponentFlags);
     
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddComponent"
		);

    try
		{
        // validate required input parameter
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

        // determine element name from the component type
		LPCWSTR wszElement;
        wszElement = WszFromComponentType(ft, ct, false);

		CVssSafeAutomaticLock lock(m_csDOM);

        // obtain BACKUP_LOCATIONS node, creating it if necessary.
		CXMLNode nodeBackupLocations = GetBackupLocationsNode();
        CXMLDocument doc(nodeBackupLocations);

		// find element type (either DATABASE or FILE_GROUP)
        if (doc.FindElement(wszElement, TRUE))
            {
            do
                {
                CComBSTR bstrLogicalPath;
				CComBSTR bstrComponentName;

				// extract logicalPath attribute
                bool bLogicalPath = doc.FindAttribute(x_wszAttrLogicalPath, &bstrLogicalPath);

				// extract componentName attribute
                if (!doc.FindAttribute(x_wszAttrComponentName, &bstrComponentName))
					MissingAttribute(ft, x_wszAttrComponentName);

                // if duplicate comonent is found then throw an error
                if (wcscmp(wszComponentName, bstrComponentName) == 0 &&
                    ((bLogicalPath &&
                      wszLogicalPath &&
                      wcscmp(wszLogicalPath, bstrLogicalPath) == 0) ||
                     (!bstrLogicalPath &&
                      (wszLogicalPath == NULL || wcslen(wszLogicalPath) == 0))))
                    ft.Throw
                        (
                        VSSDBG_XML,
						VSS_E_OBJECT_ALREADY_EXISTS,
                        L"Component %s already exists",
                        wszComponentName
                        );
                } while(doc.FindElement(wszElement, FALSE));
            }


        // create component node
		CXMLNode node = m_doc.CreateNode
								(
								wszElement,
								NODE_ELEMENT
								);


        // set logicalPath attribute if exists
        if (wszLogicalPath)
			node.SetAttribute(x_wszAttrLogicalPath, wszLogicalPath);

        // set componetName attribute
		node.SetAttribute(x_wszAttrComponentName, wszComponentName);

        // set caption element if it exists
		if (wszCaption)
			node.SetAttribute(x_wszAttrCaption, wszCaption);

        // set icon attribute if it exists
		if (pbIcon != NULL && cbIcon > 0)
			{
			Base64Coder coder;
			coder.Encode(pbIcon, cbIcon);
			node.SetAttribute(x_wszAttrIcon, coder.EncodedMessage());
			}

        // set restoreMetadata flags
		node.SetAttribute
			(
			x_wszAttrRestoreMetadata,
			WszFromBoolean(bRestoreMetadata)
			);


        // set notifyOnBackupComplete flag
		node.SetAttribute
			(
			x_wszAttrNotifyOnBackupComplete,
			WszFromBoolean(bNotifyOnBackupComplete)
			);

        // set selectable attribute
		node.SetAttribute
			(
			x_wszAttrSelectable,
			WszFromBoolean(bSelectable)
			);

		// insert component node under BACKUP_LOCATIONS node
		nodeBackupLocations.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// create DATABASE_FILES element
// implements IVssCreateWriterMetadata::AddDatabaseFile
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszDatabaseName, wszPath, or wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddDatabaseFiles
	(
	IN LPCWSTR wszLogicalPath,			// logical path name of component
	IN LPCWSTR wszDatabaseName,			// add database name
	IN LPCWSTR wszPath,					// add path name
	IN LPCWSTR wszFilespec,				// add file specification
	IN DWORD dwBackupTypeMask
	)
	{
	UNREFERENCED_PARAMETER(dwBackupTypeMask);
    
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddDatabaseFiles"
		);

    // call internal routine to do the work
	return CreateComponentFiles
			(
			ft,
			x_wszElementDatabase,
			wszLogicalPath,
			wszDatabaseName,
			x_wszElementDatabaseFiles,
			wszPath,
			wszFilespec,
			false,
			NULL
			);
	}


// create a DATABASE_FILES, DATABASE_LOGFILES or FILE_LIST element under
// a component
// internal routine used by AddDatabaseFiles, AddFiles, and AddDatabaseLogFiles
HRESULT CVssCreateWriterMetadata::CreateComponentFiles
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElement,			// element name (DATABASE or FILE_GROUP)
	IN LPCWSTR wszLogicalPath,		// logical path of component
	IN LPCWSTR wszComponentName,	// component name	
	IN LPCWSTR wszElementFile,		// element name (DATABASE_FILES, DATABASE_LOGFILES, FILELIST)
	IN LPCWSTR wszPath,				// path to root directory containing files
	IN LPCWSTR wszFilespec,			// file specification
	IN bool bRecursive,				// include subtree or just root directory
	IN LPCWSTR wszAlternateLocation	// alternate location for files
	)
	{
    try
        {
		// validate input parameters
        if (wszElement == NULL ||
            wszComponentName == NULL ||
            wszPath == NULL ||
            wszElementFile == NULL ||
            wszFilespec == NULL)
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");


		// validate element consistency
        if ((wcscmp(wszElement, x_wszElementDatabase) == 0 &&
             wcscmp(wszElementFile, x_wszElementDatabaseFiles) != 0 &&
             wcscmp(wszElementFile, x_wszElementDatabaseLogfiles) != 0) ||
            (wcscmp(wszElement, x_wszElementFilegroup) == 0 &&
             wcscmp(wszElementFile, x_wszElementFilelist) != 0))
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid element type");

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
        m_doc.ResetToDocument();

        // find BACKUP_LOCATIONS element
        if (!m_doc.FindElement(x_wszElementBackupLocations, TRUE))
			ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"BackupLocations element is missing"
                );

        // find first component of the right type
        if (!m_doc.FindElement(wszElement, TRUE))
            ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"Component %s::%s was not created",
                wszElement,
                wszComponentName
                );

        // look for matching component
        bool bFound = false;
        do
            {
            CComBSTR bstrLogicalPath;
            CComBSTR bstrComponentName;

			// extract logical path
            bool fLogicalPath = m_doc.FindAttribute(x_wszAttrLogicalPath, &bstrLogicalPath);

			// extract component name
            if (!m_doc.FindAttribute(x_wszAttrComponentName, &bstrComponentName))
				MissingAttribute(ft, x_wszAttrComponentName);

            // compare logical path if it exists
            if (wszLogicalPath != NULL && fLogicalPath)
                {
				// compare logical path
                if (wcscmp(wszLogicalPath, bstrLogicalPath) != 0)
                    continue;
                }
            else if (wszLogicalPath == NULL &&
                     fLogicalPath &&
                     wcslen(bstrLogicalPath) > 0)
                // logical path in document but component we are searching
				// for has no logical path, skip this one
			    continue;
            else if (wszLogicalPath != NULL && wcslen(wszLogicalPath) > 0)
				// logical path we are searching for is specified but
				// there is no logical path in the document
                continue;

            // if component name matches then we found target component,
			// otherwise move to next component
            if (wcscmp(bstrComponentName, wszComponentName) == 0)
                {
                bFound = true;
                break;
                }
            } while(m_doc.FindElement(wszElement, FALSE));

        // return error if component is not found
        if (!bFound)
            ft.Throw
			    (
                VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
                L"Component %s::%s was not created",
                wszElement,
                wszComponentName
                );


        // use component node as parent node
        CXMLNode nodeComponent(m_doc.GetCurrentNode(), m_doc.GetInterface());

        // create child node of the component
        CXMLNode node = m_doc.CreateNode
						(
						wszElementFile,
						NODE_ELEMENT
						);

        // set path attribute
        node.SetAttribute(x_wszAttrPath, wszPath);

		// set filespec attribute
        node.SetAttribute(x_wszAttrFilespec, wszFilespec);
		
		// set recursive attribute if it is Yes
		if (bRecursive)
			node.SetAttribute
				(
				x_wszAttrRecursive,
				WszFromBoolean(bRecursive)
				);

        if (wszAlternateLocation)
			node.SetAttribute(x_wszAttrAlternatePath, wszAlternateLocation);

		// insert file element under component node
		nodeComponent.InsertNode(node);
        }	
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// add a log file specification to a database component
// implements IVssCreateWriterMetadata::AddDatabaseLogFiles
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszDatabaseName is NULL, wszPath is NULL, or wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddDatabaseLogFiles
	(
	IN LPCWSTR wszLogicalPath,			// logical path of database
	IN LPCWSTR wszDatabaseName,			// database name
	IN LPCWSTR wszPath,					// path to directory containing log files
	IN LPCWSTR wszFilespec,				// file specification of log files
        IN DWORD dwBackupTypeMask
	)
	{
	UNREFERENCED_PARAMETER(dwBackupTypeMask);
    
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddDatabaseLogFiles"
		);

    // call internal routine to do the work
    return CreateComponentFiles
			(
			ft,
			x_wszElementDatabase,
			wszLogicalPath,
			wszDatabaseName,
			x_wszElementDatabaseLogfiles,
			wszPath,
			wszFilespec,
			false,
			NULL
			);
	}


// add files to a file group
// implements IVssCreateWriterMetadata::AddFilesToFileGroup
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszGroupName is NULL, wszPath is NULL, wszFilespec is NULL.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is cortup.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddFilesToFileGroup
	(
	IN LPCWSTR wszLogicalPath,		// logical path of file group
	IN LPCWSTR wszGroupName,		// group name	
	IN LPCWSTR wszPath,				// path to root directory containing the files
	IN LPCWSTR wszFilespec,			// file specification of the files included in the file group
	IN bool bRecursive,				// are files in the subtree included or just in the directory
	IN LPCWSTR wszAlternateLocation,// alternate location for files in the file group
        IN DWORD dwBackupTypeMask
	)
	{
	UNREFERENCED_PARAMETER(dwBackupTypeMask);
    
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddFilesToFileGroup"
		);

    // call internal routine to do the work
	return CreateComponentFiles
			(
			ft,
			x_wszElementFilegroup,
			wszLogicalPath,
			wszGroupName,
			x_wszElementFilelist,
			wszPath,
			wszFilespec,
			bRecursive,
			wszAlternateLocation
			);
	}

// create restore method
// implements IVssCreateWriterMetadata::SetRestoreMethod
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if method is invalid, writerRestore is invalid,
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::SetRestoreMethod
	(
	IN VSS_RESTOREMETHOD_ENUM method,		// method
	IN LPCWSTR wszService,					// service name, if method is VSS_RME_STOP_RESTORE_RESTART
	IN LPCWSTR wszUserProcedure,			// uri/url of manual instructions for user to follow to do the restore
	IN VSS_WRITERRESTORE_ENUM writerRestore, // is writer involved in the restore process
	IN bool bRebootRequired
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::SetRestoreMethod"
		);

    try
		{
		// convert VSS_RESTORMETHOD_ENUM to string
		// validate it as well
		LPCWSTR wszMethod = WszFromRestoreMethod(ft, method);

		// convert VSS_WRITERRESTORE_ENUM to string
		// validate it as well
		LPCWSTR wszWriterRestore = WszFromWriterRestore(ft, writerRestore);

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
        m_doc.ResetToDocument();

		// set parent node as WRITER_METADATA node
		CXMLNode nodeTop(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// if RESTORE_METHOD element exists, then return an error
		if (m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_ALREADY_EXISTS,
				L"RESTORE_METHOD element already exists."
				);

        // create RESTORE_METHOD node as child of WRITER_METADATA node
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementRestoreMethod,
							NODE_ELEMENT
							);

        // set method attribute
        node.SetAttribute(x_wszAttrMethod, wszMethod);

		// set service attribute if supplied
		if (wszService)
			node.SetAttribute(x_wszAttrService, wszService);

		// set userProcedure attribute if supplied
		if (wszUserProcedure)
			node.SetAttribute(x_wszAttrUserProcedure, wszUserProcedure);

		// set writerRestore attribute
		node.SetAttribute(x_wszAttrWriterRestore, wszWriterRestore);

		// set rebootRequired attribute
		node.SetAttribute(x_wszAttrRebootRequired, WszFromBoolean(bRebootRequired));

		// insert RESTORE_METHOD node under toplevel node
		nodeTop.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add alternate location mapping
// implements IVssCreateWriterMetadata::AddAlternateLocationMapping
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszSourcePath, wszSourceFiledesc, or wszDestination is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::AddAlternateLocationMapping
	(
	IN LPCWSTR wszSourcePath,			// path to source root directory
	IN LPCWSTR wszSourceFilespec,		// file specification
	IN bool bRecursive,					// are files in the subtree relocated or just files in the directory	
	IN LPCWSTR wszDestination			// new location of root directory
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::AddAlternateLocationMapping"
		);
    try
        {
        // validate input parameters
		if (wszSourcePath == NULL ||
			wszSourceFilespec == NULL ||
			wszDestination == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		CVssSafeAutomaticLock lock(m_csDOM);

        // reposition to top of document
		m_doc.ResetToDocument();

        // find RESTORE_METHOD element
		if (!m_doc.FindElement(x_wszElementRestoreMethod, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"RESTORE_METHOD element is not defined."
				);

        // set parent node as RESTORE_METHOD element
        CXMLNode nodeRM(m_doc.GetCurrentNode(), m_doc.GetInterface());

        // create ALTERNATE_LOCATION_MAPPING element to
		// RESTORE_METHOD element
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementAlternateMapping,
							NODE_ELEMENT
							);

		// set path attribute					
        node.SetAttribute(x_wszAttrPath, wszSourcePath);

		// add filespec attributte
		node.SetAttribute(x_wszAttrFilespec, wszSourceFilespec);

		// set alternatePath attribute
		node.SetAttribute(x_wszAttrAlternatePath, wszDestination);

		// set recursive attribute
		node.SetAttribute(x_wszAttrRecursive, WszFromBoolean(bRecursive));

		// insert ALTERNATE_LOCATION_MAPPING node under RESTORE_METHOD node
		nodeRM.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

STDMETHODIMP CVssCreateWriterMetadata::AddComponentDependency
            (
            IN LPCWSTR wszForLogicalPath,
            IN LPCWSTR wszForComponentName,
            IN VSS_ID   onWriterId,
            IN LPCWSTR wszOnLogicalPath,
            IN LPCWSTR wszOnComponentName
            )
{
    UNREFERENCED_PARAMETER(wszForLogicalPath);
    UNREFERENCED_PARAMETER(wszForComponentName);
    UNREFERENCED_PARAMETER(onWriterId);
    UNREFERENCED_PARAMETER(wszOnLogicalPath);
    UNREFERENCED_PARAMETER(wszOnComponentName);

    return E_NOTIMPL;
}

STDMETHODIMP CVssCreateWriterMetadata::SetBackupSchema
            (
            IN DWORD dwSchemaMask
            )
{
    UNREFERENCED_PARAMETER(dwSchemaMask);
    return E_NOTIMPL;
}

// obtain the XML document itself
// implements IVssCreateWriterMetadata::GetDocument
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppDoc is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::GetDocument(IXMLDOMDocument **ppDoc)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssCreateWriterMetadata::GetDocument");

	try
		{
		// validate output parameter
		if (ppDoc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// get IXMLDOMDocument interface
		*ppDoc = m_doc.GetInterface();

		// increment reference count on interface
		m_doc.GetInterface()->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// save WRITER_METADATA document as XML string
// implements IVssCreateWriterMetadata::SaveAsXML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssCreateWriterMetadata::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssCreateWriterMetadata::SaveAsXML"
		);

    try
		{
        // validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

        // initialize output paramter
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);

		// construct string from document
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft);

	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\helper.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vs_wmxml.cxx

Abstract:

    Implementation of CVssMetadataHelper class

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb      03/30/2000  Created

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vssmsg.h"


#include "rpcdce.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUEHELPC"
//
////////////////////////////////////////////////////////////////////////

// boolean type string values
static LPCWSTR x_wszYes = L"yes";
static LPCWSTR x_wszNo = L"no";

// usage type string values
static LPCWSTR x_wszBOOTABLESYSTEMSTATE = L"BOOTABLE_SYSTEM_STATE";
static LPCWSTR x_wszSYSTEMSERVICE = L"SYSTEM_SERVICE";
static LPCWSTR x_wszUSERDATA = L"USER_DATA";
static LPCWSTR x_wszOTHER = L"OTHER";

// source type string values
static LPCWSTR x_wszTRANSACTEDDB = L"TRANSACTION_DB";
static LPCWSTR x_wszNONTRANSACTEDDB = L"NONTRANSACTIONAL_DB";

// component ELEMENT type strings
static LPCWSTR x_wszElementDatabase = L"DATABASE";
static LPCWSTR x_wszElementFilegroup = L"FILE_GROUP";

// component value type strings
static LPCWSTR x_wszValueDatabase = L"database";
static LPCWSTR x_wszValueFilegroup = L"filegroup";

// writerRestore value type strings
static LPCWSTR x_wszNever = L"never";
static LPCWSTR x_wszAlways = L"always";
static LPCWSTR x_wszIfReplaceFails = L"ifReplaceFails";

// string restore methods
static LPCWSTR x_wszRESTOREIFNOTTHERE = L"RESTORE_IF_NONE_THERE";
static LPCWSTR x_wszRESTOREIFCANREPLACE = L"RESTORE_IF_CAN_BE_REPLACED";
static LPCWSTR x_wszSTOPRESTORESTART = L"STOP_RESTART_SERVICE";
static LPCWSTR x_wszRESTORETOALTERNATE = L"RESTORE_TO_ALTERNATE_LOCATION";
static LPCWSTR x_wszRESTOREATREBOOT = L"REPLACE_AT_REBOOT";
static LPCWSTR x_wszCUSTOM = L"CUSTOM";

// string backup types
static LPCWSTR x_wszValueFull = L"full";
static LPCWSTR x_wszValueDifferential = L"differential";
static LPCWSTR x_wszValueIncremental = L"incremental";
static LPCWSTR x_wszValueOther = L"other";




// convert boolean value to "yes" or "no"
LPCWSTR CVssMetadataHelper::WszFromBoolean(IN bool b)
    {
    return b ? x_wszYes : x_wszNo;
    }

// convert from "yes", "no" to a boolean value
bool CVssMetadataHelper::ConvertToBoolean
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	) throw(HRESULT)
	{
	if (wcscmp(bstr, x_wszYes) == 0)
		return true;
	else if (wcscmp(bstr, x_wszNo) == 0)
		return false;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"Value %s is neither yes nor no.",
			bstr
			);

    return false;
	}

// convert a string to a VSS_ID value
void CVssMetadataHelper::ConvertToVSS_ID
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr,
	OUT VSS_ID *pId
	) throw(HRESULT)
	{
	RPC_STATUS status = UuidFromString(bstr, pId);
	if (status != RPC_S_OK)
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"Value %s is not a valid guid.",
			bstr
			);
	}

// convert from VSS_USAGE_TYPE to string value
LPCWSTR CVssMetadataHelper::WszFromUsageType
    (
    IN CVssFunctionTracer &ft,
    IN VSS_USAGE_TYPE usage
    ) throw(HRESULT)
    {
    switch(usage)
        {
        default:
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid usage type");

        case VSS_UT_OTHER:
            return(x_wszOTHER);

        case VSS_UT_BOOTABLESYSTEMSTATE:
            return(x_wszBOOTABLESYSTEMSTATE);

        case VSS_UT_SYSTEMSERVICE:
			return(x_wszSYSTEMSERVICE);

        case VSS_UT_USERDATA:
			return(x_wszUSERDATA);
		}
    }


// convert from string to VSS_USAGE_TYPE
VSS_USAGE_TYPE CVssMetadataHelper::ConvertToUsageType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	) throw(HRESULT)
	{
	if (wcscmp(bstr, x_wszBOOTABLESYSTEMSTATE) == 0)
        return(VSS_UT_BOOTABLESYSTEMSTATE);
	else if (wcscmp(bstr, x_wszSYSTEMSERVICE) == 0)
		return(VSS_UT_SYSTEMSERVICE);
	else if (wcscmp(bstr, x_wszUSERDATA) == 0)
		return(VSS_UT_USERDATA);
	else if (wcscmp(bstr, x_wszOTHER) == 0)
		return(VSS_UT_OTHER);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid usage type",
			bstr
			);

    return VSS_UT_UNDEFINED;
	}

// convert from a VSS_SOURCE_TYPE value to a string
LPCWSTR CVssMetadataHelper::WszFromSourceType
    (
    IN CVssFunctionTracer &ft,
    IN VSS_SOURCE_TYPE source
    ) throw(HRESULT)
    {
	switch(source)
		{
		default:
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid data source type");

		case VSS_ST_OTHER:
			return(x_wszOTHER);

        case VSS_ST_TRANSACTEDDB:
			return(x_wszTRANSACTEDDB);

        case VSS_ST_NONTRANSACTEDDB:
            return(x_wszNONTRANSACTEDDB);
        }
    }

// convert from a string to a VSS_SOURCE_TYPE value
VSS_SOURCE_TYPE CVssMetadataHelper::ConvertToSourceType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszTRANSACTEDDB) == 0)
		return(VSS_ST_TRANSACTEDDB);
	else if (wcscmp(bstr, x_wszNONTRANSACTEDDB) == 0)
		return(VSS_ST_NONTRANSACTEDDB);
	else if (wcscmp(bstr, x_wszOTHER) == 0)
		return(VSS_ST_OTHER);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid source type.",
			bstr
			);

    return VSS_ST_UNDEFINED;
	}


// convert from VSS_COMPONENT_TYPE to string value
LPCWSTR CVssMetadataHelper::WszFromComponentType
    (
    IN CVssFunctionTracer &ft,
    VSS_COMPONENT_TYPE ct,
	bool bValue
    ) throw(HRESULT)
    {
    switch(ct)
        {
        default:
            ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid component type");

        case VSS_CT_DATABASE:
            return (bValue ? x_wszValueDatabase : x_wszElementDatabase);

        case VSS_CT_FILEGROUP:
            return(bValue ? x_wszValueDatabase : x_wszElementFilegroup);
        }
    }

// convert from string value to VSS_COMPONENT_TYPE
VSS_COMPONENT_TYPE CVssMetadataHelper::ConvertToComponentType
    (
    IN CVssFunctionTracer &ft,
    IN BSTR bstrName,
	bool bValue
    )
    {
	LPCWSTR wszDatabase = bValue ? x_wszValueDatabase : x_wszElementDatabase;
	LPCWSTR wszFilegroup = bValue ? x_wszValueFilegroup : x_wszElementFilegroup;
    if (wcscmp(bstrName, wszDatabase) == 0)
        return VSS_CT_DATABASE;
    else if (wcscmp(bstrName, wszFilegroup) == 0)
        return VSS_CT_FILEGROUP;
    else
        ft.Throw
            (
            VSSDBG_XML,
            E_INVALIDARG,
            L"The string %s is not a valid component type",
            bstrName
            );

    return VSS_CT_UNDEFINED;
    }


// convert from restore method to string
LPCWSTR CVssMetadataHelper::WszFromRestoreMethod
    (
    IN CVssFunctionTracer &ft,
    IN VSS_RESTOREMETHOD_ENUM method
    )
    {
    switch(method)
        {
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid method type %d",
                method
                );

        case VSS_RME_RESTORE_IF_NOT_THERE:
			return (x_wszRESTOREIFNOTTHERE);

		case VSS_RME_RESTORE_IF_CAN_REPLACE:
            return(x_wszRESTOREIFCANREPLACE);

		case VSS_RME_STOP_RESTORE_START:
            return(x_wszSTOPRESTORESTART);

        case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION:
			return(x_wszRESTORETOALTERNATE);

		case VSS_RME_RESTORE_AT_REBOOT:
            return(x_wszRESTOREATREBOOT);

		case VSS_RME_CUSTOM:
            return(x_wszCUSTOM);
        }
    }


// convert from string to VSS_RESTOREMETHOD_ENUM
VSS_RESTOREMETHOD_ENUM CVssMetadataHelper::ConvertToRestoreMethod
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszRESTOREIFNOTTHERE) == 0)
		return(VSS_RME_RESTORE_IF_NOT_THERE);
	else if (wcscmp(bstr, x_wszRESTOREIFCANREPLACE) == 0)
		return(VSS_RME_RESTORE_IF_CAN_REPLACE);
	else if (wcscmp(bstr, x_wszSTOPRESTORESTART) == 0)
		return(VSS_RME_STOP_RESTORE_START);
	else if (wcscmp(bstr, x_wszRESTORETOALTERNATE) == 0)
		return(VSS_RME_RESTORE_TO_ALTERNATE_LOCATION);
	else if (wcscmp(bstr, x_wszRESTOREATREBOOT) == 0)
		return(VSS_RME_RESTORE_AT_REBOOT);
	else if (wcscmp(bstr, x_wszCUSTOM) == 0)
		return(VSS_RME_CUSTOM);
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid restore method.",
			bstr
			);

    return VSS_RME_UNDEFINED;
	}

// convert from restore method to string
LPCWSTR CVssMetadataHelper::WszFromWriterRestore
    (
    IN CVssFunctionTracer &ft,
    IN VSS_WRITERRESTORE_ENUM method
    )
    {
    switch(method)
        {
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid writerRestore type %d",
                method
                );

        case VSS_WRE_NEVER:
			return x_wszNever;

		case VSS_WRE_IF_REPLACE_FAILS:
            return x_wszIfReplaceFails;

		case VSS_WRE_ALWAYS:
            return x_wszAlways;
        }
    }


// convert from string to VSS_RESTOREMETHOD_ENUM
VSS_WRITERRESTORE_ENUM CVssMetadataHelper::ConvertToWriterRestore
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszNever) == 0)
		return VSS_WRE_NEVER;
	else if (wcscmp(bstr, x_wszIfReplaceFails) == 0)
		return VSS_WRE_IF_REPLACE_FAILS;
	else if (wcscmp(bstr, x_wszAlways) == 0)
		return VSS_WRE_ALWAYS;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid restore method.",
			bstr
			);

    return VSS_WRE_UNDEFINED;
	}


// convert VSS_BACKUP_TYPE to string
LPCWSTR CVssMetadataHelper::WszFromBackupType
	(
	IN CVssFunctionTracer &ft,
	IN VSS_BACKUP_TYPE bt
	)
	{
	switch(bt)
		{
        default:
            ft.Throw
                (
                VSSDBG_XML,
                E_INVALIDARG,
                L"Invalid backupType %d",
                bt
                );

        case VSS_BT_INCREMENTAL:
			return x_wszValueIncremental;

		case VSS_BT_DIFFERENTIAL:
            return x_wszValueDifferential;

		case VSS_BT_FULL:
            return x_wszValueFull;

        case VSS_BT_OTHER:
			return x_wszValueOther;
        }
	}

// convert from string to backup type
VSS_BACKUP_TYPE CVssMetadataHelper::ConvertToBackupType
	(
	IN CVssFunctionTracer &ft,
	IN BSTR bstr
	)
	{
	if (wcscmp(bstr, x_wszValueIncremental) == 0)
		return VSS_BT_INCREMENTAL;
	else if (wcscmp(bstr, x_wszValueDifferential) == 0)
		return VSS_BT_DIFFERENTIAL;
	else if (wcscmp(bstr, x_wszValueFull) == 0)
		return VSS_BT_FULL;
	else if (wcscmp(bstr, x_wszValueOther) == 0)
		return VSS_BT_OTHER;
	else
		ft.Throw
			(
			VSSDBG_XML,
			E_INVALIDARG,
			L"The string %s is not a valid backup type.",
			bstr
			);

    return VSS_BT_UNDEFINED;
    }



// obtain the value of a string valued attribute.  Returns S_FALSE if
// attribute doesn't exist
HRESULT CVssMetadataHelper::GetStringAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT BSTR *pbstrValue
	)
	{
	try
		{
		// check output parameter
		if (pbstrValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// null output parameter
		*pbstrValue = NULL;

		// find attribute value
		if (m_doc.FindAttribute(wszAttrName, pbstrValue))
			return S_OK;
		else
			{
			if (bRequired)
				MissingAttribute(ft, wszAttrName);
			else
				return S_FALSE;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the value of a boolean ("yes", "no") attribute.  Return S_FALSE if
// attribute is not assigned a value.
HRESULT CVssMetadataHelper::GetBooleanAttributeValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	IN bool bRequired,
	OUT bool *pbValue
	)
	{
	try
		{
		// check output parameter
		if (pbValue == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// initialize output paramter
		*pbValue = false;

		CComBSTR bstrVal = NULL;
		// obtain string value of attribute
		if (!m_doc.FindAttribute(wszAttrName, &bstrVal))
			{
			if (bRequired)
				MissingAttribute(ft, wszAttrName);
			else
				return S_FALSE;
			}

		// convert attribute to a boolean value
        *pbValue = ConvertToBoolean(ft, bstrVal);
		return S_OK;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

bool CVssMetadataHelper::get_stringValue
	(
	IN LPCWSTR wszAttrName,
	OUT BSTR *pbstrValue
	)
	{
	// iniitialize value to null
	*pbstrValue = NULL;

	// obtain string value if exists
	return m_doc.FindAttribute(wszAttrName, pbstrValue);
	}

void CVssMetadataHelper::get_VSS_IDValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	OUT VSS_ID *pidValue
	) throw(HRESULT)
	{
	// initialize id value to GUID_NULL
	*pidValue = GUID_NULL;

	CComBSTR bstrVal = NULL;

	// obtain string value if it exists and convert it to GUID
	if (m_doc.FindAttribute(wszAttrName, &bstrVal))
		ConvertToVSS_ID(ft, bstrVal, pidValue);
	else
		MissingAttribute(ft, wszAttrName);
	}


bool CVssMetadataHelper::get_boolValue
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttrName,
	OUT bool *pb
	)
	{
	// initialize boolean value
	*pb = FALSE;

	CComBSTR bstrVal = NULL;

	// find attribute if it exists and convert its value to a boolean
	if (!m_doc.FindAttribute( wszAttrName, &bstrVal))
		return false;

	*pb = ConvertToBoolean(ft, bstrVal);
	return true;
	}

void CVssMetadataHelper::MissingElement
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszElement
	)
	{
	ft.LogError(VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ELEMENT, VSSDBG_XML << wszElement);
	ft.Throw
		(
		VSSDBG_XML,
		VSS_E_CORRUPT_XML_DOCUMENT,
		L"The %s element is missing.",
		wszElement
		);
    }

void CVssMetadataHelper::MissingAttribute
	(
	IN CVssFunctionTracer &ft,
	IN LPCWSTR wszAttribute
	)
	{
	ft.LogError(VSS_ERROR_CORRUPTXMLDOCUMENT_MISSING_ATTRIBUTE, VSSDBG_XML << wszAttribute);
	ft.Throw
		(
		VSSDBG_XML,
		VSS_E_CORRUPT_XML_DOCUMENT,
		L"The %s attribute is missing.",
		wszAttribute
		);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\backupext\vsxml\vs_cmxml.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vs_cmxml.cxx

Abstract:

    Implementation of Backup Components Metadata XML wrapper classes

	Brian Berkowitz  [brianb]  3/13/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    brianb		03/16/2000  Created
    brianb		03/22/2000  Added support for PrepareForBackup and BackupComplete
    brianb		04/04/2000  Added security checks for backup operator
    brianb		04/06/2000  Comment pass, remove callbacks from writer
    brianb		04/10/2000  add async support
    mikejohn	04/11/2000  Fix some loop iteration problems
	brianb  	04/21/2000  retool for passing WRITER_COMPONENTS as strings
	brianb		04/25/2000  added critical section support
	brianb		05/03/2000	new security model
	brianb		05/05/2000  fix bug in CVssWriterComponents::GetComponent
    brianb      05/16/2000  code review comments, remove Cancel stuff
	brianb		05/19/2000  code review comments

--*/

#include "stdafx.hxx"
#include "vs_inc.hxx"
#include "vs_sec.hxx"

#include "vs_idl.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "cmxml.c"
#include "worker.hxx"
#include "async.hxx"
#include "vssmsg.h"
#include "vs_filter.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "BUECXMLC"
//
////////////////////////////////////////////////////////////////////////


// schema information
static LPCWSTR x_wszVersionNo = L"1.0";

// element strings
static LPCWSTR x_wszElementBackupComponents = L"BACKUP_COMPONENTS";
static LPCWSTR x_wszElementWriterComponents = L"WRITER_COMPONENTS";
static LPCWSTR x_wszElementBackupMetadata = L"BACKUP_METADATA";
static LPCWSTR x_wszElementAlternateMapping = L"ALTERNATE_LOCATION_MAPPING";
static LPCWSTR x_wszElementComponent = L"COMPONENT";
static LPCWSTR x_wszElementRoot = L"root";

// attribute strings
static LPCWSTR x_wszAttrVersion = L"version";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszAttrBootableSystemStateBackup = L"bootableSystemStateBackup";
static LPCWSTR x_wszAttrWriterId = L"writerId";
static LPCWSTR x_wszAttrInstanceId = L"instanceId";
static LPCWSTR x_wszAttrComponentType = L"componentType";
static LPCWSTR x_wszAttrLogicalPath = L"logicalPath";
static LPCWSTR x_wszAttrComponentName = L"componentName";
static LPCWSTR x_wszAttrBackupSucceeded = L"backupSucceeded";
static LPCWSTR x_wszAttrPath = L"path";
static LPCWSTR x_wszAttrFilespec = L"filespec";
static LPCWSTR x_wszAttrRecursive = L"recursive";
static LPCWSTR x_wszAttrAlternatePath = L"alternatePath";
static LPCWSTR x_wszAttrMetadata = L"metadata";
static LPCWSTR x_wszAttrSelectComponents = L"selectComponents";
static LPCWSTR x_wszAttrBackupType = L"backupType";

// value strings
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssComponentMetadata";



// return the logical path for a component
// implements IVssComponent::GetLogicalPath
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if there are no errors
//      S_FALSE if there is no logical path for the component
//		E_INVALIDARG if pbstrPath is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetLogicalPath(OUT BSTR *pbstrPath)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetLogicalPath"
		);

	// acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lock(m_csDOM);

    // call internal function
    return GetStringAttributeValue(ft, x_wszAttrLogicalPath, false, pbstrPath);
	}

// return the type of a component
// implements IVssComponent::GetComponentType
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pct is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetComponentType(VSS_COMPONENT_TYPE *pct)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetComponentType"
		);

	try
		{
		// validate output argument
		if (pct == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output argument
		*pct = VSS_CT_UNDEFINED;
		CComBSTR bstrComponentType;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// get component type as a string
		if (!get_stringValue(x_wszAttrComponentType, &bstrComponentType))
			MissingAttribute(ft, x_wszAttrComponentType);

		// convert it to VSS_COMPONENT_TYPE value
		*pct = ConvertToComponentType(ft, bstrComponentType, true);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the componentName attribute
// implements IVssComponent::GetComponentName
// caller responsible for calling SysFreeString on the output parameter
//
// Returns:
//    S_OK if the operation is successful
//    E_INVALIDARG if pbstrName == NULL
//	  VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//    E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetComponentName(OUT BSTR *pbstrName)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetComponentName"
		);

	// acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lock(m_csDOM);

    // call internal implementation
    return GetStringAttributeValue(ft, x_wszAttrComponentName, true, pbstrName);
	}


// obtain the backupSucceeded attribute
// implements IVssComponent::GetBackupSucceeded
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the value of the attribute is not defined.
//		E_INVALIDARG if pbSucceeded == NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetBackupSucceeded(OUT bool *pbSucceeded)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupSucceeded"
		);

	// acquire lock to ensure single threaded access through DOM
    CVssSafeAutomaticLock lock(m_csDOM);

    // call internal implementation
    return GetBooleanAttributeValue(ft, x_wszAttrBackupSucceeded, false, pbSucceeded);
	}


// obtain the count of ALTERNATE_LOCATION_MAPPING elements
// implements IVssComponent::GetAlternateLocationMappingCount
//
// Returns
//		S_OK if the operation is successful
//		E_INVALIDARG if pcMappings is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetAlternateLocationMappingCount
	(
	OUT UINT *pcMappings
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetAlternateLocationMappingCount"
		);

    try
		{
		// validate output parameter
		if (pcMappings == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		// initialize output parameter
		*pcMappings = 0;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
		m_doc.ResetToDocument();

		// find first ALTERNATE_LOCATION_MAPPING element
		if (!m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
			return S_OK;

        UINT cMappings = 0;
		// count elements
		do
			{
			cMappings++;
			} while(m_doc.FindElement(x_wszElementAlternateMapping, FALSE));

        // set return value
        *pcMappings = cMappings;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// obtain a specific ALTERNATE_LOCATION_MAPPING element
// implements IVssComponent::GetAlterateLocationMapping
// caller is responsible for calling IVssWMFiledesc::Release on the ouptut parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppFiledesc is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specific alternative location
//			mapping doesn't exist
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::GetAlternateLocationMapping
	(
	IN UINT iMapping,					// which mapping to select
	OUT IVssWMFiledesc **ppFiledesc		// output file descriptor
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetAlternativeLocationMapping"
		);

    CVssWMFiledesc *pFiledesc = NULL;
    try
		{
		// validate output parameter
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		// initailize output parameter
		*ppFiledesc = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find first ALTERNATE_LOCATION_MAPPING element
		if (!m_doc.FindElement(x_wszElementAlternateMapping, TRUE))
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find ALTERNATE_LOCATION_MAPPING");

		// skip to selected element
		for(UINT i = 0; i < iMapping; i++)
			{
			if (!m_doc.FindElement(x_wszElementAlternateMapping, FALSE))
				ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Cannot find ALTERNATE_LOCATION_MAPPING");
			}

		// create filedesc object
		pFiledesc = new CVssWMFiledesc(m_doc.GetCurrentNode());

		// validate that allocation succeeded
		if (pFiledesc == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Couldn't create CVssWMFiledesc due to allocation failure."
				);


		// 2nd phase of initialization
		pFiledesc->Initialize(ft);

		// transfer ownership of pointer
		*ppFiledesc = (IVssWMFiledesc *) pFiledesc;

		((IVssWMFiledesc *) pFiledesc)->AddRef();
		pFiledesc = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pFiledesc;

    return ft.hr;
	}


// set BACKUP_METADATA element within the component
// implements IVssComponent::SetBackupMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if this operation is called outside of
//			the context of OnPrepareBackup
//		E_INVALIDARG if wszData is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssComponent::SetBackupMetadata(IN LPCWSTR wszData)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::SetBackupMetadata"
		);

    try
		{
		if (wszData == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Required input paramter is NULL.");

		if (m_pWriterComponents == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Components document is not writeable"
				);

		// acquire lock to ensure single threaded access through DOM
        CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();
		if (m_doc.FindElement(x_wszElementBackupMetadata, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_ALREADY_EXISTS,
				L"BackupMetadata already exists on the component"
				);

		// create BACKUP_METADATA node as child of COMPONENT node
		CXMLNode node = m_doc.CreateNode
			(
			x_wszElementBackupMetadata,
			NODE_ELEMENT
			);

        // set metadata attribute
        node.SetAttribute(x_wszAttrMetadata, wszData);
		m_pWriterComponents->SetChanged();

		// insert BACKUP_METADATA node under component node
		m_doc.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// obtain value of BACKUP_METADATA element
// implements IVssComponent::GetBackupMetadata
// caller is responsible for calling SysFreeString on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if there is no backup metadata associated with the component
//		E_INVALIDARG if pbstrData is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs
//
STDMETHODIMP CVssComponent::GetBackupMetadata
	(
	OUT BSTR *pbstrData
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssComponent::GetBackupMetadata"
		);

    try
		{
		// validate output parameters
		if (pbstrData == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pbstrData = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of COMPONENT document
		m_doc.ResetToDocument();

		// find BACKUP_METADATA element
		if (!m_doc.FindElement(x_wszElementBackupMetadata, TRUE))
			return S_FALSE;

		CComBSTR bstr;

		// extract string value
		if (!get_stringValue(x_wszAttrMetadata, &bstr))
			MissingAttribute(ft, x_wszAttrMetadata);

        *pbstrData = bstr.Detach();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}



// IUnknown::QueryInterface method
// this method should never be callsed
STDMETHODIMP CVssComponent::QueryInterface(REFIID, void **)
	{
	return E_NOTIMPL;
	}

// IUnknown::AddRef method
STDMETHODIMP_(ULONG) CVssComponent::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// IUnknown::Release method
STDMETHODIMP_(ULONG) CVssComponent::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);
	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}

// initilize document to make toplevel node WRITER_COMPONENTS node
// implements IVssWriterComponentsExt::Initialize
// fFindToplevel is called with FALSE if m_doc is already pointing at the
// WRITER_COMPONENTS element as in CVssBackupComponents::GetWriterComponents
// It is called with true if the writer components is buried a child of
// the root document as is the case when a Writer gets the WRITER_COMPONENTS
// node from the document returned by IVssWriterCallback::GetContent.
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::Initialize(bool fFindToplevel)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::Initialize");

	try
		{
		InitializeHelper(ft);

		if (fFindToplevel)
			{
			if (!m_doc.FindElement(x_wszElementWriterComponents, true))
				MissingElement(ft, x_wszElementWriterComponents);

			m_doc.SetToplevel();
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get information about the writer of a compnent
// implements IVssWriterComponents::GetWriterInfo
// NOTE: pidInstance may be NULL (i.e., is optional)
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either parameters is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetWriterInfo
	(
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetWriterInfo"
		);

    try
		{
		VssZeroOut(pidInstance);

		// validate output parameters
		if (pidWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pidWriter = GUID_NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of WRITER_COMPONENTS document
		m_doc.ResetToDocument();
		if (pidInstance)
			// get instanceId attribute value
			get_VSS_IDValue(ft, x_wszAttrInstanceId, pidInstance);

        // get writerId attribute value
		get_VSS_IDValue(ft, x_wszAttrWriterId, pidWriter);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of components associated with the writer
// implements IVssWriterComponents::GetComponentCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetComponentCount(OUT UINT *pcComponents)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetComponentCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();

		// find first COMPONENT element
		if (!m_doc.FindElement(x_wszElementComponent, TRUE))
			return S_OK;

        UINT cComponents = 0;
        // count COMPONENT elements
		do
			{
			// increment component count
			cComponents++;
			} while(m_doc.FindElement(x_wszElementComponent, FALSE));

        *pcComponents = cComponents;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// obtain a specific component
// implements IVssWriterComponents::GetComponent
// caller is responsible for calling IVssComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is sucessful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if iComponent does not refer to a valid component
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::GetComponent
	(
	IN UINT iComponent,					// specify component to select
	OUT IVssComponent **ppComponent
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetComponent"
		);

    CVssComponent *pComponent = NULL;
    try
		{
		// validate output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output paramter
		*ppComponent = NULL;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		// reset to top of document
		m_doc.ResetToDocument();

		// find first COMPONENT element
		if (!m_doc.FindElement(x_wszElementComponent, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Cannot find %d COMPONENT.",
				iComponent
				);


        // skip to selected component
		for(UINT i = 0; i < iComponent; i++)
			{
			if (!m_doc.FindElement(x_wszElementComponent, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Cannot find %d COMPONENT.",
					iComponent
					);
			}

        // return the element as a CVssComponent object
		pComponent = new CVssComponent
						(
						m_doc.GetCurrentNode(),
						m_doc.GetInterface(),
						m_bWriteable ? this : NULL
						);

		// check for memory allocation failure
		if (pComponent == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssComponent due to allocation failure"
				);

		// 2nd phase of initialization
		pComponent->Initialize(ft);

		// transfer ownership of pointer
		*ppComponent = (IVssComponent *) pComponent;
		((IVssComponent *) pComponent)->AddRef();
		pComponent = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pComponent;

    return ft.hr;
	}

// return whether any child component was modified
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbChanged is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::IsChanged(OUT bool *pbChanged)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::IsChanged");

	try
		{
		if (pbChanged == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		BS_ASSERT(!m_bChanged || m_bWriteable);
		*pbChanged = m_bChanged;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// save components as XML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssWriterComponents::SaveAsXML(OUT BSTR *pbstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterComponents::SaveAsXML");

	try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		CVssSafeAutomaticLock lock(m_csDOM);
		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// implements IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssWriterComponents::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// implements IUnknown::Release
STDMETHODIMP_(ULONG) CVssWriterComponents::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}


// get information about the writer of a compnent
// implements IVssWriterComponents::GetWriterInfo
// NOTE: pidInstance may be NULL (i.e., is optional)
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if either parameters is NULL
//		VSS_E_CORRUPTXMLDOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::GetWriterInfo
	(
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetWriterInfo"
		);

    try
		{
		VssZeroOut(pidInstance);

		// validate output parameters
		if (pidWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pidWriter = m_idWriter;
		*pidInstance = m_idInstance;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of components associated with the writer
// implements IVssWriterComponents::GetComponentCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::GetComponentCount
	(
	OUT UINT *pcComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetComponentCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// obtain a specific component
// implements IVssWriterComponents::GetComponent
// caller is responsible for calling IVssComponent::Release on the output parameter
//
// Returns:
//		S_OK if the operation is sucessful
//		E_INVALIDARG if ppComponent is NULL
//		VSS_E_OBJECT_NOT_FOUND if no other error is returned

STDMETHODIMP CVssNULLWriterComponents::GetComponent
	(
	IN UINT iComponent,					// specify component to select
	OUT IVssComponent **ppComponent
	)
	{
	UNREFERENCED_PARAMETER(iComponent);
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssNULLWriterComponents::GetComponent"
		);

    try
		{
		// validate output parameter
		if (ppComponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output paramter
		*ppComponent = NULL;

		ft.hr = VSS_E_OBJECT_NOT_FOUND;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// return whether any child component was modified
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbChanged is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::IsChanged(OUT bool *pbChanged)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssNULLWriterComponents::IsChanged");

	try
		{
		if (pbChanged == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*pbChanged = false;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// save components as XML
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssNULLWriterComponents::SaveAsXML(OUT BSTR *pbstrXML)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssNULLWriterComponents::SaveAsXML");

	try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// implements IUnknown::AddRef
STDMETHODIMP_(ULONG) CVssNULLWriterComponents::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// implements IUnknown::Release
STDMETHODIMP_(ULONG) CVssNULLWriterComponents::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);
	BS_ASSERT(cRef >= 0);

	if (cRef == 0)
		{
		// reference count is 0, delete the object
		delete this;
		return 0;
		}
	else
		return (ULONG) cRef;
	}



// constructor
CVssBackupComponents::CVssBackupComponents() :
	m_state(x_StateUndefined),
	m_cWriters(0),
	m_pDataFirst(NULL),
	m_rgWriterProp(NULL),
	m_bInitialized(false),
	m_bGatherWriterStatusComplete(false),
	m_bGatherWriterMetadataComplete(false),
	m_bSetBackupStateCalled(false),
	m_timestampOperation(0)
	{
	}

// destructor
CVssBackupComponents::~CVssBackupComponents()
	{
	if (m_bInitialized)
		{
		// abort backup in case caller failed to do so
		AbortBackup();

		// free any metadata that is hanging around
		FreeAllWriters();

		// free status associated with writers
		FreeWriterStatus();
		}
	}

// basic initialization
void CVssBackupComponents::BasicInit
	(
	IN CVssFunctionTracer &ft
	)
	{
	// note that there is a potenential race condition if someone tries
	// calling InitializeForBackup and/or InitializeForRestore from
	// multiple threads, but this is not a valid way to use this class and
	// the likelihood of this happening and not being caught is really
	// very slim.
	if (m_state != x_StateUndefined &&
		m_state != x_StateAborted)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_BAD_STATE,
			L"CVssBackupComponents already initialized"
			);

    m_state = x_StateUndefined;

	m_bstrSnapshotSetId = GUID_NULL;
	if (m_bstrSnapshotSetId.Length() == 0)
		ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate BSTR.");

	m_csWriters.Init();
	m_csState.Init();

	// initialize XML document helper
	InitializeHelper(ft);
	}

// validate that object has been initialized
void CVssBackupComponents::ValidateInitialized(CVssFunctionTracer &ft)
	{
	if (!m_bInitialized)
		ft.Throw
			(
			VSSDBG_XML,
		    VSS_E_BAD_STATE,
			L"Initialization function was not called"
			);
    }



// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::Initialize
// Returns:
//		S_OK if the operation is succesfsful
//		VSS_E_CORRUPTXMLDOCUMENT if the initial XML document is corrupt
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::InitializeForBackup(IN BSTR bstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InitializeForBackup"
		);

	try
		{
		if (!IsProcessBackupOperator())
			ft.Throw(VSSDBG_XML, E_ACCESSDENIED, L"Access denied");

		BasicInit(ft);

		// protect state variable throughout this function
		CVssSafeAutomaticLock lock(m_csState);

		BS_ASSERT(m_state == x_StateUndefined);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

		// intialize document with <root><schema></root>
		m_doc.LoadFromXML(g_ComponentMetadataXML);

		// find toplevel <root> element
		if (!m_doc.FindElement(x_wszElementRoot, true))
			MissingElement(ft, x_wszElementRoot);

		// create BACKUP_COMPONENTS element under <root> element
		CXMLNode nodeRoot(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// save root node.  It is modified in PrepareForBackup
		m_pNodeRoot = m_doc.GetCurrentNode();

		CXMLNode nodeBackup = m_doc.CreateNode	
				(
				x_wszElementBackupComponents,
				NODE_ELEMENT
				);

        // set schema and version attributes
		nodeBackup.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);
		nodeBackup.SetAttribute(x_wszAttrVersion, x_wszVersionNo);
		CXMLNode nodeToplevel = nodeRoot.InsertNode(nodeBackup);
		m_doc.SetToplevelNode(nodeToplevel);

		// indicate that CVssBackupComponents object is initialized
		m_state = x_StateInitialized;
		m_bRestore = false;
		m_bInitialized = true;
        }
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	UNREFERENCED_PARAMETER(bstrXML);
	}

// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::SetBackupState
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetBackupState
	(
	IN bool bSelectComponents,			// does backup allow selective backup of components
	IN bool bBootableSystemStateBackup,	// is bootable system state being backed up
	IN VSS_BACKUP_TYPE backupType,		// backup type
	IN bool bPartialFileSupport			// partial file support
	)
	{
	UNREFERENCED_PARAMETER(bPartialFileSupport);

	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBacupComponents::SetBackupState"
		);

	try
		{
		LPCWSTR wszBackupType = WszFromBackupType(ft, backupType);

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lock(m_csDOM);

		m_doc.ResetToDocument();
		CXMLNode nodeBackup(m_doc.GetCurrentNode(), m_doc.GetInterface());

		// set bootableSystemStateBackup flag
		nodeBackup.SetAttribute
			(
			x_wszAttrBootableSystemStateBackup,
			WszFromBoolean(bBootableSystemStateBackup)
			);

		// set indication of whether backup is selecting drives or
		// components
		nodeBackup.SetAttribute
			(
			x_wszAttrSelectComponents,
			WszFromBoolean(bSelectComponents)
			);

		// set backup type
		nodeBackup.SetAttribute(x_wszAttrBackupType, wszBackupType);
		m_bSetBackupStateCalled = true;
        }
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// initialize BACKUP_COMPONENTS document
// implements IVssBackupComponents::Initialize
//
// Returns:
//		S_OK if the operation is successful
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::InitializeForRestore
	(
	IN BSTR bstrXML		 // components document
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBacupComponents::Initialize"
		);

    BSTR bstr = NULL;

	try
		{
		if (!IsProcessRestoreOperator())
			ft.Throw(VSSDBG_XML, E_ACCESSDENIED, L"Access denied");

		BasicInit(ft);

		// protect m_state member variable throughout this function
		CVssSafeAutomaticLock lock(m_csState);

		// state should indicate we are not initialized
		BS_ASSERT(m_state == x_StateUndefined);

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

        		// compute length of constructed document consisting of
		// a root node, schema, and supplied document
		UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXML);

        // allocate string
        bstr = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root> <schema>
	    memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
		pwc += g_iwcComponentMetadataXMLEnd;

		// copy in document
		wcscpy(pwc, bstrXML);
		pwc += wcslen(bstrXML);

		// copy in </root>
		wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);

		// intialize document with <root><schema></root>
		if (!m_doc.LoadFromXML(bstr))
			{
			// reinitialize document
			m_doc.Initialize();
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_INVALID_XML_DOCUMENT,
				L"Load of Backup components document failed"
				);
            }

		// find toplevel <root> element
		if (!m_doc.FindElement(x_wszElementRoot, true))
			MissingElement(ft, x_wszElementRoot);

         // find BACKUP_COMPONENTS element
		if (!m_doc.FindElement(x_wszElementBackupComponents, true))
			MissingElement(ft, x_wszElementBackupComponents);

        // set BACKUP_COMPONENTS as toplevel element
        m_doc.SetToplevel();

		// indicate that CVssBackupComponents object is initialized
		m_state = x_StateInitialized;
		m_bRestore = true;
		m_bInitialized = true;
        }
	VSS_STANDARD_CATCH(ft)

	SysFreeString(bstr);

    return ft.hr;
	}


// add a specific component to the document
// implements IVssBackupComponents::AddComponent
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_ALREADY_EXISTS if a component with the same type, path
//			and name already exists
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AddComponent
	(
	IN VSS_ID instanceId,
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AddComponent"
		);

    try
		{
		// validate input parameters
		if (wszComponentName == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		// validate state
		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateInitialized &&
			m_state != x_StateSnapshotSetCreated)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"CVssBackupComponents::AddComponent called at the wrong time"
				);

		// obtain component type as string
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
		CComPtr<IXMLDOMNode> pNode;

		// acquire lock to ensure single threaded access through DOM
		CVssSafeAutomaticLock lockDOM(m_csDOM);

		// create the COMPONENT
		FindComponent
			(
			ft,
			&instanceId,
			writerId,
			wszComponentType,
			wszLogicalPath,
			wszComponentName,
            true
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// routine to obtain flags from the a BACKUP_COMPONENTS XML document
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetBackupState
	(
	OUT BOOL *pbSelectComponents,			// does backup allow selection of components
	OUT BOOL *pbBootableSystemStateBackup,	// is bootable system state being backed up
	OUT VSS_BACKUP_TYPE *pBackupType,		// backup type 
	OUT BOOL *pbPartialFileSupport,			// partial file support
	OUT LONG *plContext
	)
	{
	UNREFERENCED_PARAMETER(plContext);
    
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssBackupComponents::GetBackupState");

	try
		{
		if (pbBootableSystemStateBackup)
			*pbBootableSystemStateBackup = FALSE;

		if (pBackupType)
			*pBackupType = VSS_BT_UNDEFINED;

		if (pbPartialFileSupport)
			*pbPartialFileSupport = FALSE;

		// validate output parameters
		if (pbSelectComponents == NULL ||
			pbBootableSystemStateBackup == NULL ||
			pBackupType == NULL ||
			pbPartialFileSupport == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters
		*pbSelectComponents = FALSE;

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		// position to top of BACKUP_COMPONENTS document
		m_doc.ResetToDocument();

		// get bootableSystemState attribute value
		bool bBootableSystemStateBackup, bSelectComponents;
		if (!get_boolValue(ft, x_wszAttrBootableSystemStateBackup, &bBootableSystemStateBackup))
			MissingAttribute(ft, x_wszAttrBootableSystemStateBackup);

		// get selectComponents attribute value
		if (!get_boolValue(ft, x_wszAttrSelectComponents, &bSelectComponents))
			MissingAttribute(ft, x_wszAttrSelectComponents);

		CComBSTR bstrBackupType;

		if (!get_stringValue(x_wszAttrBackupType, &bstrBackupType))
			MissingAttribute(ft, x_wszAttrBackupType);


		*pBackupType = ConvertToBackupType(ft, bstrBackupType);
		*pbBootableSystemStateBackup = bBootableSystemStateBackup;
		*pbSelectComponents = bSelectComponents;
		}
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}

// internal routine to find or create a specific WRITER_COMPONENTS element
CXMLNode CVssBackupComponents::PositionOnWriterComponents
	(
	IN CVssFunctionTracer &ft,
	IN VSS_ID *pinstanceId,		// NULL indicates that it is not specified
	IN VSS_ID writerId,			// writer class id
	IN bool bCreateIfNotThere,	// create WRITER_COMPONENTS element if it isn't there
	OUT bool &bCreated			// whether component was created or not
	) throw(HRESULT)
	{
	// initialize output parameter
	bCreated = false;

	CVssSafeAutomaticLock lock(m_csDOM);

	// position to top of BACKUP_COMPONENTS document
	m_doc.ResetToDocument();

	// set parent node to be BACKUP_COMPONENTS element
	CXMLNode nodeBackupComponents(m_doc.GetCurrentNode(), m_doc.GetInterface());
	bool bFound = false;

	// look for first WRITER_COMPONENTS element
	if (m_doc.FindElement(x_wszElementWriterComponents, TRUE))
		{
		do
			{
			VSS_ID writerIdFound;
			VSS_ID instanceIdFound;
			CComBSTR bstrVal;

			// get writerId attribute
			get_VSS_IDValue(ft, x_wszAttrWriterId, &writerIdFound);

			if (pinstanceId)
				{
				get_VSS_IDValue(ft, x_wszAttrInstanceId, &instanceIdFound);

				// if instanceId doesn't match, then skip this element
				if (*pinstanceId != instanceIdFound)
					continue;
				}

			// if writerId attribute matches, then we have found the target element
			if (writerId == writerIdFound)
				{
				bFound = true;
				break;
				}
			} while (m_doc.FindElement(x_wszElementWriterComponents, FALSE));
        }

	// if element is found, then return it
	if (bFound)
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

	if (!bCreateIfNotThere)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_NOT_FOUND,
			L"WRITER_COMPONENTS element was not found."
			);

	// create element if requested
    CXMLNode node = m_doc.CreateNode
		(
		x_wszElementWriterComponents,
		NODE_ELEMENT
		);

    // assign instanceId if supplied
    if (pinstanceId)
		node.SetAttribute(x_wszAttrInstanceId, *pinstanceId);

	// assign writerId
	node.SetAttribute(x_wszAttrWriterId, writerId);

	// insert WRITER_COMPONENTS element under BACKUP_COMPONENTS node
	CXMLNode nodeRet = nodeBackupComponents.InsertNode(node);

	// element was created
	bCreated = true;

	// return node
	return nodeRet;
	}

// internal routine to return/create a specific COMPONENT
// assumes caller has already locked m_csDOM
CXMLNode CVssBackupComponents::FindComponent
	(
	IN CVssFunctionTracer &ft,
	IN VSS_ID *pinstanceId,			// NULL means instanceId is not specified(RESTORE)
	IN VSS_ID writerId,				// writer class id
	IN LPCWSTR wszComponentType,	// component type (DATABASE or FILE_GROUP)		
	IN LPCWSTR wszLogicalPath,		// logical path to component
	IN LPCWSTR wszComponentName,	// component name
	IN bool bCreate					// whether creation of element is allowed
	)
	{
	// both componentType and componentName should be specified
	BS_ASSERT(wszComponentType != NULL);
	BS_ASSERT(wszComponentName != NULL);

	// initialize state variables
	bool bFound = false;
	bool bCreated = false;

	// get WRITER_COMPONENTS node
	CXMLNode nodeWriter = PositionOnWriterComponents(ft, pinstanceId, writerId, true, bCreated);

	// find first child COMPONENT element under WRITER_COMPONENTS if
	// WRITER_COMPONENTS was found
	if (!bCreated && m_doc.FindElement(x_wszElementComponent, TRUE))
		{
		do
			{
			CComBSTR bstrComponentType;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			// get component type
			if (!get_stringValue(x_wszAttrComponentType, &bstrComponentType))
				MissingAttribute(ft, x_wszAttrComponentType);

            // if componentName doesn't match, then skip component
            if (wcscmp(wszComponentType, bstrComponentType) != 0)
				continue;

			bool fLogicalPath = get_stringValue(x_wszAttrLogicalPath, &bstrLogicalPath);
			if (wszLogicalPath != NULL && wcslen(wszLogicalPath) > 0)
				{
				// logical path doesn't exist, skip component
				if (!fLogicalPath)
					continue;
				else
					{
					// if logical path doesn't match, then skip component
					if (wcscmp(bstrLogicalPath, wszLogicalPath) != 0)
						continue;
					}
				}
			else
				{
				// if logical path exists, then skip component
				if (fLogicalPath)
					continue;
				}

			// get component name
			if (!get_stringValue(x_wszAttrComponentName, &bstrComponentName))
				MissingAttribute(ft, x_wszAttrComponentName);

            // if component name matches, then we are done
            if (wcscmp(wszComponentName, bstrComponentName) == 0)
				{
				bFound = true;
				break;
				}
			} while(m_doc.FindElement(x_wszElementComponent, FALSE));
        }

	if (bFound && bCreate)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_ALREADY_EXISTS,
			L"Attempt to create a duplicate component."
			);


    // return node if found
	if (bFound && !bCreate)
		return CXMLNode(m_doc.GetCurrentNode(), m_doc.GetInterface());

	// if node not found and if we cannot create the node, then return an error
	if (!bCreate)
		ft.Throw
			(
			VSSDBG_XML,
			VSS_E_OBJECT_NOT_FOUND,
			L"Component was not found. %s\\%s",
			wszLogicalPath,
			wszComponentName
			);

	// create node if requested to
	CXMLNode node = m_doc.CreateNode
			(
			x_wszElementComponent,
			NODE_ELEMENT
			);

     // assign logicalPath attribute if supplied
    if (wszLogicalPath && wcslen(wszLogicalPath) > 0)
		node.SetAttribute(x_wszAttrLogicalPath, wszLogicalPath);

	// assign componentName attribute
	node.SetAttribute(x_wszAttrComponentName, wszComponentName);

	// assign componentType attribute
	node.SetAttribute(x_wszAttrComponentType, wszComponentType);

	// insert COMPONENT node under WRITER_COMPONENTS node
	return nodeWriter.InsertNode(node);
	}

// get a callback interface
void CVssBackupComponents::GetCallbackInterface
	(
	CVssFunctionTracer &ft,
	IDispatch **ppDispatch
	)
	{
	CComPtr<IUnknown> pUnknown = GetUnknown();
	CComPtr<IDispatch> pDispatch;
	ft.hr = pUnknown->SafeQI(IDispatch, &pDispatch);
	BS_ASSERT(!ft.HrFailed());
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IDISPATCH_FAILED, VSSDBG_XML << ft.hr);
		ft.Throw
			(
			VSSDBG_XML,
            E_UNEXPECTED,
			L"Error querying for the IDispatch interface.  hr = 0x%08x",
			ft.hr
			);
        }

    *ppDispatch = pDispatch.Detach();
	}

// set up IVssWriters interface
void CVssBackupComponents::SetupWriter
	(
	CVssFunctionTracer &ft,
	IVssWriter **ppWriter
	)
	{
	CComPtr<IVssWriter> pWriter;
	ft.hr = pWriter.CoCreateInstance(CLSID_VssEvent);
	ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

	BS_ASSERT(pWriter);
	SetupPublisherFilter(pWriter);
	*ppWriter = pWriter.Detach();
	}

// signal PrepareForBackup event to writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::PrepareForBackup
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::PrepareForBackup"
		);

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that initialization has been perfromed
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateSnapshotSetCreated ||
			!m_bSetBackupStateCalled)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_PREPARE_FOR_BACKUP
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// internal PrepareForBackup call called from CVssAsyncBackup class
HRESULT CVssBackupComponents::InternalPrepareForBackup()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalPrepareForBackup"
		);

	// get lock serializing state changes
	m_csState.Lock();
	UINT timestamp = ++m_timestampOperation;
	try
		{
		if (m_state != x_StateSnapshotSetCreated)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);
	
		m_state = x_StatePrepareForBackup;

		// get IVssWriter event class
		CComPtr<IVssWriter> pWriter;

		SetupWriter(ft, &pWriter);
		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);


		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalPrepareForBackup1");
		ft1.hr = pWriter->PrepareForBackup(m_bstrSnapshotSetId, pDispatch);
		ft.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::PrepareForBackup (%s)", m_bstrSnapshotSetId);

		if (timestamp == m_timestampOperation)
			{
			RebuildComponentData(ft);
			m_state = x_StatePrepareForBackupSucceeded;
			}

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (timestamp == m_timestampOperation)
		{
		if (ft.HrFailed())
			m_state = x_StatePrepareForBackupFailed;

		FreeWriterComponents();
		m_timestampOperation++;
		m_csState.Unlock();
		}

	return ft.hr;
	}

// called by IVssAsync::Cancel if a PrepareBackup operation is cancelled.
void CVssBackupComponents::PostPrepareForBackup(UINT timestamp)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostPrepareForBackup");

	if (timestamp == m_timestampOperation)
		{
		m_state = x_StatePrepareForBackupSucceeded;
		m_timestampOperation++;
		m_csState.Unlock();
		}
	}

// rebuild component metadata from data gotten from writers during
// prepare for backup
void CVssBackupComponents::RebuildComponentData
	(
	IN CVssFunctionTracer &ft
	)
	{
	CVssSafeAutomaticLock lock(m_csDOM);

	m_doc.ResetToDocument();
	CComPtr<IXMLDOMNode> pNodeParent = m_doc.GetCurrentNode();

	CComPtr<IXMLDOMNode> pNodeCloned;

	if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
		return;

    ft.hr = pNodeParent->cloneNode(VARIANT_TRUE, &pNodeCloned);
	ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode:cloneNode");

	CXMLDocument docCloned(pNodeCloned, m_doc.GetInterface());

	if (!docCloned.FindElement(x_wszElementWriterComponents, TRUE))
		{
		ft.LogError(VSS_ERROR_CLONE_MISSING_CHILDREN, VSSDBG_XML);
		ft.Throw
			(
            VSSDBG_XML,
			VSS_E_CORRUPT_XML_DOCUMENT,
			L"Cloned node has no children"
			);
        }			

	do
		{
		VSS_ID idInstance;

		CComBSTR bstrVal;

		if (!docCloned.FindAttribute(x_wszAttrInstanceId, &bstrVal))
			MissingAttribute(ft, x_wszAttrInstanceId);

        CVssMetadataHelper::ConvertToVSS_ID(ft, bstrVal, &idInstance);

		for
			(
			CInternalWriterData *pData = m_pDataFirst;
			pData != NULL;
			pData = pData->m_pDataNext
			)
			{
			if (pData->m_idInstance == idInstance)
				break;
			}

		if (pData != NULL && pData->m_bstrWriterComponents)
			{
			CXMLDocument doc;
			if (!doc.LoadFromXML(pData->m_bstrWriterComponents))
				{
				ft.LogError(VSS_ERROR_INVALID_XML_DOCUMENT_FROM_WRITER, VSSDBG_XML << pData->m_idInstance);
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_CORRUPT_XML_DOCUMENT,
					L"XML data from writer is not valid:" WSTR_GUID_FMT,
					GUID_PRINTF_ARG(pData->m_idInstance)
					);
                }

            if (!doc.FindElement(x_wszElementWriterComponents, TRUE))
				MissingElement(ft, x_wszElementWriterComponents);

	        ft.hr = pNodeCloned->replaceChild
				(
				doc.GetCurrentNode(),
				docCloned.GetCurrentNode(),
				NULL
				);
            ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::replaceChild");
			docCloned.SetCurrentNode(doc.GetCurrentNode());
			}

		} while(docCloned.FindElement(x_wszElementWriterComponents, FALSE));

	ft.hr = m_pNodeRoot->replaceChild
		(
		pNodeCloned,
		pNodeParent,
		NULL
		);

    ft.CheckForError(VSSDBG_XML, L"IXMLDOMNode::replaceChild");

    CXMLNode newToplevelNode(pNodeCloned, m_doc.GetInterface());
    m_doc.SetToplevelNode(newToplevelNode);
	}


// indicate that backup was aborted
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AbortBackup()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AbortBackup"
		);

    try
		{
		// validate that object has been initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);


		if (m_state == x_StatePrepareForBackup ||
			m_state == x_StatePrepareForBackupFailed ||
			m_state == x_StatePrepareForBackupSucceeded ||
			m_state == x_StateDoSnapshotFailedWithoutSendingAbort)
			{
			m_state = x_StateAborting;

			// setup pointer to writer event class
			CComPtr <IVssWriter> pWriter;
			SetupWriter(ft, &pWriter);

			CComPtr<IDispatch> pDispatch;
			GetCallbackInterface(ft, &pDispatch);
			ft.hr = pWriter->Abort(m_bstrSnapshotSetId);
			ClearPublisherFilter(pWriter);
			}

		// release coordinator if we have a pointer to cause
		// it to abort anything in progress
		if (m_pCoordinator)
			m_pCoordinator = NULL;

		m_state = x_StateAborted;
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}




// gather status of the writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GatherWriterStatus
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GatherWriterStatus"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

	    *ppAsync = NULL;

		// validate that object has been initialized
		ValidateInitialized(ft);

		m_bGatherWriterStatusComplete = false;

		*ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_GATHER_WRITER_STATUS
			);

		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}



// gather status of the writers
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//		VSS_E_WRITER_INFRASTRUCTURE: either the service state or bootable
//      	state writer failed to respond
//

HRESULT CVssBackupComponents::InternalGatherWriterStatus()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalGatherWriterStatus"
		);

	VSS_BACKUPCALL_STATE stateSaved = x_StateUndefined;
    bool bLocked = false;
	UINT timestamp = 0;

    try
		{
		// validate that object has been initialized
		ValidateInitialized(ft);

		m_csState.Lock();
		bLocked = true;
		stateSaved = m_state;
		timestamp = ++m_timestampOperation;

		FreeWriterStatus();

        m_state = x_StateGatheringWriterStatus;
		m_rgWriterProp = new VSS_WRITER_PROP[m_cWriters];
		if (m_rgWriterProp == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Unable to allocate writer property array");

		CInternalWriterData *pData = m_pDataFirst;

		// initialize array with writers assuming that they didn't respond
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			m_rgWriterProp[iWriter].m_InstanceId = pData->m_idInstance;
			m_rgWriterProp[iWriter].m_ClassId = pData->m_idWriter;
			m_rgWriterProp[iWriter].m_pwszName = pData->m_bstrWriterName;
			m_rgWriterProp[iWriter].m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;
			pData = pData->m_pDataNext;
			}

		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter);
		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);

		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalGatherWriterStatus1");
		ft1.hr = pWriter->RequestWriterInfo
			(
			m_bstrSnapshotSetId,
			false,
			true,
			pDispatch
			);

        ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::RequestWriterInfo, Request Writer Status");

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (bLocked && timestamp == m_timestampOperation)
		{
		// look for writers that disappeared
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			if (m_rgWriterProp[iWriter].m_hrWriterFailure == VSS_E_WRITER_NOT_RESPONDING)
				{
				m_rgWriterProp[iWriter].m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;

				// check to see if either bootable state or service state writers
				// are missing
				if (m_rgWriterProp[iWriter].m_ClassId == idWriterBootableState ||
					m_rgWriterProp[iWriter].m_ClassId == idWriterServiceState)
					{
					// a key writer is missing meaning that the entire
					// infrastructure must be broken
					ft.hr = VSS_E_WRITER_INFRASTRUCTURE;
					ft.LogError(VSS_ERROR_WRITER_INFRASTRUCTURE, VSSDBG_XML);
					m_bGatherWriterStatusComplete = false;
					break;
					}

				// compute writer state based on where we are in the backup
				// sequence
				switch(stateSaved)
					{
					default:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_FREEZE;
						break;

					case x_StatePrepareForBackupSucceeded:
					case x_StatePrepareForBackupFailed:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_FAILED_AT_PREPARE_BACKUP;
						break;

					case x_StateBackupCompleteSucceeded:
					case x_StateBackupCompleteFailed:
						m_rgWriterProp[iWriter].m_nState = VSS_WS_STABLE;
						break;
					}
				try
					{
					ft.LogError(VSS_ERROR_WRITER_NOT_RESPONDING, VSSDBG_XML << m_rgWriterProp[iWriter].m_pwszName);
					}
				catch(...)
					{
					}
				}
			}

		if (ft.HrFailed())
			{
			try
				{
				delete m_rgWriterProp;
				}
			catch(...)
				{
				}

			m_rgWriterProp = NULL;
			}
		else
			m_bGatherWriterStatusComplete = true;

		m_state = stateSaved;
		m_timestampOperation++;
		m_csState.Unlock();
		}

    return ft.hr;
	}

// routine to call to complete GatherWriterStatus when
// IVssAsync::Cancel is called
void CVssBackupComponents::PostGatherWriterStatus
	(
	UINT timestamp,
	VSS_BACKUPCALL_STATE stateSaved
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostGatherWriterStatus");

	if (timestamp == m_timestampOperation)
		{
		m_timestampOperation++;
		m_bGatherWriterStatusComplete = true;
		m_state = stateSaved;
		m_csState.Unlock();
		}
	}
	

// get count of writers with status
//
// Returns:
//		S_OK if the operation is successful
//      E_INVALIDARG if pcWriters is NULL
//		VSS_E_BAD_STATE if GatherWriterStatusAsync was not called or is not complete
//
STDMETHODIMP CVssBackupComponents::GetWriterStatusCount
	(
	OUT UINT *pcWriters
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::GetWriterStatusCount");

	try
		{
		if (pcWriters == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer.");

		*pcWriters = NULL;

		if (!m_bGatherWriterStatusComplete)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"GatherWriterStatusAsync was not called or is not complete.");

		*pcWriters = m_cWriters;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}




// get status for a particular writer
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pStatus, pidWriter, pbstrWriter, or pidInstance is NULL
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_NOT_FOUND if iWriter specifies a non-existent writer
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterStatus
	(
	IN UINT iWriter,
	OUT VSS_ID *pidInstance,
	OUT VSS_ID *pidWriter,
	OUT BSTR *pbstrWriter,
	OUT VSS_WRITER_STATE *pStatus,
	OUT HRESULT *phrWriterFailure
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterStatus"
		);

    try
		{
		VssZeroOut(pidInstance);
		VssZeroOut(pbstrWriter);
		if (pStatus != NULL)
			*pStatus = VSS_WS_UNKNOWN;

		if (pidInstance == NULL ||
			pidWriter == NULL ||
			pbstrWriter == NULL ||
			pStatus == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		*pidWriter = GUID_NULL;

		// validate that object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);
		if (iWriter >= m_cWriters)
			ft.Throw(VSSDBG_XML, VSS_E_OBJECT_NOT_FOUND, L"Invalid writer selection");

		CComBSTR bstrWriter = m_rgWriterProp[iWriter].m_pwszName;
		if (!bstrWriter)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failure to allocate Writer name");

		*pidInstance = m_rgWriterProp[iWriter].m_InstanceId;
		*pidWriter = m_rgWriterProp[iWriter].m_ClassId;

		*pStatus = m_rgWriterProp[iWriter].m_nState;
		if (phrWriterFailure)
			*phrWriterFailure = m_rgWriterProp[iWriter].m_hrWriterFailure;

		*pbstrWriter = bstrWriter.Detach();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// free all writer status information
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::FreeWriterStatus()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterStatus");

	try
		{
		// validate that object is initialized
		ValidateInitialized(ft);
		CVssSafeAutomaticLock lock(m_csWriters);
		try
			{
			delete m_rgWriterProp;
			}
		catch(...)
			{
			}

		m_rgWriterProp = NULL;
        m_bGatherWriterStatusComplete = false;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// indicate that backupSucceded on a component
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wszComponentName is NULL or if the componentType is
//			not valid
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetBackupSucceeded
	(
	IN VSS_ID instanceId,
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bSucceeded
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SetBackupSucceeded"
		);

    try
		{
		// validate input parameters
		LPCWSTR wszComponentType = WszFromComponentType(ft, ct, true);
		if (wszComponentName == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Required input string parameter is NULL."
				);

        // validate that object initialized
        ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find the specified component
		CXMLNode node = FindComponent
							(
							ft,
							&instanceId,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

        // set backupSucceeded attribute on COMPONENT
		node.SetAttribute
			(
			x_wszAttrBackupSucceeded,
			WszFromBoolean(bSucceeded)
			);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// save document as an XML string
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pbstrXML is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SaveAsXML(BSTR *pbstrXML)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SaveAsXML"
		);

    try
		{
		// validate output parameter
		if (pbstrXML == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXML = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csDOM);

		*pbstrXML = m_doc.SaveAsXML();
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// signal BackupComplete event to the writers
HRESULT CVssBackupComponents::InternalBackupComplete()
	{
    CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalBackupComplete"
		);


	// protect state transition
	m_csState.Lock();
	UINT timestamp = ++m_timestampOperation;

    try
		{
		if (m_state != x_StateDoSnapshotSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        m_state = x_StateBackupComplete;

		// setup pointer to Writer event class
		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter);

		CComPtr<IDispatch> pDispatch;
		GetCallbackInterface(ft, &pDispatch);
		CVssFunctionTracer ft1(VSSDBG_XML, L"IVssWriter::InternalBackupComplete1");
		ft1.hr = pWriter->BackupComplete(m_bstrSnapshotSetId, pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::BackupComplete(%s)", m_bstrSnapshotSetId);
		if (timestamp == m_timestampOperation)
			m_state = x_StateBackupCompleteSucceeded;

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (timestamp == m_timestampOperation)
		{
		if (ft.HrFailed())
			m_state = x_StateBackupCompleteFailed;

		m_timestampOperation++;
		m_csState.Unlock();
		}

    return ft.hr;
	}

// routine called by IVssAsync::Cancel to cancel a backup complete operation
void CVssBackupComponents::PostBackupComplete(UINT timestamp)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostBackupComplete");

	if (timestamp == m_timestampOperation)
		{
		m_state = x_StateBackupCompleteSucceeded;
		m_timestampOperation++;
		m_csState.Unlock();
		}
	}

// signal BackupComplete event to the writers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		VSS_E_BAD_STATE if performing a restore or if the backup
//		components document is not initialized or if the stat is not
//		x_StateDoSnapshotSucceeded
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::BackupComplete(OUT IVssAsync **ppAsync)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::BackupComplete"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		// validate that the class is initialized
		ValidateInitialized(ft);
		
		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateDoSnapshotSucceeded)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
						(
						this,
						CVssAsyncBackup::VSS_AS_BACKUP_COMPLETE
						);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}


// add an ALTERNATE_LOCATION_MAPPING to a component on restore.
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if wsComponentName, wszPath, wszFilespec, or wszDestination
//			is NULL or if componentType is invalid	
//		VSS_E_BAD_STATE if the backup components document is not
//			initialized or if a backup is being performed.
//		VSS_E_OBJECT_NOT_FOUND if the specified component doesn't exist
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::AddAlternativeLocationMapping
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE componentType,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilespec,
	IN bool bRecursive,
	IN LPCWSTR wszDestination
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::AddAlternativeLocationMapping"
		);

    try
		{
		// validate input parameters
		LPCWSTR wszComponentType = WszFromComponentType(ft, componentType, true);
		if (wszComponentName == NULL ||
			wszFilespec == NULL ||
			wszPath == NULL ||
			wszDestination == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Required input string parameter is NULL."
				);

		CVssSafeAutomaticLock lock(m_csDOM);

        // find COMPONENT
		CXMLNode nodeComponent = FindComponent
							(
							ft,
							NULL,
							writerId,
							wszComponentType,
							wszLogicalPath,
							wszComponentName,
							false
							);

        // create ALTERNATE_LOCATION_MAPPING node
		CXMLNode node = m_doc.CreateNode
							(
							x_wszElementAlternateMapping,
							NODE_ELEMENT
							);

        // set attributes
        node.SetAttribute(x_wszAttrPath, wszPath);
		node.SetAttribute(x_wszAttrFilespec, wszFilespec);
		node.SetAttribute(x_wszAttrRecursive, WszFromBoolean(bRecursive));
		node.SetAttribute(x_wszAttrAlternatePath, wszDestination);

		// insert ALTERNATE_LOCATION_MAPPING node under COMPONENT node
		nodeComponent.InsertNode(node);
		}
	VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}

// signal BackupComplete event to the writers
HRESULT CVssBackupComponents::InternalPostRestore()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalPostRestore"
		);

	// protect state transition
	m_csState.Lock();
	LONGLONG timestamp = ++m_timestampOperation;
    try
		{
		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        m_state = x_StateRestore;

		// setup pointer to IVssWriter event class
		CComPtr<IVssWriter> pWriter;
		SetupWriter(ft, &pWriter);

		CComPtr<IDispatch> pDispatch;

		GetCallbackInterface(ft, &pDispatch);
		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalRestore1");

		ft1.hr = pWriter->PostRestore(pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::PostRestore");
		if (timestamp == m_timestampOperation)
            m_state = x_StateRestoreSucceeded;

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (timestamp == m_timestampOperation)
		{
		if (ft.HrFailed())
			m_state = x_StateRestoreFailed;

		m_timestampOperation++;
		m_csState.Unlock();
		}

    return ft.hr;
	}

void CVssBackupComponents::PostPostRestore(UINT timestamp)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PostPostRestore");

	if (timestamp == m_timestampOperation)
		{
		m_state = x_StateRestoreSucceeded;
		m_timestampOperation++;
		m_csState.Unlock();
		}
	}



// signal restore event to writers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		VSS_E_BAD_STATE if the backup components document is not
//			initialized or if a backup is being performed.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::PostRestore(OUT IVssAsync **ppAsync)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::PostRestore"
		);

    try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;

		ValidateInitialized(ft);
		if (!m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for backup");

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d for call to BackupComplete.",
				m_state
				);

        *ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
						(
						this,
						CVssAsyncBackup::VSS_AS_RESTORE
						);
		}
	VSS_STANDARD_CATCH(ft)


    return ft.hr;
	}

void CVssBackupComponents::FindAndValidateWriterData
	(
	IN VSS_ID idInstance,
	OUT UINT *piWriter
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FindAndValidateWriterData");

	// validate writer SID hasn't changed since GatherWriterMetadata
	// was called
	CInternalWriterData *pData = FindWriterData(idInstance, piWriter);
	if (pData == NULL)
		ft.Throw
			(
			VSSDBG_XML,
			E_ACCESSDENIED,
			L"Instance id was not discovered in Identify pass" WSTR_GUID_FMT,
			GUID_PRINTF_ARG(idInstance)
			);

	TOKEN_OWNER *pOwnerToken = GetClientTokenOwner(TRUE);

	if (!EqualSid(pData->m_pOwnerToken->Owner, pOwnerToken->Owner))
		{
		delete pOwnerToken;
		ft.Throw
			(
			VSSDBG_XML,
			E_ACCESSDENIED,
			L"SID for instance id does not match" WSTR_GUID_FMT,
			GUID_PRINTF_ARG(idInstance)
			);
		}

	delete pOwnerToken;
	}



// get content for a specific writer
// implements IVssWriterCallback::GetContent
//
// Returns:
//		S_OK if the operation is successful
//		S_FALSE if the object is not found
//		VSS_E_BAD_STATE if the caller is not responding to PrepareForBackup,
//			BackupComplete, or Restore
//		E_ACCESSDENIED if the caller is responding to Restore and is not
//			and administrator or if the writer is not participating in the
//			backup or is trying to impersonate another writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetContent
	(
	IN BSTR WriterInstanceId,
	OUT BSTR *pbstrXMLDocContent
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetContent"
		);

    try
		{
		// validate and initialize output parameter
		if (pbstrXMLDocContent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pbstrXMLDocContent = NULL;

		CVssID idInstance;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);

		// test state for validity
		// don't acquire m_csState as it is acquired by the call
		// to RequestWriterData in another thread.
		if (m_state != x_StatePrepareForBackup &&
			m_state != x_StateBackupComplete &&
			m_state != x_StateRestore)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Invalid state %d to request BACKUP_COMPONENTS content",
				m_state
				);


		// for now writers that participate in restore processing must
		// have administrative privileges
		if (m_state  == x_StateRestore)
			if (!IsAdministrator())
				ft.Throw
					(
					VSSDBG_XML,
					E_ACCESSDENIED,
					L"Caller must be Administrator to do a restore."
					);


		FindAndValidateWriterData(idInstance, NULL);
		CVssSafeAutomaticLock lockDOM(m_csDOM);
        m_doc.ResetToDocument();
        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			return S_FALSE;

        // find specific WRITER_COMPONENTS element
		bool bFound = false;
		do
			{
			// get instanceId value
			CComBSTR bstrVal;

			VSS_ID idFound;

			get_VSS_IDValue(ft, x_wszAttrInstanceId, &idFound);
			if (idInstance == idFound)
				{
				bFound = true;
				break;
				}
			} while(m_doc.FindElement(x_wszElementWriterComponents, FALSE));

        if (!bFound)
			return S_FALSE;


		CXMLDocument doc(m_doc.GetCurrentNode(), m_doc.GetInterface());
		CComBSTR bstrXMLDocContent = doc.SaveAsXML();

		// a root node, schema, and supplied document
		UINT cwcDoc = (UINT) g_cwcComponentMetadataXML + (UINT) wcslen(bstrXMLDocContent);

        // allocate string
        BSTR bstr = *pbstrXMLDocContent = SysAllocStringLen(NULL, cwcDoc);

		// check for allocation failure
		if (bstr == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Couldn't allocate BSTR");

		// setup pointer to beginning of string
		WCHAR *pwc = bstr;

		// copy in <root> <schema>
	    memcpy(pwc, g_ComponentMetadataXML, g_iwcComponentMetadataXMLEnd * sizeof(WCHAR));
		pwc += g_iwcComponentMetadataXMLEnd;

		// copy in document
		wcscpy(pwc, bstrXMLDocContent);
		pwc += wcslen(bstrXMLDocContent);

		// copy in </root>
		wcscpy(pwc, g_ComponentMetadataXML + g_iwcComponentMetadataXMLEnd);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// replace the contents of the backup components document
// implements IVssWriterCallback::SetContent
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the writer is not reponding to PrepareForBackup
//		E_ACCESSDENIED if the writer is not participating in the current
//			backup or another writer is trying to impersonate this writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::SetContent
	(
	IN BSTR WriterInstanceId,
	IN BSTR bstrXMLWriterComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::SetContent"
		);

    // validate state
	// don't acquire m_csState as it is acquired by the call
	if (m_state != x_StatePrepareForBackup)
		ft.hr = VSS_E_BAD_STATE;
	else
		ft.hr = AddWriterData(WriterInstanceId, NULL, NULL, bstrXMLWriterComponents, false);


	return ft.hr;
	}


// expose state of writer in response to RequestWriterMetadata
// implements IVssWriterCallback::ExposeCurrentState
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if WriterClassId, WriterInstanceId, bstrWriterName are
//			NULL or if nCurrentState is not a valid writer state
//		E_ACCESSDENIED if the writer is not participating in the current
//			backup or is trying to impersonate another writer.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::ExposeCurrentState
	(
	IN BSTR WriterInstanceId,
	IN VSS_WRITER_STATE nCurrentState,
	IN HRESULT hrWriterFailure
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ExposeCurrentState");

	try
		{
		if (WriterInstanceId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL required input parameter.");

		if (nCurrentState != VSS_WS_STABLE &&
			nCurrentState != VSS_WS_WAITING_FOR_FREEZE &&
			nCurrentState != VSS_WS_WAITING_FOR_THAW &&
			nCurrentState != VSS_WS_WAITING_FOR_BACKUP_COMPLETE &&
			nCurrentState != VSS_WS_FAILED_AT_IDENTIFY &&
			nCurrentState != VSS_WS_FAILED_AT_PREPARE_BACKUP &&
			nCurrentState != VSS_WS_FAILED_AT_PREPARE_SNAPSHOT &&
			nCurrentState != VSS_WS_FAILED_AT_FREEZE &&
			nCurrentState != VSS_WS_FAILED_AT_THAW)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Invalid Writer state");


		CVssID idInstance;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);

		UINT iWriter;
		FindAndValidateWriterData(idInstance, &iWriter);
		CVssSafeAutomaticLock lock(m_csWriters);

		BS_ASSERT(iWriter < m_cWriters);
		VSS_WRITER_PROP *pProp = &m_rgWriterProp[iWriter];
		pProp->m_nState = nCurrentState;
		pProp->m_hrWriterFailure = hrWriterFailure;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// Called to set the context for subsequent snapshot-related operations
// Not defined in client SKU
STDMETHODIMP CVssBackupComponents::SetContext
	(
    IN LONG lContext
    )
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetContext");

	BS_ASSERT(false);
	return E_NOTIMPL;

	UNREFERENCED_PARAMETER(lContext);
    }
    

// start snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pSnapshotSetId is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_SNAPSHOT_SET_IN_PROGRESS if a snapshot set is already started.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::StartSnapshotSet
	(
	OUT VSS_ID *pSnapshotSetId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::StartSnapshotSet");

	try
		{
		if (pSnapshotSetId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		*pSnapshotSetId = GUID_NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);

		if (m_state != x_StateInitialized)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_BAD_STATE,
				L"Unexpected call to PrepareForBackup in state %d.",
				m_state
				);

		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->StartSnapshotSet(pSnapshotSetId);
		if (!ft.HrFailed())
			{
			m_bstrSnapshotSetId = *pSnapshotSetId;
			if (m_bstrSnapshotSetId.Length() == 0)
				ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Failed to allocate BSTR.");

			m_state = x_StateSnapshotSetCreated;
			}
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// internal routine to setup the coordinator
// note that the m_csState critical section should be acquired
// before calling this routine.  Access to this routine must be
// single threaded
void CVssBackupComponents::SetupCoordinator(IN CVssFunctionTracer &ft)
	{
	if (m_pCoordinator)
		return;

    ft.LogVssStartupAttempt();
	ft.hr = CoCreateInstance
				(
				CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssCoordinator,
				(void **) &m_pCoordinator
			    );

    ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");
    }

// add a volume to a snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//		E_INVALIDARG if ppSnapshot is NULL

STDMETHODIMP CVssBackupComponents::AddToSnapshotSet
	(							
	IN VSS_PWSZ	pwszVolumeName, 			
	IN VSS_ID		ProviderId, 				
	OUT VSS_ID		*pSnapshotId
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddToSnapshot");

	try
		{
		if (pSnapshotId == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pSnapshotId = GUID_NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateSnapshotSetCreated)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call AddToSnapshotSet at this point");

		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->AddToSnapshotSet
						(
						pwszVolumeName,
						ProviderId,
						pSnapshotId
						);

        }
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
						
// create the snapshot set
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppAsync is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized,
//			if called during restore, or if not called after PrepareForBackup
//			was successful.
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::DoSnapshotSet
	(								
	OUT IVssAsync** ppAsync 					
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DoSnapshotSet");

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Output parameter.");

		*ppAsync = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		if (m_state != x_StateSnapshotSetCreated &&
			m_state != x_StatePrepareForBackupSucceeded)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot call DoSnapshotSet at this point.");

        // Execute DoSnapshotSet
		m_state = x_StateDoSnapshot;
		SetupCoordinator(ft);
        CComPtr<IVssAsync> ptrAsyncInternal;
		ft.hr = m_pCoordinator->DoSnapshotSet(NULL, &ptrAsyncInternal);

   		// create cover async object
		CVssAsyncCover::CreateInstance(this, ptrAsyncInternal, ppAsync);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		{

		AbortBackup();
		m_state = x_StateDoSnapshotFailed;
		}


	return ft.hr;
	}


// delete snapshots
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if eSourceObjectType is invalid, plDeletedSnapshots is
//			NULL, or pNonDeletedSnapshotID is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_OBJECT_NOT_FOUND if the specified snapshot doesn't exist.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::DeleteSnapshots
	(							
	IN VSS_ID			SourceObjectId, 		
	IN VSS_OBJECT_TYPE 	eSourceObjectType,		
	IN BOOL				bForceDelete,			
	OUT LONG*			plDeletedSnapshots,		
	OUT VSS_ID*			pNonDeletedSnapshotID	
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DeleteSnapshots");
	try
		{
		VssZeroOut(plDeletedSnapshots);
		VssZeroOut(pNonDeletedSnapshotID);
		if (plDeletedSnapshots == NULL || pNonDeletedSnapshotID == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_INVALIDARG,
				L"Null output parameter"
				);

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->DeleteSnapshots
			(
			SourceObjectId, 		
			eSourceObjectType,		
			bForceDelete,			
			plDeletedSnapshots,		
			pNonDeletedSnapshotID
			);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// query for either snapshot sets, snapshots, or providers
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if eQueriedObjectType is invalid, eReturnedObjectsType
//			is invalid or ppEnum is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_OBJECT_NOT_FOUND if the queried object doesn't exist.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		E_OUTOFMEMORY if an allocation failure occurs
//
STDMETHODIMP CVssBackupComponents::Query
	(										
	IN VSS_ID			QueriedObjectId,		
	IN VSS_OBJECT_TYPE eQueriedObjectType, 	
	IN VSS_OBJECT_TYPE eReturnedObjectsType,	
	OUT IVssEnumObject **ppEnum 				
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::Query");
	try
		{
		// validate and clear output parameter
		if (ppEnum == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppEnum = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->Query
			(
			QueriedObjectId,		
			eQueriedObjectType, 	
			eReturnedObjectsType,	
			ppEnum
			);

		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// Break the snapshot set
STDMETHODIMP CVssBackupComponents::BreakSnapshotSet
	(
	IN VSS_ID			SnapshotSetId
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::BreakSnapshotSet");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotSetId);
}


// Import snapshots
STDMETHODIMP CVssBackupComponents::ImportSnapshots
	(
	OUT IVssAsync**		ppAsync
	)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ImportSnapshots");

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(ppAsync);
}


// get interface to snapshot
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppSnap is NULL.
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is not an adminstrator
//		VSS_E_BAD_STATE if the backup components object is not initialized
//		VSS_E_OBJECT_NOT_FOUND if the snapshot id is invalid
//		E_NOINTERFACE if the SnapshotInterfaceId is not valid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetSnapshotProperties
	(								
	IN VSS_ID		SnapshotId, 			
	OUT VSS_SNAPSHOT_PROP	*pProp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::GetSnapshotProperties");

	try
		{
		if (pProp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		::VssZeroOut(pProp);

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->GetSnapshotProperties
					(
					SnapshotId,
					pProp
					);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// gather writer metadata
//
// Returns:
//		S_OK if the operation is successful.
//		E_INVAIDARG if pcWriters is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized,
//			if called during a restore operation or if called while
//			PrepareForBackup is in progress.
//		E_OUTOFMEMORY if an allocation failure occurs.

STDMETHODIMP CVssBackupComponents::GatherWriterMetadata
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GatherWriterMetadata"
		);

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

		*ppAsync = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		*ppAsync = CVssAsyncBackup::CreateInstanceAndStartJob
			(
			this,
			CVssAsyncBackup::VSS_AS_GATHER_WRITER_METADATA
			);
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of writers supplying metadata
//
// Returns:
//     VSS_E_BAD_STATE: if called when GatherWriterMetadata was not called or is in progress
//	   E_INVALIDARG: if pcWriters is NULL
//
STDMETHODIMP CVssBackupComponents::GetWriterMetadataCount
	(
	OUT UINT *pcWriters
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterMetadataCount"
		);

	try
		{
		if (pcWriters == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pcWriters = NULL;

		if (!m_bGatherWriterMetadataComplete)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Gather writer metadata is not complete");

		*pcWriters = m_cWriters;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// internal routine to gather writer metadata
// Returns:
//	   S_OK: if there are no errors.
//	   VSS_E_WRITER_INFRASTRUCTURE: either the service state or bootable state
//			writer did not respond.
//	   E_UNEXPECTED: for an unexpected error
//	   E_OUTOFMEMORY: for out of resources
//

HRESULT CVssBackupComponents::InternalGatherWriterMetadata()
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::InternalGatherWriterMetadata"
		);

    bool bLocked = false;
	VSS_BACKUPCALL_STATE stateSaved = x_StateUndefined;
	UINT timestamp = 0;

	try
		{
		// acquire critical section to change state
		m_csState.Lock();
		stateSaved = m_state;
		bLocked = true;
		timestamp = ++m_timestampOperation;


		if (m_state == x_StatePrepareForBackup)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Can't call this function while PrepareForBackup is in progress");

		m_state = x_StateGatheringWriterMetadata;

		// free existing writer data
		FreeAllWriters();

    	// start VSS service since it contains the MSDE Writer
		CComPtr<IVssCoordinator> pCoordinator;

        ft.LogVssStartupAttempt();
       	ft.hr = CoCreateInstance
				(
				CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssCoordinator,
				(void **) &pCoordinator
			    );

		ft.CheckForError(VSSDBG_XML, L"CoCreateInstance");

		CComPtr <IVssShim> pShim;
		// query interface for IVssShim interface
		ft.hr = pCoordinator->QueryInterface(IID_IVssShim, (void **) &pShim);
		if (ft.HrFailed())
			{
			BS_ASSERT(FALSE && "QI shouldn't fail");
			ft.LogError(VSS_ERROR_QI_IVSSSHIM_FAILED, VSSDBG_XML << ft.hr);
			ft.Throw
				(
                VSSDBG_XML,
				E_UNEXPECTED,
				L"QueryInterface failed.  hr = 0x%08lx", ft.hr
				);
			}

		// wait for subscriptions to complete
		ft.hr = pShim->WaitForSubscribingCompletion();
		if (ft.HrFailed())
			throw (HRESULT) (ft.hr);


		CComPtr<IVssWriter>pWriter;
		SetupWriter(ft, &pWriter);


        CComPtr<IUnknown> pUnknown = GetUnknown();
		CComPtr<IDispatch> pDispatch;
		ft.hr = pUnknown->SafeQI(IDispatch, &pDispatch);
		BS_ASSERT(!ft.HrFailed());
		if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IDISPATCH_FAILED, VSSDBG_XML << ft.hr);
			ft.Throw
				(
				VSSDBG_XML,
				E_UNEXPECTED,
				L"Error querying the IDispatch interface.  hr = 0x%08lx",
				ft.hr
				);
            }

		CVssFunctionTracer ft1(VSSDBG_XML, L"CVssBackupComponents::InternalGatherWriterMetadata1");
        ft1.hr = pWriter->RequestWriterInfo(NULL, true, false, pDispatch);
		ft1.TranslateWriterReturnCode(VSSDBG_XML, L"IVssWriter::RequestWriterInfo, GatherWriterMetadata");
		if (!ft.HrFailed())
			{
			ft.hr = PostGatherWriterMetadata(timestamp, stateSaved);
			bLocked = false;
			}

		ClearPublisherFilter(pWriter);
		}
	VSS_STANDARD_CATCH(ft)

	if (bLocked && m_timestampOperation == timestamp)
		{
		// restore state to what it was upon entry to this routine.
		m_state = stateSaved;
		m_timestampOperation++;
		m_csState.Unlock();
		}

	return ft.hr;
	}

// work to do after gather writer metadata is complete.  This may
// be called by either InternalGatherWriterMetadata or IVssAsync::Cancel
HRESULT CVssBackupComponents::PostGatherWriterMetadata
	(
	UINT timestamp,
	VSS_BACKUPCALL_STATE stateSaved
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"PostGatherWriterMetadata");

	// only perform operation if timestamp matches, i.e., PostGatherWriterMetadata
	// was not already called on a different thread.

	CVssSafeAutomaticLock lock(m_csWriters);

	if (timestamp == m_timestampOperation)
		{
		bool fFoundBootableStateWriter = false;
		bool fFoundSystemServiceWriter = false;

		CInternalWriterData *pData = m_pDataFirst;
		
		for(UINT iWriter = 0; iWriter < m_cWriters; iWriter++)
			{
			if (pData->m_idWriter == idWriterBootableState)
				fFoundBootableStateWriter = true;

			if (pData->m_idWriter == idWriterServiceState)
				fFoundSystemServiceWriter = true;

			pData = pData->m_pDataNext;
			}

		// check that both the service state and bootable state writer
		// responded.  If not there is an error.
		if (!fFoundBootableStateWriter || !fFoundSystemServiceWriter)
			{
			ft.hr = VSS_E_WRITER_INFRASTRUCTURE;
			ft.LogError(VSS_ERROR_WRITER_INFRASTRUCTURE, VSSDBG_XML);
			}

		if (!ft.HrFailed())
			m_bGatherWriterMetadataComplete = true;

		m_timestampOperation++;
		m_state = stateSaved;
		m_csState.Unlock();
		}

	return ft.hr;
	}



// internal routine to add data to the writer data queue
HRESULT CVssBackupComponents::AddWriterData
	(
	IN BSTR WriterInstanceId,
	IN BSTR WriterClassId,
	IN BSTR bstrWriterName,
	IN BSTR bstrWriterXMLDocument,
	IN bool bReinitializing
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddWriterData");

	TOKEN_OWNER *pOwnerToken = GetClientTokenOwner(TRUE);
	try
		{
		CVssID idInstance, idWriter;
		idInstance.Initialize(ft, WriterInstanceId, E_INVALIDARG);
		if (bReinitializing)
			{
			idWriter.Initialize(ft, WriterClassId, E_INVALIDARG);
			if (bstrWriterName == NULL)
				ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL Required input parameter.");
			}

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csWriters);

		// caller must be backup operator or
		if (bReinitializing)
			{
			if (FindWriterData(idInstance))
				{
				ft.LogError(VSS_ERROR_DUPLICATE_WRITERS, VSSDBG_XML << idInstance);
				ft.Throw
					(
					VSSDBG_XML,
					E_UNEXPECTED,
					L"Two writers with identical instance ids. %s",
					WriterInstanceId
					);
                }

			CInternalWriterData *pData = new CInternalWriterData();
			if (pData == NULL)
				ft.Throw
					(
					VSSDBG_XML,
					E_OUTOFMEMORY,
					L"Cannot create CInternalWriterMetadata because of allocation failure"
					);

			pData->Initialize
				(
				idInstance,
				idWriter,
			    bstrWriterName,
				bstrWriterXMLDocument,
				pOwnerToken
				);

			pOwnerToken = NULL;
			pData->m_pDataNext = m_pDataFirst;
			m_pDataFirst = pData;
			m_cWriters++;
			}
		else
			{
			CInternalWriterData *pData = FindWriterData(idInstance);
			if (pData == NULL)
				ft.Throw
					(
					VSSDBG_GEN,
					E_ACCESSDENIED,
					L"Didn't find writer with instance id. %s",
					WriterInstanceId
					);

            if (!EqualSid(pData->m_pOwnerToken->Owner, pOwnerToken->Owner))
				ft.Throw
					(
					VSSDBG_XML,
					E_ACCESSDENIED,
					L"SID didn't match initialization sid"
					);

			BS_ASSERT(!pData->m_bstrWriterComponents);
			pData->SetComponents(bstrWriterXMLDocument);
			}
		}
	VSS_STANDARD_CATCH(ft)

	delete pOwnerToken;

	return ft.hr;
	}


// a single writer exposing its data
// implements IVssWriterCallback::ExposeWriterMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the oepration is not in response to
//			a GatherWriterMetadata call (called in OnIdentify)
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::ExposeWriterMetadata
	(
	IN BSTR WriterInstanceId,
	IN BSTR WriterClassId,
	IN BSTR bstrWriterName,
	IN BSTR bstrWriterXMLMetadata
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::ExposeWriterMetadata"
		);

    // note that the state is already locked by another thread holding
	// performing RequestWriterInfo.
	if (m_state != x_StateGatheringWriterMetadata)
		ft.hr = VSS_E_BAD_STATE;
	else
		// add data to writers list
		ft.hr = AddWriterData
			(
			WriterInstanceId,
			WriterClassId,
			bstrWriterName,
			bstrWriterXMLMetadata,
			true
			);

	return ft.hr;
	}
		
// get metadata for a specific writer
// implements IVssBackupComponents::GetWriterMetadata
// caller is responsible for calling IVssExineWriterMetadata::Release on the returned object
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pidInstance or ppMetadata is NULL.
//		VSS_E_BAD_STATE if the backup components object is not initialized
//			or this is performed during a RESTORE operation
//		VSS_E_OBJECT_NOT_FOUND if iWriter does not refer to a writer
//		VSS_E_CORRUPT_XML_DOCUMENT if the XML document from the writer is invalid
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterMetadata
	(
	IN UINT iWriter,
	OUT VSS_ID *pidInstance,
	OUT IVssExamineWriterMetadata **ppMetadata
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponents::GetWriterMetadata"
		);

	CVssExamineWriterMetadata *pvem = NULL;
    try
		{
		if (pidInstance == NULL || ppMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameters to null
		*pidInstance = GUID_NULL;
		*ppMetadata = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		// protect writer information list
		CVssSafeAutomaticLock lock(m_csWriters);

		// check that writer # is within range
		if (iWriter > m_cWriters)
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"iWriter %d > # of writers(%d)",
				iWriter,
				m_cWriters
				);

		// find specific element in list
        CInternalWriterData *pMetadata = m_pDataFirst;
		for(UINT i = 0; i < iWriter; i++)
			{
			BS_ASSERT(pMetadata != NULL);
			pMetadata = pMetadata->m_pDataNext;
			}

		BS_ASSERT(pMetadata != NULL);

		// allocate object
		pvem = new CVssExamineWriterMetadata;

		// check for allocation failure
		if (pvem == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssExamineWriterMetadata due to allocation failure."
				);

        // 2nd phases of construction
        if (!pvem->Initialize(pMetadata->m_bstrWriterMetadata))
			{
			ft.LogError(VSS_ERROR_INVALID_XML_DOCUMENT_FROM_WRITER, VSSDBG_XML << pMetadata->m_idInstance);
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_CORRUPT_XML_DOCUMENT,
				L"Metadata supplied by writer {%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x} is invalid.",
				GUID_PRINTF_ARG(pMetadata->m_idInstance)
				);
            }

        // return instanceId
        *pidInstance = pMetadata->m_idInstance;

		// return IVssExamineWriterMetadata interface
		*ppMetadata = (IVssExamineWriterMetadata *) pvem;

		// set reference count to 1
		pvem->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	// delete object if failure after allocation
	if (ft.HrFailed())
		delete pvem;

	return ft.hr;
	}

// free writer metadata
// implements IVssBackupComponents::FreeWriterMetadata
//
// Returns:
//		S_OK if the operation is successful
//		VSS_E_BAD_STATE if the backup components object is not initialized
//			or if this is a Restore operation

STDMETHODIMP CVssBackupComponents::FreeWriterMetadata()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterMetadata");

	try
		{
		// validate that the object is initialized
		ValidateInitialized(ft);

		// secure writer list data structure
		CVssSafeAutomaticLock lock(m_csWriters);

		// loop through linked elements deleting each one
		CInternalWriterData *pMetadata;
		UINT iWriter = 0;
		for (pMetadata = m_pDataFirst; iWriter < m_cWriters; iWriter++)
			{
			BS_ASSERT(pMetadata != NULL);

			// free up bstring
			pMetadata->m_bstrWriterMetadata.Empty();
			pMetadata = pMetadata->m_pDataNext;
			}
		}
	VSS_STANDARD_CATCH(ft)

	m_bGatherWriterMetadataComplete = false;
	return ft.hr;
	}


// free component metadata, i.e., writer components associated with
// each writer in the backup
void CVssBackupComponents::FreeWriterComponents()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::FreeWriterMetadata");

	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	try
		{
		// loop through linked elements deleting each one
		CInternalWriterData *pMetadata;
		UINT iWriter = 0;
		for (pMetadata = m_pDataFirst; iWriter < m_cWriters; iWriter++)
			{
			BS_ASSERT(pMetadata != NULL);

			// free up bstring
			pMetadata->m_bstrWriterComponents.Empty();
			pMetadata = pMetadata->m_pDataNext;
			}
		}
	VSS_STANDARD_CATCH(ft)
	}





// free up writer metadata
// internal routine called during GatherWriterMetadata
void CVssBackupComponents::FreeAllWriters()
	{
	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	// loop through linked elements deleting each one
	CInternalWriterData *pMetadata, *pMetadataNext;
	for (pMetadata = m_pDataFirst; m_cWriters > 0; m_cWriters--)
		{
		BS_ASSERT(pMetadata != NULL);
		pMetadataNext = pMetadata->m_pDataNext;
		delete pMetadata;
		pMetadata = pMetadataNext;
		}

	// clear head of list
	m_pDataFirst = NULL;
	}

// find writer data for a writer with a specific instance id
CInternalWriterData *CVssBackupComponents::FindWriterData
	(
	VSS_ID idInstance,
	UINT *piWriter
	)
	{
	// secure writer list data structure
	CVssSafeAutomaticLock lock(m_csWriters);

	// loop through linked elements deleting each one
	CInternalWriterData *pMetadata;
	UINT iWriter = 0;
	for (pMetadata = m_pDataFirst; iWriter < m_cWriters ; iWriter++)
		{
		BS_ASSERT(pMetadata != NULL);
		if (pMetadata->m_idInstance == idInstance)
			{
			if (piWriter)
				*piWriter = iWriter;

			return pMetadata;
			}

		pMetadata = pMetadata->m_pDataNext;
		}

	return NULL;
	}



// get count of WRITER_COMPONENTS elements in a BACKUP_COMPONENTS document
// implements IVssBackupComponents::GetWriterComponentsCount
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if pcComponents is NULL
//		VSS_E_BAD_STATE if the backup components document is not initialized
//	    E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterComponentsCount
	(
	OUT UINT *pcComponents
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssWriterComponents::GetWriterComponentsCount"
		);

    try
		{
		// validate output parameter
		if (pcComponents == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*pcComponents = 0;

		// validate that the object is initialized
		ValidateInitialized(ft);


		CVssSafeAutomaticLock lock(m_csDOM);
		// reposition to top of document
		m_doc.ResetToDocument();

        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			return S_OK;

		UINT cComponents = 0;
        // count WRITER_COMPONENTS elements
		do
			{
			cComponents++;
			} while(m_doc.FindElement(x_wszElementWriterComponents, FALSE));

		*pcComponents = cComponents;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain a specific WRITER_COMPONENTS element
// implements IVssBackupComponents::GetWriterComponents
// caller is responsible for calling IVssWriterComponents::Release
// on the output parameter
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppWriter is NULL
//		VSS_E_OBJECT_NOT_FOUND if the specified component is not found
//		E_OUTOFMEMORY if an allocation failure occurs

STDMETHODIMP CVssBackupComponents::GetWriterComponents
	(
	IN UINT iWriter,
	OUT IVssWriterComponentsExt **ppWriter
	)
	{
	CVssFunctionTracer ft
		(
		VSSDBG_XML,
		L"CVssBackupComponentsDoc::GetWriterComponents"
		);

	// object deleted in case of failure
    CVssWriterComponents *pWriterComponents = NULL;
	try
		{
		// validate output parameter
		if (ppWriter == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// initialize output parameter
		*ppWriter = NULL;

		// validate that the object is initialized
		ValidateInitialized(ft);

		// obtain lock to protect access to DOM document
		CVssSafeAutomaticLock lock(m_csDOM);

		// reposition to top of document
		m_doc.ResetToDocument();

        // find first WRITER_COMPONENTS element
        if (!m_doc.FindElement(x_wszElementWriterComponents, TRUE))
			ft.Throw
				(
				VSSDBG_XML,
				VSS_E_OBJECT_NOT_FOUND,
				L"Couldn't find %d WRITER_COMPONENT.",
				iWriter
				);

        // skip to selected WRITER_COMPONENTS element
        for(UINT i = 0; i < iWriter; i++)
			{
			if (!m_doc.FindElement(x_wszElementWriterComponents, FALSE))
				ft.Throw
					(
					VSSDBG_XML,
					VSS_E_OBJECT_NOT_FOUND,
					L"Couldn't find %d WRITER_COMPONENT.",
					iWriter
					);
            }

		// allocate CVssWriterComponents object
	    pWriterComponents = new CVssWriterComponents
								(
								m_doc.GetCurrentNode(),
								m_doc.GetInterface(),
								false
								);

		// validate that memory allocation succeeded
		if (pWriterComponents == NULL)
			ft.Throw
				(
				VSSDBG_XML,
				E_OUTOFMEMORY,
				L"Cannot create CVssWriterComponents due to allocation failure."
				);

        // 2nd phase of initialization
        pWriterComponents->Initialize(false);

		// transfer ownership of pointer
        *ppWriter = (IVssWriterComponentsExt *) pWriterComponents;

		// set reference count to 1
        ((IVssWriterComponentsExt *) pWriterComponents)->AddRef();

		// transfer ownership to output pointer
		pWriterComponents = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	// delete object if failure after allocation
	delete pWriterComponents;

	return ft.hr;
	}

	// Called by the requestor to check if a certain volume is supported.
STDMETHODIMP CVssBackupComponents::IsVolumeSupported
		(										
		IN VSS_ID ProviderId,		
        IN VSS_PWSZ pwszVolumeName,
        IN BOOL * pbSupportedByThisProvider
		)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::IsVolumeSupported");

	try
		{
		if (pbSupportedByThisProvider == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"Output parameter is NULL");

		*pbSupportedByThisProvider = NULL;

		if (m_bRestore)
			ft.Throw(VSSDBG_XML, VSS_E_BAD_STATE, L"Cannot use this method for restore");

		// validate that the object is initialized
		ValidateInitialized(ft);

		CVssSafeAutomaticLock lock(m_csState);
		SetupCoordinator(ft);
		ft.hr = m_pCoordinator->IsVolumeSupported
			(
			ProviderId,		
			pwszVolumeName, 	
			pbSupportedByThisProvider
			);

        }
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// various not implemented methods

// indicate that only ranges in the file are to be backed up
STDMETHODIMP CVssComponent::AddPartialFile
	(
	IN LPCWSTR wszPath,
	IN LPCWSTR wszFilename,
	IN LPCWSTR wszRanges,
	IN LPCWSTR wszMetadata
	)
	{
	UNREFERENCED_PARAMETER(wszPath);
	UNREFERENCED_PARAMETER(wszFilename);
	UNREFERENCED_PARAMETER(wszRanges);
	UNREFERENCED_PARAMETER(wszMetadata);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddPartialFile");
	return E_NOTIMPL;
	}

// get count of partial file declarations
STDMETHODIMP CVssComponent::GetPartialFileCount
	(
	OUT UINT *pcPartialFiles
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPartialFileCount");

	try
		{
		VssZeroOut(pcPartialFiles);
		if (pcPartialFiles == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// get a partial file declaration
STDMETHODIMP CVssComponent::GetPartialFile
	(
	IN UINT iPartialFile,
	OUT BSTR *pbstrPath,
	OUT BSTR *pbstrFilename,
	OUT BSTR *pbstrRange,
	OUT BSTR *pbstrMetadata
	)
	{
	UNREFERENCED_PARAMETER(iPartialFile);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPartialFile");
	try
		{
		VssZeroOut(pbstrPath);
		VssZeroOut(pbstrFilename);
		VssZeroOut(pbstrRange);
		VssZeroOut(pbstrMetadata);

		if (pbstrPath == NULL ||
			pbstrFilename == NULL ||
            pbstrRange == NULL ||
			pbstrMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// determine if the component is selected to be restored
STDMETHODIMP CVssComponent::IsSelectedForRestore
	(
	OUT bool *pbSelectedForRestore
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::IsSelectedForRestore");

	try
		{
		VssZeroOut(pbSelectedForRestore);
		if (pbSelectedForRestore == NULL)
			ft.Throw(VSSDBG_XML, E_NOTIMPL, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

STDMETHODIMP CVssComponent::GetAdditionalRestores
	(
	OUT bool *pbAdditionalRestores
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetAdditionalRestores");
	try
		{
		VssZeroOut(pbAdditionalRestores);
		if (pbAdditionalRestores == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// get count of new target specifications
STDMETHODIMP CVssComponent::GetNewTargetCount
	(
	OUT UINT *pcNewTarget
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetNewTargetCount");

	try
		{
		VssZeroOut(pcNewTarget);

		if (pcNewTarget == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

STDMETHODIMP CVssComponent::GetNewTarget
	(
	IN UINT iNewTarget,
	OUT IVssWMFiledesc **ppFiledesc
	)
	{
	UNREFERENCED_PARAMETER(iNewTarget);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetNewTarget");

	try
		{
		VssZeroOut(ppFiledesc);
		if (ppFiledesc == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// add a directed target specification
STDMETHODIMP CVssComponent::AddDirectedTarget
	(
	IN LPCWSTR wszSourcePath,
	IN LPCWSTR wszSourceFilename,
	IN LPCWSTR wszSourceRangeList,
	IN LPCWSTR wszDestinationPath,
	IN LPCWSTR wszDestinationFilename,
	IN LPCWSTR wszDestinationRangeList
	)
	{
	UNREFERENCED_PARAMETER(wszSourcePath);
	UNREFERENCED_PARAMETER(wszSourceFilename);
	UNREFERENCED_PARAMETER(wszSourceRangeList);
	UNREFERENCED_PARAMETER(wszDestinationPath);
	UNREFERENCED_PARAMETER(wszDestinationFilename);
	UNREFERENCED_PARAMETER(wszDestinationRangeList);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::AddDirectedTarget");

	return E_NOTIMPL;
	}

// get count of directed target specifications
STDMETHODIMP CVssComponent::GetDirectedTargetCount
	(
	OUT UINT *pcDirectedTarget
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetDirectedTargetCount");

	try
		{
		VssZeroOut(pcDirectedTarget);

		if (pcDirectedTarget == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output paramter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
		
// obtain a particular directed target specification
STDMETHODIMP CVssComponent::GetDirectedTarget
	(
	IN UINT iDirectedTarget,
	OUT BSTR *pbstrSourcePath,
	OUT BSTR *pbstrSourceFileName,
	OUT BSTR *pbstrSourceRangeList,
	OUT BSTR *pbstrDestinationPath,
	OUT BSTR *pbstrDestinationFilename,
	OUT BSTR *pbstrDestinationRangeList
	)
	{
	UNREFERENCED_PARAMETER(iDirectedTarget);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetDirectedTarget");

	try
		{
		VssZeroOut(pbstrSourcePath);
		VssZeroOut(pbstrSourceFileName);
		VssZeroOut(pbstrSourceRangeList);
		VssZeroOut(pbstrDestinationPath);
		VssZeroOut(pbstrDestinationFilename);
		VssZeroOut(pbstrDestinationRangeList);

		if (pbstrSourcePath == NULL ||
			pbstrSourceFileName == NULL ||
			pbstrSourceRangeList == NULL ||
			pbstrDestinationPath == NULL ||
			pbstrDestinationFilename == NULL ||
			pbstrDestinationRangeList == NULL)
			ft.Throw(VSSDBG_XML, E_NOTIMPL, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set restore metadata associated with the component
STDMETHODIMP CVssComponent::SetRestoreMetadata
	(
	IN LPCWSTR wszRestoreMetadata
	)
	{
	UNREFERENCED_PARAMETER(wszRestoreMetadata);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetRestoreMetadata");

	return E_NOTIMPL;
	}

// obtain restore metadata associated with the component
STDMETHODIMP CVssComponent::GetRestoreMetadata
	(
	OUT BSTR *pbstrRestoreMetadata
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreMetadata");

	try
		{
		VssZeroOut(pbstrRestoreMetadata);

		if (pbstrRestoreMetadata == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set the restore target
STDMETHODIMP CVssComponent::SetRestoreTarget
	(
	IN VSS_RESTORE_TARGET target
	)
	{
	UNREFERENCED_PARAMETER(target);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetRestoreTarget");

	return E_NOTIMPL;
	}

// obtain the restore target
STDMETHODIMP CVssComponent::GetRestoreTarget
	(
	OUT VSS_RESTORE_TARGET *pTarget
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreTarget");
	try
		{
		VssZeroOut(pTarget);
		if (pTarget == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set failure message during pre restore event
STDMETHODIMP CVssComponent::SetPreRestoreFailureMsg
	(
	IN LPCWSTR wszPreRestoreFailureMsg
	)
	{
    UNREFERENCED_PARAMETER(wszPreRestoreFailureMsg);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetPreRestoreFailureMsg");

	return E_NOTIMPL;
	}


// obtain failure message during pre restore event
STDMETHODIMP CVssComponent::GetPreRestoreFailureMsg
	(
	OUT BSTR *pbstrPreRestoreFailureMsg
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPreRestoreFailureMsg");
	try
		{
		VssZeroOut(pbstrPreRestoreFailureMsg);

		if (pbstrPreRestoreFailureMsg == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// set the failure message during the post restore event
STDMETHODIMP CVssComponent::SetPostRestoreFailureMsg
	(
	IN LPCWSTR wszPostRestoreFailureMsg
	)
	{
	UNREFERENCED_PARAMETER(wszPostRestoreFailureMsg);
	CVssFunctionTracer(VSSDBG_XML, L"CVssComponent::SetPostRestoreFailureMsg");

	return E_NOTIMPL;
	}

// obtain the failure message set during the post restore event
STDMETHODIMP CVssComponent::GetPostRestoreFailureMsg
	(
	OUT BSTR *pbstrPostRestoreFailureMsg
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPostRestoreFailureMsg");

	try
		{
		VssZeroOut(pbstrPostRestoreFailureMsg);

		if (pbstrPostRestoreFailureMsg == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft);

	return ft.hr;
	}

// set the backup stamp of the backup
STDMETHODIMP CVssComponent::SetBackupStamp
	(
	IN LPCWSTR wszBackupStamp
	)
	{
	UNREFERENCED_PARAMETER(wszBackupStamp);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::SetBackupStamp");

	return E_NOTIMPL;
	}

// obtain the stamp of the backup
STDMETHODIMP CVssComponent::GetBackupStamp
	(
	OUT BSTR *pbstrBackupStamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetBackupStamp");

	try
		{
		VssZeroOut(pbstrBackupStamp);

		if (pbstrBackupStamp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_INVALIDARG;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// obtain the backup stamp that the differential or incremental
// backup is baed on
STDMETHODIMP CVssComponent::GetPreviousBackupStamp
	(
	OUT BSTR *pbstrBackupStamp
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetPreviousBackupStamp");

	try
		{
		VssZeroOut(pbstrBackupStamp);
		if (pbstrBackupStamp == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain backup options for the writer
STDMETHODIMP CVssComponent::GetBackupOptions
	(
	OUT BSTR *pbstrBackupOptions
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetBackupOptions");

	try
		{
		VssZeroOut(pbstrBackupOptions);
		if (pbstrBackupOptions == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain the restore options
STDMETHODIMP CVssComponent::GetRestoreOptions
	(
	OUT BSTR *pbstrRestoreOptions
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreOptions");

	try
		{
		VssZeroOut(pbstrRestoreOptions);

		if (pbstrRestoreOptions == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain count of subcomponents to be restored
STDMETHODIMP CVssComponent::GetRestoreSubcomponentCount
	(
	OUT UINT *pcRestoreSubcomponent
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreSubcomponentCount");

	try
		{
		VssZeroOut(pcRestoreSubcomponent);

		if (pcRestoreSubcomponent == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// obtain a particular subcomponent to be restored
STDMETHODIMP CVssComponent::GetRestoreSubcomponent
	(
	UINT iComponent,
	OUT BSTR *pbstrLogicalPath,
	OUT BSTR *pbstrComponentName,
	OUT bool *pbRepair
	)
	{
	UNREFERENCED_PARAMETER(iComponent);
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetRestoreSubcomponent");

	try
		{
		VssZeroOut(pbstrLogicalPath);
		VssZeroOut(pbstrComponentName);
		VssZeroOut(pbRepair);

		if (pbstrLogicalPath == NULL ||
			pbstrComponentName == NULL ||
			pbRepair == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// obtain whether files were successfully restored
STDMETHODIMP CVssComponent::GetFileRestoreStatus
	(
	OUT VSS_FILE_RESTORE_STATUS *pStatus
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssComponent::GetFileRestoreStatus");

	try
		{
		VssZeroOut(pStatus);

		if (pStatus == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

STDMETHODIMP CVssComponent::AddDifferencedFilesByLastModifyTime
    (
    IN LPCWSTR wszPath,
    IN LPCWSTR wszFilespec,
    IN BOOL bRecursive,
    IN FILETIME ftLastModifyTime 
    )
    {    
    UNREFERENCED_PARAMETER(wszPath);
    UNREFERENCED_PARAMETER(wszFilespec);
    UNREFERENCED_PARAMETER(bRecursive);
    UNREFERENCED_PARAMETER(ftLastModifyTime);
        return E_NOTIMPL;
    }

STDMETHODIMP CVssComponent::AddDifferencedFilesByLastModifyLSN
    (
    IN LPCWSTR wszPath,
    IN LPCWSTR wszFilespec,
    IN BOOL bRecursive,
    IN BSTR bstrLsnString
    )
    {
        UNREFERENCED_PARAMETER(wszPath);
        UNREFERENCED_PARAMETER(wszFilespec);
        UNREFERENCED_PARAMETER(bRecursive);
        UNREFERENCED_PARAMETER(bstrLsnString);
        return E_NOTIMPL;
    }

STDMETHODIMP CVssComponent::GetDifferencedFilesCount
    (
    OUT UINT *pcDifferencedFiles
    )
    {
    UNREFERENCED_PARAMETER(pcDifferencedFiles);
    return E_NOTIMPL;
    }

STDMETHODIMP CVssComponent::GetDifferencedFile
    (
    IN UINT iDifferencedFile,
    OUT BSTR *pbstrPath,
    OUT BSTR *pbstrFilespec,
    OUT BOOL *pbRecursive,
    OUT BSTR *pbstrLsnString,
    OUT FILETIME *pftLastModifyTime
    )
    {
    UNREFERENCED_PARAMETER(iDifferencedFile);
    UNREFERENCED_PARAMETER(pbstrPath);
    UNREFERENCED_PARAMETER(pbstrFilespec);
    UNREFERENCED_PARAMETER(pbRecursive);
    UNREFERENCED_PARAMETER(pbstrLsnString);
    UNREFERENCED_PARAMETER(pftLastModifyTime);
    
    return E_NOTIMPL;
    }

// set backup options for the writer
STDMETHODIMP CVssBackupComponents::SetBackupOptions
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszBackupOptions
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszBackupOptions);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetBackupOptions");

	return E_NOTIMPL;
	}

// indicate that a given component is selected to be restored
STDMETHODIMP CVssBackupComponents::SetSelectedForRestore
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bSelectedForRestore
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(bSelectedForRestore);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetSelectedForRestore");

	return E_NOTIMPL;
	}



// set restore options for the writer
STDMETHODIMP CVssBackupComponents::SetRestoreOptions
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszRestoreOptions
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszRestoreOptions);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetRestoreOptions");

	return E_NOTIMPL;
	}

// indicate that additional restores will follow
STDMETHODIMP CVssBackupComponents::SetAdditionalRestores
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN bool bAdditionalRestores
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(bAdditionalRestores);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetAdditionalRestores");

	return E_NOTIMPL;
	}

// requestor indicates whether files were successfully restored
STDMETHODIMP CVssBackupComponents::SetFileRestoreStatus
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN VSS_FILE_RESTORE_STATUS status
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
    UNREFERENCED_PARAMETER(status);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetFileRestoreStatus");

	return E_NOTIMPL;
	}

STDMETHODIMP CVssBackupComponents::AddNewTarget
    (
    IN VSS_ID writerId,
    IN VSS_COMPONENT_TYPE ct,
    IN LPCWSTR wszLogicalPath,
    IN LPCWSTR wszComponentName,
    IN LPCWSTR wszPath,
    IN LPCWSTR wszFileName,
    IN bool bRecursive,
    IN LPCWSTR wszAlternatePath
    ) 
    {
    UNREFERENCED_PARAMETER(writerId);
    UNREFERENCED_PARAMETER(ct);
    UNREFERENCED_PARAMETER(wszLogicalPath);
    UNREFERENCED_PARAMETER(wszComponentName);
    UNREFERENCED_PARAMETER(wszPath);
    UNREFERENCED_PARAMETER(wszFileName);
    UNREFERENCED_PARAMETER(bRecursive);
    UNREFERENCED_PARAMETER(wszAlternatePath);

    return E_NOTIMPL;
    }

STDMETHODIMP CVssBackupComponents::SetRangesFilePath
   	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,    		
   	IN UINT iPartialFile,
   	IN LPCWSTR wszRangesFile
   	)
	{
    UNREFERENCED_PARAMETER(writerId);
    UNREFERENCED_PARAMETER(ct);
    UNREFERENCED_PARAMETER(wszLogicalPath);
    UNREFERENCED_PARAMETER(wszComponentName);
    UNREFERENCED_PARAMETER(iPartialFile);
    UNREFERENCED_PARAMETER(wszRangesFile);

    return E_NOTIMPL;
	}

// set the backup stamp that the differential or incremental
// backup is based on
STDMETHODIMP CVssBackupComponents::SetPreviousBackupStamp
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE ct,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszPreviousBackupStamp
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(ct);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszPreviousBackupStamp);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::SetPreviousBackupStamp");

	return E_NOTIMPL;
	}

		
    // add a subcomponent to be restored
STDMETHODIMP CVssBackupComponents::AddRestoreSubcomponent
	(
	IN VSS_ID writerId,
	IN VSS_COMPONENT_TYPE componentType,
	IN LPCWSTR wszLogicalPath,
	IN LPCWSTR wszComponentName,
	IN LPCWSTR wszSubLogicalPath,
	IN LPCWSTR wszSubComponentName,
	IN bool bRepair
	)
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(componentType);
	UNREFERENCED_PARAMETER(wszLogicalPath);
	UNREFERENCED_PARAMETER(wszComponentName);
	UNREFERENCED_PARAMETER(wszSubLogicalPath);
	UNREFERENCED_PARAMETER(wszSubComponentName);
	UNREFERENCED_PARAMETER(bRepair);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::AddRestoreSubcomponent");

	return E_NOTIMPL;
	}



// signal PreRestore event to the writers
STDMETHODIMP CVssBackupComponents::PreRestore
	(
	OUT IVssAsync **ppAsync
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::PreRestore");

	try
		{
		if (ppAsync == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		*ppAsync = NULL;
		ft.hr = E_NOTIMPL;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}


// called to disable writer classes
STDMETHODIMP CVssBackupComponents::DisableWriterClasses
	(
	IN const VSS_ID *rgWriterClassId,
	IN UINT cClassId
	)
	{
	UNREFERENCED_PARAMETER(rgWriterClassId);
	UNREFERENCED_PARAMETER(cClassId);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DisableWriterClasses");

	return E_NOTIMPL;
	}



// called to enable specific writer classes.  Note that once specific
// writer classes are enabled, only enabled classes are called.
STDMETHODIMP CVssBackupComponents::EnableWriterClasses
	(
	IN const VSS_ID *rgWriterClassId,
	IN UINT cClassId
	)
	{
	UNREFERENCED_PARAMETER(rgWriterClassId);
	UNREFERENCED_PARAMETER(cClassId);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::EnableWriterClasses");

	return E_NOTIMPL;
	}

// called to disable an event call to a writer instance
STDMETHODIMP CVssBackupComponents::DisableWriterInstances
	(
	IN const VSS_ID *rgWriterInstanceId,
	IN UINT cInstanceId
	)
	{
	UNREFERENCED_PARAMETER(rgWriterInstanceId);
	UNREFERENCED_PARAMETER(cInstanceId);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::DisableWriterInstances");

	return E_NOTIMPL;
	}

// called to expose a snapshot 
STDMETHODIMP CVssBackupComponents::ExposeSnapshot
	(
    IN VSS_ID SnapshotId,
    IN VSS_PWSZ wszPathFromRoot,
    IN LONG lAttributes,
    IN VSS_PWSZ wszExpose,
    OUT VSS_PWSZ *pwszExposed
    )
	{
	UNREFERENCED_PARAMETER(SnapshotId);
	UNREFERENCED_PARAMETER(wszPathFromRoot);
	UNREFERENCED_PARAMETER(lAttributes);
	UNREFERENCED_PARAMETER(wszExpose);
	UNREFERENCED_PARAMETER(pwszExposed);

	CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::ExposeSnapshot");

    BS_ASSERT(false);   // Calling this method in the Client SKU is a bug.
	return E_NOTIMPL;
	}




    STDMETHODIMP CVssBackupComponents::RevertToSnapshot
        (
        IN VSS_ID SnapshotId,
        IN BOOL bForceDismount
        )
        {
            UNREFERENCED_PARAMETER(SnapshotId);
            UNREFERENCED_PARAMETER(bForceDismount);
            
            CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::RevertToSnapshot");
    
            ft.hr = E_NOTIMPL;
            return ft.hr;
        }
    
    STDMETHODIMP CVssBackupComponents::QueryRevertStatus
        (
        IN VSS_PWSZ pwszVolume,
        OUT IVssAsync **ppAsync
        )
        {
        UNREFERENCED_PARAMETER(pwszVolume);
        UNREFERENCED_PARAMETER(ppAsync);
        
        CVssFunctionTracer ft(VSSDBG_XML, L"CVssBackupComponents::QueryRevertStatus");
        
        ft.hr = E_NOTIMPL;
        return ft.hr;    
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by svc.rc
//

#ifndef __VSS_RESOURCE_H__
#define __VSS_RESOURCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#define IDS_SERVICENAME                 100


#define IDR_VSSVC                       201
#define IDR_COORD                       202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        306
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           306
#endif
#endif

#endif // __VSS_RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\admin.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Admin.cxx | Implementation of IVssAdmin
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     08/26/1999  Adding RegisterProvider
    aoltean     08/26/1999  Adding UnregisterProvider
    aoltean     08/27/1999  Adding IsAdministrator,
                            Adding unique provider name test.
    aoltean     08/30/1999  Calling OnUnregister on un-registering
                            Improving IsProviderNameAlreadyUsed.
    aoltean     09/03/1999  Moving QueryProviders in Query.cxx
                            Moving private methods in Private.cxx
                            More parameter checking
                            Moving constants in coord.hxx
    aoltean     09/09/1999  Adding the notification interface.
                            Making the code clearer.
                            dss -> vss
	aoltean		09/20/1999	Adding shared "copy" class
	aoltean		09/21/1999  Adding a new header for the "ptr" class.


--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"
#include "reg_util.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORADMNC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  IVssAdmin interface


CVssAdmin::CVssAdmin()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::CVssAdmin" );
}


CVssAdmin::~CVssAdmin()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::~CVssAdmin" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAdmin interface


STDMETHODIMP CVssAdmin::RegisterProvider(
    IN      VSS_ID      ProviderId,
    IN      CLSID       ClassId,
    IN      VSS_PWSZ    pwszProviderName,
	IN		VSS_PROVIDER_TYPE eProviderType,
    IN      VSS_PWSZ    pwszProviderVersion,
    IN      VSS_ID      ProviderVersionId
    )

/*++

Routine Description:

    Register the provider. Add the provider into the internal array if the array is already filled exist.

Arguments:

    VSS_ID      ProviderId,
    CLSID       ClassId,
    VSS_PWSZ    pwszProviderName,
    VSS_PROVIDER_TYPE eProviderType,
    VSS_PWSZ    pwszProviderVersion,
    VSS_ID      ProviderVersionId

Return values:

    E_OUTOFMEMORY
    E_ACCESSDENIED 
        - The user is not administrator
    E_INVALIDARG 
        - Invalid arguments
    VSS_E_PROVIDER_ALREADY_REGISTERED
        - Provider already registered
    E_UNEXPECTED 
        - Registry errors. An error log entry is added describing the error.

    [CVssProviderManager::AddProviderIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures] or
        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::RegisterProvider" );
    WCHAR   wszProviderKeyName[_MAX_KEYNAME_LEN];
    WCHAR   wszValueBuffer[_MAX_VALUE_LEN];
    HKEY    hRegKeyVSS = NULL;
    HKEY    hRegKeyProviders = NULL;
    HKEY    hRegKeyNewProvider = NULL;
    HKEY    hRegKeyCLSID = NULL;
    LONG    lRes;
    bool    bProviderKeyCreated = false;

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
                  L"ProviderId = " WSTR_GUID_FMT L",\n"
                  L"ClassId = "  WSTR_GUID_FMT L",\n"
                  L"pwszProviderName = %s\n"
				  L"eProviderType = %d\n"
                  L"pwszProviderVersion = %s\n"
                  L"ProviderVersionId = "  WSTR_GUID_FMT L",\n",
                  GUID_PRINTF_ARG( ProviderId ),
                  GUID_PRINTF_ARG( ClassId ),
                  pwszProviderName,
				  eProviderType,
                  pwszProviderVersion,
                  GUID_PRINTF_ARG( ProviderVersionId )
                  );

        // Argument validation
        if (ProviderId == GUID_NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL Provider ID");
        if (pwszProviderName == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL name");
        if (pwszProviderName[0] == L'\0')
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Empty name");
        if (::wcslen(pwszProviderName) > _MAX_VALUE_LEN - 1 )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszProviderName length greater than %d", _MAX_VALUE_LEN - 1);
		switch( eProviderType ) {
		case VSS_PROV_SOFTWARE:
//		case VSS_PROV_HARDWARE: // Disabled in Whistler client
			break;
		default:
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"invalid provider type %d", eProviderType);
		}
        if (pwszProviderVersion == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL version");
        if (::wcslen(pwszProviderVersion) > _MAX_VALUE_LEN - 1 )
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszProviderVersion length greater than %d", _MAX_VALUE_LEN - 1);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Creating the "HKLM\System\CurrentControlSet\Services\VSS" key, if it does not exist yet.
        DWORD dwDisposition;
        lRes = ::RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,         //  IN HKEY hKey,
            wszVSSKey,                  //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyVSS,                //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), L"RegCreateKeyExW(HKLM,%s,...)", 
                wszVSSKey);

        // Creating the "Providers" subkey, if it does not exist yet.
        lRes = ::RegCreateKeyExW(
            hRegKeyVSS,                 //  IN HKEY hKey,
            wszVSSKeyProviders,         //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyProviders,          //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders);

        // Create the subkey for that Provider Id.
        ::wsprintf(wszProviderKeyName, WSTR_GUID_FMT, GUID_PRINTF_ARG( ProviderId ));
        lRes = ::RegCreateKeyExW(
            hRegKeyProviders,           //  IN HKEY hKey,
            wszProviderKeyName,         //  IN LPCWSTR lpSubKey,
            0,                          //  IN DWORD Reserved,
            REG_NONE,                   //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
            NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyNewProvider,        //  OUT PHKEY phkResult,
            &dwDisposition              //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName);

        switch ( dwDisposition )
        {
        case REG_CREATED_NEW_KEY: // OK. The new provider has a new key. Break on.
            // The cleanup code must delete also the provider key also.
            bProviderKeyCreated = true;
            break;
        case REG_OPENED_EXISTING_KEY:
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_ALREADY_REGISTERED,
                      L"Provider with Id %s already registered ", wszProviderKeyName);
        default:
            BS_ASSERT( false );
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s,%s,...,[%d])", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, dwDisposition);
        }

        // Set provider name
        DWORD dwLength = ::lstrlenW( pwszProviderName );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueName,            // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)pwszProviderName,      // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueName, pwszProviderName, 
                (dwLength + 1) * sizeof(WCHAR));

        // Set provider type
        DWORD dwType = eProviderType;
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueType,            // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_DWORD,                          // IN DWORD dwType,
            (CONST BYTE*)(&dwType),				// IN CONST BYTE* lpData,
            sizeof(DWORD)						// IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_DWORD,%d,%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueType, dwType, sizeof(DWORD));

        // Set provider version
        dwLength = ::lstrlenW( pwszProviderVersion );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueVersion,         // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)pwszProviderVersion,   // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueVersion, pwszProviderVersion, 
                (dwLength + 1) * sizeof(WCHAR));

        // Set provider version Id.
        ::wsprintf(wszValueBuffer, WSTR_GUID_FMT, GUID_PRINTF_ARG( ProviderVersionId ));
        dwLength = ::lstrlenW( wszValueBuffer );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyNewProvider,                 // IN HKEY hKey,
            wszVSSProviderValueVersionId,       // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)wszValueBuffer,        // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSProviderValueVersionId, wszValueBuffer, 
                (dwLength + 1) * sizeof(WCHAR));

        // Create the subkey for the class Id.
        lRes = ::RegCreateKeyExW(
            hRegKeyNewProvider,                 //  IN HKEY hKey,
            wszVSSKeyProviderCLSID,             //  IN LPCWSTR lpSubKey,
            0,                                  //  IN DWORD Reserved,
            REG_NONE,                           //  IN LPWSTR lpClass,
            REG_OPTION_NON_VOLATILE,            //  IN DWORD dwOptions,
            KEY_ALL_ACCESS,                     //  IN REGSAM samDesired,
            NULL,                               //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            &hRegKeyCLSID,                      //  OUT PHKEY phkResult,
            &dwDisposition                      //  OUT LPDWORD lpdwDisposition
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegCreateKeyExW(HKLM\\%s\\%s\\%s,%s,...)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSKeyProviderCLSID);
        BS_ASSERT(dwDisposition == REG_CREATED_NEW_KEY );

        // Set the CLSID for the newly created key
        ::wsprintf(wszValueBuffer, WSTR_GUID_FMT, GUID_PRINTF_ARG( ClassId ));
        dwLength = ::lstrlenW( wszValueBuffer );
        BS_ASSERT( dwLength != 0 );
        lRes = ::RegSetValueExW(
            hRegKeyCLSID,                       // IN HKEY hKey,
            wszVSSCLSIDValueName,               // IN LPCWSTR lpValueName,
            0,                                  // IN DWORD Reserved,
            REG_SZ,                             // IN DWORD dwType,
            (CONST BYTE*)wszValueBuffer,        // IN CONST BYTE* lpData,
            (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
            );
        if ( lRes != ERROR_SUCCESS )
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
                L"RegSetValueExW(HKLM\\%s\\%s\\%s\\%s,%s,0,REG_SZ,%s.%d)", 
                wszVSSKey, wszVSSKeyProviders, wszProviderKeyName, wszVSSKeyProviderCLSID, wszVSSCLSIDValueName, 
                wszValueBuffer, (dwLength + 1) * sizeof(WCHAR));

		// Update m_pProvidersArray by inserting the new provider into the array.
		CVssProviderManager::AddProviderIntoArray(
			ProviderId,
			pwszProviderName,
            eProviderType,
			pwszProviderVersion,
			ProviderVersionId,
			ClassId);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    try
    {
        lRes = hRegKeyCLSID? ::RegCloseKey(hRegKeyCLSID): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyCLSID key. [0x%08lx]", GetLastError());

        lRes = hRegKeyNewProvider? ::RegCloseKey(hRegKeyNewProvider): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyNewProvider key. [0x%08lx]", GetLastError());

        lRes = hRegKeyProviders? ::RegCloseKey(hRegKeyProviders): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyProviders key. [0x%08lx]", GetLastError());

        lRes = hRegKeyVSS? ::RegCloseKey(hRegKeyVSS): ERROR_SUCCESS;
        if (lRes != ERROR_SUCCESS)
            ft.Trace(VSSDBG_COORD, L"Error closing the hRegKeyVSS key. [0x%08lx]", GetLastError());

        // Delete all registry keys that correspond to this provider
        if (bProviderKeyCreated && ft.HrFailed()) {
            CVssFunctionTracer ft2(VSSDBG_COORD,  L"CVssAdmin::RegisterProvider_rec_del" );
            WCHAR   wszProviderKeyName[_MAX_KEYNAME_LEN];
            ::wsprintf( wszProviderKeyName, L"%s\\%s\\" WSTR_GUID_FMT,
                    wszVSSKey, wszVSSKeyProviders, GUID_PRINTF_ARG( ProviderId ));
            RecursiveDeleteKey( ft2, HKEY_LOCAL_MACHINE, wszProviderKeyName );
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVssAdmin::UnregisterProvider(
    IN      VSS_ID      ProviderId
    )

/*++

Routine Description:

    Unregister the provider. Remove the provider from the internal array if the array is already filled exist.

Arguments:

    VSS_ID      ProviderId

Return values:


    E_ACCESSDENIED 
        - The user is not administrator
    VSS_E_PROVIDER_IN_USE
        - A snapshot set is in progress.
    VSS_E_PROVIDER_NOT_REGISTERED
        - The provider with the given ID is not registered.

    [lock failures]
        E_OUTOFMEMORY

    [CVssProviderManager::RemoveProviderFromArray() failures]
        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::UnregisterProvider" );
    WCHAR   wszKeyBuffer[_MAX_KEYNAME_LEN];

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

        if (ProviderId == VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                      L"Attempting to unregister the unique MS Software Snasphot provider");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
                  L"ProviderId = " WSTR_GUID_FMT,
                  GUID_PRINTF_ARG( ProviderId ));

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// If a snapshot set is in progress then abort un-registering
		if (CVssProviderManager::AreThereStatefulObjects())
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_IN_USE,
                      L"A snapshot set is in progress");

		// Notify the provider that is being unregistered. Abort unregistering in case of failure.
		// Unload the provider from memory. (forced since unregister was called)
		// Remove provider from m_pProvidersArray.
		if( !CVssProviderManager::RemoveProviderFromArray( ProviderId ))
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED,
                      L"The provider is not registered");

        // Delete all registry keys that correspond to this provider
        ::wsprintf( wszKeyBuffer, L"%s\\%s\\" WSTR_GUID_FMT,
                wszVSSKey, wszVSSKeyProviders, GUID_PRINTF_ARG( ProviderId ));
        RecursiveDeleteKey( ft, HKEY_LOCAL_MACHINE, wszKeyBuffer );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssAdmin::AbortAllSnapshotsInProgress()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::AbortAllSnapshotsInProgress" );

	try
	{
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		CVssProviderManager::DeactivateAll();
    }
    VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\async.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async.cxx | Implementation of CVssAsync object
    @end

Author:

    Adi Oltean  [aoltean]  10/05/1999

Revision History:

    Name        Date        Comments
    aoltean     10/05/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "provmgr.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "async.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORASYNC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssAsync


CVssAsync::CVssAsync():
	m_pSnapshotSet(NULL),
	m_hrState(S_OK)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::CVssAsync" );
}


CVssAsync::~CVssAsync()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::~CVssAsync" );
}


IVssAsync* CVssAsync::CreateInstanceAndStartJob(
	IN	CVssSnapshotSetObject*	pSnapshotSetObject
	)

/*++

Routine Description:

    Static method that creates a new instance of the Async interface and
    starts a background thread that runs the CVssAsync::OnRun.

Arguments:

    CVssSnapshotSetObject*	pSnapshotSetObject, - the snapshot set object given as parameter.

Throw values:

    E_OUTOFMEMORY
        - On CComObject<CVssAsync>::CreateInstance failure
        - On PrepareJob failure
        - On StartJob failure

    E_UNEXPECTED
        - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    // Allocate the COM object.
    CComObject<CVssAsync>* pObject;
    ft.hr = CComObject<CVssAsync>::CreateInstance(&pObject);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssAsync instance. hr = 0x%08lx", ft.hr);
    BS_ASSERT(pObject);

	// Setting async object internal data
	BS_ASSERT(pSnapshotSetObject);
	
	// AddRef is called - since the CVssAsync keeps a smart pointer.
    pObject->m_pSnapshotSet = pSnapshotSetObject;

    // Querying the IVssSnapshot interface. Now the ref count becomes 1.
    CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
    BS_ASSERT(pUnknown);
    ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
    if ( ft.HrFailed() ) {
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Error querying the IVssAsync interface. hr = 0x%08lx", ft.hr);
    }
    BS_ASSERT(pAsync);

	// Prepare job (thread created in resume state)
	ft.hr = pObject->PrepareJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job. hr = 0x%08lx", ft.hr);

	// Start job (now the background thread will start running).
	ft.hr = pObject->StartJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job. hr = 0x%08lx", ft.hr);

    // The reference count becomes 3 since we keep a reference for the background thread.

    // Right now the background thread is running. This thread will perform a Release when finishes.
    // This will keep the async object alive until the thread finishes.
    // But, we cannot put an AddRef in the OnInit/OnRun on the background thread,
    // (since in this thread we might
    // call all subsequent releases without giving a chance to the other thread to do an AddRef)
    // Also we cannot put an AddRef at creation since we didn't know at that time if the background
    // thread will run.
    // Therefore we must do the AddRef right here.
    // Beware, this AddRef is paired with an Release in the CVssAsync::OnFinish method:
    // Note: we are sure that we cannot reach reference count zero since the thread is surely running,
    //
    IUnknown* pUnknownTmp = pObject->GetUnknown();
    pUnknownTmp->AddRef();

	// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
    // The ref count goes back to 2

	return pAsync.Detach();	  // The ref count remains 2.
}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


bool CVssAsync::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnInit" );

	if (m_pSnapshotSet != NULL)
	{
		// Setting snapshot set internal data
		BS_ASSERT(m_hrState == S_OK);
		m_hrState = VSS_S_ASYNC_PENDING;

		// Setting snapshot set internal data
		BS_ASSERT(!m_pSnapshotSet->m_bCancel);
		m_pSnapshotSet->m_bCancel = false;
    }

	return (m_pSnapshotSet != NULL);
}


void CVssAsync::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnRun" );

	try
	{
		// Check if the snapshot object is created.
		if (m_pSnapshotSet == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
				L"Snapshot set object not yet created.");
		}

		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).
		
		// Call StartSnapshotSet on the given object.
		ft.hr = m_pSnapshotSet->DoSnapshotSet();
		if (ft.hr != S_OK)
		{
			ft.Trace( VSSDBG_COORD,
					  L"Internal DoSnapshotSet failed. 0x%08lx", ft.hr);
			
			// Put the error code into the
			BS_ASSERT(m_hrState == VSS_S_ASYNC_PENDING);
			m_hrState = ft.hr;
		}

		// Now m_hrState may be VSS_S_ASYNC_CANCELLED
	}
	VSS_STANDARD_CATCH(ft)
}


void CVssAsync::OnFinish()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnFinish" );

    try
    {
		if (m_pSnapshotSet)
		{
			if ( m_hrState == VSS_S_ASYNC_PENDING)
				m_hrState = VSS_S_ASYNC_FINISHED;
			// Else keep the m_hrState error code...
			// It may be VSS_S_ASYNC_CANCELLED, if CVssSnapshotSetObject::TestIfCancelNeeded was called.
		}
		else
			BS_ASSERT(false);

        // Release the background thread reference to this object.
		// Note: We kept an reference around for the time when the backgropund thread is running.
        // In this way we avoid the destruction of the async interface while the
        // background thread is running.
        // The paired addref was done after a sucessful StartJob

        // Mark the thread object as "finished"
        MarkAsFinished();

        // We release the interface only if StartJob was returned with success
        IUnknown* pMyself = GetUnknown();
        pMyself->Release();
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssAsync::OnTerminate()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::OnTerminate" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssAsync::Cancel()

/*++

Routine Description:

    Cancels the current running process, if any.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::Cancel" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pSnapshotSet == NULL) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");
		}

		// If thread is already finished, return correct code.
		if ((m_hrState == VSS_S_ASYNC_FINISHED) || (m_hrState == VSS_S_ASYNC_CANCELLED))
			ft.hr = m_hrState;
		else	// Otherwise, inform the thread that it must cancel. The function returns immediately.
			m_pSnapshotSet->m_bCancel = true;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssAsync::Wait(DWORD dwMilliseconds)

/*++

Routine Description:

    Waits until the process gets finished.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.
        - Thread handle is invalid. Code bug, no logging.
        - WaitForSingleObject failed. Code bug, no logging.

--*/

{
        UNREFERENCED_PARAMETER(dwMilliseconds);
        
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::Wait" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Safety check
		if (m_pSnapshotSet == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");
		}

		// No async lock here!

		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"invalid hThread");

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) {
			ft.LogGenericWarning( VSSDBG_GEN,
			    L"WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx",
			    hThread, GetLastError() );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssAsync::QueryStatus(
				OUT     HRESULT* pHrResult,
				OUT     INT* pnReserved
				)

/*++

Routine Description:

    Query the status for the current running process, if any.

Arguments:

	OUT     HRESULT* pHrResult  - Will be filled with a value reflected by the current status
	OUT     INT* pnReserved     - Reserved today. It will be filled always with zero, if non-NULL

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pSnapshotSet is NULL. Code bug, no logging.
    E_INVALIDARG
        - NULL pHrResult

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAsync::QueryStatus" );

	try
	{
		// Zero the [out] parameters
		::VssZeroOut(pHrResult);
		::VssZeroOut(pnReserved);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Argument check
		BS_ASSERT(pHrResult);
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pHrResult == NULL");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pSnapshotSet == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pSnapshotSet == NULL");

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_COORD, L"Returning *pHrResult: 0x%08x", *pHrResult );
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\comadmin\comadmin.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module COMAdmin.cxx | Simple wrapper around COM Admin classes
    @end

Author:

    Adi Oltean  [aoltean]  08/15/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     08/15/1999  Created.
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999	Fixing VSSDBG_GEN.

--*/


/////////////////////////////////////////////////////////////////////////////
// Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)

// C4127: conditional expression is constant
#pragma warning( disable: 4127 )


#define STRICT

/////////////////////////////////////////////////////////////////////////////
// Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>

#include "vs_assert.hxx"

#include <atlconv.h>
#include <atlbase.h>
#include <comadmin.h>
#include <vs_sec.hxx>

#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CADCADMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Globals


// Collection attributes - TBD: Verify if Keys are OK!!
struct _VsCOMCollectionAttr g_VsCOMCollectionsArray[] =
{
    { L"",                       L"",            L"",          },   // VSS_COM_UNKNOWN = 0,
    { L"ApplicationCluster",     L"Name",        L"Name",      },   // VSS_COM_APPLICATION_CLUSTER,
    { L"Applications",           L"ID",          L"Name",      },   // VSS_COM_APPLICATIONS,
    { L"Components",             L"CLSID",       L"ProgID",    },   // VSS_COM_COMPONENTS,
    { L"ComputerList",           L"Name",        L"Name",      },   // VSS_COM_COMPUTERLIST,
    { L"DCOMProtocols",          L"Name",        L"Name",      },   // VSS_COM_DCOM_PROTOCOLS,
    { L"ErrorInfo",              L"MajorRef",    L"MajorRef",  },   // VSS_COM_ERRORINFO,
    { L"IMDBDataSources",        L"DataSource",  L"DataSource",},   // VSS_COM_IMDB_DATA_SOURCES,
    { L"IMDBDataSourceTables",   L"TableName",   L"TableName", },   // VSS_COM_IMDB_DATA_SOURCE_TABLES,
    { L"InprocServers",          L"CLSID",       L"ProgID",    },   // VSS_COM_INPROC_SERVERS,
    { L"InterfacesForComponent", L"IID"          L"Name"       },   // VSS_COM_INTERFACES_FOR_COMPONENT,
    { L"LocalComputer",          L"Name",        L"Name",      },   // VSS_COM_LOCAL_COMPUTER,
    { L"MethodsForInterface",    L"Index",       L"Name",      },   // VSS_COM_METHODS_FOR_INTERFACE,
    { L"PropertyInfo",           L"Name",        L"Name",      },   // VSS_COM_PROPERTY_INFO,
    { L"PublisherProperties",    L"Name",        L"Name",      },   // VSS_COM_PUBLISHER_PROPERTIES,
    { L"RelatedCollectionInfo",  L"Name",        L"Name",      },   // VSS_COM_RELATED_COLLECTION_INFO,
    { L"Roles",                  L"Name",        L"Name",      },   // VSS_COM_ROLES,
    { L"RolesForComponent",      L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_COMPONENT,
    { L"RolesForInterface",      L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_INTERFACE,
    { L"RolesForMethod",         L"Name",        L"Name",      },   // VSS_COM_ROLES_FOR_METHOD,
    { L"Root",                   L"",            L"",          },   // VSS_COM_ROOT,
    { L"SubscriberProperties",   L"Name",        L"Name",      },   // VSS_COM_SUBSCRIBER_PROPERTIES,
    { L"Subscriptions",          L"ID",          L"Name",      },   // VSS_COM_SUBSCRIPTIONS,
    { L"TransientSubscriptions", L"ID",          L"Name",      },   // VSS_COM_TRANSIENT_SUBSCRIPTIONS,
    { L"UsersInRole",            L"User",        L"User",      }    // VSS_COM_USERS_IN_ROLE,
};


/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMAdminCatalog


HRESULT CVssCOMAdminCatalog::Attach(
    IN  const WCHAR* pwszAppName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::Attach" );

    try
    {
        // Testing argument
        if (pwszAppName == NULL || pwszAppName[0] == L'\0') {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL or empty application name");
        }

        // Begin initializing
        m_bInitialized = false;
        m_pICatalog = NULL;

        // Creating the COMAdminCatalog instance
        ft.hr = m_pICatalog.CoCreateInstance(__uuidof(COMAdminCatalog));
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_CREATING_COMPLUS_ADMIN_CATALOG, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Error creating the COMAdminCatalog instance hr = 0x%08lx", ft.hr);
        }

        // Getting the application name
        m_bstrAppName = pwszAppName;
        if (!m_bstrAppName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        // End initializing
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}




HRESULT CVssCOMAdminCatalog::InstallComponent(
    IN  const WCHAR* pwszDllName,
    IN  const WCHAR* pwszTlbName,
    IN  const WCHAR* pwszProxyStubName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::InstallComponent" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        // Testing arguments
        if (pwszDllName == NULL || pwszDllName[0] == L'\0')
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL or empty paths");

        CComBSTR bstrAppName = (LPWSTR)m_bstrAppName;
        if ((LPWSTR)bstrAppName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrDllName = pwszDllName;
        if ((LPWSTR)bstrDllName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrTlbName = pwszTlbName? pwszTlbName: L"";
        if ((LPWSTR)bstrTlbName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrProxyStubName = pwszProxyStubName? pwszProxyStubName: L"";
        if ((LPWSTR)bstrProxyStubName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");


        // Install event class for this application
        ft.hr = m_pICatalog->InstallComponent(
            bstrAppName,
            bstrDllName,
            bstrTlbName,
            bstrProxyStubName
            );
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.LogError( VSS_ERROR_INSTALL_COMPONENT, VSSDBG_GEN << bstrDllName << bstrAppName << ft.hr );
            ft.Throw(VSSDBG_GEN, ft.hr, L"Installing the component failed");
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMAdminCatalog::CreateServiceForApplication(
    IN  const WCHAR* pwszServiceName
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMAdminCatalog::CreateServiceForApplication" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        CComBSTR bstrAppName = (LPWSTR)m_bstrAppName;
        if ((LPWSTR)bstrAppName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrSvcName = pwszServiceName;
        if ((LPWSTR)bstrSvcName == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrStartType = L"SERVICE_DEMAND_START";
        if ((LPWSTR)bstrStartType == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrErrorControl = L"SERVICE_ERROR_IGNORE";
        if ((LPWSTR)bstrErrorControl == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrRunAs = L"LocalSystem";
        if ((LPWSTR)bstrRunAs == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        CComBSTR bstrPassword = L"";
        if ((LPWSTR)bstrRunAs == NULL)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

#ifdef _DEBUG
        VARIANT_BOOL vboolDesktopOK = VARIANT_TRUE;
#else
        VARIANT_BOOL vboolDesktopOK = VARIANT_FALSE;
#endif

        ft.Trace(VSSDBG_GEN,
            L"Calling CreateServiceForApplicationStrings(%s, %s, %s, %s, %s, %s, %s, %s)",
            bstrAppName,
            bstrSvcName,
            bstrStartType,
            bstrErrorControl,
            NULL,
            bstrRunAs,
            bstrPassword,
            vboolDesktopOK == VARIANT_TRUE? L"TRUE": L"FALSE"
            );

        // Install event class for this application
        ft.hr = m_pICatalog->CreateServiceForApplication(
            m_bstrAppName,
            bstrSvcName,
            bstrStartType,
            bstrErrorControl,
            NULL,
            bstrRunAs,
            bstrPassword,
            vboolDesktopOK
            );
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.LogError( VSS_ERROR_CREATE_SERVICE_FOR_APPLICATION, VSSDBG_GEN << bstrSvcName << m_bstrAppName << ft.hr );
            ft.Throw(VSSDBG_GEN, ft.hr, L"Installing the component failed");
		}
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}





/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMCatalogCollection


HRESULT CVssCOMCatalogCollection::Attach(
    IN  CVssCOMAdminCatalog& catalog
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::Attach_ToCatalog" );

    try
    {
        // Begin intializing
        m_bInitialized = false;
        m_pICollection = NULL;

        // Check if Collection type is valid
        if ((m_eType <= 0) || (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Invalid collection type");

        // Converting collection name into BSTR
        CComBSTR bstrCollectionName = g_VsCOMCollectionsArray[m_eType].wszName;
        if (!bstrCollectionName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

        // Get the catalog interface
        CComPtr<ICOMAdminCatalog2> pICatalog = catalog.GetInterface();
        if (pICatalog == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog object not initialized.");
        }

        // Get the collection object
        CComPtr<IDispatch> pIDisp;
        ft.hr = pICatalog->GetCollection(bstrCollectionName, &pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GETTING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting the collection. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogCollection
        CComPtr<ICatalogCollection> pICollection;
        ft.hr = pIDisp->SafeQI(ICatalogCollection, &pICollection);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogCollection. hr = 0x%08lx", ft.hr);

        // Populate the collection
        ft.hr = pICollection->Populate();
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_POPULATING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in populating the collection object. hr = 0x%08lx", ft.hr);
        }

        // End intializing
        m_pICollection = pICollection;
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMCatalogCollection::Attach(
    IN  CVssCOMCatalogObject& parentObject
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::Attach_ToParentCollection" );

    try
    {
        // Begin intializing
        m_bInitialized = false;
        m_pICollection = NULL;

        // Check if Collection type is valid
        if ((m_eType <= 0) || (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"Invalid collection type");

        // Converting collection name into BSTR
        CComBSTR bstrCollectionName = g_VsCOMCollectionsArray[m_eType].wszName;
        if (!bstrCollectionName)
            ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");

       // Get the parent object interface
        CComPtr<ICatalogObject> pIParentObject = parentObject.GetInterface();
        if (pIParentObject == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Parent object not initialized yet.");
        }

        // Get the Key that uniquely identifies the parent object in the grand parent collection
        CComVariant variant;
        // Beware to not leave variant resources before get_Key call!
        ft.hr = pIParentObject->get_Key(&variant);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GET_COLLECTION_KEY, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting object key. hr = 0x%08lx", ft.hr);
        }

        // Get the grand parent collection interface
        CComPtr<ICatalogCollection> pIGrandParentCollection = parentObject.GetParentInterface();
        if (pIGrandParentCollection == NULL) {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Parent object not initialized.");
        }

        // Get the collection object
        CComPtr<IDispatch> pIDisp;
        ft.hr = pIGrandParentCollection->GetCollection(bstrCollectionName, variant, &pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_GET_COLLECTION_FROM_PARENT, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in getting collection. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogCollection
        ICatalogCollection* pICollection;
        ft.hr = pIDisp->SafeQI(ICatalogCollection, &pICollection);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogCollection. hr = 0x%08lx", ft.hr);
        BS_ASSERT(pICollection);
        m_pICollection.Attach(pICollection);

        // Populate the collection
        ft.hr = m_pICollection->Populate();
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_POPULATING_COLLECTION, VSSDBG_GEN << bstrCollectionName << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in populating the collection object. hr = 0x%08lx", ft.hr);
        }

        // End intializing
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT CVssCOMCatalogCollection::SaveChanges()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogCollection::SaveChanges" );

    try
    {
        // Test if initialized
        if (!m_bInitialized)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Catalog not initialized");

        // Save changes
        LONG lRet = 0;
        ft.hr = m_pICollection->SaveChanges(&lRet);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_SAVING_CHANGES, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in saving the changes. hr = 0x%08lx", ft.hr);
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



/////////////////////////////////////////////////////////////////////////////
// Implementation of CVssCOMCatalogCollection


HRESULT CVssCOMCatalogObject::InsertInto(
    IN  CVssCOMCatalogCollection& collection
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogObject::InsertInto" );

    try
    {
        // Begin initialization
        m_bInitialized = false;
        m_pIObject = NULL;
        m_pIParentCollection = NULL;
        m_lIndex = -1;

        // Get the collection object
        CComPtr<ICatalogCollection> pIParentCollection = collection.GetInterface();
        if (pIParentCollection == NULL)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Collection object not initialized");

        // Get the instance of the new object
        CComPtr<IDispatch>      pIDisp;
        ft.hr = pIParentCollection->Add(&pIDisp);
        if (ft.HrFailed()) {
			ft.LogError( VSS_ERROR_INSERT_INTO, VSSDBG_GEN << ft.hr );
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in adding the catalog object. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(pIDisp);

        // Convert to ICatalogObject
        BS_ASSERT(m_pIObject == NULL);
        ft.hr = pIDisp->SafeQI(ICatalogObject, &m_pIObject);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogObject. hr = 0x%08lx", ft.hr);

        // End initialization
        m_pIParentCollection = pIParentCollection;
        m_bInitialized = true;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

//
//  Disclaimer: this method assumes that the collection is already populated
//
//  S_FALSE means object not found
//
HRESULT CVssCOMCatalogObject::AttachByName(
    IN  CVssCOMCatalogCollection& collection,
    IN  const WCHAR wszName[],
    IN  const WCHAR wszPropertyName[] /* = NULL */
    )
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssCOMCatalogObject::AttachByName" );

    try
    {
        // Begin initialization
        m_bInitialized = false;
        m_pIObject = NULL;
        m_pIParentCollection = NULL;
        m_lIndex = -1;

        // Check if Object type is valid
        if ((m_eType <= 0) && (m_eType >= VSS_COM_COLLECTIONS_COUNT))
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Invalid object type");
        if (m_eType != collection.GetType())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Object type doesn't match with collection type");

        // Get the collection object
        CComPtr<ICatalogCollection> pIParentCollection = collection.GetInterface();
        if (pIParentCollection == NULL)
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Collection object not initialized.");

        // Get the name of the property used as a key
        CComBSTR bstrPropertyName;
        if (wszPropertyName == NULL)
            bstrPropertyName = g_VsCOMCollectionsArray[m_eType].wszDefaultKey;
        else
            bstrPropertyName = wszPropertyName;

        // Get the number of objects in the collection
        LONG lCount = -1;
        ft.hr = pIParentCollection->get_Count(&lCount);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying the number of elements. hr = 0x%08lx", ft.hr);
        if (lCount == 0)
            ft.Trace(VSSDBG_GEN, L"Empty collection");

        CComVariant varObjectName = wszName;

        CComVariant variant;
        CComPtr<IDispatch> pIDisp;
        CComPtr<ICatalogObject> pIObject;
        for(LONG lIndex = 0; lIndex < lCount; lIndex++)
        {
            // Release previous references
            pIDisp = pIObject = NULL;

            // Get next item
            ft.hr = pIParentCollection->get_Item(lIndex, &pIDisp);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED,
                    L"Failure in getting object with index %ld. hr = 0x%08lx", lIndex, ft.hr);

            // Convert it to ICatalogObject
            ft.hr = pIDisp->SafeQI(ICatalogObject, &pIObject);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Failure in querying ICatalogObject. hr = 0x%08lx", ft.hr);

            variant.Clear(); // do not forget to release resources before get_XXX !
            ft.hr = pIObject->get_Value(bstrPropertyName, &variant);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_GEN, E_UNEXPECTED,
                    L"Failure in getting value for the object key with index %ld. hr = 0x%08lx", lIndex, ft.hr);

            if (varObjectName == variant)
            {
                m_bInitialized = TRUE;
                m_lIndex = lIndex;
                m_pIParentCollection = pIParentCollection;
                m_pIObject = pIObject;
                break;
            }
        }
        if (!m_bInitialized)
            ft.hr = S_FALSE;    // Object not found!
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\globals.cpp ===
//
// globals.cpp : define all the stinking global vars :(
//



#pragma warning (disable: 4268)
#include <stdafx.hxx>

#define DBINITCONSTANTS
#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.cxx | Implementation of CVssCoordinator::DeleteSnapshots
    @end

Author:

    Adi Oltean  [aoltean]  10/10/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     10/10/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "admin.hxx"
#include "provmgr.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "vs_sec.hxx"
#include "shim.hxx"
#include "coord.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORDELEC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssCoordinator


STDMETHODIMP CVssCoordinator::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
    IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )
/*++

Routine description:

    Implements the IVSsCoordinator::Delete

Error codes:

    E_ACCESSDENIED 
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid arguments
    VSS_E_OBJECT_NOT_FOUND
        - Object identified by SourceObjectId not found.

    [GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [GetProviderInterface() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [DeleteSnapshots failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::DeleteSnapshots" );

    try
    {
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);
		
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

        // Argument validation
		BS_ASSERT(plDeletedSnapshots);
        if (plDeletedSnapshots == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL plDeletedSnapshots");
		BS_ASSERT(pNondeletedSnapshotID);
        if (pNondeletedSnapshotID == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pNondeletedSnapshotID");

		// Delegating the call to the providers
		LONG lLocalDeletedSnapshots = 0;
		CSnapshotProviderItfArray ItfArray;
		CComPtr<IVssSnapshotProvider> pProviderItf;
		switch(eSourceObjectType)
		{
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
			{
				// Get the array of interfaces
				CVssProviderManager::GetProviderItfArray( ItfArray );

				// For each provider get all objects tht corresponds to the filter
				bool bObjectFound = false;
				for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
				{
					pProviderItf = ItfArray[nIndex].GetInterface();
					BS_ASSERT(pProviderItf);

					// Query the provider
					ft.hr = pProviderItf->DeleteSnapshots(
						SourceObjectId,
						eSourceObjectType,
						bForceDelete,
						&lLocalDeletedSnapshots,
						pNondeletedSnapshotID
						);

					// Increment the number of deleted snapshots, even in error case.
					// In error case the DeleteSnapshots may fail in the middle of deletion.
					// Some snapshots may get a chance to be deleted.
					(*plDeletedSnapshots) += lLocalDeletedSnapshots;

					// Treat the "object not found" case.
					// The DeleteSnapshots may fail if the object is not found on a certain provider.
					// If the object is not found on ALL providers then this function must return
					// an VSS_E_OBJECT_NOT_FOUND error.
					if (ft.HrSucceeded())
						bObjectFound = true;
					else if (ft.hr == VSS_E_OBJECT_NOT_FOUND) {
					    ft.hr = S_OK;
						continue;
					} else
    					ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(), 
    					    L"DeleteSnapshots("WSTR_GUID_FMT L", %d, %d, [%ld],["WSTR_GUID_FMT L"]) failed",
    					    GUID_PRINTF_ARG(SourceObjectId), (INT)eSourceObjectType, (INT)(bForceDelete? 1: 0), 
    					    lLocalDeletedSnapshots, GUID_PRINTF_ARG(*pNondeletedSnapshotID));
				}
				
				// If no object found in all providers...
				if (!bObjectFound)
					ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Object not found in any provider");
			}
			break;

		default:
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid type %d", eSourceObjectType);
		}
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrSucceeded())
    	(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\async_shim.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module async_shim.cxx | Implementation of CVssShimAsync object
    @end

Author:

    Adi Oltean  [aoltean]  07/20/2000

Revision History:

    Name        Date        Comments
    aoltean     07/20/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "shim.hxx"
#include "async_shim.hxx"
#include "vs_sec.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORASYSC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssShimAsync


CVssShimAsync::CVssShimAsync():
    m_guidSnapshotSetId(GUID_NULL),
	m_ulOptionFlags(0),	
	m_ulVolumeCount(0),	
	m_ppwszVolumeNamesArray(NULL),
	m_hrState(S_OK)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::CVssShimAsync" );
}


CVssShimAsync::~CVssShimAsync()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::~CVssShimAsync" );

	for (ULONG ulIndex = 0; ulIndex < m_ulVolumeCount; ulIndex++ )
	    ::VssFreeString(m_ppwszVolumeNamesArray[ulIndex]);
	delete[] m_ppwszVolumeNamesArray;
}


IVssAsync* CVssShimAsync::CreateInstanceAndStartJob(
	IN	    CVssShimObject*	pShimObject,
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray
	)

/*++

Routine Description:

    Static method that creates a new instance of the CVssShimAsync interface and
    starts a background thread that runs the CVssShimAsync::OnRun.

Arguments:

    CVssShimObject*	pShimObject,
    VSS_ID          guidSnapshotSetId,
    ULONG           ulOptionFlags,	
    ULONG           ulVolumeCount,	
    VSS_PWSZ*       ppwszVolumeNamesArray

Throw values:

    E_OUTOFMEMORY
        - On CComObject<CVssAsync>::CreateInstance failure
        - On copy the data members for the async object.
        - On PrepareJob failure
        - On StartJob failure

    E_UNEXPECTED
        - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::CreateInstanceAndStartJob" );
	CComPtr<IVssAsync> pAsync;

    // Allocate the COM object.
    CComObject<CVssShimAsync>* pObject;
    ft.hr = CComObject<CVssShimAsync>::CreateInstance(&pObject);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssShimAsync instance. hr = 0x%08lx", ft.hr);
    BS_ASSERT(pObject);

    // Querying the IVssSnapshot interface. Now the ref count becomes 1.
    CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
    BS_ASSERT(pUnknown);

	// Setting async object internal data
	BS_ASSERT(pShimObject);

	// Initialize allocated parameters
	pObject->m_guidSnapshotSetId = guidSnapshotSetId;
	pObject->m_ulOptionFlags = ulOptionFlags;
	pObject->m_ulVolumeCount = ulVolumeCount;
	pObject->m_ppwszVolumeNamesArray = new VSS_PWSZ[ulVolumeCount];
	if (pObject->m_ppwszVolumeNamesArray == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
				  L"Error creating the CVssShimAsync instance. hr = 0x%08lx", ft.hr);

        ::ZeroMemory( reinterpret_cast<PVOID>( pObject->m_ppwszVolumeNamesArray ), sizeof( VSS_PWSZ ) * ulVolumeCount );

	// Copy each volume name
	for( ULONG ulIndex = 0; ulIndex < ulVolumeCount; ulIndex++) {
	    VssSafeDuplicateStr( ft,
	        pObject->m_ppwszVolumeNamesArray[ulIndex],
	        ppwszVolumeNamesArray[ulIndex]);
	}

	// AddRef is called - since the CVssShimAsync keeps a smart pointer.
    pObject->m_pShim = pShimObject;

    ft.hr = pUnknown->SafeQI(IVssAsync, &pAsync); // The ref count is 2.
    if ( ft.HrFailed() ) {
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Error querying the IVssAsync interface. hr = 0x%08lx", ft.hr);
    }
    BS_ASSERT(pAsync);

	// Prepare job (thread created in resume state)
	ft.hr = pObject->PrepareJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job. hr = 0x%08lx", ft.hr);

	// Start job (now the background thread will start running).
	ft.hr = pObject->StartJob();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job. hr = 0x%08lx", ft.hr);

    // The reference count becomes 3 since we keep a reference for the background thread.

    // Right now the background thread is running. This thread will perform a Release when finishes.
    // This will keep the async object alive until the thread finishes.
    // But, we cannot put an AddRef in the OnInit/OnRun on the background thread,
    // (since in this thread we might
    // call all subsequent releases without giving a chance to the other thread to do an AddRef)
    // Also we cannot put an AddRef at creation since we didn't know at that time if the background
    // thread will run.
    // Therefore we must do the AddRef right here.
    // Beware, this AddRef is paired with an Release in the CVssShimAsync::OnFinish method:
    // Note: we are sure that we cannot reach reference count zero since the thread is surely running,
    //
    IUnknown* pUnknownTmp = pObject->GetUnknown();
    pUnknownTmp->AddRef();

	// Now the background thread related members (m_hrState, m_nPercentDone) begin to update.
    // The ref count goes back to 2

	return pAsync.Detach();	  // The ref count remains 2.
}


/////////////////////////////////////////////////////////////////////////////
//  CVssWorkerThread overrides


bool CVssShimAsync::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnInit" );

	if (m_pShim != NULL)
	{
		// Setting snapshot set internal data
		BS_ASSERT(m_hrState == S_OK);
		m_hrState = VSS_S_ASYNC_PENDING;

		// Setting snapshot set internal data
		BS_ASSERT(!m_pShim->m_bCancel);
		m_pShim->m_bCancel = false;
    }

	return (m_pShim != NULL);
}


void CVssShimAsync::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnRun" );

	try
	{
		// Check if the snapshot object is created.
		if (m_pShim == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
				L"Snapshot set object not yet created.");
		}

		// We assume that the async object is not yet released.
		// (the wait in destructor should ensure that).
		
		// Call SimulateSnapshotFreeze on the given object.
		ft.hr = m_pShim->SimulateSnapshotFreeze(
		            m_guidSnapshotSetId,
		            m_ulOptionFlags,
		            m_ulVolumeCount,
		            m_ppwszVolumeNamesArray);
		if (ft.hr != S_OK)
		{
			ft.Trace( VSSDBG_COORD,
					  L"Internal SimulateSnapshotFreeze failed. 0x%08lx", ft.hr);
			
			// Put the error code into the
			BS_ASSERT(m_hrState == VSS_S_ASYNC_PENDING);
			m_hrState = ft.hr;
		}

		// Now m_hrState may be VSS_S_ASYNC_CANCELLED
	}
	VSS_STANDARD_CATCH(ft)
}


void CVssShimAsync::OnFinish()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnFinish" );

    try
    {
		if (m_pShim)
		{
			if ( m_hrState == VSS_S_ASYNC_PENDING)
				m_hrState = VSS_S_ASYNC_FINISHED;
			// Else keep the m_hrState error code...
			// It may be VSS_S_ASYNC_CANCELLED, if CVssShimObject::TestIfCancelNeeded was called.
		}
		else
			BS_ASSERT(false);

        // Release the background thread reference to this object.
		// Note: We kept an reference around for the time when the backgropund thread is running.
        // In this way we avoid the destruction of the async interface while the
        // background thread is running.
        // The paired addref was done after a sucessful StartJob

        // Mark the thread object as "finished"
        MarkAsFinished();

        // We release the interface only if StartJob was returned with success
        IUnknown* pMyself = GetUnknown();
        pMyself->Release();
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssShimAsync::OnTerminate()	
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::OnTerminate" );
}


/////////////////////////////////////////////////////////////////////////////
//  IVssAsync implementation


STDMETHODIMP CVssShimAsync::Cancel()

/*++

Routine Description:

    Cancels the current running process, if any.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::Cancel" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pShim == NULL) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");
		}

		// If thread is already finished, return correct code.
		if ((m_hrState == VSS_S_ASYNC_FINISHED) || (m_hrState == VSS_S_ASYNC_CANCELLED))
			ft.hr = m_hrState;
		else	// Otherwise, inform the thread that it must cancel. The function returns immediately.
			m_pShim->m_bCancel = true;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssShimAsync::Wait(DWORD dwMilliseconds)

/*++

Routine Description:

    Waits until the process gets finished.

Arguments:

    None.

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.
        - Thread handle is invalid. Code bug, no logging.
        - WaitForSingleObject failed. Code bug, no logging.

--*/

{
        UNREFERENCED_PARAMETER(dwMilliseconds);
        
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::Wait" );

	try
	{
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Safety check
		if (m_pShim == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");
		}

		// No async lock here!

		HANDLE hThread = GetThreadHandle();
		if (hThread == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"invalid hThread");

		if (::WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED) {
			ft.LogGenericWarning( VSSDBG_GEN,
			    L"WaitForSingleObject(%p,INFINITE) == WAIT_FAILED, GetLastError() == 0x%08lx",
			    hThread, GetLastError() );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Wait failed. [0x%08lx]", ::GetLastError());
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVssShimAsync::QueryStatus(
				OUT     HRESULT* pHrResult,
				OUT     INT* pnReserved
				)

/*++

Routine Description:

    Query the status for the current running process, if any.

Arguments:

	OUT     HRESULT* pHrResult  - Will be filled with a value reflected by the current status
	OUT     INT* pnReserved     - Reserved today. It will be filled always with zero, if non-NULL

Throw values:

    E_ACCESSDENIED
        - The user is not an administrator or a backup operator
    E_UNEXPECTED
        - m_pShim is NULL. Code bug, no logging.
    E_INVALIDARG
        - NULL pHrResult

    [lock failures]
        E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimAsync::QueryStatus" );

	try
	{
		// Zero the [out] parameters
		::VssZeroOut(pHrResult);
		::VssZeroOut(pnReserved);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                      L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// Argument check
		BS_ASSERT(pHrResult);
		if (pHrResult == NULL)
			ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pHrResult == NULL");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Safety check
		if (m_pShim == NULL)
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"m_pShim == NULL");

		(*pHrResult) = m_hrState;
		ft.Trace( VSSDBG_COORD, L"Returning *pHrResult: 0x%08x", *pHrResult );
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\coord.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Coord.cxx | Implementation of CVssCoordinator
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     07/23/1999  Adding List, moving Admin functions in the Admin.cxx
    aoltean     08/11/1999  Adding support for Software and test provider
    aoltean     08/18/1999  Adding events. Making itf pointers CComPtr.
                            Renaming XXXSnapshots -> XXXSnapshot
    aoltean     08/18/1999  Renaming back XXXSnapshot -> XXXSnapshots
                            More stabe state management
                            Resource deallocations is fair
                            More comments
                            Using CComPtr
    aoltean     09/09/1999  Moving constants in coord.hxx
                            Add Security checks
                            Add argument validation.
                            Move Query into query.cpp
                            Move AddvolumesToInternalList into private.cxx
                            dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Provider-generic code.
	aoltean		10/04/1999	Treatment of writer error codes.
	aoltean		10/12/1999	Adding HoldWrites, ReleaseWrites
	aoltean		10/12/1999	Moving all code in Snap_set.cxx in order to facilitate the async interface.
	aoltean		10/15/1999	Adding async support

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "admin.hxx"
#include "provmgr.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "shim.hxx"
#include "async_shim.hxx"
#include "coord.hxx"
#include "vs_sec.hxx"


#include "async.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORCOORC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssCoordinator


STDMETHODIMP CVssCoordinator::SetContext(
	IN		LONG     lContext
    )
/*++

Routine description:

    Implements IVssCoordinator::SetContext

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SetContext" );

    BS_ASSERT(false);
    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(lContext);
}


STDMETHODIMP CVssCoordinator::StartSnapshotSet(
    OUT		VSS_ID*     pSnapshotSetId
    )
/*++

Routine description:

    Implements IVssCoordinator::StartSnapshotSet

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
        - CVssSnapshotSetObject::CreateInstance failures

    [CVssSnapshotSetObject::StartSnapshotSet() failures]
        E_OUTOFMEMORY
        VSS_E_BAD_STATE
            - wrong calling sequence.
        E_UNEXPECTED
            - if CoCreateGuid fails

        [Deactivate() failures] or
        [Activate() failures]
            [lockObj failures]
                E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::StartSnapshotSet" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSnapshotSetId );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: pSnapshotSetId = %p", pSnapshotSetId );

        // Argument validation
		BS_ASSERT(pSnapshotSetId);
        if (pSnapshotSetId == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pSnapshotSetId");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Create the snapshot object, if needed.
		// This call may throw
		// Remark: we cannot re-create this interface since the automatic garbage collection
		// requires that the snapshot set object should be alive.
		if (m_pSnapshotSet == NULL)
            m_pSnapshotSet = CVssSnapshotSetObject::CreateInstance();
					
		// Call StartSnapshotSet on the given object.
        ft.hr = m_pSnapshotSet->StartSnapshotSet(pSnapshotSetId);
		if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
					  L"Internal StartSnapshotSet failed. 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::AddToSnapshotSet(
    IN      VSS_PWSZ    pwszVolumeName,
    IN      VSS_ID      ProviderId,
    OUT     VSS_ID *    pSnapshotId
    )
/*++

Routine description:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence
    VSS_E_VOLUME_NOT_SUPPORTED
        - The volume is not supported by any registered providers

    [CVssCoordinator::IsVolumeSupported() failures]
        E_ACCESSDENIED
            The user is not a backup operator.
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        VSS_E_PROVIDER_NOT_REGISTERED
            The Provider ID does not correspond to a registered provider.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point

        [CVssProviderManager::GetProviderInterface() failures]
            E_OUTOFMEMORY

            [lockObj failures]
                E_OUTOFMEMORY    

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.
                
                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

        [CVssProviderManager::GetProviderItfArray() failures]
            E_OUTOFMEMORY

            [lockObj failures]
                E_OUTOFMEMORY
            
            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.
                
                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_ACCESSDENIED
                The user is not an administrator.
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources           
            E_UNEXPECTED
                Unexpected programming error. Logging not done and not needed.
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                The device does not exist or it is not ready.
        

    [CVssSnapshotSetObject::AddToSnapshotSet() failures]
        E_OUTOFMEMORY
        VSS_E_BAD_STATE
            - wrong calling sequence.
        E_INVALIDARG
            - Invalid arguments (for example the volume name is invalid).
        VSS_E_VOLUME_NOT_SUPPORTED
            - The volume is not supported by any registered providers

        [GetSupportedProviderId() failures]
            E_OUTOFMEMORY
            E_INVALIDARG
                - if the volume is not in the correct format.
            VSS_E_VOLUME_NOT_SUPPORTED
                - If the given volume is not supported by any provider

            [QueryProvidersIntoArray() failures]
                E_OUTOFMEMORY

                [lockObj failures]
                    E_OUTOFMEMORY

                [LoadInternalProvidersArray() failures]
                    E_OUTOFMEMORY
                    E_UNEXPECTED
                        - error while reading from registry. An error log entry is added describing the error.

                [CVssSoftwareProviderWrapper::CreateInstance failures]
                    E_OUTOFMEMORY

                    [CoCreateInstance() failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - The provider interface couldn't be created. An error log entry is added describing the error.

                    [OnLoad() failures]
                    [QueryInterface failures]
                        VSS_E_UNEXPECTED_PROVIDER_ERROR
                            - Unexpected provider error. The error code is logged into the event log.
                        VSS_E_PROVIDER_VETO
                            - Expected provider error. The provider already did the logging.

                [InitializeAsProvider() failures]
                    E_OUTOFMEMORY

                [IVssSnapshotProvider::IsVolumeSupported() failures]
                    E_INVALIDARG
                        NULL pointers passed as parameters or a volume name in an invalid format.
                    E_OUTOFMEMORY
                        Out of memory or other system resources           
                    VSS_E_PROVIDER_VETO
                        An error occured while opening the IOCTL channel. The error is logged.
                    VSS_E_OBJECT_NOT_FOUND
                        The device does not exist or it is not ready.

        [GetProviderInterfaceForSnapshotCreation() failures]

            VSS_E_PROVIDER_NOT_REGISTERED

            [lockObj failures]
                E_OUTOFMEMORY

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

        [CVssQueuedVolumesList::AddVolume() failures]
            E_UNEXPECTED
                - The thread state is incorrect. No logging is done - programming error.
            VSS_E_OBJECT_ALREADY_EXISTS
                - The volume was already added to the snapshot set.
            VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
                - The maximum number of volumes was reached.
            E_OUTOFMEMORY

            [Initialize() failures]
                E_OUTOFMEMORY

        [BeginPrepareSnapshot() failures]
            E_INVALIDARG
            VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
            VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
            VSS_E_OBJECT_NOT_FOUND
                - Volume not found or device not connected.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::AddToSnapshotSet" );

    try
    {
        // Initialize out parameters
        ::VssZeroOut(pSnapshotId);
        
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
			 L"  VolumeName = %s\n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pSnapshotId = %p\n",
             pwszVolumeName,
             GUID_PRINTF_ARG( ProviderId ),
             pSnapshotId);

        // Argument validation
        if (pwszVolumeName == NULL || wcslen(pwszVolumeName) == 0)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");
        if (pSnapshotId == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pSnapshotId");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Check if the snapshot object is created.
		if (m_pSnapshotSet == NULL)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                L"Snapshot set object not yet created.");

        // Check to see if the volume is supported 
        BOOL bIsVolumeSupported = FALSE;
		ft.hr = IsVolumeSupported( ProviderId, pwszVolumeName, &bIsVolumeSupported);
		if (ft.HrFailed())
		    ft.Throw(VSSDBG_COORD, ft.hr, 
		        L"IsVolumeSupported() failed with error code 0x%08lx", ft.hr);
		if (!bIsVolumeSupported)
		    ft.Throw(VSSDBG_COORD, 
		        (ProviderId == GUID_NULL)? 
		            VSS_E_VOLUME_NOT_SUPPORTED: VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER, 
		        L"Volume not supported");
			
		// Call StartSnapshotSet on the given object.
        ft.hr = m_pSnapshotSet->AddToSnapshotSet( pwszVolumeName,
			ProviderId,
			pSnapshotId);
		if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
					  L"Internal AddToSnapshotSet failed. 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::DoSnapshotSet(
    IN     IDispatch*  pCallback,
    OUT     IVssAsync** ppAsync
    )
/*++

Routine description:

    Implements IVssCoordinator::DoSnapshotSet
    Calls synchronously the CVssSnapshotSetObject::DoSnapshotSet in a separate thread

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssAsync::CreateInstanceAndStartJob] failures]
        E_OUTOFMEMORY
            - On CComObject<CVssAsync>::CreateInstance failure
            - On PrepareJob failure
            - On StartJob failure

        E_UNEXPECTED
            - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::DoSnapshotSet" );

    try
    {
        // Nullify all out parameters
        ::VssZeroOutPtr(ppAsync);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Check if the snapshot object is created.
		if (m_pSnapshotSet == NULL)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
                L"Snapshot set object not yet created.");

        if (pCallback != NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Non-NULL callback interface.");
		if (ppAsync == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL async interface.");
		
		// Create the new async interface corresponding to the new job.
		// Remark: AddRef will be called on the snapshot set object.
		CComPtr<IVssAsync> ptrAsync;
		ptrAsync.Attach(CVssAsync::CreateInstanceAndStartJob( m_pSnapshotSet));

		// The reference count of the pAsync interface must be 2
		// (one for the returned interface and one for the background thread).
		(*ppAsync) = ptrAsync.Detach();	// Drop that interface in the OUT parameter
		
        // The ref count remnains 2
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::GetSnapshotProperties(
    IN      VSS_ID          SnapshotId,
	OUT 	VSS_SNAPSHOT_PROP	*pProp
    )
/*++

Routine description:

    Implements IVssCoordinator::GetSnapshotProperties

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [IVssSnapshotProvider::GetSnapshotProperties() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            - The snapshot with this ID does not exists.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::GetSnapshotProperties" );

    try
    {
        // Initialize [out] arguments
        ::VssZeroOut( pProp );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT L"\n"
             L"  pProp = %p\n",
             GUID_PRINTF_ARG( SnapshotId ),
             pProp);

        // Argument validation
		BS_ASSERT(pProp);
        if (pProp == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pProp");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Get the array of interfaces
		CSnapshotProviderItfArray ItfArray;
		CVssProviderManager::GetProviderItfArray( ItfArray );

		// For each provider get all objects tht corresponds to the filter
		for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
		{
			CComPtr<IVssSnapshotProvider> pProviderItf = ItfArray[nIndex].GetInterface();
			BS_ASSERT(pProviderItf);

			// Get the snapshot interface
			ft.hr = pProviderItf->GetSnapshotProperties(
				SnapshotId,
				pProp);

			// If a snapshot was not found then continue with the next provider.
			if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
				continue;
				
			// If an error happened then abort the entire search.
			if (ft.HrFailed())
				ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
				    L"GetSnapshot("WSTR_GUID_FMT L",%p)",
				    GUID_PRINTF_ARG(SnapshotId), pProp);

			// The snapshot was found
			break;
		}
    }
    VSS_STANDARD_CATCH(ft)

	// The ft.hr may be an VSS_E_OBJECT_NOT_FOUND or not.
    return ft.hr;
}


STDMETHODIMP CVssCoordinator::ExposeSnapshot(
    IN      VSS_ID SnapshotId,
    IN      VSS_PWSZ wszPathFromRoot,
    IN      LONG lAttributes,
    IN      VSS_PWSZ wszExpose,
    OUT     VSS_PWSZ *pwszExposed
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::ExposeSnapshot" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(wszPathFromRoot);
    UNREFERENCED_PARAMETER(lAttributes);
    UNREFERENCED_PARAMETER(wszExpose);
    UNREFERENCED_PARAMETER(pwszExposed);
}
    

STDMETHODIMP CVssCoordinator::RevertToSnapshot(
    IN     VSS_ID     SnapshotId,
    IN      BOOL       bForceDismount
    )
    {
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(bForceDismount);
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinator::RevertToSnapshot");

    ft.hr = E_NOTIMPL;
    return ft.hr;    
    }

STDMETHODIMP CVssCoordinator::QueryRevertStatus(
    IN     VSS_PWSZ       pwszVolume,
    OUT  IVssAsync **ppAsync
    )
    {
    UNREFERENCED_PARAMETER(pwszVolume);
    UNREFERENCED_PARAMETER(ppAsync);
    
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssCoordinator::QueryRevertStatus");

    ft.hr = E_NOTIMPL;
    return ft.hr;    
    }

STDMETHODIMP CVssCoordinator::ImportSnapshots(
	IN      BSTR bstrXMLSnapshotSet,
	OUT     IVssAsync** ppAsync
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::ImportSnapshots" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(bstrXMLSnapshotSet);
    UNREFERENCED_PARAMETER(ppAsync);
}


STDMETHODIMP CVssCoordinator::BreakSnapshotSet(
	[in]	VSS_ID		    SnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::BreakSnapshotSet" );

    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(SnapshotSetId);
}


STDMETHODIMP CVssCoordinator::IsVolumeSupported(
    IN      VSS_ID          ProviderId,                
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbIsSupported
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the 
    corresponding provider.
 
Parameters
    ProviderID
        [in] It can be: 
            - GUID_NULL: in this case the function checks if the volume is supported 
            by at least one provider
            - A provider ID: In this case the function checks if the volume is supported 
            by the indicated provider
    pwszVolumeName
        [in] The volume name to be checked, It must represent a volume mount point, like
        in the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format or c:\
        (with trailing backslash)
    pbIsSupported
        [out] Non-NULL pointer that receives TRUE if the volume can be 
        snapshotted using this provider or FALSE otherwise.
 
Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not a backup operator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_OBJECT_NOT_FOUND
        If the volume name does not correspond to an existing mount point or volume.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported

    [CVssProviderManager::GetProviderInterface() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [IVssSnapshotProvider::IsVolumeSupported() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

    [VerifyVolumeIsSupportedByVSS]
        VSS_E_OBJECT_NOT_FOUND
            - The volume was not found
     
Remarks
    The function will return TRUE in the pbSupportedByThisProvider 
    parameter if it is possible to create a snapshot on the given volume. 
    The function must return TRUE on that volume even if the current 
    configuration does not allow the creation of a snapshot on that volume. 
    For example, if the maximum number of snapshots were reached on the 
    given volume (and therefore no more snapshots can be created on that volume), 
    the method must still indicate that the volume can be snapshotted.
 
--*/


{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::IsVolumeSupported" );
	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pbIsSupported );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             pwszVolumeName,
             pbIsSupported);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbIsSupported == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid bool ptr");
    
    	// Getting the volume name
    	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Verify if the volume is supported by VSS itself.
        // If not this will throw an VSS_E_VOLUME_NOT_SUPPORTED exception
        VerifyVolumeIsSupportedByVSS( wszVolumeNameInternal );

        // Choose the way of checking if the volume is supported
        if (ProviderId != GUID_NULL) {
            // Try to find the provider interface
    		CComPtr<IVssSnapshotProvider> pProviderItf;
            if (!(CVssProviderManager::GetProviderInterface(ProviderId,&pProviderItf)))
				ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
				    L"Provider not found");

            // Call the Provider's IsVolumeSupported
            BS_ASSERT(pProviderItf);
            ft.hr = pProviderItf->IsVolumeSupported( 
                        wszVolumeNameInternal, pbIsSupported);
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, 
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
            if (ft.HrFailed())
    			ft.TranslateProviderError( VSSDBG_COORD, ProviderId, 
    			    L"IVssSnapshotProvider::IsVolumeSupported() failed with 0x%08lx", ft.hr );
        } else {
    		CComPtr<IVssSnapshotProvider> pProviderItf;
    		CSnapshotProviderItfArray ItfArray;

			// Get the array of interfaces
			CVssProviderManager::GetProviderItfArray( ItfArray );

			// Ask each provider if the volume is supported.
			// If we find at least one provider that supports the 
			// volume then stop iteration.
			for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
			{
				pProviderItf = ItfArray[nIndex].GetInterface();
				BS_ASSERT(pProviderItf);

                BOOL bVolumeSupportedByThisProvider = FALSE;               
                ft.hr = pProviderItf->IsVolumeSupported( 
                            wszVolumeNameInternal, &bVolumeSupportedByThisProvider);
                if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                    ft.Throw(VSSDBG_COORD, 
                        VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
				if (ft.HrFailed())
					ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
                        L"Cannot ask provider " WSTR_GUID_FMT
                        L" if volume is supported. [0x%08lx]", 
                        GUID_PRINTF_ARG(GUID_NULL), ft.hr);

                // Check to see if the volume is supported by this provider.
				if (bVolumeSupportedByThisProvider) {
					BS_ASSERT(pbIsSupported);
					(*pbIsSupported) = TRUE;
					break;
				}
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    // If an exception was thrown from VerifyVolumeIsSupportedByVSS
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;
    
    return ft.hr;
}


STDMETHODIMP CVssCoordinator::IsVolumeSnapshotted(
    IN      VSS_ID          ProviderId,                
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSnapshotsPresent,
   	OUT 	LONG *		    plSnapshotCompatibility
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the 
    corresponding provider.
 
Parameters
    ProviderID
        [in] It can be: 
            - GUID_NULL: in this case the function checks if the volume is supported 
            by at least one provider
            - A provider ID
    pwszVolumeName
        [in] The volume name to be checked, It mus represent a mount point, like
        in the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format or c:\
        (with trailing backslash)
    pbSnapshotPresent
        [out] Non-NULL pointer that receives TRUE if the volume has at least 
        one snapshot or FALSE otherwise.
 
Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not a backup operator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    VSS_E_PROVIDER_NOT_REGISTERED
        The Provider ID does not correspond to a registered provider.
    VSS_E_OBJECT_NOT_FOUND
        If the volume name does not correspond to an existing mount point or volume.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSnapshotted

    [CVssProviderManager::GetProviderInterface() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssProviderManager::GetProviderItfArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [IVssSnapshotProvider::IsVolumeSnapshotted() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

    [VerifyVolumeIsSupportedByVSS]
        VSS_E_OBJECT_NOT_FOUND
            - The volume was not found
     
Remarks
    The function will return S_OK even if the current volume is a non-supported one. 
    In this case FALSE must be returned in the pbSnapshotPresent parameter.
 
--*/


{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::IsVolumeSnapshotted" );
	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pbSnapshotsPresent );
        VssZeroOut( plSnapshotCompatibility );
        
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n"
             L"  plSnapshotCompatibility = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             pwszVolumeName,
             pbSnapshotsPresent,
             plSnapshotCompatibility
             );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSnapshotsPresent == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid bool ptr");
        if (plSnapshotCompatibility == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Invalid ptr");
    
    	// Getting the volume name
    	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Verify if the volume is supported by VSS itself.
        // If not this will throw an VSS_E_VOLUME_NOT_SUPPORTED exception
        VerifyVolumeIsSupportedByVSS( wszVolumeNameInternal );

        // Choose the way of checking if the volume is supported
        if (ProviderId != GUID_NULL) {
            // Try to find the provider interface
    		CComPtr<IVssSnapshotProvider> pProviderItf;
            if (!(CVssProviderManager::GetProviderInterface(ProviderId,&pProviderItf)))
				ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
				    L"Provider not found");

            // Call the Provider's IsVolumeSnapshotted
            BS_ASSERT(pProviderItf);
            ft.hr = pProviderItf->IsVolumeSnapshotted( 
                        wszVolumeNameInternal, 
                        pbSnapshotsPresent, 
                        plSnapshotCompatibility);
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, 
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
            if (ft.HrFailed())
    			ft.TranslateProviderError( VSSDBG_COORD, ProviderId, 
    			    L"IVssSnapshotProvider::IsVolumeSnapshotted() failed with 0x%08lx", ft.hr );
        } else {
    		CComPtr<IVssSnapshotProvider> pProviderItf;
    		CSnapshotProviderItfArray ItfArray;

			// Get the array of interfaces
			CVssProviderManager::GetProviderItfArray( ItfArray );

			// Ask each provider if the volume is supported.
			// If we find at least one provider that supports the 
			// volume then stop iteration.
			for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
			{
				pProviderItf = ItfArray[nIndex].GetInterface();
				BS_ASSERT(pProviderItf);

                BOOL bVolumeSnapshottedByThisProvider = FALSE;               
                LONG lSnapshotCompatibility = 0;               
                ft.hr = pProviderItf->IsVolumeSnapshotted( 
                            wszVolumeNameInternal, 
                            &bVolumeSnapshottedByThisProvider, 
                            &lSnapshotCompatibility);
                if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                    ft.Throw(VSSDBG_COORD, 
                        VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", wszVolumeNameInternal);
				if (ft.HrFailed())
					ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
                        L"Cannot ask provider " WSTR_GUID_FMT
                        L" if volume is snapshotted. [0x%08lx]", 
                        GUID_PRINTF_ARG(GUID_NULL), ft.hr);

                // Check to see if the volume has snapshots on this provider.
				if (bVolumeSnapshottedByThisProvider) {
					BS_ASSERT(pbSnapshotsPresent);
					(*pbSnapshotsPresent) = TRUE;
					(*plSnapshotCompatibility) |= lSnapshotCompatibility;
				}
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    // If an exception was thrown from VerifyVolumeIsSupportedByVSS
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;
    
    return ft.hr;
}



STDMETHODIMP CVssCoordinator::SetWriterInstances( 
	IN  	LONG		    lWriterInstanceIdCount, 				
    IN      VSS_ID          *rgWriterInstanceId
    )
/*++

Routine description:

    Implements IVssCoordinator::SetContext

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SetWriterInstances" );

    BS_ASSERT(false);
    return E_NOTIMPL;
    UNREFERENCED_PARAMETER(lWriterInstanceIdCount);
    UNREFERENCED_PARAMETER(rgWriterInstanceId);
}



STDMETHODIMP CVssCoordinator::SimulateSnapshotFreeze(
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray,
	OUT     IVssAsync**     ppAsync 					
	)
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotFreeze

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Wrong calling sequence

    [CVssAsyncShim::CreateInstanceAndStartJob() failures]
        E_OUTOFMEMORY
            - On CComObject<CVssAsync>::CreateInstance failure
            - On copy the data members for the async object.
            - On PrepareJob failure
            - On StartJob failure

        E_UNEXPECTED
            - On QI failures. We do not log (but we assert) since this is an obvious programming error.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SimulateSnapshotFreeze" );

    try
    {
        // Nullify all out parameters
        ::VssZeroOutPtr(ppAsync);

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

		if (ppAsync == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL async interface.");
		
		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Create the shim object, if needed.
		// This call may throw
		if (m_pShim == NULL)
            m_pShim = CVssShimObject::CreateInstance();
		else {
		    // TBD: Ckeck and throw VSS_E_BAD_STATE
		    // if another "simulate background thread is already running" !!!!!
		}
					
		// Create the new async interface corresponding to the new job.
		// Remark: AddRef will be called on the shim object.
		CComPtr<IVssAsync> ptrAsync;
		ptrAsync.Attach(CVssShimAsync::CreateInstanceAndStartJob(
		                    m_pShim,
		                    guidSnapshotSetId,
		                    ulOptionFlags,
		                    ulVolumeCount,
		                    ppwszVolumeNamesArray));
		if (ptrAsync == NULL)
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Async interface creation failed");

		// The reference count of the pAsync interface must be 2
		// (one for the returned interface and one for the background thread).
		(*ppAsync) = ptrAsync.Detach();	// Drop that interface in the OUT parameter
		
        // The ref count remnains 2
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::SimulateSnapshotThaw(
    IN      VSS_ID            guidSnapshotSetId
    )
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotThaw

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator
    VSS_E_BAD_STATE
        - Wrong calling sequence

    !!! TBD !!!

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::SimulateSnapshotThaw" );

    try
    {
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        //
        // most likely the shim object is not around since SimulateSnapshotFreeze in
        // VssApi releases the IVssShim interface before it returns.
        //
		if (m_pShim == NULL)
            m_pShim = CVssShimObject::CreateInstance();

        // Call the thaw method.
		ft.hr = m_pShim->SimulateSnapshotThaw(guidSnapshotSetId);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssCoordinator::WaitForSubscribingCompletion()
/*++

Routine description:

    Implements IVssShim::SimulateSnapshotThaw

Error codes:

    E_ACCESSDENIED
        - The user is not a backup operator

    [_Module.WaitForSubscribingCompletion() failures]
        E_UNEXPECTED
            - WaitForSingleObject failures

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::WaitForSubscribingCompletion" );

    try
    {
        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

    	_Module.WaitForSubscribingCompletion();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



CVssCoordinator::~CVssCoordinator()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::~CVssCoordinator" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.cxx | Implementation of Query methods in coordinator interfaces
    @end

Author:

    Adi Oltean  [aoltean]  09/03/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/03/1999  Created
    aoltean     09/09/1999  Adding Query from coord.cxx
                            dss -> vss
	aoltean		09/20/1999	Simplify memory management
	aoltean		09/21/1999	Converting to the new enumerator
	aoltean		09/22/1999  Making the first branch of Query working
	aoltean		09/27/1999	Provider-generic code

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "vs_sec.hxx"
#include "shim.hxx"
#include "coord.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORQRYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  QueryXXXX methods


STDMETHODIMP CVssCoordinator::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssCoordinator::Query method

Arguments:

    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum

Return values:

    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_OUTOFMEMORY
    E_INVALIDARG 
        - Invalid arguments
    VSS_E_OBJECT_NOT_FOUND
        - Queried object not found.
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [GetProviderItf() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY
        
        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssProviderManager::TransferEnumeratorContentsToArray() failures]
        E_OUTOFMEMORY

        [InitializeAsEmpty failed] 
            E_OUTOFMEMORY
        
        [IVssEnumObject::Next() failed]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next. An error log entry is added describing the error.
            VSS_E_PROVIDER_VETO
                - provider error when calling Next

    [IVssSnapshotProvider::Query failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

    [QueryProvidersIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssEnumObject::Query() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next.
            VSS_E_PROVIDER_VETO
                - expected provider error
    
    [CVssProviderManager::GetProviderInterface() failures]     
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY    

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"QueriedObjectId = " WSTR_GUID_FMT
             L", eQueriedObjectType = %d"
             L", eReturnedObjectsType = %d"
             L", ppEnum = %p",
             GUID_PRINTF_ARG( QueriedObjectId ),
             eQueriedObjectType,
             eReturnedObjectsType,
             ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if ((eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            && (eReturnedObjectsType != VSS_OBJECT_PROVIDER))
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Fill now the collection
        switch( eReturnedObjectsType )
        {
        case VSS_OBJECT_SNAPSHOT:
            {
        		// Get the array of interfaces
        		CSnapshotProviderItfArray ItfArray;
        		CVssProviderManager::GetProviderItfArray( ItfArray );

                // Initialize an observer.
                // This will keep track of all Snapshot set IDs that are created 
                // while the queries are in process
                CVssSnasphotSetIdObserver rec;

                // Start recording. This may throw.
                // (stop recording occurs anyway at object destruction if a throw happens after this call)
                rec.StartRecording();

        		// For each provider get all objects tht corresponds to the filter
        		for (int nIndex = 0; nIndex < ItfArray.GetSize(); nIndex++ )
        		{
            		CComPtr<IVssSnapshotProvider> pProviderItf = ItfArray[nIndex].GetInterface();
        			BS_ASSERT(pProviderItf);
   
        			// Query the provider
            		CComPtr<IVssEnumObject> pEnumTmp;
        			ft.hr = pProviderItf->Query(
        				GUID_NULL,
        				VSS_OBJECT_NONE,
        				VSS_OBJECT_SNAPSHOT,
        				&pEnumTmp
        				);
        			if (ft.HrFailed())
        				ft.TranslateProviderError( VSSDBG_COORD, ItfArray[nIndex].GetProviderId(),
                            L"Error calling Query(). [0x%08lx]", ft.hr);
        			
        			// Add enumerator contents to array
        			CVssProviderManager::TransferEnumeratorContentsToArray( 
        			    ItfArray[nIndex].GetProviderId(), pEnumTmp, pArray );
        		}

                // Stop recording. 
                rec.StopRecording();

                // Remove from the array all snapshots that were created during Query.
                for(int nIndex = 0; nIndex < pArray->GetSize();) {
        			VSS_OBJECT_PROP_Ptr& ptr = (*pArray)[nIndex]; 
        			VSS_OBJECT_PROP* pStruct = ptr.GetStruct();
        			BS_ASSERT(pStruct);
        			BS_ASSERT(pStruct->Type == VSS_OBJECT_SNAPSHOT);
                	VSS_SNAPSHOT_PROP* pSnap = &(pStruct->Obj.Snap);

                    // If the snapshot belongs to a partially created snapshot set, remove it.
                	if (rec.IsRecorded(pSnap->m_SnapshotSetId)) {
                	    pArray->RemoveAt(nIndex);
                        // Do not increment - the same index will refer to the next element, if any.
                	} else {
                	    // This element is OK. Proceed with the next one.
                	    nIndex++;
                    }
                }
            }
    		break;
    		
        case VSS_OBJECT_PROVIDER:
            // Insert property structures into array.
    		CVssProviderManager::QuerySupportedProvidersIntoArray( 
    		    true, NULL, pArray );
    		break;

        default:
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        }

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false);
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"Init(%p, %p)", pArrayItf, *pArray);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false);
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"QueryInterface(IID_IVssEnumObject,%p)", ppEnum);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssAdmin::QueryProviders(
    OUT   IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssAdmin::QueryProviders method

Arguments:

    OUT     IVssEnumObject**ppEnum

Return values:

    E_OUTOFMEMORY
    E_INVALIDARG 
        - Invalid arguments
    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [QueryProvidersIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.
            
            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssEnumObject::Query() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next.
            VSS_E_PROVIDER_VETO
                - expected provider error
    
--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::QueryProviders" );
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    try
    {
        // Initialize [out] arguments
        VssZeroOut( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"ppEnum = %p",
             ppEnum
             );

        // Argument validation
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Insert property structures into array.
		CVssProviderManager::QuerySupportedProvidersIntoArray( 
		    true, NULL, pArray );

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object. The array's itf pointer refcount becomes now 2.
        ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);

        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssSnasphotSetIdObserver


//  Global variables
//

// Global list of observers
CVssDLList<CVssSnasphotSetIdObserver*>	 CVssSnasphotSetIdObserver::m_list;

// Global lock fot the observer operations
CVssSafeCriticalSection  CVssSnasphotSetIdObserver::m_cs;


// Implementation
//

// Constructs an observer object
CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver():
    m_bRecordingInProgress(false), 
    m_Cookie(VSS_NULL_COOKIE)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver" );
}


// Destructs the observer object
// This does NOT throw!
CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver" );

    // Check if the critical section is initialized
    if (!m_cs.IsInitialized())
        return;
    
    // Global lock. This does NOT throw!
    CVssSafeAutomaticLock lock(m_cs);

    // Check for validity
    if (!IsValid())
        return;

    // Remove ourselves to the global list of observers
    // This also does not throw.
    CVssSnasphotSetIdObserver* pThis = NULL;
    m_list.ExtractByCookie(m_Cookie, pThis);
    BS_ASSERT(this == pThis);
}


// Check if the observer is valid
bool CVssSnasphotSetIdObserver::IsValid()
{
    return (m_Cookie != VSS_NULL_COOKIE);
}


// Puts the observer in the listeners list in order to detect partial results in Query
// This may safely throw!
void CVssSnasphotSetIdObserver::StartRecording() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StartRecording" );

    // Initialize critical section if needed.
    m_cs.Init();
    if (!m_cs.IsInitialized())
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Unable to initialize the global critical section");

    // Global lock - does not throw
    CVssSafeAutomaticLock lock(m_cs);
    
    // Starts the recording
    BS_ASSERT(m_bRecordingInProgress == false);
    m_bRecordingInProgress = true;

    // Try to add the current snapshot set ID, if any
    // This may throw.
    CVssGlobalSnapshotSetId::InitializeObserver(this);

    // Add ourselves to the global list of observers. 
    // This can throw E_OUTOFMEMORY
    if (m_Cookie != VSS_NULL_COOKIE) {
        BS_ASSERT(false);
        return;
    }
    m_Cookie = m_list.Add(ft, this);
}


// Stop recording SSIDs
void CVssSnasphotSetIdObserver::StopRecording()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StopRecording" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }
    
    // Acquire the critical section. Doesn't throw.
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Stops the recording
    BS_ASSERT(m_bRecordingInProgress == true);
    m_bRecordingInProgress = false;
}


// Check if a SSID was in progress
bool CVssSnasphotSetIdObserver::IsRecorded(
    IN  VSS_ID SnapshotSetID 
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::IsRecorded" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }
    
    // Acquire the critical section
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Check to see if the snapshot set is recorded
    return (m_mapSnapshotSets.FindKey(SnapshotSetID) != -1);
}


// Records this Snapshot Set ID in ALL observers
void CVssSnasphotSetIdObserver::BroadcastSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::BroadcastSSID" );

    // Validate arguments
    BS_ASSERT(SnapshotSetId != GUID_NULL);

    // Do not attempt to broadcast SSIDs if there are no observers
    if (!m_cs.IsInitialized())
        return;
    
    // Acquire the critical section
    CVssSafeAutomaticLock lock(m_cs);

    // Record the SSID for all listeners
    //

    // Get an iterator for the global list of observers
	CVssDLListIterator<CVssSnasphotSetIdObserver*> iterator(m_list);

    // Send the SSID to all observers. If we fail in the middle, 
    // then we are still in a consistent state. In order to simplify 
    // the code we will not add any supplementary checks,
    // since the caller (StartSnapshotSet) will fail anyway, 
    // so we will have an additional harmless filtering for an invalid SSID. 

    // This might throw!
    CVssSnasphotSetIdObserver* pObj = NULL;
	while (iterator.GetNext(pObj))
		pObj->RecordSSID(SnapshotSetId);
}


// Records this Snapshot Set ID in this observer instance
// Remark: The lock is already acquired
void CVssSnasphotSetIdObserver::RecordSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::RecordSSID" );

    // Check to see if recording is in progress.
    if (!m_bRecordingInProgress)
        return;

    // Add the SSID to the internal map
    if (!m_mapSnapshotSets.Add(SnapshotSetId, 0))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\lovelace.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Lovelace.cxx

Abstract:

    Definition of CVssQueuedVolume	


    Adi Oltean  [aoltean]  10/20/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     10/20/1999  Created

--*/

#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORLOVLC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - constructors, destructors and initialization methods


CVssQueuedVolume::CVssQueuedVolume():
	m_hBeginReleaseWritesEvent(NULL),
	m_hFinishHoldWritesEvent(NULL),
	m_InstanceID(GUID_NULL),
	m_ulNumberOfVolumesToFlush(0),
	m_usSecondsToHoldFileSystemsTimeout(nFileSystemsLovelaceTimeout),
	m_usSecondsToHoldIrpsTimeout(nHoldingIRPsLovelaceTimeout),
	m_pwszVolumeName(NULL),
	m_pwszVolumeDisplayName(NULL),
	m_bFlushSucceeded(false),
	m_bReleaseSucceeded(false),
	m_hrFlush(S_OK),
	m_hrRelease(S_OK),
	m_hrOnRun(S_OK)
{
}

	
CVssQueuedVolume::~CVssQueuedVolume()
{
	// Wait for the worker thread to finish, if running.
	// WARNING: FinalReleaseWorkerThreadObject uses virtual methods!
	// Virtual methods in classes derived from CVssQueuedVolume are now inaccessible!
	FinalReleaseWorkerThreadObject();

	// Release the attached strings.
	::VssFreeString(m_pwszVolumeName);
	::VssFreeString(m_pwszVolumeDisplayName);
}


HRESULT CVssQueuedVolume::Initialize(
	IN	LPWSTR pwszVolumeName,
	IN	LPWSTR pwszVolumeDisplayName
	)
/*++

Routine description:

    Initialize a Queued volume object.

Return codes:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssQueuedVolume::Initialize");

	try
	{
		// Copy with the trailing "\\". 
		::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName);

		// Copy the volume displayed name 
		::VssSafeDuplicateStr(ft, m_pwszVolumeDisplayName, pwszVolumeDisplayName);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolume - thread-related methods



void CVssQueuedVolume::SetParameters(
	IN	HANDLE hBeginReleaseWritesEvent,
	IN	HANDLE hFinishHoldWritesEvent,
	IN	VSS_ID	InstanceID,
	IN	ULONG	ulNumberOfVolumesToFlush
	)
{
	m_hBeginReleaseWritesEvent = hBeginReleaseWritesEvent;
	m_hFinishHoldWritesEvent = hFinishHoldWritesEvent;
	m_InstanceID = InstanceID;
	m_ulNumberOfVolumesToFlush = ulNumberOfVolumesToFlush;
}


bool CVssQueuedVolume::OnInit()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnInit" );

	return (m_hBeginReleaseWritesEvent != NULL)
		&& (m_hFinishHoldWritesEvent != NULL)
		&& (m_InstanceID != GUID_NULL)
		&& (m_ulNumberOfVolumesToFlush != 0)
		&& (m_usSecondsToHoldFileSystemsTimeout != 0)
		&& (m_usSecondsToHoldIrpsTimeout != 0);
}


void CVssQueuedVolume::OnRun()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnRun" );

	try
	{
		// Open the IOCTL channel
		// Eliminate the trailing backslash
		// Throw on error 
		BS_ASSERT(::wcslen(m_pwszVolumeName) == nLengthOfVolMgmtVolumeName);
		m_objIChannel.Open(ft, m_pwszVolumeName, true, true);

		// Hold writes
		OnHoldWrites();

		// Signal the thread set that the writes are now hold...
		if (!::SetEvent(m_hFinishHoldWritesEvent))
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"SetEvent(%p)", m_hFinishHoldWritesEvent );
		m_hFinishHoldWritesEvent = NULL;

		// Wait for the "Release Writes" event
		if (::WaitForSingleObject( m_hBeginReleaseWritesEvent, nHoldingIRPsVssTimeout * 1000 ) == WAIT_FAILED)
		    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
		        L"WaitForSingleObject(%p,%d) == WAIT_FAILED", 
		        m_hFinishHoldWritesEvent, nHoldingIRPsVssTimeout * 1000 );

		// Release writes.
		OnReleaseWrites();
	}
	VSS_STANDARD_CATCH(ft);

	m_hrOnRun = ft.hr;
}


void CVssQueuedVolume::OnFinish()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnFinish" );

	m_hBeginReleaseWritesEvent = NULL;	// released by the ThreadSet
	m_hFinishHoldWritesEvent = NULL;	// released by the ThreadSet
	m_InstanceID = GUID_NULL;
	m_ulNumberOfVolumesToFlush = 0;
	m_usSecondsToHoldFileSystemsTimeout = 0;
	m_usSecondsToHoldIrpsTimeout = 0;

	// Mark thread state as finished
	MarkAsFinished();
};


void CVssQueuedVolume::OnTerminate()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnTerminate" );
}


void CVssQueuedVolume::OnHoldWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnHoldWrites" );

	try
	{
		BS_ASSERT(m_bFlushSucceeded == false);
		m_bFlushSucceeded = false;
		
		// pack the IOCTL [in] arguments
		m_objIChannel.Pack(ft, m_InstanceID);
		m_objIChannel.Pack(ft, m_ulNumberOfVolumesToFlush);
		m_objIChannel.Pack(ft, m_usSecondsToHoldFileSystemsTimeout);
		m_objIChannel.Pack(ft, m_usSecondsToHoldIrpsTimeout);

		// send the IOCTL
		m_objIChannel.Call(ft, IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES);

        BS_ASSERT(ft.hr == S_OK);
		m_bFlushSucceeded = true;
	}
	VSS_STANDARD_CATCH(ft)

	m_hrFlush = ft.hr;
};



void CVssQueuedVolume::OnReleaseWrites()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolume::OnReleaseWrites" );

	try
	{
		BS_ASSERT(m_bReleaseSucceeded == false);
		m_bReleaseSucceeded = false;

		// If the Flush IOCTL was succeeded 
        if (IsFlushSucceeded()) {
    		// then send the Release IOCTL.
    		m_objIChannel.Call(ft, IOCTL_VOLSNAP_RELEASE_WRITES);

            BS_ASSERT(ft.hr == S_OK);
    		m_bReleaseSucceeded = true;
        }
	}
	VSS_STANDARD_CATCH(ft)

	m_hrRelease = ft.hr;
};






/////////////////////////////////////////////////////////////////////////////
// CVssQueuedVolumesList


CVssQueuedVolumesList::CVssQueuedVolumesList():
	m_eState(VSS_TS_INITIALIZING),
	m_hBeginReleaseWritesEvent(NULL)
{}
	

CVssQueuedVolumesList::~CVssQueuedVolumesList()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::~CVssQueuedVolumesList" );

	try
	{
		// Remove all volumes from the map
		Reset();

		// Release the internal synchronization objects
		if (m_hBeginReleaseWritesEvent)
			::CloseHandle(m_hBeginReleaseWritesEvent);
	}
	VSS_STANDARD_CATCH(ft)
};


HRESULT CVssQueuedVolumesList::AddVolume(
	WCHAR* pwszVolumeName,
	WCHAR* pwszVolumeDisplayName
	)
/*++

Routine description:

    Adds a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_ALREADY_EXISTS
        - The volume was already added to the snapshot set.
    VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
        - The maximum number of volumes was reached.
    E_OUTOFMEMORY

    [Initialize() failures]
        E_OUTOFMEMORY
        
--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::AddVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);
		BS_ASSERT(pwszVolumeDisplayName && pwszVolumeDisplayName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING) {
		    BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
		}

		// Find if the volume was already added
		if (m_VolumesMap.Lookup(pwszVolumeName))
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_ALREADY_EXISTS, L"Volume already added");

		// Check if the maximum number of objects was reached
		if (m_VolumesMap.GetSize() >= MAXIMUM_WAIT_OBJECTS)
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED,
                      L"The maximum number (%d) of Lovelace threads was reached.",
                      m_VolumesMap.GetSize());

		// Create the queued volume object
		CVssQueuedVolume* pQueuedVol = new CVssQueuedVolume();
		if (pQueuedVol == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Initialize the pQueuedVol object. This method may throw
		ft.hr = pQueuedVol->Initialize(pwszVolumeName, pwszVolumeDisplayName);
		if (ft.HrFailed()) {
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
            		  L"Cannot initialize volume object 0x%08lx", ft.hr);
		}

		// Add the volume object to the map
		// Beware that the volume name is already allocated.
		BS_ASSERT(pQueuedVol->GetVolumeName() != NULL);
		if (!m_VolumesMap.Add(pQueuedVol->GetVolumeName(), pQueuedVol))	{
			delete pQueuedVol;
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
		}
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


HRESULT CVssQueuedVolumesList::RemoveVolume(
	WCHAR* pwszVolumeName
	)
/*++

Routine description:

    Removes a volume to the volume list.

Error codes returned:

    E_UNEXPECTED
        - The thread state is incorrect. No logging is done - programming error.
    VSS_E_OBJECT_NOT_FOUND
        - The volume was not added to the snapshot set.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::RemoveVolume" );

	try
	{
		// Assert parameters
		BS_ASSERT(pwszVolumeName && pwszVolumeName[0]);

		// Make sure the volume list object is initialized
		if (m_eState != VSS_TS_INITIALIZING)
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);

		// Find if the volume was already added
		CVssQueuedVolume* pQueuedVol = m_VolumesMap.Lookup(pwszVolumeName);
		if (pQueuedVol == NULL)
			ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, L"Volume does not exist");

		// Remove the corresponding entry
		BOOL bRemoved = m_VolumesMap.Remove(pwszVolumeName);
		if (!bRemoved) {
			BS_ASSERT(bRemoved);
			ft.Trace( VSSDBG_COORD, L"Error removing the volume entry");
		}

		// Delete the volume object.
		delete pQueuedVol;
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
};


void CVssQueuedVolumesList::Reset()
/*++

Routine description:

    Waits for all background threads. Reset the snapshot set.

Thrown errors:

    None.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::Reset" );

    // If the flush faield this must be treated already in the "flush" error case
    if (  (m_eState == VSS_TS_HOLDING)
        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
    {
        BS_ASSERT(m_VolumesMap.GetSize() > 0);

	    // Wait for all threads to finish. 
	    // This will signal the m_hBeginReleaseWritesEvent event.
	    // WARNING: Ignore return codes from this call. Trace already done.
	    WaitForFinish();
    }

	// Remove all queued volumes
	for(int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++) {
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
		BS_ASSERT(pVol);
		delete pVol;
	}

	// Remove all map entries
	m_VolumesMap.RemoveAll();

    ft.Trace(VSSDBG_COORD, L"Current state %d. Reset to initializing", m_eState);
    m_eState = VSS_TS_INITIALIZING;
}
	

HRESULT CVssQueuedVolumesList::FlushAndHoldAllWrites(
	IN	VSS_ID	SnapshotSetID
	)
/*++

Routine description:

    Creates the background threads.
    Flush and Hold all writes on the background threads.
    Wait until all IOCTLS are performed.

Return codes:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Invalid thread state. Dev error - no entry is put in the event log.
        - Empty volume array. Dev error - no entry is put in the event log.
        - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
    VSS_ERROR_FLUSH_WRITES_TIMEOUT
        - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::FlushAndHoldAllWrites" );

	HANDLE* pHandleArray = NULL;
	INT nFilledHandles = 0;

	try
	{
		// Check to see if the state is correct
        if (m_eState != VSS_TS_INITIALIZING) {
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Bad state %d.", m_eState);
        }

		// Check we have added some volumes first
		if (m_VolumesMap.GetSize() <= 0) {
			BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Improper array size.");
		}

		// Create the Begin Release Writes event, as a manual reset non-signaled event
		if (m_hBeginReleaseWritesEvent == NULL) {
    		m_hBeginReleaseWritesEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    		if (m_hBeginReleaseWritesEvent == NULL)
    			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
    			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");
		} else
		    ::ResetEvent( m_hBeginReleaseWritesEvent );

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Prepares all jobs
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Create the Finish Hold Writes event, as a manual reset non-signaled event
			pHandleArray[nIndex] = ::CreateEvent( NULL, TRUE, FALSE, NULL );
			if (pHandleArray[nIndex] == NULL)
			ft.TranslateGenericError( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
			    L"CreateEvent( NULL, TRUE, FALSE, NULL )");

			// Increase the number of filled handles
			nFilledHandles++;
			BS_ASSERT(nFilledHandles == nIndex + 1);

			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// Transfer parameters to the current job
			pVol->SetParameters(
				m_hBeginReleaseWritesEvent,
				pHandleArray[nIndex],
				SnapshotSetID,
				m_VolumesMap.GetSize()
				);

			// Prepare the job
			ft.hr = pVol->PrepareJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error preparing the job %d [0x%08lx]. ", nIndex, ft.hr);
		}

		// Flush and hold writes. All threads will wait for the event to be signaled.
		// This thread will wait until all IOCTLS were sent.

		// Start (i.e. Resume) all threads
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ ) {
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

			// This can happen only because some thread objects were in invalid state...
			ft.hr = pVol->StartJob();
			if (ft.HrFailed())
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Error starting the job %d [0x%08lx]. ", nIndex, ft.hr);
		}

		// Wait for all threads to send the FlushAndHold IOCTLS.
		if (::WaitForMultipleObjects( m_VolumesMap.GetSize(),
				pHandleArray, TRUE, nFlushVssTimeout * 1000) == WAIT_FAILED)
			ft.TranslateGenericError( VSSDBG_COORD, 
			    HRESULT_FROM_WIN32(GetLastError()), L"WaitForMultipleObjects(%d,%p,1,%d) == WAIT_FAILED", 
			    m_VolumesMap.GetSize(),pHandleArray, nFlushVssTimeout * 1000);

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

            // Check if Flush succeeded.
			if (!pVol->IsFlushSucceeded()) {
                BS_ASSERT(pVol->GetReleaseError() == S_OK);
                
                if ((pVol->GetFlushError() == E_OUTOFMEMORY) ||
                    (pVol->GetOnRunError() == E_OUTOFMEMORY))
                    ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx]",
                        pVol->GetFlushError(), pVol->GetReleaseError(), pVol->GetOnRunError());
			    
			    ft.LogError(VSS_ERROR_FLUSH_WRITES_TIMEOUT, 
			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
				ft.Throw( VSSDBG_COORD, VSS_E_FLUSH_WRITES_TIMEOUT,
						  L"Lovelace failed to hold writes at volume %d - '%s'",
						  nIndex, pVol->GetVolumeDisplayName() );
			}
		}

		m_eState = VSS_TS_HOLDING;
	}
	VSS_STANDARD_CATCH(ft)

	// Close all events (from 0..nFilledHandles-1)
	for (int nIndexTmp = 0; nIndexTmp < nFilledHandles; nIndexTmp++ )
		::CloseHandle(pHandleArray[nIndexTmp]);

	// Deallocate the handle array
	delete[] pHandleArray;

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_FLUSH;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::ReleaseAllWrites()
/*++

Routine description:

    Signals all the background threads to release the writes.
    Wait until all IOCTLS are performed.

Return codes:

    [WaitForFinish() failures]
        E_UNEXPECTED
            - The list of volumes is empty. Dev error - nothing is logged on.
            - SetEvent failed. An entry is put in the error log.
            - WaitForMultipleObjects failed. An entry is put in the error log.
        E_OUTOFMEMORY
            - Cannot create the array of handles.
            - One of the background threads failed with E_OUTOFMEMORY
        VSS_E_HOLD_WRITES_TIMEOUT
            - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::ReleaseAllWrites" );

    try
    {
        // If the flush faield this must be treated already in the "flush" error case
	    if (  (m_eState == VSS_TS_HOLDING)
	        ||(m_eState == VSS_TS_FAILED_IN_FLUSH) )
        {
            BS_ASSERT(m_VolumesMap.GetSize() > 0);
    	    // Wait for all threads to finish.
    	    // This will signal the m_hBeginReleaseWritesEvent event.
    	    ft.hr = WaitForFinish();
    	    if (ft.HrFailed())
    		    ft.Throw( VSSDBG_COORD, ft.hr, L"Error waiting threads for finishing");
	    }
    }
    VSS_STANDARD_CATCH(ft)

	// Check for errors
    if (ft.HrFailed())
		m_eState = VSS_TS_FAILED_IN_RELEASE;

    return ft.hr;
};


HRESULT CVssQueuedVolumesList::WaitForFinish()
/*++

Routine description:

    Wait until all Lovelace threads are finished.

Thrown errors:

    E_UNEXPECTED
        - The list of volumes is empty. Dev error - nothing is logged on.
        - SetEvent failed. An entry is put in the error log.
        - WaitForMultipleObjects failed. An entry is put in the error log.
    E_OUTOFMEMORY
        - Cannot create the array of handles.
        - One of the background threads failed with E_OUTOFMEMORY
    VSS_E_HOLD_WRITES_TIMEOUT
        - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::WaitForFinish" );

	// Table of handles used for synchronization
	HANDLE* pHandleArray = NULL;

	try
	{
		// Release all blocked threads by signaling the m_hBeginReleaseWritesEvent event.
		if(m_hBeginReleaseWritesEvent != NULL) {
			if (!::SetEvent(m_hBeginReleaseWritesEvent))
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()), 
				    L"SetEvent(%p)", m_hBeginReleaseWritesEvent);
		}

		// Get the size of the array.
		if (m_VolumesMap.GetSize() <= 0) {
		    BS_ASSERT(false);
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"Zero array size.");
		}

		// Create the array of handles local to each thread
		pHandleArray = new HANDLE[m_VolumesMap.GetSize()];
		if (pHandleArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

		// Search to find any running threads
		int nThreadHandlesCount = 0;
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);
			
			// Get the thread handle, if it is still running
			// Note: the "prepared" threads will not be in "running" state at this point
			// The only procedure that can fire them up (i.e. StartJob) cannot
			// be called anymore at this point.
			if (pVol->IsStarted()) {
			    HANDLE hThread = pVol->GetThreadHandle();
    			BS_ASSERT(hThread != NULL);
    			pHandleArray[nThreadHandlesCount++] = hThread; // will be closed on job array destruction.
			}
		}

        // If we have threads that we can wait on...
        if (nThreadHandlesCount != 0) {
    		// Wait for all threads to send the Release IOCTLS.
    		if (::WaitForMultipleObjects( nThreadHandlesCount,
    				pHandleArray, TRUE, nReleaseVssTimeout * 1000) == WAIT_FAILED)
				ft.TranslateGenericError( VSSDBG_COORD, 
				    HRESULT_FROM_WIN32(GetLastError()),
				    L"WaitForMultipleObjects(%d,%p,1,%d) == WAIT_FAILED", 
				    nThreadHandlesCount,pHandleArray, nReleaseVssTimeout * 1000);
        }

		// Check for IOCTL errors
		for (int nIndex = 0; nIndex < m_VolumesMap.GetSize(); nIndex++ )
		{
			// Obtain the queued volume object in discussion
			CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndex);
			BS_ASSERT(pVol);

            // Check if Release writers succeeded. 
            if (pVol->IsFlushSucceeded()) {
                BS_ASSERT(pVol->GetFlushError() == S_OK);

                // Check if Release writes succeeded
    			if (!pVol->IsReleaseSucceeded()) {
                    if ((pVol->GetFlushError() == E_OUTOFMEMORY) ||
                        (pVol->GetReleaseError() == E_OUTOFMEMORY) ||
                        (pVol->GetOnRunError() == E_OUTOFMEMORY))
                        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error. [0x%08lx,0x%08lx,0x%08lx]",
                            pVol->GetFlushError(), pVol->GetReleaseError(), pVol->GetOnRunError());
    			    
    			    ft.LogError(VSS_ERROR_HOLD_WRITES_TIMEOUT, 
    			        VSSDBG_COORD << pVol->GetVolumeDisplayName() << (INT)nIndex 
    			            << pVol->GetFlushError() << pVol->GetReleaseError() << pVol->GetOnRunError() );
    				ft.Throw( VSSDBG_COORD, VSS_E_HOLD_WRITES_TIMEOUT,
    						  L"Lovelace failed to hold writes at volume %d - '%s'",
    						  nIndex, pVol->GetVolumeDisplayName() );
    			}
            }
		}

		m_eState = VSS_TS_RELEASED;
	}
	VSS_STANDARD_CATCH(ft)

	// Deallocate the handle array
	delete[] pHandleArray;

	return ft.hr;
};


CComBSTR CVssQueuedVolumesList::GetVolumesList() throw(HRESULT)
/*++

Routine description:

    Gets the list of volumes as a BSTR.

Throws:

    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssQueuedVolumesList::GetVolumesList" );
	CComBSTR bstrVolumeNamesList;

    BS_ASSERT(m_VolumesMap.GetSize() > 0);

	// Concatenate the list of volume display names
	for (int nIndexTmp = 0; nIndexTmp < m_VolumesMap.GetSize(); nIndexTmp++ ) {
		// Obtain the queued volume object in discussion
		CVssQueuedVolume* pVol = m_VolumesMap.GetValueAt(nIndexTmp);
		BS_ASSERT(pVol);

		// Check to see if this is the first item
		if (nIndexTmp == 0) {
			// Put the first volume name
			bstrVolumeNamesList = pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		} else {
			// Append the semicolon
			bstrVolumeNamesList += wszVolumeNamesSeparator;
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
			// Append the next volume name
			bstrVolumeNamesList += pVol->GetVolumeName();
			if (bstrVolumeNamesList.Length() == 0)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
		}
	}

	// Return the built list
	return bstrVolumeNamesList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\provmgr.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module ProvMgr.cxx | Implementation of the CVssProviderManager methods
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created
    aoltean     09/09/1999  Adding AddVolumeTointernalList from coord.cxx
    aoltean     09/09/1999  dss -> vss
    aoltean     09/15/1999  Returning only volume names to the writers.
	aoltean		09/21/1999	Rewriting GetProviderProperties in accordance with the new enumerator.
	aoltean		09/22/1999	Add TransferEnumeratorContentsToArray

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "reg_util.hxx"
#include "provmgr.hxx"
#include "softwrp.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORPRVMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager static members

VSS_OBJECT_PROP_Array* CVssProviderManager::m_pProvidersArray = NULL;

CVssProviderManager* CVssProviderManager::m_pStatefulObjList = NULL;

CVssCriticalSection CVssProviderManager::m_GlobalCS;


/////////////////////////////////////////////////////////////////////////////
//  Query methods



void CVssProviderManager::TransferEnumeratorContentsToArray(
    IN  VSS_ID ProviderId,
    IN  IVssEnumObject* pEnum,
    IN  VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Append to the array the objects returned by this enumerator

Arguments:

    IN  IVssEnumObject* pEnum,          - The enumerator interface used for query
    IN  VSS_OBJECT_PROP_Array* pArray   - The array that will contain the results
    IN  VSS_ID  ProviderID              - The provider ID (for logging in case of errors)

Throw values: 

    E_OUTOFMEMORY

    [InitializeAsEmpty failed] 
        E_OUTOFMEMORY
    
    [IVssEnumObject::Next() failed]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - unexpected provider error when calling Next. An error log entry is added describing the error.
        VSS_E_PROVIDER_VETO
            - provider error when calling Next

Warning:

    The array remains filled partially on error! It is the responsibility of caller to take care.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::TransferEnumeratorContentsToArray");

	BS_ASSERT(pEnum);
	BS_ASSERT(pArray);

	ULONG ulFetched;
	VSS_OBJECT_PROP_Ptr ptrObjectProp;
	while (true)
	{
		// Allocate the new structure object, but with zero contents.
		// The internal pointer must not be NULL.
		// WARNING: This might throw E_OUTOFMEMORY
		ptrObjectProp.InitializeAsEmpty(ft);

		// Get the Next object in the newly allocated structure object.
		// This will fill up hte object's type and fields in the union
		// The pointer fields will refer some CoTaskMemAlloc buffers
		// that must be deallocated by us, after the structure is useless.
		VSS_OBJECT_PROP* pProp = ptrObjectProp.GetStruct();
		BS_ASSERT(pProp);
		ft.hr = pEnum->Next(1, pProp, &ulFetched);
		if (ft.hr == S_FALSE) // end of enumeration
		{
			BS_ASSERT(ulFetched == 0);
			break; // This will destroy the last allocated structure in the VSS_OBJECT_PROP_Ptr destructor
		}
		if (ft.HrFailed())
			ft.TranslateProviderError( VSSDBG_COORD, ProviderId, L"IVssEnumObject::Next" );

		// Add the element to the array.
		// If fails then VSS_OBJECT_PROP_Ptr::m_pStruct will be correctly deallocated
		// by the VSS_OBJECT_PROP_Ptr destructor
		if (!pArray->Add(ptrObjectProp))
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

		// Reset the current pointer to NULL
		ptrObjectProp.Reset(); // The internal pointer was detached into pArray.
	}
}


void CVssProviderManager::QuerySupportedProvidersIntoArray(
    IN      bool bQueryAllProviders,
    IN      VSS_PWSZ pwszVolumeName,
	IN		VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Fill the array with all providers

Arguments:

    BOOL bQueryAllProviders         // If false then query only the providers who supports the volume name below.
	VSS_PWSZ    pwszVolumeName      // The volume name that must be checked.
	VSS_OBJECT_PROP_Array* pArray	// where to put the result.

Throws:

    E_OUTOFMEMORY

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported
        
    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

    [IVssSnapshotProvider::IsVolumeSupported() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::QuerySupportedProvidersIntoArray");
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    BS_ASSERT(bQueryAllProviders || pwszVolumeName );
    BS_ASSERT(!bQueryAllProviders || !pwszVolumeName );
	BS_ASSERT(pArray);

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw E_OUTOFMEMORY
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

    // Add elements to the collection
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
		// Get the structure object from the array
		VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		// Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
		BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;
		
        // Check if we aplying a filter
        if (!bQueryAllProviders) {
    		// Create the IVssSnapshotProvider interface, if needed
            // The ref count will remain 1
    		if (ptrProperties.m_pProviderItf == NULL) {
    		    // Warning: This call may throw 
                ptrProperties.m_pProviderItf.Attach(
                    CVssSoftwareProviderWrapper::CreateInstance( 
                        ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
    			BS_ASSERT(ptrProperties.m_pProviderItf);
    		}

    		// Check if the volume is supported by this provider
    		BOOL bIsSupported = FALSE;
    		ft.hr = ptrProperties.m_pProviderItf->IsVolumeSupported( pwszVolumeName, &bIsSupported );
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD, 
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", pwszVolumeName);
    		if (ft.HrFailed())
    			ft.TranslateProviderError( VSSDBG_COORD, ProviderProp.m_ProviderId, 
    			    L"IVssSnapshotProvider::IsVolumeSupported() failed with 0x%08lx", ft.hr );

            // If the provider does not support this volume then continue the enumeration.
            if (!bIsSupported)
                continue;
        }

		// Build the structure
		// This might throw E_OUTOFMEMORY
		ptrProviderProperties.InitializeAsProvider( ft,
			ProviderProp.m_ProviderId,
			ProviderProp.m_pwszProviderName,
  			ProviderProp.m_eProviderType,
			ProviderProp.m_pwszProviderVersion,
			ProviderProp.m_ProviderVersionId,
			ProviderProp.m_ClassId);

		// Insert provider into the array.
		// If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
		if (!pArray->Add(ptrProviderProperties))
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

		// Reset the current pointer to NULL since the internal pointer was detached into pArray.
		ptrProviderProperties.Reset();
    }
}


BOOL CVssProviderManager::GetProviderInterface(
	IN		VSS_ID ProviderId,
	OUT		IVssSnapshotProvider** ppProviderInterface
    )

/*++

Routine Description:

    Get the interface corresponding to this provider Id.

Arguments:

	VSS_ID ProviderId,				// Provider Id
	IVssSnapshotProvider** ppProviderInterface // the provider interface

Return value:
	TRUE, if provider was found
	FALSE otherwise.

Throws:
    E_OUTOFMEMORY

    [lockObj failures]
        E_OUTOFMEMORY    

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterface");

	BS_ASSERT(ppProviderInterface);

	// Reset the interface pointer
	(*ppProviderInterface) = NULL;

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw E_OUTOFMEMORY exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

    // Find that provider
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
		// Get the structure object from the array
		VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		// Get the provider structure
		BS_ASSERT(ptrProperties.GetStruct());
		BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;
		
		// Check if provider was found.
		if (ProviderProp.m_ProviderId != ProviderId)
			continue;

		// Create the IVssSnapshotProvider interface, if needed
		// This may throw if an error occurs at COM object creation!
		if (ptrProperties.m_pProviderItf == NULL)
		{
            ptrProperties.m_pProviderItf.Attach(
                CVssSoftwareProviderWrapper::CreateInstance( 
                    ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
			BS_ASSERT(ptrProperties.m_pProviderItf);
		}

		// Put an interface reference into ppProviderInterface
		ft.hr = ptrProperties.m_pProviderItf.CopyTo(ppProviderInterface);
		BS_ASSERT(ft.HrSucceeded());

		// Exit from the loop
		break;
    }

	return (ppProviderInterface && *ppProviderInterface);
}


void CVssProviderManager::GetProviderItfArray(
	IN		CSnapshotProviderItfArray& ItfArray
	)

/*++

Routine Description:

    Get the array of all provider interfaces

Arguments:

	CSnapshotProviderItfArray& ItfArray

Throws:

    E_OUTOFMEMORY

    [lockObj failures]
        E_OUTOFMEMORY
    
    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderItfArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

	try
	{
		// find that provider
		for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
		{
			// Get the structure object from the array
			VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

			// Get the provider structure
			BS_ASSERT(ptrProperties.GetStruct());
			BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
			VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

			// Create the IVssSnapshotProvider interface, if needed
			if (ptrProperties.m_pProviderItf == NULL) {
                ptrProperties.m_pProviderItf.Attach(
                    CVssSoftwareProviderWrapper::CreateInstance( 
                        ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
				BS_ASSERT(ptrProperties.m_pProviderItf);
			}

			// Interface reference count is increased (and decreased at block exit).
			CProviderItfNode node(ProviderProp.m_ProviderId, ptrProperties.m_pProviderItf);

			// Add the interface to the array. 
			// Interface reference count is increased again.
			if (!ItfArray.Add(node))
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
						  L"Cannot add element to the array");
		}
	}
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
	{
		ItfArray.RemoveAll();
		ft.Throw( VSSDBG_COORD, ft.hr,
				  L"Cannot add element to the array");
	}
}


/////////////////////////////////////////////////////////////////////////////
//  Provider array management


void CVssProviderManager::LoadInternalProvidersArray()

/*++

Routine Description:

    Fill the array with all providers, if not initialized

Arguments:


Warnings:

	Each time when you access m_pProvidersArray you should call first this method.

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - error while reading from registry. An error log entry is added describing the error.

    [GetProviderProperties() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::LoadInternalProvidersArray");

    VSS_OBJECT_PROP_Ptr ptrProviderProperties;
    WCHAR       wszKeyName[_MAX_KEYNAME_LEN];
    HKEY        hKeyProviders = NULL;
    FILETIME    time;
    LONG        lRes;

    try
    {
        // The lock should be active now.
        BS_ASSERT(m_GlobalCS.IsLocked());
    
		// If needed, reconstruct the array from registry.
		if (m_pProvidersArray == NULL)
		{
			// Create the collection object. Initial reference count is 0.
			m_pProvidersArray = new VSS_OBJECT_PROP_Array;
			if (m_pProvidersArray == NULL)
				ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

			// Open the "Providers" key.
			::wsprintf( wszKeyName, L"%s\\%s", wszVSSKey, wszVSSKeyProviders);
			lRes = ::RegOpenKeyExW(
				HKEY_LOCAL_MACHINE, //  IN HKEY hKey,
				wszKeyName,         //  IN LPCWSTR lpSubKey,
				0,                  //  IN DWORD ulOptions,
				KEY_ALL_ACCESS,     //  IN REGSAM samDesired,
				&hKeyProviders      //  OUT PHKEY phkResult
				);
			if (lRes != ERROR_SUCCESS)
			    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
			        L"RegOpenKeyExW(HKLM,%s\\%s,0,KEY_ALL_ACCESS,&ptr)", wszVSSKey, wszVSSKeyProviders );
			BS_ASSERT(hKeyProviders);

			// Add elements to the collection
			bool bLastProviderInEnumeration = false;
			for (DWORD dwIndex = 0; !bLastProviderInEnumeration; dwIndex++)
			{
				// Fill wszKeyName with the name of the subkey
				DWORD dwSize = _MAX_KEYNAME_LEN;
				lRes = ::RegEnumKeyExW(
					hKeyProviders,      // IN HKEY hKey,
					dwIndex,            // IN DWORD dwIndex,
					wszKeyName,         // OUT LPWSTR lpName,
					&dwSize,            // IN OUT LPDWORD lpcbName,
					NULL,               // IN LPDWORD lpReserved,
					NULL,               // IN OUT LPWSTR lpClass,
					NULL,               // IN OUT LPDWORD lpcbClass,
					&time);             // OUT PFILETIME lpftLastWriteTime
				switch(lRes)
				{
				case ERROR_SUCCESS:
					BS_ASSERT(dwSize != 0);

					// Get the provider properties structure
					ft.hr = CVssProviderManager::GetProviderProperties(
								hKeyProviders,
								wszKeyName,
								ptrProviderProperties
								);
					if (ft.HrFailed())
					{
						// Do not throw in case that the registry contain keys with bad format.
						ft.Warning( VSSDBG_COORD,
								  L"Error on getting Provider properties for %s. [0x%08lx]",
								  wszKeyName, ft.hr );
						BS_ASSERT(ptrProviderProperties.GetStruct() == NULL);
						break;  // Continue the iteration
					}
					BS_ASSERT(ptrProviderProperties.GetStruct());
					BS_ASSERT(ptrProviderProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);

					// Insert it into the array.
					// If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
					if (!m_pProvidersArray->Add(ptrProviderProperties))
						ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
								  L"Cannot add element to the array");

					// Reset the current pointer to NULL since
					// the internal pointer was detached into pArray.
					ptrProviderProperties.Reset();

					break; // Go to Next key, if not find yet.

				case ERROR_NO_MORE_ITEMS:
					bLastProviderInEnumeration = true;
					break; // End of iteration

				default:
				    // RegEnumKeyExW failure
    			    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
    			        L"RegEnumKeyExW(HKLM\\%s\\%s,%s,%d,...)", 
    			        wszVSSKey, wszVSSKeyProviders, wszKeyName, dwIndex );
				}
			}
		}
		BS_ASSERT(m_pProvidersArray);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProviders? ::RegCloseKey(hKeyProviders): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace( VSSDBG_COORD, L"Error closing the hKeyProviders key. [0x%08lx]", GetLastError());

    // If an error occured then throw it outside
	if (ft.HrFailed()) {
	    // Unload the array of providers
	    UnloadInternalProvidersArray();
	    // Throw the corresponding error
		ft.Throw( VSSDBG_COORD, ft.hr, L"Cannot load the internal providers array [0x%08lx]", ft.hr);
	}
}


void CVssProviderManager::UnloadInternalProvidersArray()

/*++

Routine Description:

    Destroy the static array, if exist.
	Call OnUnload for all providers.
	Deallocate all cached provider interface references.

Arguments:

    None.

Caller:

	You should call this method at program termination.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::UnloadInternalProvidersArray");

    try
    {
        // Lock the global critical section for the duration of this block
        // WARNING: This call may throw exceptions!
        CVssAutomaticLock2 lockObj(m_GlobalCS); 

    	if (m_pProvidersArray != NULL)
    	{
    		for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    		{
    			// Get the structure object from the array
    			VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

    			// Notify the provider that is being unloaded.
    			if (ptrProperties.m_pProviderItf != NULL)
    			{
    				CComPtr<IVssProviderNotifications> pNotificationsItf;
    				ft.hr = ptrProperties.m_pProviderItf->SafeQI(
    							IVssProviderNotifications, &pNotificationsItf );

    				// If the provider supports notifications, send them to it.
    				if (ft.HrSucceeded())
    				{
                        // We force provider unloading since the service goes down.
    					BS_ASSERT(pNotificationsItf);
    					ft.hr = pNotificationsItf->OnUnload(TRUE);
    					if (ft.HrFailed())
    						ft.Warning( VSSDBG_COORD,
    								  L"Cannot unload load the internal provider");
    				}
    			}
    		}

    		// Delete silently the array and all its elements.
    		// This will release the provider interfaces too.
    		delete m_pProvidersArray;
    		m_pProvidersArray = NULL;

    		// Unload all unused COM server DLLs in this service
    		::CoFreeUnusedLibraries();
    	}
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		ft.Warning( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);
}


void CVssProviderManager::AddProviderIntoArray(				
	IN		VSS_ID ProviderId,
	IN      VSS_PWSZ pwszProviderName,
    IN      VSS_PROVIDER_TYPE eProviderType,
	IN      VSS_PWSZ pwszProviderVersion,
	IN      VSS_ID ProviderVersionId,
	IN      CLSID ClassId
	)

/*++

Routine Description:

    Add that provider to the array. This has nothing to do with the registry.
	The caller is supposed to add the provider to the registry also.

	Called only by the RegisterProvider method.

Arguments:

	VSS_ID ProviderId,				// Id of the provider
	VSS_PWSZ pwszProviderName,
    VSS_PROVIDER_TYPE eProviderType,
	VSS_PWSZ pwszProviderVersion,
	VSS_ID ProviderVersionId,
	CLSID ClassId

Throws:

    E_OUTOFMEMORY

    [lockObj failures] or
    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AddProviderIntoArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	if (m_pProvidersArray)
	{
		VSS_OBJECT_PROP_Ptr ptrProviderProperties;
		ptrProviderProperties.InitializeAsProvider( ft,
			ProviderId,
			pwszProviderName,
            eProviderType,
			pwszProviderVersion,
			ProviderVersionId,
			ClassId	);

		// Insert it into the array.
		// If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
		if (!m_pProvidersArray->Add(ptrProviderProperties))
			ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
					  L"Cannot add element to the array");

		// Reset the current pointer to NULL since
		// the internal pointer was detached into pArray.
		ptrProviderProperties.Reset();
	}
}


bool CVssProviderManager::RemoveProviderFromArray(
	IN		VSS_ID ProviderId
    )

/*++

Routine Description:

	Eliminates the corresponding array element.
    WARNING: Also load, unload and unregister the provider with the given Id.

	Called only by the UnregisterProvider method

Arguments:

	VSS_ID ProviderId			// The provider Id

Return value:

    true - if the provider was sucessfully removed
    false - if there is no provider registered under that ID.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::RemoveProviderFromArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	// Load m_pProvidersArray, if needed.
	LoadInternalProvidersArray();
	BS_ASSERT(m_pProvidersArray);

	// Find that provider
	bool bFind = false;
	for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
	{
		// Get the structure object from the array
		VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		// Get the provider structure
		BS_ASSERT(ptrProperties.GetStruct());
		BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;
		
		// Check if provider was found.
		if (ProviderProp.m_ProviderId != ProviderId)
			continue;

		// We will try OnUnload only on providers that were loaded
		// Call notifications, if possible
		if (ptrProperties.m_pProviderItf)
		{
			CComPtr<IVssProviderNotifications> pNotificationsItf;
			ft.hr = ptrProperties.m_pProviderItf->SafeQI( IVssProviderNotifications, &pNotificationsItf );

			// If the provider supports notifications, send them to it.
			if (ft.HrSucceeded())
			{
				BS_ASSERT(pNotificationsItf);
				ft.hr = pNotificationsItf->OnUnload(FALSE);
				if (ft.HrFailed())
					ft.Warning( VSSDBG_COORD, L"Cannot unload the internal provider");
			}
		}

		// Delete the element from the array.
		m_pProvidersArray->RemoveAt(nIndex);

		// Unload all unused COM server DLLs in this service
		::CoFreeUnusedLibraries();

		// Exit from the loop
		bFind = true;
		break;
	}

	return bFind;
}


/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager private methods



HRESULT CVssProviderManager::GetProviderProperties(
    IN  HKEY hKeyProviders,
    IN  LPCWSTR wszProviderKeyName,
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties
    )

/*++

Routine Description:

    Get provider properties from registry.

Arguments:

    IN  HKEY hKeyProviders,							// The providers Key
    IN  LPCWSTR wszProviderKeyName,					// The provider Key name (actually a guid)
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties  // will return an allocated structure containing provider properties

Return values:

    E_OUTOFMEMORY
    E_UNEXPECTED 
        - on registry failures. An error log entry is added describing the error.

    [QueryStringValue failures] or 
    [QueryDWORDValue] failures
        E_OUTOFMEMORY
        E_UNEXPECTED 
            - on registry failures. An error log entry is added describing the error.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderProperties");

    HKEY hKeyProvider = NULL;
    HKEY hKeyCLSID = NULL;
    LONG lRes;

    BS_ASSERT( hKeyProviders );
    BS_ASSERT( wszProviderKeyName != NULL && wszProviderKeyName[0] != L'\0' );
    BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );

    try
    {
        // Convert wszProviderKeyName into ProviderId.
		VSS_ID ProviderId;
        ft.hr = ::CLSIDFromString( W2OLE(const_cast<LPWSTR>(wszProviderKeyName)), &ProviderId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CLSIDFromString(%s)", wszProviderKeyName);

        // Open the provider key
        lRes = ::RegOpenKeyExW(
            hKeyProviders,      //  IN HKEY hKey,
            wszProviderKeyName, //  IN LPCWSTR lpSubKey,
            0,                  //  IN DWORD ulOptions,
            KEY_READ,           //  IN REGSAM samDesired,
            &hKeyProvider       //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"RegOpenKeyExW(hKeyProviders,%s,KEY_READ,...)", wszProviderKeyName);
        BS_ASSERT(hKeyProvider);

		// Get the provider name
		WCHAR wszProviderName[_MAX_VALUE_LEN];
		QueryStringValue( ft,
			hKeyProvider,
			wszProviderKeyName,
			wszVSSProviderValueName,
			_MAX_VALUE_LEN,
			wszProviderName
			);
		BS_ASSERT(wszProviderName[0] != L'\0');

		// Get the provider type
		DWORD dwProviderType = 0;
		QueryDWORDValue( ft,
			hKeyProvider,
			wszProviderKeyName,
			wszVSSProviderValueType,
			&dwProviderType
			);

        VSS_PROVIDER_TYPE eProviderType = VSS_PROV_UNKNOWN;
        switch(dwProviderType) {
        case VSS_PROV_SYSTEM:
        case VSS_PROV_SOFTWARE:
        case VSS_PROV_HARDWARE:
            eProviderType = (VSS_PROVIDER_TYPE) dwProviderType;
            break;
        default:
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"QueryDWORDValue(hProvider,%s,%s,%d)", 
                wszProviderKeyName,
    			wszVSSProviderValueType,
    			dwProviderType);
        }

        // Get the provider version string
		WCHAR wszProviderVersion[_MAX_VALUE_LEN];
		QueryStringValue( ft,
			hKeyProvider,
			wszProviderKeyName,
			wszVSSProviderValueVersion,
			_MAX_VALUE_LEN,
			wszProviderVersion
			);

        // Get the provider version Id
		WCHAR wszProviderVersionId[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            wszVSSProviderValueVersionId,
            _MAX_VALUE_LEN,
            wszProviderVersionId
            );
        BS_ASSERT(wszProviderVersionId[0] != L'\0');

        // Convert wszValueBuffer into ProviderVersionId .
		VSS_ID ProviderVersionId;
        ft.hr = ::CLSIDFromString(W2OLE(wszProviderVersionId), &ProviderVersionId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszProviderVersionId);

        // Open the CLSID key of that provider
        lRes = ::RegOpenKeyExW(
            hKeyProvider,           //  IN HKEY hKey,
            wszVSSKeyProviderCLSID, //  IN LPCWSTR lpSubKey,
            0,                      //  IN DWORD ulOptions,
            KEY_ALL_ACCESS,         //  IN REGSAM samDesired,
            &hKeyCLSID              //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"CLSIDFromString(%s)", wszProviderVersionId);
        BS_ASSERT(hKeyCLSID);

        // Get the content of the default value
		WCHAR wszClsid[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyCLSID,
            wszVSSKeyProviderCLSID,
            wszVSSCLSIDValueName,
            _MAX_VALUE_LEN,
            wszClsid
            );
        BS_ASSERT(wszClsid[0] != L'\0');

        // Get the clsid. Remark: if W2OLE fails a SE is thrown
		CLSID ClassId;
        ft.hr = ::CLSIDFromString(W2OLE(wszClsid), &ClassId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszClsid);

		// Initialize the Properties pointer. If an error occurs an exception is thrown.
		ptrProviderProperties.InitializeAsProvider(ft,
			ProviderId,
			wszProviderName,
            eProviderType,
			wszProviderVersion,
			ProviderVersionId,
			ClassId);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProvider? ::RegCloseKey(hKeyProvider): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyProvider key. [0x%08lx]", GetLastError());

    lRes = hKeyCLSID? ::RegCloseKey(hKeyCLSID): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyCLSID key. [0x%08lx]", GetLastError());

    // If something went wrong, the out must be NULL.
    if (ft.HrFailed()) {
		BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );
	}

    return ft.hr;
}


void CVssProviderManager::Activate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateful.

	The concrete case the current object is a coordinator interface. This interface have no state
	in the moment when StartSnapshotSet is called. After that the state will contain the
	snapshot set Id, the list of involved snapshots (providers), etc.

	When DoSnapshotSet is called then the state is lost and the object must be taken out from the
	global list of stategful objects.

	This whole thing is done to allow AbortAllSnapshotsInProgress to take action on all objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Activate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	if (!m_bHasState)
	{
		m_pNext = m_pPrev = NULL; // for safety

		if (m_pStatefulObjList != NULL)
		{
			BS_ASSERT(m_pStatefulObjList->m_pPrev == NULL);
			m_pStatefulObjList->m_pPrev = this;
		}
		m_pNext = m_pStatefulObjList;
		m_pStatefulObjList = this;
		m_bHasState = true;
	}
}


void CVssProviderManager::Deactivate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateless.

	The concrete case the current object is a coordinator interface. This interface have no state
	in the moment when StartSnapshotSet is called. After that the state will contain the
	snapshot set Id, the list of involved snapshots (providers), etc.

	When DoSnapshotSet is called then the state is lost and the object must be taken out from the
	global list of stategful objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Deactivate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	if (m_bHasState)
	{
		if (m_pPrev != NULL) // we are in the middle
			m_pPrev->m_pNext = m_pNext;
		else // we are the first
		{
			BS_ASSERT(m_pStatefulObjList == this);
			m_pStatefulObjList = m_pNext;
		}

		if (m_pNext != NULL)
			m_pNext->m_pPrev = m_pPrev;

		m_pNext = m_pPrev = NULL;
		m_bHasState = false;

		// Warning: this call may throw errors!
		OnDeactivate();
	}
}


void CVssProviderManager::DeactivateAll()

/*++

Routine Description:

    Deactivate all activated objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [OnDeactivate failures]
        TBD

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::DeactivateAll");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS); 

	while (m_pStatefulObjList)
	{
		CVssProviderManager* pFirstObj = m_pStatefulObjList;

		BS_ASSERT(pFirstObj->m_bHasState);
		pFirstObj->m_bHasState = false;

		BS_ASSERT(pFirstObj->m_pPrev == NULL);
		m_pStatefulObjList = pFirstObj->m_pNext;

		if (pFirstObj->m_pNext != NULL)
		{
			BS_ASSERT(pFirstObj->m_pNext->m_pPrev == pFirstObj);
			pFirstObj->m_pNext->m_pPrev = NULL;

			pFirstObj->m_pNext = NULL;
		}

		pFirstObj->OnDeactivate();
	}
}


bool CVssProviderManager::AreThereStatefulObjects()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AreThereStatefulObjects");

    return (m_pStatefulObjList != NULL);
};



void CVssProviderManager::GetProviderInterfaceForSnapshotCreation(
	IN		VSS_ID ProviderId,
	OUT		IVssSnapshotProvider** ppProviderInterface
	)
/*++

Method:

    CVssProviderManager::GetProviderInterfaceForSnapshotCreation

Description:

    To be called only in AddToSnapshotSet

    This method caches a list of provider interfaces per coordinator instance, named the local cache.
    The list is an associative array ProviderID - interface designed to be used only during the
    snapshot creation protocol.

    This method does not rely on the global Provider interface cached into
    the global Providers array. (i.e. on the "global cache").
    This is because we need to handle "auto-delete" snapshots
    and we link the lifetime of all auto-delete snapshots with the lifetime of the
    originating provider interface. Therefore there might be several provider interfaces with different
    lifetimes.

    Each coordinator object will keep on its own lifetime a list of provider interfaces
    that corresponds to each "used" provider ID. If the coordinator object goes away then
    all used provider interfaces will be released, therefore giving a chance to the provider to
    delete the "auto-delete" snapshots.

Algorithm:

    If a cached interface exists in the current coordinator object then it will be returned. Otherwise
    a new instance will be created, inserted into the local cache and returned.

Info:

    The ref count for the returned interface is at least 2 (one reference in the local cache and another
    which is returned.

Throws:

    VSS_E_PROVIDER_NOT_REGISTERED

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [CVssSoftwareProviderWrapper::CreateInstance() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.
        
        [OnLoad() failures]
        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
                
--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterfaceForSnapshotCreation");

	BS_ASSERT(ppProviderInterface);
    
	// Reset the interface pointer
	(*ppProviderInterface) = NULL;

    // Lookup for the interface cached under that provider.
    CComPtr<IVssSnapshotProvider> pItf = m_mapProviderItfLocalCache.Lookup(ProviderId);
    if (pItf == NULL) {

        // No interface found

        // Lock the global critical section for the duration of this block
        // WARNING: This call may throw exceptions!
        CVssAutomaticLock2 lockObj(m_GlobalCS); 

	    // Load m_pProvidersArray, if needed.
	    LoadInternalProvidersArray();
	    BS_ASSERT(m_pProvidersArray);

        // Find that provider
        bool bFound = false;
        for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
        {
		    // Get the structure object from the array
		    VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

		    // Get the provider structure
		    BS_ASSERT(ptrProperties.GetStruct());
		    BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
		    VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

		    // Check if provider was found.
		    if (ProviderProp.m_ProviderId != ProviderId)
			    continue;

            // Create the global cached interface (to correctly handle OnUnload)
            // The ref count will remain 1 on the global interface
			if (ptrProperties.m_pProviderItf == NULL)
			{
                ptrProperties.m_pProviderItf.Attach(
                    CVssSoftwareProviderWrapper::CreateInstance( 
                        ProviderProp.m_ProviderId, ProviderProp.m_ClassId, true ));
				BS_ASSERT(ptrProperties.m_pProviderItf);
			}

            // Create the local cached interface
            // Now pItf will keep an interface pointer with ref count == 1,
            // since pItf is a smart pointer.
            pItf.Attach(CVssSoftwareProviderWrapper::CreateInstance( 
                ProviderProp.m_ProviderId, ProviderProp.m_ClassId, false ));
			BS_ASSERT(pItf);

            // Put a copy into the local cache. The ref count becomes 2
            if (!m_mapProviderItfLocalCache.Add(ProviderId, pItf))
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

		    // Put an interface reference into ppProviderInterface. The ref count goes to 3
		    ft.hr = pItf.CopyTo(ppProviderInterface);
            BS_ASSERT(ft.HrSucceeded());

		    // Exit from the loop
		    bFound = true;
		    break;
        }

        if (!bFound)
            ft.Throw( VSSDBG_COORD, VSS_E_PROVIDER_NOT_REGISTERED, 
                L"Provider with ID = " WSTR_GUID_FMT L" not registered", GUID_PRINTF_ARG(ProviderId) );
        
    } else {

        // Interface found in the map.
        // The ref count is 2 (one from the map, one from the smart pointer)

		// Put an interface reference into ppProviderInterface. The ref count goes to 3
		ft.hr = pItf.CopyTo(ppProviderInterface);
        BS_ASSERT(ft.HrSucceeded());
    }

    // Unless there was no interface found the smart pointer ref goes from 3 to 2
    // Remaining interfaces: one in returned itf, another in the map
    BS_ASSERT(*ppProviderInterface);
}


CVssProviderManager::~CVssProviderManager()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::~CVssProviderManager");

	BS_ASSERT((m_pNext == NULL) && (m_pPrev == NULL) && !m_bHasState );

    // The local cache interfaces must be automatically released
    // Here the auto-delete snapshots are deleted.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\shim.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Shim.cxx | Implementation of CVssShimObject
    @end

Author:

    Adi Oltean  [aoltean]  07/20/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/20/2000  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"

#include "shim.hxx"

#include "vswriter.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSHIMC"
//
////////////////////////////////////////////////////////////////////////

// Global semaphore used to serialize creation of snapshot sets, CVssShimObject also uses
// this semaphore to serialize both StartSnapshotSet and SimulateSnapshotFreeze.  Defined
// in snap_set.cxx.
extern LONG g_hSemSnapshotSets;

/////////////////////////////////////////////////////////////////////////////
//  CVssShimObject


HRESULT CVssShimObject::SimulateSnapshotFreeze(
    IN      VSS_ID          guidSnapshotSetId,
	IN      ULONG           ulOptionFlags,	
	IN      ULONG           ulVolumeCount,	
	IN      VSS_PWSZ*       ppwszVolumeNamesArray
	)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotFreeze" );

    try
    {
		BS_ASSERT(!m_bHasAcquiredSem);

        // Trace the input parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: SnapshotSetID = " WSTR_GUID_FMT L" "
            L" OptionFlags = %lu, VolumeCount = %d", 
            GUID_PRINTF_ARG(guidSnapshotSetId), ulOptionFlags, ulVolumeCount );
        for ( ULONG ulIndex = 0; ulIndex < ulVolumeCount ; ulIndex++ )
            ft.Trace( VSSDBG_COORD, L"   Volume[%02d]= %s", 
                ulIndex, ppwszVolumeNamesArray[ulIndex] );

        // Prevent simultaneous creation of multiple snapshot sets and SimulateSnapshotFreeze
        // on the same machine.
		if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
			ft.Throw
				(
				VSSDBG_COORD,
				VSS_E_SNAPSHOT_SET_IN_PROGRESS,
				L"Snapshot set creation is already in progress."
				);
        m_bHasAcquiredSem = true;

        //
        // Finally call into the VssApi.DLL's SimulateSnaphotFreezeInternal!
        //
        PFunc_SimulateSnapshotFreezeInternal pFuncFreeze;
        _Module.GetSimulateFunctions( &pFuncFreeze, NULL );
        if ( pFuncFreeze != NULL )
        {
            m_guidSimulateSnapshotSetId = guidSnapshotSetId;        
            ft.hr = pFuncFreeze( guidSnapshotSetId, ulOptionFlags,	ulVolumeCount,	ppwszVolumeNamesArray, &m_bCancel );
            if ( ft.HrFailed() )
            {
                ft.Trace( VSSDBG_COORD, L"ERROR: SimulateSnapshotFreezeInternal returned hr: 0x%08lx", ft.hr );
            }
        }
        else
        {
            ft.Trace( VSSDBG_COORD, L"ERROR: pFuncFreeze is NULL, no registered simulate snapshot function!!" );
        }
        
        if ( ft.HrSucceeded() )
        {
            TestIfCancelNeeded(ft);        
        }
    }
    VSS_STANDARD_CATCH(ft);

	// Cleanup on error...
	if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
	{
		ft.Trace( VSSDBG_COORD, L"Abort detected 0x%08lx", ft.hr );
        // These functions should not throw

        // If it was a cancel then abort the snapshot set in progress.
        if (ft.hr == VSS_S_ASYNC_CANCELLED) {
            // TBD: User cancelled.            
        }

        // Thaw any shim writers that got frozen before the error occurred or the
        // async operation was cancelled.  Note that SimulateSnapshotThaw will
        // release the semaphore.
        if ( m_bHasAcquiredSem )
            SimulateSnapshotThaw( guidSnapshotSetId );
	}

    // We may return here VSS_S_ASYNC_CANCELLED
    return ft.hr;
}


HRESULT CVssShimObject::SimulateSnapshotThaw(
    IN      VSS_ID          guidSnapshotSetId
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::SimulateSnapshotThaw" );

    //
    // Finally call into the VssApi.DLL's SimulateSnaphotThawInternal!
    //
    PFunc_SimulateSnapshotThawInternal pFuncThaw;
    _Module.GetSimulateFunctions( NULL, &pFuncThaw );
    if ( pFuncThaw != NULL )
    {
        pFuncThaw( guidSnapshotSetId );
    }
    else
    {
        ft.Trace( VSSDBG_COORD, L"ERROR: pFuncThaw is NULL, no registered simulate snapshot function!!" );
    }

    //
    //  Thaw can be called out of order since the requestor might be making sure that
    //  all writers thaw properly.
    //
    if ( m_bHasAcquiredSem )
    {
    	if ( InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1) == 1 )
            m_bHasAcquiredSem = false;
    }

    m_guidSimulateSnapshotSetId = GUID_NULL;
    
    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


void CVssShimObject::TestIfCancelNeeded(
	IN	CVssFunctionTracer& ft
    ) throw(HRESULT)
{
	if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


STDMETHODIMP CVssShimObject::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CVssShimObject::AddRef()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::AddRef");
	
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssShimObject::Release()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::Release");
	
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssShimObject* CVssShimObject::CreateInstance() throw(HRESULT)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CreateInstance");
	
	CVssShimObject* pObj = new CVssShimObject;
	if (pObj == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	if (FAILED(pObj->FinalConstructInternal()))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

	return pObj;
}


HRESULT CVssShimObject::FinalConstructInternal()
{
	return S_OK;
}


CVssShimObject::CVssShimObject():
	m_bCancel(false),
	m_lRef(0),
	m_guidSimulateSnapshotSetId( GUID_NULL ),
	m_bHasAcquiredSem( false )
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssShimObject::CVssShimObject");
}


CVssShimObject::~CVssShimObject()
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssShimObject::~CVssShimObject");

	//
	// If we acquired the semaphore then make
	// sure to call SimulateSnapshotThaw.  This happens if the requestor doesn't
	// call it before exiting.
	//
	if ( m_bHasAcquiredSem )
	{
        ft.Trace( VSSDBG_COORD, L"Calling SimulateSnapshotThaw since requestor did not do so" );
        SimulateSnapshotThaw( m_guidSimulateSnapshotSetId );

        //  Make sure we always clear the semaphore.  SimulateSnapshotThaw should always 
        if ( m_bHasAcquiredSem )
        {
        	InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
        	m_bHasAcquiredSem = false;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\reg_util.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module reg_util.cxx | Implementation of the Registry-related functions
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "reg_util.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORREGUC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssCoordinator private methods


void RecursiveDeleteKey(
    IN  CVssFunctionTracer& ft,
    IN  HKEY hParentKey,
    IN  LPCWSTR wszName
    )

/*++

Routine Description:

    Deletes recursively a registry key.

Arguments:

    IN  CVssFunctionTracer& ft,     // function tracer of the caller
    IN  HKEY hParentKey,            // handle to an ancestor key (like HKEY_LOCAL_MACHINE)
    IN  LPCWSTR wszName             // The key path from ancestor

Remarks:

    Calls RecursiveDeleteSubkeys() who also calls this function

--*/

{
    HKEY hKey;
    WCHAR wszFunctionName[] = L"RecursiveDeleteKey";

	BS_ASSERT(ft.hr == S_OK);
    BS_ASSERT(hParentKey);
    BS_ASSERT(wszName && wszName[0] != L'\0');

    // Open the key
    LONG lRes = ::RegOpenKeyExW(
        hParentKey,     //  IN HKEY hKey,
        wszName,        //  IN LPCWSTR lpSubKey,
        0,              //  IN DWORD ulOptions,
        KEY_ALL_ACCESS, //  IN REGSAM samDesired,
        &hKey           //  OUT PHKEY phkResult
        );
    if (lRes != ERROR_SUCCESS)
    {
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
		ft.LogGenericWarning(VSSDBG_COORD, L"RegOpenKeyExW(0x%08lx,%s,...) == 0x%08lx", hParentKey, wszName, lRes);
        ft.Trace( VSSDBG_COORD, L"%s: Error on opening (enumerated) key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
        return;
    }
    BS_ASSERT(hKey);

    // Recursive delete the subkeys
    RecursiveDeleteSubkeys( ft, hKey );

    // Close the key
    lRes = ::RegCloseKey( hKey );
    if (lRes != ERROR_SUCCESS)
    {
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
        ft.Trace( VSSDBG_COORD, L"%s: Error on closing key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
    }

    // Delete the key
    lRes = ::RegDeleteKeyW( hParentKey, wszName );
    switch( lRes )
    {
    case ERROR_SUCCESS:
        break;
    case ERROR_FILE_NOT_FOUND:
    default:
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
		ft.LogGenericWarning(VSSDBG_COORD, L"RegDeleteKeyW(0x%08lx,%s) == 0x%08lx", hParentKey, wszName, lRes);
        ft.Trace( VSSDBG_COORD, L"%s: Error on deleting key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
    }
}


void RecursiveDeleteSubkeys(
    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey
    )

/*++

Routine Description:

    Deletes recursively all subkeys under a registry key.

Arguments:

    IN  CVssFunctionTracer& ft,     // function tracer of the caller
    IN  HKEY hKey,                  // handle to the current key

Remarks:

    Calls RecursiveDeleteKey() for all subkeys, who also calls this function

--*/

{
    WCHAR wszFunctionName[] = L"RecursiveDeleteSubkeys";
    WCHAR   wszSubKeyName[_MAX_KEYNAME_LEN];
    FILETIME time;

	BS_ASSERT(ft.hr == S_OK);
    BS_ASSERT(hKey);

    // Enumerate all subkeys
    while (true)
    {
        // Fill wszSubKeyName with the name of the subkey
        DWORD dwSize = sizeof(wszSubKeyName)/sizeof(wszSubKeyName[0]);
        LONG lRes = ::RegEnumKeyExW(
            hKey,           // IN HKEY hKey,
            0,              // IN DWORD dwIndex,
            wszSubKeyName,  // OUT LPWSTR lpName,
            &dwSize,        // IN OUT LPDWORD lpcbName,
            NULL,           // IN LPDWORD lpReserved,
            NULL,           // IN OUT LPWSTR lpClass,
            NULL,           // IN OUT LPDWORD lpcbClass,
            &time);         // OUT PFILETIME lpftLastWriteTime
        switch(lRes)
        {
        case ERROR_SUCCESS:
            BS_ASSERT(dwSize != 0);
            RecursiveDeleteKey( ft, hKey, wszSubKeyName );
            break; // Go to Next key
        default:
            if (ft.hr == S_OK)  // Remember only first error
                ft.hr = lRes;
    		ft.LogGenericWarning(VSSDBG_COORD, L"RegEnumKeyExW(0x%08lx,%s,...) == 0x%08lx", hKey, wszSubKeyName, lRes);
            ft.Trace( VSSDBG_COORD, L"%s: Error on iteration. 0x%08lx", wszFunctionName, lRes );
        case ERROR_NO_MORE_ITEMS:
            return;   // End of iteration
        }
    }
}


void QueryStringValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    IN  DWORD   dwValueSize,
    OUT LPCWSTR wszValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    IN  DWORD   dwValueSize,    // the size of the value buffer, in WCHARs
    OUT LPCWSTR wszValue        // The content of that value.
                                // The buffer must be already allocated and must have at
                                // least dwValueSize WCHARs

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryStringValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( dwValueSize != 0 );
    BS_ASSERT( wszValue );

    ::ZeroMemory( (void*)wszValue, dwValueSize * sizeof(WCHAR) );

    // Get the string content of the named key value
    DWORD   dwType;
    DWORD   dwDataSize = dwValueSize * sizeof(WCHAR);
    LPBYTE  pbData = (LPBYTE)wszValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_SZ ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_SZ << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_SZ type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}


void QueryDWORDValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    OUT PDWORD pdwValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    OUT PDWORD pdwValue         // The content of that DWORD value.

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryDWORDValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( pdwValue );

    (*pdwValue)=0;

    // Get the string content of the named key value
    DWORD   dwType = REG_NONE;  // Prefix bug 192471, still doesn't handle throw inside called functions well.
    DWORD   dwDataSize = sizeof(DWORD);
    LPBYTE  pbData = (LPBYTE)pdwValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_DWORD ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_DWORD << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_DWORD type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\setup.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    setup.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding some headers
	aoltean		10/05/1999	Moved from svc.cxx
	aoltean		03/10/2000	Simplifying Setup

--*/



////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"

// General utilities
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSETUC"
//
////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT CVsServiceModule::RegisterServer(
    BOOL bRegTypeLib
    )

/*++

Routine Description:

    Register the new COM server.

Arguments:

    bRegTypeLib,

Remarks:

    Called by CVsServiceModule::_WinMain()

Return Value:

    S_OK
    E_UNEXPECTED  if an error has occured. See trace file for details

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::RegisterServer" );

    try
    {
        //
        // Initialize the COM library
        //

        ft.hr = CoInitialize(NULL);
        if ( ft.HrFailed() )
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"CoInitialize failed 0x%08lx", ft.hr );

        // Add registry entries for CLSID and APPID by running proper scripts
        ft.hr = UpdateRegistryFromResource(IDR_VSSVC, TRUE);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        // Register the type library and add object map registry entries
        ft.hr = CComModule::RegisterServer(bRegTypeLib);
        if ( ft.HrFailed() )
			ft.Trace( VSSDBG_COORD, L"UpdateRegistryFromResource failed 0x%08lx", ft.hr );

        //
        // Uninitialize the COM library
        //
        CoUninitialize();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\softwrp.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module softwrp.cxx | Implementation of CVssSoftwareProviderWrapper
    @end

Author:

    Adi Oltean  [aoltean]  03/11/2001

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     03/11/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "softwrp.hxx"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSOFTC"
//
////////////////////////////////////////////////////////////////////////


IVssSnapshotProvider* CVssSoftwareProviderWrapper::CreateInstance(
    IN VSS_ID ProviderId,
	IN CLSID ClassId,
    IN bool bCallOnLoad
    ) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::CreateInstance");

    // Ref count becomes 1
    CComPtr<CVssSoftwareProviderWrapper> pWrapper = new CVssSoftwareProviderWrapper();
    if (pWrapper == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	// Create the IVssSoftwareSnapshotProvider interface
	ft.hr = pWrapper->m_pSoftwareItf.CoCreateInstance(ClassId, NULL, CLSCTX_LOCAL_SERVER);
	if ( ft.HrFailed() ) {
	    ft.LogError(VSS_ERROR_CREATING_PROVIDER_CLASS, VSSDBG_COORD << ClassId << ft.hr );
		ft.Throw( VSSDBG_COORD, VSS_E_UNEXPECTED_PROVIDER_ERROR, L"CoCreateInstance failed with hr = 0x%08lx", ft.hr);
	}
	BS_ASSERT(pWrapper->m_pSoftwareItf);

	// Query the creation itf.
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderCreateSnapshotSet, &(pWrapper->m_pCreationItf) );
    if (ft.HrFailed()) {
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderCreateSnapshotSet");
    }
	BS_ASSERT(pWrapper->m_pCreationItf);

	// Query the notification itf.
	// Execute the OnLoad, if needed
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderNotifications, &(pWrapper->m_pNotificationItf) );
    if (ft.HrSucceeded()) {
	    BS_ASSERT(pWrapper->m_pNotificationItf);
        if (bCallOnLoad) {
		    ft.hr = pWrapper->m_pNotificationItf->OnLoad(NULL);
		    if (ft.HrFailed()) 
                ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"IVssProviderNotifications::OnLoad");
        }
    } else if (ft.hr != E_NOINTERFACE) {
        BS_ASSERT(false);
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderNotifications");
    }

    // return the created interface
    // Ref count is still 1
    return pWrapper.Detach();
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP CVssSoftwareProviderWrapper::QueryInterface(REFIID iid, void** pp)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::QueryInterface");
    
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::AddRef()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::AddRef");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper AddRef(%p) %lu --> %lu", this, m_lRef, m_lRef+1);
    
    return ::InterlockedIncrement(&m_lRef);
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::Release()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::Release");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper Release(%p) %lu --> %lu", this, m_lRef, m_lRef-1);
    
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
};


/////////////////////////////////////////////////////////////////////////////
//  IVssSoftwareSnapshotProvider


STDMETHODIMP CVssSoftwareProviderWrapper::SetContext(
	IN		LONG     lContext
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetContext(lContext);
}


STDMETHODIMP CVssSoftwareProviderWrapper::GetSnapshotProperties(
	IN      VSS_ID			SnapshotId,
	OUT 	VSS_SNAPSHOT_PROP	*pProp
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->GetSnapshotProperties(
                SnapshotId,
                pProp
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::Query(                                      
    IN      VSS_ID          QueriedObjectId,        
    IN      VSS_OBJECT_TYPE eQueriedObjectType,     
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,   
    OUT     IVssEnumObject**ppEnum                 
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->Query(
                QueriedObjectId,        
                eQueriedObjectType,     
                eReturnedObjectsType,   
                ppEnum
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::DeleteSnapshots(                            
    IN      VSS_ID          SourceObjectId,         
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->DeleteSnapshots(
                SourceObjectId,         
                eSourceObjectType,
                bForceDelete,			
                plDeletedSnapshots,		
                pNondeletedSnapshotID
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::BeginPrepareSnapshot(                                
    IN      VSS_ID          SnapshotSetId,              
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ		pwszVolumeName,
    IN      LONG            lNewContext
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->BeginPrepareSnapshot(
                SnapshotSetId, 
                SnapshotId,
                pwszVolumeName ,
                lNewContext
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSupported( 
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSupportedByThisProvider
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSupported(
                pwszVolumeName, 
                pbSupportedByThisProvider
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSnapshotted( 
    IN      VSS_PWSZ        pwszVolumeName, 
    OUT     BOOL *          pbSnapshotsPresent,
	OUT 	LONG *		    plSnapshotCompatibility
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSnapshotted(
                pwszVolumeName, 
                pbSnapshotsPresent,
                plSnapshotCompatibility
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::SetSnapshotProperty(
	IN   VSS_ID  			SnapshotId,
	IN   VSS_SNAPSHOT_PROPERTY_ID	eSnapshotPropertyId,
	IN   VARIANT 			vProperty
	)
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetSnapshotProperty(SnapshotId, eSnapshotPropertyId, vProperty);
}

STDMETHODIMP CVssSoftwareProviderWrapper::RevertToSnapshot(
   IN       VSS_ID              SnapshotId
 )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->RevertToSnapshot(SnapshotId);
}

STDMETHODIMP CVssSoftwareProviderWrapper::QueryRevertStatus(
   IN      VSS_PWSZ                         pwszVolume,
   OUT    IVssAsync**                  ppAsync
 )
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->QueryRevertStatus(pwszVolume, ppAsync);
}


/////////////////////////////////////////////////////////////////////////////
// IVssProviderCreateSnapshotSet


STDMETHODIMP CVssSoftwareProviderWrapper::EndPrepareSnapshots(                            
    IN      VSS_ID          SnapshotSetId
	)
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->EndPrepareSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PreCommitSnapshots(                            
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PreCommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::CommitSnapshots(                            
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->CommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PostCommitSnapshots(                            
    IN      VSS_ID          SnapshotSetId,
	IN      LONG            lSnapshotsCount
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PostCommitSnapshots(SnapshotSetId, lSnapshotsCount);
}

STDMETHODIMP CVssSoftwareProviderWrapper::PreFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PreFinalCommitSnapshots(SnapshotSetId);
}

STDMETHODIMP CVssSoftwareProviderWrapper::PostFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PostFinalCommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::AbortSnapshots(                             
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->AbortSnapshots(SnapshotSetId);
}


////////////////////////////////////////////////////////////////////////
// IVssProviderNotifications

STDMETHODIMP CVssSoftwareProviderWrapper::OnUnload(								
	IN  	BOOL	bForceUnload				
    )
{
    return m_pNotificationItf? m_pNotificationItf->OnUnload(bForceUnload): S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\snap_set.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Coord.cxx | Implementation of CVssSnapshotSetObject
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     07/23/1999  Adding List, moving Admin functions in the Admin.cxx
    aoltean     08/11/1999  Adding support for Software and test provider
    aoltean     08/18/1999  Adding events. Making itf pointers CComPtr.
                            Renaming XXXSnapshots -> XXXSnapshot
    aoltean     08/18/1999  Renaming back XXXSnapshot -> XXXSnapshots
                            More stabe state management
                            Resource deallocations is fair
                            More comments
                            Using CComPtr
    aoltean     09/09/1999  Moving constants in coord.hxx
                            Add Security checks
                            Add argument validation.
                            Move Query into query.cpp
                            Move AddvolumesToInternalList into private.cxx
                            dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Provider-generic code.
	aoltean		10/04/1999	Treatment of writer error codes.
	aoltean		10/12/1999	Adding HoldWrites, ReleaseWrites
	aoltean		10/13/1999	Moving from coord.cxx into snap_set.cxx
	brianb		04/20/2000  Added SQL wrapper stuff
	brianb      04/21/2000  Disable SQL writer until new ODBC driver is available

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"

#include "provmgr.hxx"
#include "snap_set.hxx"

#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_filter.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSNPSC"
//
////////////////////////////////////////////////////////////////////////

// global semaphore used to serialize creation of snapshot sets
LONG g_hSemSnapshotSets = 0;



/////////////////////////////////////////////////////////////////////////////
//  CVssSnapshotSetObject


HRESULT CVssSnapshotSetObject::StartSnapshotSet(
    OUT		VSS_ID*     pSnapshotSetId
    )
/*++

Routine description:
	
	Starts a new calling sequence for snapshot creation.
	Called by CVssCoordinator::StartSnapshotSet.

Arguments:

    OUT		VSS_ID*     pSnapshotSetId

Return values:

    E_OUTOFMEMORY
    VSS_E_SNAPSHOT_SET_IN_PROGRESS
        - StartSnapshotSet is called while another snapshot set in in the
		  process of being created
    E_UNEXPECTED
        - if CoCreateGuid fails

    [Deactivate() failures] or
    [Activate() failures]
        [lockObj failures]
            E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::StartSnapshotSet" );

    try
    {
		BS_ASSERT(pSnapshotSetId);

        // Prevent simultaneous creation of multiple snapshot sets on the same machine.
		if (InterlockedCompareExchange(&g_hSemSnapshotSets, 1, 0) != 0)
			ft.Throw
				(
				VSSDBG_COORD,
				VSS_E_SNAPSHOT_SET_IN_PROGRESS,
				L"Snapshot set creation is already in progress."
				);

		BS_ASSERT(!m_bHasAcquiredSem);
        m_bHasAcquiredSem = true;

        // Verifying state...
        if (m_eCoordState != VSSC_Initialized) {
			// Mark the ending of the snapshot set creation!
			// Warning: may throw E_OUTOFMEMORY
			Deactivate();
        }

		// We should be in the correct state.
        BS_ASSERT(m_eCoordState == VSSC_Initialized);
        BS_ASSERT(m_lSnapshotsCount == 0);

        // Allocate a new Snapshot Set ID
		CVssGlobalSnapshotSetId::NewID();

		// Mark the beginning of the snapshot set creation
		// WARNING: This call may throw an E_OUTOFMEMORY exception!
		Activate();

        // Initialize the state of the snapshot set object.
		// Do not initialize any state that is related to the background state.
        ft.Trace( VSSDBG_COORD, L"Initialize the state of the snapshot set object" );
        (*pSnapshotSetId) = CVssGlobalSnapshotSetId::GetID();
        m_eCoordState = VSSC_SnapshotSetStarted;
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed() && m_bHasAcquiredSem)
		{
        // Reset the allocated Snapshot Set ID
		CVssGlobalSnapshotSetId::ResetID();

		InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
		m_bHasAcquiredSem = false;
		}

    return ft.hr;
}


HRESULT CVssSnapshotSetObject::AddToSnapshotSet(
    IN      VSS_PWSZ    pwszVolumeName,              
    IN      VSS_ID      ProviderId,                
	OUT 	VSS_ID		*pSnapshotId
    )
/*++

Routine description:
	
	Adds a volume to the snapshot set

Arguments:

    pwszVolumeName, - volume name (to be parsed by GetVolumeNameForVolumeMountPointW)
    ProviderId      - ID of the provider or GUID_NULL for automatic choosing of the provider
    ppSnapshot      - If non-NULL then will hold a pointer for the returned IVssSnapshot

Return values:

    E_OUTOFMEMORY
    VSS_E_BAD_STATE
        - wrong calling sequence.
    E_INVALIDARG
        - Invalid arguments (for example the volume name is invalid).
    VSS_E_VOLUME_NOT_SUPPORTED
        - The volume is not supported by any registered providers

    [GetSupportedProviderId() failures]
        E_OUTOFMEMORY
        E_INVALIDARG
            - if the volume is not in the correct format.
        VSS_E_VOLUME_NOT_SUPPORTED
            - If the given volume is not supported by any provider

        [QueryProvidersIntoArray() failures]
            E_OUTOFMEMORY

            [lockObj failures]
                E_OUTOFMEMORY

            [LoadInternalProvidersArray() failures]
                E_OUTOFMEMORY
                E_UNEXPECTED
                    - error while reading from registry. An error log entry is added describing the error.

            [CVssSoftwareProviderWrapper::CreateInstance failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [OnLoad() failures]
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

            [InitializeAsProvider() failures]
                E_OUTOFMEMORY

            [IVssSnapshotProvider::IsVolumeSupported() failures]
                E_INVALIDARG
                    NULL pointers passed as parameters or a volume name in an invalid format.
                E_OUTOFMEMORY
                    Out of memory or other system resources
                VSS_E_PROVIDER_VETO
                    An error occured while opening the IOCTL channel. The error is logged.
                VSS_E_OBJECT_NOT_FOUND
                    If the volume name does not correspond to an existing mount point

    [GetProviderInterfaceForSnapshotCreation() failures]

        VSS_E_PROVIDER_NOT_REGISTERED

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

    [CVssQueuedVolumesList::AddVolume() failures]
        E_UNEXPECTED
            - The thread state is incorrect. No logging is done - programming error.
        VSS_E_OBJECT_ALREADY_EXISTS
            - The volume was already added to the snapshot set.
        VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED
            - The maximum number of volumes was reached.
        E_OUTOFMEMORY

        [Initialize() failures]
            E_OUTOFMEMORY

    [BeginPrepareSnapshot() failures] 
        E_INVALIDARG
        VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddToSnapshotSet" );
	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
	VSS_ID InternalProviderId = ProviderId;

    bool bVolumeInserted = false;
    bool bProviderItfInserted = false;

    try
    {
		BS_ASSERT(::wcslen(pwszVolumeName) > 0);
		BS_ASSERT(pSnapshotId);

        // Verifying state
        if (m_eCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE,
					  L"Snapshot Set in incorrect state %d", m_eCoordState);

		// Getting the volume name
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
				wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
			ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED, // Changed from E_INVALIDARG, bug 197074
					  L"GetVolumeNameForVolumeMountPoint(%s,...) "
					  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
		BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
		BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // If the caller did not specified a provider
        if (InternalProviderId == GUID_NULL) {
            // Choose a provider that works.
            // This call may throw!
            GetSupportedProviderId( wszVolumeNameInternal, &InternalProviderId );
            ft.Trace( VSSDBG_COORD, L"Provider found: " WSTR_GUID_FMT, GUID_PRINTF_ARG(InternalProviderId) );

            BS_ASSERT(InternalProviderId != GUID_NULL);
        }

		// Get the provider interface
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.Lookup( InternalProviderId );
        if (!pProviderItf) {
            // The ref count will be 2 since the method keeps another
            // copy in its internal local cache.
		    GetProviderInterfaceForSnapshotCreation( InternalProviderId, &pProviderItf );
		    BS_ASSERT(pProviderItf);

		    // Add the interface to the array. In this moment the reference count will become 3.
            // We cannot use the local cache for keeping these interfaces because we need to
            // differentiate between provider interfaces involved in the current snapshot set
            // and provider interfaces involved in auto-delete snapshots.
		    if ( !m_mapProviderItfInSnapSet.Add( InternalProviderId, pProviderItf ) )
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

		    // Mark the provider interface as inserted
            bProviderItfInserted = true;
        }

		// Add volume to the thread set.
		// TBD: In the future snapshots will be allowed without involving Lovelace.
		ft.hr = m_VolumesList.AddVolume(wszVolumeNameInternal, pwszVolumeName);
		if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, ft.hr,
					  L"Error adding volume %s to the thread set. 0x%08lx",
					  wszVolumeNameInternal, ft.hr);

		// Mark the volume as inserted
		bVolumeInserted = true;

        // Create the snapshot Id
        VSS_ID SnapshotId;
		ft.hr = ::CoCreateGuid(&SnapshotId);
		if (ft.HrFailed())
			ft.TranslateGenericError( VSSDBG_COORD, ft.hr, L"CoCreateGuid()");

        // Prepare the snapshot
        ft.hr = pProviderItf->BeginPrepareSnapshot(
                    CVssGlobalSnapshotSetId::GetID(),
                    SnapshotId,
                    wszVolumeNameInternal,
                    0
                    );
        // Check if the volume is a non-supported one.
        if ( ft.hr == E_INVALIDARG ) {
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                L"Invalid arguments to BeginPrepareSnapshot for provider " WSTR_GUID_FMT,
                GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER ) {
            BS_ASSERT( ProviderId != GUID_NULL );
            ft.Throw( VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER,
                L"Volume %s not supported by provider " WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.hr == VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED ) {
            ft.Throw( VSSDBG_COORD, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED,
                L"Volume %s has too many snapshots" WSTR_GUID_FMT,
                wszVolumeNameInternal, GUID_PRINTF_ARG(ProviderId) );
        }
        if ( ft.HrFailed() )
            ft.TranslateProviderError(VSSDBG_COORD, InternalProviderId,
                L"BeginPrepareSnapshot("WSTR_GUID_FMT L","WSTR_GUID_FMT L",%s)",
                GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()),
                GUID_PRINTF_ARG(SnapshotId), 
                wszVolumeNameInternal);

        // Increment the number of snapshots on this set
        m_lSnapshotsCount++;

        // Set the Snapshot ID
        (*pSnapshotId) = SnapshotId;

        // The pProviderItf reference count will be again 2
        // (the itfs in local cache and in the snapshot set cache) since the smart pointer is gone
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed()) {
		// We do not need to abort the snapshot on error since BeginPrepareSnapshot is the last call.

    	// Remove the volume from the list, if added
    	if (bVolumeInserted) {
    		HRESULT hr2 = m_VolumesList.RemoveVolume( wszVolumeNameInternal );
    		if (FAILED(hr2)) {
    		    BS_ASSERT(false);
    			ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the volume 0x%08lx", hr2);
    		}
    	}

    	// Remove the new interface, if added
    	if (bProviderItfInserted) {
    		if (!m_mapProviderItfInSnapSet.Remove( InternalProviderId ))
    			ft.Trace( VSSDBG_COORD, L"Warning: Error deleting the added interface");
    	}
    }

    return ft.hr;
}


HRESULT CVssSnapshotSetObject::DoSnapshotSet()
/*++

Routine description:

    Performs DoSnapshotSet in a synchronous manner.

Error codes:

    E_OUTOFMEMORY
        - lock statement.
    VSS_E_BAD_STATE
        - Wrong calling sequence.

    [EndPrepareAllSnapshots() failures] or
    [PreCommitAllSnapshots() failures] or
    [CommitAllSnapshots() failures] or
    [PostCommitAllSnapshots() failures]
    
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Invalid number of prepared snapshots

        [EndPrepareSnapshots() failures] or
        [PreCommitSnapshots() failures] or
        [CommitSnapshots() failures] or
        [PostCommitSnapshots() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.
            VSS_E_OBJECT_NOT_FOUND
                - If the volume name does not correspond to an existing mount point then abort 
                snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

    [PrepareAndFreezeWriters() failures] or
    [ThawWriters() failures]
        E_OUTOFMEMORY

        [CoCreateInstance(CLSID_VssEvent) failures] or
        [PrepareForSnapshot() failures] or
        [Freeze() failures]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_WRITER_ERROR
                - Unexpected writer error. The error code is logged into the event log.

    [LovelaceFlushAndHold() failures]
        [FlushAndHoldAllWrites() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - Invalid thread state. Dev error - no entry is put in the event log.
                - Empty volume array. Dev error - no entry is put in the event log.
                - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
            VSS_ERROR_FLUSH_WRITES_TIMEOUT
                - An error occured while flushing the writes from a background thread. An event log entry is added.

    [LovelaceRelease() failures]
        [ReleaseAllWrites() failures]
            [WaitForFinish() failures]
                E_UNEXPECTED
                    - The list of volumes is empty. Dev error - nothing is logged on.
                    - SetEvent failed. An entry is put in the error log.
                    - WaitForMultipleObjects failed. An entry is put in the error log.
                E_OUTOFMEMORY
                    - Cannot create the array of handles.
                    - One of the background threads failed with E_OUTOFMEMORY
                VSS_E_HOLD_WRITES_TIMEOUT
                    - Lovelace couldn't keep more the writes. An event log entry is added.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet" );

    try
    {
		//
		// Enter in the critical section.
		//

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

        // Verifying state
        if (m_eCoordState != VSSC_SnapshotSetStarted)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set in incorrect state %d", m_eCoordState);
        m_eCoordState = VSSC_SnapshotCreation;

        if (m_lSnapshotsCount == 0)
            ft.Throw( VSSDBG_COORD, VSS_E_BAD_STATE, L"Snapshot Set is empty");

		//
		// Create the snapshot set
		//

		// End the prepare phase for all snapshots. Cancel detection inside
		EndPrepareAllSnapshots();

		// Send PrepareForSnapshot and Freeze to writers.
		// This function may throw HRESULTs
		// Cancel detection inside.
		PrepareAndFreezeWriters();

		// Pre-commit all snapshots. Cancel detection inside
		PreCommitAllSnapshots();

		// Flush and Hold writes on involved volumes
		LovelaceFlushAndHold();

		// Commit all snapshots. Cancel detection inside
		CommitAllSnapshots();

		// Release writes on involved volumes
		LovelaceRelease();

		// On each involved provider, call PostCommitSnapshots for all committed snapshots.
		PostCommitAllSnapshots();

		// Send the Thaw event to all writers.
		ThawWriters();

		//
		// Snapshot set created.
		//

        // Remove any snapshotset related  state
		Deactivate();

		// Hide errors in eventuality of writer vetos
		ft.hr = S_OK;
    }
    VSS_STANDARD_CATCH(ft)

	CVssFunctionTracer ft2( VSSDBG_COORD, L"CVssSnapshotSetObject::DoSnapshotSet_failure_block" );

    try
    {
    	// Cleanup on error...
    	if (ft.hr != S_OK) // HrFailed not used since VSS_S_ASYNC_CANCELLED may be thrown...
    	{
    		ft.Trace( VSSDBG_COORD, L"Abort detected while commiting the snapshot set 0x%08lx", ft.hr );
            // These functions should not throw

    		// Deal correctly with committed snapshots
    		AbortAllSnapshots();

        	// Release writes on involved volumes using Lovelace.
        	// Tracing the return value already done.
        	m_VolumesList.ReleaseAllWrites();

    		// Send Abort to all writers,regardless of what events they were already received.
    		AbortWriters();

            // If it was a cancel then abort the snapshot set in progress.
            // WARNING: This call may throw
            if (ft.hr == VSS_S_ASYNC_CANCELLED)
                Deactivate();
    	}
    }
    VSS_STANDARD_CATCH(ft2);

    if (ft2.HrFailed())
	    ft2.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft2.hr);

	BS_ASSERT(m_bHasAcquiredSem);
	InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);
	m_bHasAcquiredSem = false;

    return ft.hr;
}


void CVssSnapshotSetObject::PrepareAndFreezeWriters() throw (HRESULT)
/*++

Routine description:

    Send the PrepareForSnapshot and Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [CoCreateInstance(CLSID_VssEvent) failures] or
    [PrepareForSnapshot() failures] or
    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PrepareAndFreezeWriters" );
		
    // Allocate the string for snapshot set ID
     CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();
    if (!bstrSnapshotSetID)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

    // Create the instance of the event class
    if (m_pWriters == NULL)
    {
        CVssFunctionTracer ft( VSSDBG_COORD, L"PrepareAndFreezeWriters_create_writers_instance" );
        ft.hr = m_pWriters.CoCreateInstance(CLSID_VssEvent);
        ft.TranslateWriterReturnCode( VSSDBG_COORD, L"CoCreateInstance(CLSID_VssEvent)");
        BS_ASSERT(m_pWriters);
		SetupPublisherFilter(m_pWriters);
    }

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);

	// Get the list of volumes to be snapshotted
	CComBSTR bstrVolumeNamesList = m_VolumesList.GetVolumesList();
	if (bstrVolumeNamesList.Length() == 0)
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Null volume list");

	// We will ignore the case when if some subscribers returned and
	// error code while treating the event. This is because
	// transient subscriptions are not garbage collected in the event system.
	// In other words, if a subscriber process died without having a change to remove its
	// transient subscriptions the sending event will return one of these
	// EVENT_XXXX_SUBSCRIBERS_FAILED - which is wrong. Therefore this mechanism is not so
	// reliable therefore we will not use it.

    // Send "PrepareForSnapshot" event to all subscribers
    ft.hr = m_pWriters->PrepareForSnapshot(
				bstrSnapshotSetID,
				bstrVolumeNamesList
				);
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"PrepareForSnapshot(%s,%s)", bstrSnapshotSetID, bstrVolumeNamesList);

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);

    // Freeze the front-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_FRONT_END);

    // Freeze the back-end apps
    FreezePhase(bstrSnapshotSetID, VSS_APP_BACK_END);

    // Freeze the system writers
    FreezePhase(bstrSnapshotSetID, VSS_APP_SYSTEM);
}


void CVssSnapshotSetObject::FreezePhase(
        IN  CComBSTR& bstrSnapshotSetID,
        IN  VSS_APPLICATION_LEVEL eAppLevel
        ) throw (HRESULT)
/*++

Routine description:

    Send the Freeze events to all writers.

Error codes:

    E_OUTOFMEMORY
    VSS_S_ASYNC_CANCELLED
        - if IVssAsync::Cancel was called

    [Freeze() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::FreezePhase" );
		
    // Send "Freeze" event to all level 0 subscribers
    BS_ASSERT(m_pWriters != NULL);
    ft.hr = m_pWriters->Freeze(bstrSnapshotSetID, eAppLevel);
    ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Freeze(%s,%d)", bstrSnapshotSetID, (INT)eAppLevel);

	// Test if an Cancel occured
	TestIfCancelNeeded(ft);
}


void CVssSnapshotSetObject::ThawWriters() throw (HRESULT)
/*++

Routine description:

    Send the Thaw events to all writers.

Error codes:

    E_OUTOFMEMORY

    [Thaw() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::ThawWriters" );
		
    // Allocate the string for snapshot set ID
    CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

    if (!bstrSnapshotSetID) {
		// We cannot send anymore the Thaw event since we have a memory allocation error
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	} else {

		// Send "Thaw" event to all subscribers
        BS_ASSERT(m_pWriters != NULL);
		ft.hr = m_pWriters->Thaw(bstrSnapshotSetID);
        ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Thaw(%s)", bstrSnapshotSetID);
	}
}


void CVssSnapshotSetObject::AbortWriters()
/*++

Routine description:

    Send the Abort events to all writers.

Error codes:

    [Abort() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_WRITER_ERROR
            - Unexpected writer error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortWriters" );
		
	if (m_pWriters != NULL) {

		// Allocate the string for snapshot set ID
		CComBSTR bstrSnapshotSetID = CVssGlobalSnapshotSetId::GetID();

		if (!bstrSnapshotSetID) {
			// We cannot send anymore the Abort event since we have a memory allocation error
			ft.Trace( VSSDBG_COORD, L"Memory allocation error");
		} else {

			// Send "Abort" event to all subscribers
			ft.hr = m_pWriters->Abort(bstrSnapshotSetID);
            ft.TranslateWriterReturnCode( VSSDBG_COORD, L"Abort(%s)", bstrSnapshotSetID);
		}
	}
}


void CVssSnapshotSetObject::LovelaceFlushAndHold()
/*++

Routine description:

    Invokes the Lovelace's Flush& Hold on all volumes in the snapshot set.

Throws:

    [FlushAndHoldAllWrites() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - Invalid thread state. Dev error - no entry is put in the event log.
            - Empty volume array. Dev error - no entry is put in the event log.
            - Error creating or waiting a Win32 event. An entry is added into the Event Log if needed.
        VSS_ERROR_FLUSH_WRITES_TIMEOUT
            - An error occured while flushing the writes from a background thread. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceFlushAndHold" );

	// Flush And Hold writes on involved volumes using Lovelace.
	ft.hr = m_VolumesList.FlushAndHoldAllWrites(CVssGlobalSnapshotSetId::GetID());
	if (ft.HrFailed())
		ft.Throw(VSSDBG_COORD, ft.hr, L"Flush and Hold failure");
}


void CVssSnapshotSetObject::LovelaceRelease()
/*++

Routine description:

    Invokes the Lovelace's Release on all volumes in the snapshot set,

Throws:

    [ReleaseAllWrites() failures]
        [WaitForFinish() failures]
            E_UNEXPECTED
                - The list of volumes is empty. Dev error - nothing is logged on.
                - SetEvent failed. An entry is put in the error log.
                - WaitForMultipleObjects failed. An entry is put in the error log.
            E_OUTOFMEMORY
                - Cannot create the array of handles.
                - One of the background threads failed with E_OUTOFMEMORY
            VSS_E_HOLD_WRITES_TIMEOUT
                - Lovelace couldn't keep more the writes. An event log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::LovelaceRelease" );

	// Release writes on involved volumes using Lovelace.
	ft.hr = m_VolumesList.ReleaseAllWrites();
	if (ft.HrFailed())
		ft.Throw(VSSDBG_COORD, ft.hr, L"Release failure");
}


void CVssSnapshotSetObject::EndPrepareAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call EndPrepareSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [EndPrepareSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::EndPrepareAllSnapshots" );
		
	// On each involved provider, call PreCommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// End the background prepare phase
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->EndPrepareSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"EndPrepareSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PreCommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call PreCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PreCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PreCommitAllSnapshots" );
		
	// On each involved provider, call PreCommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// Pre-commit
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PreCommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"PreCommitSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));
		
		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::CommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call CommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [CommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CommitAllSnapshots" );

	// On each involved provider, call CommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// Commit
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->CommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"CommitSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PostCommitAllSnapshots() throw (HRESULT)
/*++

Routine description:

    Call PostCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PostCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort 
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PostCommitAllSnapshots" );
		
	// On each involved provider, call PostCommitSnapshots for all committed snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PostCommitSnapshots( CVssGlobalSnapshotSetId::GetID(), m_lSnapshotsCount );
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT, 
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"PostCommitSnapshots("WSTR_GUID_FMT L", %ld)",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()), m_lSnapshotsCount);

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::AbortAllSnapshots()
/*++

Routine description:

    Call AbortSnapshots for each provider involved in the snapshot set.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortAllSnapshots" );

    try
    {
	    for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	    {
		    CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);

		    ft.hr = pProviderItf->AbortSnapshots(CVssGlobalSnapshotSetId::GetID());
		    if (ft.HrFailed())
			    ft.Trace( VSSDBG_COORD, L"AbortSnapshots failed at one writer. hr = 0x%08lx", ft.hr);
	    }
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssSnapshotSetObject::TestIfCancelNeeded(
	IN	CVssFunctionTracer& ft
    ) throw(HRESULT)
{
	if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


void CVssSnapshotSetObject::OnDeactivate() throw(HRESULT)

/*++

Routine Description:

	Called by CVssProviderManager::Deactivate in order to remove the state of the object.

Warning:

    - The local cache interfaces are not released since are needed in the auto-delete case
    - The Reset function may throw...

Thrown errors:

    E_OUTOFMEMORY.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::OnDeactivate" );

	// Remove state from the coordinator interface
    // This will release the interfaces also but not completely
    // since a copy is stored in the local cache.
	m_mapProviderItfInSnapSet.RemoveAll();

    // Remove all volumes from the snapshot set.
    m_VolumesList.Reset();

    m_lSnapshotsCount = 0;

   	CVssGlobalSnapshotSetId::ResetID();
	
    m_eCoordState = VSSC_Initialized;
}


void CVssSnapshotSetObject::GetSupportedProviderId(
	IN	LPWSTR wszVolumeName,
    OUT VSS_ID* pProviderId
	) throw(HRESULT)

/*++

Routine Description:

	Called by CVssSnapshotSetObject::AddToSnapshotSet in order to establish the provider
    that will be used for snapshotting this volume

Algorithm:

    for $ProvType in the following order (Hardware, Software, System)
        for $Provider in all providers of type $ProvType
            if ($Provider supports Volume) then
                return the ID of $Provider
    return VSS_E_VOLUME_NOT_SUPPORTED

Remarks:

    We impose no rule for choosing between providers of the same type. The mechanishm of
    choosing is intentionally arbitrarily.

Arguments:
    wszVolumeName - expected to be in the \\\\\?\\Volume{00000000-0000-0000-0000-000000000000}\\ format.

Return values:

    None.

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
        - if the volume is not in the correct format.
    VSS_E_VOLUME_NOT_SUPPORTED
        - If the given volume is not supported by any provider

    [QueryProvidersIntoArray() failures]
        E_OUTOFMEMORY

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [CVssSoftwareProviderWrapper::CreateInstance failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [OnLoad() failures]
            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::GetSupportedProviderId" );

    VSS_ID VolumeId;

    // Assert parameters
    BS_ASSERT(pProviderId);
    BS_ASSERT(*pProviderId == GUID_NULL);
    BS_ASSERT(wszVolumeName);

    // Get the volume GUID
    if (!::GetVolumeGuid(wszVolumeName, VolumeId)) {
        // We assert since the check was already done
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Cannot convert volume name %s to a GUID", wszVolumeName);
    }

    //
    // Get all providers that supports this volume into an array
    //

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pFilteredProvidersArray = new VSS_OBJECT_PROP_Array;
    if (pFilteredProvidersArray == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pFilteredProvidersArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pFilteredProvidersArray);
    BS_ASSERT(pArrayItf);

    // Insert property structures into the array.
    // Only providers that supports tha volume will be chosen.
	CVssProviderManager::QuerySupportedProvidersIntoArray(
	    false, wszVolumeName, pFilteredProvidersArray );

    //
    //  Search a provider that supports that volume (i.e. from the above list),
    //  in the correct priority order.
    //

    // For each provider type, in the correct priority order
    bool bFound = false;
    for(int nPriority = 0; !bFound && arrProviderTypesOrder[nPriority] ; nPriority++) {

        // Get the current provider type
        VSS_PROVIDER_TYPE nCurrentType = arrProviderTypesOrder[nPriority];

        // For all providers of that type search one that supports the volume
        for(int nIndex = 0; !bFound && (nIndex < pFilteredProvidersArray->GetSize()); nIndex++) {

	        // Get the structure object from the array
	        VSS_OBJECT_PROP_Ptr& ptrProperties = (*pFilteredProvidersArray)[nIndex];

	        // Get the provider structure
            BS_ASSERT(ptrProperties.GetStruct());
	        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
	        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

            // Skip providers with the wrong type
            if (ProviderProp.m_eProviderType != nCurrentType)
                continue;

            // We found a good provider
            (*pProviderId) = ProviderProp.m_ProviderId;
            bFound = true;
        }
    }

    if (!bFound) {
        BS_ASSERT(false); // The "Volume not supported should be detected already by the IsVolumeSupported() call in coord.cxx
        ft.Throw(VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED, L"Volume %s not supported by any provider", wszVolumeName);
    }
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


STDMETHODIMP CVssSnapshotSetObject::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CVssSnapshotSetObject::AddRef()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddRef");
	
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssSnapshotSetObject::Release()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::Release");
	
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssSnapshotSetObject* CVssSnapshotSetObject::CreateInstance() throw(HRESULT)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CreateInstance");
	
	CVssSnapshotSetObject* pObj = new CVssSnapshotSetObject;
	if (pObj == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	if (FAILED(pObj->FinalConstructInternal()))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

	return pObj;
}


HRESULT CVssSnapshotSetObject::FinalConstructInternal()
{
	return S_OK;
}


CVssSnapshotSetObject::CVssSnapshotSetObject():
	m_bCancel(false),
	m_lSnapshotsCount(0),
    m_eCoordState(VSSC_Initialized),
	m_bHasAcquiredSem(false),
	m_lRef(0)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CVssSnapshotSetObject");
}


CVssSnapshotSetObject::~CVssSnapshotSetObject()
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSnapshotSetObject::~CVssSnapshotSetObject");

	try
	{
    	// Release aborts all prepared snapshots
    	Deactivate();

	}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
	    ft.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);

	if (m_bHasAcquiredSem)
		InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);

}


/////////////////////////////////////////////////////////////////////////////
//  CVssGlobalSnapshotSetId


//  Static data members
//

// Global snapshot set Id
VSS_ID CVssGlobalSnapshotSetId::m_SnapshotSetID = GUID_NULL;

// Global lock
CVssCriticalSection  CVssGlobalSnapshotSetId::m_cs;


//  Implementation
//

// Get the current Snasphot set ID
VSS_ID CVssGlobalSnapshotSetId::GetID() throw(HRESULT)
{
    // (Simplify tracing: do not declare a function tracer)
    
    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    return m_SnapshotSetID;
}


// Allocate a new Snapshot Set ID
VSS_ID CVssGlobalSnapshotSetId::NewID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::NewID" );

    try
    {
        // Acquire the critical section. This may throw.
        CVssAutomaticLock2 lock(m_cs);

        // Create the new Snapshot Set ID
        BS_ASSERT(m_SnapshotSetID == GUID_NULL);
        ft.hr = ::CoCreateGuid( &m_SnapshotSetID );
        if ( ft.HrFailed() )
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CoCreateGuid" );

        // Broadcast the new snapshot set ID. This may throw.
    	CVssSnasphotSetIdObserver::BroadcastSSID(m_SnapshotSetID);
    }
    VSS_STANDARD_CATCH(ft)

    // Re-throw error, if needed
    if (ft.HrFailed()) {
        m_SnapshotSetID = GUID_NULL;
        ft.Throw( VSSDBG_COORD, ft.hr, L"Re-throw error 0x%08lx", ft.hr);
    }

    // Return the created SSID
    return m_SnapshotSetID;
}


// Clear the current snapshot Set ID
void CVssGlobalSnapshotSetId::ResetID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::ResetID" );
    
    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Set the new Snapshot Set ID
    m_SnapshotSetID = GUID_NULL;
}


// Record the current SSID in the given observer
void CVssGlobalSnapshotSetId::InitializeObserver(
    IN CVssSnasphotSetIdObserver* pObserver
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::InitializeObserver" );
    
    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Record the current Snapshot Set ID. This may throw.
    if (m_SnapshotSetID != GUID_NULL) 
        pObserver->RecordSSID(m_SnapshotSetID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    StdAfx.cxx

Abstract:

    Source file that includes just the standard includes.  stdafx.pch will be
    the pre-compiled header and stdafx.obj will contain the pre-compiled type
    information.

Author:

    Adi Oltean   [aoltean]      07/02/1999

Revision History:

--*/

#include "StdAfx.hxx"

// Needed here to match COM server definitions with the <atlimpl.cpp> stuff
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\vssqlwrt.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsSqlWr.cpp | Implementation of Sql Writer wrapper class used by the coordinator
    @end

Author:

    Brian Berkowitz  [brianb]  04/18/2000

TBD:
	
	Add comments.

Revision History:

	
    Name        Date        Comments
    brianb     04/18/2000   Created
	brianb	   04/20/2000   integrated with coordinator
	brianb	   05/10/2000   make sure registration thread does CoUninitialize

--*/
#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include <vswriter.h>
#include <sqlsnap.h>
#include <sqlwriter.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSQLWC"
//
////////////////////////////////////////////////////////////////////////


__declspec(dllexport)
CVssSqlWriterWrapper::CVssSqlWriterWrapper() :
	m_pSqlWriter(NULL)
	{
	}

DWORD CVssSqlWriterWrapper::InitializeThreadFunc(VOID *pv)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::InitializeThreadFunc");

	CVssSqlWriterWrapper *pWrapper = (CVssSqlWriterWrapper *) pv;

	BOOL fCoinitializeSucceeded = false;

	try
		{
		// intialize MTA thread
		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

        fCoinitializeSucceeded = true;

		ft.hr = pWrapper->m_pSqlWriter->Initialize();
		}
	VSS_STANDARD_CATCH(ft)

	if (fCoinitializeSucceeded)
		CoUninitialize();

	pWrapper->m_hrInitialize = ft.hr;
	return 0;
	}



__declspec(dllexport)
HRESULT CVssSqlWriterWrapper::CreateSqlWriter()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::CreateSqlWriter");

	if (m_pSqlWriter)
		return S_OK;

	try
		{
		m_pSqlWriter = new CSqlWriter;
		if (m_pSqlWriter == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Allocation of CSqlWriter object failed.");

		DWORD tid;

		HANDLE hThread = CreateThread
							(
							NULL,
							256* 1024,
							CVssSqlWriterWrapper::InitializeThreadFunc,
							this,
							0,
							&tid
							);

		if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				GetLastError()
				);

		// wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		ft.hr = m_hrInitialize;
		}
	VSS_STANDARD_CATCH(ft)
	if (ft.HrFailed() && m_pSqlWriter)
		{
		delete m_pSqlWriter;
		m_pSqlWriter = NULL;
		}

	return ft.hr;
	}

__declspec(dllexport)
void CVssSqlWriterWrapper::DestroySqlWriter()
	{
	if (m_pSqlWriter)
		{
		m_pSqlWriter->Uninitialize();
		delete m_pSqlWriter;
		m_pSqlWriter = NULL;
		}
	}


__declspec(dllexport)
CVssSqlWriterWrapper::~CVssSqlWriterWrapper()
	{
	DestroySqlWriter();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\coord\src\svc.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    svc.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding some headers
	aoltean		03/10/2000	Simplifying Setup
	brianb		04/19/2000  Add Sql Writer
	brianb		05/03/2000	Start sql writer before registering COM stuff
	brianb		05/05/2000	fix sql writer startup

--*/


////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"
#include "vssmsg.h"

// General utilities
#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "shim.hxx"
#include "coord.hxx"

#include "comadmin.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSVCC"
//
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//  Constants

// 15 minutes of idle activity until shutdown. 
// The time is expressed number of 100 nanosecond intervals.
const LONGLONG  llVSSVCIdleTimeout = (LONGLONG)(-15) * 60 * 1000 * 1000 * 10;

// Immediate shutdown. 
const LONGLONG  llVSSVCShutdownTimeout = (LONGLONG)(-1);


////////////////////////////////////////////////////////////////////////
//  ATL Stuff


CVsServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VSSCoordinator, CVssCoordinator)
END_OBJECT_MAP()

// sql server (MSDE) Writer wrapper.  Included in coordinator because
// it needs admin privileges
CVssSqlWriterWrapper g_SqlWrapper;

//
//  Store away the thread id of the thread executing the ServiceMain() method.
//  Used to syncronize the ending of the main thread.
//
static DWORD g_dwServiceMainThreadId = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  CVsServiceModule implementation


CVsServiceModule::CVsServiceModule()

/*++

Routine Description:

    Default constructor. Initialize ALL members with predefined values.

--*/

{
	::VssZeroOut(&m_status);
	m_hInstance = NULL;
	m_hServiceStatus = NULL;
	m_dwThreadID = 0;
	m_hShutdownTimer = NULL;
	m_bShutdownInProgress = false;
	m_hSubscriptionsInitializeEvent = NULL;
	m_bCOMStarted = false;
    m_pvFuncSimulateSnapshotFreezeInternal = NULL;
    m_pvFuncSimulateSnapshotThawInternal = NULL;
    
	// Initialize the members of the SERVICE_STATUS that don't change
	m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwControlsAccepted =
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_SHUTDOWN;
}


///////////////////////////////////////////////////////////////////////////////////////
// Service control routines (i.e. ServiceMain-related methods)
//


void CVsServiceModule::StartDispatcher()

/*++

Routine Description:

    Called in the main execution path.
	Will register the _ServiceMain function.

Called by:

	CVsServiceModule::_WinMain

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher");

    try
    {
		SERVICE_TABLE_ENTRYW st[] =
		{
			{ const_cast<LPWSTR>(wszServiceName), _ServiceMain },
			{ NULL, NULL }
		};

		// Register the dispatcher main function into the Service Control Manager
		// This call blocks until ServiceMain tells SCM the service status is stopped
		if ( !::StartServiceCtrlDispatcherW(st) ) {
		    ft.LogError(VSS_ERROR_STARTING_SERVICE_CTRL_DISPATCHER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
					  L"StartServiceCtrlDispatcherW failed. 0x%08lx", GetLastError() );
	    }

        //  If the ServiceMain thread is still running, wait for it to finish.
        if ( g_dwServiceMainThreadId != 0 )
        {
            HANDLE hServiceMainThread;

            hServiceMainThread = ::OpenThread( SYNCHRONIZE, FALSE, g_dwServiceMainThreadId );
            if ( hServiceMainThread != NULL )
            {
                ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Waiting for ServiceMain thread to finish..." );
                //  Wait up to 10 seconds
                if ( ::WaitForSingleObject( hServiceMainThread, 10000 ) == WAIT_TIMEOUT )
                {
                    ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Wait timed out, ending anyway" );
                }
                ::CloseHandle( hServiceMainThread );
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

	m_status.dwWin32ExitCode = ft.hr;
}


void WINAPI CVsServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}


void CVsServiceModule::ServiceMain(
    IN	DWORD	/* dwArgc */,
    IN	LPTSTR* /* lpszArgv */
    )

/*++

Routine Description:

	The main service control dispatcher.

Called by:

    Called by the NT Service framework following
	the StartServiceCtrlDispatcherW which was called in CVsServiceModule::StartDispatcher

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::ServiceMain");

    try
    {
        // Store away this thread id for use by the main thread.
        g_dwServiceMainThreadId = ::GetCurrentThreadId();
        
		// Needed for SERVICE_CONTROL_INTERROGATE that may come between the next two calls
		m_status.dwCurrentState = SERVICE_START_PENDING;

        // Register the control request handler
        m_hServiceStatus = ::RegisterServiceCtrlHandlerW(wszServiceName, _Handler);
        if ( m_hServiceStatus == NULL ) {
		    ft.LogError(VSS_ERROR_STARTING_SERVICE_REG_CTRL_HANDLER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"RegisterServiceCtrlHandler failed. 0x%08lx", GetLastError() );
        }

		// Now we will really inform the SCM that the service is pending its start.
        SetServiceStatus(SERVICE_START_PENDING);

		// Internal initialization
		OnInitializing();

		// The service is started now.
		SetServiceStatus(SERVICE_RUNNING);

		// Wait for shutdown attempt
		OnRunning();

		// Shutdown was started either by receiving the SERVICE_CONTROL_STOP
		// or SERVICE_CONTROL_SHUTDOWN events either because the COM objects number is zero.
		SetServiceStatus(SERVICE_STOP_PENDING);

		// Perform the un-initialization tasks
		OnStopping();

		// The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED);
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()) {

		// Present the error codes to the caller.
		m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
		m_status.dwServiceSpecificExitCode = ft.hr;

		// Perform the un-initialization tasks
		OnStopping();

		// The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED, false);
	}
}


void WINAPI CVsServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode);
}


void CVsServiceModule::Handler(
    DWORD dwOpcode
    )

/*++

Routine Description:

    Used by Service Control Manager to inform this service about the service-related events

Called by:

	Service Control Manager.

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Handler");

    try
    {
		// re-initialize "volatile" members
		m_status.dwCheckPoint = 0;
		m_status.dwWaitHint = 0;
		m_status.dwWin32ExitCode = 0;
        m_status.dwServiceSpecificExitCode = 0;

		switch (dwOpcode)
		{
		case SERVICE_CONTROL_INTERROGATE:
			// Present the previous state.
			SetServiceStatus(m_status.dwCurrentState);
			break;

		case SERVICE_CONTROL_STOP:
		case SERVICE_CONTROL_SHUTDOWN:
			SetServiceStatus(SERVICE_STOP_PENDING);
			OnSignalShutdown();
			// The SERVICE_STOPPED status must be communicated
			// in Service's main function.
			break;

		default:
			BS_ASSERT(false);
			ft.Trace( VSSDBG_COORD, L"Bad service request 0x%08lx", dwOpcode );
		}
	}
    VSS_STANDARD_CATCH(ft)
}


void CVsServiceModule::SetServiceStatus(
		IN	DWORD dwState,
		IN	bool bThrowOnError /* = true */
		)

/*++

Routine Description:

    Informs the Service Control Manager about the new status.

Called by:

	CVsServiceModule methods

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::SetServiceStatus");

	try
	{
		ft.Trace( VSSDBG_COORD, L"Attempt to change the service status to %lu", dwState);

		BS_ASSERT(m_hServiceStatus != NULL);

		// Inform SCM about the new status
		m_status.dwCurrentState = dwState;
		if ( !::SetServiceStatus(m_hServiceStatus, &m_status) ) {
		    ft.LogError(VSS_ERROR_SET_SERVICE_STATUS, VSSDBG_COORD << (INT)dwState << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
						L"Error on calling SetServiceStatus. 0x%08lx", GetLastError() );
		}
	}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		ft.ThrowIf( bThrowOnError, VSSDBG_COORD, ft.hr,
					L"Error on calling SetServiceStatus. 0x%08lx", ft.hr );
}


void CVsServiceModule::WaitForSubscribingCompletion() throw(HRESULT)

/*++

Routine Description:

    Wait until all subscriptions are performed

Called by:

	CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::WaitForSubscribingCompletion" );

	// Wait for shutdown
	DWORD dwRet = WaitForSingleObject(
		m_hSubscriptionsInitializeEvent,    // IN HANDLE hHandle,
		INFINITE                            // IN DWORD dwMilliseconds
		);
	if( dwRet != WAIT_OBJECT_0 )
	    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
	        L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hSubscriptionsInitializeEvent);
}


/*++

Routine Description:

    Gets the simulate snapshot function pointers.

Called by:

	CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/
void CVsServiceModule::GetSimulateFunctions( 
        OUT PFunc_SimulateSnapshotFreezeInternal *ppvSimulateFreeze, 
        OUT PFunc_SimulateSnapshotThawInternal *ppvSimulateThaw )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::GetSimulateFunctions" );
    //
    //  Must wait for the shim to finish subscribing before accessing the
    //  internal freeze and thaw functions; otherwise the two m_pvFuncXXXX
    //  vars will be NULL.
    //
	WaitForSubscribingCompletion();        
    if ( ppvSimulateFreeze != NULL )
        *ppvSimulateFreeze = m_pvFuncSimulateSnapshotFreezeInternal;
    if ( ppvSimulateThaw != NULL )
        *ppvSimulateThaw = m_pvFuncSimulateSnapshotThawInternal;
};



///////////////////////////////////////////////////////////////////////////////////////
// Service initialization, running and finalization routines
//


void CVsServiceModule::OnInitializing()

/*++

Routine Description:

    Initialize the service.

	If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
	Otherwise ServiceMain must silently shutdown the service.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnInitializing" );

    m_dwThreadID = GetCurrentThreadId();

    // Initialize the COM library
    ft.hr = CoInitializeEx(
            NULL,
            COINIT_MULTITHREADED
            );
    if (ft.HrFailed()) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INIT_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: CoInitialize(NULL) returned 0x%08lx", ft.hr );
    }

    BS_ASSERT( ft.hr == S_OK );

    m_bCOMStarted = true;

    // Initialize COM security
    ft.hr = CoInitializeSecurity(
           NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );
    if (ft.HrFailed()) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INITSEC_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr,
                  L" Error: CoInitializeSecurity() returned 0x%08lx", ft.hr );
    }

	// Create the event needed to synchronize
	BS_ASSERT(m_hShutdownTimer == NULL);
	m_hShutdownTimer = CreateWaitableTimer(
		NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
		TRUE,       //  IN BOOL bManualReset,
		NULL        //  IN LPCTSTR lpName
		);
	if ( m_hShutdownTimer == NULL ) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				  L"Error creating the shutdown timer 0x%08lx", GetLastError() );
    }

	// Create the event needed to synchronize
	BS_ASSERT(m_hSubscriptionsInitializeEvent == NULL);
	m_hSubscriptionsInitializeEvent = CreateEvent(
		NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
		TRUE,       //  IN BOOL bManualReset,
		FALSE,      //  IN BOOL bInitialState,
		NULL        //  IN LPCTSTR lpName
		);
	if ( m_hSubscriptionsInitializeEvent == NULL ) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				  L"Error creating the subscriptions sync event 0x%08lx", GetLastError() );
    }

    //  Register the COM class objects
    ft.hr = RegisterClassObjects( CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE );
    if (ft.HrFailed()) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CLASS_REG, VSSDBG_COORD << ft.hr);
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: RegisterClassObjects() returned 0x%08lx", ft.hr );
    }
	
	// The service is started now to prevent the service startup from
	// timing out.  The COM registration is done after we fully complete
	// initialization
	SetServiceStatus(SERVICE_RUNNING);

	// startup sql writer if not already started.
	g_SqlWrapper.CreateSqlWriter();

	// register the shim snapshot writers
	RegisterSnapshotSubscriptions( &m_pvFuncSimulateSnapshotFreezeInternal, &m_pvFuncSimulateSnapshotThawInternal );

    // Mark that all the subscriptiuons are initialized
	if (!::SetEvent( m_hSubscriptionsInitializeEvent )) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				L"Error on setting the sub sync event 0x%08lx", GetLastError());
	}
}



void CVsServiceModule::OnRunning()

/*++

Routine Description:

    Keeps the service alive until the job is done.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnRunning" );

	// Wait for shutdown
	DWORD dwRet = WaitForSingleObject(
		m_hShutdownTimer,                   // IN HANDLE hHandle,
		INFINITE                            // IN DWORD dwMilliseconds
		);
	if( dwRet != WAIT_OBJECT_0 )
	    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()), 
	        L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hShutdownTimer);

    // Trace the fact that the service will be shutdown
	ft.Trace( VSSDBG_COORD, L"VSSVC: %s event received",
	    m_bShutdownInProgress? L"Shutdown": L"Idle timeout");
}


void CVsServiceModule::OnStopping()

/*++

Routine Description:

    Performs the uninitialization tasks.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnStopping" );

    try
    {
        g_SqlWrapper.DestroySqlWriter();

        //  Unregister the COM classes
        ft.hr = RevokeClassObjects();
        if (ft.HrFailed())
            ft.Trace( VSSDBG_COORD, L" Error: RevokeClassObjects returned hr = 0x%08lx", ft.hr );

		// Remove the providers array
		CVssProviderManager::UnloadInternalProvidersArray();

		// Remove state from all stateful objects
		CVssProviderManager::DeactivateAll();

		UnregisterSnapshotSubscriptions();
        m_pvFuncSimulateSnapshotFreezeInternal = NULL;
        m_pvFuncSimulateSnapshotThawInternal = NULL;

        // Uninitialize the COM library
        if ( m_bCOMStarted )
            CoUninitialize();

        // Close the handles
		if ( !::CloseHandle( m_hShutdownTimer ) )
			ft.Trace( VSSDBG_COORD, L"Error closing the shutdown event 0x%08lx", GetLastError() );

		if ( !::CloseHandle( m_hSubscriptionsInitializeEvent ) )
			ft.Trace( VSSDBG_COORD, L"Error closing the sub sync event 0x%08lx", GetLastError() );
    }
    VSS_STANDARD_CATCH(ft)
}


void CVsServiceModule::OnSignalShutdown()

/*++

Routine Description:

    Called when the current service should not be stopping its activity.
	Too bad about COM calls in progress - the running clients will get an error.

Called by:

	CVsServiceModule::Handler

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnSignalShutdown" );

    try
    {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = llVSSVCShutdownTimeout;

        // Trace the fact that the service will be shutdown
		ft.Trace( VSSDBG_COORD, L"VSSVC: Trying to shutdown the service");

        // Set the timer to become signaled immediately.
		if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
        		L"Error on setting the shutdown event 0x%08lx", GetLastError());
		BS_ASSERT(GetLastError() == 0);
		m_bShutdownInProgress = true;
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()) {
		m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
		m_status.dwServiceSpecificExitCode = ft.hr;
	}
}


///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//


LONG CVsServiceModule::Lock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Lock" );

    // If we are not shutting down then we are cancelling the "idle timeout" timer.
    if (!m_bShutdownInProgress) {

        // Trace the fact that the idle period is done.
    	ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period is finished");

        // Cancel the timer
        if (!::CancelWaitableTimer(m_hShutdownTimer))
            ft.Warning(VSSDBG_COORD, L"Error cancelling the waitable timer 0x%08lx",
                GetLastError());
    }

    return CComModule::Lock();
}


LONG CVsServiceModule::Unlock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Unlock" );

    // Check if we entered in the idle period.
    LONG lRefCount = CComModule::Unlock();
    if ( lRefCount == 0) {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = llVSSVCIdleTimeout;

        // Trace the fact that the idle period begins
    	ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period begins");

        // Set the timer to become signaled after the proper idle time.
        // We cannot fail at this point (BUG 265455)
		if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE)) 
		    ft.LogGenericWarning( VSSDBG_COORD, L"SetWaitableTimer(...) [0x%08lx]", GetLastError());
		BS_ASSERT(GetLastError() == 0);
		
        return 0;
    }
    return lRefCount;
}



///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//



LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (*p1 != NULL)
    {
        LPCTSTR p = p2;
        while (*p != NULL)
        {
            if (*p1 == *p++)
                return p1+1;
        }
        p1++;
    }
    return NULL;
}


extern "C" int WINAPI _tWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE, /* hPrevInstance */
    IN LPTSTR lpCmdLine,
    IN int /* nShowCmd */
    )
{
    return _Module._WinMain( hInstance, lpCmdLine );
}


int WINAPI CVsServiceModule::_WinMain(
    IN HINSTANCE hInstance,
    IN LPTSTR /* lpCmdLine */
    )

/*++

Routine Description:

    Called in the main execution path.
	Used to:
		- start the service, if no parameters on the command line.
		- register the service, if the "/Register" or "-Register" command line parameter is present

Called by:

    _WinMain()

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::_WinMain");

    try
    {
		// Get the command line
        LPTSTR lpCmdLine = GetCommandLine();
        ft.Trace( VSSDBG_COORD, L"Trace: VSS command-line: '%s'", T2W(lpCmdLine) );

        // Set the reporting mode for ATLASSERT and BS_ASSERT macros.
//        VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

		// Initialize the internal variables
        Init(ObjectMap, hInstance);
        m_hInstance = hInstance;

		// Parse the command line
        TCHAR szTokens[] = _T("-/");
        LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);

		bool bRegisterTentative = false;
        while (lpszToken != NULL)
        {
			ft.Trace( VSSDBG_COORD, L"Current token = \'%s\'", lpszToken );

            // Register as Server
            if (lstrcmpi(lpszToken, _T("Register"))==0)
			{
				bRegisterTentative = true;
                ft.hr = RegisterServer(TRUE);
				break;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
        }

		// Start the dispatcher function
		if (!bRegisterTentative)
			StartDispatcher();
    }
    VSS_STANDARD_CATCH(ft)

    // When we get here, the service has been stopped
    return m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\event\src\impl.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module EventMonImpl.h : Declaration of the CVssEventClassImpl

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/



#ifndef __EventMonIMPL_H_
#define __EventMonIMPL_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CVssEventClassImpl
class ATL_NO_VTABLE CVssEventClassImpl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVssEventClassImpl, &__uuidof(VssEvent)>
{
public:
	CVssEventClassImpl()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_EVENTMONIMPL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVssEventClassImpl)
END_COM_MAP()

public:


};

#endif //__EventMonIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\event\src\impl.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module EventMonImpl.cpp : Implementation of CVssEventClassImpl

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/


#include "stdafx.h"
#include "vsevent.h"
#include "Impl.h"

/////////////////////////////////////////////////////////////////////////////
// CVssEventClassImpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\event\src\stdafx.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cpp : source file that includes just the standard includes
        stdafx.pch will be the pre-compiled header
        stdafx.obj will contain the pre-compiled type information

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/



#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\event\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ZooEventClass.rc
//
#define IDS_PROJNAME                    100
#define IDR_EVENTMONIMPL                     101
#define IDR_TYPELIB1                    201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\event\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.h : include file for standard system include files,          
         or project specific include files that are used frequently,    
         but are changed infrequently                                   

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created

--*/




#if !defined(AFX_STDAFX_H__036BCDC7_D1E3_11D2_9A34_00C04F72EB9B__INCLUDED_)
#define AFX_STDAFX_H__036BCDC7_D1E3_11D2_9A34_00C04F72EB9B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//#pragma warning(disable:4786)

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__036BCDC7_D1E3_11D2_9A34_00C04F72EB9B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\event\src\eventcls.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module EventCls.cpp : Implementation of DLL Exports.

    @end

Author:

    Adi Oltean  [aoltean]  08/14/1999

Revision History:

    Name        Date        Comments
    aoltean     08/14/1999  Created
    aoltean     09/09/1999  Adding copyright

--*/


#include "stdafx.h"
#include "vssmsg.h"
#include "resource.h"
#include <initguid.h>

#include "vs_inc.hxx"

#include "vsevent.h"
#include "Impl.h"

#include <comadmin.h>
#include "comadmin.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "EVTEVTCC"
//
////////////////////////////////////////////////////////////////////////

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VssEvent, CVssEventClassImpl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Constants



const WCHAR g_wszPublisherAppName[]     = L"Volume Shadow Copy Service";   // Publisher Application Name
const WCHAR g_wszEventClassDllName[]    = L"\\EVENTCLS.DLL";
const WCHAR g_wszEventClassProgID[]     = L"VssEvent.VssEvent.1";
const WCHAR g_wszPublisherID[]          = L"VSS Publisher";             // Publisher ID


///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT GetECDllPathName(
	IN	INT nBufferLength, // Does not include terminating zero character
    OUT   WCHAR* wszFileName
    )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"GetECDllPathName" );

    try
    {
		WCHAR wszPath[MAX_PATH];
        if (!::GetCurrentDirectory(MAX_PATH, wszPath)) {
            ft.LogError(VSS_ERROR_GETTING_CURRENT_DIR, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw(VSSDBG_COORD, E_UNEXPECTED,
				L"Error on getting the current path. hr = 0x%08lx",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( ::wcslen(wszPath) +
			 ::wcslen(g_wszEventClassDllName) >= (size_t) nBufferLength )
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Out of memory.");

        ::_snwprintf(wszFileName, nBufferLength,
				L"%s%s", wszPath, g_wszEventClassDllName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

HRESULT RegisterEventClass()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"RegisterEventClass" );

    try
		{
		// create event system
		CComPtr<IEventSystem> pSystem;

		ft.hr = CoCreateInstance
				(
				CLSID_CEventSystem,
				NULL,
				CLSCTX_SERVER,
				IID_IEventSystem,
				(void **) &pSystem
				);

		ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");
		CComBSTR bstrClassId = CLSID_VssEvent;

		CComBSTR bstrQuery = "EventClassID == ";
		if (!bstrQuery)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

		bstrQuery.Append(bstrClassId);
		if (!bstrQuery)
			ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

		int location;

		// remove event class if it already exists
		ft.hr = pSystem->Remove
				(
				PROGID_EventClassCollection,
				bstrQuery,
				&location
				);

		ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Remove");

		CComPtr<IEventClass> pEvent;

		CComBSTR bstrEventClassName = L"VssEvent";
		WCHAR buf[MAX_PATH*2 + 1];
		GetECDllPathName(MAX_PATH * 2, buf);

		CComBSTR bstrTypelib = buf;

		// create event class
		// note we will have to do something else to enable parallel firing
		ft.hr = CoCreateInstance
				(
				CLSID_CEventClass,
				NULL,
				CLSCTX_SERVER,
				IID_IEventClass,
				(void **) &pEvent
				);

		ft.CheckForError(VSSDBG_WRITER, L"CoCreatInstance");
		ft.hr = pEvent->put_EventClassID(bstrClassId);
		ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassID");
		ft.hr = pEvent->put_EventClassName(bstrEventClassName);
		ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassName");
		ft.hr = pEvent->put_TypeLib(bstrTypelib);
		ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_TypeLib");
		ft.hr = pSystem->Store(PROGID_EventClass, pEvent);
		ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");
		}
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
	}



///////////////////////////////////////////////////////////////////////////////
//   DLL Entry point
//

//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        // Set the proper way for displaying asserts
        ::VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);

        // TODO discussion about the logger file in this DLL!
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}


// DllInstall - install the event class into the COM+ catalog.
STDAPI DllInstall(	
	IN	BOOL bInstall,
	IN	LPCWSTR /* pszCmdLine */
)
{
	HRESULT hr = S_OK;

	// Registers the COM+ application
	// This will implicitely call DllRegisterServer
	if (bInstall)
		hr = RegisterEventClass();

	return hr;
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\jetwriter\stdafx.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>
#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)

#include "vs_assert.hxx"

#include <oleauto.h>
#include <comadmin.h>

#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\jetwriter\ijetwriter.cpp ===
/*
**++
**
**  Copyright (c) 2000-2001  Microsoft Corporation
**
**  Module Name:
**
**	wrtrrsm.cpp
**
**
**  Abstract:
**
**	Writer shim module for RSM
**
**
**  Author:
**
**	Brian Berkowitz [brianb]
**
**
**  Revision History:
**
**	X-11	MCJ		Michael C. Johnson		19-Sep-2000
**		215218: Wildcard name of log files returned by OnIdentify()
**		215390: Incorporate multiple '.' fix in MatchFileName from NtBackup
**
**	X-10	MCJ		Michael C. Johnson		19-Sep-2000
**		176860: Add the missing calling convention specifiers
**
**	X-9	MCJ		Michael C. Johnson		21-Aug-2000
**		Added copyright and edit history
**		161899: Don't add a component for a database file in the
**		        exclude list.
**		165873: Remove trailing '\' from metadata file paths
**		165913: Deallocate memory on class destruction
**
**
**--
*/

#include <stdafx.h>

#include <esent.h>

#include <vss.h>
#include <vswriter.h>

#include <jetwriter.h>


#include "ijetwriter.h"
#include "vs_inc.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "JTWIJTWC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  local functions


#define UMAX(_a, _b)			((_a) > (_b)      ? (_a)    : (_b))
#define	EXECUTEIF(_bSuccess, _fn)	((_bSuccess)      ? (_fn)   : (_bSuccess))
#define	GET_STATUS_FROM_BOOL(_bSucceed)	((_bSucceed)      ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))


typedef struct _ExpandedPathInfo
    {
    LIST_ENTRY	leQueueHead;
    PWCHAR	pwszOriginalFilePath;
    PWCHAR	pwszOriginalFileName;
    PWCHAR	pwszExpandedFilePath;
    PWCHAR	pwszExpandedFileName;
    bool	bRecurseIntoSubdirectories;
    } EXPANDEDPATHINFO, *PEXPANDEDPATHINFO, **PPEXPANDEDPATHINFO;



static void RemoveAnyTrailingSeparator (PCHAR szPath)
    {
    ULONG	ulPathLength = strlen (szPath);

    if ('\\' == szPath [ulPathLength - 1])
	{
	szPath [ulPathLength - 1] = '\0';
	}
    }


static void RemoveAnyTrailingSeparator (PWCHAR wszPath)
    {
    ULONG	ulPathLength = wcslen (wszPath);

    if (L'\\' == wszPath [ulPathLength - 1])
	{
	wszPath [ulPathLength - 1] = UNICODE_NULL;
	}
    }


static bool ConvertName (PCHAR  szSourceName,
			 ULONG  ulTargetBufferLengthInChars,
			 PWCHAR wszTargetBuffer)
    {
    bool bSucceeded = true;


    wszTargetBuffer [0] = '\0';


    /*
    ** Only need to do the conversion for non-zero length
    ** strings. Returning a zero length string for a zero length
    ** argument is an ok thing to do.
    */
    if ('\0' != szSourceName [0])
	{
	bSucceeded = (0 != MultiByteToWideChar (CP_OEMCP,
						0,
						szSourceName,
						-1,
						wszTargetBuffer,
						ulTargetBufferLengthInChars));
	}


    return (bSucceeded);
    } /* ConvertName () */


static bool ConvertNameAndSeparateFilePaths (PCHAR	pszSourcePath,
					     ULONG	ulTargetBufferLength,
					     PWCHAR	pwszTargetPath,
					     PWCHAR&	pwszTargetFileSpec)
    {
    bool	bSucceeded;
    PWCHAR	pwchLastSlash;


    bSucceeded = ConvertName (pszSourcePath, ulTargetBufferLength, pwszTargetPath);

    if (bSucceeded)
	{
	/*
	** Scan backwards from the end of the target path, zap the
	** end-most '\' and point the file spec at the character
	** following where the '\' used to be.
	*/
	pwchLastSlash = wcsrchr (pwszTargetPath, L'\\');

	bSucceeded = (NULL != pwchLastSlash);
	}


    if (bSucceeded)
	{
	pwszTargetFileSpec = pwchLastSlash + 1;

	*pwchLastSlash = UNICODE_NULL;
	}


    return (bSucceeded);
    } /* ConvertNameAndSeparateFilePaths () */



/*
** This routine breaks out the next path and filespec from a list of
** filespecs. The expected format of the input string is
**
**	path\[filespec] [/s]
**
**
** The list can contain an arbitrary number of filespecs each
** separated by a semi-colon.
*/
static bool DetermineNextPathWorker (LPCWSTR  pwszFileList,
				     LPCWSTR& pwszReturnedCursor,
				     ULONG&   ulReturnedDirectoryStart,
				     ULONG&   ulReturnedDirectoryLength,
				     ULONG&   ulReturnedFilenameStart,
				     ULONG&   ulReturnedFilenameLength,
				     bool&    bReturnedRecurseIntoSubdirectories,
				     bool&    bReturnedFoundSpec)
    {
    bool	bSucceeded                    = true;
    bool	bFoundSpec                    = false;
    ULONG	ulPathNameLength;
    ULONG	ulFileNameLength;
    ULONG	ulIndex;
    ULONG	ulIndexSubDirectory           = 0;
    ULONG	ulIndexLastDirectorySeparator = 0;
    ULONG	ulIndexFirstCharInSpec        = 0;
    ULONG	ulIndexLastCharInSpec         = 0;
    const ULONG	ulLengthFileList              = wcslen (pwszFileList);


    /*
    ** The format of the string we are expecting is "filename.ext /s
    ** ;nextname", ie a list of semi-colon separated names with an
    ** optional trailing '/s'. There can be an arbitrary number of
    ** spaces before the '/' and before the ';': these will be
    ** stripped out and discarded. So we start by scanning for the
    ** first '/' or ';' characters.
    **
    ** Look for a ';' first to determine the end point.
    */
    if ((NULL         == pwszFileList) ||
	(UNICODE_NULL == pwszFileList [0]))
	{
	bFoundSpec = false;
	}

    else if (( L';'  == pwszFileList [0]) ||
	     ( L'/'  == pwszFileList [0]) ||
	     ((L'\\' == pwszFileList [0]) && (UNICODE_NULL == pwszFileList [1])))
	{
	bSucceeded = false;
	bFoundSpec = false;
	}

    else
	{
	bFoundSpec = true;
	}


    if (bSucceeded && bFoundSpec)
	{
	while (L' ' == pwszFileList [ulIndexFirstCharInSpec])
	    {
	    ulIndexFirstCharInSpec++;
	    }


	for (ulIndex = ulIndexFirstCharInSpec; ulIndex < ulLengthFileList; ulIndex++)
	    {
	    if ((UNICODE_NULL == pwszFileList [ulIndex]) ||
		(L';'         == pwszFileList [ulIndex]))
		{
		/*
		** We found the end of this specification
		*/
		break;
		}

	    else if (L'\\' == pwszFileList [ulIndex])
		{
		/*
		** Found a backslash? Record it's location. We'll want
		** this later when determining what the file name is
		** and so on.
		*/
		ulIndexLastDirectorySeparator = ulIndex;
		}

	    else if ((L'/' ==           pwszFileList [ulIndex]) &&
		     (L's' == towlower (pwszFileList [ulIndex + 1])))
		{
		ulIndexSubDirectory = ulIndex;
		}
	    }
	


	ulIndexLastCharInSpec = (0 == ulIndexSubDirectory) ? ulIndex - 1 : ulIndexSubDirectory - 1;

	while (L' ' == pwszFileList [ulIndexLastCharInSpec])
	    {
	    ulIndexLastCharInSpec--;
	    }


	_ASSERTE (ulIndex                       >  ulIndexSubDirectory);
	_ASSERTE (ulIndexSubDirectory == 0 ||
	          ulIndexSubDirectory           >  ulIndexLastCharInSpec);
	_ASSERTE (ulIndexLastCharInSpec         >= ulIndexLastDirectorySeparator);
	_ASSERTE (ulIndexLastDirectorySeparator >  ulIndexFirstCharInSpec);


	/*
	** We may have an illegal spec here with a missing '\'. Come
	** on folks, there ought to be at least one. one measly '\' is
	** all I'm after.
	*/
	bSucceeded = (0 < ulIndexLastDirectorySeparator);
	}




    if (bSucceeded)
	{
	if (bFoundSpec)
	    {
	    ulPathNameLength = ulIndexLastDirectorySeparator - ulIndexFirstCharInSpec;
	    ulFileNameLength = ulIndexLastCharInSpec         - ulIndexLastDirectorySeparator;


	    pwszReturnedCursor                 = (UNICODE_NULL == pwszFileList [ulIndex])
									? &pwszFileList [ulIndex]
									: &pwszFileList [ulIndex + 1];

	    ulReturnedDirectoryStart           = ulIndexFirstCharInSpec;
	    ulReturnedDirectoryLength          = ulPathNameLength;
	    ulReturnedFilenameStart            = ulIndexLastDirectorySeparator + 1;
	    ulReturnedFilenameLength           = ulFileNameLength;

	    bReturnedRecurseIntoSubdirectories = (0 != ulIndexSubDirectory);
	    bReturnedFoundSpec                 = true;
	    }

	else
	    {
	    pwszReturnedCursor                 = pwszFileList;

	    ulReturnedDirectoryStart           = 0;
	    ulReturnedDirectoryLength          = 0;
	    ulReturnedFilenameStart            = 0;
	    ulReturnedFilenameLength           = 0;

	    bReturnedRecurseIntoSubdirectories = false;
	    bReturnedFoundSpec                 = false;
	    }
	}



    return (bSucceeded);
    } /* DetermineNextPathWorker () */



static bool DetermineNextPathLengths (LPCWSTR pwszFileList,
				      ULONG&  ulReturnedLengthDirectory,
				      ULONG&  ulReturnedLengthFilename,
				      bool&   bReturnedRecurseIntoSubdirectories,
				      bool&   bReturnedFoundSpec)
    {
    bool	bSucceeded;
    LPCWSTR	pwszUpdatedCursor;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
					  pwszUpdatedCursor,
					  ulIndexDirectoryStart,
					  ulReturnedLengthDirectory,
					  ulIndexFilenameStart,
					  ulReturnedLengthFilename,
					  bReturnedRecurseIntoSubdirectories,
					  bReturnedFoundSpec);

    return (bSucceeded);
    } /* DetermineNextPathLengths () */


static bool DetermineNextPath (LPCWSTR  pwszFileList,
			       LPCWSTR& pwszReturnedCursor,
			       ULONG    ulLengthBufferDirectory,
			       PWCHAR   pwszBufferDirectory,
			       ULONG    ulLengthBufferFilename,
			       PWCHAR   pwszBufferFilename,
			       bool&    bReturnedRecurseIntoSubdirectories,
			       bool&    bReturnedFoundSpec)
    {
    bool	bSucceeded                    = true;
    bool	bRecurseIntoSubdirectories;
    bool	bFoundSpec;
    bool	bWildcardFilename;
    LPCWSTR	pwszUpdatedCursor;
    ULONG	ulLengthDirectory;
    ULONG	ulLengthFilename;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
					  pwszUpdatedCursor,
					  ulIndexDirectoryStart,
					  ulLengthDirectory,
					  ulIndexFilenameStart,
					  ulLengthFilename,
					  bRecurseIntoSubdirectories,
					  bFoundSpec);

    if (bSucceeded && bFoundSpec)
	{
	if ((ulLengthBufferDirectory < ((sizeof (WCHAR) * ulLengthDirectory) + sizeof (UNICODE_NULL))) ||
	    (ulLengthBufferFilename  < ((sizeof (WCHAR) * ulLengthFilename)  + sizeof (UNICODE_NULL))))
	    {
	    /*
	    ** Oops, buffer overflow would occur if we were to proceed
	    ** with the copy.
	    */
	    bSucceeded = false;
	    }
	}


    if (bSucceeded)
	{
	bReturnedRecurseIntoSubdirectories = bRecurseIntoSubdirectories;
	bReturnedFoundSpec                 = bFoundSpec;
	pwszReturnedCursor                 = pwszUpdatedCursor;


	if (bFoundSpec)
	    {
	    /*
	    ** Everything up to, but excluding the last directory
	    ** separator is the path. Everything after the last directory
	    ** separator up to and including the last char is the
	    ** filespec. If the filespec is zero length, then add the '*'
	    ** wildcard.
	    */
	    bWildcardFilename = (0 == ulLengthFilename);

	    ulLengthFilename += bWildcardFilename ? 1 : 0;


	    memcpy (pwszBufferDirectory,
		    &pwszFileList [ulIndexDirectoryStart],
		    sizeof (WCHAR) * ulLengthDirectory);

	    memcpy (pwszBufferFilename,
		    (bWildcardFilename) ? L"*" : &pwszFileList [ulIndexFilenameStart],
		    sizeof (WCHAR) * ulLengthFilename);

	    pwszBufferDirectory [ulLengthDirectory] = UNICODE_NULL;
	    pwszBufferFilename  [ulLengthFilename]  = UNICODE_NULL;
	    }
	}


    return (bSucceeded);
    } /* DetermineNextPath () */



static bool ValidateIncludeExcludeList (LPCWSTR pwszFileList)
    {
    LPCWSTR	pwszCursor  = pwszFileList;
    bool	bSucceeded  = true;
    bool	bFoundFiles = true;
    bool	bRecurseIntoSubdirectories;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;
    ULONG	ulLengthDirectory;
    ULONG	ulLengthFilename;

    while (bSucceeded && bFoundFiles)
	{
	bSucceeded = EXECUTEIF (bSucceeded, (DetermineNextPathWorker (pwszCursor,
								      pwszCursor,
								      ulIndexDirectoryStart,
								      ulLengthDirectory,
								      ulIndexFilenameStart,
								      ulLengthFilename,
								      bRecurseIntoSubdirectories,
								      bFoundFiles)));
	}


    return (bSucceeded);
    } /* ValidateIncludeExcludeList () */


/*
** Based on MatchFname() from \nt\base\fs\utils\ntback50\be\bsdmatch.cpp
*/
static bool MatchFilename (LPCWSTR pwszPattern,    /* I - file name (with wildcards)     */
			   LPCWSTR pwszFilename)   /* I - file name (without wildcards ) */
    {
    ULONG	ulIndexPattern;					/* index for pwszPattern */
    ULONG	ulIndexFilename;				/* index for pwszFilename */
    ULONG	ulLengthPattern;
    const ULONG	ulLengthFilename        = wcslen (pwszFilename);
    bool	bSucceeded              = true;
    PWCHAR	pwszNameBufferAllocated = NULL;			/* allocated temp name buffer  */
    PWCHAR	pwszNameBufferTemp;				/* pointer to one of the above */
    PWCHAR	pwchTemp;
    WCHAR	pwszNameBufferStatic [256];			/* static temp name buffer     */
    WCHAR	wchSavedChar ;


    ulIndexFilename = 0;

    if (wcscmp (pwszPattern, L"*") && wcscmp (pwszPattern, L"*.*"))
	{
	bool bTryWithDot = false;

	do
	    {
	    if (bTryWithDot)
		{
		/*
		** Size of name_buff minus a null, minus a dot for the
		** "bTryWithDot" code below. If the name is longer than the
		** static buffer, allocate one from the heap.
		*/
		if (((ulLengthFilename + 2) * sizeof (WCHAR)) > sizeof (pwszNameBufferStatic))
		    {
		    pwszNameBufferAllocated = new WCHAR [ulLengthFilename + 2];
		    pwszNameBufferTemp = pwszNameBufferAllocated;
		    }
		else
		    {
		    pwszNameBufferTemp = pwszNameBufferStatic;
		    }

		if (pwszNameBufferTemp != NULL)
		    {
		    wcscpy (pwszNameBufferTemp, pwszFilename);
		    wcscat (pwszNameBufferTemp, L".");
		    pwszFilename = pwszNameBufferTemp;
		    ulIndexFilename = 0;
		    bSucceeded = true;
		    }

		bTryWithDot = false;
		}

	    else if (wcschr (pwszFilename, L'.') == NULL)
		{
		bTryWithDot = true;
		}


	    for (ulIndexPattern = 0; (pwszPattern [ulIndexPattern] != 0) && (bSucceeded) ; ulIndexPattern++)
		{
		switch (pwszPattern [ulIndexPattern])
		    {
		    case L'*':
			while (pwszPattern [ulIndexPattern + 1] != UNICODE_NULL)
			    {
			    if (pwszPattern [ulIndexPattern + 1] == L'?')
				{
				if (pwszFilename [++ulIndexFilename] == UNICODE_NULL)
				    {
				    break ;
				    }
				}

			    else if (pwszPattern [ulIndexPattern + 1] != L'*')
				{
				break ;
				}

			    ulIndexPattern++ ;
			    }

			pwchTemp = wcspbrk (&pwszPattern [ulIndexPattern + 1], L"*?");

			if (pwchTemp != NULL)
			    {
			    wchSavedChar = *pwchTemp;
			    *pwchTemp = UNICODE_NULL;

			    ulLengthPattern = wcslen (&pwszPattern [ulIndexPattern + 1]);

			    while (pwszFilename [ulIndexFilename] &&
				   _wcsnicmp (&pwszFilename [ulIndexFilename],
					      &pwszPattern [ulIndexPattern + 1],
					      ulLengthPattern))
				{
				ulIndexFilename++;
				}

			    ulIndexPattern += ulLengthPattern;

			    *pwchTemp = wchSavedChar;

			    if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
				{
				bSucceeded = false;
				}
			    else
				{
				ulIndexFilename++;
				}
			    }
			else
			    {
			    if (pwszPattern [ulIndexPattern + 1] == UNICODE_NULL)
				{
				ulIndexFilename = wcslen (pwszFilename);
				break;
				}
			    else
				{
				pwchTemp = wcschr (&pwszFilename [ulIndexFilename],
						   pwszPattern [ulIndexPattern + 1]);

				if (pwchTemp != NULL)
				    {
				    ulIndexFilename += (ULONG)(pwchTemp - &pwszFilename [ulIndexFilename]);
				    }
				else
				    {
				    bSucceeded = false;
				    }
				}
			    }
			break;


		    case L'?' :
			if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
			    {
			    ulIndexFilename++;
			    }
			break;


		    default:
			if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
			    {
			    bSucceeded = false;
			    }

			else if (towupper (pwszFilename [ulIndexFilename]) != towupper (pwszPattern [ulIndexPattern]))
			    {
			    ULONG	ulIndexPreviousStar = ulIndexPattern;


			    /*
			    ** Set the index back to the last '*'
			    */
			    bSucceeded = false;

			    do
				{
				if (pwszPattern [ulIndexPreviousStar] == L'*')
				    {
				    ulIndexPattern = ulIndexPreviousStar;
				    ulIndexFilename++;
				    bSucceeded = true;
				    break;
				    }
				} while (ulIndexPreviousStar-- > 0);
			    }
			else
			    {
			    ulIndexFilename++;
			    }

		    }
		}


	    if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
		{
		bSucceeded = false;
		}

	    } while ((!bSucceeded) && (bTryWithDot));
	}


    delete [] pwszNameBufferAllocated;


    return (bSucceeded);
    } /* MatchFilename () */


/////////////////////////////////////////////////////////////////////////////
//  class CVssIJetWriter
//
// logical path   == instance name
// component name == dbfilename (minus the extension?)
// caption        == display name
//
//
// add db and slv files as database files
// add the per-instance log file to each database even though is is the same each time.



STDMETHODCALLTYPE CVssIJetWriter::~CVssIJetWriter()
    {
    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);

    delete m_wszWriterName;
    delete m_wszFilesToInclude;
    delete m_wszFilesToExclude;
    }



BOOL CVssIJetWriter::CheckExcludedFileListForMatch (LPCWSTR pwszDatabaseFilePath,
						    LPCWSTR pwszDatabaseFileSpec)
    {
    BOOL		bMatchFound	= false;
    PLIST_ENTRY		pleElement	= m_leFilesToExcludeEntries.Flink;
    UNICODE_STRING	ucsExcludedFilePath;
    UNICODE_STRING	ucsDatabaseFilePath;
    PEXPANDEDPATHINFO	pepnPathInfomation;


    RtlInitUnicodeString (&ucsDatabaseFilePath, pwszDatabaseFilePath);


    while ((&m_leFilesToExcludeEntries != pleElement) && !bMatchFound)
	{
	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

	RtlInitUnicodeString (&ucsExcludedFilePath,
			      pepnPathInfomation->pwszExpandedFilePath);

	
	if (pepnPathInfomation->bRecurseIntoSubdirectories)
	    {
	    bMatchFound = RtlPrefixUnicodeString (&ucsExcludedFilePath,
						  &ucsDatabaseFilePath,
						  true);
	    }
	else
	    {
	    bMatchFound = RtlEqualUnicodeString (&ucsExcludedFilePath, &ucsDatabaseFilePath, true) &&
			  MatchFilename (pepnPathInfomation->pwszExpandedFileName, pwszDatabaseFileSpec);
	    }



	pleElement = pleElement->Flink;
	}




    return (bMatchFound);
    } /* CVssIJetWriter::CheckExcludedFileListForMatch () */




bool CVssIJetWriter::ProcessJetInstance (JET_INSTANCE_INFO *pInstanceInfo)
    {
    JET_ERR	jetStatus;
    HRESULT	hrStatus;
    DWORD	dwStatus;
    bool	bSucceeded;
    bool	bRestoreMetadata        = false;
    bool	bNotifyOnBackupComplete = false;
    bool	bSelectable             = false;
    bool	bIncludeComponent;
    CHAR	szPathShortName        [MAX_PATH];
    CHAR	szPathFullName         [MAX_PATH];
    WCHAR	wszInstanceName        [MAX_PATH];
    WCHAR	wszDatabaseName        [MAX_PATH];
    WCHAR	wszDatabaseDisplayName [MAX_PATH];
    WCHAR	wszDatabaseFilePath    [MAX_PATH];
    WCHAR	wszDatabaseSLVFilePath [MAX_PATH];
    WCHAR	wszLogFilePath         [MAX_PATH];
    WCHAR	wszLogFileName         [MAX_PATH];
    WCHAR	wszCheckpointFilePath  [MAX_PATH];
    WCHAR	wszCheckpointFileName  [MAX_PATH];

    PWCHAR	pwszDatabaseFileName    = L"";
    PWCHAR	pwszDatabaseSLVFileName = L"";




    /*
    ** A valid instance will have an instance Id, but if it's not
    ** actually being used for anything it may well not have a name,
    ** any log or database files.
    **
    ** See if we can get hold of the name of the log file for this
    ** instance.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramLogFilePath,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	dwStatus = GetFullPathNameA (szPathShortName,
				     sizeof (szPathFullName),
				     szPathFullName,
				     NULL);

	bSucceeded = (dwStatus > 0);
	}


    if (bSucceeded)
	{
	RemoveAnyTrailingSeparator (szPathFullName);

	bSucceeded = ConvertName (szPathFullName,
				  MAX_PATH,
				  wszLogFilePath);
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() with instance Log file path '%S' (shortname) or '%s' full name",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszLogFilePath));





    /*
    ** Ok, now get the SystemPath which we will need to construct the
    ** path for the checkpoint file.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramSystemPath,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	dwStatus = GetFullPathNameA (szPathShortName,
				     sizeof (szPathFullName),
				     szPathFullName,
				     NULL);

	bSucceeded = (dwStatus > 0);
	}


    if (bSucceeded)
	{
	RemoveAnyTrailingSeparator (szPathFullName);

	bSucceeded = ConvertName (szPathFullName,
				  MAX_PATH,
				  wszCheckpointFilePath);
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() with checkpoint file path '%S' (shortname) or '%s' full name",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszCheckpointFilePath));



    /*
    ** Ok, now get the base name which we will need to construct the
    ** file spec for the log and checkpoint files. Note that we expect
    ** this to be just 3 chars long.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramBaseName,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	/*
	** Convert to wide char ensuring that we leave a little room
	** for the "*.log"/".chk" strings to be appended to form the
	** log file spec and the checkpoint file specs respectively.
	*/
	bSucceeded = ConvertName (szPathShortName,
				  MAX_PATH - sizeof ("*.log"),
				  wszCheckpointFileName);
	}


    if (bSucceeded)
	{
	wcscpy (wszLogFileName, wszCheckpointFileName);


	wcscat (wszCheckpointFileName, L".chk" );
	wcscat (wszLogFileName,        L"*.log");
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() for base name '%S' to form LogFileName '%s' and CheckpointFileName '%s'",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszLogFileName,
		   wszCheckpointFileName));




    if (bSucceeded && (pInstanceInfo->cDatabases > 0))
	{
	/*
	** Ok, we think we have an instance that is actually being
	** used for something. so go ahead and construct a 'component'
	** for it.
	*/
	if ((NULL == pInstanceInfo->szInstanceName) ||
	    ('\0' == pInstanceInfo->szInstanceName [0]))
	    {
	    /*
	    ** We seem to have a NULL pointer or a zero length
	    ** string. Just set to a zero length unicode string.
	    */
	    wszInstanceName [0] = UNICODE_NULL;
	    }

	else
	    {
	    bSucceeded = ConvertName (pInstanceInfo->szInstanceName,
				      MAX_PATH,
				      wszInstanceName);
	    }



	for (ULONG ulDatabase = 0; bSucceeded && (ulDatabase < pInstanceInfo->cDatabases); ulDatabase++)
	    {
	    bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseFileName [ulDatabase],
							  MAX_PATH,
							  wszDatabaseFilePath,
							  pwszDatabaseFileName);


	    /*
	    ** Convert the database display name to unicode but allow
	    ** for a possible NULL pointer or a non-zero length file
	    ** spec.
	    */
	    if (bSucceeded)
		{
		if ((NULL == pInstanceInfo->szDatabaseDisplayName [ulDatabase]) ||
		    ('\0' == pInstanceInfo->szDatabaseDisplayName [ulDatabase][0]))
		    {
		    wszDatabaseDisplayName [0] = UNICODE_NULL;
		    }
		else
		    {
		    bSucceeded = ConvertName (pInstanceInfo->szDatabaseDisplayName [ulDatabase],
					      MAX_PATH,
					      wszDatabaseDisplayName);
		    }
		}


	    /*
	    ** Convert the SLV filename to unicode but allow for a
	    ** possible NULL pointer or a non-zero length file spec.
	    */
	    if (bSucceeded)
		{
		if ((NULL == pInstanceInfo->szDatabaseSLVFileName [ulDatabase]) ||
		    ('\0' == pInstanceInfo->szDatabaseSLVFileName [ulDatabase][0]))
		    {
		    wszDatabaseSLVFilePath [0] = UNICODE_NULL;
		    pwszDatabaseSLVFileName    = wszDatabaseSLVFilePath;
		    }
		else
		    {
		    bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseSLVFileName [ulDatabase],
								  MAX_PATH,
								  wszDatabaseSLVFilePath,
								  pwszDatabaseSLVFileName);
		    }
		}




	    /*
	    ** We've now done all the name conversions to unicode so
	    ** add a component and the log and database files where
	    ** they're available.
	    */
	    if (bSucceeded)
		{
		bIncludeComponent = !CheckExcludedFileListForMatch (wszDatabaseFilePath,
								    pwszDatabaseFileName);
		}


	    if (bSucceeded && bIncludeComponent)
		{
		PWCHAR	pwchLastDot          = wcsrchr (pwszDatabaseFileName, L'.');
		ULONG	ulDatabaseNameLength = (ULONG) (pwchLastDot - pwszDatabaseFileName);

		wcsncpy (wszDatabaseName, pwszDatabaseFileName, ulDatabaseNameLength);
		wszDatabaseName [ulDatabaseNameLength] = '\0';



		hrStatus = m_pIMetadata->AddComponent (VSS_CT_DATABASE,
						       wszInstanceName,
						       wszDatabaseName,
						       wszDatabaseDisplayName,
						       NULL,
						       0,
						       bRestoreMetadata,
						       bNotifyOnBackupComplete,
						       bSelectable);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding component '%s' for database '%s' with display name '%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseDisplayName));
		}
	


	    if (bSucceeded && bIncludeComponent)
		{
		hrStatus = m_pIMetadata->AddDatabaseFiles (wszInstanceName,
							   wszDatabaseName,
							   wszDatabaseFilePath,
							   pwszDatabaseFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding database files for instance '%s', database '%s', database file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseFilePath,
			       pwszDatabaseFileName));
		}
	


	    /*
	    ** May not have an SLV file so only add it if we have a
	    ** non-zero length file spec
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != pwszDatabaseSLVFileName [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseFiles (wszInstanceName,
							   wszDatabaseName,
							   wszDatabaseSLVFilePath,
							   pwszDatabaseSLVFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding SLV file for instance '%s', database '%s', SLV file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseSLVFilePath,
			       pwszDatabaseSLVFileName));
		}


	    /*
	    ** May not have an instance log file so only add it if we
	    ** have a non-zero length file path
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszLogFilePath [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszInstanceName,
							      wszDatabaseName,
							      wszLogFilePath,
							      wszLogFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding log file for instance '%s', database '%s', log file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszLogFilePath,
			       wszLogFileName));
		}


	    /*
	    ** May not have a checkpoint file so only add it if we
	    ** have a non-zero length file path
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszCheckpointFilePath [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszInstanceName,
							      wszDatabaseName,
							      wszCheckpointFilePath,
							      wszCheckpointFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding checkpoint file for instance '%s', database '%s', checkpoint file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszCheckpointFilePath,
			       wszCheckpointFileName));
		}
	    }
	}


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessJetInstance () */



bool CVssIJetWriter::PreProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** Parse the m_wszFilesToInclude and m_wszFilesToExclude adding
    ** and enty to the appropriate list as necessary. This will
    ** minimize the number of passes over the un-processed lists.
    */
    ULONG		ulPathLength;
    ULONG		ulNameLength;
    bool		bRecurseIntoSubdirectories;
    bool		bSucceeded         = true;
    bool		bFoundFiles        = true;
    PEXPANDEDPATHINFO	pepnPathInfomation = NULL;
    PWCHAR		pwszCursor         = bProcessingIncludeList
						? m_wszFilesToInclude
						: m_wszFilesToExclude;



    while (bSucceeded && bFoundFiles)
	{
	bSucceeded = DetermineNextPathLengths (pwszCursor,
					       ulPathLength,
					       ulNameLength,
					       bRecurseIntoSubdirectories,
					       bFoundFiles);


	if (bSucceeded && bFoundFiles)
	    {
	    pepnPathInfomation = new EXPANDEDPATHINFO;

	    bSucceeded = (NULL != pepnPathInfomation);
	    }
	else
	    {
	    /*
	    ** We either failed and/or found no files. In either case
	    ** there is no point in continuing.
	    */
	    break;
	    }



	if (bSucceeded)
	    {
	    InitializeListHead (&pepnPathInfomation->leQueueHead);


	    if (0 == ulNameLength)
		{
		/*
		** If the filename component is zero length, then it
		** will be turned into a "*" so add a character to the
		** buffer to make room.
		*/
		ulNameLength++;
		}

	    /*
	    ** Allow extra space for terminating UNICODE_NULL
	    */
	    ulPathLength++;
	    ulNameLength++;


	    pepnPathInfomation->pwszExpandedFilePath = NULL;
	    pepnPathInfomation->pwszExpandedFileName = NULL;
	    pepnPathInfomation->pwszOriginalFilePath = new WCHAR [ulPathLength];
	    pepnPathInfomation->pwszOriginalFileName = new WCHAR [ulNameLength];

	    bSucceeded = ((NULL != pepnPathInfomation->pwszOriginalFilePath) &&
			  (NULL != pepnPathInfomation->pwszOriginalFileName));
	    }


	if (bSucceeded)
	    {
	    bSucceeded = DetermineNextPath (pwszCursor,
					    pwszCursor,
					    ulPathLength * sizeof (WCHAR),
					    pepnPathInfomation->pwszOriginalFilePath,
					    ulNameLength * sizeof (WCHAR),
					    pepnPathInfomation->pwszOriginalFileName,
					    pepnPathInfomation->bRecurseIntoSubdirectories,
					    bFoundFiles);

	    BS_ASSERT (bFoundFiles && L"Second attempt to locate files failed unexpectedly");
	    }


	if (bSucceeded)
	    {
	    ulPathLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath, NULL, 0);
	    ulNameLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName, NULL, 0);

	    bSucceeded = (0 < ulPathLength) && (0 < ulNameLength);
	    }


	if (bSucceeded)
	    {
	    pepnPathInfomation->pwszExpandedFilePath = new WCHAR [ulPathLength];
	    pepnPathInfomation->pwszExpandedFileName = new WCHAR [ulNameLength];

	    bSucceeded = ((NULL != pepnPathInfomation->pwszExpandedFilePath) &&
			  (NULL != pepnPathInfomation->pwszExpandedFileName));
	    }


	if (bSucceeded)
	    {
	    ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath,
				       pepnPathInfomation->pwszExpandedFilePath,
				       ulPathLength);


	    ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName,
				       pepnPathInfomation->pwszExpandedFileName,
				       ulNameLength);
	    }


	if (bSucceeded)
	    {
	    InsertTailList (bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries,
			    &pepnPathInfomation->leQueueHead);

	    pepnPathInfomation = NULL;
	    }



	if (NULL != pepnPathInfomation)
	    {
	    delete [] pepnPathInfomation->pwszOriginalFilePath;
	    delete [] pepnPathInfomation->pwszOriginalFileName;
	    delete [] pepnPathInfomation->pwszExpandedFilePath;
	    delete [] pepnPathInfomation->pwszExpandedFileName;
	    delete pepnPathInfomation;

	    pepnPathInfomation = NULL;
	    }
	}


    return (bSucceeded);
    } /* CVssIJetWriter::PreProcessIncludeExcludeLists () */



bool CVssIJetWriter::ProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** parse the m_wszFilesToInclude and m_wszFilesToExclude
    ** calling the m_pIMetadata->IncludeFiles() and/or
    ** m_pIMetadata->ExcludeFiles() routines as necessary
    */
    HRESULT		hrStatus;
    bool		bSucceeded   = true;
    const PLIST_ENTRY	pleQueueHead = bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries;
    PLIST_ENTRY		pleElement   = pleQueueHead->Flink;
    PEXPANDEDPATHINFO	pepnPathInfomation;



    while (bSucceeded && (pleQueueHead != pleElement))
	{
	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));


	if (bProcessingIncludeList)
	    {
	    hrStatus = m_pIMetadata->AddIncludeFiles (pepnPathInfomation->pwszOriginalFilePath,
						      pepnPathInfomation->pwszOriginalFileName,
						      pepnPathInfomation->bRecurseIntoSubdirectories,
						      NULL);
	    }
	else
	    {
	    hrStatus = m_pIMetadata->AddExcludeFiles (pepnPathInfomation->pwszOriginalFilePath,
						      pepnPathInfomation->pwszOriginalFileName,
						      pepnPathInfomation->bRecurseIntoSubdirectories);
	    }


	bSucceeded = SUCCEEDED (hrStatus);

	pleElement = pleElement->Flink;
	}


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessIncludeExcludeLists () */



void CVssIJetWriter::PostProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    PEXPANDEDPATHINFO	pepnPathInfomation;
    PLIST_ENTRY		pleElement;
    const PLIST_ENTRY	pleQueueHead = bProcessingIncludeList
						? &m_leFilesToIncludeEntries
						: &m_leFilesToExcludeEntries;


    while (!IsListEmpty (pleQueueHead))
	{
	pleElement = RemoveHeadList (pleQueueHead);

	BS_ASSERT (NULL != pleElement);


	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

	delete [] pepnPathInfomation->pwszOriginalFilePath;
	delete [] pepnPathInfomation->pwszOriginalFileName;
	delete [] pepnPathInfomation->pwszExpandedFilePath;
	delete [] pepnPathInfomation->pwszExpandedFileName;
	delete pepnPathInfomation;
	}
    } /* CVssIJetWriter::PostProcessIncludeExcludeLists () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnIdentify (IN IVssCreateWriterMetadata *pMetadata)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnIdentify");

    JET_ERR		 jetStatus;
    HRESULT		 hrStatus;
    bool		 bSucceeded = true;
    ULONG		 ulInstanceInfoCount = 0;
    JET_INSTANCE_INFO	*pInstanceInfo;


    m_pIMetadata = pMetadata;


    /*
    ** Set up list of include and exclude files. ready for use in
    ** filtering Jet databases and adding include/exclude files lists.
    */
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (false)));

    bSucceeded = EXECUTEIF (bSucceeded, (JET_errSuccess <= JetGetInstanceInfo (&ulInstanceInfoCount,
									       &pInstanceInfo)));

    for (ULONG ulInstanceIndex = 0; ulInstanceIndex < ulInstanceInfoCount; ulInstanceIndex++)
	{
	bSucceeded = EXECUTEIF (bSucceeded, (ProcessJetInstance (pInstanceInfo + ulInstanceIndex)));
	}


    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (false)));
    bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnIdentify (pMetadata)));



    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);


    m_pIMetadata = NULL;

    return (bSucceeded);
    } /* CVssIJetWriter::OnIdentify () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareBackup (IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareBackup");

	bool	bSucceeded;
	

	bSucceeded = m_pwrapper->OnPrepareBackupBegin (pIVssWriterComponents);

	bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnPrepareBackupEnd (pIVssWriterComponents, bSucceeded)));

	return (bSucceeded);
	} /* CVssIJetWriter::OnPrepareBackup () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnBackupComplete (IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnBackupComplete");

	bool	bSucceeded;
	

	bSucceeded = m_pwrapper->OnBackupCompleteBegin (pIVssWriterComponents);

	bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnBackupCompleteEnd (pIVssWriterComponents, bSucceeded)));

	return (bSucceeded);
	} /* CVssIJetWriter::OnBackupComplete () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareSnapshot()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareSnapshot");

	if (!m_pwrapper->OnPrepareSnapshotBegin())
		return false;

	// go to Jet level directly
	bool fSuccess = JET_errSuccess <= JetOSSnapshotPrepare( &m_idJet , 0 );
	return m_pwrapper->OnPrepareSnapshotEnd(fSuccess);
	} /* CVssIJetWriter::OnPrepareSnapshot () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnFreeze()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnFreeze");

	unsigned long 			cInstanceInfo 	= 0;
	JET_INSTANCE_INFO *		aInstanceInfo 	= NULL;
	bool 					fDependence		= true;

	if (!m_pwrapper->OnFreezeBegin())
		return false;


	// we need to freeze at Jet level, then check from this DLL the dependencies
	// (as here we hagve the snapshot object implementation and COM registration)
	
	if ( JET_errSuccess > JetOSSnapshotFreeze( m_idJet , &cInstanceInfo, &aInstanceInfo, 0 ) )
		{
		return false;
		}

	// return false if some instances are only partialy affected
	fDependence = FCheckVolumeDependencies(cInstanceInfo, aInstanceInfo);
	(void)JetFreeBuffer( (char *)aInstanceInfo );
	
	if ( !fDependence )
		{
		JET_ERR 	err;
 		// on error, stop the snapshot, return false
		err = JetOSSnapshotThaw( m_idJet , 0 );
		// shell we check for time-out error here ?
		// (debugging may result in time-out error the call)
		BS_ASSERT ( JET_errSuccess == err );
 		}

	return m_pwrapper->OnFreezeEnd(fDependence);	
	} /* CVssIJetWriter::OnFreeze () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnThaw()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnThaw");

	bool fSuccess1 = m_pwrapper->OnThawBegin();
	// go to Jet level directly. It will eventualy return timeout errors
	bool fSuccess2 = JET_errSuccess <= JetOSSnapshotThaw( m_idJet , 0 );
	return fSuccess1 && m_pwrapper->OnThawEnd(fSuccess2);
	} /* CVssIJetWriter::OnThaw () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPostSnapshot
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	return m_pwrapper->OnPostSnapshot(pIVssWriterComponents);
	}



bool STDMETHODCALLTYPE CVssIJetWriter::OnAbort()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnAbort");

	m_pwrapper->OnAbortBegin();
	JetOSSnapshotThaw( m_idJet , 0 );
	m_pwrapper->OnAbortEnd();
	return true;
	} /* CVssIJetWriter::OnAbort () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPreRestore
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

	if (!m_pwrapper->OnPreRestoreBegin(pIVssWriterComponents))
		return false;

	// go to Jet level directly
	// BUGBUG - need to add the correct Jet restore call/code here (MCJ)
	//	bool fSuccess = JET_errSuccess <= JetRestore ( ??? &m_idJet , 0 );
	bool fSuccess = TRUE;
	return m_pwrapper->OnPreRestoreEnd(pIVssWriterComponents, fSuccess);
	} /* CVssIJetWriter::OnPreRestore () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnPostRestore
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

	if (!m_pwrapper->OnPostRestoreBegin(pIVssWriterComponents))
		return false;

	// go to Jet level directly
	// BUGBUG - need to add the correct Jet restore call/code here (MCJ)
	//	bool fSuccess = JET_errSuccess <= JetRestore ( ??? &m_idJet , 0 );
	bool fSuccess = TRUE;
	return m_pwrapper->OnPostRestoreEnd(pIVssWriterComponents, fSuccess);
	} /* CVssIJetWriter::OnPostRestore () */



bool CVssIJetWriter::FCheckPathVolumeDependencies(const char * szPath) const
	{
	// use static variable in order to avoid alloc/free
	WCHAR wszPath[MAX_PATH];

	if (MultiByteToWideChar(CP_OEMCP, 0, szPath, -1, wszPath, MAX_PATH ) == 0 )
		{
		BS_ASSERT( ERROR_INSUFFICIENT_BUFFER != GetLastError() );
		return false;
		}

	// use standart Writer call to check the affected path
	return IsPathAffected(wszPath);
	} /* CVssIJetWriter::FCheckPathVolumeDependencies () */



// all or nothing check: all path in instance are affected or none !
//
bool CVssIJetWriter::FCheckInstanceVolumeDependencies (const JET_INSTANCE_INFO * pInstanceInfo) const
	{
	BS_ASSERT(pInstanceInfo);

	JET_ERR 	err 			= JET_errSuccess;
	bool		fAffected		= false;
	char 		szPath[ MAX_PATH ];		
	
	
	// check first system and log path
	err = JetGetSystemParameter( pInstanceInfo->hInstanceId, JET_sesidNil, JET_paramLogFilePath, NULL, szPath, sizeof( szPath ) );
	if ( JET_errSuccess > err )
		return false;

	fAffected = FCheckPathVolumeDependencies( szPath );

	err = JetGetSystemParameter
		(
		pInstanceInfo->hInstanceId,
		JET_sesidNil,
		JET_paramSystemPath,
		NULL,
		szPath,
		sizeof(szPath)
		);

	if (JET_errSuccess > err)
		return false;

		
	fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szPath));
	if (!fAffected)
		return false;
		
	for (ULONG_PTR iDatabase = 0;
		iDatabase < pInstanceInfo->cDatabases;
		iDatabase++)
		{
		char * szFile = pInstanceInfo->szDatabaseFileName[iDatabase];
		
		BS_ASSERT(szFile); // we always have a db file name
		fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szFile));
		if (!fAffected)
			return false;

		szFile = pInstanceInfo->szDatabaseSLVFileName[iDatabase];

		// if no SLV file, go to next database
		if (!szFile)
			continue;
			
		fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szFile));
		if ( !fAffected )
			return false;
		}

	// all set !
	return true;
	} /* CVssIJetWriter::FCheckInstanceVolumeDependencies () */



bool CVssIJetWriter::FCheckVolumeDependencies
	(
	unsigned long cInstanceInfo,
	JET_INSTANCE_INFO *	aInstanceInfo
	) const
	{
	bool fResult = true;

	// check each instance
	while (cInstanceInfo && fResult)
		{
		cInstanceInfo--;
		fResult = FCheckInstanceVolumeDependencies (aInstanceInfo + cInstanceInfo);
		}
		
	return fResult;
	} /* CVssIJetWriter::FCheckVolumeDependencies () */



// internal method to assign basic members
HRESULT CVssIJetWriter::InternalInitialize (IN VSS_ID  idWriter,
					    IN LPCWSTR wszWriterName,
					    IN bool    bSystemService,
					    IN bool    bBootableSystemState,
					    IN LPCWSTR wszFilesToInclude,
					    IN LPCWSTR wszFilesToExclude)
    {
    HRESULT hrStatus = NOERROR;


    CVssWriter::Initialize (idWriter,
				wszWriterName,
				bBootableSystemState
					? VSS_UT_BOOTABLESYSTEMSTATE
					: (bSystemService
						? VSS_UT_SYSTEMSERVICE
						: VSS_UT_USERDATA),
				VSS_ST_TRANSACTEDDB,
				VSS_APP_BACK_END);


    m_idWriter             = idWriter;
    m_bSystemService       = bSystemService;
    m_bBootableSystemState = bBootableSystemState;
    m_wszWriterName        = _wcsdup(wszWriterName);
    m_wszFilesToInclude    = _wcsdup(wszFilesToInclude);
    m_wszFilesToExclude    = _wcsdup(wszFilesToExclude);

    if ((NULL == m_wszWriterName)     ||
	(NULL == m_wszFilesToInclude) ||
	(NULL == m_wszFilesToExclude))
	{
	delete m_wszWriterName;
	delete m_wszFilesToInclude;
	delete m_wszFilesToExclude;

	m_wszWriterName     = NULL;
	m_wszFilesToInclude = NULL;
	m_wszFilesToExclude = NULL;

	hrStatus = E_OUTOFMEMORY;
	}


    return (hrStatus);
    } /* CVssIJetWriter::InternalInitialize () */



// do initialization
HRESULT STDMETHODCALLTYPE CVssIJetWriter::Initialize (IN VSS_ID idWriter,			// id of writer
						      IN LPCWSTR wszWriterName,		// writer name
						      IN bool bSystemService,		// is this a system service
						      IN bool bBootableSystemState,	// is this writer part of bootable system state
						      IN LPCWSTR wszFilesToInclude,	// additional files to include
						      IN LPCWSTR wszFilesToExclude,	// additional files to exclude
						      IN CVssJetWriter *pWriter,		// writer wrapper class
						      OUT void **ppInstance)		// output instance
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Initialize");

    try
	{
	// check parameters
	if (ppInstance == NULL)
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"NULL output parameter.");
	    }

	// change null pointer to null strings for files to include
	// and files to exclude
    if (wszFilesToInclude == NULL)
		wszFilesToInclude = L"";

	if (wszFilesToExclude == NULL)
		wszFilesToExclude = L"";


	if (!ValidateIncludeExcludeList (wszFilesToInclude))
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToInclude list.");
	    }

	if (!ValidateIncludeExcludeList (wszFilesToExclude))
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToExclude list.");
	    }



	// null output parameter
	*ppInstance = NULL;

	// create instance
	PVSSIJETWRITER pInstance = new CVssIJetWriter;

	// create instance
	ft.ThrowIf (NULL == pInstance,
		    VSSDBG_GEN,
		    E_OUTOFMEMORY,
		    L"FAILED creating CVssIJetWriter object due to allocation failure.");



	// call internal initialization
	ft.hr = pInstance->InternalInitialize (idWriter,
					       wszWriterName,
					       bSystemService,
					       bBootableSystemState,
					       wszFilesToInclude,
					       wszFilesToExclude);

	ft.ThrowIf (ft.HrFailed(),
		    VSSDBG_GEN,
		    ft.hr,
		    L"FAILED during internal initialisation of CVssIJetWriter object");



	// Subscribe the object.
	ft.hr = pInstance->Subscribe();

	ft.ThrowIf (ft.HrFailed(),
		    VSSDBG_GEN,
		    ft.hr,
		    L"FAILED during internal initialisation of CVssIJetWriter object");



	((CVssIJetWriter *) pInstance)->m_pwrapper = pWriter;
	*ppInstance = (void *) pInstance;
	} VSS_STANDARD_CATCH(ft)


    return (ft.hr);
    } /* CVssIJetWriter::Initialize () */



void STDMETHODCALLTYPE CVssIJetWriter::Uninitialize(IN PVSSIJETWRITER pInstance)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Uninitialize");

	try
		{
		CVssIJetWriter *pWriter = (CVssIJetWriter *) pInstance;
		// Unsubscribe the object.

		BS_ASSERT(pWriter);

		pWriter->Unsubscribe();
		delete pWriter;
		}
	VSS_STANDARD_CATCH(ft)
	} /* CVssIJetWriter::Uninitialize () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\filter\filter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:

    @doc
    @module filter.cxx | publisher filter for IVssWriter event
    @end

Author:

    Brian Berkowitz  [brianb]  11/09/2000

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      10/09/2000  Created.

--*/

#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "sddl.h"
#include "vs_idl.hxx"
#include "lmerr.h"
#include "lmaccess.h"
#include "lmapibuf.h"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "FILFILTC"
//
////////////////////////////////////////////////////////////////////////


// auto sid class,  destroys sid when going out of scope
class CAutoSid
	{
public:
	CAutoSid() : m_psid(NULL)
		{
		}

	~CAutoSid()
		{
		if (m_psid)
			LocalFree(m_psid);
		}

	// create a sid base on a well known sid type
	void CreateBasicSid(WELL_KNOWN_SID_TYPE type);

	// create a sid from a string
	void CreateFromString(LPCWSTR wsz);

	// return pointer to sid
	SID *GetSid() { return m_psid; }

	void Empty()
		{
		LocalFree(m_psid);
		m_psid = NULL;
		}
private:
	SID *m_psid;

	};

// create a basic well known sid such as LOCAL_SERVICE, LOCAL_SYSTEM,
// or NETWORK_SERVICE.
void CAutoSid::CreateBasicSid(WELL_KNOWN_SID_TYPE type)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateBasicSid");

	BS_ASSERT(m_psid == NULL);

	DWORD cbSid = 0;
	CreateWellKnownSid(type, NULL, NULL, &cbSid);
	DWORD dwErr = GetLastError();
	if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		{
		ft.hr = HRESULT_FROM_WIN32(dwErr);
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
		}

	m_psid = (SID *) LocalAlloc(0, cbSid);
	if (m_psid == NULL)
		ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate SID");

	if (!CreateWellKnownSid(type, NULL, m_psid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
		}
	}

// create a sid based on a STRING sid
void CAutoSid::CreateFromString(LPCWSTR wsz)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateFromString");

	if (!ConvertStringSidToSid (wsz, (PSID *) &m_psid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"ConvertStringSidToSid");
		}
	}



// filter class
class CVssWriterPublisherFilter : public IMultiInterfacePublisherFilter
	{
public:
	CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl);

	STDMETHOD(Initialize)(IMultiInterfaceEventControl *pEc);
	STDMETHOD(PrepareToFire)(REFIID iid, BSTR bstrMethod, IFiringControl *pFiringControl);

	STDMETHOD(QueryInterface)(REFIID riid, void **ppvUnknown);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	static void CreatePublisherFilter
		(
		IMultiInterfaceEventControl *pControl,
		IMultiInterfacePublisherFilter **ppFilter
		);

private:
	// setup well known sids
	void SetupGenericSids();

	// determine if a SID is a member of a local group
	bool IsSidInGroup(SID *psid, LPCWSTR wszGroup);

	// cached pointer to event control
	CComPtr<IMultiInterfaceEventControl> m_pControl;

	// reference count
	LONG m_cRef;

	// well known sids

	// local service
	CAutoSid m_asidLocalService;

	// local system
	CAutoSid m_asidLocalSystem;

	// network service
	CAutoSid m_asidNetworkService;

	// Administrators
	CAutoSid m_asidAdministrators;

	// backup operators
	CAutoSid m_asidBackupOperators;

	// name of administrators group
	WCHAR m_wszAdministrators[MAX_PATH];

	// name of backup operators group
	WCHAR m_wszBackupOperators[MAX_PATH];

	// have well known sids beeen compouted
	bool m_bSidsAssigned;
	};

// constructor
CVssWriterPublisherFilter::CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl) :
	m_cRef(0),
	m_pControl(pControl),
	m_bSidsAssigned(false)
	{
	}

// create a publisher filter and return an interface pointer to it
void CVssWriterPublisherFilter::CreatePublisherFilter
	(
	IMultiInterfaceEventControl *pControl,
	IMultiInterfacePublisherFilter **ppFilter
	)
	{
	CVssWriterPublisherFilter *pFilter = new CVssWriterPublisherFilter(pControl);
	if (pFilter == NULL)
		throw E_OUTOFMEMORY;

	pFilter->QueryInterface(IID_IMultiInterfacePublisherFilter, (void **) ppFilter);
	}

// query interface method
STDMETHODIMP CVssWriterPublisherFilter::QueryInterface(REFIID riid, void **ppvUnk)
	{
	if (riid == IID_IUnknown)
		*ppvUnk = (IUnknown *) this;
	else if (riid == IID_IMultiInterfacePublisherFilter)
		*ppvUnk = (IMultiInterfacePublisherFilter *) (IUnknown *) this;
	else
		return E_NOINTERFACE;

	((IUnknown *) (*ppvUnk))->AddRef();
	return S_OK;
	}

// add ref method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// release method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);

	if (cRef == 0)
		{
		delete this;

		return 0;
		}
	else
		return (ULONG) cRef;
	}



// initialize method (does nothing.  All the work is done in PrepareToFire)
STDMETHODIMP CVssWriterPublisherFilter::Initialize
	(
	IMultiInterfaceEventControl *pec
	)
	{
	UNREFERENCED_PARAMETER(pec);

	return S_OK;
	}

// setup well known sids so that they only are computed once
void CVssWriterPublisherFilter::SetupGenericSids()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssPublisherFilter::SetupGenericSids");

	if (m_bSidsAssigned)
		return;

	m_asidLocalService.Empty();
	m_asidLocalSystem.Empty();
	m_asidNetworkService.Empty();

	m_asidLocalService.CreateBasicSid(WinLocalServiceSid);
	m_asidLocalSystem.CreateBasicSid(WinLocalSystemSid);
	m_asidNetworkService.CreateBasicSid(WinNetworkServiceSid);
	m_asidAdministrators.CreateBasicSid(WinBuiltinAdministratorsSid);
	m_asidBackupOperators.CreateBasicSid(WinBuiltinBackupOperatorsSid);

	DWORD cbName = MAX_PATH;
	WCHAR wszDomain[MAX_PATH];
	DWORD cbDomainName = MAX_PATH;
	SID_NAME_USE snu;

	// lookup name of administrators group
	if (!LookupAccountSid
			(
			NULL,
			m_asidAdministrators.GetSid(),
			m_wszAdministrators,
			&cbName,
			wszDomain,
			&cbDomainName,
			&snu))
        {
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"LookupAccountSid");
		}

	// lookup name of backup operators group
	cbName = MAX_PATH;
	cbDomainName= MAX_PATH;

	if (!LookupAccountSid
			(
			NULL,
			m_asidBackupOperators.GetSid(),
			m_wszBackupOperators,
			&cbName,
			wszDomain,
			&cbDomainName,
			&snu))
        {
		DWORD dwErr = GetLastError();
		// the backup operators group does not exist on the personal
		// SKU.  A NULL name indicates that it doesn't exist
		if (dwErr == ERROR_NONE_MAPPED)
			m_wszBackupOperators[0] = L'\0';
		else
			{
			ft.hr = HRESULT_FROM_WIN32(GetLastError());
			ft.CheckForError(VSSDBG_GEN, L"LookupAccountSid");
			}
		}


	m_bSidsAssigned = true;
	}

// is a sid a member of a local group
bool CVssWriterPublisherFilter::IsSidInGroup(SID *psid, LPCWSTR wszGroup)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::IsSidInGroup");

	NET_API_STATUS status;
	BYTE *buffer;
	DWORD_PTR ResumeHandle = NULL;
	DWORD cEntriesRead, cEntriesTotal;

	// if group name is NULL, then the group does not exist.  It must have
	// no members
	if (wszGroup[0] == L'\0')
		return false;

	// get list of local group members
	status = NetLocalGroupGetMembers
				(
				NULL,
				wszGroup,
				0,
				&buffer,
				MAX_PREFERRED_LENGTH,
				&cEntriesRead,
				&cEntriesTotal,
				&ResumeHandle
				);

    if (status != NERR_Success)
		{
		ft.hr = HRESULT_FROM_WIN32(status);
		ft.CheckForError(VSSDBG_GEN, L"NetGroupGetUsers");
		}

	BS_ASSERT(cEntriesRead == cEntriesTotal);

	bool bFound = false;
	try
		{
		LOCALGROUP_MEMBERS_INFO_0 *rgMembers = (LOCALGROUP_MEMBERS_INFO_0 *) buffer;

		// loop through member list to see if any sids mach the sid of the owner
		// of the subscription
		for(DWORD iEntry = 0; iEntry < cEntriesRead; iEntry++)
			{
			PSID psidMember = rgMembers[iEntry].lgrmi0_sid;
			if (EqualSid(psidMember, psid))
				{
				bFound = true;
				break;
				}
			}
		}
	VSS_STANDARD_CATCH(ft)

	// free buffer allocated in NetLocalGroupGetMembers
	NetApiBufferFree(buffer);
	if (ft.HrFailed())
		{
		HRESULT hr = ft.hr;
		throw hr;
		}

	return bFound;
	}


// key method that determines which subscriptions shoud receive the event
STDMETHODIMP CVssWriterPublisherFilter::PrepareToFire
	(
	REFIID iid,
	BSTR bstrMethod,
	IFiringControl *pFiringControl
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::PrepareToFire");

	BS_ASSERT(iid == IID_IVssWriter);
	// validate iid we are being called on
	if (iid != IID_IVssWriter)
		return E_INVALIDARG;

	try
		{
		SetupGenericSids();

		CComPtr<IEventObjectCollection> pCollection;
		int location;

		// get subscriptions
		ft.hr = m_pControl->GetSubscriptions
					(
					IID_IVssWriter,
					bstrMethod,
					NULL,
					&location,
					&pCollection
					);

		ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::GetSubscriptions");

		// create enumerator
		CComPtr<IEnumEventObject> pEnum;
		ft.hr = pCollection->get_NewEnum(&pEnum);
		ft.CheckForError(VSSDBG_GEN, L"IEventObjectCollection::get_NewEnum");

		while(TRUE)
			{
			CComPtr<IEventSubscription> pSubscription;
			DWORD cElt;

			// get next subscription
			ft.hr = pEnum->Next(1, (IUnknown **) &pSubscription, &cElt);
			ft.CheckForError(VSSDBG_GEN, L"IEnumEventObject::Next");
			if (ft.hr == S_FALSE)
				break;

			// get owner of subscription
			CComBSTR bstrSID;
			ft.hr = pSubscription->get_OwnerSID(&bstrSID);
			ft.CheckForError(VSSDBG_GEN, L"IEventSubscription::get_OwnerSID");

			// convert string representation to sid
			CAutoSid asid;
			asid.CreateFromString(bstrSID);
			SID *psid = asid.GetSid();

			// determine if subscription should be fired
			bool bFire = false;

			if (EqualSid(psid, m_asidLocalSystem.GetSid()) ||
				EqualSid(psid, m_asidLocalService.GetSid()) ||
				EqualSid(psid, m_asidNetworkService.GetSid()))

				// fire if owner is LOCALSYSTEM, LOCALSERVICE, or NETWORKSERVICE
				bFire = true;
			else if (IsSidInGroup(psid, m_wszAdministrators) ||
					 IsSidInGroup(psid, m_wszBackupOperators))

                // fire if owner is a member of the Administrators
				// or Backup Operators group
				bFire = true;

			if (bFire)
				pFiringControl->FireSubscription(pSubscription);
			}

		ft.hr = S_OK;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// setup a filter on an event object
void SetupPublisherFilter(IVssWriter *pWriter)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"SetupPublisherFilter");

	CComPtr<IMultiInterfaceEventControl> pControl;

	// get event control interface
	ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
		ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
			ft.hr
			);
        }

	// create filter
	CComPtr<IMultiInterfacePublisherFilter> pFilter;
	CVssWriterPublisherFilter::CreatePublisherFilter(pControl, &pFilter);

	// set filter for event
	ft.hr = pControl->SetMultiInterfacePublisherFilter(pFilter);
	ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");

	// indicate that subscriptions should be fired in parallel
	ft.hr = pControl->put_FireInParallel(TRUE);
	ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::put_FireInParallel");
	}

// clear the publisher filter from an event
void ClearPublisherFilter(IVssWriter *pWriter)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"ClearPublisherFilter");

	try
		{
		CComPtr<IMultiInterfaceEventControl> pControl;

		// get event control interface
		ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
		if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
				ft.hr
				);	
				}
	
		// set filter for event
		ft.hr = pControl->SetMultiInterfacePublisherFilter(NULL);
		ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");
		}
	VSS_STANDARD_CATCH(ft)

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\prop\copy.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Copy.cxx | Implementation of VSS_OBJECT_PROP_Copy and VSS_OBJECT_PROP_Ptr classes
    @end

Author:

    Adi Oltean  [aoltean]  09/01/1999

Remarks:

	It cannot be put into a library because of ATL code.

Revision History:

    Name        Date        Comments
    aoltean     09/01/1999  Created
    aoltean     09/09/1999  dss -> vss
	aoltean		09/13/1999	Moved to inc. Renamed to copy.inl
	aoltean		09/20/1999	Adding methods for creating the snapshot, snapshot set,
							provider and volume property structures.
							Also VSS_OBJECT_PROP_Manager renamed to VSS_OBJECT_PROP_Manager.
	aoltean		09/21/1999	Renaming back VSS_OBJECT_PROP_Manager to VSS_OBJECT_PROP_Copy.
							Moving the CreateXXX into VSS_OBJECT_PROP_Ptr::InstantiateAsXXX
	aoltean		09/22/1999	Fixing VSSDBG_GEN.
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		12/16/1999	Adding specialized copyXXX methods

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes

#include "stdafx.hxx"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "copy.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPCOPYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Copy class


HRESULT VSS_OBJECT_PROP_Copy::copySnapshot(
			IN	VSS_SNAPSHOT_PROP* pObj1,
			IN	VSS_SNAPSHOT_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copySnapshot" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_SnapshotId = pObj2->m_SnapshotId;
        pObj1->m_SnapshotSetId = pObj2->m_SnapshotSetId;
        pObj1->m_lSnapshotsCount = pObj2->m_lSnapshotsCount;
		::VssSafeDuplicateStr( ft, pObj1->m_pwszSnapshotDeviceObject, pObj2->m_pwszSnapshotDeviceObject );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginalVolumeName, pObj2->m_pwszOriginalVolumeName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginatingMachine, pObj2->m_pwszOriginatingMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszServiceMachine, pObj2->m_pwszServiceMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedName, pObj2->m_pwszExposedName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedPath, pObj2->m_pwszExposedPath );
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        pObj1->m_lSnapshotAttributes = pObj2->m_lSnapshotAttributes;
        pObj1->m_tsCreationTimestamp = pObj2->m_tsCreationTimestamp;
        pObj1->m_eStatus = pObj2->m_eStatus;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copyProvider(
		IN	VSS_PROVIDER_PROP* pObj1,
		IN	VSS_PROVIDER_PROP* pObj2
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copyProvider" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderName, pObj2->m_pwszProviderName );
        pObj1->m_eProviderType = pObj2->m_eProviderType;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderVersion, pObj2->m_pwszProviderVersion );
        pObj1->m_ProviderVersionId = pObj2->m_ProviderVersionId;
        pObj1->m_ClassId = pObj2->m_ClassId;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copy(
		IN	VSS_OBJECT_PROP* pObj1,
		IN	VSS_OBJECT_PROP* pObj2
		)
{
	HRESULT hr;

    // Testing arguments
    if ((pObj1 == NULL) || (pObj2 == NULL))
        return E_INVALIDARG;

    // Zeroing the contents of the destination structure
    ::VssZeroOut(pObj1);

    // Copy the type
    pObj1->Type = pObj2->Type;

    // Effective copy
    switch(pObj2->Type)
    {
    case VSS_OBJECT_SNAPSHOT:
		hr = copySnapshot( &(pObj1->Obj.Snap), &(pObj2->Obj.Snap) );
        break;

    case VSS_OBJECT_PROVIDER:
		hr = copyProvider( &(pObj1->Obj.Prov), &(pObj2->Obj.Prov) );
        break;

    default:
		BS_ASSERT(false);
		hr = E_UNEXPECTED;
        break;
    }

    return hr;
}


void VSS_OBJECT_PROP_Copy::init(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::init" );

    try
    {
        // Zeroing the contents of the structure
        ::VssZeroOut(pObjectProp);
    }
    VSS_STANDARD_CATCH(ft)
}


void VSS_OBJECT_PROP_Copy::destroy(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::destroy" );

    try
    {
        if (pObjectProp)
        {
            switch(pObjectProp->Type)
            {
            case VSS_OBJECT_SNAPSHOT:
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginalVolumeName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszSnapshotDeviceObject);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginatingMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszServiceMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedPath);
                break;

            case VSS_OBJECT_PROVIDER:
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderName);
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderVersion);
                break;

            default:
                break;
            }
            pObjectProp->Type = VSS_OBJECT_UNKNOWN;
        }
    }
    VSS_STANDARD_CATCH(ft)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\prop\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\prop\pointer.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Pointer.cxx | Implementation of VSS_OBJECT_PROP_Ptr class
    @end

Author:

    Adi Oltean  [aoltean]  09/21/1999

Revision History:

    Name        Date        Comments

    aoltean     09/21/1999	VSS_OBJECT_PROP_Ptr as a pointer to the properties structure.
							This pointer will serve as element in CSimpleArray constructs.
	aoltean		09/22/1999	Adding InitializeAsEmpty and Print
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		03/27/2000	Adding Writers

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes


#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "copy.hxx"	
#include "pointer.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPPNTRC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Ptr class


void VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot(
    IN  CVssFunctionTracer& ft,
	IN  VSS_ID SnapshotId,
	IN  VSS_ID SnapshotSetId,
	IN  LONG lSnapshotsCount,
	IN  VSS_PWSZ pwszSnapshotDeviceObject,
	IN  VSS_PWSZ pwszOriginalVolumeName,
	IN  VSS_PWSZ pwszOriginatingMachine,
	IN  VSS_PWSZ pwszServiceMachine,
	IN  VSS_PWSZ pwszExposedName,
	IN  VSS_PWSZ pwszExposedPath,
	IN  VSS_ID ProviderId,
	IN  LONG lSnapshotAttributes,
	IN  VSS_TIMESTAMP tsCreationTimestamp,
	IN  VSS_SNAPSHOT_STATE eStatus
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_SNAPSHOT structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot";
	VSS_OBJECT_PROP* pProp = NULL;

    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_SNAPSHOT;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_SNAPSHOT_PROP& SnapshotProp = pProp->Obj.Snap;

		// Setting the internal members
		SnapshotProp.m_SnapshotId			= SnapshotId;
		SnapshotProp.m_SnapshotSetId		= SnapshotSetId;
		SnapshotProp.m_lSnapshotsCount      = lSnapshotsCount;
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszSnapshotDeviceObject, pwszSnapshotDeviceObject);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginalVolumeName, pwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginatingMachine, pwszOriginatingMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszServiceMachine, pwszServiceMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedName, pwszExposedName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedPath, pwszExposedPath);
		SnapshotProp.m_ProviderId			= ProviderId;
		SnapshotProp.m_lSnapshotAttributes	= lSnapshotAttributes;
		SnapshotProp.m_tsCreationTimestamp = tsCreationTimestamp;
		SnapshotProp.m_eStatus				= eStatus;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsProvider(
    IN  CVssFunctionTracer& ft,
    IN	VSS_ID ProviderId,
    IN	VSS_PWSZ pwszProviderName,
    IN  VSS_PROVIDER_TYPE eProviderType,
    IN	VSS_PWSZ pwszProviderVersion,
    IN	VSS_ID ProviderVersionId,
	IN	CLSID ClassId
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsProvider";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(pwszProviderName == NULL || pwszProviderName[0] != L'\0');
		BS_ASSERT(eProviderType == VSS_PROV_SYSTEM ||
            eProviderType == VSS_PROV_SOFTWARE ||
            eProviderType == VSS_PROV_HARDWARE
            );

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_PROVIDER;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_PROVIDER_PROP& ProviderProp = pProp->Obj.Prov;

		// Setting the internal members
		ProviderProp.m_ProviderId		 = ProviderId;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderName, pwszProviderName);
		ProviderProp.m_eProviderType	 = eProviderType;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderVersion, pwszProviderVersion);
		ProviderProp.m_ProviderVersionId = ProviderVersionId;
		ProviderProp.m_ClassId			 = ClassId;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsEmpty(
    IN  CVssFunctionTracer& ft
	)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to appear as an empty structure (to be filled later).

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeEmpty";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		BS_ASSERT(pProp == NULL);
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::Print(
    IN  CVssFunctionTracer& ft,
	IN  LPWSTR wszOutputBuffer,
	IN  LONG lBufferSize
	)
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::Print";

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		if (m_pStruct == NULL)
			::_snwprintf(wszOutputBuffer, lBufferSize, L"NULL object\n\n");

        // Effective copy
        switch(m_pStruct->Type)
        {
        case VSS_OBJECT_SNAPSHOT:

			::_snwprintf(wszOutputBuffer, lBufferSize,
				L"Id = " WSTR_GUID_FMT L", "
				L"SnapshotSetId = " WSTR_GUID_FMT L"\n"
				L"SnapCount = %ld "
				L"DevObj = %s\n"
				L"OriginalVolumeName = %s\n"
				L"OriginatingMachine = %s\n"
				L"ServiceMachine = %s\n"
				L"Exposed name = %s\n"
				L"Exposed path = %s\n"
				L"ProviderId = " WSTR_GUID_FMT L"\n"
				L"Attributes = 0x%08lx\n"
				L"Timestamp = " WSTR_LONGLONG_FMT L"\n"
				L"Status = %d\n ",
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotId ),
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotSetId ),
				m_pStruct->Obj.Snap.m_lSnapshotsCount,
				m_pStruct->Obj.Snap.m_pwszSnapshotDeviceObject,
				m_pStruct->Obj.Snap.m_pwszOriginalVolumeName,
				m_pStruct->Obj.Snap.m_pwszOriginatingMachine,
				m_pStruct->Obj.Snap.m_pwszServiceMachine,
				m_pStruct->Obj.Snap.m_pwszExposedName,
				m_pStruct->Obj.Snap.m_pwszExposedPath,
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_ProviderId ),
				m_pStruct->Obj.Snap.m_lSnapshotAttributes,
				LONGLONG_PRINTF_ARG( m_pStruct->Obj.Snap.m_tsCreationTimestamp ),
				m_pStruct->Obj.Snap.m_eStatus);
            break;

        case VSS_OBJECT_PROVIDER:
            ::_snwprintf(wszOutputBuffer, lBufferSize,
				L"m_ProviderId = " WSTR_GUID_FMT L"\n"
				L"m_pwszProviderName = %s\n"
				L"m_ProviderType = %d\n"
				L"m_pwszProviderVersion = %s\n"
				L"m_ProviderVersionId = " WSTR_GUID_FMT L"\n"
				L"m_ClassID: " WSTR_GUID_FMT L"\n\n",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderId ),
                m_pStruct->Obj.Prov.m_pwszProviderName? m_pStruct->Obj.Prov.m_pwszProviderName: L"NULL",
                m_pStruct->Obj.Prov.m_eProviderType,
                m_pStruct->Obj.Prov.m_pwszProviderVersion? m_pStruct->Obj.Prov.m_pwszProviderVersion: L"NULL",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderVersionId ),
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ClassId )
                );
            break;

        default:
			ft.ErrBox( VSSDBG_GEN, E_UNEXPECTED,
					   L"%s: Wrong object type %d", wszFunctionName, m_pStruct->Type );
            break;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
		BS_ASSERT(m_pStruct == NULL);
		ft.Throw( VSSDBG_GEN, E_UNEXPECTED,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\sec\security.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module security.cxx | Implementation of IsAdministrator
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     08/26/1999  Adding RegisterProvider
    aoltean     08/26/1999  Adding UnregisterProvider
    aoltean     08/27/1999  Adding IsAdministrator,
                            Adding unique provider name test.
    aoltean     08/30/1999  Calling OnUnregister on un-registering
                            Improving IsProviderNameAlreadyUsed.
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding new headers
	aoltean		10/15/1999  Moving declaration in security.hxx
	aoltean		01/18/2000	Moved into a separate directory
	brianb		04/04/2000	Add IsBackupOperator
	brianb		04/27/2000  Change IsBackupOperator to check SE_BACKUP_NAME privilege
	brianb		05/03/2000	Added GetClientTokenOwner method
	brianb		05/10/2000  fix problem with uninitialized variable
	brianb		05/12/2000	handle in proc case for impersonation failures

--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"

#include "vs_inc.hxx"

#include "vs_sec.hxx"

#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SECSECRC"
//
////////////////////////////////////////////////////////////////////////

BOOL DoImpersonate
	(
	BOOL bImpersonate,
	HANDLE *phToken
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"DoImpersonate");
	if (bImpersonate)
		{
		//  Impersonate the client to get its identity access token.
		//  The client should not have RPC_C_IMP_LEVEL_ANONYMOUS otherwise an error will be returned
		ft.hr = ::CoImpersonateClient();
		if (ft.hr == RPC_E_CALL_COMPLETE)
			{
			// this means that the call came from the same thread
			// do not do impersonation.  Just use the process
			// token
			bImpersonate = false;
			ft.hr = S_OK;
			}
		else
			{
			BOOL bRes;

			ft.CheckForError(VSSDBG_GEN, L"CoImpersonateClient");

			//  Get the Access Token of the client calling process in order to establish the client identity
			CVssAutoWin32Handle  hThread = ::GetCurrentThread(); // CloseHandle have no effect here

			bRes = ::OpenThreadToken
					(
					hThread,        //  IN HANDLE ThreadHandle,
					TOKEN_QUERY,    //  IN DWORD DesiredAccess,
					TRUE,           //  IN BOOL OpenAsSelf      (TRUE means not the client calling thread's access token)
					phToken         //  OUT PHANDLE TokenHandle
					);

			DWORD dwErr = GetLastError();

			// Revert the thread's access token - finish the impersonation
			ft.hr = ::CoRevertToSelf();
			ft.CheckForError(VSSDBG_GEN, L"CoRevertToSelf");

			if (!bRes)
				ft.TranslateError
					(
					VSSDBG_GEN,
					HRESULT_FROM_WIN32(dwErr),
					L"OpenThreadToken"
					);
			}
		}

	// note that the previous if statement may change the value
	// of bImpersonate.  This is why we can't just put this in an
	// else clause
	if (!bImpersonate)
		{
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,phToken))
			ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"OpenProcessToken"
				);
        }

	return bImpersonate;
	}




bool IsInGroup(DWORD dwGroup, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"IsInGroup" );

    BOOL bIsInGroup = FALSE;
    PSID psidGroup = NULL;
	BOOL bRes;

	// Reset the error code
	ft.hr = S_OK;

	//  Build the SID for the Administrators group
	SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
	bRes = AllocateAndInitializeSid
			(
            &SidAuth,                       //  IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
            2,                              //  IN BYTE nSubAuthorityCount,
			SECURITY_BUILTIN_DOMAIN_RID,	//  IN DWORD nSubAuthority0,
            dwGroup,  						//  IN DWORD nSubAuthority1,
            0,                              //  IN DWORD nSubAuthority2,
            0,                              //  IN DWORD nSubAuthority3,
            0,                              //  IN DWORD nSubAuthority4,
            0,                              //  IN DWORD nSubAuthority5,
            0,                              //  IN DWORD nSubAuthority6,
            0,                              //  IN DWORD nSubAuthority7,
            &psidGroup                      //  OUT PSID *pSid
            );

	if (!bRes)
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"AllocateAndInitializeSid"
			);

    try
		{

		if (!bImpersonate)
			bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
		else
			{
			CVssAutoWin32Handle  hToken;

			// impersonate client (or get process token)
			if (DoImpersonate(true, hToken.ResetAndGetAddress()))
				// check token membership
				bRes = CheckTokenMembership(hToken, psidGroup, &bIsInGroup);
            else
				// called from same thread
				bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
			}

		if (!bRes)
            ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"CheckTokenMembership"
				);

		}
    VSS_STANDARD_CATCH(ft)

	HRESULT hr = ft.hr;

    // Catch possible AVs
    try
		{
        //  Free the previously allocated SID
        if (psidGroup)
            ::FreeSid( psidGroup );
		}
    VSS_STANDARD_CATCH(ft)

    // Pass down the exception, if any
    if (FAILED(hr))
        throw(hr);

    return bIsInGroup ? true : false;
	}

bool HasPrivilege(LPWSTR wszPriv, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process has a specific privilege

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"HasPrivilege" );

	BOOL bHasPrivilege = false;
	CVssAutoWin32Handle  hToken;

	LUID TokenValue;
	if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"LookupPrivilegeValue"
			);

    DoImpersonate(bImpersonate, hToken.ResetAndGetAddress());

	BYTE rgb[sizeof(LUID_AND_ATTRIBUTES) + sizeof(PRIVILEGE_SET)];
	PRIVILEGE_SET *pSet = (PRIVILEGE_SET *) rgb;

	pSet->PrivilegeCount = 1;
	pSet->Control = PRIVILEGE_SET_ALL_NECESSARY;
	pSet->Privilege[0].Luid = TokenValue;
	pSet->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
	
	if (!PrivilegeCheck(hToken, pSet, &bHasPrivilege))
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"PrivilegeCheck"
			);

    return bHasPrivilege ? true : false;
	}


TOKEN_OWNER *GetClientTokenOwner(BOOL bImpersonate)

/*++

Routine Description:

    Return TOKEN_OWNER of client process

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we return the client sid of that token

Return Value:

	SID of client thread

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"GetClientTokenOwner" );

	BOOL bRes;

    CVssAutoWin32Handle  hToken;

	DoImpersonate(bImpersonate, hToken.ResetAndGetAddress());

    DWORD cbSid;
    bRes = ::GetTokenInformation
			(
            hToken,         //  IN HANDLE TokenHandle,
            TokenOwner,  //  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
            NULL,           //  OUT LPVOID TokenInformation,
            0,              //  IN DWORD TokenInformationLength,
            &cbSid     		//  OUT PDWORD ReturnLength
            );

	BS_ASSERT( bRes == FALSE );

    DWORD dwError = GetLastError();
    if ( dwError != ERROR_INSUFFICIENT_BUFFER )
		{
		ft.LogError(VSS_ERROR_EXPECTED_INSUFFICENT_BUFFER, VSSDBG_GEN << (HRESULT) dwError);
        ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"ERROR_INSUFFICIENT_BUFFER expected error . [0x%08lx]",
			dwError
			);
        }

    //  Allocate the buffer needed to get the Token Groups information
	TOKEN_OWNER *pToken = (TOKEN_OWNER*) new BYTE[cbSid];
    if (pToken == NULL)
		ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error.");

	//  Get the all Group SIDs in the token
	DWORD cbTokenObtained;
	bRes = ::GetTokenInformation
		(
		hToken,             //  IN HANDLE TokenHandle,
		TokenOwner,        	//  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
		pToken,            	//  OUT LPVOID TokenInformation,
		cbSid,         		//  IN DWORD TokenInformationLength,
		&cbTokenObtained 	//  OUT PDWORD ReturnLength
		);

	if ( !bRes )
        ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
            L"GetTokenInformation"
			);

    if (cbTokenObtained != cbSid)
		{
		ft.LogError(VSS_ERROR_GET_TOKEN_INFORMATION_BUFFER_SIZE_MISMATCH, VSSDBG_GEN << (INT) cbTokenObtained << (INT) cbSid);
		ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"Unexpected error. Final buffer size = %lu, original size was %lu",
			cbTokenObtained,
			cbSid
			);
        }

    return pToken;
	}



bool IsAdministrator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, true);
	}

bool IsProcessAdministrator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of an administrator

Arguments:

    none

Remarks:
    The current process is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the process is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, false);
	}



bool IsBackupOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a backup operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the groups token
	or the backup privilege is enabled

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_BACKUP_NAME, true) || IsAdministrator();
	}

bool IsRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a restore operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the token groups or
	if the restore privilege is enabled.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_RESTORE_NAME, true) || IsAdministrator();
	}


bool IsProcessBackupOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a backup operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator or
	has SE_BACKUP_NAME privilege enabled
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_BACKUP_NAME, false) || IsProcessAdministrator();
	}

bool IsProcessRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a restore operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator
	or has the SE_RESTORE_NAME privilege; false otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_RESTORE_NAME, false) || IsProcessAdministrator();
	}



// turn on a particular security privilege
HRESULT TurnOnSecurityPrivilege(LPCWSTR wszPriv)

/*++

Routine Description:

    sets the specified privilege on the process token

Arguments:

    none

Remarks:

Return Value:
	status code for operation

Thrown exceptions:
	none
--*/

    {
	HANDLE	hProcessToken = INVALID_HANDLE_VALUE;
	BOOL	bProcessTokenValid = FALSE;

	CVssFunctionTracer ft(VSSDBG_GEN, L"TurnOnSecurityPrivilege");
	try
		{
		LUID	TokenValue = {0, 0};


		bProcessTokenValid = OpenProcessToken
								(
								GetCurrentProcess(),
								TOKEN_ADJUST_PRIVILEGES,
								&hProcessToken
								);

		if (!bProcessTokenValid)
			ft.TranslateError
				(
				VSSDBG_GEN,
                HRESULT_FROM_WIN32(GetLastError()),
				L"OpenProcessToken"
				);

				
		if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
			ft.TranslateError
				(
				VSSDBG_GEN,
                HRESULT_FROM_WIN32(GetLastError()),
				L"LookupPrivilegeValue"
				);

		TOKEN_PRIVILEGES	NewTokenPrivileges;

		NewTokenPrivileges.PrivilegeCount           = 1;
		NewTokenPrivileges.Privileges[0].Luid       = TokenValue;
		NewTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		// AdjustTokenPrivileges succeeds even the token isn't set
		SetLastError(ERROR_SUCCESS);

		AdjustTokenPrivileges
			(	
			hProcessToken,
			FALSE,
			&NewTokenPrivileges,
			sizeof (NewTokenPrivileges),
			NULL,
			NULL
			);


        DWORD dwErr = GetLastError();
		if (dwErr != ERROR_SUCCESS)
			ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"AdjustTokenPrivileges"
				);
		}
	VSS_STANDARD_CATCH(ft)

	if (bProcessTokenValid)
		CloseHandle (hProcessToken);

    return ft.hr;
    }

// turn on backup security privilege
HRESULT TurnOnSecurityPrivilegeBackup()
	{
	return TurnOnSecurityPrivilege(SE_BACKUP_NAME);
	}

// turn on restore security privilege
HRESULT TurnOnSecurityPrivilegeRestore()
	{
	return TurnOnSecurityPrivilege(SE_RESTORE_NAME);
	}



// determine if the process is a local service
bool IsProcessLocalService()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"IsProcessLocalService");

	BYTE rgbSid[256];
	DWORD cbSid = sizeof(rgbSid);
	TOKEN_OWNER *pOwner = GetClientTokenOwner(FALSE);

	if (!CreateWellKnownSid(WinLocalServiceSid, NULL, (SID *) rgbSid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSid");
		}

	return EqualSid(pOwner->Owner, (SID *) rgbSid) ? true : false;
	}

// determine if the process is a local service
bool IsProcessNetworkService()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"IsProcessNetworkService");

	BYTE rgbSid[256];
	TOKEN_OWNER *pOwner = GetClientTokenOwner(FALSE);
	DWORD cbSid = sizeof(rgbSid);

	if (!CreateWellKnownSid(WinNetworkServiceSid, NULL, (SID *) rgbSid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSid");
		}

	return EqualSid(pOwner->Owner, (SID *) rgbSid) ? true : false;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\sec\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\softprv\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.cxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   02/01/2000

Revision History:

    Name        Date        Comments

    aoltean     02/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"


#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDELEC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsSoftwareProvider::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots that match the proper filter criteria.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then S_OK is returned.

Throws:

    E_ACCESSDENIED
        - The user is not an administrator (this should be the SYSTEM account).
    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::DeleteSnapshots" );

    try
    {
    	// Zero out parameters
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

		// Check arguments
		BS_ASSERT(plDeletedSnapshots);
		if (plDeletedSnapshots == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plDeletedSnapshots == NULL");
		BS_ASSERT(pNondeletedSnapshotID);
		if (pNondeletedSnapshotID == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pNondeletedSnapshotID == NULL");

		// Delete snapshots based on the given filter
        switch(eSourceObjectType) {
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
    		ft.hr = InternalDeleteSnapshots(SourceObjectId,
    					eSourceObjectType,
    					plDeletedSnapshots,
    					pNondeletedSnapshotID);
			break;
			
		default:
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Incompatible type %d", eSourceObjectType);
		}
		
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods


HRESULT CVsSoftwareProvider::InternalDeleteSnapshots(
    IN      VSS_ID			SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots in the snapshot set.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::InternalDeleteSnapshotSet" );
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

    try
    {
		BS_ASSERT(*plDeletedSnapshots == 0);
		BS_ASSERT(*pNondeletedSnapshotID == GUID_NULL);

		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
		CVssIOCTLChannel volumeIChannel2;	// For snapshots deletion
		CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes
		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
		bool bObjectFound = false;

		// Search for snapshots in all mounted volumes
		while(true) {
		
			// Get the volume name
			if (bFirstVolume) {
				hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
				if (hSearch == INVALID_HANDLE_VALUE)
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
        				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
        				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
        				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
				}
			}

			// Check if the snapshot(s) within this snapshot set is belonging to that volume
			// Open a IOCTL channel on that volume
			// Eliminate the last backslash in order to open the volume
			// The call will throw on error
			ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE);
			if (ft.HrFailed()) {
			    ft.hr = S_OK;
			    continue;
			}

			// Get the list of snapshots
			// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
			// supported then try with the next volume.

			ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}

			// Get the length of snapshot names multistring
			ULONG ulMultiszLen;
			volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
			// Try to find the snapshot with the corresponding Id
			DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif
            bool bFirstSnapshot = true;
			while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {

                // In this version we will have only one snapshot per volume
			    if (!bFirstSnapshot) {
    			    BS_ASSERT(false);
    			    break;
			    } else {
    			    bFirstSnapshot = false;
			    }
			    
				// Compose the snapshot name in a user-mode style
				WCHAR wszUserModeSnapshotName[MAX_PATH];
                ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                    wszGlobalRootPrefix, pwszSnapshotName );
					
				// Open that snapshot and verify if it has our ID
                // If we fail we do not throw since the snapshot may be deleted in the meantime
                // Do NOT eliminate the trailing backslash
                // The call will NOT throw on error
				ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false);
                if (ft.HrFailed()) {
                    ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
                    continue;
                }

				// Get the application buffer
                // If we fail we do not throw since the snapshot may be deleted in the meantime
				ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
                if (ft.HrFailed()) {
                    ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be queried for properties",
                              wszUserModeSnapshotName);
                    continue;
                }

				// Get the length of the application buffer
				ULONG ulLen;
				snapshotIChannel.Unpack(ft, &ulLen);

				if (ulLen == 0) {
					ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
            	    BS_ASSERT(false);
					continue;
				}

                // Unpacking the app info ID
            	VSS_ID AppinfoId;
            	snapshotIChannel.Unpack(ft, &AppinfoId);
            	if (AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
            	{
            	    BS_ASSERT(false);
					continue;
                }
            	
				// Get the snapshot Id
				VSS_ID CurrentSnapshotId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

				// Get the snapshot set Id
				VSS_ID CurrentSnapshotSetId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

                switch(eSourceObjectType) {
        		case VSS_OBJECT_SNAPSHOT_SET:
    				// Check if this snapshot belongs to the snapshot set.
    				if (CurrentSnapshotSetId != SourceObjectId) 
    					continue;
    				break;

        		case VSS_OBJECT_SNAPSHOT:
    				if (CurrentSnapshotId != SourceObjectId)
    					continue;
        			break;
        			
        		default:
        			BS_ASSERT(false);
        			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Incompatible type %d", eSourceObjectType);
        		}

				// We found a snapshot belonging to the set.
				bObjectFound = true;

				// Set in order to deal with failure cases
				(*pNondeletedSnapshotID) = CurrentSnapshotId;
				
				// We found a snapshot. 
				volumeIChannel2.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);

				// Delete the snapshot
				volumeIChannel2.Call(ft, IOCTL_VOLSNAP_DELETE_OLDEST_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
				
				(*plDeletedSnapshots)++;
			}

#ifdef _DEBUG
			// Check if all strings were browsed correctly
			DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
			BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
		}

		if (!bObjectFound)
			ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Object not found");
    }
    VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	// Delete the temporary snapshot name
	::VssFreeString(pwszSnapshotName);

	if (ft.HrSucceeded())
		(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\softprv\src\persist.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Persist.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


Storage Format for all structures:

	The snapshot structures for the MS Software Snapshot Provider
	have the following format:

	+-----------------+
	|  AppInfo GUID   |   GUID: VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshot ID     |   GUID: Snapshot ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshot Set ID |   GUID: Snapshot Set ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshots count |   LONG: Snapshots count in the snapshot set.
	+-----------------+


Storage place:

	typedef struct _VSS_SNAPSHOT_PROP {
		VSS_ID			m_SnapshotId;						//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	We need a special IOCTL in the future
		VSS_ID			m_SnapshotSetId;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	Mentioned above
		LONG			m_lSnapshotsCount;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		VSS_PWSZ		m_pwszSnapshotDeviceObject; 		//	None						IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS	None
		VSS_PWSZ		m_pwszOriginalVolumeName;			//	LoadOriginalVolumeNameIoctl	IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME None									
		VSS_ID			m_ProviderId;						//	None																None 									Always the Software Provider ID
		LONG            m_lSnapshotAttributes;              //  None                                                                                                        Always zero
		VSS_TIMESTAMP	m_tsCreationTimestamp;				//	LoadTimestampIoctl		    None (driver)		                    IOCTL_VOLSNAP_QUERY_CONFIG_INFO
		VSS_SNAPSHOT_STATE	m_eStatus;						//	None.                                                                                                       Always VSS_SS_CREATED after creation
	} VSS_SNAPSHOT_PROP, *PVSS_SNAPSHOT_PROP;				

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPERSC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::SaveSnapshotPropertiesIoctl() throw(HRESULT)

/*++

Description:

	This function will save the properties related to the snapshot

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SaveSnapshotPropertiesIoctl");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Open the snapshot channel, if needed.
	// It will log on error.
	OpenSnapshotChannel();

	// Pack the snapshot structure
	SaveStructure(m_snapIChannel, pProp);

	// send the IOCTL
	// It will log on error...
	m_snapIChannel.Call(ft, IOCTL_VOLSNAP_SET_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssQueuedSnapshot::SaveStructure(
    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp
    ) throw(HRESULT)

/*++

Description:

	This function will save the properties related to the snapshot in the given IOCTL channel

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SaveStructure");

    BS_ASSERT(pProp);
    BS_ASSERT(channel.IsOpen());

	// Pack the length of the entire buffer
	PVOID pulBufferLength = channel.Pack(ft, (ULONG)0 ); // unknown right now
	
	// Start counting entire buffer length
	DWORD dwInitialOffset = channel.GetCurrentInputOffset();
	
	// Pack the AppInfo ID
	VSS_ID AppinfoId = VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU;
	channel.Pack(ft, AppinfoId);
	
	// Pack the Snapshot ID
	channel.Pack(ft, pProp->m_SnapshotId);
	
	// Pack the Snapshot Set ID
	channel.Pack(ft, pProp->m_SnapshotSetId);
	
	// Pack the number of snapshots in this snapshot set
	channel.Pack(ft, pProp->m_lSnapshotsCount);

	// Compute the entire buffer length and save it.
	// TBD: move to ULONG
	DWORD dwFinalOffset = channel.GetCurrentInputOffset();
	
	BS_ASSERT( dwFinalOffset > dwInitialOffset );
	DWORD dwBufferLength = dwFinalOffset - dwInitialOffset;
	if ( dwBufferLength > (DWORD)((USHORT)(-1)) )
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
				L"Error: the buffer length cannot be stored in a USHORT %ld", dwBufferLength );
				
	ULONG ulBufferLength = (ULONG)dwBufferLength;
	BS_ASSERT( pulBufferLength );
	::CopyMemory(pulBufferLength, &ulBufferLength, sizeof(ULONG));
	BS_ASSERT( (DWORD)ulBufferLength == dwBufferLength );
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::LoadXXX methods
//



void CVssQueuedSnapshot::LoadSnapshotProperties() throw(HRESULT)

/*++

Description:

	This method loads various properties of a snapshot.
	It can call:
		- LoadDeviceNameFromID to load the device name
		- Load the properties kept in the Application data
		- LoadOriginalVolumeIoctl for getting the original volume name

	If bGetOnly == true then this method was called in a Get call.
	Otherwise it was called in a Set call.

Throws:

    E_OUTOFMEMORY
    VSS_E_OBJECT_NOT_FOUND
        - The snapshot with this ID was not found.

    [FindPersistedSnapshotByID() failures]
        E_OUTOFMEMORY

        [EnumerateSnapshots() failures]
            VSS_E_PROVIDER_VETO
                - On runtime errors (like Unpack)
            E_OUTOFMEMORY  

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadSnapshotProperties");
		
	// Get the snapshot properties structure
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Assume that the Snapshot is completed
	BS_ASSERT(!IsDuringCreation());
	BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);
	
	// If the device name is not completed, search for it
	if (pProp->m_pwszSnapshotDeviceObject == NULL)
	{
		// Try to find a created snapshot with this ID
    	BS_ASSERT(!IsDuringCreation());
		bool bFound = CVssQueuedSnapshot::FindPersistedSnapshotByID(
		    pProp->m_SnapshotId, 
		    &(pProp->m_pwszSnapshotDeviceObject)
		    );

		// Handle the "snapshot not found" special error
		if (!bFound)
			ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
					L"A snapshot with Id" WSTR_GUID_FMT L"was not found",
					GUID_PRINTF_ARG(pProp->m_SnapshotId) );
		BS_ASSERT(pProp->m_pwszSnapshotDeviceObject != NULL);
	}

	// Load the needed fields saved in snapshot header and standard structure
	// Open the snapshot channel, if needed.
	OpenSnapshotChannel();

	// send the IOCTL.
	m_snapIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);

	// Unpack the snapshot structure
	LoadStructure(m_snapIChannel, pProp);

	// Get the original volume name
	CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
	    m_snapIChannel, 
	    &(pProp->m_pwszOriginalVolumeName));

	// Get the timestamp
	CVssQueuedSnapshot::LoadTimestampIoctl(
	    m_snapIChannel, 
	    &(pProp->m_tsCreationTimestamp));
}


void CVssQueuedSnapshot::LoadStructure(
    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp,
	IN  bool bIDsAlreadyLoaded /* = false */
    ) throw(HRESULT)

/*++

Description:

	This function will load the properties related to the snapshot from the given IOCTL channel

Arguments:

    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp,
	IN  bool bIDsAlreadyLoaded = false  // If true, do not load the buffer length and the IDs

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadStructure");

	ULONG ulBufferLength = 0;
    DWORD dwInitialOffset = 0;

    // Set the properties that have a constant value.
    pProp->m_eStatus = VSS_SS_CREATED;

    // if IDs not loaded yet
    if (!bIDsAlreadyLoaded) {
    	// Unpack the length of the entire buffer
    	channel.Unpack(ft, &ulBufferLength );
    	
    	// Start counting entire buffer length, for checking
    	dwInitialOffset = channel.GetCurrentOutputOffset();
    	
    	// Unpack the Appinfo ID
    	VSS_ID AppinfoId;
    	channel.Unpack(ft, &AppinfoId);
    	if (AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
    	{
    	    BS_ASSERT(false);
    	    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown app info " WSTR_GUID_FMT, GUID_PRINTF_ARG(AppinfoId));
    	}
    	
    	// Unpack the Snapshot ID
    	channel.Unpack(ft, &(pProp->m_SnapshotId));
    	
    	// Unpack the Snapshot Set ID
    	channel.Unpack(ft, &(pProp->m_SnapshotSetId));
    }

    // Unpack the snapshots count
    channel.Unpack(ft, &(pProp->m_lSnapshotsCount) );

    if (bIDsAlreadyLoaded == false) {
		// Compute the entire buffer length and check it.
#ifdef _DEBUG
		DWORD dwFinalOffset = channel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset > dwInitialOffset );
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulBufferLength );
#endif
    }
}



void CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
    IN  CVssIOCTLChannel & snapshotIChannel,
    OUT LPWSTR * ppwszOriginalVolumeName
    ) throw(HRESULT)

/*++

Description:

	Load the original volume name and ID.
	Uses IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures (like OpenSnapshotChannel, GetVolumeNameForVolumeMountPointW)
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");
	LPCWSTR pwszDeviceVolumeName = NULL;

	try
	{
	    BS_ASSERT(ppwszOriginalVolumeName);
	    
    	// send the IOCTL.
    	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME, 
    	    true, VSS_ICHANNEL_LOG_PROV);

    	// Load the Original volume name
    	snapshotIChannel.UnpackSmallString(ft, pwszDeviceVolumeName);

    	// Get the user-mode style device name
    	WCHAR wszVolNameUsermode[MAX_PATH];
    	if (::_snwprintf(wszVolNameUsermode, MAX_PATH - 1,
    			L"%s%s\\", wszGlobalRootPrefix, pwszDeviceVolumeName) < 0)
    		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory" );

    	// Get the mount point for the original volume
    	WCHAR wszMPMVolumeName[MAX_PATH];
    	BOOL bSucceeded = ::GetVolumeNameForVolumeMountPointW(
    							wszVolNameUsermode,
    							wszMPMVolumeName, MAX_PATH );			
    	if (!bSucceeded)
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszVolNameUsermode);

        ::VssFreeString(*ppwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, *ppwszOriginalVolumeName, wszMPMVolumeName);
    }
	VSS_STANDARD_CATCH(ft)

	::VssFreeString(pwszDeviceVolumeName);

	if (ft.HrFailed())
	    ft.Throw( VSSDBG_SWPRV, ft.hr, L"Exception detected");
}


void CVssQueuedSnapshot::LoadTimestampIoctl(
    IN  CVssIOCTLChannel &  snapshotIChannel,
    OUT VSS_TIMESTAMP    *  pTimestamp
    ) throw(HRESULT)

/*++

Description:

	Load the timestamp
	Uses IOCTL_VOLSNAP_QUERY_CONFIG_INFO.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");

    BS_ASSERT(pTimestamp);
    
	// send the IOCTL.
	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, 
	    true, VSS_ICHANNEL_LOG_PROV);

	// Load the attributes
	ULONG ulAttributes = 0;
	snapshotIChannel.Unpack(ft, &ulAttributes);

	// Load the reserved field
	ULONG ulReserved = 0;
	snapshotIChannel.Unpack(ft, &ulReserved);

	// Load the timestamp
	BS_ASSERT(sizeof(LARGE_INTEGER) == sizeof(*pTimestamp));
	snapshotIChannel.Unpack(ft, pTimestamp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\softprv\src\alloc.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Alloc.cxx | Automatic allocation of diff areas
    @end

Author:

    Adi Oltean  [aoltean]   06/01/2000

Revision History:

    Name        Date        Comments

    aoltean     06/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"
#include "vssmsg.h"

//  Generated MIDL headers
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRALLOC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Constants

const WCHAR wszFileSystemNameNTFS[] = L"NTFS";

// The minimum free space for a diff area
const nRemainingFreeSpace = 20 * 1024 * 1024;


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator constructors/destructors


CVssDiffAreaAllocator::CVssDiffAreaAllocator(
    IN  VSS_ID SnapshotSetID
    ):
    m_bChangesCommitted(false),
    m_bNoChangesNeeded(false),
    m_SnapshotSetID(SnapshotSetID)
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::CVssDiffAreaAllocator");

    BS_ASSERT(SnapshotSetID != GUID_NULL);
}


CVssDiffAreaAllocator::~CVssDiffAreaAllocator()
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::~CVssDiffAreaAllocator");
    int nIndex;

    // The Rollback function should not throw.
    if (!m_bChangesCommitted && !m_bNoChangesNeeded)
        Rollback();

    // Deallocate all the volume names
    for (nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++)
        ::VssFreeString(m_arrOriginalVolumes[nIndex]);

    // Deallocate all the diff area candidates
    // This will delete the associated volume names also (which are the keys)
    for (nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++)
	    delete m_mapDiffAreaCandidates.GetValueAt(nIndex);
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Public operations

void CVssDiffAreaAllocator::AssignDiffAreas() throw(HRESULT)
/*++

Routine description:

    Assign all the diff areas for the current snapshot set.

Throws:

    VSS_E_PROVIDER_VETO
    E_UNEXPECTED

    [CVssDiffAreaAllocator::Initialize() failures]
        E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignDiffAreas");


    // Fill out various internal structures (like the list of original volumes)
    Initialize();

    // If no volumes to snapshot then we are done.
    if (m_arrOriginalVolumes.GetSize() == 0)
        return;

    // Find the candidates for the diff areas
    FindDiffAreaCandidates();

    // Deal with no candidates scenario... 
    // If no candidates then we will stop here and inform the user to add more NTFS disk space.
    if (m_mapDiffAreaCandidates.GetSize() == 0) {
        ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
        ft.Throw( VSSDBG_SWPRV, VSS_E_PROVIDER_VETO, L"Cannot find a diff area candidate");
    }

    // Clear the non-necessary diff areas and compute the number of allocated
    // diff areas that already exist on each candidate
    ComputeExistingDiffAreasCount();

    // planning of new diff areas
    PlanNewDiffAreas();

    // effectively allocate the diff areas for the voluems to be snapshotted
    AssignPlannedDiffAreas();
}


void CVssDiffAreaAllocator::Commit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Commit");

    m_bChangesCommitted = true;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Private operations


void CVssDiffAreaAllocator::Initialize() throw(HRESULT)
/*++

Routine description:

    Initialize the internal data structures

Throws:

    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Initialize");

    // Get the list of volumes to be snapshotted
    BS_ASSERT(m_arrOriginalVolumes.GetSize() == 0);
	CVssSnapIterator snapIterator;
    while (true)
    {
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(m_SnapshotSetID);

		// End of enumeration?
		if (ptrQueuedSnapshot == NULL)
			break;

		// Get the snapshot structure
		PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
		BS_ASSERT(pProp != NULL);

        // Ignore the snapshots that are not in the PREPARING state.
        if (ptrQueuedSnapshot->GetStatus() == VSS_SS_PREPARING) {
            // Make a copy of the volume name 
            BS_ASSERT(pProp->m_pwszOriginalVolumeName && pProp->m_pwszOriginalVolumeName[0]);
            LPWSTR wszOriginalVolumeName = NULL;
            ::VssSafeDuplicateStr( ft, wszOriginalVolumeName, pProp->m_pwszOriginalVolumeName );
            BS_ASSERT(wszOriginalVolumeName);

            if (!m_arrOriginalVolumes.Add(wszOriginalVolumeName)) {
                ::VssFreeString(wszOriginalVolumeName);
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
            }
        }
    }

    // If there are no volumes to process then make this explicit
    if (m_arrOriginalVolumes.GetSize() == 0) {
        m_bNoChangesNeeded = true;
        return;
    }
}


void CVssDiffAreaAllocator::FindDiffAreaCandidates() throw(HRESULT)
/*++

Routine description:

    Find the candidates for the diff areas
    Compute various parameters like the number of allocated diff areas on each candidate

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO
        - FindFirstVolume, FindNextVolume errors

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::FindDiffAreaCandidates");

	// Search between all mounted volumes
	bool bFirstVolume = true;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
	WCHAR wszVolumeName[MAX_PATH+1];
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
			}
		}

        BS_ASSERT( wszVolumeName[0] );

        // Check if the volume is NTFS
        // This is likely to fail, for example on CD-ROM drives
        DWORD dwFileSystemFlags = 0;
        WCHAR wszFileSystemNameBuffer[MAX_PATH+1];
        if (!::GetVolumeInformationW(wszVolumeName,
                NULL,   // lpVolumeNameBuffer
                0,      // nVolumeNameSize
                NULL,   // lpVolumeSerialNumber
                NULL,   // lpMaximumComponentLength
                &dwFileSystemFlags,
                wszFileSystemNameBuffer,
                MAX_PATH
                )) {
            ft.Trace( VSSDBG_SWPRV,
                      L"Warning: Error calling GetVolumeInformation on volume '%s' 0x%08lx",
                      wszVolumeName, GetLastError());
            continue;
        }

        // If the file system is not NTFS, ignore it
        if (::wcscmp(wszFileSystemNameBuffer, wszFileSystemNameNTFS) != 0) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a non-NTFS volume (%s) - %s",
                      wszVolumeName, wszFileSystemNameBuffer);
            continue;
        }

        // If the volume is read-only, ignore it
        if (dwFileSystemFlags & FILE_READ_ONLY_VOLUME) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a read-only volume (%s)", wszVolumeName);
            continue;
        }

        // Check if the volume is fixed (i.e. no CD-ROM, no removable)
        UINT uDriveType = ::GetDriveTypeW(wszVolumeName);
        if ( uDriveType != DRIVE_FIXED) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a non-fixed volume (%s) - %ud",
                      wszVolumeName, uDriveType);
            continue;
        }

        // Get its free space
        ULARGE_INTEGER ulnFreeBytesAvailable;
        ULARGE_INTEGER ulnTotalNumberOfBytes;
        ULARGE_INTEGER ulnTotalNumberOfFreeBytes;
        if (!::GetDiskFreeSpaceEx(wszVolumeName,
                &ulnFreeBytesAvailable,
                &ulnTotalNumberOfBytes,
                &ulnTotalNumberOfFreeBytes
                )){
            ft.Trace( VSSDBG_SWPRV, L"Cannot get the free space for volume (%s) - [0x%08lx]",
                      wszVolumeName, GetLastError());
            continue;
        }

        // Check to see if the free space is enough for at least one diff area
        if (ulnTotalNumberOfFreeBytes.QuadPart <
                (ULONGLONG)(nRemainingFreeSpace + nDefaultInitialSnapshotAllocation)) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a volume (%s) with "
                      L"insufficient free space for one allocation (%I64u)",
                      wszVolumeName, ulnFreeBytesAvailable);
            continue;
        }

        // Add the local volume as a candidate
        LPWSTR wszCandidate = NULL;
        ::VssSafeDuplicateStr(ft, wszCandidate, wszVolumeName);

        // Create the candidate object that must keep this information.
        CVssDiffAreaCandidate* pObj =
            new CVssDiffAreaCandidate(wszCandidate, ulnFreeBytesAvailable);
        if (pObj == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

        // Add the candidate object into the array
        if (!m_mapDiffAreaCandidates.Add(wszCandidate, pObj)) {
            delete pObj;
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ft.Trace( VSSDBG_SWPRV, L"Candidate added: (\'%s\', %I64u)",
                  wszCandidate, ulnFreeBytesAvailable );
    }
}


void CVssDiffAreaAllocator::ComputeExistingDiffAreasCount() throw(HRESULT)
/*++

Description:

    Compute the nunber of original volumes that keeps diff areas on this volume.
    This does not include volumes on which there are no existing shapshots.

    Stores the results in the properties of the existing candidates objects list.

WARNING:

    This method will clear the diff area settings for volumes who keep no snapshots
    (but for us it doesn't matter)

Throws:

    VSS_E_PROVIDER_VETO
        - failure in FindFirstVolume/FindNextVolume, IVssEnumObject::Next
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::ComputeExistingDiffAreasCount" );

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() != 0);

    CVsDiffArea diffobj;
	bool bFirstVolume = true;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
	WCHAR wszQueriedVolumeName[MAX_PATH+1];

	// Search between all mounted volumes
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch = ::FindFirstVolumeW( wszQueriedVolumeName, MAX_PATH);
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszQueriedVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszQueriedVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW(%p,[%s],MAX_PATH)", hSearch, wszQueriedVolumeName);
			}
		}

        BS_ASSERT( wszQueriedVolumeName[0] );

        // Initialize the diff area object
        // This might fail...
        ft.hr = diffobj.Initialize(wszQueriedVolumeName);
        if (ft.HrFailed()) {
            ft.Trace( VSSDBG_SWPRV, 
                L"INFO: Failed to initialize the diff area object on volume %s [0x%08lx]. Going with the next volume.", 
                wszQueriedVolumeName,
                ft.hr );
            continue;
	    }

        // Clear the diff area on the queried volume.
        // If succeeds, then it is clear that the queried volume does not refer anymore the current volume
        // as its diff area.
        // Also, if such a diff area was present then the clear is harmless since there are no existing snapshots.
        // on that volume
        ft.hr = diffobj.Clear();
        if (ft.HrSucceeded())
            continue;

        // Enumerate the diff area volumes for the queried volume.
        // This is likely to fail, for example on non-NTFS volumes.
        // Increment the "diff areas" counter for the corresponding diff area volume
        ft.hr = diffobj.Query( this );
        if (ft.HrFailed()) {
            ft.Trace( VSSDBG_SWPRV, 
                L"INFO: Failed to query diff areas on volume %s. Going with the next volume.", 
                wszQueriedVolumeName);
            continue;
        }
    }

    // Result of computation
    for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++) {
	    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
        ft.Trace( VSSDBG_SWPRV, L"Number of diff areas for volume '%s' = %d",
                  pObj->GetVolumeName(), pObj->GetExistingDiffAreas() );
    }
}


void CVssDiffAreaAllocator::OnDiffAreaVolume(
    IN  LPWSTR pwszDiffAreaVolumeName
    )
    
/*++

Description:

    Increment the "diff areas" counter for the corresponding diff area volume
    This routine is called for each diff area voplume for the queried volume name.

Arguments:

    pwszDiffAreaVolumeName - The diff area for the queried volume name

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::OnDiffAreaVolume");
    
    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pwszDiffAreaVolumeName);

    // If this volume is also a diff area candidate then increment the
    // associated counter of existing diff areas
    if (pObj)
        pObj->IncrementExistingDiffAreas();
}


void CVssDiffAreaAllocator::PlanNewDiffAreas() throw(HRESULT)
/*++

Description:

    Planning of new diff areas

Throws:

    VSS_E_PROVIDER_VETO
        - Not enough space for the diff area.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::PlanNewDiffAreas");

    INT nVolumesCount = m_arrOriginalVolumes.GetSize();
    BS_ASSERT(nVolumesCount > 0);
    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() > 0);

    // Repeat the allocation sequence for each volume to be snapshotted.
    for(;nVolumesCount--;) {

        // Find a diff area candidate that will remain with
        // maximum free space per hosted diff area
        INT nCandidateIndex = -1;
        double lfMaxFreeSpacePerHostedDiffArea = 0;
        for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++) {

	        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
            BS_ASSERT(pObj);

            // We try to add *another* diff area and we estimate the results.
            INT nEstimatedDiffAreas = 1 + pObj->GetPlannedDiffAreas();

            // What will be the free space if we will allocate another diff area?
            // We will ignore the allocated space for the new diff areas in order to keep
            // the algorithm simple to understand
            double lfRemainingFreeSpaceAfterAllocation = pObj->GetVolumeFreeSpace();

            // What will be the free space per hosted diff area (including estimated ones)?
            double lfFreeSpacePerHostedDiffArea =
                lfRemainingFreeSpaceAfterAllocation / (nEstimatedDiffAreas + pObj->GetExistingDiffAreas());

            // Is the current volume a better candidate?
            if (lfFreeSpacePerHostedDiffArea > lfMaxFreeSpacePerHostedDiffArea) {
                nCandidateIndex = nIndex;
                lfMaxFreeSpacePerHostedDiffArea = lfFreeSpacePerHostedDiffArea;
            }
        }

        BS_ASSERT( nCandidateIndex >= 0 );

        // We found another candidate.
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nCandidateIndex);

        // Check to see if we have enough free space per diff area
        if (lfMaxFreeSpacePerHostedDiffArea < nRemainingFreeSpace) {
            // Indicate to the user the requirement that it should provide more space.
            ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
            ft.Throw( VSSDBG_SWPRV, VSS_E_PROVIDER_VETO,
                      L"Not enough free space (%.1f) on any diff area. Best bet: '%s - %.1f'",
                      lfMaxFreeSpacePerHostedDiffArea,
                      pObj->GetVolumeName(),
                      pObj->GetVolumeFreeSpace());
        }
        
        // Increment the planned diff areas
        pObj->IncrementPlannedDiffAreas();

        ft.Trace( VSSDBG_SWPRV,
            L"\r\n   New hosting candidate: '%s'. \r\n\tExisting: %d, \r\n\tplanned: %d, \r\n\tFree: (%.1f). \r\n\tRelative (%.1f)\r\n",
            pObj->GetVolumeName(),
            pObj->GetExistingDiffAreas(),
            pObj->GetPlannedDiffAreas(),
            pObj->GetVolumeFreeSpace(),
            lfMaxFreeSpacePerHostedDiffArea
            );
    }
}


// effectively allocate the diff areas for the voluems to be snapshotted
void CVssDiffAreaAllocator::AssignPlannedDiffAreas() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignPlannedDiffAreas");

    CVsDiffArea diffobj;

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() > 0);

    //
    // For each volume to be snapshotted, find its diff area
    //

    // Keep an array of properties whether a volume is auto-assigned or not
    bool bTmp = false;
    CSimpleArray<bool>    m_arrIsVolumeAutoAssigned;
    for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++)
        m_arrIsVolumeAutoAssigned.Add(bTmp);

    // For each volume to be snapshotted, check to see if we can put the diff area on the same volume
    for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++) {
        LPCWSTR wszVolumeName = m_arrOriginalVolumes[nIndex];
        BS_ASSERT( wszVolumeName && wszVolumeName[0] );

        // The current volume is a diff area candidate also?
        // If not we cannot reasingn the diff area to itself
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(wszVolumeName);
        if (pObj == NULL)
            continue;
        BS_ASSERT(::wcscmp(pObj->GetVolumeName(), wszVolumeName) == 0);

        // We have remaining planned diff areas on the same volume?
        BS_ASSERT(pObj->GetPlannedDiffAreas() >= 0);
        if (pObj->GetPlannedDiffAreas() == 0)
            continue;

        // We convert a planned diff area into an "existing" one.
        BS_ASSERT(pObj);
        pObj->DecrementPlannedDiffAreas();

        // We mark taht volume as auto-assigned
        m_arrIsVolumeAutoAssigned[nIndex] = true;

        //
        // Assign the found diff area to the snapshotted volume
        //

        // Initialize the diff area object
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.Initialize(wszVolumeName);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to initialize the diff area object 0x%08lx", ft.hr);

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.AddVolume(const_cast<LPWSTR>(wszVolumeName));
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to add the volume '%s' as the diff area for itself [0x%08lx]",
                      wszVolumeName, ft.hr);
        else
            ft.Trace( VSSDBG_SWPRV,
                      L"Assigning the diff area '%s' to itself",
                      wszVolumeName);
    }

    // For each remaining volume to be snapshotted, find its diff area
    for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++) {
        LPCWSTR wszVolumeName = m_arrOriginalVolumes[nIndex];
        BS_ASSERT( wszVolumeName && wszVolumeName[0] );

        // The current volume was treated in previous step as an auto-assigned diff area?
        // If yes we will continue with the next one
        if (m_arrIsVolumeAutoAssigned[nIndex])
            continue;

        // We will find the first available diff area candidate
        bool bFound = false;
        CVssDiffAreaCandidate* pObj = NULL;
        for(int nDiffIndex = 0; nDiffIndex < m_mapDiffAreaCandidates.GetSize(); nDiffIndex++) {

	        pObj = m_mapDiffAreaCandidates.GetValueAt(nDiffIndex);
            BS_ASSERT(pObj);

            // We have remaining planned diff areas?
            if (pObj->GetPlannedDiffAreas() > 0) {
                bFound = true;
                break;
            }
        }

        // convert a planned diff area into an "existing" one.
        BS_ASSERT(bFound);
        BS_ASSERT(pObj);
        pObj->DecrementPlannedDiffAreas();

        //
        // Assign the found diff area to the snapshotted volume
        //

        // Initialize the diff area object
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.Initialize(wszVolumeName);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to initialize the diff area object 0x%08lx", ft.hr);

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        ft.hr = diffobj.AddVolume(const_cast<LPWSTR>(pObj->GetVolumeName()));
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, ft.hr,
                      L"Failed to add the volume '%s' as the diff area for '%s' [0x%08lx]",
                      pObj->GetVolumeName(), wszVolumeName, ft.hr);
        else
            ft.Trace( VSSDBG_SWPRV,
                      L"Assigning the diff area '%s' to the volume '%s'",
                      wszVolumeName, pObj->GetVolumeName());
    }

    // Check if all planned diff areas were used.
    for(int nDiffIndex = 0; nDiffIndex < m_mapDiffAreaCandidates.GetSize(); nDiffIndex++) {
	    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nDiffIndex);
        BS_ASSERT(pObj);

        // We have remaining planned diff areas?
        if (pObj->GetPlannedDiffAreas() != 0)
            ft.Trace( VSSDBG_SWPRV,
                      L"FALSE ASSERT: remaining planned diff areas (%d) on '%s'",
                      pObj->GetPlannedDiffAreas(), pObj->GetVolumeName() );
    }
}


void CVssDiffAreaAllocator::Rollback()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Rollback");

    BS_ASSERT(m_bChangesCommitted == false);
    BS_ASSERT(m_bNoChangesNeeded == false);

    try
    {
        CVsDiffArea diffobj;

        // For each volume to be snapshoted, rollback the diff area assignments
        for (int nIndex = 0; nIndex < m_arrOriginalVolumes.GetSize(); nIndex++) {
            LPCWSTR wszVolumeName = m_arrOriginalVolumes[nIndex];
            BS_ASSERT( wszVolumeName && wszVolumeName[0] );

            // Initialize the diff area object. Ignore the errors
            ft.hr = diffobj.Initialize(wszVolumeName);
            if (ft.HrFailed())
                ft.Trace( VSSDBG_SWPRV,
                          L"Failed to initialize the diff area object on volume '%s' 0x%08lx",
                          wszVolumeName, ft.hr);
            else {
                // Clear the diff area on the queried volume.  Ignore the errors
                ft.hr = diffobj.Clear();
                if (ft.HrFailed())
                    ft.Trace( VSSDBG_SWPRV,
                              L"Failed to clear the diff area object on volume '%s' 0x%08lx",
                              wszVolumeName, ft.hr);
            }
        }
    }
    VSS_STANDARD_CATCH(ft)
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaCandidate methods


CVssDiffAreaCandidate::CVssDiffAreaCandidate(
    IN  LPCWSTR wszVolumeName,       // Transfer ownership!
    IN  ULARGE_INTEGER ulFreeSpace
    ):
    m_wszVolumeName(wszVolumeName),
    m_ulFreeSpace(ulFreeSpace),
    m_nPlannedDiffAreas(0),
    m_nExistingDiffAreas(0)
{
}


CVssDiffAreaCandidate::~CVssDiffAreaCandidate()
{
    ::VssFreeString(m_wszVolumeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\softprv\src\find.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Find.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRFINDC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::EnumerateSnapshots(
    IN  bool bSearchBySnapshotID,
    IN  VSS_ID SnapshotID,
	VSS_OBJECT_PROP_Array* pArray
	) throw(HRESULT)

/*++

Description:

	This method enumerates all snapshots

Throws:

    VSS_E_PROVIDER_VETO
        - On runtime errors
    E_OUTOFMEMORY

--*/

{	
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EnumerateSnapshots");
		
	HANDLE hSearch = INVALID_HANDLE_VALUE;
	LPWSTR pwszSnapshotName = NULL;

	try
	{
		// Enumerate snapshots through all the volumes
		CVssIOCTLChannel volumeIChannel;
		CVssIOCTLChannel snapshotIChannel;
		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
		while(true) {
			// Get the volume name
			if (bFirstVolume) {
				hSearch = ::FindFirstVolumeW( wszVolumeName, MAX_PATH);
				if (hSearch == INVALID_HANDLE_VALUE)
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
        				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
        				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
        				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
				}
			}

			// Check if the snapshot is belonging to that volume
			// Open a IOCTL channel on that volume
			// Eliminate the last backslash in order to open the volume
			// On error the call will throw and it will log it
			ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}
			

			// Get the list of snapshots
			// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
			// supported then try with the next volume.
			ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
			if (ft.HrFailed()) {
				ft.hr = S_OK;
				continue;
			}

			// Get the length of snapshot names multistring
			ULONG ulMultiszLen;
			volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
			// Try to find the snapshot with the corresponding Id
			DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif

            bool bFirstSnapshot = true;
			while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName)) {
			    
                // In this version we will have only one snapshot per volume
			    if (!bFirstSnapshot) {
    			    BS_ASSERT(false);
    			    break;
			    } else {
    			    bFirstSnapshot = false;
			    }
			    
    			// Compose the snapshot name in a user-mode style
    			WCHAR wszUserModeSnapshotName[MAX_PATH];
                ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                    wszGlobalRootPrefix, pwszSnapshotName );
				
				// Open that snapshot 
				// Do not eliminate the trailing backslash
				// Do not throw on error
				ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false);
				if (ft.HrFailed()) {
					ft.Warning( VSSDBG_SWPRV, L"Warning: Error opening the snapshot device name %s [0x%08lx]",
								wszUserModeSnapshotName, ft.hr );
					continue;
				}

				// Send the IOCTL to get the application buffer
				ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
				if (ft.HrFailed()) {
					ft.Warning( VSSDBG_SWPRV,
								L"Warning: Error sending the query IOCTL to the snapshot device name %s [0x%08lx]",
								wszUserModeSnapshotName, ft.hr );
					continue;
				}

				// Unpack the length of the application buffer
				ULONG ulLen;
				snapshotIChannel.Unpack(ft, &ulLen);

				if (ulLen == 0) {
					ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
            	    BS_ASSERT(false);
					continue;
				}

                // Unpacking the app info ID
            	VSS_ID AppinfoId;
            	snapshotIChannel.Unpack(ft, &AppinfoId);
            	if (AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
            	{
            	    BS_ASSERT(false);
					continue;
                }
            	
				// Get the snapshot Id
				VSS_ID CurrentSnapshotId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

                // If we are filtering, ignore the rest...
                if (bSearchBySnapshotID)
                    if (SnapshotID != CurrentSnapshotId)
                        continue;

				// Get the snapshot set Id
				VSS_ID CurrentSnapshotSetId;
				snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);
				
                //
				// Process the snapshot that was just found
				//
				
    			// Initialize an empty snapshot properties structure
    			VSS_OBJECT_PROP_Ptr ptrSnapProp;
    			ptrSnapProp.InitializeAsSnapshot( ft,
    				CurrentSnapshotId,
    				CurrentSnapshotSetId,
    				0,
    				wszUserModeSnapshotName,
    				wszVolumeName,
    				NULL,
    				NULL,
    				NULL,
    				NULL,
    				VSS_SWPRV_ProviderId,
    				0,
    				0,
    				VSS_SS_UNKNOWN);

    			// Get the snapshot structure
    			VSS_OBJECT_PROP* pObj = ptrSnapProp.GetStruct();
    			BS_ASSERT(pObj);
    			VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

    			// Load the rest of properties
    			// Do not load the Name and the Original volume name fields
    			// twice since they are already known
    			LoadStructure( snapshotIChannel, pSnap, true );

            	// Get the original volume name and Id
        		CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
        		    snapshotIChannel, 
        		    &(pSnap->m_pwszOriginalVolumeName));

            	// Get the timestamp
            	CVssQueuedSnapshot::LoadTimestampIoctl(
            	    snapshotIChannel, 
            	    &(pSnap->m_tsCreationTimestamp));
    			
    			if (!pArray->Add(ptrSnapProp))
    				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
    						  L"Cannot add element to the array");

    			// Reset the current pointer to NULL
    			ptrSnapProp.Reset(); // The internal pointer was detached into pArray.
			}

#ifdef _DEBUG
			// Check if all strings were browsed correctly
			DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
			BS_ASSERT( (dwFinalOffset - dwInitialOffset == ulMultiszLen));
#endif
		}
	}
	VSS_STANDARD_CATCH(ft)

	// Close the search handle, if needed
	if (hSearch != INVALID_HANDLE_VALUE) {
		if (!::FindVolumeClose(hSearch))
			ft.Trace( VSSDBG_SWPRV, L"Error while closing the search handle 0x%08lx", GetLastError());
	}

	::VssFreeString(pwszSnapshotName);

	if (ft.HrFailed())
		ft.Throw( VSSDBG_SWPRV, ft.hr, L"Error while searching the snapshot 0x%08lx", ft.hr);
}


bool CVssQueuedSnapshot::FindPersistedSnapshotByID(
    IN  VSS_ID SnapshotID,
    OUT LPWSTR * ppwszSnapshotDeviceObject
    ) throw(HRESULT)

/*++

Description:

	Finds a snapshot (and its device name) based on ID.

Throws:

    E_OUTOFMEMORY

    [EnumerateSnapshots() failures]
        VSS_E_PROVIDER_VETO
            - On runtime errors (like Unpack)
        E_OUTOFMEMORY    

--*/
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::FindPersistedSnapshotByID");
		
	BS_ASSERT(SnapshotID != GUID_NULL);
	if (ppwszSnapshotDeviceObject != NULL) {
    	BS_ASSERT((*ppwszSnapshotDeviceObject) == NULL);
	}

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
    if (pArray == NULL)
        ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
    BS_ASSERT(pArrayItf);

    // Put into the array only one element.
    EnumerateSnapshots(
	    true,
    	SnapshotID,
    	pArray
    	);

    // Extract the element from the array.
    if (pArray->GetSize() == 0)
    	return false;

    if (ppwszSnapshotDeviceObject) {
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);
    	BS_ASSERT(pSnap->m_pwszSnapshotDeviceObject);
    	::VssSafeDuplicateStr(ft, (*ppwszSnapshotDeviceObject), 
    	    pSnap->m_pwszSnapshotDeviceObject);
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\softprv\src\diff.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Diff.cxx | Diff area object implementation
    @end

Author:

    Adi Oltean  [aoltean]   01/24/2000

Revision History:

    Name        Date        Comments

    aoltean     01/24/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL headers
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDIFFC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Operations


CVsDiffArea::CVsDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsDiffArea::CVsDiffArea" );
}


CVsDiffArea::~CVsDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsDiffArea::~CVsDiffArea" );
}


HRESULT CVsDiffArea::Initialize(
    IN      LPCWSTR pwszVolumeMountPoint	// DO NOT transfer ownership
    )
/*++

Routine description:

    Initialize the internal structure for a new diff area.

Return codes:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW
        - Error in opening the IOCTL channel
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Initialize" );

    try
    {
		// Test the arguments
		if ((pwszVolumeMountPoint == NULL) ||
			(pwszVolumeMountPoint[0] == L'\0')) {
			BS_ASSERT(false);
			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"NULL volume mount point");
		}

    	// Convert the volume mount point into a volume name
    	WCHAR wszVolumeName[MAX_PATH];
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
				wszVolumeName, ARRAY_LEN(wszVolumeName)))
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
		BS_ASSERT(::wcslen(wszVolumeName) != 0);
    		
		// Opening the channel
        // (if already opened then it will be closed automatically)
		// Eliminate the last backslash from the volume name.
		// The call will throw on error
		// Warning: Always do the logging 
		m_volumeIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  Interface methods

STDMETHODIMP CVsDiffArea::AddVolume(                      			
    IN      VSS_PWSZ pwszVolumeMountPoint						
    )
/*++

Routine description:

    Add a volume to the diff area.
    
Return codes:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, ConvertVolMgmtVolumeNameIntoKernelObject
        - Error in sending the IOCTL
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::AddVolume" );

    try
    {
		// Test arguments
        if (pwszVolumeMountPoint == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		BS_ASSERT(m_volumeIChannel.IsOpen());

    	// Convert the volume mount point into a volume name
    	WCHAR wszVolumeName[MAX_PATH];
		if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
				wszVolumeName, ARRAY_LEN(wszVolumeName)))
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
		BS_ASSERT(::wcslen(wszVolumeName) != 0);

		if (!::ConvertVolMgmtVolumeNameIntoKernelObject(wszVolumeName))
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    E_UNEXPECTED, VSS_E_PROVIDER_VETO,
			    L"ConvertVolMgmtVolumeNameIntoKernelObject( %s, ...)", wszVolumeName);

		// Send the IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA ioctl
		// Logs the error, if any, as a provider error.
    	m_volumeIChannel.PackSmallString(ft, wszVolumeName);
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA, true, VSS_ICHANNEL_LOG_PROV);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsDiffArea::Query(									
    IN OUT  CVssDiffAreaAllocator* pObj
    )												
    
/*++

Routine description:

    Query the diff area volumes for the current volume.
    and call CVssDiffAreaAllocator::OnDiffAreaVolume 
    for each volume in the diff area.
    
Return codes:

    E_OUTOFMEMORY
        - lock failures
    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, GetVolumeGuid
    E_UNEXPECTED
        - Nothing to log. (wrong volume) The result is anyway ignored by the client.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Query" );

	LPWSTR pwszVolumeName = NULL;
	
    try
    {
        // Initialize [out] arguments
        BS_ASSERT( pObj );

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Get the list of volumes that are part of the diff area
		// Do not perform any logging.
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA);

		// Get the length of snapshot names multistring
		ULONG ulMultiszLen;
		m_volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
		// Try to find the snapshot with the corresponding Id
		DWORD dwInitialOffset = m_volumeIChannel.GetCurrentOutputOffset();
#endif

		while(m_volumeIChannel.UnpackZeroString(ft, pwszVolumeName))
		{
			// Compose the volume name in a user-mode style
			WCHAR wszMountPoint[MAX_PATH];
			if (::_snwprintf(wszMountPoint, MAX_PATH - 1,
					L"%s%s\\", wszGlobalRootPrefix, pwszVolumeName) < 0)
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory." );

			// Get the mount point for the volume name
			// If an error occurs then DO the logging.
	    	WCHAR wszUserModeVolumeName[MAX_PATH];
			if (!::GetVolumeNameForVolumeMountPointW( wszMountPoint,
					wszUserModeVolumeName, MAX_PATH))
    			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszMountPoint);
			BS_ASSERT(::wcslen(wszUserModeVolumeName) != 0);

            // Invoke the callback
            pObj->OnDiffAreaVolume(wszUserModeVolumeName);
		}

#ifdef _DEBUG
		// Check if all strings were browsed correctly
		DWORD dwFinalOffset = m_volumeIChannel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
    }
    VSS_STANDARD_CATCH(ft)

    ::VssFreeString(pwszVolumeName);

    return ft.hr;
}


STDMETHODIMP CVsDiffArea::Clear(                      				
    )												
/*++

Routine description:

    Add a volume to the diff area.
    
Return codes:

    E_UNEXPECTED
        - Error in sending the IOCTL (ignored anyway in the client)
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsDiffArea::Clear" );

    try
    {
		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(m_cs);

		// Try to clear the diff area on the current volume
		// Do not log anything at this point!
		BS_ASSERT(m_volumeIChannel.IsOpen());
    	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_CLEAR_DIFF_AREA);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\volsnap\vss\modules\softprv\src\provider.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Provider.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     08/17/1999  Change CommitSnapshots to CommitSnapshot
    aoltean     09/23/1999  Using CComXXX classes for better memory management
                            Renaming back XXXSnapshots -> XXXSnapshot
    aoltean     09/26/1999  Returning a Provider Id in OnRegister
    aoltean     09/09/1999  Adding PostCommitSnapshots
                            dss->vss
	aoltean		09/20/1999	Making asserts more cleaner.
	aoltean		09/21/1999	Small renames

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

//  Generated MIDL header
#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diff.hxx"
#include "alloc.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPROVC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Global Definitions

CVssCriticalSection CVsSoftwareProvider::m_cs;

CVssDLList<CVssQueuedSnapshot*>	 CVssQueuedSnapshot::m_list;


/////////////////////////////////////////////////////////////////////////////
//  Definitions


STDMETHODIMP CVsSoftwareProvider::SetContext(
	IN		LONG     lContext
    )
/*++

Routine description:

    Implements IVsSoftwareProvider::SetContext

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsSoftwareProvider::SetContext" );

    return ft.hr;
    UNREFERENCED_PARAMETER(lContext);
}


STDMETHODIMP CVsSoftwareProvider::BeginPrepareSnapshot(
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ		pwszVolumeName,
    IN      LONG            lNewContext
    )

/*++

Description:

	Creates a Queued Snapshot object to be committed later.

Algorithm:

	1) Creates an internal VSS_SNAPSHOT_PROP structure that will keep most of the properties.
	2) Creates an CVssQueuedSnapshot object and insert it into the global queue of snapshots pending to commit.
	3) Set the state of the snapshot as PREPARING.
	4) If needed, create the snapshot object and return it to the caller.

Remarks:

	The queued snapshot object keeps a reference count. At the end of this function it will be:
		1 = the queued snap obj is reffered by the global queue (if no snapshot COM object was returned)
		2 = reffered by the global queue and by the returned snapshot COM object

Called by:

	IVssCoordinator::AddToSnapshotSet

Error codes:

    VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        - Volume not supported by provider.
    VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        - Maximum number of snapshots reached.
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid arguments

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/


{
    UNREFERENCED_PARAMETER(lNewContext);
    
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::BeginPrepareSnapshot" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT 	L"\n"
             L"  SnapshotSetId = " WSTR_GUID_FMT 	L"\n"
             L"  VolumeName = %s,\n"
             L"  ppSnapshot = %p,\n",
             GUID_PRINTF_ARG( SnapshotId ),
             GUID_PRINTF_ARG( SnapshotSetId ),
             pwszVolumeName);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
        if ( pwszVolumeName == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if ( SnapshotId == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Snapshot ID is NULL");

        if (m_ProviderInstanceID == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"The Provider instance ID could not be generated");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        // Check to see if the volume is supported. 
        // This may throw VSS_E_OBJECT_NOT_FOUND or even VSS_E_PROVIDER_VETO if an error occurs.
        //
        LONG lVolAttr = GetVolumeInformation(pwszVolumeName);
        if ((lVolAttr & VSS_VOLATTR_SUPPORTED) == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER, L"Volume not supported");

        //
        // Check to see if the volume already has snapshots
        //
        if ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED, L"Maximum number of snapshots reached");

        //
        //  Reset the provider interface state
        //

		// Create the structure that will keep the prepared snapshot state.
		VSS_OBJECT_PROP_Ptr ptrSnapshot;
		ptrSnapshot.InitializeAsSnapshot( ft,
			SnapshotId,
			SnapshotSetId,
			0,
			NULL,
			pwszVolumeName,
			NULL,
			NULL,
			NULL,
			NULL,
			VSS_SWPRV_ProviderId,
			0,
			0,
			VSS_SS_PREPARING
			);

		// Create the snapshot object. After this assignment the ref count becomes 1.
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnap = new CVssQueuedSnapshot(
            ptrSnapshot, m_ProviderInstanceID);
		if (ptrQueuedSnap == NULL)
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

		// The structure was detached into the queued object
		// since the ownership was passed to the constructor.
		ptrSnapshot.Reset();

		// Add the snapshot object to the global queue. No exceptions should be thrown here.
		// The reference count will be 2.
		ptrQueuedSnap->AttachToGlobalList();

        // The destructor for the smart pointer will be called. The reference count will be 1
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareProvider::EndPrepareSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as a rendez-vous method
    in order to finish the prepare phase for snapshots
    (like ending the background prepare tasks or performing the lengthly operations before
    issuing the snapshots freeze).

	This function acts on the given snapshot set (i.e. to call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
    on each snapshotted volume)

Algorithm:

	For each preparing snapshot (but not prepared yet) in this snapshot set:
		2) Call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_PREPARED

	Compute the number of prepared snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the first phase (i.e. EndPrepare All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many EndPrepareSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after PrepareSnapshots therefore the state of all snapshots must be PREPARING before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::EndPrepareSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        // Allocate the diff areas
        //

        CVssDiffAreaAllocator allocator(SnapshotSetId);

        // Compute all new diff areas
        // This method may throw
        allocator.AssignDiffAreas();

        //
        // Change the state for the existing snapshots
        //

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARING:

                // Remark - we are supposing here that only one snaphsot set can be 
                // in progress. We are not checking again if the volume has snapshots.

				// Mark the state of this snapshot as failed
                // in order to correctly handle the state
				ptrQueuedSnapshot->MarkAsProcessingPrepare();

				// Open the volume IOCTL channel for that snapshot.
				ptrQueuedSnapshot->OpenVolumeChannel();
					
				// Send the IOCTL_VOLSNAP_AUTO_CLEANUP ioctl.
				ptrQueuedSnapshot->AutoDeleteIoctl();

				// Send the IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT ioctl.
				ptrQueuedSnapshot->PrepareForSnapshotIoctl();

				// Mark the snapshot as prepared
				ptrQueuedSnapshot->MarkAsPrepared();
				break;

			case VSS_SS_PREPARED:

				// Snapshot was already prepared in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }

        // Commit all diff areas allocations
        // (otherwise the diff areas changes will be rollbacked in destructor)
        allocator.Commit();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PreCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to pre-commit all snapshots
	on the given snapshot set

Algorithm:

	For each prepared snapshot (but not precommitted yet) in this snapshot set:
		1) Change the state of the snapshot to VSS_SS_PRECOMMITTED

	Compute the number of pre-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordiantor::DoSnapshotsSet in the second phase (i.e. Pre-Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many PreCommitSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after EndPrepareSnapshots therefore the state of all snapshots must be PREPARED before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PreCommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARED:

				// Mark the snapshot as processing pre-commit
				ptrQueuedSnapshot->MarkAsProcessingPreCommit();

				// Mark the snapshot as pre-committed
                // Do nothing in Babbage provider
				ptrQueuedSnapshot->MarkAsPreCommitted();

				break;

			case VSS_SS_PRECOMMITTED:

				// Snapshot was already pre-committed in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::CommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to commit all snapshots
	on the given snapshot set (i.e. to call IOCTL_VOLSNAP_COMMIT_SNAPSHOT on each snapshotted volume)

Algorithm:

	For each precommitted (but not yet committed) snapshot in this snapshot set:
		2) Call IOCTL_VOLSNAP_COMMIT_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_COMMITTED

	Return the number of committed snapshots, if success.
	Otherwise return 0 (even if some snapshots were committed).

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is already holding writes on snapshotted volumes.
	- The coordinator may issue many CommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::CommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Commit the snapshot, if not failed in pre-commit phase.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PRECOMMITTED:

				// Mark the snapshot as processing commit
				ptrQueuedSnapshot->MarkAsProcessingCommit();

				// Send the IOCTL_VOLSNAP_COMMIT_SNAPSHOT ioctl.
				ptrQueuedSnapshot->CommitSnapshotIoctl();

				// Mark the snapshot as committed
				ptrQueuedSnapshot->MarkAsCommitted();
				break;

			case VSS_SS_COMMITTED:

				// Commit was already done.
				// The provider may receive many CommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PostCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator as a last phase after commit for all snapshots
	on the given snapshot set

Algorithm:

	For each committed snapshot in this snapshot set:
		1) Call IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. The purpose of this
			IOCTL is to get the Snapshot Device object name.
		2) Create a unique snapshot ID
		3) Change the state of the snapshot to VSS_SS_CREATED
		4) Set the "number of committed snapshots" attribute of the snapshot set
		5) Save the snapshot properties using the IOCTL_VOLSNAP_SET_APPLICATION_INFO ioctl.
		6) If everything is OK then remove all snapshots from the global list.

	Keep the number of post-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots), after releasing writes
	by Lovelace

Remarks:

	- While calling this, Lovelace is not holding writes anymore.
	- The coordinator may issue many PostCommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PostCommitSnapshots" );
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				  L"  SnapshotSetId = " WSTR_GUID_FMT L" \n"
				  L"  lSnapshotsCount = %ld",
				  GUID_PRINTF_ARG( SnapshotSetId ),
				  lSnapshotsCount);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		if ( lSnapshotsCount < 0 )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"lSnapshotsCount < 0");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		// On each committed snapshot store the lSnapshotsCount
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Get the snapshot volume name and set the snapshot data.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_COMMITTED:

				// Mark the snapshot as processing post-commit
				ptrQueuedSnapshot->MarkAsProcessingPostCommit();

				// Remark: the snapshot device name will not be persisted

				// Fill the required properties - BEFORE the snapshot properties are saved!
				ptrQueuedSnapshot->SetPostcommitInfo(lSnapshotsCount);

				// Send the IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT ioctl.
				// Get the snapshot device name
				ptrQueuedSnapshot->EndCommitSnapshotIoctl(pProp);
				ft.Trace( VSSDBG_SWPRV, L"Snapshot created at %s", pProp->m_pwszSnapshotDeviceObject);

				// Increment the number of processed snapshots
				lProcessedSnapshotsCount++;

				// Mark the snapshot as created
				ptrQueuedSnapshot->MarkAsCreated();

				break;
				
			case VSS_SS_CREATED:

				// This snapshot is already created.
				// The provider may receive many PostCommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        } // end while(true)
    }
    VSS_STANDARD_CATCH(ft)

	// If an error occured then the coordinator is responsible to call AbortSnapshots
    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PreFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    UNREFERENCED_PARAMETER(SnapshotSetId);
    
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PreFinalCommitSnapshots" );

    ft.hr = E_NOTIMPL;
    return ft.hr;
}

STDMETHODIMP CVsSoftwareProvider::PostFinalCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    UNREFERENCED_PARAMETER(SnapshotSetId);
    
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PostFinalCommitSnapshots" );

    ft.hr = E_NOTIMPL;
    return ft.hr;
}

STDMETHODIMP CVsSoftwareProvider::AbortSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as to abort all snapshots from the given snapshot set.
    The snapshots are "reset" to the preparing state, so that a new DoSnapshotSet sequence can start.

Algorithm:

 	For each pre-committed snapshot in this snapshot set calls IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
 	For each committed or created snapshot it deletes the snapshot

Called by:

	IVssCoordinator::DoSnapshotsSet to abort precommitted snapshots

Remarks:

	- While calling this, Lovelace is not holding writes on snapshotted volumes.
	- The coordinator may receive many AbortSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then 
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::AbortSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		LONG lProcessedSnapshotsCount = 0;
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Switch the snapshot back to "Preparing" state
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PREPARING:
			case VSS_SS_PROCESSING_PREPARE: // Bug 207793

                // Nothing to do.
				break;

			case VSS_SS_PREPARED:
			case VSS_SS_PROCESSING_PRECOMMIT:
			case VSS_SS_PRECOMMITTED:

				// If snapshot was prepared, send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
				ft.hr = ptrQueuedSnapshot->AbortPreparedSnapshotIoctl();
				if (ft.HrFailed())
					ft.Warning( VSSDBG_SWPRV,
                                L"sending IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT failed 0x%08lx", ft.hr);
                break;

			case VSS_SS_PROCESSING_COMMIT:
			case VSS_SS_COMMITTED:
			case VSS_SS_PROCESSING_POSTCOMMIT:
			case VSS_SS_CREATED:

				// If snapshot was committed, delete the snapshot
				ft.hr = ptrQueuedSnapshot->DeleteSnapshotIoctl();
				if (ft.HrFailed())
					ft.Warning( VSSDBG_SWPRV,
                                L"sending IOCTL_VOLSNAP_DELETE_OLDE