k = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        goto out;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        ULONG ulObjType = 0;

        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              0,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);

        if(lpMailUser)
        {
            ULONG cProps;
            LPSPropValue lpPropArray = NULL;
            SizedSPropTagArray(1, ptaBday) =
            {
                1,
                { PR_BIRTHDAY }
            };

            lpMailUser->GetProps((LPSPropTagArray) &ptaBday, 0, &cProps, &lpPropArray);

            if(lpPropArray)
            {
                if(lpPropArray[0].ulPropTag == PR_BIRTHDAY)
                {
                    FILETIME ft = lpPropArray[0].Value.ft;
                    if(FileTimeToSystemTime(&ft, lpst))
                    {
                        bRet = TRUE;
                    }
                }
                m_lpWABObject->FreeBuffer(lpPropArray);
            }

            lpMailUser->Release();
        }
                              

    }
out:
    return bRet;
}

void CWAB::SetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME st)
{

    LV_ITEM lvi = {0};
    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        goto out;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        ULONG ulObjType = 0;

        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              MAPI_MODIFY,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);
        if(lpMailUser)
        {
            ULONG cProps;
            SPropValue PropArray = {0};

            cProps = 1;
            PropArray.ulPropTag = PR_BIRTHDAY;

            FILETIME ft;
            if(SystemTimeToFileTime(&st, &ft))
            {
                PropArray.Value.ft = ft;

                if(S_OK == lpMailUser->SetProps(cProps, &PropArray, NULL))
                {
                    lpMailUser->SaveChanges(KEEP_OPEN_READWRITE);
                }
            }
            lpMailUser->Release();
        }
                              

    }
out:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\webbrwsr.h ===
#if !defined(AFX_WEBBROWSER2_H__8E0170B0_D226_11D0_9A48_00A0C91F9C8B__INCLUDED_)
#define AFX_WEBBROWSER2_H__8E0170B0_D226_11D0_9A48_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser wrapper class

class CWebBrowser : public CWnd
{
protected:
	DECLARE_DYNCREATE(CWebBrowser)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x8856f961, 0x340a, 0x11d0, { 0xa9, 0x6b, 0x0, 0xc0, 0x4f, 0xd7, 0x5, 0xa2 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void GoBack();
	void GoForward();
	void GoHome();
	void GoSearch();
	void Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
	void Refresh();
	void Refresh2(VARIANT* Level);
	void Stop();
	LPDISPATCH GetApplication();
	LPDISPATCH GetParent();
	LPDISPATCH GetContainer();
	LPDISPATCH GetDocument();
	BOOL GetTopLevelContainer();
	CString GetType();
	long GetLeft();
	void SetLeft(long nNewValue);
	long GetTop();
	void SetTop(long nNewValue);
	long GetWidth();
	void SetWidth(long nNewValue);
	long GetHeight();
	void SetHeight(long nNewValue);
	CString GetLocationName();
	CString GetLocationURL();
	BOOL GetBusy();
	void Quit();
	void ClientToWindow(long* pcx, long* pcy);
	void PutProperty(LPCTSTR szProperty, const VARIANT& vtValue);
	VARIANT GetProperty_(LPCTSTR szProperty);
	CString GetName();
	long GetHwnd();
	CString GetFullName();
	CString GetPath();
	BOOL GetVisible();
	void SetVisible(BOOL bNewValue);
	BOOL GetStatusBar();
	void SetStatusBar(BOOL bNewValue);
	CString GetStatusText();
	void SetStatusText(LPCTSTR lpszNewValue);
	long GetToolBar();
	void SetToolBar(long nNewValue);
	BOOL GetMenuBar();
	void SetMenuBar(BOOL bNewValue);
	BOOL GetFullScreen();
	void SetFullScreen(BOOL bNewValue);
	void Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
	long QueryStatusWB(long cmdID);
	void ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);
	void ShowBrowserBar(VARIANT* pvaClsid, VARIANT* pvarShow, VARIANT* pvarSize);
	long GetReadyState();
	BOOL GetOffline();
	void SetOffline(BOOL bNewValue);
	BOOL GetSilent();
	void SetSilent(BOOL bNewValue);
	BOOL GetRegisterAsBrowser();
	void SetRegisterAsBrowser(BOOL bNewValue);
	BOOL GetRegisterAsDropTarget();
	void SetRegisterAsDropTarget(BOOL bNewValue);
	BOOL GetTheaterMode();
	void SetTheaterMode(BOOL bNewValue);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WEBBROWSER2_H__8E0170B0_D226_11D0_9A48_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDI_ICON1                       101
#define IDD_PROP2                       103
#define IDD_PROP                        104
#define IDC_EXT_EDIT_HOME               1000
#define IDC_EXT_EDIT_TEAM               1002
#define IDC_STATIC_NAME                 1004
#define IDC_BUTTON1                     1006
#define IDC_BUTTON2                     1007
#define IDC_BUTTON3                     1008
#define IDC_BUTTON4                     1009
#define IDC_BUTTON5                     1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabext\wabex.c ===
/*//$$***************************************************************
//
//
// WABEX.C
//
// Main source file for WABEX.DLL, a sample DLL that demonstrates 
// how to extend the wab properties UI - enabling WAB clients to add
// their own PropertySheets to the UI displayed for details on contacts
// and groups. This demo uses a couple of named properties to show
// how you can extend the wab with your own UI for your own named props
//
//
// Created: 9/26/97 vikramm
//
//********************************************************************/
#include <windows.h>
#include "resource.h"
#include <wab.h>

// Globally cached hInstance for the DLL
//
HINSTANCE hinstApp = NULL;


// For the purposes of this sample, we will use 2 named properties,
// HomeTown and SportsTeam

// This demo's private GUID:
// {2B6D7EE0-36AB-11d1-9ABC-00A0C91F9C8B}
static const GUID WAB_ExtDemoGuid = 
{ 0x2b6d7ee0, 0x36ab, 0x11d1, { 0x9a, 0xbc, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMyPropNames[] = 
{   
    "MyHomeTown", 
    "MySportsTeam"
};

enum _MyTags
{
    myHomeTown = 0,
    mySportsTeam,
    myMax
};

ULONG MyPropTags[myMax];
ULONG PR_MY_HOMETOWN;
ULONG PR_MY_SPORTSTEAM;



// 
// Function prototypes:
//
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED);
BOOL CALLBACK fnDetailsPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
UINT CALLBACK fnCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED);

/*//$$****************************************************************
//
// DllEntryPoint
//
// Entry point for win32 - just used here to cache the DLL instance
//
//********************************************************************/
BOOL WINAPI
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpvReserved)
{
	switch ((short)dwReason)
	{
	case DLL_PROCESS_ATTACH:
		hinstApp = hinst;
        break;
    }
    return TRUE;
}



/*//$$****************************************************************
//
// AddExtendedPropPage
//
// This is the main exported function that WAB will call. In this 
// function, you create your PropertyPage and pass it to the WAB
// through the lpfnAddPage function. The WAB will automatically call 
// DestroyPropertySheetPage on exit to clean up the page you create.
// The lParam passed into this function should be set as the lParam
// on the property sheet you create, as shown below.
//
// Input Params: 
//
// lpfnPage - pointer to AddPropSheetPage function proc you call to
//          pass your hpage to the WAB
// lParam - LPARAM you set on your PropSheet page and also pass back to
//          wab in the lpfnAddPage. This lParam is a pointer to a 
//          WABEXTDISPLAY struct that your propsheet will use to 
//          exchange information with the WAB 
// 
// ***IMPORTANT*** Make sure your callback function is declared as a
//              WINAPI otherwise ugly things happen to the stack when
//              this function is called
//
//********************************************************************/
HRESULT WINAPI AddExtendedPropPage(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, int * lpnPage)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) lParam;
    LPWABEXTDISPLAY lpWED = NULL; 

    // Check that there is space to create this property sheet
    // WAB can support a maximum of WAB_MAX_EXT_PROPSHEETS extension sheets

    if(WAB_MAX_EXT_PROPSHEETS <= *lpnPage)
        return E_FAIL;

    lpWED = &((*lppWED)[*lpnPage]);

    psp.dwSize = sizeof(psp);
    
    psp.dwFlags =   PSP_USETITLE |
                    PSP_USECALLBACK;// Specify this callback only if you need
                                    // a seperate function to perform special
                                    // initialization and cleanup when the 
                                    // property sheet is created or destroyed.
    psp.hInstance = hinstApp;

    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP); // Dialog resource

    psp.pfnDlgProc = fnDetailsPropDlgProc; // Message handler function

    psp.pcRefParent = NULL; //ignored
    
    psp.pfnCallback = fnCallback; // Callback function if PSP_USECALLBACK specified
    
    psp.lParam = (LPARAM) lpWED; // *** VERY IMPORTANT *** dont forget to do this
    
    psp.pszTitle = "Extension 1"; // Title for your tab

    /*
    // If you have some private data of your own that you want to cache
    // on your page, you can add it to the WABEXTDISPLAY struct
    // However WAB will not free this data so you must do it yourself on
    // cleanup
    {
        LPMYDATA lpMyData;
        // Create Data Here
        lpWED->lParam = (LPARAM) lpMyData;
    }
    */

    // Check if we can retrieve our named props .. if we cant,
    // no point creating this dialog ..
    //
    if(HR_FAILED(InitNamedProps(lpWED)))
        return E_FAIL;

    // Create the property sheet
    //
    hpage = CreatePropertySheetPage(&psp);

    if(hpage)
    {
        // Pass this hpage back to the WAB
        //
        if(!lpfnAddPage(hpage, (LPARAM) lpWED))
            DestroyPropertySheetPage(hpage);
        else
            (*lpnPage)++;

        //return NOERROR;
    }

    // if you are creating more than one property sheet, repeat the above as follows


    // Check that there is space to create this property sheet
    // WAB can support a maximum of WAB_MAX_EXT_PROPSHEETS extension sheets

    if(WAB_MAX_EXT_PROPSHEETS <= *lpnPage)
        return E_FAIL;

    lpWED = &((*lppWED)[*lpnPage]);
    
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP2); // Dialog resource

    psp.pfnDlgProc = fnDetailsPropDlgProc; // Message handler function

    psp.pszTitle = "Extension 2"; // Title for your tab

    psp.lParam = (LPARAM) lpWED; // *** VERY IMPORTANT *** dont forget to do this

    // Create the property sheet
    //
    hpage = CreatePropertySheetPage(&psp);

    if(hpage)
    {
        // Pass this hpage back to the WAB
        //
        if(!lpfnAddPage(hpage, (LPARAM) lpWED))
            DestroyPropertySheetPage(hpage);
        else
            (*lpnPage)++;
        return NOERROR;
    }

    return E_FAIL;
}


/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED)
{
    // The lpWED provides a lpMailUser object for
    // the specific purpose of retrieving named properties by 
    // calling GetNamesFromIDs. The lpMailUser object is otherwise
    // a blank object - you cant get properties from it and shouldnt
    // set properties on it
    //
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMyProps = NULL;
    LPMAPINAMEID * lppMyPropNames;
    SCODE sc;
    LPMAILUSER lpMailUser = (LPMAILUSER) lpWED->lpPropObj;
    WCHAR szBuf[myMax][MAX_PATH];

    if(!lpMailUser)
        goto err;

    sc = lpWED->lpWABObject->lpVtbl->AllocateBuffer(lpWED->lpWABObject,
                                                    sizeof(LPMAPINAMEID) * myMax, 
                                                    (LPVOID *) &lppMyPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<myMax;i++)
    {
        sc = lpWED->lpWABObject->lpVtbl->AllocateMore(lpWED->lpWABObject,
                                                    sizeof(MAPINAMEID), 
                                                    lppMyPropNames, 
                                                    &(lppMyPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMyPropNames[i]->lpguid = (LPGUID) &WAB_ExtDemoGuid;
        lppMyPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMyPropNames[i], -1, szBuf[i], sizeof(szBuf[i])) )
        {
            continue;
        }

        lppMyPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = lpMailUser->lpVtbl->GetIDsFromNames(lpMailUser, 
                                            myMax, 
                                            lppMyPropNames,
                                            MAPI_CREATE, 
                                            &lptaMyProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMyProps)
    {
        // Set the property types on the returned props
        MyPropTags[myHomeTown] = PR_MY_HOMETOWN = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[myHomeTown],    PT_TSTRING);
        MyPropTags[mySportsTeam] = PR_MY_SPORTSTEAM = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[mySportsTeam],    PT_TSTRING);
    }

err:
    if(lptaMyProps)
        lpWED->lpWABObject->lpVtbl->FreeBuffer( lpWED->lpWABObject,
                                                lptaMyProps);

    if(lppMyPropNames)
        lpWED->lpWABObject->lpVtbl->FreeBuffer( lpWED->lpWABObject,
                                                lppMyPropNames);

    return hr;

}


#define lpW_E_D ((LPWABEXTDISPLAY)pps->lParam)
/*//$$****************************************************************
//
// fnDetailsPropDlgProc
//
// The dialog procedure that will handle all the windows messages for 
// the extended property page. 
//
//********************************************************************/
BOOL CALLBACK fnDetailsPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    PROPSHEETPAGE * pps;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        //
        // The lParam on InitDialog contains the application data
        // Cache this on the dialog so we can retrieve it later.
        //
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        // Initialize the UI appropriately
        InitializeUI(hDlg, lpW_E_D);

        // Fill the UI with appropriate data
        SetDataInUI(hDlg, lpW_E_D);

        return TRUE;
        break;


    case WM_COMMAND:
        switch(HIWORD(wParam)) //check the notification code
        {
            // If data changes, we should signal back to the WAB that
            // the data changed. If this flag is not set, the WAB will not
            // write the new data back to the store!!!
        case EN_CHANGE: //one of the edit boxes changed - dont care which
            lpW_E_D->fDataChanged = TRUE;
            break;
        }
        break;
    

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //Page being activated
            // Get the latest display name info and update the 
            // corresponding control
            UpdateDisplayNameInfo(hDlg, lpW_E_D);
            break;


        case PSN_KILLACTIVE:    //Losing activation to another page or OK
            //
            // Take all the data from this prop sheet and convert it to a 
            // SPropValue array and place the data in an appropriate place.
            // The advantage of doing this in the KillActive notification is
            // that other property sheets can scan these property arrays and
            // if deisred, update data on other prop sheets based on this data
            //
            bUpdatePropSheetData(hDlg, lpW_E_D);
            break;


        case PSN_RESET:         //cancel
            break;


        case PSN_APPLY:         //ok pressed
            if (!(lpW_E_D->fReadOnly))
            {
                //
                // Check for any required properties here
                // If some required property is not filled in, you can prevent
                // the property sheet from closing
                //
                /*
                if (RequiredDataNotFilledIn())
                {
                    // abort this OK ... ie dont let them close
                    SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
                }
                */
            }
            break;
        }
        break;
    }

    return 0;
}

int EditControls[] = 
{
    IDC_EXT_EDIT_HOME,
    IDC_EXT_EDIT_TEAM
};

/*//$$****************************************************************
//
// InitializeUI
//
// Rearranges/Sets UI based on input params
//
//********************************************************************/
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // The WAB property sheets can be readonly when opening LDAP entries,
    // or vCards or other things. If the READONLY flag is set, set this
    // prop sheets controls to readonly
    //
    int i;
    for(i=0;i<myMax;i++)
    {
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETREADONLY, 
                            (WPARAM) lpWED->fReadOnly, 0);
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETLIMITTEXT, 
                            (WPARAM) MAX_PATH-1, 0);
    }
    return;
}


/*//$$****************************************************************
//
// SetDataInUI
//
// Fills in the controls with data passed in by the WAB
//
//********************************************************************/
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{

    // Search for our private named properties and set them in the UI
    //
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    ULONG i = 0, j =0;

    // Get all the props from this object - one can also selectively
    // ask for specific props by passing in an SPropTagArray
    //
    if(!HR_FAILED(lpWED->lpPropObj->lpVtbl->GetProps(lpWED->lpPropObj,
                                                    NULL, 0, 
                                                    &ulcPropCount, 
                                                    &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i=0;i<ulcPropCount;i++)
            {
                for(j=0;j<myMax;j++)
                {
                    if(lpPropArray[i].ulPropTag == MyPropTags[j])
                    {
                        SetWindowText(  GetDlgItem(hDlg, EditControls[j]),
                                        lpPropArray[i].Value.LPSZ);
                        break;
                    }
                }
            }
        }
    }
    if(lpPropArray)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject, lpPropArray);
                                    
    return;
}

/*//$$****************************************************************
//
// GetDataFromUI
//
// Retrieves data from the UI and passes back to the WAB
//
//********************************************************************/
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    TCHAR szData[myMax][MAX_PATH];
    int i;
    ULONG ulIndex = 0;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;
    BOOL bRet = FALSE;
    int nIndex = lpWED->nIndexNumber; // position of page in sheets

    // Did any data change that we have to care about ?
    // If nothing changed, old data will be retained by WAB
    //
    if(!lpWED->fDataChanged)
        return TRUE;

    // Check if we have any data to save ...
    for(i=0;i<myMax;i++)
    {
        *(szData[i]) = '\0';
        GetWindowText(GetDlgItem(hDlg, EditControls[i]), szData[i], MAX_PATH);
        if(lstrlen(szData[i]))
            ulcPropCount++;
    }

    if(!ulcPropCount) // no data
        return TRUE;

    // Else data exists. Create a return prop array to pass back to the WAB
    sc = lpWED->lpWABObject->lpVtbl->AllocateBuffer(    lpWED->lpWABObject,
                                                        sizeof(SPropValue) * ulcPropCount, 
                                                        &lpPropArray);
    if (sc!=S_OK)
        goto out;

    for(i=0;i<myMax;i++)
    {
        int nLen = lstrlen(szData[i]);
        if(nLen)
        {
            lpPropArray[ulIndex].ulPropTag = MyPropTags[i];
            sc = lpWED->lpWABObject->lpVtbl->AllocateMore(  lpWED->lpWABObject,
                                                            nLen+1, lpPropArray, 
                                                            &(lpPropArray[ulIndex].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szData[i]);
            ulIndex++;
        }
    }

    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->lpVtbl->SetProps( lpWED->lpPropObj,
                                                    ulcPropCount, lpPropArray, NULL)))
        goto out;

    // ** Important - do not call SaveChanges on the object
    //    SaveChanges makes persistent changes and may modify/lose data if called at this point
    //    The WAB will determine if its appropriate or not to call SaveChanges after the
    // ** user has closed the property sheets
    

    bRet = TRUE;

out:
    if(!bRet && lpPropArray)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject, lpPropArray);

    return bRet;

} 


/*//$$****************************************************************
//
// UpdateDisplayNameInfo
//
// Demonstrates how to read information from other sibling property
// sheets when the user switches between pages
//
// This demo function attempts to get the updated display name info 
// when the user switches to this page in the UI
//
//********************************************************************/
const SizedSPropTagArray(1, ptaName)=
{
    1,
    {
        PR_DISPLAY_NAME
    }
};

void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // 
    // Scan all the updated information from all the other property sheets
    //
    ULONG i = 0, j=0;
    LPTSTR lpName = NULL;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    // Each sheet should update its data on the object when it looses
    // focus and gets the PSN_KILLACTIVE message, provided the user has
    // made any changes. We just scan the object for the desired properties
    // and use them.

    // Ask only for the display name
    if(!HR_FAILED(lpWED->lpPropObj->lpVtbl->GetProps( lpWED->lpPropObj,
                                                    (LPSPropTagArray) &ptaName,
                                                    0,
                                                    &ulcPropCount, &lpPropArray)))
    {
        if( ulcPropCount == 1 && 
            PROP_TYPE(lpPropArray[0].ulPropTag) == PT_TSTRING) // The call could succeed but there may be no DN
        {                                                      // in which case the PROP_TYPE will be PR_NULL 
            lpName = lpPropArray[0].Value.LPSZ;
        }
    }

    if(lpName && lstrlen(lpName))
        SetDlgItemText(hDlg, IDC_STATIC_NAME, lpName);

    if(ulcPropCount && lpPropArray)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject, lpPropArray);

    return;
}

/*//$$*********************************************************************
//
//  UpdateOldPropTagsArray
//
//  When we update the data on a particular property sheet, we want to update
//  all the properties related to that particular sheet. Since some properties
//  may have been deleted from the UI, we delete all relevant properties from
//  the property object
//
//**************************************************************************/
BOOL UpdateOldPropTagsArray(LPWABEXTDISPLAY lpWED, int nIndex)
{
    LPSPropTagArray lpPTA = NULL;
    SCODE sc = 0;
    int i =0;
    
    sc = lpWED->lpWABObject->lpVtbl->AllocateBuffer(lpWED->lpWABObject,
                            sizeof(SPropTagArray) + sizeof(ULONG)*(myMax), 
                            &lpPTA);

    if(!lpPTA || sc!=S_OK)
        return FALSE;

    lpPTA->cValues = myMax;

    for(i=0;i<myMax;i++)
        lpPTA->aulPropTag[i] = MyPropTags[i];

    // Delete any props in the original that may have been modified on this propsheet
    lpWED->lpPropObj->lpVtbl->DeleteProps(lpWED->lpPropObj,
                                            lpPTA,
                                            NULL);

    if(lpPTA)
        lpWED->lpWABObject->lpVtbl->FreeBuffer(lpWED->lpWABObject,
                                                lpPTA);

    return TRUE;

}

/*//$$*********************************************************************
//
// bUpdatePropSheetData
//
// We delete any properties relevant to us from the object, and set new
// data from the property sheet onto the object
//
****************************************************************************/
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    BOOL bRet = TRUE;

    // ****Dont**** do anything if this is a READ_ONLY operation
    // In that case the memory variables are not all set up and this
    // prop sheet is not expected to return anything at all
    //
    if(!lpWED->fReadOnly)
    {
        // Delete old
        if(!UpdateOldPropTagsArray(lpWED, lpWED->nIndexNumber))
            return FALSE;

        bRet = GetDataFromUI(hDlg, lpWED);
    }
    return bRet;
}



/*//$$****************************************************************
//
// fnCallback
//
// A callback function that is called when the property sheet is created
// and when it is destroyed. This functional is optional - you dont need
// it unless you want to do specific initialization and cleanup.
//
// See SDK documentation on PropSheetPageProc for more details
//
//********************************************************************/
UINT CALLBACK fnCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp )
{
    switch(uMsg)
    {
    case PSPCB_CREATE:
        // Propsheet is being created
        break;
    case PSPCB_RELEASE:
        // Propsheet is being destroyed
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE				0xF2D1
#define AFX_IDS_HTTP_NO_TEXT			0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST		0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED		0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN			0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND			0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR		0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED	0xF2D8


/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7





#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\bin.c ===
/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\mutil.h ===
/***********************************************************************
 *
 * MUTIL.H
 *
 * WAB Mapi Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifdef DEBUG
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label);
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(LPMAPITABLE lpTable);

#define DebugObjectProps(lpObject, Label) _DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable) _DebugMapiTable(lpTable)

#else

#define DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable)

#endif

SCODE ScMergePropValues(ULONG cProps1, LPSPropValue lpSource1,
  ULONG cProps2, LPSPropValue lpSource2, LPULONG lpcPropsDest, LPSPropValue * lppDest);

#define MAPIFreeBuffer lpWABObject->FreeBuffer
#define MAPIAllocateBuffer lpWABObject->AllocateBuffer
//#define DebugTrace(x) LUIOut(L4, #x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pabtest.rc
//
#define IDR_MENU1                       102
#define IDD_INIFILE                     104
#define IDC_EDIT                        1000
#define IDC_LIST2                       1002
#define IDM_HELP                        65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\wabguid.c ===
// This builds mapiguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by MAPI.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData

#define USES_PS_MAPI
#define USES_PS_PUBLIC_STRINGS


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
//#include "_apipch.h"

#include <windows.h>
#include <windowsx.h>
#include <limits.h>
#include <memory.h>
#include <commdlg.h>
#include <stdio.h>
#include <string.h>
#include <mbstring.h>
#include <time.h>
#include <math.h>

//
// MAPI headers
//
#include <mapiwin.h>
#include <mapidefs.h>
#include <mapicode.h>
#include <mapitags.h>
#include <mapiguid.h>
//#include <mapispi.h>
#include <mapiutil.h>
#include <mapival.h>
#include <mapix.h>
#include <mapiutil.h>
#include <unknwn.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\mutil.cpp ===
/***********************************************************************
 *
 * MUTIL.C
 *
 * Windows AB Mapi Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

//#include <_apipch.h>
#include <wab.h>
#include "mutil.h"

#define _WAB_MUTIL_C

#ifdef DEBUG
PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";
#endif

#if defined (_MIPS_) || defined (_ALPHA_) || defined (_PPC_)
#define AlignProp(_cb)	Align8(_cb)
#else
#define AlignProp(_cb)	(_cb)
#endif


#define ALIGN_RISC		8
#define ALIGN_X86		1
//#define LPULONG unsigned long*

extern LPWABOBJECT		lpWABObject; //Global handle to session


/***************************************************************************

    Name      : RemoveDuplicateProps

    Purpose   : Removes duplicate properties from an SPropValue array.

    Parameters: lpcProps -> input/output: number of properties in lpProps
                lpProps -> input/output: prop array to remove dups from.

    Returns   : none

    Comment   : Gives preference to earlier properties.

***************************************************************************/
void RemoveDuplicateProps(LPULONG lpcProps, LPSPropValue lpProps) {
    ULONG i, j;
    ULONG cProps = *lpcProps;

    for (i = 0; i < cProps; i++) {
        for (j = i + 1; j < cProps; j++) {
            if (PROP_ID(lpProps[i].ulPropTag) == PROP_ID(lpProps[j].ulPropTag)) {
                // If j is PT_ERROR, use i, else use j.
                if (lpProps[j].ulPropTag != PR_NULL) {
                    if (PROP_TYPE(lpProps[j].ulPropTag) != PT_ERROR) {
                        // Replace i's propvalue with j's.  Nuke j's entry.
                        lpProps[i] = lpProps[j];
                    }
                    lpProps[j].ulPropTag = PR_NULL;
                }
            }
        }
    }

    // Now, squeeze out all the PR_NULLs.
    for (i = 0; i < cProps; i++) {
        if (lpProps[i].ulPropTag == PR_NULL) {
            // Move the array down
            cProps--;

            if (cProps > i) {

                MoveMemory(&lpProps[i], // dest
                  &lpProps[i + 1],      // src
                  (cProps - i) * sizeof(SPropValue));
                i--;    // Redo this row... it's new!
            }
        }
    }

    *lpcProps = cProps;
}


/***************************************************************************

    Name      : ScMergePropValues

    Purpose   : Merge two SPropValue arrays

    Parameters: cProps1 = count of properties in lpSource1
                lpSource1 -> 1st source SPropValue array
                cProps2 = count of properties in lpSource2
                lpSource2 -> 2nd source SPropValue array
                lpcPropsDest -> returned number of properties
                lppDest -> Returned destination SPropValue array.  This
                  buffer will be allocated using AllocateBuffer and is the
                  responsibility of the caller on return.

    Returns   : SCODE

    Comment   : Gives preference to Source2 over Source1 in case of collisions.

***************************************************************************/

SCODE ScMergePropValues(ULONG cProps1, LPSPropValue lpSource1,
  ULONG cProps2, LPSPropValue lpSource2, LPULONG lpcPropsDest, LPSPropValue * lppDest) {
    ULONG cb1, cb2, cb, cProps, i, cbT, cbMV;
    SCODE sc = SUCCESS_SUCCESS;
    LPSPropValue pprop, lpDestReturn = NULL;
    __UPV upv;
    LPBYTE pb;  // moving pointer for property data
    int iValue;



    DebugProperties(lpSource1, cProps1, "Source 1");
    DebugProperties(lpSource2, cProps2, "Source 2");


    // How big do I need to make the destination buffer?
    // Just add the sizes of the two together to get an upper limit.
    // This is close enough, though not optimal (consider overlap).

    if (sc = ScCountProps(cProps1, lpSource1, &cb1)) {
        goto exit;
    }
    if (sc = ScCountProps(cProps2, lpSource2, &cb2)) {
        goto exit;
    }

    cProps = cProps1 + cProps2;
    cb = cb1 + cb2;
    if (sc = MAPIAllocateBuffer(cb, (void **)&lpDestReturn)) {
        goto exit;
    }
//    MAPISetBufferName(lpDestReturn, "WAB: lpDestReturn in ScMergePropValues");



    // Copy each source property array to the destination
    memcpy(lpDestReturn, lpSource1, cProps1 * sizeof(SPropValue));
    memcpy(&lpDestReturn[cProps1], lpSource2, cProps2 * sizeof(SPropValue));


    // Remove duplicates
    RemoveDuplicateProps(&cProps, lpDestReturn);

    // Fixup the pointers.
    pb = (LPBYTE)&(lpDestReturn[cProps]);   // point past the prop array


    for (pprop = lpDestReturn, i = cProps; i--; ++pprop) {
        //	Tricky: common code after the switch increments pb and cb
        //	by the amount copied. If no increment is necessary, the case
        //	uses 'continue' rather than 'break' to exit the switch, thus
        //	skipping the increment -- AND any other code which may be
        //	added after the switch.

        switch (PROP_TYPE(pprop->ulPropTag)) {
            default:
                DebugTrace("ScMergePropValues: Unknown property type %s (index %d)\n",
                  SzDecodeUlPropTag(pprop->ulPropTag), pprop - lpDestReturn);
                sc = E_INVALIDARG;
                goto exit;

            case PT_I2:
            case PT_LONG:
            case PT_R4:
            case PT_APPTIME:
            case PT_DOUBLE:
            case PT_BOOLEAN:
            case PT_CURRENCY:
            case PT_SYSTIME:
            case PT_I8:
            case PT_ERROR:
            case PT_OBJECT:
            case PT_NULL:
                continue;	//	nothing to add

            case PT_CLSID:
                cbT = sizeof(GUID);
                MemCopy(pb, (LPBYTE)pprop->Value.lpguid, cbT);
                pprop->Value.lpguid = (LPGUID)pb;
                break;

            case PT_BINARY:
                cbT = (UINT)pprop->Value.bin.cb;
                MemCopy(pb, pprop->Value.bin.lpb, cbT);
                pprop->Value.bin.lpb = pb;
                break;

            case PT_STRING8:
                cbT = lstrlenA( pprop->Value.lpszA ) + 1;
                MemCopy(pb, pprop->Value.lpszA, cbT);
                pprop->Value.lpszA = (LPSTR)pb;
                break;

            case PT_UNICODE:
                cbT = (lstrlenW( pprop->Value.lpszW ) + 1) * sizeof(WCHAR);
                MemCopy(pb, pprop->Value.lpszW, cbT);
                pprop->Value.lpszW = (LPWSTR)pb;
                break;

            case PT_MV_I2:
                cbT = (UINT)pprop->Value.MVi.cValues * sizeof(short int);
                MemCopy(pb, pprop->Value.MVi.lpi, cbT);
                pprop->Value.MVi.lpi = (short int FAR *)pb;
                break;

            case PT_MV_LONG:
                cbT = (UINT)pprop->Value.MVl.cValues * sizeof(LONG);
                MemCopy(pb, pprop->Value.MVl.lpl, cbT);
                pprop->Value.MVl.lpl = (LONG FAR *)pb;
                break;

            case PT_MV_R4:
                cbT = (UINT)pprop->Value.MVflt.cValues * sizeof(float);
                MemCopy(pb, pprop->Value.MVflt.lpflt, cbT);
                pprop->Value.MVflt.lpflt = (float FAR *)pb;
                break;

            case PT_MV_APPTIME:
                cbT = (UINT)pprop->Value.MVat.cValues * sizeof(double);
                MemCopy(pb, pprop->Value.MVat.lpat, cbT);
                pprop->Value.MVat.lpat = (double FAR *)pb;
                break;

            case PT_MV_DOUBLE:
                cbT = (UINT)pprop->Value.MVdbl.cValues * sizeof(double);
                MemCopy(pb, pprop->Value.MVdbl.lpdbl, cbT);
                pprop->Value.MVdbl.lpdbl = (double FAR *)pb;
                break;

            case PT_MV_CURRENCY:
                cbT = (UINT)pprop->Value.MVcur.cValues * sizeof(CURRENCY);
                MemCopy(pb, pprop->Value.MVcur.lpcur, cbT);
                pprop->Value.MVcur.lpcur = (CURRENCY FAR *)pb;
                break;

            case PT_MV_SYSTIME:
                cbT = (UINT)pprop->Value.MVft.cValues * sizeof(FILETIME);
                MemCopy(pb, pprop->Value.MVft.lpft, cbT);
                pprop->Value.MVft.lpft = (FILETIME FAR *)pb;
                break;

            case PT_MV_CLSID:
                cbT = (UINT)pprop->Value.MVguid.cValues * sizeof(GUID);
                MemCopy(pb, pprop->Value.MVguid.lpguid, cbT);
                pprop->Value.MVguid.lpguid = (GUID FAR *)pb;
                break;

            case PT_MV_I8:
                cbT = (UINT)pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER);
                MemCopy(pb, pprop->Value.MVli.lpli, cbT);
                pprop->Value.MVli.lpli = (LARGE_INTEGER FAR *)pb;
                break;

            case PT_MV_BINARY:
                upv = pprop->Value;
                pprop->Value.MVbin.lpbin = (SBinary *)pb;
                cbMV = upv.MVbin.cValues * sizeof(SBinary);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVbin.cValues; iValue++) {
                    pprop->Value.MVbin.lpbin[iValue].lpb = pb;
                    cbT = (UINT)upv.MVbin.lpbin[iValue].cb;
                    pprop->Value.MVbin.lpbin[iValue].cb = (ULONG)cbT;
                    MemCopy(pb, upv.MVbin.lpbin[iValue].lpb, cbT);
                    cbT = AlignProp(cbT);
                    cb += cbT;
                    pb += cbT;
                }
                continue;	//	already updated, don't do it again

            case PT_MV_STRING8:
                upv = pprop->Value;
                pprop->Value.MVszA.lppszA = (LPSTR *)pb;
                cbMV = upv.MVszA.cValues * sizeof(LPSTR);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVszA.cValues; iValue++) {
                    pprop->Value.MVszA.lppszA[iValue] = (LPSTR)pb;
                    cbT = lstrlenA(upv.MVszA.lppszA[iValue]) + 1;
                    MemCopy(pb, upv.MVszA.lppszA[iValue], cbT);
                    pb += cbT;
                    cb += cbT;
                }
                cbT = (UINT)AlignProp(cb);
                pb += cbT - cb;
                cb  = cbT;
                continue;	//	already updated, don't do it again

            case PT_MV_UNICODE:
                upv = pprop->Value;
                pprop->Value.MVszW.lppszW = (LPWSTR *)pb;
                cbMV = upv.MVszW.cValues * sizeof(LPWSTR);
                pb += cbMV;
                cb += cbMV;
                for (iValue = 0; (ULONG)iValue < upv.MVszW.cValues; iValue++) {
                    pprop->Value.MVszW.lppszW[iValue] = (LPWSTR)pb;
                    cbT = (lstrlenW(upv.MVszW.lppszW[iValue]) + 1)
                    * sizeof(WCHAR);
                    MemCopy(pb, upv.MVszW.lppszW[iValue], cbT);
                    pb += cbT;
                    cb += cbT;
                }
                cbT = (UINT)AlignProp(cb);
                pb += cbT - cb;
                cb  = cbT;
                continue;	//	already updated, don't do it again
        }

        //	Advance pointer and total count by the amount copied
        cbT = AlignProp(cbT);
        pb += cbT;
        cb += cbT;
    }

exit:
    // In case of error, free the memory.
    if (sc && lpDestReturn) {
        MAPIFreeBuffer(lpDestReturn);
        *lppDest = NULL;
    } else if (lpDestReturn) {
        *lppDest = lpDestReturn;
        *lpcPropsDest = cProps;
        DebugProperties(lpDestReturn, cProps, "Destination");
    } // else just return the error

    return(sc);
}





#ifdef OLD_STUFF
/***************************************************************************

    Name      : AddPropToMVPBin

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpNew -> new data
                cbNew = size of lpbNew

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpbin the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPBin(
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPVOID lpNew,
  ULONG cbNew) {

    SBinaryArray * lprgsbOld = NULL;
    SBinaryArray * lprgsbNew = NULL;
    LPSBinary lpsbOld = NULL;
    LPSBinary lpsbNew = NULL;
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;


    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_BINARY, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgsbOld = &(lpaProps[index].Value.MVbin);
        lpsbOld = lprgsbOld->lpbin;

        cExisting = lprgsbOld->cValues;
        cbMVP = cExisting * sizeof(SBinary);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(SBinary);   // room in the MVP for another Sbin

    // Allocate room for new MVP
    if (sc = MAPIAllocateMore(cbMVP, lpaProps, (LPVOID)&lpsbNew)) {
        AwDebugError(("AddPropToMVPBin allocation (%u) failed %x\n", cbMVP, sc));
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lpsbNew[i].cb = lpsbOld[i].cb;
        lpsbNew[i].lpb = lpsbOld[i].lpb;
    }

    // Add the new property value
    // Allocate room for it
    if (sc = MAPIAllocateMore(cbNew, lpaProps, (LPVOID)&(lpsbNew[i].lpb))) {
        AwDebugError(("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc));
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    lpsbNew[i].cb = cbNew;
    CopyMemory(lpsbNew[i].lpb, lpNew, cbNew);

    lpaProps[index].Value.MVbin.lpbin = lpsbNew;
    lpaProps[index].Value.MVbin.cValues = cExisting + 1;

    return(hResult);
}


/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array LPSZ to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPTSTR lpszNew) {

    SStringArray * lprgszOld = NULL;    // old SString array
    LPTSTR * lppszNew = NULL;           // new prop array
    LPTSTR * lppszOld = NULL;           // old prop array
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;
    ULONG cbNew;

    if (lpszNew) {
        cbNew = lstrlen(lpszNew) + 1;
    } else {
        cbNew = 0;
    }

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_TSTRING, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgszOld = &(lpaProps[index].Value.MVSZ);
        lppszOld = lprgszOld->LPPSZ;

        cExisting = lprgszOld->cValues;
        cbMVP = cExisting * sizeof(LPTSTR);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPTSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = MAPIAllocateMore(cbMVP, lpaProps, (LPVOID)&lppszNew)) {
        AwDebugError(("AddPropToMVPString allocation (%u) failed %x\n", cbMVP, sc));
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lppszNew[i] = lppszOld[i];
    }

    // Add the new property value
    // Allocate room for it
    if (cbNew) {
        if (sc = MAPIAllocateMore(cbNew, lpaProps, (LPVOID)&(lppszNew[i]))) {
            AwDebugError(("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc));
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        lstrcpy(lppszNew[i], lpszNew);

        lpaProps[index].Value.MVSZ.LPPSZ= lppszNew;
        lpaProps[index].Value.MVSZ.cValues = cExisting + 1;

    } else {
        lppszNew[i] = NULL;
    }

    return(hResult);
}


#endif // OLD_STUFF


/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (sc = MAPIFreeBuffer(*lppv)) {
                DebugTrace("MAPIFreeBuffer(%x) -> %s\n", *lppv, SzDecodeScode(sc));
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> %s\n", *lppunk, SzDecodeScode(GetScode(hResult)));
            }
            *lppunk = NULL;
        }
    }
}


#ifdef OLD_STUFF
/***************************************************************************

    Name      : MergeProblemArrays

    Purpose   : Merge a problem array into another

    Parameters: lpPaDest -> destination problem array
                lpPaSource -> source problem array
                cDestMax = total number of problem slots in lpPaDest.  This
                  includes those in use (lpPaDest->cProblem) and those not
                  yet in use.

    Returns   : none

    Comment   :

***************************************************************************/
void MergeProblemArrays(LPSPropProblemArray lpPaDest,
  LPSPropProblemArray lpPaSource, ULONG cDestMax) {
    ULONG i, j;
    ULONG cDest;
    ULONG cDestRemaining;

    cDest = lpPaDest->cProblem;
    cDestRemaining = cDestMax - cDest;

    // Loop through the source problems, copying the non-duplicates into dest
    for (i = 0; i < lpPaSource->cProblem; i++) {
        // Search the Dest problem array for the same property
        for (j = 0; j < cDest; j++) {
            // should just compare PROP_IDs here, since we may be overwriting
            // some of the proptypes with PT_NULL elsewhere.
            if (PROP_ID(lpPaSource->aProblem[i].ulPropTag) == PROP_ID(lpPaDest->aProblem[j].ulPropTag)) {
                break;  // Found a match, don't copy this one.  Move along.
            }
        }

        if (j == lpPaDest->cProblem) {
            Assert(cDestRemaining);
            if (cDestRemaining) {
                // No matches, copy this problem from Source to Dest
                lpPaDest->aProblem[lpPaDest->cProblem++] = lpPaSource->aProblem[i];
                cDestRemaining--;
            } else {
                AwDebugError(("MergeProblemArrays ran out of problem slots!\n"));
            }
        }
    }
}


/***************************************************************************

    Name      : MapObjectNamedProps

    Purpose   : Map the named properties WAB cares about into the object.

    Parameters: lpmp -> IMAPIProp object
                lppPropTags -> returned array of property tags.  Note: Must
                be MAPIFreeBuffer'd by caller.

    Returns   : none

    Comment   : What a pain in the butt!
                We could conceivably improve performance here by caching the
                returned table and comparing the object's PR_MAPPING_SIGNATURE
                against the cache.

***************************************************************************/
HRESULT MapObjectNamedProps(LPMAPIPROP lpmp, LPSPropTagArray * lppPropTags) {
    static GUID guidWABProps = { /* efa29030-364e-11cf-a49b-00aa0047faa4 */
        0xefa29030,
        0x364e,
        0x11cf,
        {0xa4, 0x9b, 0x00, 0xaa, 0x00, 0x47, 0xfa, 0xa4}
    };

    ULONG i;
    LPMAPINAMEID lppmnid[eMaxNameIDs] = {NULL};
    MAPINAMEID rgmnid[eMaxNameIDs] = {0};
    HRESULT hResult = hrSuccess;


    // Loop through each property, setting up the NAME ID structures
    for (i = 0; i < eMaxNameIDs; i++) {

        rgmnid[i].lpguid = &guidWABProps;
        rgmnid[i].ulKind = MNID_STRING;             // Unicode String
        rgmnid[i].Kind.lpwstrName = rgPropNames[i];

        lppmnid[i] = &rgmnid[i];
    }

    if (hResult = lpmp->lpVtbl->GetIDsFromNames(lpmp,
      eMaxNameIDs,      // how many?
      lppmnid,
      MAPI_CREATE,      // create them if they don't already exist
      lppPropTags)) {
        if (HR_FAILED(hResult)) {
            AwDebugError(("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult))));
            goto exit;
        } else {
            DebugTrace("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult)));
        }
    }

    Assert((*lppPropTags)->cValues == eMaxNameIDs);

    AwDebugTrace(("PropTag\t\tType\tProp Name\n"));
    // Loop through the property tags, filling in their property types.
    for (i = 0; i < eMaxNameIDs; i++) {
        (*lppPropTags)->aulPropTag[i] = CHANGE_PROP_TYPE((*lppPropTags)->aulPropTag[i],
          PROP_TYPE(rgulNamedPropTags[i]));
#ifdef DEBUG
        {
            TCHAR szBuffer[257];

            WideCharToMultiByte(CP_ACP, 0, rgPropNames[i], -1, szBuffer, 257, NULL, NULL);

            AwDebugTrace(("%08x\t%s\t%s\n", (*lppPropTags)->aulPropTag[i],
              PropTypeString(PROP_TYPE((*lppPropTags)->aulPropTag[i])), szBuffer));
        }
#endif

    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : PreparePropTagArray

    Purpose   : Prepare a prop tag array by replacing placeholder props tags
                with their named property tags.

    Parameters: ptaStatic = static property tag array (input)
                pptaReturn -> returned prop tag array (output)
                pptaNamedProps -> returned array of named property tags
                    Three possibilities here:
                       + NULL pointer: no input PTA or output named
                           props PTA is returned.  This is less efficient since
                           it must call MAPI to get the named props array.
                       + good pointer to NULL pointer:  no input PTA, but
                           will return a good PTA of named props which can
                           be used in later calls on this object for faster
                           operation.
                       + good pointer to good pointer.  Use the input PTA instead
                           of calling MAPI to map props.  Returned contents must
                           be freed with MAPIFreeBuffer.
                lpObject = object that the properties apply to.  Required if
                    no input *pptaNamedProps is supplied, otherwise, NULL.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT PreparePropTagArray(LPSPropTagArray ptaStatic, LPSPropTagArray * pptaReturn,
  LPSPropTagArray * pptaNamedProps, LPMAPIPROP lpObject) {
    HRESULT hResult = hrSuccess;
    ULONG cbpta;
    LPSPropTagArray ptaTemp = NULL;
    LPSPropTagArray ptaNamedProps;
    ULONG i;

    if (pptaNamedProps) {
        // input Named Props PTA
        ptaNamedProps = *pptaNamedProps;
    } else {
        ptaNamedProps = NULL;
    }

    if (! ptaNamedProps) {
        if (! lpObject) {
            AwDebugError(("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n"));
            hResult = ResultFromScode(E_INVALIDARG);
            goto exit;
        }

        // Map the property names into the object
        if (hResult = MapObjectNamedProps(lpObject, &ptaTemp)) {
            AwDebugError(("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n"));
            goto exit;
        }
    }

    if (pptaReturn) {
        // Allocate a return pta
        cbpta = sizeof(SPropTagArray) + ptaStatic->cValues * sizeof(ULONG);
        if ((*pptaReturn = WABAlloc(cbpta)) == NULL) {
            AwDebugError(("PreparePropTagArray WABAlloc(%u) failed\n", cbpta));
            hResult = ResultFromScode(E_OUTOFMEMORY);
            goto exit;
        }

        (*pptaReturn)->cValues = ptaStatic->cValues;

        // Walk through the ptaStatic looking for named property placeholders.
        for (i = 0; i < ptaStatic->cValues; i++) {
            if (IS_PLACEHOLDER(ptaStatic->aulPropTag[i])) {
                // Found a placeholder.  Turn it into a true property tag
                Assert(PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i]) < ptaNamedProps->cValues);
                (*pptaReturn)->aulPropTag[i] =
                   ptaNamedProps->aulPropTag[PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i])];
            } else {
                (*pptaReturn)->aulPropTag[i] = ptaStatic->aulPropTag[i];
            }
        }
    }

exit:
    if (hResult || ! pptaNamedProps) {
        FreeBufferAndNull(&ptaTemp);
    } else {
        // Client is responsible for freeing this.
        *pptaNamedProps = ptaNamedProps;
    }

    return(hResult);
}


/***************************************************************************

    Name      : OpenCreateProperty

    Purpose   : Open an interface on a property or create if non-existent.

    Parameters: lpmp -> IMAPIProp object to open prop on
                ulPropTag = property tag to open
                lpciid -> interface identifier
                ulInterfaceOptions = interface specific flags
                ulFlags = MAPI_MODIFY?
                lppunk -> return the object here

    Returns   : HRESULT

    Comment   : Caller is responsible for Release'ing the returned object.

***************************************************************************/
HRESULT OpenCreateProperty(LPMAPIPROP lpmp,
  ULONG ulPropTag,
  LPCIID lpciid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppunk) {

    HRESULT hResult;

    if (hResult = lpmp->lpVtbl->OpenProperty(
      lpmp,
      ulPropTag,
      lpciid,
      ulInterfaceOptions,
      ulFlags,
      (LPUNKNOWN *)lppunk)) {
        AwDebugTrace(("OpenCreateProperty:OpenProperty(%s)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult))));
        // property doesn't exist... try to create it
        if (hResult = lpmp->lpVtbl->OpenProperty(
          lpmp,
          ulPropTag,
          lpciid,
          ulInterfaceOptions,
          MAPI_CREATE | ulFlags,
          (LPUNKNOWN *)lppunk)) {
            AwDebugTrace(("OpenCreateProperty:OpenProperty(%s, MAPI_CREATE)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult))));
        }
    }

    return(hResult);
}
#endif // OLD_STUFF


#ifdef DEBUG
/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value %s\n", SzDecodeScode(PropValue.Value.err));
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>\n");    //
    }
#endif
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {
        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: %s\n", SzDecodeScode(lpProps[i].Value.err));
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
//                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY Value\n");
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 Value\n");
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(&lpProps);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp, "ROW %u", wIndex);

            DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            FreeProws(lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\wabsub.cpp ===
#include "wabtest.h"
#include <assert.h>

#include "resource.h"
#include "..\luieng.dll\luieng.h"

extern LUIOUT LUIOut;
extern BOOL bLUIInit;

#ifdef WAB
extern LPWABOBJECT		lpWABObject; //Global handle to session
#endif

#ifdef PAB
MAPIINIT_0 mapiinit = {    
            MAPI_INIT_VERSION,
            MAPI_MULTITHREAD_NOTIFICATIONS
            };

#endif //PAB


PropTableEntry	PropTable[] = {
		PR_7BIT_DISPLAY_NAME, "PR_7BIT_DISPLAY_NAME", 0,
		PR_ACCOUNT, "PR_ACCOUNT", 0,
		PR_ADDRTYPE, "PR_ADDRTYPE", 0,
		PR_ALTERNATE_RECIPIENT, "PR_ALTERNATE_RECIPIENT", 0,
		PR_ASSISTANT, "PR_ASSISTANT", 0,
		PR_ASSISTANT_TELEPHONE_NUMBER, "PR_ASSISTANT_TELEPHONE_NUMBER", 0,
		PR_BEEPER_TELEPHONE_NUMBER, "PR_BEEPER_TELEPHONE_NUMBER", 0,
		PR_BIRTHDAY, "PR_BIRTHDAY", 0,
		PR_BUSINESS_ADDRESS_CITY, "PR_BUSINESS_ADDRESS_CITY", 0,
		PR_BUSINESS_ADDRESS_COUNTRY, "PR_BUSINESS_ADDRESS_COUNTRY", 0,
		PR_BUSINESS_ADDRESS_POST_OFFICE_BOX, "PR_BUSINESS_ADDRESS_POST_OFFICE_BOX", 0,
		PR_BUSINESS_ADDRESS_POSTAL_CODE, "PR_BUSINESS_ADDRESS_POSTAL_CODE", 0,
		PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE, "PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE", 0,
		PR_BUSINESS_ADDRESS_STREET, "PR_BUSINESS_ADDRESS_STREET", 0,
		PR_BUSINESS_FAX_NUMBER, "PR_BUSINESS_FAX_NUMBER", 0,
		PR_BUSINESS_HOME_PAGE, "PR_BUSINESS_HOME_PAGE", 0,
		PR_BUSINESS_TELEPHONE_NUMBER, "PR_BUSINESS_TELEPHONE_NUMBER", 0,
		PR_BUSINESS2_TELEPHONE_NUMBER, "PR_BUSINESS2_TELEPHONE_NUMBER", 0, 
		PR_CALLBACK_TELEPHONE_NUMBER, "PR_CALLBACK_TELEPHONE_NUMBER", 0,
		PR_CAR_TELEPHONE_NUMBER, "PR_CAR_TELEPHONE_NUMBER", 0,
		PR_CELLULAR_TELEPHONE_NUMBER, "PR_CELLULAR_TELEPHONE_NUMBER", 0,
		PR_CHILDRENS_NAMES, "PR_CHILDRENS_NAMES", 0,
		PR_COMMENT, "PR_COMMENT", 0,
		PR_COMPANY_MAIN_PHONE_NUMBER, "PR_COMPANY_MAIN_PHONE_NUMBER", 0,
		PR_COMPANY_NAME, "PR_COMPANY_NAME", 0,
		PR_COMPUTER_NETWORK_NAME, "PR_COMPUTER_NETWORK_NAME", 0,
		PR_CONTACT_ADDRTYPES, "PR_CONTACT_ADDRTYPES", 0,
		PR_CONTACT_DEFAULT_ADDRESS_INDEX, "PR_CONTACT_DEFAULT_ADDRESS_INDEX", 0,
		PR_CONTACT_EMAIL_ADDRESSES, "PR_CONTACT_EMAIL_ADDRESSES", 0,
		PR_CONTACT_ENTRYIDS, "PR_CONTACT_ENTRYIDS", 0,
		PR_CONTACT_VERSION, "PR_CONTACT_VERSION", 0,
		PR_CONVERSION_PROHIBITED, "PR_CONVERSION_PROHIBITED", 0,
		PR_COUNTRY, "PR_COUNTRY", 0,
		PR_CUSTOMER_ID, "PR_CUSTOMER_ID", 0,
		PR_DEPARTMENT_NAME, "PR_DEPARTMENT_NAME", 0,
		PR_DISCLOSE_RECIPIENTS, "PR_DISCLOSE_RECIPIENTS", 0,
		PR_DISPLAY_NAME, "PR_DISPLAY_NAME", 0,
		PR_DISPLAY_NAME_PREFIX, "PR_DISPLAY_NAME_PREFIX", 0,
		PR_EMAIL_ADDRESS, "PR_EMAIL_ADDRESS", 0,
		PR_ENTRYID, "PR_ENTRYID", 0,
		PR_FTP_SITE, "PR_FTP_SITE", 0,
		PR_GENDER, "PR_GENDER", 0,
		PR_GENERATION, "PR_GENERATION", 0,
		PR_GIVEN_NAME, "PR_GIVEN_NAME", 0,
		PR_GOVERNMENT_ID_NUMBER, "PR_GOVERNMENT_ID_NUMBER", 0,
		PR_HOBBIES, "PR_HOBBIES", 0,
		PR_HOME_ADDRESS_CITY, "PR_HOME_ADDRESS_CITY", 0,
		PR_HOME_ADDRESS_COUNTRY, "PR_HOME_ADDRESS_COUNTRY", 0,
		PR_HOME_ADDRESS_POST_OFFICE_BOX, "PR_HOME_ADDRESS_POST_OFFICE_BOX", 0,
		PR_HOME_ADDRESS_POSTAL_CODE, "PR_HOME_ADDRESS_POSTAL_CODE", 0,
		PR_HOME_ADDRESS_STATE_OR_PROVINCE, "PR_HOME_ADDRESS_STATE_OR_PROVINCE", 0,
		PR_HOME_ADDRESS_STREET, "PR_HOME_ADDRESS_STREET", 0,
		PR_HOME_FAX_NUMBER, "PR_HOME_FAX_NUMBER", 0,
		PR_HOME_TELEPHONE_NUMBER, "PR_HOME_TELEPHONE_NUMBER", 0,
		PR_HOME2_TELEPHONE_NUMBER, "PR_HOME2_TELEPHONE_NUMBER", 0,
		PR_INITIALS, "PR_INITIALS", 0,
		PR_ISDN_NUMBER, "PR_ISDN_NUMBER", 0,
		PR_KEYWORD, "PR_KEYWORD", 0,
		PR_LANGUAGE, "PR_LANGUAGE", 0,
		PR_LOCALITY, "PR_LOCALITY", 0,
		PR_LOCATION, "PR_LOCATION", 0,
		PR_MAIL_PERMISSION, "PR_MAIL_PERMISSION", 0,
		PR_MANAGER_NAME, "PR_MANAGER_NAME", 0,
		PR_MHS_COMMON_NAME, "PR_MHS_COMMON_NAME", 0,
		PR_MIDDLE_NAME, "PR_MIDDLE_NAME", 0,
		PR_MOBILE_TELEPHONE_NUMBER, "PR_MOBILE_TELEPHONE_NUMBER", 0,
		PR_NICKNAME, "PR_NICKNAME", 0,
		PR_OBJECT_TYPE, "PR_OBJECT_TYPE", 0,
		PR_OFFICE_LOCATION, "PR_OFFICE_LOCATION", 0,
		PR_OFFICE_TELEPHONE_NUMBER, "PR_OFFICE_TELEPHONE_NUMBER", 0,
		PR_OFFICE2_TELEPHONE_NUMBER, "PR_OFFICE2_TELEPHONE_NUMBER", 0,
		PR_ORGANIZATIONAL_ID_NUMBER, "PR_ORGANIZATIONAL_ID_NUMBER", 0,
		PR_ORIGINAL_DISPLAY_NAME, "PR_ORIGINAL_DISPLAY_NAME", 0,
		PR_ORIGINAL_ENTRYID, "PR_ORIGINAL_ENTRYID", 0,
		PR_ORIGINAL_SEARCH_KEY, "PR_ORIGINAL_SEARCH_KEY", 0,
		PR_OTHER_ADDRESS_CITY, "PR_OTHER_ADDRESS_CITY", 0,
		PR_OTHER_ADDRESS_COUNTRY, "PR_OTHER_ADDRESS_COUNTRY", 0,
		PR_OTHER_ADDRESS_POST_OFFICE_BOX, "PR_OTHER_ADDRESS_POST_OFFICE_BOX", 0,
		PR_OTHER_ADDRESS_POSTAL_CODE, "PR_OTHER_ADDRESS_POSTAL_CODE", 0,
		PR_OTHER_ADDRESS_STATE_OR_PROVINCE, "PR_OTHER_ADDRESS_STATE_OR_PROVINCE", 0,
		PR_OTHER_ADDRESS_STREET,"PR_OTHER_ADDRESS_STREET", 0,
		PR_OTHER_TELEPHONE_NUMBER, "PR_OTHER_TELEPHONE_NUMBER", 0,
		PR_PAGER_TELEPHONE_NUMBER, "PR_PAGER_TELEPHONE_NUMBER", 0,
		PR_PERSONAL_HOME_PAGE, "PR_PERSONAL_HOME_PAGE", 0,
		PR_POST_OFFICE_BOX, "PR_POST_OFFICE_BOX", 0,
		PR_POSTAL_ADDRESS, "PR_POSTAL_ADDRESS", 0,
		PR_POSTAL_CODE, "PR_POSTAL_CODE", 0,
		PR_PREFERRED_BY_NAME, "PR_PREFERRED_BY_NAME", 0,
		PR_PRIMARY_FAX_NUMBER, "PR_PRIMARY_FAX_NUMBER", 0,
		PR_PRIMARY_TELEPHONE_NUMBER, "PR_PRIMARY_TELEPHONE_NUMBER", 0,
		PR_PROFESSION, "PR_PROFESSION", 0,
		PR_RADIO_TELEPHONE_NUMBER, "PR_RADIO_TELEPHONE_NUMBER", 0,
		PR_SEND_RICH_INFO, "PR_SEND_RICH_INFO", 0,
		PR_SPOUSE_NAME, "PR_SPOUSE_NAME", 0,
		PR_STATE_OR_PROVINCE, "PR_STATE_OR_PROVINCE", 0,
		PR_STREET_ADDRESS, "PR_STREET_ADDRESS", 0,
		PR_SURNAME, "PR_SURNAME", 0,
		PR_TELEX_NUMBER, "PR_TELEX_NUMBER", 0,
		PR_TITLE, "PR_TITLE", 0,
		PR_TRANSMITABLE_DISPLAY_NAME, "PR_TRANSMITABLE_DISPLAY_NAME", 0, 
		PR_TTYTDD_PHONE_NUMBER, "PR_TTYTDD_PHONE_NUMBER", 0,
		PR_USER_CERTIFICATE, "PR_USER_CERTIFICATE", 0,
		PR_WEDDING_ANNIVERSARY, "PR_WEDDING_ANNIVERSARY", 0,
		PR_USER_X509_CERTIFICATE, "PR_USER_X509_CERTIFICATE", 0,

		(ULONG)0, "End of Table", 0
	};



HRESULT OpenPABID(  IN  LPADRBOOK  lpAdrBook,
                        OUT ULONG		*lpcbEidPAB,
                        OUT LPENTRYID	*lppEidPAB,
                        OUT LPABCONT	*lppPABCont,
						OUT ULONG		*lpulObjType)
{
    HRESULT     hr          = hrSuccess;
	int retval = TRUE;

    *lpulObjType = 0;

    if ( (NULL == lpcbEidPAB) || 
         (NULL == lppEidPAB) ||
         (NULL == lppPABCont) ) 
         return(FALSE);

    *lpcbEidPAB = 0;
    *lppEidPAB  = NULL;
    *lppPABCont = NULL;


    //
    // Get the PAB
    //
    hr = lpAdrBook->GetPAB(    
                     OUT lpcbEidPAB,
                     OUT lppEidPAB);
     
    if (HR_FAILED(hr)) {
		 retval = FALSE;
         goto out;
	}
    
    if (0 == *lpcbEidPAB)  //There is no PAB associated with this profile
	{
		LUIOut(L2, "Call to GetPAB FAILED. No PAB associated with this profile"); 
		retval = FALSE;
        goto out;
	}
     
    
    //
    // Open the PAB Container
    //
    hr = lpAdrBook->OpenEntry(
                     IN	 *lpcbEidPAB,
                     IN	 *lppEidPAB,
                     IN	 NULL,         //interface
                     IN	 MAPI_MODIFY,   //flags
                     OUT lpulObjType,
                     OUT (LPUNKNOWN *) lppPABCont);
     
    if (0 == *lpulObjType) {
		retval = FALSE;
        goto out;
	}

out:
    return(retval); 
}


#ifdef PAB
BOOL MapiInitLogon(OUT LPMAPISESSION * lppMAPISession)
{

    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	char szProfileName[SML_BUF];

	hr = MAPIInitialize(IN & mapiinit); 
	

    if (hr)
    {
	   if (FAILED (GetScode(hr))) {
			LUIOut(L1,"Could not initialize MAPI\n");
			retval=FALSE;
	   }
    }

	szProfileName[0]='\0';
	GetPrivateProfileString("Misc","Profile","",szProfileName,SML_BUF,"c:\\pabtests.ini");

     sc = MAPILogonEx(
                IN  0,                 //window handle
                IN  szProfileName,   //Profile Name
                IN  NULL,              //Password
                IN  MAPI_NEW_SESSION | 
                    MAPI_EXTENDED | 
                    MAPI_LOGON_UI |
                    MAPI_EXPLICIT_PROFILE |
					MAPI_ALLOW_OTHERS |
					MAPI_NO_MAIL,      //Flags
                OUT lppMAPISession);   //Session Pointer address
     
     if (FAILED(sc))
     {
        hr = ResultFromScode(sc);
        LUIOut(L1,"Could not start MAPI Session");
		retval=FALSE;
     }
	 return retval;
}

#endif //PAB

BOOL GetPropsFromIniBufEntry(LPSTR EntryBuf,ULONG cValues, char (*EntProp)[BIG_BUF])
{
//char szTemp[BIG_BUF];
int j=0;
	if (EntryBuf) {	
		for (int i = 0; i < (int)cValues; i++) {
			if ((*EntryBuf) == '"') {
				EntryBuf++;
			}
			j=0;
			while ((*EntryBuf)&&((*EntryBuf) != '"')&&(j< BIG_BUF-1)) {

				EntProp[i][j]= *EntryBuf;
				j++; EntryBuf++;
			}
			EntProp[i][j]='\0'; 
			if (*EntryBuf) EntryBuf++;
			if ((*EntryBuf)&&((*EntryBuf) == ',')) EntryBuf++;
		}
		return TRUE;
	}
	else {
		for (int i = 0; i < (int)cValues; i++) {
			EntProp[i][0]=0;
		}
		return FALSE;
	}
}


HRESULT HrCreateEntryListFromID(
					IN LPWABOBJECT lpLocalWABObject,
                    IN ULONG cbeid,                     // count of bytes in Entry ID
                    IN LPENTRYID lpeid,                 // pointer to Entry ID
                    OUT LPENTRYLIST FAR *lppEntryList)  // pointer to address variable of Entry
                                                        // list
{
    HRESULT hr              = NOERROR;
    SCODE   sc              = 0;
    LPVOID  lpvSBinaryArray = NULL;
    LPVOID  lpvSBinary      = NULL;
    LPVOID  lpv             = NULL;

    
    if (NULL == lppEntryList) return(FALSE);

    *lppEntryList = NULL;


#ifdef PAB
    sc = MAPIAllocateBuffer(cbeid, &lpv);                  
#endif
#ifdef WAB
    sc = lpLocalWABObject->AllocateBuffer(cbeid, &lpv);                  
#endif


    if(FAILED(sc))                           
    {                                                   
        hr = ResultFromScode(sc);
        goto cleanup;
    }                                                   

  
    // Copy entry ID
    CopyMemory(lpv, lpeid, cbeid);


#ifdef PAB
    sc = MAPIAllocateBuffer(sizeof(SBinary), &lpvSBinary);
#endif
#ifdef WAB
    sc = lpLocalWABObject->AllocateBuffer(sizeof(SBinary), &lpvSBinary);
#endif

    if(FAILED(sc))                           
    {                                                   
        hr = ResultFromScode(sc);
        goto cleanup;
    }                                                   

    // Initialize SBinary structure
    ZeroMemory(lpvSBinary, sizeof(SBinary));

    ((LPSBinary)lpvSBinary)->cb = cbeid;
    ((LPSBinary)lpvSBinary)->lpb = (LPBYTE)lpv;

#ifdef PAB
	sc = MAPIAllocateBuffer(sizeof(SBinaryArray), &lpvSBinaryArray);
#endif
#ifdef WAB
	sc = lpLocalWABObject->AllocateBuffer(sizeof(SBinaryArray), &lpvSBinaryArray);
#endif

    if(FAILED(sc))                           
    {                                                   
        hr = ResultFromScode(sc);
        goto cleanup;
    }                                                   

    // Initialize SBinaryArray structure
    ZeroMemory(lpvSBinaryArray, sizeof(SBinaryArray));

    ((SBinaryArray *)lpvSBinaryArray)->cValues = 1;
    ((SBinaryArray *)lpvSBinaryArray)->lpbin = (LPSBinary)lpvSBinary;

    *lppEntryList = (LPENTRYLIST)lpvSBinaryArray;

cleanup:

    if (HR_FAILED(hr))
    {
#ifdef PAB
        if (lpv)
            MAPIFreeBuffer(lpv);
        
        if (lpvSBinary)
            MAPIFreeBuffer(lpvSBinary);

        if (lpvSBinaryArray)
            MAPIFreeBuffer(lpvSBinaryArray);
#endif
#ifdef WAB
        if (lpv)
            lpLocalWABObject->FreeBuffer(lpv);
        
        if (lpvSBinary)
            lpLocalWABObject->FreeBuffer(lpvSBinary);

        if (lpvSBinaryArray)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray);
#endif
    }

    return(hr);

}



HRESULT HrCreateEntryListFromRows(
			IN LPWABOBJECT lpLocalWABObject,
			IN LPSRowSet far* lppRows,
			OUT LPENTRYLIST FAR *lppEntryList)  // pointer to address variable of Entry
                                                // list
{	LPSRowSet		lpRows = *lppRows;
    HRESULT			hr              = NOERROR;
    SCODE			sc              = 0;
    SBinaryArray*	lpvSBinaryArray = NULL;
	ULONG			Rows			= lpRows->cRows;
	unsigned int	PropIndex;					
	ULONG			cb;
	LPENTRYID		lpb;


    
    if (NULL == lppEntryList) return(FALSE);

    *lppEntryList = NULL;
	if (lpRows) {
		// Allocate the SBinaryArray
		sc = lpLocalWABObject->AllocateBuffer(sizeof(SBinaryArray), (void**)&lpvSBinaryArray);
		if(FAILED(sc))                           
		{   
			LUIOut(L2, "HrCreateEntryListFromRows: Unable to allocate memory for the SBinaryArray.");
			hr = ResultFromScode(sc);
			goto cleanup;
		}                                                   
		// Initialize SBinaryArray structure
		ZeroMemory(lpvSBinaryArray, sizeof(SBinaryArray));
		lpvSBinaryArray->cValues = Rows;
		
		// Allocate the SBinary structures
		sc = lpLocalWABObject->AllocateBuffer((Rows*sizeof(SBinary)), (void**)&lpvSBinaryArray->lpbin);
		if(FAILED(sc))                           
		{                                                   
			LUIOut(L2, "HrCreateEntryListFromRows: Unable to allocate memory for the SBinary structures.");
			hr = ResultFromScode(sc);
			goto cleanup;
		}                                                   
		// Initialize SBinary structure
		ZeroMemory(lpvSBinaryArray->lpbin, (Rows*sizeof(SBinary)));
		FindPropinRow(&lpRows->aRow[0],			// Find which column has the EID 
					  PR_ENTRYID,
					  &PropIndex);
		
		// Walk through the rows, allocate the lpb and copy over each cbeid and lpb into the entrylist
		for (ULONG Row = 0; Row < Rows; Row++) {
			cb = lpRows->aRow[Row].lpProps[PropIndex].Value.bin.cb,
			lpb = (ENTRYID*)lpRows->aRow[Row].lpProps[PropIndex].Value.bin.lpb,
			sc = lpLocalWABObject->AllocateBuffer(cb, (void**)&(lpvSBinaryArray->lpbin[Row].lpb));
			if(FAILED(sc))                           
			{                                                   
				LUIOut(L2, "HrCreateEntryListFromRows: Unable to allocate memory for the SBinary->lpb.");
				hr = ResultFromScode(sc);
				goto cleanup;
			}                                                   
		    // Copy entry ID
		    lpvSBinaryArray->lpbin[Row].cb = cb;
		    CopyMemory(lpvSBinaryArray->lpbin[Row].lpb, lpb, cb);
		}
	    *lppEntryList = (LPENTRYLIST)lpvSBinaryArray;
		return TRUE;
	}
	return FALSE;

cleanup:

    if (HR_FAILED(hr))
    {
		for (ULONG Kill=0; Kill<Rows; Kill++) {
			if (lpvSBinaryArray->lpbin[Kill].lpb)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray->lpbin[Kill].lpb);
			lpvSBinaryArray->lpbin[Kill].lpb = NULL;
		}
        
        if (lpvSBinaryArray->lpbin)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray->lpbin);

        if (lpvSBinaryArray)
            lpLocalWABObject->FreeBuffer(lpvSBinaryArray);
    }

    return(hr);

}


BOOL FreeEntryList(IN LPWABOBJECT lpLocalWABObject,
				   IN LPENTRYLIST *lppEntryList) // pointer to address variable of Entry
														// list
{	LPENTRYLIST	lpEntryList = *lppEntryList;

	if (lpEntryList == NULL) return FALSE;
	for (ULONG Row = 0; Row < lpEntryList->cValues; Row++) {
		if (lpEntryList->lpbin[Row].lpb)
            lpLocalWABObject->FreeBuffer(lpEntryList->lpbin[Row].lpb);
	}
        
    if (lpEntryList->lpbin)
        lpLocalWABObject->FreeBuffer(lpEntryList->lpbin);

    if (lpEntryList)
        lpLocalWABObject->FreeBuffer(lpEntryList);

	*lppEntryList = NULL;
	return TRUE;
}

BOOL FreeRows(IN LPWABOBJECT lpLocalWABObject,
			  IN LPSRowSet far* lppRows)
{	LPSRowSet lpRows = *lppRows;

#ifdef WAB
	if (lpRows) {
		for (ULONG Kill = 0; Kill < lpRows->cRows; Kill++) 
			lpLocalWABObject->FreeBuffer(lpRows->aRow[Kill].lpProps);
		lpLocalWABObject->FreeBuffer(lpRows);
		*lppRows = NULL;
#endif
		return TRUE;
	}
	return FALSE;
}
	

BOOL DisplayRows(IN LPSRowSet lpRows)
{	ULONG	Rows, Columns;
	WORD*	Key;
	if (lpRows) {
		Rows = lpRows->cRows;
		LUIOut(L2, "%u rows found.", Rows);
		for (ULONG Row = 0; Row < Rows; Row++) {
			Columns = lpRows->aRow[Row].cValues;
			LUIOut(L3, "Row %u contains %u columns.", Row, Columns);
			for (ULONG Column = 0; Column < Columns; Column++) {
				switch(lpRows->aRow[Row].lpProps[Column].ulPropTag) {
				case PR_ADDRTYPE:
					LUIOut(L3, "Column %u: PR_ADDRTYPE = %s", Column, lpRows->aRow[Row].lpProps[Column].Value.LPSZ); 
					break;
				case PR_DISPLAY_NAME:
					LUIOut(L3, "Column %u: PR_DISPLAY_NAME = %s", Column, lpRows->aRow[Row].lpProps[Column].Value.LPSZ); 
					break;
				case PR_DISPLAY_TYPE:
					switch(lpRows->aRow[Row].lpProps[Column].Value.l) {
					case DT_AGENT:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_AGENT", Column); 
						break;
					case DT_DISTLIST:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_DISTLIST", Column); 
						break;
					case DT_FORUM:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_FORUM", Column); 
						break;
					case DT_MAILUSER:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_MAILUSER", Column); 
						break;
					case DT_ORGANIZATION:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_ORGANIZATION", Column); 
						break;
					case DT_PRIVATE_DISTLIST:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_PRIVATE_DISTLIST", Column); 
						break;
					case DT_REMOTE_MAILUSER:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = DT_REMOTE_MAILUSER", Column); 
						break;
					default:
						LUIOut(L3, "Column %u: PR_DISPLAY_TYPE = UNKNOWN!! [0x%x]", Column,
								lpRows->aRow[Row].lpProps[Column].Value.l); 
					}
					break;
				case PR_ENTRYID:
					LUIOut(L3, "Column %u: PR_ENTRYID", Column); 
					break;
				case PR_INSTANCE_KEY:
					Key = (WORD*)lpRows->aRow[Row].lpProps[Column].Value.bin.lpb;
					LUIOut(L3, "Column %u: PR_INSTANCE_KEY = 0x%x%x%x%x%x%x%x%x", Column,
							Key[0],Key[2],Key[4],Key[6],Key[8],Key[10],Key[12],Key[14]); 
					break;
				case PR_OBJECT_TYPE:
					switch(lpRows->aRow[Row].lpProps[Column].Value.l) {
					case MAPI_ABCONT:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_ABCONT", Column); 
						break;
					case MAPI_ADDRBOOK:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_ADDRBOOK", Column); 
						break;
					case MAPI_ATTACH:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_ATTACH", Column); 
						break;
					case MAPI_DISTLIST:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_DISTLIST", Column); 
						break;
					case MAPI_FOLDER:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_FOLDER", Column); 
						break;
					case MAPI_FORMINFO:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_FORMINFO", Column); 
						break;
					case MAPI_MAILUSER:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_MAILUSER", Column); 
						break;
					case MAPI_MESSAGE:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_MESSAGE", Column); 
						break;
					case MAPI_PROFSECT:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_PROFSECT", Column); 
						break;
					case MAPI_STATUS:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_STATUS", Column); 
						break;
					case MAPI_STORE:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = MAPI_STORE", Column); 
						break;
					default:
						LUIOut(L3, "Column %u: PR_OBJECT_TYPE = UNKNOWN!! [0x%x]", Column,
								lpRows->aRow[Row].lpProps[Column].Value.l); 
					}
					break;
				case PR_RECORD_KEY:
					LUIOut(L3, "Column %u: PR_RECORD_KEY", Column); 
					break;
				default:
					LUIOut(L3, "Column %u: Property tag UNKNOWN!! [0x%x]", Column,
							lpRows->aRow[Row].lpProps[Column].ulPropTag); 
				}
			}
		}
		return TRUE;
	}
	return FALSE;
}
	


BOOL ValidateAdrList(LPADRLIST lpAdrList, ULONG cEntries)
{
	int         i           = 0;
	int         idx         = 0;
	int         cMaxProps   = 0;

	for(i=0; i<(int) cEntries; ++i)
	{
	cMaxProps = (int)lpAdrList->aEntries[i].cValues;
	//Check to see if Email Address Type exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ADDRTYPE )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_ADDRTYPE was not found in the lpAdrList");
			return FALSE;
		}
	}

	//Check to see if Email Address exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_OBJECT_TYPE )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_OBJECT_TYPE was not found in the lpAdrList");
			return FALSE;
		}
	}

	//Check to see if Email Address exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_TYPE )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_DISPLAY_TYPE was not found in the lpAdrList");
			return FALSE;
		}
	}
	
	//Check to see if Display Name exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )
	{
		idx++;
		if(idx == cMaxProps) {
			LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
			return FALSE;
		}
	}
	LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);

	//Check to see if EntryID exists
	idx=0;
	while(lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )
	{
		idx++;
		if(idx == cMaxProps)	{
			LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
			return FALSE;
		}
	}
	}
	return TRUE;
}


//
// PROCEDURE:	VerifyResolvedAdrList
// DESCRIPTION: Walk through a lpAdrList looking for PR_DISPLAY_NAME, PR_EMAIL_ADDRESS,
//				PR_ADDRTYPE, PR_ENTRYID, and PR_OBJECT_TYPE. Each EID is sanity checked
//				(lpb != NULL and cb != 0) and valid EIDs are passed to OpenEntry with
//				a MailUser interface specified. If OpenEntry succedes, we assume the EID
//				is a valid MailUser ID.
//				
// PARAMETERS:	LPADRLIST lpAdrList 
//				char* lpszInput - can be NULL to bypass match checking
//

BOOL VerifyResolvedAdrList(LPADRLIST lpAdrList, char* lpszInput)
{
	extern LPADRBOOK	glbllpAdrBook;
	int		i = 0, idx = 0, cMaxProps = 0;
	BOOL	Found = FALSE, retval = TRUE, localretval = TRUE;
	ULONG	cEntries = lpAdrList->cEntries;
	ULONG	cbLookupEID, ulObjType;
	LPENTRYID	lpLookupEID;
	HRESULT	hr;
	LPUNKNOWN	lpUnk=NULL;
	LPADRBOOK	lpAdrBook;
	LPCIID		lpcIID;
	LPVOID	Reserved1=NULL;
	DWORD	Reserved2=0;
//	LPWABOBJECT	lpWABObject2;
	

/*	kludge to work around multiple wabopen/release bug, storing adrbook ptr
	in a global variable

	hr = WABOpen(&lpAdrBook, &lpWABObject2, Reserved1, Reserved2); 
	if (hr != S_OK) {
		LUIOut(L4, "WABOpen FAILED. Couldn't obtain IAdrBook.");
		retval = FALSE;
	}

*/
#ifdef WAB
	lpAdrBook = glbllpAdrBook;
	lpAdrBook->AddRef();
#endif //WAB

	
	// Walk through each AdrList entry
	for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
		LUIOut(L3, "Searching Entry #%i out of %i", i+1, cEntries);
		cMaxProps = (int)lpAdrList->aEntries[i].cValues;
		
		//Check to see if Display Name exists
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps) {
				LUIOut(L4, "PR_DISPLAY_NAME was not found in lpAdrList entry #%i",i);
				localretval = FALSE; retval = FALSE;
				goto skip;
			}
		}
		LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
		if (lpszInput) {
			if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput))	{
				LUIOut(L3, "Found the entry we just added");
				Found = TRUE;
			}
			else {
				LUIOut(L3, "Did not find the entry we just added");
				retval = FALSE;
			}
		}
		
		//Check to see if EntryID exists
		LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
				localretval = FALSE; retval = FALSE;
				goto skip;
			}
		}
		if (idx < cMaxProps) {
			// Store EID for call to OpenEntry
			lpLookupEID = (ENTRYID*)lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.lpb;
			cbLookupEID = lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.cb;
			if ((cbLookupEID == 0) || (lpLookupEID == NULL)) {
				LUIOut(L4, "EntryID found, but is NULL or has size = 0. Test FAILED");
				retval = FALSE;
				goto skip;
			}
			else LUIOut(L4, "EntryID found and appears to be valid (not NULL and >0 size).");
			// Try calling OpenEntry on the returned EID specifying a mailuser interface
			LUIOut(L4, "Calling OpenEntry on the EntryID");
			lpcIID = &IID_IMailUser;
			hr = lpAdrBook->OpenEntry(cbLookupEID, lpLookupEID, lpcIID, 
					MAPI_BEST_ACCESS, &ulObjType, &lpUnk);
			switch(hr)	{
			case S_OK:
				if ((lpUnk) && (ulObjType==MAPI_MAILUSER))
					LUIOut(L4, "OpenEntry call succeded on this EntryID and returned a valid object pointer and type.");
				else	{
					LUIOut(L4, "OpenEntry call succeded on this EntryID but returned an invalid object pointer or incorrect type. Test FAILED");
					retval = FALSE;
				}
				break;
			case MAPI_E_NOT_FOUND:
				LUIOut(L4, "OpenEntry returned MAPI_E_NOT_FOUND for this EntryID. Test FAILED");
				retval = FALSE;
				break;
			case MAPI_E_UNKNOWN_ENTRYID:
				LUIOut(L4, "OpenEntry returned MAPI_E_UNKNOWN_ENTRYID for this EntryID. Test FAILED");
				retval = FALSE;
				break;
			case MAPI_E_NO_ACCESS:
				LUIOut(L4, "OpenEntry returned MAPI_E_NO_ACCESS for this EntryID. Test FAILED");
				retval = FALSE;
				break;
			default:
				LUIOut(L4, "OpenEntry returned unknown result code (0x%x) for this EntryID. Test FAILED", hr);
				retval = FALSE;
				lpUnk = NULL;
				break;
			}
		}

		//Check to see if PR_EMAIL_ADDRESS exists
		LUIOut(L3, "Verifying a PR_EMAIL_ADDRESS entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_EMAIL_ADDRESS )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_EMAIL_ADDRESS was not found in the lpAdrList");
				localretval = FALSE; //retval = FALSE;
			}
		}
		if (idx < cMaxProps) {
			LUIOut(L4,"Email Address: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
		}

		//Check to see if PR_ADDRTYPE exists
		LUIOut(L3, "Verifying a PR_ADDRTYPE entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ADDRTYPE )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_ADDRTYPE was not found in the lpAdrList");
				localretval = FALSE; //retval = FALSE;
			}
		}
		if (idx < cMaxProps) {
			LUIOut(L4,"Address Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
		}

		//Check to see if PR_OBJECT_TYPE exists
		LUIOut(L3, "Verifying a PR_OBJECT_TYPE entry exists in the PropertyTagArray");
		idx=0; localretval = TRUE;
		while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_OBJECT_TYPE )	
			&& localretval)	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_OBJECT_TYPE was not found in the lpAdrList");
				localretval = FALSE; retval = FALSE;
			}
		}
		if (idx < cMaxProps) {
			switch (lpAdrList->aEntries[i].rgPropVals[idx].Value.l) {
			case MAPI_MAILUSER: 
				LUIOut(L4, "Object Type: MAPI_MAILUSER");
				break;
			case MAPI_DISTLIST: 
				LUIOut(L4, "Object Type: MAPI_DISTLIST");
				break;
			default: 
				LUIOut(L4,"Object Type not MAILUSER or DISTLIST. Test FAILED");
			}
		}


skip:	// skip the current entry and continue through the lpAdrList
	if (lpUnk) lpUnk->Release();	//Release the object returned from OpenEntry
	}
	if (lpAdrBook) lpAdrBook->Release();
	//if (lpWABObject2) lpWABObject->Release();
	return(retval);
}

BOOL DisplayAdrList(LPADRLIST lpAdrList, ULONG cEntries)
{
	int         i           = 0;
	int         idx         = 0;
	int         cMaxProps   = 0;
	BOOL		Found, retval = TRUE;

	for(i=0; i<(int) cEntries; ++i)	{
		LUIOut(L3, "Searching Entry #%i out of %i", i+1, cEntries);
      cMaxProps = (int)lpAdrList->aEntries[i].cValues;
/*
	  //Check to see if Email Address Type exists
	  idx=0; Found = TRUE;
	  while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ADDRTYPE )	{
	    idx++;
		if(idx == cMaxProps) {
		  LUIOut(L4, "PR_ADDRTYPE was not found in the lpAdrList");
		  Found = FALSE;
		}
	  }
	  if (Found) LUIOut(L4,"Address Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
	
	    //Check to see if Email Address exists
		idx=0; Found = TRUE;
		while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_OBJECT_TYPE )	{
		  idx++;
		  if(idx == cMaxProps) {
			LUIOut(L4, "PR_OBJECT_TYPE was not found in the lpAdrList");
			Found = FALSE;
		  }
		}
		if (Found) LUIOut(L4,"Object Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);

	      //Check to see if display type exists
		  idx=0; Found = TRUE;
		  while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_TYPE )	{
			idx++;
			if(idx == cMaxProps) {
			  LUIOut(L4, "PR_DISPLAY_TYPE was not found in the lpAdrList");
			  Found = FALSE;
		    }
		  }
		  if (Found) LUIOut(L4,"Display Type: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
	
*/
		//Check to see if Display Name exists
		idx=0; Found = TRUE;
		while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	{
		  idx++;
		  if(idx == cMaxProps) {
			LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
			Found = FALSE;
		  }
		}
		if (Found) LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);

		//Check to see if EntryID exists
		idx=0; Found = TRUE;
		while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	{
			idx++;
			if(idx == cMaxProps)	{
			  LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
			  Found = FALSE;
			}
		}
		if (Found) LUIOut(L4,"Entry ID Found");
		//Check to see if Recipient Type exists
	    idx=0; Found = TRUE;
	    while(Found && lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_RECIPIENT_TYPE )	{
			idx++;
			if(idx == cMaxProps)	{
				LUIOut(L4, "PR_RECIPIENT_TYPE was not found in the lpAdrList");
				Found = FALSE;
			}
		}
		if (Found) {
			switch((ULONG)lpAdrList->aEntries[i].rgPropVals[idx].Value.l)	{
				case MAPI_TO:	{
					LUIOut(L4, "Recipient Type: [TO:]");
					break;
				}
				case MAPI_CC:	{
					LUIOut(L4, "Recipient Type: [CC:]");
					break;
				}
				case MAPI_BCC:	{
					LUIOut(L4, "Recipient Type: [BCC:]");
					break;
				}
				default:	{
					LUIOut(L4, "Recipient Type: [UNKNOWN]. Test FAILED");
				}
			}
		}
	}
	return retval;
}



BOOL LogIt(HRESULT hr, int Level,char * LogString)
{
	switch (Level) {

		case 0: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS,"%s",LogString);
			return TRUE;

		case 1: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL1, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS1,"%s",LogString);
			return TRUE;
		case 2: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL2, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS2,"%s",LogString);
			return TRUE;
		
		case 3: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL3, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS3,"%s",LogString);
			return TRUE;

		case 4: 
			if (HR_FAILED(hr)) {
				LUIOut(LFAIL4, "%s",LogString);
				return FALSE;
			}
			else LUIOut(LPASS4,"%s",LogString);
			return TRUE;

		default: break;
	}
	if (HR_FAILED(hr)) {
			LUIOut(LFAIL2, "%s",LogString);
			return FALSE;
	}
	else LUIOut(LPASS2,"%s",LogString);
	return TRUE;
}

//
// PROCEDURE:	AllocateAdrList
// DESCRIPTION: Uses either MAPI or WAB allocaters to allocate an lpAdrList
//				
// PARAMETERS:	LPWABOBJECT lpLocalWABObject - ptr to opened WABObject
//				int nEntries - how many AdrEntries to allocate
//				int nProps - how many properties per AdrEntry
//				LPADRLIST * lppAdrList - where to return the allocated ptr
//

BOOL AllocateAdrList(IN LPWABOBJECT lpLocalWABObject, IN int nEntries, IN int nProps, OUT LPADRLIST * lppAdrList) {
	BOOL	retval = TRUE;
	SCODE	sc;

*lppAdrList = NULL;
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)lppAdrList))) {
		(*lppAdrList)->cEntries = nEntries;
		for (int entry = 0; entry < nEntries; entry++) {
		    (*lppAdrList)->aEntries[entry].ulReserved1 = 0;
			(*lppAdrList)->aEntries[entry].cValues = nProps;
			sc = MAPIAllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&(*lppAdrList)->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//

#endif //PAB
#ifdef WAB
    if (! (sc = lpLocalWABObject->AllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)lppAdrList))) {
		(*lppAdrList)->cEntries = nEntries;
		for (int entry = 0; entry < nEntries; entry++) {
		    (*lppAdrList)->aEntries[entry].ulReserved1 = 0;
			(*lppAdrList)->aEntries[entry].cValues = nProps;
			sc = lpLocalWABObject->AllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&(*lppAdrList)->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//
#endif //WAB
return retval;
}

//
// PROCEDURE:	GrowAdrList
// DESCRIPTION: Takes an existing lpAdrList, allocates a new, larger lpAdrList
//				, copies over the old entries and allocates new entries, returning
//				a pointer to the new AdrList in lpAdrList.
//				
// PARAMETERS:	int nEntries - how many AdrEntries to allocate in new list
//				int nProps - how many properties per new AdrEntry
//				LPADRLIST * lppAdrList - where to return the allocated ptr
//

BOOL GrowAdrList(IN UINT nEntries, IN UINT nProps, OUT LPADRLIST * lppAdrList) {
	BOOL	retval = TRUE;
	SCODE	sc;
	LPADRLIST	lpTempAdrList;
	unsigned int		entry;


	if ((!lppAdrList) || ((*lppAdrList)->cEntries>=nEntries))	
		return FALSE;

#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)&lpTempAdrList))) {
		lpTempAdrList->cEntries = nEntries;
		// Copy over old entries
		entry = (*lppAdrList)->cEntries;
		memcpy(lpTempAdrList, *lppAdrList, (entry * sizeof(ADRENTRY)));
		// Allocate new entries 
		for (; entry < nEntries; entry++) {
		    lpTempAdrList->aEntries[entry].ulReserved1 = 0;
			lpTempAdrList->aEntries[entry].cValues = nProps;
			sc = MAPIAllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&lpTempAdrList->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
		FreeAdrList(lppAdrList);
		*lppAdrList = lpTempAdrList;
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//

#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + (nEntries * sizeof(ADRENTRY)), 
		(void **)&lpTempAdrList))) {
		// Copy over old entries
		entry = (*lppAdrList)->cEntries;
		memcpy(lpTempAdrList, *lppAdrList, (sizeof(ADRLIST)+(entry * sizeof(ADRENTRY))));
		lpTempAdrList->cEntries = nEntries;
		// Allocate new entries 
		for (; entry < nEntries; entry++) {
		    lpTempAdrList->aEntries[entry].ulReserved1 = 0;
			lpTempAdrList->aEntries[entry].cValues = nProps;
			sc = lpWABObject->AllocateBuffer((nProps * sizeof(SPropValue)), 
				(void **)(&lpTempAdrList->aEntries[entry].rgPropVals));
			if (sc != S_OK) retval = FALSE;
		}
		FreePartAdrList(lppAdrList);
		*lppAdrList = lpTempAdrList;
	}
	else retval = FALSE;

	//
	// Should do cleanup here for a partial allocation that fails
	//

#endif //WAB
return retval;
}


//
// PROCEDURE:	FreeAdrList
// DESCRIPTION: Uses either MAPI or WAB de-allocaters to walk and free an lpAdrList
//				
// PARAMETERS:	LPWABOBJECT lpLocalWABObject - ptr to opened WABObject
//				LPADRLIST * lppAdrList - where the lpAdrList to free is stored
//

BOOL FreeAdrList(IN LPWABOBJECT lpLocalWABObject, IN LPADRLIST * lppAdrList) {
	LPADRLIST	lpAdrList = NULL;
	UINT	idx;
	
	if (lppAdrList) lpAdrList = *lppAdrList;

#ifdef PAB
	if (lpAdrList) {
		for (idx = 0; idx < lpAdrList->cEntries; idx++)
			MAPIFreeBuffer(lpAdrList->aEntries[idx].rgPropVals);
		MAPIFreeBuffer(lpAdrList);
		*lppAdrList=NULL;
	}
#endif //PAB
#ifdef WAB
	if (lpAdrList) {
		for (idx = 0; idx < lpAdrList->cEntries; idx++)
			lpLocalWABObject->FreeBuffer(lpAdrList->aEntries[idx].rgPropVals);
		lpLocalWABObject->FreeBuffer(lpAdrList);
		*lppAdrList=NULL;
	}
#endif //WAB
	
	return TRUE;
}


//
// PROCEDURE:	FreePartAdrList
// DESCRIPTION: Uses either MAPI or WAB de-allocaters to free an lpAdrList
//				but not the associated properties.
//				
// PARAMETERS:	LPADRLIST * lppAdrList - where the lpAdrList to free is stored
//

BOOL FreePartAdrList(IN LPADRLIST * lppAdrList) {
	LPADRLIST	lpAdrList = NULL;
	
	if (lppAdrList) lpAdrList = *lppAdrList;

#ifdef PAB
	if (lpAdrList) {
		MAPIFreeBuffer(lpAdrList);
		lpAdrList=NULL;
	}
#endif //PAB
#ifdef WAB
	if (lpAdrList) {
		lpWABObject->FreeBuffer(lpAdrList);
		lpAdrList=NULL;
	}
#endif //WAB
	
	return TRUE;
}


//
// PROCEDURE:	FindProp
// DESCRIPTION: Walks through the properties of an AdrEntry and returns the index
//				of the requested property tag.
//				
// PARAMETERS:	LPADRENTRY lpAdrEntry - Entry to search through
//				ULONG ulPropTag - Property tag to look for
//				unsigned int* lpnFoundIndex - Ptr to output variable where the found index 
//				  value is to be stored. 
//
// RETURNS:		TRUE if succesfull.
//

BOOL FindProp(IN LPADRENTRY lpAdrEntry, IN ULONG ulPropTag, OUT unsigned int* lpnFoundIndex) {

	if ((!lpAdrEntry) || (!ulPropTag) || (!lpnFoundIndex)) return(FALSE);
	
	for (unsigned int Counter1 = 0; Counter1 < lpAdrEntry->cValues; Counter1++) {
		if (lpAdrEntry->rgPropVals[Counter1].ulPropTag == ulPropTag) {
			*lpnFoundIndex = Counter1;
			return(TRUE);
		}
	}
	return(FALSE);
}


//
// PROCEDURE:	FindPropinRow
// DESCRIPTION: Walks through the properties of an SRowSet and returns the index
//				of the requested property tag.
//				
// PARAMETERS:	LPSRow lpRow - Row to search through
//				ULONG ulPropTag - Property tag to look for
//				unsigned int* lpnFoundIndex - Ptr to output variable where the found index 
//				  value is to be stored. 
//
// RETURNS:		TRUE if succesfull.
//

BOOL FindPropinRow(IN LPSRow lpRow, IN ULONG ulPropTag, OUT unsigned int* lpnFoundIndex) {

	if ((!lpRow) || (!ulPropTag) || (!lpnFoundIndex)) return(FALSE);
	

	for (ULONG Column = 0; Column < lpRow->cValues; Column++) {
		if (lpRow->lpProps[Column].ulPropTag == ulPropTag) {
			*lpnFoundIndex = Column;
			return(TRUE);
		}
	}
	return(FALSE);
}




//
// PROCEDURE:	ParseIniBuffer
// DESCRIPTION: Walks through a buffer read from an ini file which contains
//				several strings separated by quotation marks and copies the
//				requested string to the users buffer.
//				
// PARAMETERS:	LPSTR	lpszIniBuffer
//				UINT	uSelect - which string (in order left to right starting with 1 ) to return
//				LPSTR	lpszReturnBuffer - pre-alocated by caller and dumb (assumes enough space)
//

BOOL ParseIniBuffer(LPSTR lpszIniBuffer, UINT uSelect, LPSTR lpszReturnBuffer) {
	UINT	Selected = 0;

	// while (*(lpszIniBuffer++) != '"');	// Advance to first entry 
	// lpszIniBuffer++; 
	Selected++;		// Now pointing at 1st letter of first item
	while(uSelect != Selected++) {
		while (*(lpszIniBuffer++) != '"');	// Advance to end of this entry 
		while (*(lpszIniBuffer++) != '"');	// Advance to beginning of next entry 
		// Now we are pointing at the 1st letter of the desired entry so copy
	}
	while((*(lpszIniBuffer) != '"') && (*(lpszIniBuffer) != '\0')) {
		*(lpszReturnBuffer++) = *lpszIniBuffer++;
	}
	*lpszReturnBuffer = '\0';	// Add the terminator
	return(TRUE);
}
		

//
// PROCEDURE:	PropError
// DESCRIPTION: Compares the passed in property type with PT_ERROR returning TRUE is error is found
//				
// PARAMETERS:	ulPropTag - Tag to compare
//				cValues - # of entries returned from GetProps
//

BOOL PropError(ULONG ulPropTag, ULONG cValues) {
	BOOL retval = FALSE;
#ifdef DISTLISTS
	for(ULONG Counter = 0; Counter < cValues; Counter++) {
		if (PROP_TYPE(ulPropTag) == PT_ERROR) retval = TRUE;
	}
#endif
	return retval;
}

//
// PROCEDURE:	DeleteWABFile
// DESCRIPTION: Reads the registry to determine the location of the WAB file,
//				and deletes the file.
//				
// PARAMETERS:	none
//

BOOL DeleteWABFile () {
	BOOL	retval = TRUE;
	long	lretval;
	HKEY	hKey;
	char	KeyAddress[] = "Software\\Microsoft\\WAB\\Wab File Name";
	DWORD	dType, dSize = 256;
	char	achData[256];

	if (!MyRegOpenKeyEx(HKEY_CURRENT_USER, 
						   KeyAddress, 
						   KEY_QUERY_VALUE, 
						   &hKey)) {
		LUIOut(L2, "MyRegOpenKeyEx call failed");
		retval = FALSE;
		return(retval);
	}

	
	lretval = RegQueryValueEx(hKey,					// handle of key to query 
							  NULL,					// address of name of value to query 
							  (LPDWORD)NULL,		// reserved 
							  &dType,				// address of buffer for value type 
							  (LPBYTE)achData,		// address of data buffer 
							  &dSize	 			// address of data buffer size 
							 );				 

	if (lretval != ERROR_SUCCESS) {
		LUIOut(L2, "RegQueryValueEx call failed with error code %u", lretval);
		retval = FALSE;
		return(retval);
	}

	LUIOut(L2, "Deleting WAB file: %s", achData);

	RegCloseKey(hKey);

	if (!DeleteFile(achData)) {
		LUIOut(L3, "Delete FAILED. Could not locate or delete file.");			
		retval = FALSE;
	}

	return(retval);
}

//
// PROCEDURE:	MyRegOpenKeyEx
// DESCRIPTION: Walks through a null terminated string, such as "\Software\Microsoft\WAB"
//				openning each key until it reaches the end and returns that open key (closing
//				the interim keys along the way). The caller must close the returned HKEY.
//				
// PARAMETERS:	StartKey - one of the predefined "open" keys to root at
//				szAddress - null terminated string specifcying the path to the key to be opened
//				RegSec - the security access required (i.e. KEY_READ)
//				lpReturnKey - address of HKEY where final opened key is stored
//

BOOL MyRegOpenKeyEx(HKEY StartKey, char* szAddress, REGSAM RegSec, HKEY* lpReturnKey) {
	HKEY	workkey1, workkey2, *lpOpenKey=&workkey1, *lpNewKey=&workkey2;
	char	workbuffer[256], *lpAddr = szAddress, *lpWork = workbuffer;
	BOOL	Started = FALSE, Done = FALSE;
	long	lretval;

	if (!szAddress) return FALSE;

	while (!Done) {
		if (*lpAddr == '\\') lpAddr++;		//skip over the initial backslash if it exists
		while((*(lpAddr) != '\\') && (*(lpAddr) != '\0')) {
			*(lpWork++) = *lpAddr++;
		}
		*lpWork = '\0';						// Add the terminator
		if (*(lpAddr) == '\0') Done = TRUE;
		lpWork = workbuffer;
		if (!Started) {
			//
			// First, special case the starting key (predefined/open key root)
			//
			lretval = RegOpenKeyEx(	StartKey, 
									lpWork, 
									DWORD(0), 
									RegSec, 
									lpOpenKey);
			Started = TRUE;
		}
		else {
			lretval = RegOpenKeyEx(	*lpOpenKey, 
									lpWork, 
									DWORD(0), 
									RegSec, 
									lpNewKey);
			RegCloseKey(*lpOpenKey);
			*lpOpenKey = *lpNewKey;
		}
		if (lretval != ERROR_SUCCESS) {
			LUIOut(L2, "RegOpenKeyEx call failed with error code 0x%x", lretval);
			return(FALSE);
		}

	}

		*lpReturnKey = *lpNewKey;
		return(TRUE);
}

//
// PROCEDURE:	CreateMultipleEntries
// DESCRIPTION: Creates multiple entries in the WAB using the display name stored in the
//				pabtests.ini file CreateEntriesStress section.
//				
// PARAMETERS:	NumEntriesIn - how many entries to create. If 0, then the value is read
//				from the same CreateEntriesStress section.
//				lpPerfData - address of a dword data type to hold the average time in milliseconds
//				required during SaveChanges. If NULL perf data is not accumulated.
//

BOOL CreateMultipleEntries(IN UINT NumEntriesIn, DWORD* lpPerfData)
{
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	DWORD	StartTime, StopTime;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;

    char	EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG   cValues = 0, ulObjType=NULL;	
	int i=0,k=0;
	char EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	unsigned int	NumEntries, counter, StrLen;
	
    LPMAILUSER  lpMailUser=NULL,lpDistList=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.

    LPSPropValue lpSPropValueAddress = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
	
	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	// Wipe perfdata if we're tracking this
	if (lpPerfData) *lpPerfData = (DWORD)0;
	// 
	// Try to create a MailUser entry in the container
	//


	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}
        
    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //

	// Retrieve user info from ini file
	cValues = 3; //# of props we are setting 
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntriesStress",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
	StrLen = (strlen(EntProp[0]));
	_itoa(0,(char*)&EntProp[0][StrLen],10);
	EntProp[0][StrLen+1]= '\0';
	NumEntries = (NumEntriesIn > 0) ? 
		NumEntriesIn:GetPrivateProfileInt("CreateEntriesStress","NumCopies",0,INIFILENAME);

	if (NumEntries > 100)
		LUIOut(L2, "Adding %u MailUser entries to the WAB. This may take several minutes.", NumEntries);
	for (counter = 0; counter < NumEntries; counter++)	{ 
//		LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);
     
		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//  
		// Then set the properties
		// 

		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
		PropValue[1].ulPropTag  = PR_ADDRTYPE;
		PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;

     
			
		_itoa(counter,(char*)&EntProp[0][StrLen],10);
//		LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
			
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
		hr = lpMailUser->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		} 
//		else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

		StartTime = GetTickCount();
		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags
		StopTime = GetTickCount();
/*		if (lpPerfData) {
			if ((StopTime-StartTime) > *lpPerfData)
				*lpPerfData = (StopTime - StartTime);
		}
*/
		if (lpPerfData) {
			*lpPerfData += (StopTime - StartTime);
		}

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}
//		else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

		if (lpMailUser) {
			lpMailUser->Release();
			lpMailUser = NULL;
		}

	}
	if (lpPerfData)
		*lpPerfData /= NumEntries;


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB) 
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress); 

		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL); 

#endif
#ifdef WAB
		if (lpEidPAB) 
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress); 

		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL); 

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpABCont) 
				lpABCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject) {
			lpWABObject->Release();
			lpWABObject = NULL;
		}
#endif

		return retval;    
}

void GenerateRandomPhoneNumber(char **lppPhone) {
#define FORMATSIZE 15	// Size of formatted phone# + terminator i.e. (206)-882-8080
#define MAXNUMSIZE (FORMATSIZE + 32)
	unsigned int	Offset = 0;
	extern BOOL Seeded; 
	*lppPhone = (char*)LocalAlloc(LMEM_FIXED, MAXNUMSIZE*sizeof(char));
	(*lppPhone)[0] = '\0';		// Set the first char to a terminator
	
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
	while (Offset < FORMATSIZE) {
		_itoa(rand(), ((*lppPhone)+Offset), 10);
		Offset = strlen(*lppPhone);
	}
	// Overwrite some numbers with formatting characters
	(*lppPhone)[0] = '(';
	(*lppPhone)[4] = ')';
	(*lppPhone)[5] = '-';
	(*lppPhone)[9] = '-';
	(*lppPhone)[FORMATSIZE-1] = '\0';	//Cutoff the end in case it's > FORMATSIZE
}

void GenerateRandomText(char **lppText, UINT unSize) {
	unsigned int	Offset = 0;
	extern BOOL Seeded; 
	extern ULONG glblTest, glblCount, glblDN;
	*lppText = (char*)LocalAlloc(LMEM_FIXED, (unSize+1)*sizeof(char));
	
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
#ifdef TESTPASS
	for (Offset = 0; Offset < unSize; Offset++) {
		(*lppText)[Offset] = (char)glblTest;
		if ((*lppText)[Offset] == '\0') (*lppText)[Offset] = (char)'?';	//don't want a terminator mid string
	}
	(*lppText)[unSize] = '\0';	//Cutoff the end 
	if (glblDN) {
		glblDN = 0;
		if (++glblCount == 15) {
			glblTest++;
			glblCount=0;
			LUIOut(L4, "Testing value %i [%c].", glblTest, glblTest);
		}
	}
#else
	for (Offset = 0; Offset < unSize; Offset++) {
		(*lppText)[Offset] = rand();
		if ((*lppText)[Offset] == '\0') (*lppText)[Offset] = (char)'?';	//don't want a terminator mid string
	}
	(*lppText)[unSize] = '\0';	//Cutoff the end 
#endif
}

void GenerateRandomBoolean(unsigned short *lpBool) {
	extern BOOL Seeded; 
	
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}

	*lpBool = (unsigned short)(GetTickCount() & 0x01); //If bit 0 is set then true otherwise false
}

void GenerateRandomLong(long *lpLong) {
	extern BOOL Seeded; 

	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
	*lpLong = (long)rand();
}

void GenerateRandomBinary(SBinary *lpBinary, UINT unSize) {
	unsigned int	Offset = 0;
	extern BOOL Seeded; 
	lpBinary->lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, unSize);
	lpBinary->cb = unSize;
	// seed the random number generator with the current time
	if (!Seeded) {
		srand( (unsigned)GetTickCount());
		Seeded = TRUE; 
	}
	
	for (Offset = 0; Offset < unSize; Offset++) {
		lpBinary->lpb[Offset] = (BYTE)(rand() * 255)/RAND_MAX;
	}
}

//***
//*** set unCount to AUTONUM_OFF to disable autonumbering display names
//*** if lppDisplayName is not NULL then the *lppDisplayName string is used for the prefix of 
//*** the DN and the ptr to the completed DisplayName is returned to the callee if lppReturnName is not NULL
//***
void CreateProps(LPTSTR lpszFileName, LPTSTR lpszSection, SPropValue** lppProperties, ULONG* lpcValues, UINT unCount, char** lppDisplayName, char ** lppReturnName) {
	UINT	StrLen1, PropIndex = 0, Properties = 0;		//How many props does the user want to set
	char	*lpszLocalDisplayName, DNText[] = {"Test Entry #"};
	extern ULONG glblDN;
	PropTableEntry*	lpEntry = PropTable;

	while (lpEntry->ulPropTag) {
		lpEntry->unSize = GetPrivateProfileInt(lpszSection,lpEntry->lpszPropTag,0,lpszFileName);
		if ((lpEntry->ulPropTag == PR_DISPLAY_NAME) && (unCount != AUTONUM_OFF))
			lpEntry->unSize = TRUE;	//If we're autonumbering the display name, then make sure unsize is not zero
		if (lpEntry->unSize) Properties++;
		lpEntry++;
	}

	//At this point, any table entry with nonzero size we need to create
	//LUIOut(L3, "Setting %i properties.", Properties);
	*lpcValues = Properties;
	*lppProperties = (SPropValue*)LocalAlloc(LMEM_FIXED, (Properties * sizeof(SPropValue)));
	lpEntry = PropTable;

	while (lpEntry->ulPropTag) {
		if (lpEntry->unSize) {
			//special case phone numbers
			if ((strstr(lpEntry->lpszPropTag, "PHONE")) || (strstr(lpEntry->lpszPropTag, "FAX"))) {
				//LUIOut(L3, "Found a prop I think is a phone number, called %s.", lpEntry->lpszPropTag);
				(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
				GenerateRandomPhoneNumber(&((*lppProperties)[PropIndex].Value.LPSZ));
			}
			//special case for autonumbering display names if requested
			else if ((lpEntry->ulPropTag == PR_DISPLAY_NAME) && (unCount != AUTONUM_OFF)) {
				if ((lppDisplayName)&&(*lppDisplayName)) {
					//Caller passed in a string to use as the prefix
					StrLen1 = strlen(*lppDisplayName);	
					lpszLocalDisplayName = (char*)LocalAlloc(LMEM_FIXED, (StrLen1+5)*sizeof(char)); //5 for terminator plus # up to 9999
					strcpy(lpszLocalDisplayName, *lppDisplayName);
				}
				else {
					StrLen1 = strlen(DNText);	
					lpszLocalDisplayName = (char*)LocalAlloc(LMEM_FIXED, (StrLen1+5)*sizeof(char)); //5 for terminator plus # up to 9999
					strcpy(lpszLocalDisplayName, DNText);
				}
				// Add the Entry # to the display name
				_itoa(unCount,(char*)&(lpszLocalDisplayName[StrLen1]),10);
				(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
				(*lppProperties)[PropIndex].Value.LPSZ = lpszLocalDisplayName;
				if (lppReturnName) *lppReturnName = lpszLocalDisplayName;
			}
			else {
				switch(PROP_TYPE(lpEntry->ulPropTag)) {
				case PT_STRING8:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
#ifdef TESTPASS
					if (lpEntry->ulPropTag == PR_DISPLAY_NAME) glblDN = 1;
#endif					
					GenerateRandomText(&((*lppProperties)[PropIndex].Value.LPSZ),lpEntry->unSize);
					if ((lpEntry->ulPropTag == PR_DISPLAY_NAME) && lppReturnName)
						*lppReturnName = (*lppProperties)[PropIndex].Value.LPSZ;
					break;
				case PT_BOOLEAN:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
					GenerateRandomBoolean(&((*lppProperties)[PropIndex].Value.b));
					break;
				case PT_LONG:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
					GenerateRandomLong(&((*lppProperties)[PropIndex].Value.l));
					break;
				case PT_BINARY:
					(*lppProperties)[PropIndex].ulPropTag = lpEntry->ulPropTag;
					GenerateRandomBinary(&((*lppProperties)[PropIndex].Value.bin),lpEntry->unSize);
					break;
				default:
					LUIOut(L1, "Unrecognized prop type 0x%x for property %s", PROP_TYPE(lpEntry->ulPropTag), lpEntry->lpszPropTag);
				}
			}
			PropIndex++;
		}
		lpEntry++;
	}

}

//***
//*** Walks through the expected props and searches the found props for the same prop/value combo
//***
BOOL CompareProps(SPropValue* lpExpectedProps, ULONG cValuesExpected, SPropValue* lpCompareProps, ULONG cValuesCompare) {
	ULONG	TargetProp, CompareIndex; 
	BOOL	Result = TRUE, Found;
	for (ULONG PropertyIndex = 0; PropertyIndex < cValuesExpected; PropertyIndex++) {
		TargetProp = lpExpectedProps[PropertyIndex].ulPropTag;
		for (CompareIndex = 0, Found = FALSE; CompareIndex < cValuesCompare; CompareIndex++) {
			if (lpCompareProps[CompareIndex].ulPropTag == TargetProp) {
				//if (TargetProp == PR_DISPLAY_NAME) _asm{int 3};
				Found = TRUE;
				switch(PROP_TYPE(TargetProp)) {
				case PT_STRING8:
					if (strcmp(lpExpectedProps[PropertyIndex].Value.LPSZ, lpCompareProps[CompareIndex].Value.LPSZ)) {
						//Strings did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. Expected %s but found %s",	TargetProp, lpExpectedProps[PropertyIndex].Value.LPSZ, lpCompareProps[CompareIndex].Value.LPSZ);
						Result = FALSE;
						//_asm{int 3};
					}
					break;
				case PT_BOOLEAN:
					if (lpExpectedProps[PropertyIndex].Value.b != lpCompareProps[CompareIndex].Value.b) {
						//bools did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. Expected %u but found %u",	TargetProp, lpExpectedProps[PropertyIndex].Value.b, lpCompareProps[CompareIndex].Value.b);
						Result = FALSE;
					}
					break;
				case PT_LONG:
					if (lpExpectedProps[PropertyIndex].Value.l != lpCompareProps[CompareIndex].Value.l) {
						//bools did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. Expected %u but found %u",	TargetProp, lpExpectedProps[PropertyIndex].Value.l, lpCompareProps[CompareIndex].Value.l);
						Result = FALSE;
					}
					break;
				case PT_BINARY:
					if (memcmp(lpExpectedProps[PropertyIndex].Value.bin.lpb, lpCompareProps[CompareIndex].Value.bin.lpb, lpExpectedProps[PropertyIndex].Value.bin.cb)) {
						//bools did not match so fail compare
						LUIOut(L3, "Comparison failed for prop 0x%x. %u bytes expected, %u found and they are not equal",	TargetProp, lpExpectedProps[PropertyIndex].Value.bin.cb, lpCompareProps[CompareIndex].Value.bin.cb);
						Result = FALSE;
					}
					break;
				default:
					LUIOut(L3, "Unrecognized prop type 0x%x", PROP_TYPE(lpExpectedProps[PropertyIndex].ulPropTag));
				} //switch
			} //if propr match
		} //for loop (CompareIndex)
		if (!Found) {
			LUIOut(L3, "Did not find property 0x%x. Compare FAILS", TargetProp);
			Result = FALSE;
		}
	} //for loop (PropertyIndex)
	//LUIOut(L3, "%u propertes compared %s", PropertyIndex, Result ? "Successfully" : "With Errors");
	return(Result);
} //CompareProps()

//***
//*** Walks through the expected props until it finds the target prop and displays its value
//***
BOOL DisplayProp(SPropValue *lpSearchProps, ULONG ulTargetProp, ULONG cValues) {
	BOOL	Result = TRUE, Found = FALSE;
	for (ULONG PropertyIndex = 0; PropertyIndex < cValues; PropertyIndex++) {
		if (lpSearchProps[PropertyIndex].ulPropTag == ulTargetProp) {
			//if (TargetProp == PR_DISPLAY_NAME) _asm{int 3};
			Found = TRUE;
			switch(PROP_TYPE(ulTargetProp)) {
			case PT_STRING8:
				LUIOut(L4, "Property 0x%x has value:%s", ulTargetProp, lpSearchProps[PropertyIndex].Value.LPSZ);
				break;
			case PT_BOOLEAN:
				LUIOut(L4, "Property 0x%x has value:%i", ulTargetProp, lpSearchProps[PropertyIndex].Value.b);
				break;
			case PT_LONG:
				LUIOut(L4, "Property 0x%x has value:0x%x", ulTargetProp, lpSearchProps[PropertyIndex].Value.l);
				break;
			case PT_BINARY:
				LUIOut(L4, "Binary prop found but not displayed.");
				break;
			default:
				LUIOut(L3, "Unrecognized prop type 0x%x", PROP_TYPE(ulTargetProp));
			} //switch
		} //if propr match
	} //for loop (PropertyIndex)
	if (!Found) {
		LUIOut(L4, "Did not find property 0x%x.", ulTargetProp);
		Result = FALSE;
	}
	return(Result);
} //DisplayProp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#define OBM_CLOSE       32754
#define OBM_UPARROW     32753
#define OBM_DNARROW     32752
#define OBM_RGARROW     32751
#define OBM_LFARROW     32750
#define OBM_REDUCE      32749
#define OBM_ZOOM        32748
#define OBM_RESTORE     32747
#define OBM_REDUCED     32746
#define OBM_ZOOMD       32745
#define OBM_RESTORED    32744
#define OBM_UPARROWD    32743
#define OBM_DNARROWD    32742
#define OBM_RGARROWD    32741
#define OBM_LFARROWD    32740
#define OBM_MNARROW     32739
#define OBM_COMBO       32738
#define OBM_UPARROWI    32737
#define OBM_DNARROWI    32736
#define OBM_RGARROWI    32735
#define OBM_LFARROWI    32734
#define OBM_OLD_CLOSE   32767
#define OBM_SIZE        32766
#define OBM_OLD_UPARROW 32765
#define OBM_OLD_DNARROW 32764
#define OBM_OLD_RGARROW 32763
#define OBM_OLD_LFARROW 32762
#define OBM_BTSIZE      32761
#define OBM_CHECK       32760
#define OBM_CHECKBOXES  32759
#define OBM_BTNCORNERS  32758
#define OBM_OLD_REDUCE  32757
#define OBM_OLD_ZOOM    32756
#define OBM_OLD_RESTORE 32755
#define OCR_NORMAL      32512
#define OCR_IBEAM       32513
#define OCR_WAIT        32514
#define OCR_CROSS       32515
#define OCR_UP          32516
#define OCR_SIZE        32640
#define OCR_ICON        32641
#define OCR_SIZENWSE    32642
#define OCR_SIZENESW    32643
#define OCR_SIZEWE      32644
#define OCR_SIZENS      32645
#define OCR_SIZEALL     32646
#define OCR_ICOCUR      32647
#define OCR_NO          32648
#define OIC_SAMPLE      32512
#define OIC_HAND        32513
#define OIC_QUES        32514
#define OIC_BANG        32515
#define OIC_NOTE        32516

#if (WINVER >= 0x0400)
#define OCR_APPSTARTING     32650
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE
#endif

#define WS_OVERLAPPED   0x00000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_MINIMIZE     0x20000000L
#define WS_MAXIMIZE     0x01000000L
#define WS_CAPTION      0x00C00000L
#define WS_BORDER       0x00800000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_THICKFRAME   0x00040000L
#define WS_MINIMIZEBOX  0x00020000L
#define WS_MAXIMIZEBOX  0x00010000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

// other aliases
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW  (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW  (WS_CHILD)
#define WS_TILED        WS_OVERLAPPED
#define WS_ICONIC       WS_MINIMIZE
#define WS_SIZEBOX      WS_THICKFRAME
#define WS_TILEDWINDOW  WS_OVERLAPPEDWINDOW

#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#if (WINVER >= 0x0400)
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L

#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
#endif

#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

#define VK_LSHIFT       0xA0
#define VK_RSHIFT       0xA1
#define VK_LCONTROL     0xA2
#define VK_RCONTROL     0xA3
#define VK_LMENU        0xA4
#define VK_RMENU        0xA5

#if (WINVER >= 0x0400)
#define VK_PROCESSKEY   0xE5
#endif /* WINVER >= 0x0400 */

#define VK_ATTN         0xF6
#define VK_CRSEL        0xF7
#define VK_EXSEL        0xF8
#define VK_EREOF        0xF9
#define VK_PLAY         0xFA
#define VK_ZOOM         0xFB
#define VK_NONAME       0xFC
#define VK_PA1          0xFD
#define VK_OEM_CLEAR    0xFE

#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

#define DS_ABSALIGN     0x01L
#define DS_SYSMODAL     0x02L
#define DS_LOCALEDIT    0x20L
#define DS_SETFONT      0x40L
#define DS_MODALFRAME   0x80L
#define DS_NOIDLEMSG    0x100L
#define DS_SETFOREGROUND 0x200L

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

#if (WINVER >= 0x0400)
#define DS_3DLOOK       0x0004L
#define DS_FIXEDSYS     0x0008L
#define DS_NOFAILCREATE 0x0010L
#define DS_CONTROL      0x0400L
#define DS_CENTER       0x0800L
#define DS_CENTERMOUSE  0x1000L
#define DS_CONTEXTHELP  0x2000L
#endif

#define SS_LEFT         0x00000000L
#define SS_CENTER       0x00000001L
#define SS_RIGHT        0x00000002L
#define SS_ICON         0x00000003L
#define SS_BLACKRECT    0x00000004L
#define SS_GRAYRECT     0x00000005L
#define SS_WHITERECT    0x00000006L
#define SS_BLACKFRAME   0x00000007L
#define SS_GRAYFRAME    0x00000008L
#define SS_WHITEFRAME   0x00000009L
#define SS_SIMPLE       0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL
#define SS_BITMAP           0x0000000EL

#if (WINVER >= 0x0400)
#define SS_OWNERDRAW        0x0000000DL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L
#endif

#define SS_NOPREFIX     0x00000080L
#if (WINVER >= 0x0400)
#define SS_NOTIFY           0x00000100L
#endif
#define SS_CENTERIMAGE      0x00000200L
#if (WINVER >= 0x0400)
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L
#endif

#define BS_PUSHBUTTON   0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX     0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON  0x00000004L
#define BS_3STATE       0x00000005L
#define BS_AUTO3STATE   0x00000006L
#define BS_GROUPBOX     0x00000007L
#define BS_USERBUTTON   0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT     0x00000020L
#if (WINVER >= 0x0400)
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT
#endif

#define ES_LEFT         0x00000000L
#define ES_CENTER       0x00000001L
#define ES_RIGHT        0x00000002L
#define ES_MULTILINE    0x00000004L
#define ES_UPPERCASE    0x00000008L
#define ES_LOWERCASE    0x00000010L
#define ES_PASSWORD     0x00000020L
#define ES_AUTOVSCROLL  0x00000040L
#define ES_AUTOHSCROLL  0x00000080L
#define ES_NOHIDESEL    0x00000100L
#define ES_OEMCONVERT   0x00000400L
#define ES_READONLY     0x00000800L
#define ES_WANTRETURN   0x00001000L
#if (WINVER >= 0x0400)
#define ES_NUMBER       0x2000L
#endif

#define SBS_HORZ        0x0000L
#define SBS_VERT        0x0001L
#define SBS_TOPALIGN    0x0002L
#define SBS_LEFTALIGN   0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN  0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX     0x0008L
#if (WINVER >= 0x0400)
#define SBS_SIZEGRIP    0x0010L
#endif

#define LBS_NOTIFY      0x0001L
#define LBS_SORT        0x0002L
#define LBS_NOREDRAW    0x0004L
#define LBS_MULTIPLESEL 0x0008L
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS  0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#if (WINVER >= 0x0400)
#define LBS_NOSEL       0x4000L
#endif
#define LBS_STANDARD    (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#define CBS_SIMPLE      0x0001L
#define CBS_DROPDOWN    0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT  0x0080L
#define CBS_SORT        0x0100L
#define CBS_HASSTRINGS  0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L
#if (WINVER >= 0x0400)
#define CBS_UPPERCASE   0x2000L
#define CBS_LOWERCASE   0x4000L
#endif

// operation messages sent to DLGINIT
#define WM_USER         0x0400
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#if (WINVER >= 0x0400)

#define HDS_HORZ                0x00000000
#define HDS_BUTTONS             0x00000002
#define HDS_HIDDEN              0x00000008

#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02

#define SBARS_SIZEGRIP          0x0100

#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080

#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_NOHILITE            0x00000010L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L

#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#define LVS_NOSCROLL            0x2000

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000

#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020

#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#define TCS_SHAREIMAGELISTS     0x0040
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000

#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004

#endif // (WINVER >= 0x0400)

// 32-bit language/sub-language identifiers

#ifndef LANG_NEUTRAL
// Primary language IDs.
#define LANG_NEUTRAL                     0x00

#define LANG_BULGARIAN                   0x02
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_TURKISH                     0x1f
#endif //!LANG_NEUTRAL

#ifndef SUBLANG_NEUTRAL
// Sublanguage IDs.
#define SUBLANG_NEUTRAL                  0x00
#define SUBLANG_DEFAULT                  0x01
#define SUBLANG_SYS_DEFAULT              0x02

#define SUBLANG_CHINESE_TRADITIONAL      0x01
#define SUBLANG_CHINESE_SIMPLIFIED       0x02
#define SUBLANG_CHINESE_HONGKONG         0x03
#define SUBLANG_CHINESE_SINGAPORE        0x04
#define SUBLANG_DUTCH                    0x01
#define SUBLANG_DUTCH_BELGIAN            0x02
#define SUBLANG_ENGLISH_US               0x01
#define SUBLANG_ENGLISH_UK               0x02
#define SUBLANG_ENGLISH_AUS              0x03
#define SUBLANG_ENGLISH_CAN              0x04
#define SUBLANG_ENGLISH_NZ               0x05
#define SUBLANG_ENGLISH_EIRE             0x06
#define SUBLANG_FRENCH                   0x01
#define SUBLANG_FRENCH_BELGIAN           0x02
#define SUBLANG_FRENCH_CANADIAN          0x03
#define SUBLANG_FRENCH_SWISS             0x04
#define SUBLANG_GERMAN                   0x01
#define SUBLANG_GERMAN_SWISS             0x02
#define SUBLANG_GERMAN_AUSTRIAN          0x03
#define SUBLANG_ITALIAN                  0x01
#define SUBLANG_ITALIAN_SWISS            0x02
#define SUBLANG_NORWEGIAN_BOKMAL         0x01
#define SUBLANG_NORWEGIAN_NYNORSK        0x02
#define SUBLANG_PORTUGUESE               0x02
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01
#define SUBLANG_SPANISH                  0x01
#define SUBLANG_SPANISH_MEXICAN          0x02
#define SUBLANG_SPANISH_MODERN           0x03
#endif //!SUBLANG_NEUTRAL

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
#if (WINVER >= 0x0400)
#define IDCLOSE         8
#define IDHELP          9
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\wabtest.h ===
#ifndef PABTEST_H
#define PABTEST_H

//#define TESTPASS

// Set the provider to either PAB or WAB
//#define PAB
#ifndef PAB
#define WAB
#endif

#include <windows.h>
#include <windowsx.h>

#ifdef WAB
//
// WAB Headers
//
#include <wab.h>
#endif

#ifdef PAB
//
// MAPI headers
//
#include <mapiwin.h>
#include <mapidefs.h>
#include <mapicode.h>
#include <mapitags.h>
//#include <mapispi.h>
#include <mapiutil.h>
#include <mapival.h>
#include <mapix.h>
#include <mapiutil.h>
#endif

//MAPI Headers that are needed for WAB
#include <mapiguid.h>


#include <limits.h>
#include <memory.h>
#include <commdlg.h>
#include <stdio.h>
#include <string.h>
#include <mbstring.h>
#include <time.h>
#include <math.h>


#include <unknwn.h>




LRESULT CALLBACK WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam);



// Foreign Address Book Provider MAPIUID
//#define MUIDFAB {0x45,0xef,0xe6,0xe0,0xfd,0xd8,0x11,0xce,0xa4,0x88,0x00,0xaa,0x00,0x47,0xfa,0xa4}



// Test for PT_ERROR property tag
#define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))


// Blank tags                    
#define	IN 
#define	OUT
#define BIG_BUF	256
#define MAX_BUF 1000
#define SML_BUF	50
#define MAXMENU 20
#define MAXSTRING 64
#define INIFILENAME "c:\\Pabtests.ini"

// Flag used only in sample code shell toswitch between operations
// using and not-using UI
#define SAMPWAB_ADDRESS_UI  0x00000001

#define BUFFERSIZE	1024
#define BUFFERSIZE2 2003
#define BUFFERSIZE3	4096
#define PATTERN	0xA5	// 1 byte test pattern for verifying memory
#define INVALIDPTR	0xfeeefeee
#define AUTONUM_OFF 0xFFFF

HRESULT OpenPABID(
                IN  LPADRBOOK	lpAdrBook,
                OUT ULONG		*lpcbEidPAB,
                OUT LPENTRYID	*lppEidPAB,
                OUT LPABCONT	*lppPABCont,
				OUT ULONG		*lpulObjType);

#ifdef PAB
BOOL MapiUnInit(IN LPMAPISESSION);
BOOL MapiInitLogon(OUT LPMAPISESSION *);
#endif

BOOL GetPropsFromIniBufEntry(LPSTR,ULONG,char (*)[BIG_BUF]);
HRESULT HrCreateEntryListFromID(LPWABOBJECT,
                    IN ULONG ,                     // count of bytes in Entry ID
                    IN LPENTRYID ,                 // pointer to Entry ID
                    OUT LPENTRYLIST FAR *); // pointer to address variable of Entry
                                                        // list
BOOL GetAB(OUT LPADRBOOK*);
BOOL ValidateAdrList(LPADRLIST, ULONG);
BOOL PabCreateEntry();
BOOL PabDeleteEntry();
BOOL PabEnumerateAll();
BOOL ClearPab(int);
BOOL CreateOneOff();
BOOL PABResolveName();
BOOL PABSetProps();
BOOL PABQueryInterface();
BOOL PABPrepareRecips();
BOOL PABCopyEntries();
BOOL PABRunBVT();
BOOL PABAllocateBuffer();
BOOL PABAllocateMore();
BOOL PABFreeBuffer();
BOOL PAB_IABOpenEntry();
BOOL PAB_IABContainerCreateEntry();
BOOL PAB_IMailUserSetGetProps();
BOOL PAB_IMailUserSaveChanges();
BOOL PAB_IABContainerResolveNames();
BOOL PAB_IABContainerOpenEntry();
BOOL PAB_IABAddress();
BOOL PAB_AddMultipleEntries();
BOOL PAB_IABResolveName();
BOOL PAB_IABNewEntry_Details();
BOOL ThreadManager();
BOOL ThreadStress(LPVOID);
BOOL Performance();
BOOL PAB_IDLSuite();
BOOL NamedPropsSuite();

BOOL AllocateAdrList(LPWABOBJECT, int, int, LPADRLIST *);
BOOL FreeAdrList(LPWABOBJECT, LPADRLIST *);
BOOL FreePartAdrList(IN LPADRLIST *);
BOOL GrowAdrList(UINT, UINT, LPADRLIST *);
BOOL ParseIniBuffer(LPSTR, UINT, LPSTR);
BOOL VerifyBuffer(DWORD **, DWORD);
BOOL DisplayAdrList(LPADRLIST, ULONG);
BOOL VerifyResolvedAdrList(LPADRLIST, char*);
BOOL CALLBACK SetIniFile(HWND,UINT, WPARAM, LONG);
BOOL LogIt(HRESULT, int, char *);
BOOL PropError(ULONG, ULONG);
BOOL FindProp(LPADRENTRY, ULONG, unsigned int*);
BOOL FreeEntryList(LPWABOBJECT, IN LPENTRYLIST *);
BOOL FreeRows(LPWABOBJECT, LPSRowSet far*);
BOOL DisplayRows(LPSRowSet lpRows);
BOOL FindPropinRow(LPSRow, ULONG, unsigned int*);
BOOL DeleteWABFile();
BOOL MyRegOpenKeyEx(HKEY, char*, REGSAM, HKEY*);
BOOL CreateMultipleEntries(IN UINT, OUT DWORD*);
HRESULT HrCreateEntryListFromRows(LPWABOBJECT, LPSRowSet far*, LPENTRYLIST FAR *);
void GenerateRandomPhoneNumber(char **lppPhone);
void GenerateRandomText(char **lppPhone, UINT);
void CreateProps(LPTSTR, LPTSTR, SPropValue**, ULONG*, UINT, char**, char**);
BOOL CompareProps(SPropValue*, ULONG, SPropValue*, ULONG);
BOOL DisplayProp(SPropValue *, ULONG, ULONG);
void GenerateRandomBoolean(unsigned short *);
void GenerateRandomLong(long *);
void GenerateRandomBinary(SBinary *, UINT);


struct EntryID {
	char*	lpDisplayName;
	ULONG	cb;
	LPBYTE	lpb;
};

struct PropTableEntry {
	ULONG	ulPropTag;	//MAPI Property ID
	char*	lpszPropTag;	//String version of the prop name for lookup in ini file

//	void*	lpValue;	//ptr to the value if supplied or NULL if don't use or create random
	UINT	unSize;		//size of rand value to create or 0 if don't use or value supplied in lpValue
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\dlgprop.h ===
#if !defined(AFX_DLGPROP_H__ED006BC1_F340_11D0_9A82_00A0C91F9C8B__INCLUDED_)
#define AFX_DLGPROP_H__ED006BC1_F340_11D0_9A82_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgProp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgProp dialog

class CDlgProp : public CDialog
{
// Construction
public:
	CDlgProp(CWnd* pParent = NULL);   // standard constructor

    ULONG   m_ulPropTag;
    LPTSTR  m_lpszPropVal;
    ULONG   m_cbsz;

// Dialog Data
	//{{AFX_DATA(CDlgProp)
	enum { IDD = IDD_DIALOG_PROP };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgProp)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGPROP_H__ED006BC1_F340_11D0_9A82_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\dlgprop.cpp ===
// DlgProp.cpp : implementation file
//

#include "stdafx.h"
#include "wabtool.h"
#include "DlgProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgProp dialog


CDlgProp::CDlgProp(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgProp::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgProp)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgProp::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgProp)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgProp, CDialog)
	//{{AFX_MSG_MAP(CDlgProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgProp message handlers

BOOL CDlgProp::OnInitDialog() 
{
	CDialog::OnInitDialog();

    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT_TAG);
    pEdit->SetLimitText(32);
    TCHAR sz[32];
    wsprintf(sz, "%x", m_ulPropTag);
    pEdit->SetWindowText(sz);


    pEdit = (CEdit *) GetDlgItem(IDC_EDIT_VALUE);
    pEdit->SetLimitText(512);
    pEdit->SetWindowText(m_lpszPropVal);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

ULONG GetULONGVal(CEdit * pEdit)
{
    TCHAR sz[32];
    const LPTSTR lpZero = "00000000";

    pEdit->GetWindowText(sz, sizeof(sz));

    int nLen = lstrlen(sz);
    if(nLen < 8)
    {
        // pad with zeros
        TCHAR sz1[32];
        lstrcpy(sz1, sz);
        CopyMemory(sz, lpZero, 8-nLen);
        sz[8-nLen] = '\0';
        lstrcat(sz, sz1);
    }

    CharUpper(sz);
    LPTSTR lp = sz;
    ULONG ulVal = 0;

    while(lp && *lp)
    {
        int i = 0;

        if(*lp >= 'A' && *lp <= 'F')
            i = *lp - 'A' + 10;
        else if(*lp >= '0' && *lp <= '9')
            i = *lp - '0';

        ulVal = ulVal * 16 + i;

        lp = CharNext(lp);
    }

    return ulVal;
}

void CDlgProp::OnOK() 
{
    m_ulPropTag = GetULONGVal((CEdit *) GetDlgItem(IDC_EDIT_TAG));
	
    GetDlgItemText(IDC_EDIT_VALUE, m_lpszPropVal, m_cbsz);

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtests\wabtest.cpp ===
#include "wabtest.h"

#include <assert.h>
#include "resource.h"
#include "..\luieng.dll\luieng.h"
#include "wabtest.h"


#define IDM_CREATEENTRIES 2000
#define	IDM_ENUMERATEALL 2001
#define	IDM_DELETEENTRIES 2002
#define IDM_DELETEALL 2003
#define	IDM_DELETEUSERSONLY 2004
#define IDM_CREATEONEOFF	2005
#define IDM_RESOLVENAME		2006
#define IDM_SETPROPS		2007
#define IDM_QUERYINTERFACE	2008
#define IDM_PREPARERECIPS	2009
#define IDM_COPYENTRIES		2010
#define IDM_RUNBVT			2011
#define IDM_ALLOCATEBUFFER	2012
#define IDM_ALLOCATEMORE	2013
#define IDM_FREEBUFFER		2014
#define IDM_IABOPENENTRY    2015
#define IDM_ICCREATEENTRY	2016
#define IDM_IMUSETGETPROPS	2017
#define IDM_IMUSAVECHANGES	2018
#define IDM_ICRESOLVENAMES	2019
#define IDM_ICOPENENTRY		2020
#define IDM_IABADDRESS		2021
#define IDM_ADDMULTIPLE		2022
#define IDM_IABRESOLVENAME	2023
#define IDM_MULTITHREAD		2024
#define IDM_IABNEWENTRYDET	2025
#define IDM_DELWAB			2026
#define IDM_PERFORMANCE		2027
#define IDM_IDLSUITE		2028
#define IDM_NAMEDPROPS		2029

#define IDM_SETINIFILE		2501
#define ID_MULTITHREADCOMPLETE	2502



//
// Globals
//
GUID WabTestGUID = { /* 683ce274-343a-11d0-9ff1-00a0c905424c */
    0x683ce274,
    0x343a,
    0x11d0,
    {0x9f, 0xf1, 0x00, 0xa0, 0xc9, 0x05, 0x42, 0x4c}
  };
static char szAppName[]= "WABTESTS";
char szIniFile[BIG_BUF];
CRITICAL_SECTION	CriticalSection;
ULONG	glblCount = 0, glblTest = 39, glblDN = 0;

#ifdef PAB
LPMAPISESSION	lpMAPISession;	//Global handle to session
#endif
#ifdef WAB
LPWABOBJECT		lpWABObject; //Global handle to session
LPADRBOOK		glbllpAdrBook;
#endif

DWORD ThreadIdJunk;
HWND glblhwnd;
HINSTANCE hinstLib, glblhinst;
HANDLE glblThreadManager;
LUIINIT LUIInit;
LUIMSGHANDLER LUIMsgHandler;
LUIOUT LUIOut;
BOOL bLUIInit, glblStop, Seeded;

//***************************************************************

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR lpszCmdLine, int nCmdShow)
	{
	HWND hwnd;
	MSG msg;
	WNDCLASS wndclass;


	//
	// Init Global Variables Here
	//
#ifdef PAB
	lpMAPISession = NULL;
#endif
	glblThreadManager = NULL;
	bLUIInit = FALSE;
	glblStop = FALSE;
	Seeded = FALSE;

	if (!hPrevInstance)
		{
		wndclass.style = CS_HREDRAW|CS_VREDRAW;
		wndclass.lpfnWndProc = WndProc;
		wndclass.hInstance = hInstance;
		wndclass.cbClsExtra = 4;
		wndclass.cbWndExtra = 0;
		wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1);
		wndclass.hIcon = LoadIcon(NULL,IDI_APPLICATION);
		wndclass.hCursor = LoadCursor(NULL,IDC_ARROW);
		wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
		wndclass.lpszClassName = szAppName;

		RegisterClass(&wndclass);
		}

	hwnd = CreateWindow(szAppName,"WABTests", WS_OVERLAPPEDWINDOW,
						CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,
						NULL, NULL, hInstance, NULL);

	hinstLib = LoadLibrary("luieng.dll");
	if (hinstLib) {
		LUIInit = (LUIINIT)GetProcAddress(hinstLib,"LUIInit");
		LUIMsgHandler=(LUIMSGHANDLER)GetProcAddress(hinstLib,"LUIMsgHandler");
		LUIOut = (LUIOUT)GetProcAddress(hinstLib,"LUIOut");

		lstrcpy(szIniFile,INIFILENAME);
	
		MenuStruct Tests[MAXMENU];
		MenuStruct Tools[MAXMENU];
		MenuStruct TestSettings[MAXMENU];

		memset((void *)Tests,0,sizeof(Tests));
		memset((void *)Tools,0,sizeof(Tests));
		memset((void *)TestSettings,0,sizeof(TestSettings));

		Tests[0].nType = LINE;
		Tests[1].nItemID = IDM_ALLOCATEBUFFER;
		Tests[1].nType = NORMAL;
		lstrcpy(Tests[1].lpszItemName,"&AllocateBuffer");
		Tests[2].nItemID = IDM_ALLOCATEMORE;
		Tests[2].nType = NORMAL;
		lstrcpy(Tests[2].lpszItemName,"&AllocateMore");
		Tests[3].nItemID = IDM_FREEBUFFER;
		Tests[3].nType = NORMAL;
		lstrcpy(Tests[3].lpszItemName,"&FreeBuffer");
		Tests[4].nItemID = IDM_IABOPENENTRY;
		Tests[4].nType = NORMAL;
		lstrcpy(Tests[4].lpszItemName,"IAB->OpenEntry");
		Tests[5].nItemID = IDM_IABADDRESS;
		Tests[5].nType = NORMAL;
		lstrcpy(Tests[5].lpszItemName,"IAB->Address");
		Tests[6].nItemID = IDM_IABRESOLVENAME;
		Tests[6].nType = NORMAL;
		lstrcpy(Tests[6].lpszItemName,"IAB->ResolveName");
		Tests[7].nItemID = IDM_IABNEWENTRYDET;
		Tests[7].nType = NORMAL;
		lstrcpy(Tests[7].lpszItemName,"IAB->NewEntry/Det");
		Tests[8].nItemID = IDM_ICCREATEENTRY;
		Tests[8].nType = NORMAL;
		lstrcpy(Tests[8].lpszItemName,"ICtr->CreateEntry");
		Tests[9].nItemID = IDM_ICRESOLVENAMES;
		Tests[9].nType = NORMAL;
		lstrcpy(Tests[9].lpszItemName,"ICtr->ResolveNames");
		Tests[10].nItemID = IDM_ICOPENENTRY;
		Tests[10].nType = NORMAL;
		lstrcpy(Tests[10].lpszItemName,"ICtr->OpenEntry");
		Tests[11].nItemID = IDM_IMUSETGETPROPS;
		Tests[11].nType = NORMAL;
		lstrcpy(Tests[11].lpszItemName,"IMU->Set/GetProps");
		Tests[12].nItemID = IDM_IMUSAVECHANGES;
		Tests[12].nType = NORMAL;
		lstrcpy(Tests[12].lpszItemName,"IMU->SaveChanges");
		Tests[13].nItemID = IDM_IDLSUITE;
		Tests[13].nType = NORMAL;
		lstrcpy(Tests[13].lpszItemName,"IDL Test Suite");
		Tests[14].nItemID = IDM_NAMEDPROPS;
		Tests[14].nType = NORMAL;
		lstrcpy(Tests[14].lpszItemName,"Named Props Suite");

		Tests[15].nType= ENDMENU;

/*		Tests[15].nType = LINE;
		Tests[16].nItemID = IDM_ADDMULTIPLE;
		Tests[16].nType = NORMAL;
		lstrcpy(Tests[16].lpszItemName,"AddMultipleEntries");
		Tests[17].nItemID = IDM_DELWAB;
		Tests[17].nType = NORMAL;
		lstrcpy(Tests[17].lpszItemName,"DeleteWABFile");
		Tests[18].nItemID = IDM_PERFORMANCE;
		Tests[18].nType = NORMAL;
		lstrcpy(Tests[18].lpszItemName,"Performance Suite");
		Tests[19].nItemID = IDM_MULTITHREAD;
		Tests[19].nType = NORMAL;
		lstrcpy(Tests[19].lpszItemName,"MultiThreadStress");
		
		Tests[6].nItemID = IDM_CREATEENTRIES;
		Tests[6].nType = NORMAL;
		lstrcpy(Tests[6].lpszItemName,"&CreateEntries");
		Tests[7].nItemID = IDM_ENUMERATEALL;
		Tests[7].nType = NORMAL;
		lstrcpy(Tests[7].lpszItemName,"&EnumerateAll");
		Tests[8].nItemID = IDM_DELETEENTRIES;
		Tests[8].nType = NORMAL;
		lstrcpy(Tests[8].lpszItemName,"&DeleteEntries");
		Tests[9].nItemID = IDM_DELETEALL;
		Tests[9].nType = NORMAL;
		lstrcpy(Tests[9].lpszItemName,"Delete&All");
		*/

		
		TestSettings[0].nItemID = IDM_SETINIFILE;
		TestSettings[0].nType = NORMAL;
		lstrcpy(TestSettings[0].lpszItemName,"&INI File");
		TestSettings[1].nType = ENDMENU;
	
		Tools[0].nItemID = IDM_ADDMULTIPLE;
		Tools[0].nType = NORMAL;
		lstrcpy(Tools[0].lpszItemName,"AddMultipleEntries");
		Tools[1].nItemID = IDM_DELWAB;
		Tools[1].nType = NORMAL;
		lstrcpy(Tools[1].lpszItemName,"DeleteWABFile");
		Tools[2].nItemID = IDM_PERFORMANCE;
		Tools[2].nType = NORMAL;
		lstrcpy(Tools[2].lpszItemName,"Performance Suite");
		Tools[4].nType= ENDMENU;
		Tools[3].nItemID = IDM_MULTITHREAD;
		Tools[3].nType = NORMAL;
		lstrcpy(Tools[3].lpszItemName,"MultiThreadStress");

		bLUIInit = LUIInit(hwnd,Tests,Tools,/*TestSettings,*/FALSE);

		glblhwnd=hwnd;
		glblhinst=hInstance;
		ShowWindow(hwnd, nCmdShow);
		UpdateWindow(hwnd);

		while(GetMessage(&msg,NULL,0,0))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}

		FreeLibrary(hinstLib);
	}
	else MessageBox(NULL,"LoadLibrary Failed: Cannot find testcntl.dll","PabTest Error",MB_OK);	
	return msg.wParam;
	}

//***************************************************************

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
	static int i;
	DWORD	retval;
	
	if (bLUIInit)
		LUIMsgHandler(message,wParam,lParam);
	
	switch(message)
	{
	case WM_CREATE:
		{
			i=0;
			return 0;
		}
	case WM_SIZE:
		{
			return 0;
		}
	case WM_COMMAND:
		{
			switch(LOWORD(wParam))
			{
			case IDM_STOP :
				glblStop = TRUE;
				break;
			case IDM_ALLOCATEBUFFER:
				if (PABAllocateBuffer()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"AllocateBuffer: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"AllocateBuffer: %d",i);
				}
				i++;
				return 0;
			
			case IDM_ALLOCATEMORE:
				if (PABAllocateMore()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"AllocateMore: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"AllocateMore: %d",i);
				}
				i++;
				return 0;
			
			case IDM_FREEBUFFER :
				if (PABFreeBuffer()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"FreeBuffer: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"FreeBuffer: %d",i);
				}
				i++;
				return 0;
			
			case IDM_IABOPENENTRY :
				if (PAB_IABOpenEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAddrBook->OpenEntry: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAddrBook->OpenEntry: %d",i);
				}
				i++;
				return 0;
			

			case IDM_ICCREATEENTRY :
				if (PAB_IABContainerCreateEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IABContainer->CreateEntry: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IABContainer->CreateEntry: %d",i);
				}
				i++;
				return 0;
			

			case IDM_IMUSETGETPROPS :
				if (PAB_IMailUserSetGetProps()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IMailUser->Set/GetProps: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IMailUser->Set/GetProps: %d",i);
				}
				i++;
				return 0;

			case IDM_IMUSAVECHANGES :
				if (PAB_IMailUserSaveChanges()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IMailUser->SaveChanges: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IMailUser->SaveChanges: %d",i);
				}
				i++;
				return 0;

			
			case IDM_ICRESOLVENAMES :
				if (PAB_IABContainerResolveNames()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IABContainer->ResolveNames: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IABContainer->ResolveNames: %d",i);
				}
				i++;
				return 0;


			case IDM_ICOPENENTRY :
				if (PAB_IABContainerOpenEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IABContainer->OpenEntry: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IABContainer->OpenEntry: %d",i);
				}
				i++;
				return 0;


			case IDM_IABADDRESS :
				if (PAB_IABAddress()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAdrBook->Address: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAdrBook->Address: %d",i);
				}
				i++;
				return 0;
			
			case IDM_ADDMULTIPLE :
				if (PAB_AddMultipleEntries()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"AddMultipleEntries: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"AddMultipleEntries: %d",i);
				}
				i++;
				return 0;
			
			case IDM_IABRESOLVENAME :
				if (PAB_IABResolveName()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAdrBook->ResolveName: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAdrBook->ResolveName: %d",i);
				}
				i++;
				return 0;
			

			case IDM_IABNEWENTRYDET :
				if (PAB_IABNewEntry_Details()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"IAdrBook->NewEntry/Details: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"IAdrBook->NewEntry/Details: %d",i);
				}
				i++;
				return 0;
			

			case IDM_CREATEENTRIES :
				if (PabCreateEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Create Entries: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Create Entries: %d",i);
				}
				i++;
				return 0;
			
			case IDM_MULTITHREAD :
				if (glblThreadManager) {
					LUIOut(L1, "In cleanup routine");
					TerminateThread(glblThreadManager, (DWORD)0);
					CloseHandle(glblThreadManager);
				}
				glblThreadManager =(HANDLE)CreateThread(
					(LPSECURITY_ATTRIBUTES) NULL,		// pointer to thread security attributes
					(DWORD) 0,							// initial thread stack size, in bytes
					(LPTHREAD_START_ROUTINE) ThreadManager,		// pointer to thread function
					(LPVOID) NULL,						// argument for new thread
					(DWORD) 0,							// creation flags
					&ThreadIdJunk						// pointer to returned thread identifier
				);
				if (!glblThreadManager) LUIOut(L1, "<ERROR> WndProc: CreateThread returned 0x%X", GetLastError());
				return 0;
			
			case ID_MULTITHREADCOMPLETE :
				if (glblThreadManager) {
					//GetExitCodeThread(glblThreadManager, &retval);
					retval = HIWORD(wParam);
					if (retval) {
						LUIOut(L1," ");
						LUIOut(LPASS,"MultiThreadStress: %d",i);
					}
					else {
						LUIOut(L1," ");
						LUIOut(LFAIL,"MultiThreadStress: %d",i);
					}
					CloseHandle(glblThreadManager);
				}
				
				glblStop = FALSE;		//reset stop flag
				i++;
				return 0;
			
			case IDM_DELWAB :
				if (DeleteWABFile()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete WAB File: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete WAB File: %d",i);
				}
				i++;
				return 0;
			
			case IDM_IDLSUITE :
				if (PAB_IDLSuite()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Distribution List Test Suite: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Distribution List Test Suite: %d",i);
				}
				i++;
				return 0;
		

			case IDM_PERFORMANCE :
				if (Performance()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"WAB Performance Suite: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"WAB Performance Suite: %d",i);
				}
				i++;
				return 0;
			
			case IDM_NAMEDPROPS :
				if (NamedPropsSuite()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Named Properties Test Suite: %d",i);
				}
				else {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Named Properties Test Suite: %d",i);
				}
				i++;
				return 0;

			case IDM_ENUMERATEALL :
				if (PabEnumerateAll())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"Enumerate All: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Enumerate All: %d",i);
				}
				i++;
				return 0;
			
			case IDM_DELETEENTRIES :
				if (PabDeleteEntry()) {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete specified Entries: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete specified Entries: %d",i);
				}
				i++;
				return 0;
			
			case IDM_DELETEALL:
				if (ClearPab(0))  {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete All Entries: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete All Entries: %d",i);
				}
				i++;
				return 0;
	
			case IDM_DELETEUSERSONLY:
				if (ClearPab(1))  {
					LUIOut(L1," ");
					LUIOut(LPASS,"Delete Mail Users Only: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"Delete Mail Users Only: %d",i);
				}
				i++;
				return 0;

			case IDM_CREATEONEOFF :
				if (CreateOneOff())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"CreateOneOff: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"CreateOneOff: %d",i);
				}
				i++;
				return 0;
			
			case IDM_RESOLVENAME :
				if (PABResolveName())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"ResolveName: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"ResolveName: %d",i);
				}
				i++;
				return 0;

			case IDM_SETPROPS :
				if (PABSetProps())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"SetProps: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"SetProps: %d",i);
				}
				i++;
				return 0;
		
			case IDM_QUERYINTERFACE :
				if (PABQueryInterface())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"QueryInterface: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"QueryInterface: %d",i);
				}
				i++;
				return 0;
			
			case IDM_PREPARERECIPS :
				if (PABPrepareRecips())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"PrepareRecips: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"PrepareRecips: %d",i);
				}
				i++;
				return 0;

			case IDM_COPYENTRIES :
				if (PABCopyEntries())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"CopyEntries: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"CopyEntries: %d",i);
				}
				i++;
				return 0;

			case IDM_RUNBVT :
				if (PABRunBVT())  {
					LUIOut(L1," ");
					LUIOut(LPASS,"RunBVT: %d",i);
				}
				else  {
					LUIOut(L1," ");
					LUIOut(LFAIL,"RunBVT: %d",i);
				}
				i++;
				return 0;

			case IDM_SETINIFILE :
				DialogBox(glblhinst, MAKEINTRESOURCE(IDD_INIFILE), glblhwnd, SetIniFile);
				return 0;    			
			}
			return 0;
		}

	case WM_DESTROY:
		{
			PostQuitMessage(0);
			return 0;
		}
	}
	return DefWindowProc(hwnd,message,wParam,lParam);
}

BOOL PABAllocateBuffer()
{
    DWORD ** lppBuffer;
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	
	LUIOut(L1," ");
	LUIOut(L1,"Running AllocateBuffer");
	LUIOut(L2,"-> Allocates and confirms memory using the Allocate Buffer");
	LUIOut(L2, "   routine. confirms by writing a bit pattern and verifying.");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Allocate a buffer and check for success
	
	lppBuffer = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"MAPIAllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	if ( !VerifyBuffer(lppBuffer,BUFFERSIZE) )
		retval = FALSE;

out:
#ifdef PAB
		if (*lppBuffer)	{
			if (MAPIFreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"MAPIFreeBuffer Succeded");	
			else 	LUIOut(L2,"MAPIFreeBuffer Failed");
		}

		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (*lppBuffer)	{
			if (lpWABObject->FreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"lpWABObject->FreeBuffer Succeded");	
			else 	LUIOut(L2,"lpWABObject->FreeBuffer Failed");
		}

		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();


		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();

#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PABAllocateMore()
{
    DWORD ** lppBuffer, ** lppBuffer2, ** lppBuffer3;
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;

	LUIOut(L1," ");
	LUIOut(L1,"Running AllocateMore");
	LUIOut(L2,"-> Allocates memory using the AllocateBuffer routine");
	LUIOut(L2, "    followed by two calls to AllocateMore using different");
	LUIOut(L2, "    buffer sizes. It then confirms the buffer by writing");
	LUIOut(L2, "    a bit pattern and verifying.");
	LUIOut(L1," ");


	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Allocate a buffer and check for success
	
	lppBuffer = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"MAPIAllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer2 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer3 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	if ( !VerifyBuffer(lppBuffer,BUFFERSIZE) )
		retval = FALSE;
	if ( !VerifyBuffer(lppBuffer2,BUFFERSIZE2) )
		retval = FALSE;
	if ( !VerifyBuffer(lppBuffer3,BUFFERSIZE3) )
		retval = FALSE;


out:
#ifdef PAB
		if (*lppBuffer)	{
			if (MAPIFreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"MAPIFreeBuffer Succeded");	
			else 	LUIOut(L2,"MAPIFreeBuffer Failed");
		}

		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (*lppBuffer)	{
			if (lpWABObject->FreeBuffer(*lppBuffer) == S_OK)
				LUIOut(L2,"lpWABObject->FreeBuffer Succeded");	
			else 	LUIOut(L2,"lpWABObject->FreeBuffer Failed");
		}

		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PABFreeBuffer()
{
    DWORD ** lppBuffer, ** lppBuffer2, ** lppBuffer3;
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	
	LUIOut(L1," ");
	LUIOut(L1,"Running FreeBuffer");
	LUIOut(L2,"-> Allocates memory using the AllocateBuffer routine");
	LUIOut(L2, "    followed by two calls to AllocateMore using different");
	LUIOut(L2, "    buffer sizes. It then frees the initial buffer and verifies");
	LUIOut(L2, "    that all 3 pointers are nullified.");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Allocate a buffer and check for success
	
	lppBuffer = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"MAPIAllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateBuffer(BUFFERSIZE, (LPVOID FAR *)lppBuffer) == S_OK) && *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateBuffer PASSED");
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer2 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE2, *lppBuffer, (LPVOID FAR *)lppBuffer2) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE2);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

	lppBuffer3 = new (DWORD*);
#ifdef PAB
	if ((MAPIAllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"MAPIAllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"MAPIAllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif

#ifdef WAB
	if ((lpWABObject->AllocateMore(BUFFERSIZE3, *lppBuffer, (LPVOID FAR *)lppBuffer3) == S_OK)
		&& *lppBuffer)
			LUIOut(L2,"lpWABObject->AllocateMore PASSED, %u bytes allocated", BUFFERSIZE3);
	else 	{
		LUIOut(L2,"lpWABObject->AllocateBuffer FAILED");
		retval = FALSE;
		goto out;
	}
#endif


	// Now free the original buffer
#ifdef PAB
	if (*lppBuffer)	{
		if (MAPIFreeBuffer(*lppBuffer) == S_OK)
			LUIOut(L2,"Call to MAPIFreeBuffer Succeded");	
		else	{
			LUIOut(L2,"Call to MAPIFreeBuffer Failed");
		}
	}
#endif
#ifdef WAB
	if (*lppBuffer)	{
		if (lpWABObject->FreeBuffer(*lppBuffer) == S_OK)
			LUIOut(L2,"Call to lpWABObject->FreeBuffer Succeded");	
		else	{
			LUIOut(L2,"Call to lpWABObject->FreeBuffer Failed");
		}
	}
#endif

	/*
	dwTest = INVALIDPTR;
	//Verify all 3 pointers are now null
	if (IsBadReadPtr(*lppBuffer,BUFFERSIZE)&&IsBadReadPtr(*lppBuffer2, BUFFERSIZE2)
		&&IsBadReadPtr(*lppBuffer3, BUFFERSIZE3)){
		LUIOut(L2,"MAPIFreeBuffer Succeded, all pointers are invalidated");			
	}
	else	{	
		LUIOut(L2,"MAPIFreeBuffer Failed to invalidate all pointers");	
		retval = FALSE;
	}
	*/
out:

#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}		 		 		


BOOL PAB_IABOpenEntry()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	ULONG		  cbEidPAB = 0;
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABOpenEntry");
	LUIOut(L2,"-> Verifies IAddrBook->OpenEntry is functional by checking the following:");
	LUIOut(L2, "   # The return code from OpenEntry");
	LUIOut(L2, "   # The object type returned is compared to MAPI_ABCONT");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L1," ");

	
	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}


	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	LUIOut(L2, "Calling IABOpenEntry");
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr) || (!lpABCont)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}
	LUIOut(L3, "The call to IABOpenEntry PASSED");

	// Check to make sure the object type is what we expect

	LUIOut(L3, "Checking to make sure the returned object type is correct");
	if (ulObjType != MAPI_ABCONT) {
		LUIOut(L2, "Object type is not MAPI_ABCONT");
		retval = FALSE;
		goto out;
	}
	LUIOut(L3, "Object type is MAPI_ABCONT");
	
	
	// Call QueryInterface on the object
	LUIOut(L3, "Calling QueryInterface on the returned object");	
	hr = (lpABCont->QueryInterface((REFIID)(IID_IABContainer), (VOID **) &lpABCont2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IABContainer FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "QueryInterface on IID_IABContainer PASSED");

	LUIOut(L3, "Trying to release the object QI returned");
	if(lpABCont2)	{
		if ((LPUNKNOWN)(lpABCont2)->Release() <= 0)
			LUIOut(L3, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpABCont2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpABCont)
				lpABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}



BOOL PAB_IABContainerCreateEntry()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
    LPMAILUSER  lpAddress=NULL,lpAddress2=NULL,lpAddress3=NULL,lpAddress4=NULL;
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABContainerCreateEntry");
	LUIOut(L2,"-> Verifies IABContainer->CreateEntry is functional by performing the following:");
	LUIOut(L2, "   Attempts to CreateEntry with the MailUser template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L2, "   Attempts to CreateEntry with the DistList template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpAddress);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}


	// Call QueryInterface on the object
	
	hr = (lpAddress->QueryInterface((REFIID)(IID_IMailUser), (VOID **) &lpAddress2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IMailUser FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L2, "QueryInterface on IID_IMailUser PASSED");

	if(lpAddress2)	{
		if ((LPUNKNOWN)(lpAddress2)->Release() <= 0)
			LUIOut(L2, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpAddress2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpAddress3);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}


	// Call QueryInterface on the object
	hr = (lpAddress3->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpAddress4));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IDistList FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L2, "QueryInterface on IID_IDistList PASSED");

	if(lpAddress4)	{
		if ((LPUNKNOWN)(lpAddress4)->Release() <= 0)
			LUIOut(L2, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpAddress4 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}
#endif

out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpAddress)
			lpAddress->Release();

		if (lpAddress2)
			lpAddress2->Release();

		if (lpAddress3)
			lpAddress3->Release();

		if (lpAddress4)
			lpAddress4->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}



BOOL PAB_IDLSuite()
{
	BOOL	Cleanup;
    HRESULT hr      = hrSuccess;
	int		retval=TRUE;
	ULONG	cbEidPAB = 0;
	ULONG   cbEid=0;  // entry id of the entry being added
	ULONG   cValues = 0, ulObjType=NULL, cValues2;	
    ULONG   cRows           = 0;
	UINT	Entry, DL, NumEntries, NumDLs, PropIndex;
	char	szDLTag[SML_BUF], *lpszDisplayName = NULL, *lpszReturnName = NULL;
	EntryID	*lpEntries, *lpDLs;
	char	EntryBuf[MAX_BUF];
		
	LPENTRYID		lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST		lpEntryList=NULL; // needed for copy entry to PDL
    LPADRBOOK		lpAdrBook= NULL;
	LPABCONT		lpABCont= NULL;
    LPMAILUSER		lpMailUser=NULL;
	LPDISTLIST		lpDL=NULL,lpDL2=NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	SRestriction	Restriction;
	SPropValue		*lpPropValue = NULL;		//Used to create props for the mailusers
	SPropValue		PropValue[1]= {0};			//
    LPSPropValue	lpSPropValueAddress = NULL; //Used to create default mailuser
    LPSPropValue	lpSPropValueEntryID = NULL; //Used to getprops on entryid of user
	LPSPropValue	lpSPropValueDL = NULL;		//Used to create default DL
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IDLSuite");
	LUIOut(L2,"-> Tests Distribution List functionality by performing the following:");
	LUIOut(L2, "   Attempts to CreateEntry with the DistList template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L2, "   Calls CreateEntry on the DistList object to add MailUser and DL members and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Create MailUsers in the container
	//

	LUIOut(L2, "Creating MailUsers");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	// Retrieve user info from ini file
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("DLTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	//_itoa(0,(char*)lpszDisplayName[strlen(lpszDisplayName)],10);

	NumEntries = GetPrivateProfileInt("DLTestSuite","NumCopies",0,INIFILENAME);

	//Allocate an array of String pointers to hold the EntryIDs
	lpEntries = (EntryID*)LocalAlloc(LMEM_FIXED, NumEntries * sizeof(EntryID));
	lpszDisplayName = (char*)LocalAlloc(LMEM_FIXED, MAX_BUF);
	ParseIniBuffer(IN EntryBuf, IN 1, OUT lpszDisplayName);

	for (Entry = 0; Entry < NumEntries; Entry++)	{
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//
		CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues2, IN Entry, IN &lpszDisplayName, OUT &lpszReturnName);
	

		LUIOut(L3,"MailUser Entry to Add: %s",lpszReturnName);
			
		hr = lpMailUser->SetProps(IN  cValues2,
								 IN  lpPropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED with 0x%x",hr);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}


		// Store the EID for deleting this entry later
		hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}
		//Allocate space for the display name
		lpEntries[Entry].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(lpszReturnName)+1));
		//Copy the DisplayName for use later
		strcpy(lpEntries[Entry].lpDisplayName, lpszReturnName);
		//Allocate space for the EID (lpb)
		lpEntries[Entry].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpEntries[Entry].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpEntries[Entry].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpEntries[Entry].cb);

		
		//Free the SPropValue for use in the next loop
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}

		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		lpMailUser->Release();
		lpMailUser = NULL;
	}
	
	
	//
	// Create the Distribution Lists in the container
	//
	NumDLs = GetPrivateProfileInt("DLTestSuite","NumDLs",0,INIFILENAME);
	lpDLs = (EntryID*)LocalAlloc(LMEM_FIXED, NumDLs * sizeof(EntryID));
	LUIOut(L2, "Creating Distribution Lists");
	for (DL = 0; DL < NumDLs; DL++) {

		hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueDL);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 			retval=FALSE;			
				goto out;
		}

		// The returned value of PR_DEF_CREATE_DL is an
		// EntryID which can be passed to CreateEntry
		//
		//LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
									 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
			retval=FALSE;			
			goto out;
		}


		// Call QueryInterface on the object
		
		hr = (lpDL->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpDL2));
		if (HR_FAILED(hr))	{
			LUIOut(L4, "QueryInterface on IID_IDistList FAILED. hr = 0x%x", hr);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L4, "QueryInterface on IID_IDistList PASSED");

		lstrcpy(szDLTag,"DistList1");
		GetPrivateProfileString("DLTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

		//StrLen2 = (StrLen1 + sprintf((char*)&EntProp[0][StrLen1], " [Thread #%i] - ", *(int *)lpThreadNum));	
		_itoa(DL,(char*)&EntryBuf[strlen(EntryBuf)],10);

		LUIOut(L3,"DistList Entry to Add: %s",EntryBuf);
		cValues = 1;		
		PropValue[0].Value.LPSZ = (LPTSTR)EntryBuf;
		hr = lpDL->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpDL->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}

		// Want a container interface to the DL, and since QueryInterface on a DL
		// is currently broken (returns a MailUser interface when called with IID_IDistList)
		// we do it the hard way. Call GetProps to get the EID for the new DL, and then
		// call OpenEntry from the container or AB interfaces to open a DL interface
		hr = lpDL->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}

		lpDL2->Release();	//Free up this pointer so we can recycle it
		hr = lpABCont->OpenEntry(IN		lpSPropValueEntryID->Value.bin.cb,
								 IN		(LPENTRYID) lpSPropValueEntryID->Value.bin.lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL2);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		LUIOut(L3, "Adding MailUser Members to the Distribution List");
		
		//
		// Now add mailuser entries to the DL
		//
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = lpDL2->CreateEntry(  IN  lpEntries[Entry].cb,
									 IN  (LPENTRYID) lpEntries[Entry].lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
				retval=FALSE;			
				goto out;
			}

			hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

			if (HR_FAILED(hr)) {
				LUIOut(L3,"MailUser->SaveChanges FAILED");
				retval=FALSE;
				goto out;
			}
			lpMailUser->Release();
			lpMailUser = NULL;
		}

		//Allocate space for the display name
		lpDLs[DL].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(EntryBuf)+1));
		//Copy the DisplayName for use later
		strcpy(lpDLs[DL].lpDisplayName, EntryBuf);
		//Allocate space for the EID (lpb)
		lpDLs[DL].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpDLs[DL].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpDLs[DL].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpDLs[DL].cb);
		
		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		if (lpSPropValueDL) {
			lpWABObject->FreeBuffer(lpSPropValueDL);
			lpSPropValueDL = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
		lpDL2->Release();
		lpDL2 = NULL;
	}

	//
	// Verify all entries are in the DL
	//
	LUIOut(L2, "Verifying MailUser Members are in the Distribution List");

	for (DL = 0; DL < NumDLs; DL++) {
		// Need to get an interface to the DL
		hr = lpABCont->OpenEntry(IN		lpDLs[DL].cb,
								 IN		(LPENTRYID) lpDLs[DL].lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		// Create a contents table to verify each added entry exists in the DL
		hr = lpDL->GetContentsTable(ULONG(0), &lpTable);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DistList->GetContentsTable call FAILED, returned 0x%x", hr);
			retval=FALSE;
			goto out;
		}

		// Allocate the SpropValue ptr in the restriction structure
		lpWABObject->AllocateBuffer(sizeof(SPropValue), (void**)&(Restriction.res.resProperty.lpProp));
		Restriction.res.resProperty.lpProp = (SPropValue*)Restriction.res.resProperty.lpProp;
		for (Entry = 0; Entry < NumEntries; Entry++) {
			hr = lpDL->OpenEntry(	IN		lpEntries[Entry].cb,
									IN		(LPENTRYID) lpEntries[Entry].lpb,
									IN		&IID_IMailUser,
									IN		MAPI_BEST_ACCESS,
									OUT	&ulObjType,
									OUT	(LPUNKNOWN*) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"OpenEntry failed for DistList");
				retval=FALSE;			
				goto out;
			}
		
			lpMailUser->Release();
			lpMailUser = NULL;

			// Build the restriction structure to pass to lpTable->Restrict
		
			//** For testing the fail case only, stub out for real testing
			// lstrcpy(lpszDisplayNames[Counter2], "This should not match");
			//**
			Restriction.rt = RES_PROPERTY;					//Property restriction
			Restriction.res.resProperty.relop = RELOP_EQ;	//Equals
			Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->Value.LPSZ = lpEntries[Entry].lpDisplayName;

			hr = lpTable->Restrict(&Restriction, ULONG(0));
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->Restrict call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}

			hr = lpTable->QueryRows(LONG(1),
									ULONG(0),
									&lpRows);
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
				retval=FALSE;
				goto out;
			}

			if (!lpRows->cRows) {
				LUIOut(L2, "QueryRows did not find entry #%i. Test FAILED", Entry);
				retval=FALSE;
				goto out;
			}

			//** For testing purposes only, stub out for real testing
			//InitializeCriticalSection(&CriticalSection);
			//EnterCriticalSection(&CriticalSection);
			//DisplayRows(lpRows);
			//LeaveCriticalSection(&CriticalSection);
			//**

			// Does the user want us to cleanup after ourself?
			Cleanup = GetPrivateProfileInt("DLTestSuite","Cleanup",1,INIFILENAME);
		
			if (Cleanup) {
				// Change the EntryID to a LPENTRYLIST
				FindPropinRow(&lpRows->aRow[0],
							 PR_ENTRYID,
							 &PropIndex);
				hr = HrCreateEntryListFromID(lpWABObject,
						IN  lpRows->aRow[0].lpProps[PropIndex].Value.bin.cb,
						IN  (ENTRYID*)lpRows->aRow[0].lpProps[PropIndex].Value.bin.lpb,
						OUT &lpEntryList);
				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Create Entry List");
						retval=FALSE;
						goto out;
				}

				// Then pass the lpEntryList to DeleteEntries to delete ...
				hr = lpDL->DeleteEntries(IN  lpEntryList,IN  0);

				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Delete Entry %i. DeleteEntry returned 0x%x", Entry, hr);
						FreeEntryList(lpWABObject, &lpEntryList);
						retval=FALSE;
						goto out;
				}


				FreeRows(lpWABObject, &lpRows);	// Cleanup from first call to queryrows

				// Verify the entry was deleted by calling QueryRows again
				hr = lpTable->QueryRows(LONG(1),
										ULONG(0),
										&lpRows);
				if (HR_FAILED(hr)) {
					LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
					retval=FALSE;
					goto out;
				}

				if (lpRows->cRows) {	// Should be 0 if deleted
					LUIOut(L2, "QueryRows found entry #%i even tho it was deleted. Test FAILED", Entry);
					retval=FALSE;
					goto out;
				}
			}
			//Cleanup
			FreeRows(lpWABObject, &lpRows);	// Cleanup from second call to queryrows
			if (lpEntryList) {
				FreeEntryList(lpWABObject, &lpEntryList);
				lpEntryList = NULL;
			}
		}
		LUIOut(L3, "All members verified for Distribution List #%i", DL);

		//Free up memory
		lpWABObject->FreeBuffer(Restriction.res.resProperty.lpProp);
		if (lpTable) {
			lpTable->Release();
			lpTable = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
	}
	//
	// Cleanup the WAB
	//
	if (Cleanup) {

		LUIOut(L2, "Cleanup: Removing MailUsers");
		// First, delete the MailUser entries from the wab
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpEntries[Entry].cb,
				IN  (ENTRYID*)lpEntries[Entry].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}

		LocalFree((HLOCAL)lpEntries);
	
		LUIOut(L2, "Cleanup: Removing Distribution Lists");
		// Now, delete the Distribution Lists from the wab
		for (DL = 0; DL < NumDLs; DL++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpDLs[DL].cb,
				IN  (ENTRYID*)lpDLs[DL].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	else {
		LUIOut(L2, "Cleanup: User has requested that the MailUser entries and DistLists not be removed");
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
		}
		LocalFree((HLOCAL)lpEntries);
	
		for (DL = 0; DL < NumDLs; DL++)	{
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	

out:
#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		//if (lpszDisplayName) LocalFree(lpszDisplayName);
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDL)
			lpDL->Release();

		if (lpDL2)
			lpDL2->Release();

		if (lpTable)
			lpTable->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL NamedPropsSuite()
{
	BOOL	Cleanup;
    HRESULT hr      = hrSuccess;
	int		retval=TRUE;
	ULONG	cbEidPAB = 0;
	ULONG   cbEid=0;  // entry id of the entry being added
	ULONG   cValues = 0, ulObjType=NULL, cValues2;	
    ULONG   cRows           = 0;
	UINT	Entry, DL, NumEntries, NumDLs, PropIndex;
	char	szDLTag[SML_BUF], *lpszDisplayName = NULL, *lpszReturnName = NULL;
	EntryID	*lpEntries, *lpDLs;
	char	EntryBuf[MAX_BUF];
		
	LPENTRYID		lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST		lpEntryList=NULL; // needed for copy entry to PDL
    LPADRBOOK		lpAdrBook= NULL;
	LPABCONT		lpABCont= NULL;
    LPMAILUSER		lpMailUser=NULL;
	LPDISTLIST		lpDL=NULL,lpDL2=NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	SRestriction	Restriction;
	SPropValue		*lpPropValue = NULL;		//Used to create props for the mailusers
	SPropValue		PropValue[1]= {0};			//
    LPSPropValue	lpSPropValueAddress = NULL; //Used to create default mailuser
    LPSPropValue	lpSPropValueEntryID = NULL; //Used to getprops on entryid of user
	LPSPropValue	lpSPropValueDL = NULL;		//Used to create default DL
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
    MAPINAMEID		mnid[3];
	LPMAPINAMEID	lpmnid = &(mnid[0]);
    LPSPropTagArray lpNamedPropTags = NULL;
    SPropValue		spv[3];

	
/*	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IDLSuite");
	LUIOut(L2,"-> Tests Distribution List functionality by performing the following:");
	LUIOut(L2, "   Attempts to CreateEntry with the DistList template and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
	LUIOut(L2, "   Calls CreateEntry on the DistList object to add MailUser and DL members and checks...");
	LUIOut(L2, "   # The return code from CreateEntry");
	LUIOut(L2, "   # QueryInterface is called on the returned object and checked for success");
	LUIOut(L2, "   # Release is called on the interface ptr returned from QI and the reference");
	LUIOut(L2, "     count is tested for <= 0 (pass)");
*/	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Create MailUsers in the container
	//

	LUIOut(L2, "Creating MailUsers");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	// Retrieve user info from ini file
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("NamedPropsTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	//_itoa(0,(char*)lpszDisplayName[strlen(lpszDisplayName)],10);

	NumEntries = GetPrivateProfileInt("NamedPropsTestSuite","NumCopies",0,INIFILENAME);

	//Allocate an array of String pointers to hold the EntryIDs
	lpEntries = (EntryID*)LocalAlloc(LMEM_FIXED, NumEntries * sizeof(EntryID));
	lpszDisplayName = (char*)LocalAlloc(LMEM_FIXED, MAX_BUF);
	ParseIniBuffer(IN EntryBuf, IN 1, OUT lpszDisplayName);

	for (Entry = 0; Entry < NumEntries; Entry++)	{
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//
		CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues2, IN Entry, IN &lpszDisplayName, OUT &lpszReturnName);
	

		LUIOut(L3,"MailUser Entry to Add: %s",lpszReturnName);
			
		hr = lpMailUser->SetProps(IN  cValues2,
								 IN  lpPropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED with 0x%x",hr);
	 		retval=FALSE;			
			goto out;
		}

		//
		// Create and save 3 Named Properties
		//

	    mnid[0].lpguid = &WabTestGUID;
	    mnid[0].ulKind = MNID_STRING;    //  This means union will contain a UNICODE string...
		mnid[0].Kind.lpwstrName = L"A long test string of little meaning or relevance entered here ~!@#$%^&*{}[]()";

	    mnid[1].lpguid = &WabTestGUID;
		mnid[1].ulKind = MNID_ID;        //  This means union will contain a long...
		mnid[1].Kind.lID = 0x00000000;   // numeric property 1

	    mnid[2].lpguid = &WabTestGUID;
		mnid[2].ulKind = MNID_ID;        //  This means union will contain a long...
		mnid[2].Kind.lID = 0xFFFFFFFF;   // numeric property 1
		
		hr = lpMailUser->GetIDsFromNames(3, // named props in the array
		  &lpmnid, // &-of because this is an array
		  MAPI_CREATE,
		  &lpNamedPropTags);
		if (hr) {
			//
			//  I'd really be suprised if I got S_OK for this...
			//
			if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) {
				//  Real error here
				retval = FALSE;
				goto out;
			}

			//  Basically, this means you don't have anything by this name and you
			//  didn't ask the object to create it.

			//$ no biggie
		}

		LUIOut(L4, "GetIDsFromNames returned %i tags.", lpNamedPropTags->cValues);
		//
		//  Ok, so what can I do with this ptaga?  Well, we can set a value for it by doing:
		//
		spv[0].ulPropTag = CHANGE_PROP_TYPE(lpNamedPropTags->aulPropTag[0],PT_STRING8);
		spv[0].Value.lpszA = "More meaningless testing text of no consequence !@#$%&*()_+[]{}";
		spv[1].ulPropTag = CHANGE_PROP_TYPE(lpNamedPropTags->aulPropTag[1],PT_LONG);
		spv[1].Value.l = 0x5A5A5A5A;
		spv[2].ulPropTag = CHANGE_PROP_TYPE(lpNamedPropTags->aulPropTag[2],PT_BINARY);
		GenerateRandomBinary(&(spv[2].Value.bin),256); // stick 256 bytes of random data in there

		hr = lpMailUser->SetProps(
		  3,
		  &spv[0],
		  NULL);
		if (HR_FAILED(hr)) {
			goto out;
		}
		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}


		// Store the EID for deleting this entry later
		hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}
		//Allocate space for the display name
		lpEntries[Entry].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(lpszReturnName)+1));
		//Copy the DisplayName for use later
		strcpy(lpEntries[Entry].lpDisplayName, lpszReturnName);
		//Allocate space for the EID (lpb)
		lpEntries[Entry].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpEntries[Entry].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpEntries[Entry].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpEntries[Entry].cb);

		
		//Free the SPropValue for use in the next loop
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}

		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		lpMailUser->Release();
		lpMailUser = NULL;
	}
	
	
	//
	// Create the Distribution Lists in the container
	//
	NumDLs = GetPrivateProfileInt("NamedPropsTestSuite","NumDLs",0,INIFILENAME);
	lpDLs = (EntryID*)LocalAlloc(LMEM_FIXED, NumDLs * sizeof(EntryID));
	LUIOut(L2, "Creating Distribution Lists");
	for (DL = 0; DL < NumDLs; DL++) {

		hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueDL);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 			retval=FALSE;			
				goto out;
		}

		// The returned value of PR_DEF_CREATE_DL is an
		// EntryID which can be passed to CreateEntry
		//
		//LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
									 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
			retval=FALSE;			
			goto out;
		}


		// Call QueryInterface on the object
		
		hr = (lpDL->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpDL2));
		if (HR_FAILED(hr))	{
			LUIOut(L4, "QueryInterface on IID_IDistList FAILED. hr = 0x%x", hr);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L4, "QueryInterface on IID_IDistList PASSED");

		lstrcpy(szDLTag,"DistList1");
		GetPrivateProfileString("NamedPropsTestSuite",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

		//StrLen2 = (StrLen1 + sprintf((char*)&EntProp[0][StrLen1], " [Thread #%i] - ", *(int *)lpThreadNum));	
		_itoa(DL,(char*)&EntryBuf[strlen(EntryBuf)],10);

		LUIOut(L3,"DistList Entry to Add: %s",EntryBuf);
		cValues = 1;		
		PropValue[0].Value.LPSZ = (LPTSTR)EntryBuf;
		hr = lpDL->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpDL->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"DL->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}

		// Want a container interface to the DL, and since QueryInterface on a DL
		// is currently broken (returns a MailUser interface when called with IID_IDistList)
		// we do it the hard way. Call GetProps to get the EID for the new DL, and then
		// call OpenEntry from the container or AB interfaces to open a DL interface
		hr = lpDL->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
								   IN  0,      //Flags
								   OUT &cValues,
								   OUT &lpSPropValueEntryID);

		if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}

		lpDL2->Release();	//Free up this pointer so we can recycle it
		hr = lpABCont->OpenEntry(IN		lpSPropValueEntryID->Value.bin.cb,
								 IN		(LPENTRYID) lpSPropValueEntryID->Value.bin.lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL2);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		LUIOut(L3, "Adding MailUser Members to the Distribution List");
		
		//
		// Now add mailuser entries to the DL
		//
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = lpDL2->CreateEntry(  IN  lpEntries[Entry].cb,
									 IN  (LPENTRYID) lpEntries[Entry].lpb,
									 IN  0,
									 OUT (LPMAPIPROP *) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
				retval=FALSE;			
				goto out;
			}

			hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

			if (HR_FAILED(hr)) {
				LUIOut(L3,"MailUser->SaveChanges FAILED");
				retval=FALSE;
				goto out;
			}
			lpMailUser->Release();
			lpMailUser = NULL;
		}

		//Allocate space for the display name
		lpDLs[DL].lpDisplayName = (char*)LocalAlloc(LMEM_FIXED, (strlen(EntryBuf)+1));
		//Copy the DisplayName for use later
		strcpy(lpDLs[DL].lpDisplayName, EntryBuf);
		//Allocate space for the EID (lpb)
		lpDLs[DL].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED, lpSPropValueEntryID->Value.bin.cb);
		//Copy the EID for use later
		lpDLs[DL].cb = lpSPropValueEntryID->Value.bin.cb;
		memcpy(lpDLs[DL].lpb,lpSPropValueEntryID->Value.bin.lpb,
				lpDLs[DL].cb);
		
		if (lpSPropValueEntryID) {
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
			lpSPropValueEntryID = NULL;
		}
		if (lpSPropValueDL) {
			lpWABObject->FreeBuffer(lpSPropValueDL);
			lpSPropValueDL = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
		lpDL2->Release();
		lpDL2 = NULL;
	}

	//
	// Verify all entries are in the DL
	//
	LUIOut(L2, "Verifying MailUser Members are in the Distribution List");

	for (DL = 0; DL < NumDLs; DL++) {
		// Need to get an interface to the DL
		hr = lpABCont->OpenEntry(IN		lpDLs[DL].cb,
								 IN		(LPENTRYID) lpDLs[DL].lpb,
								 IN		&IID_IDistList,
								 IN		MAPI_BEST_ACCESS,
								 OUT	&ulObjType,
								 OUT	(LPUNKNOWN*) &lpDL);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"OpenEntry failed for DistList");
			retval=FALSE;			
			goto out;
		}

		// Create a contents table to verify each added entry exists in the DL
		hr = lpDL->GetContentsTable(ULONG(0), &lpTable);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"DistList->GetContentsTable call FAILED, returned 0x%x", hr);
			retval=FALSE;
			goto out;
		}

		// Allocate the SpropValue ptr in the restriction structure
		lpWABObject->AllocateBuffer(sizeof(SPropValue), (void**)&(Restriction.res.resProperty.lpProp));
		Restriction.res.resProperty.lpProp = (SPropValue*)Restriction.res.resProperty.lpProp;
		for (Entry = 0; Entry < NumEntries; Entry++) {
			hr = lpDL->OpenEntry(	IN		lpEntries[Entry].cb,
									IN		(LPENTRYID) lpEntries[Entry].lpb,
									IN		&IID_IMailUser,
									IN		MAPI_BEST_ACCESS,
									OUT	&ulObjType,
									OUT	(LPUNKNOWN*) &lpMailUser);

			if (HR_FAILED(hr)) {
				LUIOut(L3,"OpenEntry failed for DistList");
				retval=FALSE;			
				goto out;
			}
		
			lpMailUser->Release();
			lpMailUser = NULL;

			// Build the restriction structure to pass to lpTable->Restrict
		
			//** For testing the fail case only, stub out for real testing
			// lstrcpy(lpszDisplayNames[Counter2], "This should not match");
			//**
			Restriction.rt = RES_PROPERTY;					//Property restriction
			Restriction.res.resProperty.relop = RELOP_EQ;	//Equals
			Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->ulPropTag = PR_DISPLAY_NAME;
			Restriction.res.resProperty.lpProp->Value.LPSZ = lpEntries[Entry].lpDisplayName;

			hr = lpTable->Restrict(&Restriction, ULONG(0));
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->Restrict call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}

			hr = lpTable->QueryRows(LONG(1),
									ULONG(0),
									&lpRows);
			if (HR_FAILED(hr)) {
				LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
				retval=FALSE;
				goto out;
			}

			if (!lpRows->cRows) {
				LUIOut(L2, "QueryRows did not find entry #%i. Test FAILED", Entry);
				retval=FALSE;
				goto out;
			}

			//** For testing purposes only, stub out for real testing
			//InitializeCriticalSection(&CriticalSection);
			//EnterCriticalSection(&CriticalSection);
			//DisplayRows(lpRows);
			//LeaveCriticalSection(&CriticalSection);
			//**

			// Does the user want us to cleanup after ourself?
			Cleanup = GetPrivateProfileInt("NamedPropsTestSuite","Cleanup",1,INIFILENAME);
		
			if (Cleanup) {
				// Change the EntryID to a LPENTRYLIST
				FindPropinRow(&lpRows->aRow[0],
							 PR_ENTRYID,
							 &PropIndex);
				hr = HrCreateEntryListFromID(lpWABObject,
						IN  lpRows->aRow[0].lpProps[PropIndex].Value.bin.cb,
						IN  (ENTRYID*)lpRows->aRow[0].lpProps[PropIndex].Value.bin.lpb,
						OUT &lpEntryList);
				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Create Entry List");
						retval=FALSE;
						goto out;
				}

				// Then pass the lpEntryList to DeleteEntries to delete ...
				hr = lpDL->DeleteEntries(IN  lpEntryList,IN  0);

				if (HR_FAILED(hr)) {
						LUIOut(L3,"Could not Delete Entry %i. DeleteEntry returned 0x%x", Entry, hr);
						FreeEntryList(lpWABObject, &lpEntryList);
						retval=FALSE;
						goto out;
				}


				FreeRows(lpWABObject, &lpRows);	// Cleanup from first call to queryrows

				// Verify the entry was deleted by calling QueryRows again
				hr = lpTable->QueryRows(LONG(1),
										ULONG(0),
										&lpRows);
				if (HR_FAILED(hr)) {
					LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Entry, hr);
					retval=FALSE;
					goto out;
				}

				if (lpRows->cRows) {	// Should be 0 if deleted
					LUIOut(L2, "QueryRows found entry #%i even tho it was deleted. Test FAILED", Entry);
					retval=FALSE;
					goto out;
				}
			}
			//Cleanup
			FreeRows(lpWABObject, &lpRows);	// Cleanup from second call to queryrows
			if (lpEntryList) {
				FreeEntryList(lpWABObject, &lpEntryList);
				lpEntryList = NULL;
			}
		}
		LUIOut(L3, "All members verified for Distribution List #%i", DL);

		//Free up memory
		lpWABObject->FreeBuffer(Restriction.res.resProperty.lpProp);
		if (lpTable) {
			lpTable->Release();
			lpTable = NULL;
		}
		lpDL->Release();
		lpDL = NULL;
	}
	//
	// Cleanup the WAB
	//
	if (Cleanup) {

		LUIOut(L2, "Cleanup: Removing MailUsers");
		// First, delete the MailUser entries from the wab
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpEntries[Entry].cb,
				IN  (ENTRYID*)lpEntries[Entry].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}

		LocalFree((HLOCAL)lpEntries);
	
		LUIOut(L2, "Cleanup: Removing Distribution Lists");
		// Now, delete the Distribution Lists from the wab
		for (DL = 0; DL < NumDLs; DL++)	{
			hr = HrCreateEntryListFromID(lpWABObject,
				IN  lpDLs[DL].cb,
				IN  (ENTRYID*)lpDLs[DL].lpb,
				OUT &lpEntryList);
			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Create Entry List");
					retval=FALSE;
					goto out;
			}

			// Then pass the lpEntryList to DeleteEntries to delete ...
			hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

			if (HR_FAILED(hr)) {
					LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
					FreeEntryList(lpWABObject, &lpEntryList);
					retval=FALSE;
					goto out;
			}
			
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
			FreeEntryList(lpWABObject, &lpEntryList);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	else {
		LUIOut(L2, "Cleanup: User has requested that the MailUser entries and DistLists not be removed");
		for (Entry = 0; Entry < NumEntries; Entry++)	{
			LocalFree((HLOCAL)lpEntries[Entry].lpDisplayName);
			LocalFree((HLOCAL)lpEntries[Entry].lpb);
		}
		LocalFree((HLOCAL)lpEntries);
	
		for (DL = 0; DL < NumDLs; DL++)	{
			LocalFree((HLOCAL)lpDLs[DL].lpDisplayName);
			LocalFree((HLOCAL)lpDLs[DL].lpb);
		}
		LocalFree((HLOCAL)lpDLs);
	}
	

out:
#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		//if (lpszDisplayName) LocalFree(lpszDisplayName);
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDL)
			lpDL->Release();

		if (lpDL2)
			lpDL2->Release();

		if (lpTable)
			lpTable->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IMailUserSetGetProps()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	lpAdrBook       = NULL;
	LPABCONT	lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	lpDLCont= NULL;
	ULONG		cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG		cbEid=0;  // entry id of the entry being added
	LPENTRYID	lpEid=NULL;

    char		EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
	int i=0,k=0;
	char EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IMailUserSetGetProps");
	LUIOut(L2,"-> Verifies IMailUser->SetProps and GetProps are functional by performing the following:");
	LUIOut(L2, "   Attempts to Set/GetProps on a MailUser PR_DISPLAY_NAME using address1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from both SetProps and GetProps");
	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Attempts to Set/GetProps on a DistList PR_DISPLAY_NAME using Name1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from both SetProps and GetProps");
	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //


	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntries",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

	LUIOut(L2, "Calling MailUser->GetProps to verify the properties are what we expect");
	hr = lpMailUser->GetProps(	IN (LPSPropTagArray) &SPTArrayDisplayName,
								IN 0,
								OUT &cValues2,
								OUT (LPSPropValue FAR *)&lpSPropValueMailUser);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueMailUser->ulPropTag, cValues2))) {
		LUIOut(L3,"MailUser->GetProps call FAILED");
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->GetProps call PASSED. Now verifying property array...");
	
	for (i=0; i<(int)cValues;i++)	{
		if (lstrcmp(PropValue[i].Value.LPSZ, lpSPropValueMailUser->Value.LPSZ))	{	//FAILED
			LUIOut(L3, "Display names are not egual. [%s != %s]",
				PropValue[i].Value.LPSZ, lpSPropValueMailUser->Value.LPSZ);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L3, "Display names are equal. [%s = %s]",
			PropValue[i].Value.LPSZ, lpSPropValueMailUser->Value.LPSZ);
	}
	LUIOut(L2, "MailUserSet/GetProps PASSED");

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

	LUIOut(L2, "Calling DistList->GetProps to verify the properties are what we expect");
	hr = lpDistList->GetProps(	IN (LPSPropTagArray) &SPTArrayDisplayName,
								IN 0,
								OUT &cValues2,
								OUT (LPSPropValue FAR *)&lpSPropValueDistList);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDistList->ulPropTag))) {
		LUIOut(L3,"DistList->GetProps call FAILED");
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->GetProps call PASSED. Now verifying property array...");
	
	for (i=0; i<(int)cValues;i++)	{
		if (lstrcmp(PropValue[i].Value.LPSZ, lpSPropValueDistList->Value.LPSZ))	{	//FAILED
			LUIOut(L3, "Display names are not egual. [%s != %s]",
				PropValue[i].Value.LPSZ, lpSPropValueDistList->Value.LPSZ);
			retval = FALSE;
			goto out;
		}
		else LUIOut(L3, "Display names are equal. [%s = %s]",
			PropValue[i].Value.LPSZ, lpSPropValueDistList->Value.LPSZ);
	}
	LUIOut(L2, "DistList Set/GetProps PASSED");
#endif DISTLIST


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueMailUser)
			MAPIFreeBuffer(lpSPropValueMailUser);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueMailUser)
			lpWABObject->FreeBuffer(lpSPropValueMailUser);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PAB_IMailUserSaveChanges()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	SPropValue*	lpPropValue = NULL;
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IMailUserSaveChanges");
	LUIOut(L2,"-> Verifies IMailUser->SaveChanges is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using address1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from SaveChanges");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using address1 from the");
	LUIOut(L2, "   ini file and checks...");
	LUIOut(L2, "   # The return code from SaveChanges");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

#ifdef TESTPASS
	while (1) {
#endif
	
	CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues2, IN AUTONUM_OFF, IN NULL, OUT NULL);

	LUIOut(L4, "Creating a MailUser with %i properties.", cValues2);
	hr = lpMailUser->SetProps(IN  cValues2,
                             IN  lpPropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED");
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED");

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	// Now retrieve all the props and compare to what we expect
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) NULL,	//Want all props
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	
	DisplayProp(lpSPropValueEntryID, PR_GIVEN_NAME, cValues);
	DisplayProp(lpSPropValueEntryID, PR_SURNAME, cValues);

	if (!CompareProps(lpPropValue, cValues2, lpSPropValueEntryID, cValues)) {
		retval=FALSE;
		goto out;
	}
	else LUIOut(L4, "Compared expected and found props. No differences detected.");

	// Free the memory associated with this ptr so the ptr can be reused below
	if (lpSPropValueEntryID)
		lpWABObject->FreeBuffer(lpSPropValueEntryID);

	
	if (lpPropValue) {
		for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
				if (lpPropValue[Prop].Value.LPSZ) {
					LocalFree(lpPropValue[Prop].Value.LPSZ);
					lpPropValue[Prop].Value.LPSZ = NULL;
				}
			}
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
				if (lpPropValue[Prop].Value.bin.lpb) {
					LocalFree(lpPropValue[Prop].Value.bin.lpb);
					lpPropValue[Prop].Value.bin.lpb = NULL;
				}
			}
		}
		LocalFree(lpPropValue);
		lpPropValue=NULL;
	}
		
#ifdef TESTPASS
	}
#endif
	// Now delete the entry from the wab
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	

	hr = HrCreateEntryListFromID(lpWABObject,
		IN  lpSPropValueEntryID->Value.bin.cb,
		IN  (ENTRYID*)lpSPropValueEntryID->Value.bin.lpb,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues2; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}
		
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PAB_IABContainerResolveNames()
{
	//DWORD	nCells, counter;
	
	BOOL	Found = FALSE;
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	int NumEntries, NumProps;

	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0;

    char lpszInput[] = "Resolve THIS buddy!01234567891123456789212345678931234567894123456789512345678961234567897123456789812345678991234567890123456789112345678921234567893123456789412345678951234567896123456789712345678981234567899123456789012345678911234567892123456789312345678941234567895123456789612345678971234567898123456789", lpszInput2[] = "Resolve THIS DL buddy!";
    LPADRLIST lpAdrList = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;


    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int k=0;
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, SPTArrayCols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABContainerResolveNames");
	LUIOut(L2,"-> Verifies IABContainer->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntries",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
*/
	lstrcpy((LPTSTR)EntProp[0], lpszInput);		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	NumEntries = 1, NumProps = 1;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

	lpFlagList->cFlags = 1;
	lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

	hr = lpABCont->ResolveNames(
		(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
		0,               // ulFlags
		lpAdrList,
		lpFlagList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

	VerifyResolvedAdrList(lpAdrList, lpszInput);
		// Now delete the entry from the wab
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	
	
	hr = HrCreateEntryListFromID(lpWABObject,
		IN  lpSPropValueEntryID->Value.bin.cb,
		IN  (ENTRYID*)lpSPropValueEntryID->Value.bin.lpb,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);

	FreeAdrList(lpWABObject, &lpAdrList);	// Free lpAdrList and properties

	

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
*/	
	lstrcpy((LPTSTR)EntProp[0], lpszInput2);		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
	
	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	// use WAB Allocators here
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //WAB
		lpAdrList->cEntries = 1;
        lpAdrList->aEntries[0].ulReserved1 = 0;
        lpAdrList->aEntries[0].cValues = 1;

#ifdef PAB
        if (! (sc = MAPIAllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB
#ifdef WAB
        if (! (sc = lpWABObject->AllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB

			lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput2;
			
			lpFlagList->cFlags = 1;
            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

            hr = lpABCont->ResolveNames(
				(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
                0,               // ulFlags
                lpAdrList,
                lpFlagList);
		    if (HR_FAILED(hr)) {
				LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}
			else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

			Found = FALSE;
			// Search through returned AdrList for our entry
			for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
				cMaxProps = (int)lpAdrList->aEntries[i].cValues;
				//Check to see if Display Name exists
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps) {
						LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
						retval = FALSE;
					}
				}
				LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
				if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput2))	{
					LUIOut(L3, "Found the entry we just added");
					Found = TRUE;
				}
				//Check to see if EntryID exists
				LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps)	{
						LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
						retval =  FALSE;
					}
				}
				if (!Found) LUIOut(L3, "Did not find the entry. Test FAILED");
				if (idx < cMaxProps) LUIOut(L3, "EntryID found");
				if (!(retval && Found)) retval = FALSE;
				else	{
					// Store EID for call to OpenEntry
				}
			}
		}			

#ifdef PAB
        MAPIFreeBuffer(lpAdrList);
#endif //PAB
#ifdef WAB
        lpWABObject->FreeBuffer(lpAdrList);
#endif //WAB
	}
#endif //DISTLIST


out:
	// Free lpAdrList and properties
FreeAdrList(lpWABObject, &lpAdrList);
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}

BOOL PAB_IABContainerOpenEntry()
{
	//DWORD	nCells, counter;
	
	BOOL	Found = FALSE;
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE, NumEntries, NumProps;
	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0, PropIndex;

    char lpszInput[] = "Resolve THIS buddy!", lpszInput2[] = "Resolve THIS DL buddy!";
    LPADRLIST lpAdrList = NULL;
    FlagList rgFlagList;
    LPFlagList lpFlagList = (LPFlagList)&rgFlagList;


    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	ULONG	cbLookupEID;
	LPENTRYID	lpLookupEID;
	int k=0;
	
    LPMAILUSER  lpMailUser=NULL,lpMailUser2=NULL,lpDistList=NULL,lpDistList2=NULL;
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, SPTArrayCols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABContainerOpenEntry");
	LUIOut(L2,"-> Verifies IABContainer->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}


	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntries",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
*/
	lstrcpy((LPTSTR)&(EntProp[0]), lpszInput);		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	NumEntries = 1, NumProps = 1;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

	lpFlagList->cFlags = 1;
	lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

	hr = lpABCont->ResolveNames(
		(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
		0,               // ulFlags
		lpAdrList,
		lpFlagList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

	switch((ULONG)*lpFlagList->ulFlag) {
	case MAPI_AMBIGUOUS:	{
			LUIOut(L4, "ResolveNames returned the MAPI_AMBIGUOUS flag. Test FAILED");
			retval = FALSE;
			break;
	}
	case MAPI_RESOLVED:	{
			LUIOut(L4, "ResolveNames returned the MAPI_RESOLVED flag. Test PASSED");
			break;
	}
	case MAPI_UNRESOLVED:	{
			LUIOut(L4, "ResolveNames returned the MAPI_UNRESOLVED flag. Test FAILED");
			retval = FALSE;
			break;
	}
	default:	{
		LUIOut(L4, "Undefined flag value [%i] returned. Test FAILED", (ULONG)lpFlagList->ulFlag);
		retval = FALSE;
	}
	}

	// Search through returned AdrList for our entry
	VerifyResolvedAdrList(lpAdrList, lpszInput);

	FindProp(&lpAdrList->aEntries[0],
			 PR_ENTRYID,
			 &PropIndex);

	lpLookupEID = (ENTRYID*)lpAdrList->aEntries[0].rgPropVals[PropIndex].Value.bin.lpb;
	cbLookupEID = lpAdrList->aEntries[0].rgPropVals[PropIndex].Value.bin.cb;

    hr = lpABCont->OpenEntry(	IN  cbLookupEID,
								IN  lpLookupEID,
								IN  0,					// Interface
								IN	MAPI_BEST_ACCESS,	// Flags
								OUT	&ulObjType,
								OUT (LPUNKNOWN *) &lpMailUser2
								);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"OpenEntry FAILED");
		retval=FALSE;			
		goto dl;
	}
		// Check to make sure the object type is what we expect

	LUIOut(L3, "Checking to make sure the returned object type is correct");
	if (ulObjType != MAPI_MAILUSER) {
		LUIOut(L2, "Object type is not MAPI_MAILUSER");
		retval = FALSE;
		goto out;
	}
	LUIOut(L3, "Object type is MAPI_MAILUSER");
	
	// Call QueryInterface on the object
	LUIOut(L3, "Calling QueryInterface on the returned object");	
	hr = (lpMailUser2->QueryInterface((REFIID)(IID_IMailUser), (VOID **) &lpABCont2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IMailUser FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "QueryInterface on IID_IMailUser PASSED");

	LUIOut(L3, "Trying to release the object QI returned");
	if(lpABCont2)	{
		if ((LPUNKNOWN)(lpABCont2)->Release() <= 0)
			LUIOut(L3, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpABCont2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

	//
	// Delete the test entry we created in the wab
	//

	hr = HrCreateEntryListFromID(lpWABObject,
		IN  cbLookupEID,
		IN  lpLookupEID,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);
	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);
	
dl:
#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
/*	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
*/	
	lstrcpy((LPTSTR)EntProp[0], lpszInput2);		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
	
	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	// use WAB Allocators here
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //WAB
		lpAdrList->cEntries = 1;
        lpAdrList->aEntries[0].ulReserved1 = 0;
        lpAdrList->aEntries[0].cValues = 1;

#ifdef PAB
        if (! (sc = MAPIAllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB
#ifdef WAB
        if (! (sc = lpWABObject->AllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB

			lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput2;
			
			lpFlagList->cFlags = 1;
            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

            hr = lpABCont->ResolveNames(
				(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
                0,               // ulFlags
                lpAdrList,
                lpFlagList);
		    if (HR_FAILED(hr)) {
				LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}
			else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

			Found = FALSE;
			// Search through returned AdrList for our entry
			for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
				cMaxProps = (int)lpAdrList->aEntries[i].cValues;
				//Check to see if Display Name exists
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps) {
						LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
						retval = FALSE;
					}
				}
				LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
				if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput2))	{
					LUIOut(L3, "Found the entry we just added");
					Found = TRUE;
				}
				//Check to see if EntryID exists
				LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps)	{
						LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
						retval =  FALSE;
					}
				}
				if (!Found) LUIOut(L3, "Did not find the entry. Test FAILED");
				if (idx < cMaxProps) LUIOut(L3, "EntryID found");
				if (!(retval && Found)) retval = FALSE;
				else	{
					// Store EID for call to OpenEntry
					lpLookupEID = (ENTRYID*)lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.lpb;
					cbLookupEID = lpAdrList->aEntries[i].rgPropVals[idx].Value.bin.cb;
				}
			}
		}			

    hr = lpABCont->OpenEntry(	IN  cbLookupEID,
								IN  lpLookupEID,
								IN  0,					// Interface
								IN	MAPI_BEST_ACCESS,	// Flags
								OUT	&ulObjType,
								OUT (LPUNKNOWN *) &lpDistList2
								);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"OpenEntry FAILED");
		retval=FALSE;
		//goto out;
	}
		// Check to make sure the object type is what we expect

	LUIOut(L3, "Checking to make sure the returned object type is correct");
	if (ulObjType != MAPI_DISTLIST) {
		LUIOut(L2, "Object type is not MAPI_DISTLIST");
		retval = FALSE;
		goto out;
	}
	LUIOut(L3, "Object type is MAPI_DISTLIST");
	
	// Call QueryInterface on the object
	LUIOut(L3, "Calling QueryInterface on the returned object");	
	hr = (lpABCont->QueryInterface((REFIID)(IID_IDistList), (VOID **) &lpABCont2));
	if (HR_FAILED(hr))	{
		LUIOut(L2, "QueryInterface on IID_IDistList FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "QueryInterface on IID_IDistList PASSED");

	LUIOut(L3, "Trying to release the object QI returned");
	if(lpABCont2)	{
		if ((LPUNKNOWN)(lpABCont2)->Release() <= 0)
			LUIOut(L3, "QueryInterface returned a valid ptr and released succesfully");
		else	{
			LUIOut(L2, "Release FAILED:returned a > zero ref count");
		}
		lpABCont2 = NULL;

	}
	else {
		LUIOut(L2, "QueryInterface did not return a valid ptr");
		retval = FALSE;
		goto out;
	}

#ifdef PAB
        MAPIFreeBuffer(lpAdrList);
#endif //PAB
#ifdef WAB
        lpWABObject->FreeBuffer(lpAdrList);
#endif //WAB
	}
#endif //DISTLIST


out:
	// Free lpAdrList and properties
FreeAdrList(lpWABObject, &lpAdrList);
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpMailUser2)
			lpMailUser2->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpDistList2)
			lpDistList2->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IABAddress()
{
	//DWORD	nCells, counter;
	
	HWND		hwnd = glblhwnd;
	ADRPARM		AdrParms;
	LPADRPARM	lpAdrParms = &AdrParms;
    LPADRLIST lpAdrList = NULL;
	char 	lpszCaptionText[64], lpszDestWellsText[64];
	char lpszDisplayName[MAXSTRING], lpszDisplayName2[MAXSTRING], lpszDisplayName3[MAXSTRING];

	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE, NumEntries, NumProps;
	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0;

    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;


    LPADRBOOK	  lpAdrBook       = NULL;
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABAddress");
	LUIOut(L2,"-> Verifies IABContainer->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	
	//
	// MULTISELECT MODE - To well only
	//

	// Fill in the ADRPARM structure
	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 3, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_TO;
			
	strcpy(lpszDisplayName3, "Ren & Stimpy");
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszDisplayName3;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[2].rgPropVals[1].Value.l = MAPI_TO;
			

	LUIOut(L2, "Calling IABAddress with multiselect mode and only the To well");

	MessageBox(NULL, "Calling IAB->Address in multi-select mode with To: well only. You should see 3 entries in the To: well.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - MultiSelect mode");
	strcpy(lpszDestWellsText, "WABTEST - Destination well text");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->lpszDestWellsTitle = lpszDestWellsText;
	lpAdrParms->cDestFields = 1;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the multi-select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	
	//
	// MULTISELECT MODE - To and CC wells only
	//

	// Fill in the ADRPARM structure
	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 3, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
			
	strcpy(lpszDisplayName3, "Ren & Stimpy");
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszDisplayName3;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[2].rgPropVals[1].Value.l = MAPI_BCC;
			
	LUIOut(L2, "Calling IABAddress with multiselect mode and both To and CC wells");

	MessageBox(NULL, "Calling IAB->Address in multi-select mode with both To: and CC: wells. You should see 1 entry in each of the wells.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - MultiSelect mode");
	strcpy(lpszDestWellsText, "WABTEST - Destination well text");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->lpszDestWellsTitle = lpszDestWellsText;
	lpAdrParms->cDestFields = 2;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the multi-select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

	
	//
	// MULTISELECT MODE - To, CC and BCC wells
	//

	// Fill in the ADRPARM structure
	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 3, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
			
	strcpy(lpszDisplayName3, "Ren & Stimpy");
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszDisplayName3;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[2].rgPropVals[1].Value.l = MAPI_BCC;
			
	LUIOut(L2, "Calling IABAddress with multiselect mode and To, CC and BCC wells");

	MessageBox(NULL, "Calling IAB->Address in multi-select mode with To:, CC: and BCC: wells. You should see 1 entry in each well.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - MultiSelect mode");
	strcpy(lpszDestWellsText, "WABTEST - Destination well text");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->lpszDestWellsTitle = lpszDestWellsText;
	lpAdrParms->cDestFields = 3;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the multi-select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

	//
	// BROWSE MODE - Modal
	//

	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 2, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
		
	LUIOut(L2, "Calling IABAddress with browse mode (modal)");
	MessageBox(NULL, "Calling IAB->Address in browse mode with the modal flag set.",
		"WAB Test Harness", MB_OK);

	
	lpAdrParms->ulFlags = (	DIALOG_MODAL );
	strcpy(lpszCaptionText, "WABTEST - Browse mode (modal)");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->cDestFields = 0;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");


	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the modal, browse UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

	//
	// BROWSE MODE - Modeless
	//

	ZeroMemory(lpAdrParms, sizeof(ADRPARM));

	NumEntries = 2, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	strcpy(lpszDisplayName2, "Carl Sagon");
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszDisplayName2;
	lpAdrList->aEntries[1].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[1].rgPropVals[1].Value.l = MAPI_CC;
		
	LUIOut(L2, "Calling IABAddress with browse mode (modeless)");
	MessageBox(NULL, "Calling IAB->Address in browse mode with the SDI (modeless) flag set.",
		"WAB Test Harness", MB_OK);

	
	lpAdrParms->ulFlags = (	DIALOG_SDI );
	strcpy(lpszCaptionText, "WABTEST - Browse mode (modeless)");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->cDestFields = 0;

	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");

	//Reset the hwnd as the modeless call returns the hwnd of the modeless dialog
	hwnd = glblhwnd;

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the modeless, browse UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}


	//
	// SINGLESELECT MODE
	//
	
	NumEntries = 1, NumProps = 2;
	AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList);

	strcpy(lpszDisplayName, "Abraham Lincoln");
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszDisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[1].Value.l = MAPI_TO;

	LUIOut(L2, "Calling IABAddress with single select mode");
	MessageBox(NULL, "Calling IAB->Address in single select mode.",
		"WAB Test Harness", MB_OK);

	lpAdrParms->ulFlags = (	DIALOG_MODAL | ADDRESS_ONE );
	strcpy(lpszCaptionText, "WABTEST - SingleSelect mode");
	lpAdrParms->lpszCaption = lpszCaptionText;
	lpAdrParms->cDestFields = 0;
	
	hr = lpAdrBook->Address((ULONG*)&hwnd, lpAdrParms, &lpAdrList);
	if (HR_FAILED(hr))	{
		LUIOut(L2, "IAdrBook->Address call FAILED");
		retval = FALSE;
		goto out;
	}
	else LUIOut(L3, "IAdrBook->Address call PASSED");
	
	if (lpAdrList) DisplayAdrList(lpAdrList, lpAdrList->cEntries);
	else	{
		LUIOut(L3, "IAdrBook->Address returned a NULL lpAdrList. No entries were selected.");
	}
	

	// Free lpAdrList and properties
	FreeAdrList(lpWABObject, &lpAdrList);

	if (MessageBox(NULL, "Did the single select UI display correctly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "Test operator reports the UI did not display correctly. Test FAILED");
		retval = FALSE;
		goto out;
	}

out:
	FreeAdrList(lpWABObject, &lpAdrList);
		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL ThreadStress(LPVOID lpThreadNum) {
	HRESULT			hr;
	LPENTRYLIST		lpEntryList=NULL;
	LPADRBOOK		lpLocalAdrBook;
	LPVOID			Reserved1 = NULL;
	DWORD			Reserved2 = 0;
	LPWABOBJECT		lpLocalWABObject;
	BOOL			retval = TRUE;
    LPSPropValue	lpSPropValueAddress = NULL, lpSCompareProps = NULL;
	ULONG			cValues = 0, cValues2 = 0, cbEidPAB = 0, ulObjType = 0;
	LPENTRYID		lpEidPAB = NULL;
	LPABCONT		lpABCont= NULL;
	char			szDLTag[SML_BUF], *lpszReturnName = NULL, *lpszDisplayName = NULL, **lpszDisplayNames;
	char			EntryBuf[MAX_BUF];
	unsigned int	NumEntries, Counter1, Counter2, StrLen1, PropIndex;
    LPMAILUSER		lpMailUser = NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	SRestriction	Restriction;
	SPropValue*		lpPropValue;
	SizedSPropTagArray(1, SPTArrayCols) = { 1, {PR_ENTRYID} };
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	WAB_PARAM		WP;

	LUIOut(L2, "Thread #%i initializing.", *(int *)lpThreadNum);
	ZeroMemory((void *)&WP, sizeof(WAB_PARAM));
	WP.cbSize=sizeof(WAB_PARAM);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	//lpWABObject = lpLocalWABObject;	//AllocateAdrList expects a global ptr to the WAB obj

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//


	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //

	// Retrieve user info from ini file
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntriesStress",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	NumEntries = GetPrivateProfileInt("CreateEntriesStress","NumCopies",0,INIFILENAME);

	//Allocate an array of String pointers to hold the display names
	lpszDisplayNames = (char**)LocalAlloc(LMEM_FIXED, NumEntries * sizeof(LPSTR));
	lpszDisplayName = (char*)LocalAlloc(LMEM_FIXED, MAX_BUF*sizeof(char));
	ParseIniBuffer(IN EntryBuf, IN 1, OUT lpszDisplayName);
	StrLen1 = strlen(lpszDisplayName);
	sprintf(&(lpszDisplayName[StrLen1]), " [Thread #%i] - ", *(int *)lpThreadNum);	

	LUIOut(L2, "Thread #%i adding %i entries", *(int *)lpThreadNum, NumEntries);

	for (Counter1 = 0; Counter1 < NumEntries; Counter1++)	{
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//


		CreateProps(IN INIFILENAME, IN "Properties", OUT &lpPropValue, OUT &cValues, IN Counter1, IN &lpszDisplayName, OUT &lpszReturnName);
		
		//Allocate space for the display name
		lpszDisplayNames[Counter1] = (char*)LocalAlloc(LMEM_FIXED, (strlen(lpszReturnName)+1)*sizeof(char));
		//Copy the DisplayName for use later
		strcpy(lpszDisplayNames[Counter1], lpszReturnName);
		//LUIOut(L2,"MailUser Entry to Add: %s",lpszDisplayName);
			
		hr = lpMailUser->SetProps(IN  cValues,
								 IN  lpPropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",lpszReturnName);
	 		retval=FALSE;			
			goto out;
		}

		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED with error code 0x%x",hr);
			retval=FALSE;
			goto out;
		}

		// Now retrieve all the props and compare to what we expect
		
		hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) NULL,	//Want all props
								   IN  0,      //Flags
								   OUT &cValues2,
								   OUT &lpSCompareProps);

		if ((HR_FAILED(hr))||(PropError(lpSCompareProps->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps FAILED for MailUser");
	 			retval=FALSE;			
				goto out;
		}
		
		if (!CompareProps(lpPropValue, cValues, lpSCompareProps, cValues2)) {
			retval=FALSE;
			goto out;
		}
		
		//Free the SPropValue for use in the next loop
		if (lpPropValue) {
			for (unsigned int Prop = 0; Prop < cValues; Prop++) {
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
					if (lpPropValue[Prop].Value.LPSZ) {
						LocalFree(lpPropValue[Prop].Value.LPSZ);
						lpPropValue[Prop].Value.LPSZ = NULL;
					}
				}
				if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
					if (lpPropValue[Prop].Value.bin.lpb) {
						LocalFree(lpPropValue[Prop].Value.bin.lpb);
						lpPropValue[Prop].Value.bin.lpb = NULL;
					}
				}
			}
			LocalFree(lpPropValue);
			lpPropValue=NULL;
		}
		


		if (lpSCompareProps) {
			lpLocalWABObject->FreeBuffer(lpSCompareProps);
			lpSCompareProps = NULL;
		}
		lpMailUser->Release();
		lpMailUser = NULL;
	}

	//LUIOut(L2, "Thread #%i added %i entries with %i properties", *(int *)lpThreadNum, NumEntries, cValues);
	if (retval) LUIOut(L2, "Thread #%i compared %i props. No differences found", *(int *)lpThreadNum, cValues);

	
	//
	// Verify each entry we added now exists in the WAB and then delete it
	//

	LUIOut(L2, "Thread #%i verifying and deleting %i entries", *(int *)lpThreadNum, NumEntries);

	// Create a contents table to verify each added entry exists in the store
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	//else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

	// Allocate the SpropValue ptr in the restriction structure
	lpLocalWABObject->AllocateBuffer(sizeof(SPropValue), (void**)&(Restriction.res.resProperty.lpProp));
	Restriction.res.resProperty.lpProp = (SPropValue*)Restriction.res.resProperty.lpProp;

	//Now walk the FlagList and make sure everything resolved, if it did then delete it now
	for (Counter2 = 0; Counter2 < NumEntries; Counter2++)	{
	
	// Build the restriction structure to pass to lpTable->Restrict
	
		//** For testing the fail case only, stub out for real testing
		// lstrcpy(lpszDisplayNames[Counter2], "This should not match");
		//**
		Restriction.rt = RES_PROPERTY;					//Property restriction
		Restriction.res.resProperty.relop = RELOP_EQ;	//Equals
		Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
		Restriction.res.resProperty.lpProp->ulPropTag = PR_DISPLAY_NAME;
		Restriction.res.resProperty.lpProp->Value.LPSZ = lpszDisplayNames[Counter2];

		hr = lpTable->Restrict(&Restriction, ULONG(0));
		if (HR_FAILED(hr)) {
			LUIOut(L3,"Table->Restrict call FAILED, returned 0x%x", hr);
			retval=FALSE;
			goto out;
		}

		hr = lpTable->QueryRows(LONG(1),
								ULONG(0),
								&lpRows);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Counter2, hr);
			retval=FALSE;
			goto out;
		}

		if (!lpRows->cRows) {
			LUIOut(L2, "QueryRows did not find entry #%i. Test FAILED", Counter2);
			retval=FALSE;
			goto out;
		}

		//** For testing purposes only, stub out for real testing
		//EnterCriticalSection(&CriticalSection);
		//DisplayRows(lpRows);
		//LeaveCriticalSection(&CriticalSection);
		//**

	
		// Change the EntryID to a LPENTRYLIST
		FindPropinRow(&lpRows->aRow[0],
					 PR_ENTRYID,
					 &PropIndex);
		hr = HrCreateEntryListFromID(lpLocalWABObject,
				IN  lpRows->aRow[0].lpProps[PropIndex].Value.bin.cb,
				IN  (ENTRYID*)lpRows->aRow[0].lpProps[PropIndex].Value.bin.lpb,
				OUT &lpEntryList);
		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Create Entry List");
				retval=FALSE;
				goto out;
		}

		// Then pass the lpEntryList to DeleteEntries to delete ...
		hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Delete Entry %i. DeleteEntry returned 0x%x", Counter2, hr);
				FreeEntryList(lpLocalWABObject, &lpEntryList);
				retval=FALSE;
				goto out;
		}


		FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows

		// Verify the entry was deleted by calling QueryRows again
		hr = lpTable->QueryRows(LONG(1),
								ULONG(0),
								&lpRows);
		if (HR_FAILED(hr)) {
			LUIOut(L3,"Table->QueryRows call FAILED: Entry #%i, returned 0x%x", Counter2, hr);
			retval=FALSE;
			goto out;
		}

		if (lpRows->cRows) {	// Should be 0 if deleted
			LUIOut(L2, "Thread #%i: QueryRows found entry #%i even tho it was deleted. Test FAILED", *(int *)lpThreadNum, Counter2);
			retval=FALSE;
			goto out;
		}
		
		//Cleanup
		FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from second call to queryrows
		if (lpEntryList) {
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			lpEntryList = NULL;
		}
		LocalFree((HLOCAL)lpszDisplayNames[Counter2]);
		lpszDisplayNames[Counter2] = NULL;
	}



out:
	if (lpszDisplayName) {
		LocalFree(lpszDisplayName);
		lpszDisplayName = NULL;
	}
	if (lpPropValue) {
		for (unsigned int Prop = 0; Prop < cValues; Prop++) {
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_STRING8)	{
				if (lpPropValue[Prop].Value.LPSZ) {
					LocalFree(lpPropValue[Prop].Value.LPSZ);
					lpPropValue[Prop].Value.LPSZ = NULL;
				}
			}
			if (PROP_TYPE(lpPropValue[Prop].ulPropTag) == PT_BINARY) {
				if (lpPropValue[Prop].Value.bin.lpb) {
					LocalFree(lpPropValue[Prop].Value.bin.lpb);
					lpPropValue[Prop].Value.bin.lpb = NULL;
				}
			}
		}
		LocalFree(lpPropValue);
		lpPropValue=NULL;
	}
	
	if (lpEntryList) {
		FreeEntryList(lpLocalWABObject, &lpEntryList);
		lpEntryList = NULL;
	}

	if (Restriction.res.resProperty.lpProp) {
		lpLocalWABObject->FreeBuffer(Restriction.res.resProperty.lpProp);
		Restriction.res.resProperty.lpProp = NULL;
	}

	if (lpszDisplayNames) {
		for (unsigned int FreeCounter = 0; FreeCounter < NumEntries; FreeCounter++) {
			if (lpszDisplayNames[FreeCounter]) LocalFree((HLOCAL)lpszDisplayNames[FreeCounter]);
		}
		LocalFree((HLOCAL)lpszDisplayNames);
	}

	FreeRows(lpLocalWABObject, &lpRows);

#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);
#endif
#ifdef WAB
		if (lpEidPAB)
			lpLocalWABObject->FreeBuffer(lpEidPAB);
		if (lpSCompareProps) {
			lpLocalWABObject->FreeBuffer(lpSCompareProps);
			lpSCompareProps = NULL;
		}
		if (lpSPropValueAddress)
			lpLocalWABObject->FreeBuffer(lpSPropValueAddress);
#endif
		if (lpTable)
			lpTable->Release();
		
		if (lpMailUser)
			lpMailUser->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpLocalAdrBook)
				lpLocalAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpLocalWABObject)
			lpLocalWABObject->Release();
#endif
	return(retval);
}


BOOL ThreadManager()
{
	int		NumReps, NumThreads, Counter1, Counter2, Counter3;
	BOOL	retval = TRUE;
	HANDLE *lpThreads;			//ptr to Array of thread handles
	int	*	lpThreadParams;		//ptr to Array of params passed to threads
	DWORD	ThreadId;			//Don't care about thread IDs so it gets overwritten each time
	DWORD	ThreadRetVal;

	
	// how many reps and threads
	// Retrieve user info from ini file
	InitializeCriticalSection(&CriticalSection);
	NumReps = GetPrivateProfileInt("CreateEntriesStress","NumReps",1,INIFILENAME);
	NumThreads = GetPrivateProfileInt("CreateEntriesStress","NumThreads",3,INIFILENAME);

	LUIOut(L1, "ThreadManager: Preparing to run %i repititions with %i threads each",
			NumReps, NumThreads);

	// allocate lpThreads for NumThreads
	lpThreads = (HANDLE*)LocalAlloc(LMEM_FIXED, NumThreads * sizeof(HANDLE));
	lpThreadParams = (int*)LocalAlloc(LMEM_FIXED, NumThreads * sizeof(int));
	if (lpThreads) {
		for (Counter1 = 0; ((Counter1 < NumReps) || ((NumReps == 0) && (!glblStop))) && retval; Counter1++) {
			for (Counter2 = 0; (Counter2 < NumThreads); Counter2++) {
				lpThreadParams[Counter2] = Counter2;
				lpThreads[Counter2] = CreateThread(
					(LPSECURITY_ATTRIBUTES) NULL,		// pointer to thread security attributes
					(DWORD) 0,							// initial thread stack size, in bytes
					(LPTHREAD_START_ROUTINE) ThreadStress,		// pointer to thread function
					(LPVOID) &(lpThreadParams[Counter2]),		// argument for new thread
					(DWORD) 0,							// creation flags
					(LPDWORD) &ThreadId					// pointer to returned thread identifier
				);
				if (!lpThreads[Counter2]) {
					LUIOut(L1, "<ERROR> ThreadManager: Unable to create one of the helper threads");
					retval = FALSE;
					break;	//We're outta here, just go on to cleanup the threads that launched
				}
			}
			
			//Threads are off and running at this point
			//Wait till they complete, collect retvals and cleanup
			WaitForMultipleObjects(
				(DWORD) (Counter2),					// number of handles in handle array or
													// partial if not all threads made it
				lpThreads,							// address of object-handle array
				TRUE,								// wait flag - TRUE = wait for all threads
				INFINITE						 	// time-out interval in milliseconds
			);
			//Check each thread for errors and then free the handles
			for (Counter3 = 0; Counter3 < Counter2; Counter3++) {
				GetExitCodeThread(
					(HANDLE) lpThreads[Counter3],		// handle to the thread
					(LPDWORD) &ThreadRetVal				// address to receive termination status
				);
				if (!(ThreadRetVal)) retval = FALSE;
				CloseHandle(lpThreads[Counter3]);
			}

		}		
		DeleteCriticalSection(&CriticalSection);
		LocalFree((HLOCAL)lpThreadParams);
		LocalFree((HLOCAL)lpThreads);
	}
	else {
		LUIOut(L1, "<ERROR> ThreadManager: Couldn't allocate the thread handle array.");
		//Tell the app that ThreadManager has finished and pass back the return value in
		//the HIWORD of the wParam - since we know it failed at this point, no need to
		//stuff the HIWORD since it's already zero.
		PostMessage(glblhwnd, WM_COMMAND, (WPARAM)ID_MULTITHREADCOMPLETE, (LPARAM)0);
		return(FALSE);
	}
	
	//Tell the app that ThreadManager has finished and pass back the return value in
	//the HIWORD of the wParam
	PostMessage(glblhwnd, WM_COMMAND,
				(WPARAM)(ID_MULTITHREADCOMPLETE | (retval << 16)), (LPARAM)0);
	return(retval);
}

BOOL PAB_AddMultipleEntries()
{
	//DWORD	nCells, counter;
	
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpABCont= NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, cValues2 = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int i=0,k=0;
	char EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	unsigned int	NumEntries, counter, StrLen;
	
    LPMAILUSER  lpMailUser=NULL,lpDistList=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.

    LPSPropValue lpSPropValueAddress = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_AddMultipleEntries");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);
	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
//	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //

	// Retrieve user info from ini file
	cValues = 3; //# of props we are setting
	lstrcpy(szDLTag,"Address1");
	GetPrivateProfileString("CreateEntriesStress",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
	StrLen = (strlen(EntProp[0]));
	_itoa(0,(char*)&EntProp[0][StrLen],10);
	EntProp[0][StrLen+1]= '\0';
	NumEntries = GetPrivateProfileInt("CreateEntriesStress","NumCopies",0,INIFILENAME);

	for (counter = 0; counter < NumEntries; counter++)	{
//		LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
		hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

		if (HR_FAILED(hr)) {
			LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
			retval=FALSE;			
			goto out;
		}

		//
		// Then set the properties
		//

		PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
		PropValue[1].ulPropTag  = PR_ADDRTYPE;
		PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;


			
		_itoa(counter,(char*)&EntProp[0][StrLen],10);
		LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
			
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
		hr = lpMailUser->SetProps(IN  cValues,
								 IN  PropValue,
								 IN  NULL);
			
		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 		retval=FALSE;			
			goto out;
		}
//		else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

		hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

		if (HR_FAILED(hr)) {
			LUIOut(L3,"MailUser->SaveChanges FAILED");
			retval=FALSE;
			goto out;
		}
//		else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

		if (lpMailUser) {
			lpMailUser->Release();
			lpMailUser = NULL;
		}

	}

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy(szDLTag,"Name1");
	GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
#endif DISTLIST	


out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IABResolveName()
{
	//DWORD	nCells, counter;
	
	char 	lpTitleText[64];
	BOOL	Found = FALSE;
	ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;
	unsigned int i = 0, idx = 0, cMaxProps =0, cEntries = 0;
	ENTRYLIST*	lpEntryList;

    char	lpszMatch[MAXSTRING], lpszNoMatch[MAXSTRING], lpszOneOff[MAXSTRING], lpszOneOff2[MAXSTRING];
	char	lpszMatchDisplayName[MAXSTRING], lpszMatchAddrType[MAXSTRING], lpszMatchEmailAddress[MAXSTRING];
    char	lpszOneOff2DisplayName[MAXSTRING], lpszOneOff2EmailAddress[MAXSTRING];
	char	lpszOneOffDisplayName[MAXSTRING], lpszOneOffEmailAddress[MAXSTRING];
	LPADRLIST	lpAdrList = NULL;
    ULONG		rgFlagList[2];
    LPFlagList	lpFlagList = (LPFlagList)rgFlagList;


    LPADRBOOK	lpAdrBook = NULL;
	LPABCONT	lpABCont = NULL;
	LPABCONT	lpDLCont = NULL;
	ULONG		cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	lpEidPAB = NULL, lpDLEntryID= NULL, lpLookupEID=NULL;

	ULONG		cbLookupEID, cValues = 0, cValues2 = 0, ulObjType=NULL;	
	int			k=0, NumEntries, NumProps;
	
    LPMAILUSER  lpMailUser=NULL,lpDistList=NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, SPTArrayCols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueMailUser = NULL;
    LPSPropValue lpSPropValueDistList = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;

    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	SizedSPropTagArray(1,SPTArrayDisplayName) = {1, {PR_DISPLAY_NAME} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABResolveName");
	LUIOut(L2,"-> Verifies IAdrBook->ResolveNames is functional by performing the following:");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a MailUser PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # Verifies the resolve UI is displayed when it should be by asking the test operator.");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L2, "   Calls SetProps followed by SaveChanges on a DistList PR_DISPLAY_NAME using a test string, and checks...");
	LUIOut(L2, "   # Verifies the resolve UI is displayed when it should be by asking the test operator.");
	LUIOut(L2, "   # The return code from ResolveNames (called with a PropertyTagArray containing PR_DISPLAY_NAME and PR_ENTRY_ID)");
	LUIOut(L2, "   # Walks the returned lpAdrList and checks each PropertyTagArray for PR_DISPLAY_NAME and then compares the ");
	LUIOut(L2, "     string to the original test string.");
	LUIOut(L2, "   # Walks the returned lpAdrList and verifies that an EntryID exists in each PropertyTagArray");
//	LUIOut(L2, "   # Verifies that the display name returned from GetProps is what we set");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Try to create a MailUser entry in the container
	//

	LUIOut(L2, "Creating a Mail User in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_MAILUSER property");

	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_MAILUSER
	assert(lpABCont != NULL);
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayAddress,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for Default MailUser template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_MAILUSER is an
    // EntryID which can be passed to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueAddress->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpMailUser);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

	// Read in the ini file strings to resolve against
	// Only adding 1 entry for the first ResName in the ini file
	// but will attempt to resolve all ResNames in the multientry resolve case
	GetPrivateProfileString("ResolveName","ResName1","no ini found",lpszMatch,MAXSTRING,INIFILENAME);
	GetPrivateProfileString("ResolveName","NonExistentName","no ini found",lpszNoMatch,MAXSTRING,INIFILENAME);
	GetPrivateProfileString("ResolveName","OneOffAddress","no ini found",lpszOneOff,MAXSTRING,INIFILENAME);
	GetPrivateProfileString("ResolveName","OneOffAddress2","no ini found",lpszOneOff2,MAXSTRING,INIFILENAME);
	

	ParseIniBuffer(lpszMatch, 1, lpszMatchDisplayName);
	ParseIniBuffer(lpszMatch, 2, lpszMatchAddrType);
	ParseIniBuffer(lpszMatch, 3, lpszMatchEmailAddress);

	ParseIniBuffer(lpszOneOff2, 1, lpszOneOff2DisplayName);
	ParseIniBuffer(lpszOneOff2, 3, lpszOneOff2EmailAddress);

	ParseIniBuffer(lpszOneOff, 1, lpszOneOffDisplayName);
	ParseIniBuffer(lpszOneOff, 3, lpszOneOffEmailAddress);

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
    PropValue[1].ulPropTag  = PR_ADDRTYPE;
    PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;
    PropValue[0].Value.LPSZ = lpszMatchDisplayName;
    PropValue[1].Value.LPSZ = lpszMatchAddrType;
    PropValue[2].Value.LPSZ = lpszMatchEmailAddress;

	/*
	cValues = 3; //# of props we are setting

	GetPropsFromIniBufEntry(lpszMatch,cValues,EntProp);

	//lstrcpy((LPTSTR)EntProp[0], lpszMatch);		
	LUIOut(L2,"MailUser Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	
	*/
	LUIOut(L2,"MailUser Entry to Add: %s",PropValue[0].Value.LPSZ);
	hr = lpMailUser->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"MailUser->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpMailUser->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"MailUser->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"MailUser->SaveChanges PASSED, entry added to PAB/WAB");

	//
	// Call ResolveName on the entry we just added which will be an exact match,
	// not display the UI and return a valid EID
	//
	
	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszMatchDisplayName;

	LUIOut(L2, "Calling IAdrBook->ResolveName with an exact match. Expect no UI and success.");
	
	MessageBox(NULL, "Calling IAB->ResolveName on the entry that was just added. Since this will be an exact match, you should not see the resolve dialog box.",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDYES)	{
		LUIOut(L3, "IABResolveName dialog displayed even tho we had an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	// Search through returned AdrList and verify each entry is resolved correctly
	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;

	// Store EID for multiple entry test case later on which needs a valid EID
	//lpLookupEID = (ENTRYID*)lpAdrList->aEntries[0].rgPropVals[idx].Value.bin.lpb;
	//cbLookupEID = lpAdrList->aEntries[0].rgPropVals[idx].Value.bin.cb;
	lpLookupEID = (ENTRYID*)NULL;
	cbLookupEID = 0;

	// Cleanup
	FreeAdrList(lpWABObject, &lpAdrList);

 	//
	// Call ResolveName on a OneOff Address which should succede with
	// no UI and return a valid EID. One off has a foo@com type DN and no email address
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszOneOff;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a one-off address (DN = foo@com type and no email addr). Expect no UI and success.");
	MessageBox(NULL, "Calling IAB->ResolveName on a one-off address. Since this will be an exact match, you should not see the resolve dialog box.",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDYES)	{
		LUIOut(L3, "IABResolveName dialog displayed even tho we had an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;
	FreeAdrList(lpWABObject, &lpAdrList);

 	//
	// Call ResolveName on a OneOff Address which should succede with
	// no UI and return a valid EID. One off has a DN of foo and an email address
	// of type foo@com
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 2;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszOneOff2DisplayName;
	lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_EMAIL_ADDRESS;
    lpAdrList->aEntries[0].rgPropVals[1].Value.LPSZ = lpszOneOff2EmailAddress;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a one-off address (DN = foo, email addr = foo@...). Expect no UI and success.");
	MessageBox(NULL, "Calling IAB->ResolveName on a second type of one-off address (DN = foo, EMail = foo@com type). Since this will be an exact match, you should not see the resolve dialog box.",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDYES)	{
		LUIOut(L3, "IABResolveName dialog displayed even tho we had an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;
	FreeAdrList(lpWABObject, &lpAdrList);

	
	//
	// Call ResolveName on an entry we don't expect to match exactly
	// Should bring up the resolve UI. Have the user select an entry and
	// then check for success
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszNoMatch;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a non-exact match. Expect to see UI and success  (user presses OK).");

	MessageBox(NULL, "Calling IAB->ResolveName on 'No such name' which should not match. This should cause the resolve dialog box to display. Please select any entry from the ListBox and press the OK button",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "IABResolveName dialog did not display even tho we did not have an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;
	FreeAdrList(lpWABObject, &lpAdrList);

	//
	// Call ResolveName on an entry we don't expect to match exactly
	// Should bring up the resolve UI. Have the user cancel from the UI
	// then check for MAPI_E_USER_CANCEL
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 1;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	// Fill in the properties we want
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszNoMatch;

	LUIOut(L2, "Calling IAdrBook->ResolveName with a non-exact match. Expect to see UI and MAPI_E_USER_CANCEL  (user presses CANCEL).");

	MessageBox(NULL, "Calling IAB->ResolveName on 'No such name' which should not match. This should cause the resolve dialog box to display. When the ListBox is displayed, please press the CANCEL button",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName(
		(ULONG)glblhwnd,
        MAPI_DIALOG,               // ulFlags
        lpTitleText,
		lpAdrList);
	if (hr == MAPI_E_USER_CANCEL) {
		LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		LUIOut(L3,"IAdrBook->ResolveName call PASSED");
	}
	else if (hr == MAPI_E_AMBIGUOUS_RECIP) {
		LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		retval=FALSE;
		goto out;
	}
	else if (hr == MAPI_E_NOT_FOUND) {
		LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		retval=FALSE;
		goto out;
	}
	else {
		LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		retval=FALSE;
		goto out;
	}

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "IABResolveName dialog did not display even tho we did not have an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	// Don't want to track the success of verify for this case
	VerifyResolvedAdrList(lpAdrList, NULL);
	FreeAdrList(lpWABObject, &lpAdrList);

	//
	// Call ResolveName on 4 entries as follows:
	//	* Entry with a non-zero EID prop -> already resolved so no UI
	//	* One-off entry with NULL EID -> will resolve but not bring up UI
	//	* non-exact match with NULL EID -> Will resolve and bring up UI
	//	* exact match with NULL EID -> Will resolve but not bring up UI
	//
	// When the UI is presented to the user, they should select a valid
	// entry and press OK. VerifyAdrList is expected to succede.
	//

	// Allocate an AdrList for NumEntries of NumProps
	NumEntries = 2;	// How many AdrEntries
	NumProps = 1;	// How many props for each entry

	if (!AllocateAdrList(lpWABObject, NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't allocate AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}

	// [ENTRY #1] - Exact match pre-resolve
	lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszMatchDisplayName;
	// [ENTRY #2] - One-off pre-resolve
	lpAdrList->aEntries[1].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[1].rgPropVals[0].Value.LPSZ = lpszOneOffDisplayName;
	// Pre-resolve these entries
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								(ULONG)0,               // want no UI this time
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"PRE-RESOLVE FAILED: IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	
	// Allocate the final AdrList for NumEntries of NumProps
	NumEntries = 5;	// How many AdrEntries
	NumProps = 2;	// How many props for each new entry

	if (!GrowAdrList(NumEntries, NumProps, &lpAdrList)) {
		LUIOut(L2, "Couldn't grow AdrList. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
	
	
	// [ENTRY #3] - Non-exact match not resolved
	lpAdrList->aEntries[2].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[2].rgPropVals[0].Value.LPSZ = lpszNoMatch;
	lpAdrList->aEntries[2].rgPropVals[1].ulPropTag = PR_NULL;

	// [ENTRY #4] - Exact match not resolved
	lpAdrList->aEntries[3].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[3].rgPropVals[0].Value.LPSZ = lpszMatchDisplayName;
	lpAdrList->aEntries[3].rgPropVals[1].ulPropTag = PR_NULL;
	// [ENTRY #5] - one-off type 2 (dispname and email addr) not resolved
	// Fill in the properties we want
    //PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
    //PropValue[1].ulPropTag  = PR_ADDRTYPE;
    //PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;
	lpAdrList->aEntries[4].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    lpAdrList->aEntries[4].rgPropVals[0].Value.LPSZ = lpszOneOff2DisplayName;
	lpAdrList->aEntries[4].rgPropVals[1].ulPropTag = PR_EMAIL_ADDRESS;
    lpAdrList->aEntries[4].rgPropVals[1].Value.LPSZ = lpszOneOff2EmailAddress;
	
	LUIOut(L2, "Calling IAdrBook->ResolveName with 5 Entries. Expect to see UI once and success  (user presses OK).");

	MessageBox(NULL, "Calling IAB->ResolveName with multiple entries. This should cause the resolve dialog box to display only once. Please select any entry from the ListBox and press the OK button",
						"WAB Test Harness", MB_OK);
    strcpy(lpTitleText, "IAdrBook->ResolveName Test");
	hr = lpAdrBook->ResolveName((ULONG)glblhwnd,
								MAPI_DIALOG,               // ulFlags
								lpTitleText,
								lpAdrList);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"IAdrBook->ResolveName call FAILED");
		if (hr == MAPI_E_AMBIGUOUS_RECIP)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_AMBIGUOUS_RECIP");
		else if (hr == MAPI_E_NOT_FOUND)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_NOT_FOUND");
		else if (hr == MAPI_E_USER_CANCEL)
			LUIOut(L3, "IAdrBook->ResolveName returned MAPI_E_USER_CANCEL");
		else
			LUIOut(L3, "IAdrBook->ResolveName returned UNKNOWN result code");
		retval=FALSE;
		goto out;
	}
	else LUIOut(L3,"IAdrBook->ResolveName call PASSED");

	if (MessageBox(NULL, "Did you see the ResolveName dialog box appear?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "IABResolveName dialog did not display even tho we did not have an exact match. Test FAILED");
		retval = FALSE;
		goto out;
	}

	if (!VerifyResolvedAdrList(lpAdrList, NULL)) retval = FALSE;

		// Now delete the entry from the wab
	
	hr = lpMailUser->GetProps(   IN  (LPSPropTagArray) &SPTArrayEntryID,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueEntryID);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps FAILED for MailUser");
	 		retval=FALSE;			
			goto out;
	}
	
	
	hr = HrCreateEntryListFromID(lpWABObject,
		IN  lpSPropValueEntryID->Value.bin.cb,
		IN  (ENTRYID*)lpSPropValueEntryID->Value.bin.lpb,
		OUT &lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entry. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}

	FreeEntryList(lpWABObject, &lpEntryList);

	FreeAdrList(lpWABObject, &lpAdrList);

#ifdef DISTLIST
	//
	// Try to create a DL entry in the container
	//

	LUIOut(L2, "Creating a Distribution List in the container");
	LUIOut(L3, "Calling GetProps on the container with the PR_DEF_CREATE_DL property");
	// Need to get the template ID so we call GetProps with PR_DEF_CREATE_DL
	hr = lpABCont->GetProps(   IN  (LPSPropTagArray) &SPTArrayDL,
                               IN  0,      //Flags
                               OUT &cValues,
                               OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
			LUIOut(L3,"GetProps failed for Default DL template");
	 		retval=FALSE;			
			goto out;
	}

    // The returned value of PR_DEF_CREATE_DL is an
    // EntryID which one can pass to CreateEntry
    //
	LUIOut(L3, "Calling IABContainer->CreateEntry with the EID from GetProps");
    hr = lpABCont->CreateEntry(  IN  lpSPropValueDL->Value.bin.cb,
								 IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,
								 IN  0,
								 OUT (LPMAPIPROP *) &lpDistList);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		retval=FALSE;			
	    goto out;
	}

    //
    // Then set the properties
    //

    PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

	cValues = 1; //# of props we are setting
		
	lstrcpy((LPTSTR)EntProp[0], lpszInput2);		
	LUIOut(L2,"DistList Entry to Add: %s",EntProp[0]);
		
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	hr = lpDistList->SetProps(IN  cValues,
                             IN  PropValue,
                             IN  NULL);
		
    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SetProps call FAILED for %s properties",PropValue[0].Value.LPSZ);
	 	retval=FALSE;			
		goto out;
	}
	else 	LUIOut(L3,"DistList->SetProps call PASSED for %s properties",PropValue[0].Value.LPSZ);

    hr = lpDistList->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

    if (HR_FAILED(hr)) {
		LUIOut(L3,"DistList->SaveChanges FAILED");
		retval=FALSE;
        goto out;
	}
	else LUIOut(L3,"DistList->SaveChanges PASSED, entry added to PAB/WAB");
	
	//
	// Do a ResolveNames on the string
	//
	
	LUIOut(L2, "Retrieving the entry and verifying against what we tried to save.");

	// use WAB Allocators here
#ifdef PAB
    if (! (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //PAB
#ifdef WAB
    if (! (sc = lpWABObject->AllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), (void **)&lpAdrList))) {
#endif //WAB
		lpAdrList->cEntries = 1;
        lpAdrList->aEntries[0].ulReserved1 = 0;
        lpAdrList->aEntries[0].cValues = 1;

#ifdef PAB
        if (! (sc = MAPIAllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB
#ifdef WAB
        if (! (sc = lpWABObject->AllocateMore(sizeof(SPropValue), lpAdrList,
               (void **)&lpAdrList->aEntries[0].rgPropVals))) {
#endif //WAB

			lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput2;
			
			lpFlagList->cFlags = 1;
            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

            hr = lpABCont->ResolveNames(
				(LPSPropTagArray)&SPTArrayCols,    // tag set for disp_name and eid
                0,               // ulFlags
                lpAdrList,
                lpFlagList);
		    if (HR_FAILED(hr)) {
				LUIOut(L3,"ABContainer->ResolveNames call FAILED, returned 0x%x", hr);
				retval=FALSE;
				goto out;
			}
			else LUIOut(L3,"ABContainer->ResolveNames call PASSED");

			Found = FALSE;
			// Search through returned AdrList for our entry
			for(i=0; ((i<(int) lpAdrList->cEntries) && (!Found)); ++i)	{
				cMaxProps = (int)lpAdrList->aEntries[i].cValues;
				//Check to see if Display Name exists
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_DISPLAY_NAME )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps) {
						LUIOut(L4, "PR_DISPLAY_NAME was not found in the lpAdrList");
						retval = FALSE;
					}
				}
				LUIOut(L4,"Display Name: %s",lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ);
				if (!lstrcmp(lpAdrList->aEntries[i].rgPropVals[idx].Value.LPSZ,lpszInput2))	{
					LUIOut(L3, "Found the entry we just added");
					Found = TRUE;
				}
				//Check to see if EntryID exists
				LUIOut(L3, "Verifying a PR_ENTRYID entry exists in the PropertyTagArray");
				idx=0;
				while((lpAdrList->aEntries[i].rgPropVals[idx].ulPropTag != PR_ENTRYID )	
						&& retval)	{
					idx++;
					if(idx == cMaxProps)	{
						LUIOut(L4, "PR_ENTRYID was not found in the lpAdrList");
						retval =  FALSE;
					}
				}
				if (!Found) LUIOut(L3, "Did not find the entry. Test FAILED");
				if (idx < cMaxProps) LUIOut(L3, "EntryID found");
				if (!(retval && Found)) retval = FALSE;
				else	{
					// Store EID for call to OpenEntry
				}
			}
		}			

#ifdef PAB
        MAPIFreeBuffer(lpAdrList);
#endif //PAB
#ifdef WAB
        lpWABObject->FreeBuffer(lpAdrList);
#endif //WAB
	}
#endif //DISTLIST

out:
		FreeAdrList(lpWABObject, &lpAdrList);

#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

#endif
#ifdef WAB
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			lpWABObject->FreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			lpWABObject->FreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			lpWABObject->FreeBuffer(lpSPropValueDL);

#endif
		if (lpMailUser)
			lpMailUser->Release();

		if (lpDistList)
			lpDistList->Release();

		if (lpABCont)
				lpABCont->Release();

		if (lpDLCont)
				lpDLCont->Release();

		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

		return retval;
}


BOOL PAB_IABNewEntry_Details()
{
    LPADRBOOK	lpAdrBook = NULL;
	LPABCONT	lpABCont= NULL;
	ULONG		cbEidPAB = 0, cbEid = 0;
	LPENTRYID	lpEidPAB   = NULL, lpEid = NULL;
	ULONG		ulObjType=NULL;	
    HRESULT		hr = hrSuccess;
	int			retval=TRUE;
	ULONG		UIParam = (ULONG)glblhwnd;
	
	
	LUIOut(L1," ");
	LUIOut(L1,"Running PAB_IABNewEntry//Details");
	LUIOut(L2,"-> Verifies IAdrBook->NewEntry and Details are functional by performing the following:");
	LUIOut(L2, "   Calls NewEntry and then passes the returned EID to Details");
	LUIOut(L1," ");

	if (!GetAB(OUT &lpAdrBook))	{
		retval = FALSE;
		goto out;
	}

	// Call IAddrBook::OpenEntry to get the root container to PAB - MAPI
	
	assert(lpAdrBook != NULL);

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);

	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->OpenEntry Failed");
		retval=FALSE;
		goto out;
	}

	//
	// Bringing up the NewEntry UI
	//

	LUIOut(L2, "Calling NewEntry");
	assert(lpABCont != NULL);

	MessageBox(NULL, "Calling IAB->NewEntry, which will bring up the property panes for creating a new WAB entry. Fill in as many fields as possible and press the OK button",
						"WAB Test Harness", MB_OK);
	hr = lpAdrBook->NewEntry(
						IN (ULONG)glblhwnd,
						IN 0,		//ulFlags - reserved, must be zero
						IN cbEidPAB,
						IN lpEidPAB,
						IN 0,		//cbEIDNewEntryTpl - not supported by WAB, must be zero
						IN NULL,	//lpEIDNewEntryTpl - not supported by WAB, must be zero
						OUT &cbEid,
						OUT &lpEid);

	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->NewEntry Failed");
		retval=FALSE;
		goto out;
	}

	MessageBox(NULL, "Calling IAB->Details, which will bring up the property panes for the WAB entry you just created. Please verify the values of the fields are as expected and press the OK button",
						"WAB Test Harness", MB_OK);
	hr = lpAdrBook->Details(
						&UIParam,
						IN NULL,	//lpfnDismiss - must be NULL for tier1 WAB
						IN 0,		//lpvDismissContext
						IN cbEid,
						IN lpEid,
						IN NULL,	//lpfButtonCallback - not supported in WAB, must be NULL
						IN NULL,	//lpvButtonContext - not supported in WAB, must be NULL
						IN NULL,	//lpszButtonText - not supported in WAB, must be NULL
						IN 0);		//ulFlags - not supported in WAB, must be zero

	if (HR_FAILED(hr)) {
		LUIOut(L2,"IAddrBook->Details Failed");
		retval=FALSE;
		goto out;
	}
	
	if (MessageBox(NULL, "Did the new entry get added/displayed properly?",
		"WAB Test Harness", MB_YESNO) == IDNO)	{
		LUIOut(L3, "User ansered No to the pass-test message box. Test FAILED");
		retval = FALSE;
		goto out;
	}
	
out:
#ifdef PAB
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif
#ifdef WAB
		if (lpEid)
			lpWABObject->FreeBuffer(lpEid);
		if (lpEidPAB)
			lpWABObject->FreeBuffer(lpEidPAB);
#endif
		if (lpABCont)
				lpABCont->Release();
		if (lpAdrBook)
			  lpAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		if (lpWABObject)
			lpWABObject->Release();
#endif

	return(retval);
}


BOOL Performance()
{
	
    HRESULT hr;
	int		retval=TRUE;
	DWORD	StartTime, StopTime, Elapsed;
	LPVOID			Reserved1 = NULL;
	DWORD			Reserved2 = 0;

    LPADRBOOK		lpLocalAdrBook;
	LPABCONT		lpABCont= NULL;
	ULONG			cbEidPAB = 0;
	LPENTRYID		lpEidPAB   = NULL;
	LPMAPITABLE		lpTable = NULL;
	LPSRowSet		lpRows = NULL;
	LPWABOBJECT		lpLocalWABObject;
	ENTRYLIST		EntryList,*lpEntryList = &EntryList;

	ULONG   cValues = 0, ulObjType=NULL;	
	int i=0,k=0;
	unsigned int	NumEntries;
	DWORD	PerfData;
	WAB_PARAM		WP;
	
	LUIOut(L1, "WAB Performance Suite");
	NumEntries = 20;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;

	NumEntries = 100;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;


	NumEntries = 500;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;


	NumEntries = 1000;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;
	lpLocalWABObject->Release();
	lpLocalWABObject = NULL;


	NumEntries = 5000;
	LUIOut(L1, " ");
	LUIOut(L2, "Running performance data for %u entries.", NumEntries);
	DeleteWABFile();
	CreateMultipleEntries(NumEntries,&PerfData);
	LUIOut(L2, "** Time for SaveChanges (Avg. per entry) = %u milliseconds", PerfData);

	hr = WABOpen(&lpLocalAdrBook, &lpLocalWABObject, &WP, Reserved2);
	
	if (HR_FAILED(hr)) {
		LUIOut(L2,"WABOpen Failed");
		retval=FALSE;
		goto out;
	}

	assert(lpLocalAdrBook != NULL);
	hr = OpenPABID(  IN lpLocalAdrBook, OUT &cbEidPAB,
						OUT &lpEidPAB,OUT &lpABCont, OUT &ulObjType);
	if (HR_FAILED(hr)) {
		LUIOut(L2,"OpenPABID Failed");
		retval=FALSE;
		goto out;
	}
	StartTime = GetTickCount();
	hr = lpABCont->GetContentsTable(ULONG(0), &lpTable);
	StopTime = GetTickCount();
	if (HR_FAILED(hr)) {
		LUIOut(L3,"ABContainer->GetContentsTable call FAILED, returned 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to GetContentsTable (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));
	hr = lpTable->QueryRows(LONG(0x7FFFFFFF),
							ULONG(0),
							&lpRows);
	if (HR_FAILED(hr)) {
		LUIOut(L3,"Table->QueryRows call FAILED with errorcode 0x%x", hr);
		retval=FALSE;
		goto out;
	}
	if (!lpRows->cRows) {
		LUIOut(L2, "QueryRows did not find any entries. Test FAILED");
		retval=FALSE;
		goto out;
	}
	else
		LUIOut(L3, "QueryRows returned %u rows.", lpRows->cRows);

	// Change the EntryIDs to a LPENTRYLIST
	hr = HrCreateEntryListFromRows(IN lpLocalWABObject,
								   IN  &lpRows,
								   OUT (ENTRYLIST**)&lpEntryList);
	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Create Entry List");
			retval=FALSE;
			goto out;
	}

	// Then pass the lpEntryList to DeleteEntries to delete ...
	StartTime = GetTickCount();
	hr = lpABCont->DeleteEntries(IN  lpEntryList,IN  0);
	StopTime = GetTickCount();
	Elapsed = StopTime-StartTime;
	LUIOut(L2, "** Time to DeleteEntries (Avg. per entry) = %u.%03u milliseconds", Elapsed/NumEntries, ((Elapsed*1000)/NumEntries)-((Elapsed/NumEntries)*1000));

	if (HR_FAILED(hr)) {
			LUIOut(L3,"Could not Delete Entries. DeleteEntry returned 0x%x", hr);
			FreeEntryList(lpLocalWABObject, &lpEntryList);
			retval=FALSE;
			goto out;
	}
	FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
	FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
	if (lpTable) {
		lpTable->Release();
		lpTable = NULL;
	}
	lpLocalWABObject->FreeBuffer(lpEidPAB);
	lpEidPAB = NULL;
	lpABCont->Release();
	lpABCont = NULL;
	lpLocalAdrBook->Release();
	lpLocalAdrBook = NULL;

// Don't want to release the WABObject at this point since we'll need it to free memory below	
//	lpLocalWABObject->Release();
//	lpLocalWABObject = NULL;

	
out:
		FreeRows(lpLocalWABObject, &lpRows);	// Cleanup from first call to queryrows
		FreeEntryList(lpLocalWABObject, (ENTRYLIST**)&lpEntryList);
		if (lpTable) {
			lpTable->Release();
			lpTable = NULL;
		}
#ifdef PAB
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
#endif

#ifdef WAB
		if (lpEidPAB)
			lpLocalWABObject->FreeBuffer(lpEidPAB);
#endif

		if (lpABCont)
				lpABCont->Release();

		if (lpLocalAdrBook)
			  lpLocalAdrBook->Release();

#ifdef PAB
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
#ifdef WAB
		
		if (lpLocalWABObject) {
			lpLocalWABObject->Release();
			lpLocalWABObject = NULL;
		}

		if (lpWABObject) {
			lpWABObject->Release();
			lpWABObject = NULL;
		}
#endif

		return retval;
}



BOOL PabCreateEntry()
{
    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPABCONT	  lpDLCont= NULL;
	ULONG		  cbEidPAB = 0, cbDLEntryID = 0;
	LPENTRYID	  lpEidPAB   = NULL, lpDLEntryID= NULL;
	LPENTRYLIST	lpEntryList=NULL; // needed for copy entry to PDL
	ULONG     cbEid=0;  // entry id of the entry being added
	LPENTRYID lpEid=NULL;

    char   EntProp[10][BIG_BUF];  //MAX_PROP
	ULONG       cValues = 0, ulObjType=NULL;	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;
	int cEntriesToAdd,i=0,k=0;
	char szEntryTag[SML_BUF],szTagBuf[SML_BUF],EntryBuf[MAX_BUF];
	char szDLTag[SML_BUF];
	
	LPMAPITABLE lpContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL;
    LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};  // This value is 3 because we
                                        // will be setting 3 properties:
                                        // EmailAddress, DisplayName and
                                        // AddressType.
	SizedSPropTagArray(2, Cols) = { 2, {PR_OBJECT_TYPE, PR_ENTRYID } };

    LPSPropValue lpSPropValueAddress = NULL;
    LPSPropValue lpSPropValueEntryID = NULL;
	LPSPropValue lpSPropValueDL = NULL;
    SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	SizedSPropTagArray(1,SPTArrayDL) = {1, {PR_DEF_CREATE_DL} };
    SizedSPropTagArray(1,SPTArrayEntryID) = {1, {PR_ENTRYID} };
	
	LUIOut(L1," ");
	LUIOut(L1,"Running CreateEntries");
	LUIOut(L2,"-> Creates specified entries in PAB");
	LUIOut(L2, "   And also copies them into a Distribution List");
	LUIOut(L1," ");
	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
		 		 		
	// Create an Entry of type "Other Address" in PAB
	// OpenPAB

	 hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	 if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	 }

	// Create a PDL to fill

	 	hr = lpPABCont->GetProps(  IN  (LPSPropTagArray) &SPTArrayDL,
                                IN  0,      //Flags
                                OUT &cValues,
                                OUT &lpSPropValueDL);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps failed for Default DL template");
		 		retval=FALSE;			
				goto out;
		}

        // The returned value of PR_DEF_CREATE_DL is an
        // EntryID which one can pass to CreateEntry
        //
        hr = lpPABCont->CreateEntry(
                    IN  lpSPropValueDL->Value.bin.cb,               //Template cbEid
                    IN  (LPENTRYID) lpSPropValueDL->Value.bin.lpb,  //Template lpEid
                    IN  0,
                    OUT (LPMAPIPROP *) &lpAddress);

        if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_DL");
		 		retval=FALSE;			
			    goto out;
		}

        //
        // Then set the properties
        //

        PropValue[0].ulPropTag  = PR_DISPLAY_NAME;

		cValues = 1; //# of props we are setting
		
		lstrcpy(szDLTag,"Name1");
		GetPrivateProfileString("CreatePDL",szDLTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	
		GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
		LUIOut(L2,"PDL Entry to Add: %s",EntProp[0]);
		
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	    hr = lpAddress->SetProps(IN  cValues,
                                IN  PropValue,
                                IN  NULL);
		
        if (HR_FAILED(hr)) {
			LUIOut(L3,"SetProps on failed for %s properties",PropValue[0].Value.LPSZ);
		 	retval=FALSE;			
			goto out;
		}
		//else 	LUIOut(L3,"SetProps Passed for %s properties",PropValue[0].Value.LPSZ);
		
        hr = lpAddress->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

        if (HR_FAILED(hr)) {
			LUIOut(L3,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
		}
		else LUIOut(L3,"PDL Entry Added to PAB");

		if (lpAddress) {
			lpAddress->Release();
			lpAddress = NULL;
		}

//***
		
	//Get the PAB table so we can extract the DL
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"GetContentsTable: Failed");
		retval = FALSE;
        goto out;
	}

	// look for the first PDL that you can find

	hr = lpContentsTable->SetColumns(IN  (LPSPropTagArray) &Cols,
                                IN  0);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetColumns Failed");
		retval = FALSE;
        goto out;
	}

	do
	{
		hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet);
		if (HR_FAILED(hr)){
			LUIOut(L3,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}
		
		cRows = lpRowSet->cRows;
		for (iEntry = 0; iEntry < cRows; iEntry++)
		{
			//
			//  For each entry, process it.
			//
			//lpSPropValue = lpRowSet->aRow[iEntry].lpProps;
			if ((lpRowSet->aRow[iEntry].lpProps[0].ulPropTag == PR_OBJECT_TYPE) &&
				(lpRowSet->aRow[iEntry].lpProps[0].Value.ul == MAPI_DISTLIST))
            {
                if (lpRowSet->aRow[iEntry].lpProps[1].ulPropTag == PR_ENTRYID)
			    {
					cbDLEntryID = lpRowSet->aRow[iEntry].lpProps[1].Value.bin.cb;
					if ( !MAPIAllocateBuffer(cbDLEntryID, (LPVOID *)&lpDLEntryID)) {						
                  		 CopyMemory(lpDLEntryID, (LPENTRYID)lpRowSet->aRow[iEntry].lpProps[1].Value.bin.lpb, cbDLEntryID);
					}
					else {
						LUIOut(L3,"MAPIAllocateBuffer Failed");
						retval = FALSE;
					}
					break;
                }
		    }
        }

        //
		//  done, clean up
		//
        if(lpRowSet) {
		    FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
		
      }while((0!=cRows)&& (0==(cbDLEntryID)));

	if (cbDLEntryID == 0)
		LUIOut(L3,"PDL does not exist");

	hr = lpPABCont->OpenEntry(
                         IN	 cbDLEntryID,
                         IN	 lpDLEntryID,
                         IN	 NULL,              //default interface
                         IN	 MAPI_BEST_ACCESS,  //flags
                         OUT &ulObjType,
                         OUT (LPUNKNOWN *) &lpDLCont);

	if (HR_FAILED(hr)) {
			LUIOut(L2,"OpenEntry Failed");
			retval=FALSE;
			goto out;
	}

		

//***
	// Get Entry displayname, addresstype and (email)address from INI
	
	
	cEntriesToAdd= GetPrivateProfileInt("CreateEntries","NumEntries",0,INIFILENAME);
	
	for (k= 0; k<cEntriesToAdd; k++) {
		lstrcpy((LPSTR)szEntryTag,"Address");
		lstrcat(szEntryTag,_itoa(k+1,szTagBuf,10));
		// Addresses are comma delimited and enclosed in quotes
		GetPrivateProfileString("CreateEntries",szEntryTag,"",EntryBuf,MAX_BUF,INIFILENAME);
		// parse the buffer for properties: displayname, emailaddress and address type
	
	// if no email address specified
	// then user will enter
	// else enter programatically
	// else part implemented below

	hr = lpPABCont->GetProps(  IN  (LPSPropTagArray) &SPTArrayAddress,
                                IN  0,      //Flags
                                OUT &cValues,
                                OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps failed for Default template");
		 		retval=FALSE;			
				goto out;
		}

        // The returned value of PR_DEF_CREATE_MAILUSER is an
        // EntryID which one can pass to CreateEntry
        //
				
        hr = lpPABCont->CreateEntry(
                    IN  lpSPropValueAddress->Value.bin.cb,               //Template cbEid
                    IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,  //Template lpEid
                    IN  0,
                    OUT (LPMAPIPROP *) &lpAddress);

        if (HR_FAILED(hr)) {
				LUIOut(L3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		 		retval=FALSE;			
			    goto out;
		}

        //
        // Then set the properties
        //

        PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
        PropValue[1].ulPropTag  = PR_ADDRTYPE;
        PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;

		cValues = 3; //# of props we are setting
	
		GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
		
		LUIOut(L2,"Entry to Add: %s",EntProp[0]);
		
		for (i=0; i<(int)cValues;i++)
			PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
	    hr = lpAddress->SetProps(IN  cValues,
                                IN  PropValue,
                                IN  NULL);
		
        if (HR_FAILED(hr)) {
			LUIOut(L3,"SetProps failed for %s",PropValue[0].Value.LPSZ);
		 	retval=FALSE;			
			goto out;
		}
		//else 	LUIOut(L3,"SetProps Passed for %s properties",PropValue[0].Value.LPSZ);
		
        hr = lpAddress->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

        if (HR_FAILED(hr)) {
			LUIOut(L3,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
		}
		else LUIOut(L3,"Entry Added to PAB");

		
	/** */
	// Now copy the entry to the default DL

	// Get EntryID

		hr = lpAddress->GetProps(
                    IN (LPSPropTagArray) &SPTArrayEntryID,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValueEntryID);
    if ((HR_FAILED(hr))||(PropError(lpSPropValueEntryID->ulPropTag))) {
		{
					LUIOut( L2,"GetProps on entry in PAB failed" );
					retval = FALSE;
					goto out;
		}
		
		cbEid = lpSPropValueEntryID->Value.bin.cb;
		if ( !MAPIAllocateBuffer(cbEid, (LPVOID *)&lpEid)) {						
                 CopyMemory(lpEid, (VOID*)(LPENTRYID) lpSPropValueEntryID->Value.bin.lpb, cbEid);
		} else {
						LUIOut(L3,"MAPIAllocateBuffer Failed");
						retval = FALSE;
		}
		

	/** */
	// Now copy the entry to the default DL

	hr = HrCreateEntryListFromID(lpLocalWABObject, lpLocalWABObject,    IN  cbEid,
									IN  lpEid,
									OUT &lpEntryList);
	if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Create Entry List");
				retval=FALSE;
				goto out;
	}
	
	hr = lpDLCont->CopyEntries(IN lpEntryList,IN NULL, IN NULL, IN NULL);

	if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Copy Entry %s", EntProp[0]);
				retval=FALSE;
				goto out;
	} else 	LUIOut(L3,"Copied Entry: %s to PDL", EntProp[0]);

		/** */

		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);

		if (lpAddress) {
			lpAddress->Release();
			lpAddress = NULL;
		}
}


	out:
 	
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);

		if (lpSPropValueEntryID)
			MAPIFreeBuffer(lpSPropValueEntryID);
		
		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

		if (lpEid)
			MAPIFreeBuffer(lpEid);

		if (lpAddress)
			lpAddress->Release();

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();


		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL PabDeleteEntry()
{
    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
    char   szDispName[BIG_BUF];

	ULONG       cValues         = 0;
	int cEntriesToDelete,i=0,k=0;
	char szEntryTag[SML_BUF],szTagBuf[SML_BUF];
	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;

    LPMAPITABLE lpContentsTable = NULL;

    LPSRowSet   lpRowSet    = NULL;

    SPropValue   PropValue      = {0};
    LPSPropValue lpSPropValue   = NULL;

	SizedSPropTagArray(2, Cols) = { 2, {PR_DISPLAY_NAME, PR_ENTRYID } };

	LPENTRYLIST	lpEntryList=NULL;
	ULONG     cbEid=0;
	LPENTRYID lpEid=NULL;
	LPVOID *lpEid2=NULL;
	
	LUIOut(L1," ");
	LUIOut(L1,"Running DeleteEntries");
	LUIOut(L2,"-> Deletes specified entries from the PAB");
	LUIOut(L1," ");
		
	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
		 		 		
	// OpenPAB

	 hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	 if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	 }

	// Get Entry displayname from INI

	cEntriesToDelete = GetPrivateProfileInt("DeleteEntries","NumEntries",0,INIFILENAME);
	
	for (k= 0; k<cEntriesToDelete; k++) {
		lstrcpy((LPSTR)szEntryTag,"Name");
		lstrcat(szEntryTag,_itoa(k+1,szTagBuf,10));
		GetPrivateProfileString("DeleteEntries",szEntryTag,"",szDispName,MAX_BUF,INIFILENAME);
		if (szDispName[0]==0) continue;
		LUIOut(L2,"Entry to Delete: %s",szDispName);
		cbEid=0;

	//
    // Get the Contents Table for the PAB container
    //
    hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"GetContentsTable: Failed");
        goto out;
	}

    //
    // Only interested in 2 columns:
    // PR_DISPLAY_NAME and PR_ENTRYID
    //
    hr = lpContentsTable->SetColumns(IN  (LPSPropTagArray) &Cols,
                                IN  0);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetColumns Failed");
		retval = FALSE;
        goto out;
	}

    //
    // Since we don't know how many entries exist in the PAB,
    // we will scan them 1000 at a time till we find the desired
    // contact or reach the end of the table...
    do
	{
		hr = lpContentsTable->QueryRows(IN  1000,
								IN  0,
							    OUT &lpRowSet);
		if (HR_FAILED(hr)){
			LUIOut(L3,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}
			
		cRows = lpRowSet->cRows;
		for (iEntry = 0; iEntry < cRows; iEntry++)
		{
			//
			//  For each entry, process it.
			//
			lpSPropValue = lpRowSet->aRow[iEntry].lpProps;
			if (    (lpSPropValue[0].ulPropTag == PR_DISPLAY_NAME) &&
                    (!lstrcmpi(lpSPropValue[0].Value.LPSZ, szDispName)) )
            {
                if (lpSPropValue[1].ulPropTag == PR_ENTRYID)
			    {
    	    		cbEid = lpSPropValue[1].Value.bin.cb;
					lpEid = (LPENTRYID) lpSPropValue[1].Value.bin.lpb;

					if ( !MAPIAllocateBuffer(cbEid, (LPVOID *)&lpEid2)) {						
                  		 CopyMemory(lpEid2, lpEid, cbEid);
						 lpEid= (LPENTRYID)lpEid2;
					}
					else {
						LUIOut(L3,"MAPIAllocateBuffer Failed");
						retval = FALSE;
					}
	    	    	//lpEid = (LPENTRYID) lpSPropValue[1].Value.bin.lpb;

                  // if ( !MAPIAllocateBuffer(cbEid, (LPVOID*)lppEid))
                  //  {
                   //     CopyMemory(*lppEid, lpEid, *lpcbEid);
                  //  }
                    break;
                }
		    }
        }

        //
		//  done, clean up
		//
        if(lpRowSet) {
		    FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
		
      }while((0!=cRows)&& (0==(cbEid)));

	if (cbEid == 0)
		LUIOut(L3,"Entry does not exist");
	else {

		//
		// Change the EntryID to a LPENTRYLIST
		//
		hr = HrCreateEntryListFromID(lpLocalWABObject,    IN  cbEid,
										IN  lpEid,
										OUT &lpEntryList);
		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Create Entry List");
				retval=FALSE;
				goto out;
		}



		//
		// Then pass the lpEntryList to DeleteEntries to delete ...
		//
		hr = lpPABCont->DeleteEntries(IN  lpEntryList,IN  0);

		if (HR_FAILED(hr)) {
				LUIOut(L3,"Could not Delete Entry %s", szDispName);
				retval=FALSE;
				goto out;
		} else 	LUIOut(L3,"Deleted Entry: %s", szDispName);
	}

}
		
	out:
 	
		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpEid)
			MAPIFreeBuffer(lpEid);

		if (lpPABCont)
				lpPABCont->Release();

		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();

#endif
		return retval;
}

BOOL PabEnumerateAll()
{
	HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		i = 0,j = 0,retval=TRUE, bDistList = FALSE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL, lpDLCont = NULL;
	ULONG ulEntries=0, ulEntriesDL = 0;
	ULONG     cbEid=0, cbDLEid=0;
	LPENTRYID lpEid=NULL, lpDLEid = NULL;
	ULONG	ulObjType=NULL,cValues=0;
	LPMAILUSER	lpUser=NULL, lpDLUser = NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
    LPMAPITABLE lpContentsTable = NULL, lpDLContentsTable = NULL;
	LPSRowSet   lpRowSet    = NULL, lpRowSetDL= NULL;

	LPSPropValue lpSPropValue = NULL, lpSPropValueDL = NULL;
    SizedSPropTagArray(2,SPTTagArray) = {2, {PR_DISPLAY_NAME, PR_EMAIL_ADDRESS} };

    LUIOut(L1," ");
	LUIOut(L1,"Running EnumerateAll");
	LUIOut(L2,"-> Enumerates all the entries in the PAB");
	LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}
	
	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	
	if(! OpenPABID(IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType))
	{
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	assert(lpPABCont != NULL);
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L2,"GetContentsTable: Failed");
		retval=FALSE;
		goto out;
	}
	assert(lpRowSet == NULL);	
	assert(lpRowSetDL == NULL);
	assert(lpContentsTable != NULL);
	while(!HR_FAILED(hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet))) {
		assert(lpRowSet != NULL);
		bDistList = FALSE;
			
		if (lpRowSet->cRows) {
			ulEntries++;
			i=0;
			while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_ENTRYID )
				if (++i >= (int) lpRowSet->aRow[0].cValues)
				{
					LUIOut( L2, "Didn't find PR_ENTRYID in the row!" );
					retval=FALSE;
					goto out;
				}

			cbEid = lpRowSet->aRow[0].lpProps[i].Value.bin.cb;
			lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[i].Value.bin.lpb;
			assert(lpEid != NULL);

			// Is this a DL
			i=0;
			while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_OBJECT_TYPE )
				if (++i >= (int) lpRowSet->aRow[0].cValues)
				{
					LUIOut( L2, "Didn't find PR_OBJECT_TYPE in the row!" );
					retval=FALSE;
					goto out;
				}
			if (lpRowSet->aRow[0].lpProps[i].Value.ul == MAPI_DISTLIST)
				bDistList = TRUE;
		//d	lpUser = NULL;
			assert(lpUser == NULL);
			assert(lpPABCont != NULL);
	
			hr = lpPABCont->OpenEntry(
                         IN	 cbEid,
                         IN	 lpEid,
                         IN	 NULL,              //default interface
                         IN	 MAPI_BEST_ACCESS,  //flags
                         OUT &ulObjType,
                         OUT (LPUNKNOWN *) &lpUser);

			if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenEntry Failed");
				retval=FALSE;
				goto out;
			}
			else
			{
				//d assert(lpUser != NULL);
				//LUIOut( L2,"OpenEntry on EntryID for User Passed" );
				
				assert(lpUser != NULL);
				hr = lpUser->GetProps(
                    IN (LPSPropTagArray) &SPTTagArray,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValue);


    if ((HR_FAILED(hr))||(PropError(lpSPropValue->ulPropTag, cValues))) {
				{
					LUIOut( L2,"GetProps on User Object failed" );
				}
				else
				{
					LUIOut(L2,"Entry Name: %s",lpSPropValue->Value.LPSZ);
					if (lpSPropValue) {
						MAPIFreeBuffer(lpSPropValue);
						lpSPropValue = NULL;
					}
					assert(lpSPropValue == NULL);

				}	
				
				/* */
				if (bDistList) {
					//d lpDLCont = NULL;
					assert(lpDLCont == NULL);
					assert(lpPABCont != NULL);
					hr = lpPABCont->OpenEntry(
                         IN	 cbEid,
                         IN	 lpEid,
                         IN	 NULL,              //default interface
                         IN	 MAPI_BEST_ACCESS,  //flags
                         OUT &ulObjType,
                         OUT (LPUNKNOWN *) &lpDLCont);

						if (HR_FAILED(hr)) {
								LUIOut(L2,"OpenEntry Failed");
								retval=FALSE;
								goto out;
						}
						//d set to NULL?
						assert(lpDLContentsTable == NULL);
			
						assert(lpDLCont != NULL);
						hr = lpDLCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpDLContentsTable);

						if (HR_FAILED(hr)) {
							LUIOut(L2,"GetContentsTable: Failed");
							retval=FALSE;
							goto out;
						}
						assert(lpRowSetDL == NULL);
						
						assert(lpDLContentsTable != NULL);
						while(!HR_FAILED(hr = lpDLContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSetDL))) {
						if (lpRowSetDL->cRows) {
							ulEntriesDL++;
							j=0;
							while(lpRowSetDL->aRow[0].lpProps[j].ulPropTag != PR_ENTRYID )
								if (++j >= (int) lpRowSetDL->aRow[0].cValues)
								{
									LUIOut( L2, "Didn't find PR_ENTRYID in the row!" );
									retval=FALSE;
									goto out;
								}
							cbDLEid = lpRowSetDL->aRow[0].lpProps[j].Value.bin.cb;
							lpDLEid = (LPENTRYID)lpRowSetDL->aRow[0].lpProps[j].Value.bin.lpb;
							assert(lpDLEid != NULL);
							//d lpDLUser = NULL;
							//d assert(lpDLUser == NULL);
							assert(lpDLCont != NULL);
						
							hr = lpDLCont->OpenEntry(
									 IN	 cbDLEid,
									 IN	 lpDLEid,
									 IN	 NULL,              //default interface
									 IN	 MAPI_BEST_ACCESS,  //flags
									 OUT &ulObjType,
									 OUT (LPUNKNOWN *) &lpDLUser);

						if (HR_FAILED(hr)) {
							LUIOut(L2,"OpenEntry Failed");
							retval=FALSE;
							goto out;
						}
						else
						{
							assert(lpSPropValueDL == NULL);
							//LUIOut( L2,"OpenEntry on EntryID for User Passed" );
						assert(lpDLUser != NULL);
						
						hr = lpDLUser->GetProps(
								IN (LPSPropTagArray) &SPTTagArray,
								IN  0,
								OUT &cValues,
								OUT &lpSPropValueDL);


					    if ((HR_FAILED(hr))||(PropError(lpSPropValueDL->ulPropTag, cValues))) {
							assert( lpSPropValueDL == NULL);
							LUIOut( L3,"GetProps on User Object failed" );
						}
						else {
							LUIOut(L3,"Entry Name: %s",lpSPropValueDL->Value.LPSZ);
							assert( lpSPropValueDL != NULL);
							if (lpSPropValueDL) {
								MAPIFreeBuffer(lpSPropValueDL);
								lpSPropValueDL = NULL;
							}
							assert( lpSPropValueDL == NULL);
							
						}
						}
						if (lpRowSetDL) {
							FreeProws( lpRowSetDL );
							lpRowSetDL = NULL;
						}
						assert( lpRowSetDL == NULL);
						if(lpDLUser) {
							lpDLUser->Release();	
							lpDLUser = NULL;
						}
			/* */		}
				
					else  // no more rows in table
					{
						//Free Row
						if (lpRowSetDL) {
							FreeProws(lpRowSetDL);
							lpRowSetDL = NULL;
						}
						assert( lpRowSetDL == NULL);
						break;
					}
					if(ulEntriesDL == 50)  // we only handle the first 50 entries otherwise this would take forever
						break;
				assert(lpRowSetDL == NULL);
				//***//
				}		
				if (lpDLCont)
					lpDLCont->Release();
				lpDLCont = NULL;
				
				assert(lpRowSetDL == NULL);
				if (lpDLContentsTable)
					lpDLContentsTable->Release();
				lpDLContentsTable = NULL;
			}
			}
			//Free Row
			if (lpRowSet) {
				FreeProws(lpRowSet);
				lpRowSet = NULL;
			}
			assert( lpRowSet == NULL);
			
			
		}
		else  // no more rows in table
		{
			//Free Row
			if (lpRowSet) {
				FreeProws(lpRowSet);
				lpRowSet = NULL;
			}
			assert( lpRowSet == NULL);
						
			break;
		}

		if(ulEntries == 50)  // we only handle the first 50 entries otherwise this would take forever
			break;
	assert(lpRowSet == NULL);	
	assert(lpRowSetDL == NULL);
	assert(lpContentsTable != NULL);
	
	if(lpUser) {
		lpUser->Release();
		lpUser = NULL;
	}
}//while
	
	assert(lpRowSet == NULL);
	assert(lpRowSetDL == NULL);
	LUIOut(L2,"Total Entries: %d", ulEntries);

	if (HR_FAILED(hr)){
			LUIOut(L2,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}		
	
out:
		
		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpSPropValueDL)
			MAPIFreeBuffer(lpSPropValueDL);

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpDLContentsTable)
			lpDLContentsTable->Release();

		if (lpPABCont)
				lpPABCont->Release();
		
		if (lpDLCont)
				lpDLCont->Release();

		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL ClearPab(int bMAILUSERS)
{
// Clear PAB of all the entries. If bMailUsers flag is TRUE,
//	then only clear MAILUSERS, else clear everything.


    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
    //char   szDispName[BIG_BUF];

	ULONG       cValues         = 0;
	//int cEntriesToDelete;
	int i=0,k=0;
	//char szEntryTag[SML_BUF];
	//char szTagBuf[SML_BUF];
	
    ULONG   cRows           = 0;
    ULONG   iEntry          = 0;

    LPMAPITABLE lpContentsTable = NULL;

    LPSRowSet   lpRowSet    = NULL;

    SPropValue   PropValue      = {0};
    LPSPropValue lpSPropValue   = NULL;

	SizedSPropTagArray(3, Cols) = { 3, {PR_DISPLAY_NAME, PR_ENTRYID, PR_OBJECT_TYPE } };

	LPENTRYLIST	lpEntryList=NULL;
	ULONG     cbEid=0;
	LPENTRYID lpEid=NULL;
	LPVOID *lpEid2=NULL;
	
	LUIOut(L1," ");
	if (bMAILUSERS) {
		LUIOut(L1,"Running DeleteUsersOnly");
		LUIOut(L2,"-> Deletes mail users Only (not distribution lists) from the PAB");
		LUIOut(L1," ");
	}
	else {
		LUIOut(L1,"Running Delete All Entries");
		LUIOut(L2,"-> Clears the PAB");
		LUIOut(L1," ");
	}

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
		 		 		
	// OpenPAB

	 hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	 if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	 }
	//
    // Get the Contents Table for the PAB container
    //
    hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"GetContentsTable: Failed");
        goto out;
	}

    //
    // Only interested in 2 columns:
    // PR_DISPLAY_NAME and PR_ENTRYID
    //
    hr = lpContentsTable->SetColumns(IN  (LPSPropTagArray) &Cols,
                                IN  0);

    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetColumns Failed");
		retval = FALSE;
        goto out;
	}

    // Query and delete 1 row at a time
    do
	{
		hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet);
		if (HR_FAILED(hr)){
			LUIOut(L3,"QueryRows Failed");
			retval = FALSE;
			goto out;
		}
			
		cRows = lpRowSet->cRows;
		for (iEntry = 0; iEntry < cRows; iEntry++)
		{
			//
			//  For each entry, process it.
			//
			lpSPropValue = lpRowSet->aRow[iEntry].lpProps;
		    if (lpSPropValue[1].ulPropTag == PR_ENTRYID)
			{
				// don't delete this since it is not a mail user
				//
				if ((!bMAILUSERS) || (bMAILUSERS &&(lpSPropValue[2].ulPropTag == PR_OBJECT_TYPE)
					&& (lpSPropValue[2].Value.ul == MAPI_MAILUSER))) {
				
    	    		cbEid = lpSPropValue[1].Value.bin.cb;
					lpEid = (LPENTRYID) lpSPropValue[1].Value.bin.lpb;
					
					hr = HrCreateEntryListFromID(lpLocalWABObject,    IN  cbEid,
													IN  lpEid,
													OUT &lpEntryList);
					if (HR_FAILED(hr)) {
							LUIOut(L3,"Could not Create Entry List");
							retval=FALSE;
							goto out;
					}
					//
					// Then pass the lpEntryList to DeleteEntries to delete ...
					//
					hr = lpPABCont->DeleteEntries(IN  lpEntryList,IN  0);

					if (HR_FAILED(hr)) {
							LUIOut(L3,"Could not Delete Entry %s", lpSPropValue[0].Value.LPSZ);
							retval=FALSE;
							goto out;
					} else 	LUIOut(L3,"Deleted Entry: %s", lpSPropValue[0].Value.LPSZ);
				}
			}

      }
	  if(lpRowSet) {
		    FreeProws(lpRowSet);
			lpRowSet = NULL;
	  }

		
  }while((0!=cRows) && (0==!(cbEid)));
		
  out:
        if(lpRowSet)
		    FreeProws(lpRowSet);		

		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpContentsTable)
			lpContentsTable->Release();

		if (lpEid)
			MAPIFreeBuffer(lpEid);

		if (lpPABCont)
				lpPABCont->Release();

		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL CreateOneOff()
{
    ULONG   ulFlags = 0;
    HRESULT hr      = hrSuccess;
    SCODE   sc      = SUCCESS_SUCCESS;
	int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
//	ULONG		  cbEidPAB = 0;
//	LPENTRYID	  lpEidPAB   = NULL;
	ULONG     cbEid=0, cValues;
	LPENTRYID lpEid=NULL;
	ULONG   ulObjType=NULL;	
	LPMAILUSER	lpUser=NULL;
	char   szDispName[BIG_BUF];
	char   szAddressType[BIG_BUF];
	char   szEmailAddress[BIG_BUF];

	LPSPropValue lpSPropValue = NULL;
	SizedSPropTagArray(5,SPTTagArray) = {5, {PR_DISPLAY_NAME,
		PR_ADDRTYPE, PR_EMAIL_ADDRESS,
		PR_OBJECT_TYPE,PR_ENTRYID} };

	LUIOut(L1," ");
	LUIOut(L1,"Running CreateOneOff");
		LUIOut(L2,"-> Creates a one off entry as specified, in the PAB");
		LUIOut(L3,"And then verifies the properties of the entry created");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	// Get the details of the Entry to Create from INI file
	GetPrivateProfileString("CreateOneOff","Name","",szDispName,BIG_BUF,INIFILENAME);
	GetPrivateProfileString("CreateOneOff","AddressType","",szAddressType,BIG_BUF,INIFILENAME);
	GetPrivateProfileString("CreateOneOff","EmailAddress","",szEmailAddress,BIG_BUF,INIFILENAME);
	
	hr = lpAdrBook->CreateOneOff(szDispName,szAddressType,szEmailAddress,NULL,&cbEid,&lpEid);

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"CreateOneOff Failed");
			 retval=FALSE;
			 goto out;
	}
	//Verification
		hr = lpAdrBook->OpenEntry(IN cbEid, IN lpEid, IN NULL, MAPI_BEST_ACCESS,
			OUT & ulObjType,(LPUNKNOWN *) &lpUser);
	
		if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenEntry Failed");
			 retval=FALSE;
			 goto out;
		} else LUIOut(L2,"OpenEntry Succeeded");
		
		hr = lpUser->GetProps(
                    IN (LPSPropTagArray) &SPTTagArray,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValue);

	    if ((HR_FAILED(hr))||(PropError(lpSPropValue->ulPropTag, cValues))) {

					LUIOut( L2,"GetProps on User Object failed" );
		else {
			LUIOut(L2,"Entry Name: %s",(lpSPropValue[0]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[0]).Value.LPSZ, (LPSTR)szDispName))
				retval = FALSE;
			LUIOut(L2,"AddressType: %s",(lpSPropValue[1]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[1]).Value.LPSZ, (LPSTR)szAddressType))
				retval = FALSE;
			LUIOut(L2,"EmailAddress: %s",(lpSPropValue[2]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[2]).Value.LPSZ, (LPSTR)szEmailAddress))
				retval = FALSE;
			LUIOut(L2,"ObjectType: %0x",(lpSPropValue[3]).Value.ul);
			if ((lpSPropValue[3]).Value.ul  != MAPI_MAILUSER)
				retval = FALSE;
		}	
				
out:
		
		if (lpSPropValue)
			MAPIFreeBuffer(lpSPropValue);

		if (lpEid)
			MAPIFreeBuffer(lpEid);
	
		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL PABResolveName()
{
	HRESULT hr      = hrSuccess;
    int		retval=TRUE;
#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	ULONG cEntries=0;
	LPADRLIST lpAdrList = NULL, lpAdrListNew = NULL;
	int temp1=0, temp2 =0, temp3=0, temp4=0;
	char szResName[10][BIG_BUF];
	int i = 0;

	
	LUIOut(L1," ");
	LUIOut(L1,"Running ResolveName");
		LUIOut(L2,"-> Does Name Resolution Tests on PAB");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	
	cEntries = 1;
	GetPrivateProfileString("ResolveName","ResName1","",szResName[0],BIG_BUF,INIFILENAME);
	LUIOut(L2,"Step1: Resolve unresolved name");
	LUIOut(L3,"Name to resolve: %s",szResName[0]);
	temp1 = sizeof(ADRLIST) + cEntries*(sizeof(ADRENTRY));
	temp2 = CbNewADRLIST(cEntries);

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList );
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->dwAlignPad = 0;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[0];

	hr = lpAdrBook->ResolveName((ULONG)GetActiveWindow(), MAPI_DIALOG, NULL, lpAdrList);

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL4,"ResolveName Failed for %s",lpAdrList->aEntries[0].rgPropVals->Value.LPSZ);
			 retval=FALSE;
			 goto out;
	}
	else LUIOut(LPASS4,"Resolved successfully");

	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}


	LUIOut(L2,"Step2: Resolve the previously resolved name");

	hr = lpAdrBook->ResolveName(0, 0, NULL, lpAdrList);

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL4,"ResolveName Failed for %s",lpAdrList->aEntries[0].rgPropVals->Value.LPSZ);
			 retval=FALSE;
			 goto out;
	}
	else LUIOut(LPASS4,"Resolved successfully");

	LUIOut(L4,"Validate the returned PropList");

	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}
	
	MAPIFreeBuffer( lpAdrList->aEntries[0].rgPropVals );
	MAPIFreeBuffer( lpAdrList );
	lpAdrList = NULL;
	
	LUIOut(L2,"Step3: Resolve  mixed names");
	LUIOut(L2,"->prev. resolved and unresolved");

	LUIOut(L3,"Step3a: Resolve following unresolved names: ");

	GetPrivateProfileString("ResolveName","ResName2","",szResName[1],BIG_BUF,INIFILENAME);
	GetPrivateProfileString("ResolveName","ResName3","",szResName[2],BIG_BUF,INIFILENAME);
	GetPrivateProfileString("ResolveName","ResName4","",szResName[3],BIG_BUF,INIFILENAME);

	LUIOut(L4,"%s",szResName[1]);
	LUIOut(L4,"%s",szResName[2]);
	LUIOut(L4,"%s",szResName[3]);

	cEntries = 3;

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList );
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[1].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[2].rgPropVals));

	lpAdrList->cEntries = cEntries;
	// Name 1
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[1];
	// Name 2
	lpAdrList->aEntries[1].cValues = 1;
	lpAdrList->aEntries[1].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[1].rgPropVals->Value.LPSZ = szResName[2];
	// Name 3
	lpAdrList->aEntries[2].cValues = 1;
	lpAdrList->aEntries[2].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[2].rgPropVals->Value.LPSZ = szResName[3];

	if(HR_FAILED(lpAdrBook->ResolveName((ULONG)GetActiveWindow(), MAPI_DIALOG, NULL, lpAdrList))) {
		LUIOut( LFAIL4, "ResolveName failed for unresolved names" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName passed for unresolved names." );

	//Validate the AdrList
	LUIOut(L4,"Validate the returned PropList");
	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}

	// Now add two unresolved names to the AdrList
	LUIOut(L4,"Step3b: Add the following unresolved names to the list: ");

	GetPrivateProfileString("ResolveName","ResName5","",szResName[4],BIG_BUF,INIFILENAME);
	GetPrivateProfileString("ResolveName","ResName6","",szResName[5],BIG_BUF,INIFILENAME);
	LUIOut(L4,"%s",szResName[4]);
	LUIOut(L4,"%s",szResName[5]);

	cEntries = 5;
	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrListNew);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrListNew->aEntries[1].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrListNew->aEntries[3].rgPropVals));
	
	lpAdrListNew->cEntries = cEntries;

	// Name 2
	lpAdrListNew->aEntries[1].cValues = 1;
	lpAdrListNew->aEntries[1].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrListNew->aEntries[1].rgPropVals->Value.LPSZ = szResName[4];

	// Name 4
	lpAdrListNew->aEntries[3].cValues = 1;
	lpAdrListNew->aEntries[3].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrListNew->aEntries[3].rgPropVals->Value.LPSZ = szResName[5];

	lpAdrListNew->aEntries[0] = lpAdrList->aEntries[0];
	lpAdrListNew->aEntries[2] = lpAdrList->aEntries[1];
	lpAdrListNew->aEntries[4] = lpAdrList->aEntries[2];

	MAPIFreeBuffer(lpAdrList);
	lpAdrList = NULL;

	lpAdrList = lpAdrListNew;

	// call ResolveName() w/ a mix of resolved and unresolved.

	if(HR_FAILED(lpAdrBook->ResolveName((ULONG) GetActiveWindow(), MAPI_DIALOG, NULL, lpAdrList)))
	{
		LUIOut( LFAIL4, "ResolveName failed with resolved and unresolved names" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName passed with resolved and unresolved names" );

	//Validate the AdrList
	LUIOut(L4,"Validate the returned PropList");
	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}

	for(i=0; i<(int) cEntries; ++i)
		MAPIFreeBuffer(lpAdrList->aEntries[i].rgPropVals);

	MAPIFreeBuffer(lpAdrList );
	lpAdrList = NULL;

	GetPrivateProfileString("ResolveName","NonExistentName","",szResName[6],BIG_BUF,INIFILENAME);
	LUIOut(L3,"Step 4: Resolve non existent name");
	LUIOut(L3,"Name: %s",szResName[6]);

	//call ResolveName() with a non-existant name
	cEntries = 1;

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));


	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[6];
	
	if(lpAdrBook->ResolveName(0,0, NULL,lpAdrList)	!= MAPI_E_NOT_FOUND)
	{
		LUIOut( LFAIL4, "ResolveName did not return NOT FOUND" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName correctly returned MAPI_E_NOT_FOUND." );

	MAPIFreeBuffer(lpAdrList->aEntries[0].rgPropVals );
	MAPIFreeBuffer(lpAdrList );
	lpAdrList = NULL;

	//call ResolveName() w/ just the ambiguous name
	cEntries = 1;
	GetPrivateProfileString("ResolveName","AmbigousName","",szResName[7],BIG_BUF,INIFILENAME);
	LUIOut(L2,"Step5: Resolve ambigous name");
	LUIOut(L3,"Name: %s",szResName[7]);

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[7];

	if (hr = lpAdrBook->ResolveName((ULONG)GetActiveWindow(),MAPI_DIALOG, NULL, lpAdrList)
		&&( hr != MAPI_E_AMBIGUOUS_RECIP)) {
		LUIOut(LFAIL4, "ResolveName failed for name that was not specific enough");
		retval = FALSE;
		goto out;
	}
	else LUIOut(LPASS4,"ResolveName correctly returned MAPI_E_AMBUGUOUS_RECIP." );

	MAPIFreeBuffer(lpAdrList->aEntries[0].rgPropVals);
	MAPIFreeBuffer(lpAdrList);
	lpAdrList = NULL;

	//Resolves name using the oneoff provider
	cEntries = 1;
	GetPrivateProfileString("ResolveName","OneOffAddress","",szResName[8],BIG_BUF,INIFILENAME);
	LUIOut(L2,"Resolve OneOff Name");
	LUIOut(L3,"OneOff Address: %s",szResName[8]);

	MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList);
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_DISPLAY_NAME;
	lpAdrList->aEntries[0].rgPropVals->Value.LPSZ = szResName[8];

	if(HR_FAILED(lpAdrBook->ResolveName(0,0, NULL, lpAdrList)))
	{
		LUIOut( LFAIL4, "ResolveName failed for OneOffAddress" );
		retval = FALSE;
		goto out;
	}
	LUIOut( LPASS4, "ResolveName passed for OneOffAddress" );

	//Validate the AdrList
	LUIOut(L4,"Validate the returned PropList");
	if (ValidateAdrList(lpAdrList, cEntries))
		LUIOut(LPASS4,"Validation passed");
	else {
		LUIOut(LFAIL4,"Validation unsuccessful");
		retval = FALSE;
	}

	MAPIFreeBuffer(lpAdrList->aEntries[0].rgPropVals);

	MAPIFreeBuffer(lpAdrList );
	lpAdrList = NULL;
	
	cEntries = 0;
out:
		if (cEntries > 0)
			for (i=0;i<(int)cEntries; i++) {
				MAPIFreeBuffer( lpAdrList->aEntries[i].rgPropVals );
		}
		
		if (lpAdrList) {
			MAPIFreeBuffer( lpAdrList );
			lpAdrList = NULL;
		}

		if (lpAdrBook)
			  lpAdrBook->Release();

		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}


BOOL PABSetProps()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

	int i=0;
	int bFound = FALSE;

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	SPropValue  PropValue[3];
	LPSPropValue lpSPropValue = NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
	LPABCONT	  lpPABCont= NULL;
	LPMAILUSER	lpUser=NULL;
	LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpRowSet    = NULL;
	ULONG     cbEid=0, cValues;
	LPENTRYID lpEid=NULL;
	ULONG   ulObjType=NULL;	
	char szLocation[SML_BUF],szComment[SML_BUF];

	SizedSPropTagArray(3,SPTTagArray) = {3, {PR_DISPLAY_NAME,
	PR_OFFICE_LOCATION, PR_COMMENT} };


	LUIOut(L1," ");
	LUIOut(L1,"Running SetProps");
	LUIOut(L2,"-> Sets properties on a MailUser in the PAB");
	LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}
	
	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}
	
	if(!OpenPABID(IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType))
	{
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	assert(lpPABCont != NULL);
	assert(lpContentsTable == NULL);
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);

    if (HR_FAILED(hr)) {
		LUIOut(L2,"GetContentsTable: Failed");
		retval=FALSE;
		goto out;
	}
	assert(lpContentsTable != NULL);
	assert(lpRowSet == NULL);	
	while((bFound == FALSE) &&(!HR_FAILED(hr = lpContentsTable->QueryRows(IN  1,
								IN  0,
							    OUT &lpRowSet)))) {
		
	if (lpRowSet->cRows) {
		i=0;
		assert(lpRowSet != NULL);
		while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_OBJECT_TYPE)
			if (++i >= (int) lpRowSet->aRow[0].cValues)
			{
				LUIOut( L2, "PR_OBJECT_TYPE not found in the row!" );
				retval = FALSE;
				goto out;
			}

		if(lpRowSet->aRow[0].lpProps[i].Value.ul == MAPI_MAILUSER)
			bFound = TRUE;
		else
		{
			FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
	}
	else  {
		LUIOut(LFAIL2,"No Mail User Entry found in the PAB");
		retval = FALSE;
		if (lpRowSet) {
				FreeProws(lpRowSet);
				lpRowSet = NULL;
			}
			assert( lpRowSet == NULL);
			goto out;
	}
}

// check for QueryRows() errors
if (HR_FAILED(hr)){
			LUIOut(L2,"QueryRows Failed");
			retval = FALSE;
			goto out;
}
if (bFound) {
	i=0;
	assert(lpRowSet != NULL);
	while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_ENTRYID)
		if (++i >= (int) lpRowSet->aRow[0].cValues)
		{
			LUIOut( L2, "PR_ENTRYID not found in the row!" );
			retval = FALSE;
			goto out;
		}

	cbEid = lpRowSet->aRow[0].lpProps[i].Value.bin.cb;
	lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[i].Value.bin.lpb;
	
	assert(lpAdrBook != NULL);
	assert(lpUser == NULL);
	hr = lpAdrBook->OpenEntry(cbEid, lpEid, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpUser);
	if (HR_FAILED(hr)) {
		LUIOut(LFAIL2, "OpenEntry with modify flag on first MailUser failed");
		retval = FALSE;
		goto out;
	}
	else LUIOut(LPASS2,"OpenEntry with modify flag on first MailUser passed");
	GetPrivateProfileString("SetProps","Location","",szLocation,SML_BUF,szIniFile);
	GetPrivateProfileString("SetProps","Comment","",szComment,SML_BUF,szIniFile);
	cValues = 2;
	PropValue[0].ulPropTag  = PR_OFFICE_LOCATION;
    PropValue[1].ulPropTag  = PR_COMMENT;
   	PropValue[0].Value.LPSZ = (LPTSTR)szLocation;
	PropValue[1].Value.LPSZ = (LPTSTR)szComment;

	assert(lpUser != NULL);
	hr = lpUser->SetProps(IN  cValues,
                          IN  PropValue,
                          IN  NULL);
		
    if (HR_FAILED(hr)) {
			LUIOut(LFAIL2,"SetProps failed for the MailUser");
		 	retval=FALSE;			
			goto out;
	}
	assert(lpUser != NULL);
    hr = lpUser->SaveChanges(IN  KEEP_OPEN_READWRITE);
	if (HR_FAILED(hr)) {
			LUIOut(LFAIL2,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
	}
	else LUIOut(LPASS2,"Savechanges passed for the properties on the MailUser in PAB");
	assert(lpUser != NULL);
	assert(lpSPropValue == NULL);
	hr = lpUser->GetProps(
                    IN (LPSPropTagArray) &SPTTagArray,
                    IN  0,
                    OUT &cValues,
                    OUT &lpSPropValue);

    if ((HR_FAILED(hr))||(PropError(lpSPropValue->ulPropTag, cValues))) {

		LUIOut( L2,"GetProps on Mail User failed" );
		retval = FALSE;
		goto out;
	}
	else {
			LUIOut(L2,"Verification of Properties set");
			LUIOut(L3,"Entry Name: %s",(lpSPropValue[0]).Value.LPSZ);
			LUIOut(L3,"Location: %s",(lpSPropValue[1]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[1]).Value.LPSZ, (LPSTR)szLocation))
				retval = FALSE;
			LUIOut(L3,"Comment: %s",(lpSPropValue[2]).Value.LPSZ);
			if (lstrcmpi((lpSPropValue[2]).Value.LPSZ, (LPSTR)szComment))
				retval = FALSE;
	}	
	assert(lpUser != NULL);
	hr = lpUser->SaveChanges(IN  KEEP_OPEN_READWRITE);
	if (HR_FAILED(hr)) {
			LUIOut(LFAIL2,"SaveChanges, without changes, failed on Mail User in PAB");
			retval=FALSE;
            goto out;
	}
	else LUIOut(LPASS2,"SaveChanges, without changes, passed on Mail User in PAB");
}
else {
	LUIOut(LPASS2,"No Mail User Entry found in the PAB to set the properties");
	retval = FALSE;
}

out:		
	if (lpSPropValue)
		MAPIFreeBuffer(lpSPropValue);
	//if (lpEid)
	//	MAPIFreeBuffer(lpEid);
	if (lpContentsTable)
		lpContentsTable->Release();
	if (lpPABCont)
				lpPABCont->Release();
	if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
	if(lpRowSet)
			FreeProws(lpRowSet);
	if(lpUser)
		lpUser->Release();
	if (lpAdrBook)
		  lpAdrBook->Release();
	if (lpMAPISession)
		  lpMAPISession->Release();
	MAPIUninitialize();
#endif
	return retval;
}

BOOL PABQueryInterface()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

	int i=0;

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
	LPABCONT	  lpABCont= NULL, lpABCont2= NULL;
	LPABCONT	  lpPABCont= NULL,lpPABCont2= NULL;
	LPMAILUSER	lpUser=NULL, lpUser2=NULL;
	LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpRowSet    = NULL;
	ULONG     cbEid=0;
	LPENTRYID lpEid=NULL;
	ULONG   ulObjType=NULL;	
	
	LUIOut(L1," ");
	LUIOut(L1,"Running QueryInterface");
	LUIOut(L2,"-> Calls QueryInterface on all objects in the PAB");
	LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}
	
	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	assert(lpAdrBook != NULL);
	hr = lpAdrBook->OpenEntry(0, NULL, NULL,MAPI_MODIFY,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (!(retval = LogIt(hr,2, "OpenEntry on AddressBook")))
		goto out;
	
	if (ulObjType != MAPI_ABCONT) {
		LUIOut(LFAIL2, "Object type is not MAPI_ABCONT");
		retval = FALSE;
		goto out;
	}
	LUIOut(LPASS2, "Object type is MAPI_ABCONT");
	
	hr = (lpABCont->QueryInterface((REFIID)(IID_IUnknown), (VOID **) &lpABCont2));
	if (!(retval = LogIt(hr,2, "QueryInterface on the Root Container")))
		goto out;

	if(lpABCont2)
		(LPUNKNOWN)(lpABCont2)->Release();
	else {
		LUIOut(LFAIL2, "QueryInterface failed on the Root Container");
		retval = FALSE;
	}
	lpABCont2 = NULL;

	if(!OpenPABID(IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType))
	{
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	hr = (lpPABCont->QueryInterface((REFIID)(IID_IUnknown), (VOID **) &lpPABCont2));
	if (!(retval = LogIt(hr,2, "QueryInterface on the PAB Container")))
		goto out;

	if(lpPABCont2)
		(LPUNKNOWN)(lpPABCont2)->Release();
	else {
		LUIOut(LFAIL2, "QueryInterface failed on the Root Container");
		retval = FALSE;
	}
	lpPABCont2 = NULL;
	
	// Now open the PAB and get a user and do QueryInterface on the User
	hr = lpPABCont->GetContentsTable( IN  0,          //Flags
                                OUT &lpContentsTable);
	
    if (HR_FAILED(hr)) {
		LUIOut(LFAIL2,"GetContentsTable: Failed");
		retval=FALSE;
		goto out;
	}
	assert(lpContentsTable != NULL);
	assert(lpRowSet == NULL);	
	hr = lpContentsTable->QueryRows(1, 0, OUT &lpRowSet);
	if (!(retval = LogIt(hr,2, "QueryRows on the PAB Container")))
		goto out;

	if (lpRowSet->cRows) {
		i=0;
		while(lpRowSet->aRow[0].lpProps[i].ulPropTag != PR_ENTRYID )
			if (++i >= (int) lpRowSet->aRow[0].cValues)
			{
				LUIOut(LFAIL2,"PR_ENTRYID not found in the row!" );
				retval = FALSE;
				goto out;
			}
		cbEid = lpRowSet->aRow[0].lpProps[i].Value.bin.cb;
		lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[i].Value.bin.lpb;

		hr = lpPABCont->OpenEntry(cbEid, lpEid, NULL, 0, &ulObjType,(LPUNKNOWN *)&lpUser);
		if (!(retval = LogIt(hr,2, "OpenEntry on EntryID for PAB Entry")))
			goto out;

		FreeProws(lpRowSet);
		lpRowSet = NULL;

		hr = lpUser->QueryInterface(IID_IUnknown, (VOID **) &lpUser2);
		if (!(retval = LogIt(hr,2, "QueryInterface on an Entry in PAB")))
			goto out;

		if(lpUser2)
			(LPUNKNOWN)(lpUser2)->Release();
		else {
			LUIOut(LFAIL2, "QueryInterface failed on an Entry in PAB");
			retval = FALSE;
		}
		lpUser2 = NULL;
	}
	else {
		LUIOut(LFAIL2, "No Entries found in the PAB");
		retval = FALSE;
		goto out;
	}

out:		
	if (lpABCont)
		lpABCont->Release();
	if (lpABCont2)
		lpABCont2->Release();
	if (lpPABCont)
		lpPABCont->Release();
	if (lpPABCont2)
		lpPABCont2->Release();
	if (lpEid)
		MAPIFreeBuffer(lpEid);
	if (lpContentsTable)
		lpContentsTable->Release();
	if (lpEidPAB)
			MAPIFreeBuffer(lpEidPAB);
	if(lpRowSet)
			FreeProws(lpRowSet);
	if(lpUser)
		lpUser->Release();
	if(lpUser2)
		lpUser2->Release();
	if (lpAdrBook)
		  lpAdrBook->Release();
	if (lpMAPISession)
		  lpMAPISession->Release();
	MAPIUninitialize();
#endif
	return retval;
}

BOOL PABPrepareRecips()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL;
	ULONG cEntries=0;
	LPADRLIST lpAdrList = NULL;
	char   EntProp[10][BIG_BUF];
	ULONG		  cbEidPAB = 0;
	LPENTRYID	  lpEidPAB   = NULL;
	LPSPropValue lpSPropValueAddress = NULL;
	LPSPropTagArray lpPropTagArray = NULL;
	LPMAILUSER  lpAddress   = NULL;
	SPropValue  PropValue[3]    = {0};
	SizedSPropTagArray(1,SPTArrayAddress) = {1, {PR_DEF_CREATE_MAILUSER} };
	char szEntryTag[SML_BUF],EntryBuf[MAX_BUF];
	int i = 0,j=0, cPropCount=0;
	ULONG     cbEid=0, cbUserEid=0, cValues;
	LPENTRYID lpEid = NULL, lpUserEid = NULL;

	
	LUIOut(L1," ");
	LUIOut(L1,"Running PrepareRecips");
		LUIOut(L2,"-> Does Prepare Recipients Test on PAB");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}

	LUIOut(L2,"Create a User Entry in PAB");
	hr = lpPABCont->GetProps(  IN  (LPSPropTagArray) &SPTArrayAddress,
                                IN  0,      //Flags
                                OUT &cValues,
                                OUT &lpSPropValueAddress);

    if ((HR_FAILED(hr))||(PropError(lpSPropValueAddress->ulPropTag, cValues))) {
				LUIOut(L3,"GetProps failed for Default template");
		 		retval=FALSE;			
				goto out;
	}
	cbUserEid = lpSPropValueAddress->Value.bin.cb;
	if ( !MAPIAllocateBuffer(cbUserEid, (LPVOID *)&lpUserEid)) {						
          CopyMemory(lpUserEid, (LPENTRYID) lpSPropValueAddress->Value.bin.lpb, cbUserEid);
	}
	else {
		retval = FALSE;
		LUIOut(LFAIL3," MAPIAllocateBuffer failed");
		goto out;
	}
	
       // The returned value of PR_DEF_CREATE_MAILUSER is an
       // EntryID which one can pass to CreateEntry
       //
	
    hr = lpPABCont->CreateEntry(
                    IN  lpSPropValueAddress->Value.bin.cb,               //Template cbEid
                    IN  (LPENTRYID) lpSPropValueAddress->Value.bin.lpb,  //Template lpEid
                    IN  0,
                    OUT (LPMAPIPROP *) &lpAddress);

    if (HR_FAILED(hr)) {
				LUIOut(LFAIL3,"CreateEntry failed for PR_DEF_CREATE_MAILUSER");
		 		retval=FALSE;			
			    goto out;
	}
  //
  // Then set the properties
  //

	PropValue[0].ulPropTag  = PR_DISPLAY_NAME;
    PropValue[1].ulPropTag  = PR_ADDRTYPE;
	PropValue[2].ulPropTag  = PR_EMAIL_ADDRESS;

	cValues = 3; //# of props we are setting
	lstrcpy((LPSTR)szEntryTag,"CreateUserAddress");
	// Addresses are comma delimited and enclosed in quotes
	GetPrivateProfileString("PrepareRecips",szEntryTag,"",EntryBuf,MAX_BUF,INIFILENAME);
	GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
	
	LUIOut(L3,"Entry to Create: %s",EntProp[0]);
	
	for (i=0; i<(int)cValues;i++)
		PropValue[i].Value.LPSZ = (LPTSTR)EntProp[i];
    hr = lpAddress->SetProps(IN  cValues,
                               IN  PropValue,
                               IN  NULL);
	
    if (HR_FAILED(hr)) {
		LUIOut(L3,"SetProps failed for %s",PropValue[0].Value.LPSZ);
		 	retval=FALSE;			
			goto out;
	}
	hr = lpAddress->SaveChanges(IN  KEEP_OPEN_READWRITE); //flags

   if (HR_FAILED(hr)) {
			LUIOut(L3,"SaveChanges failed for SetProps");
			retval=FALSE;
            goto out;
   }
   else LUIOut(LPASS3,"Entry Added to PAB");

   LUIOut(L2,"Create a OneOff Entry in PAB");
   // Create a oneoff user
   cValues = 3;
   lstrcpy((LPSTR)szEntryTag,"CreateOneOffAddress");
   GetPrivateProfileString("PrepareRecips",szEntryTag,"",EntryBuf,MAX_BUF,INIFILENAME);
   GetPropsFromIniBufEntry(EntryBuf,cValues,EntProp);
   LUIOut(L3,"Entry to Create: %s",EntProp[0]);
   hr = lpAdrBook->CreateOneOff(EntProp[0],EntProp[1],EntProp[2],NULL,&cbEid,&lpEid);

   if (HR_FAILED(hr)) {		
	   LUIOut(LFAIL3,"CreateOneOff");
			 retval=FALSE;
			 goto out;
   }
   else LUIOut(LPASS3,"CreateOneOff");

   LUIOut(L2,"Call PrepareRecips on these two entries in the PAB");
    cEntries = 2;
    MAPIAllocateBuffer(CbNewADRLIST(cEntries), (LPVOID *) &lpAdrList );
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[0].rgPropVals));
	MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *) &(lpAdrList->aEntries[1].rgPropVals));
	
	lpAdrList->cEntries = cEntries;
	lpAdrList->aEntries[0].cValues = 1;
	lpAdrList->aEntries[0].rgPropVals->ulPropTag = PR_ENTRYID;
	lpAdrList->aEntries[0].rgPropVals->dwAlignPad = 0;
	lpAdrList->aEntries[0].rgPropVals->Value.bin.cb = cbUserEid;
	lpAdrList->aEntries[0].rgPropVals->Value.bin.lpb = (LPBYTE) lpUserEid;
	
	lpAdrList->aEntries[1].cValues = 1;
	lpAdrList->aEntries[1].rgPropVals->ulPropTag = PR_ENTRYID;
	lpAdrList->aEntries[1].rgPropVals->dwAlignPad = 0;
	lpAdrList->aEntries[1].rgPropVals->Value.bin.cb = cbEid;
	lpAdrList->aEntries[1].rgPropVals->Value.bin.lpb = (LPBYTE) lpEid;

	cPropCount = 8;
	MAPIAllocateBuffer( CbNewSPropTagArray(cPropCount), (void **)&lpPropTagArray );
	lpPropTagArray->cValues = cPropCount;
	lpPropTagArray->aulPropTag[0] = PR_DISPLAY_NAME;
	lpPropTagArray->aulPropTag[1] = PR_OBJECT_TYPE;
	lpPropTagArray->aulPropTag[2] = PR_ADDRTYPE;
	lpPropTagArray->aulPropTag[3] = PR_EMAIL_ADDRESS;
	lpPropTagArray->aulPropTag[4] = PR_DISPLAY_TYPE;
	lpPropTagArray->aulPropTag[5] = PR_CALLBACK_TELEPHONE_NUMBER;
	lpPropTagArray->aulPropTag[6] = PR_COMMENT;
	lpPropTagArray->aulPropTag[7] = PR_OFFICE_LOCATION;

	if( lpAdrBook->PrepareRecips( 0, lpPropTagArray, lpAdrList ) )
	{
		LUIOut(LFAIL3, "PrepareRecips failed" );
		retval = FALSE;
		goto out;
	}
	else LUIOut(LPASS3, "PrepareRecips passed" );

	if(lpAdrList->cEntries == 0 )
	{
		LUIOut(LFAIL3, "No entries were prepared" );
		retval = FALSE;
		goto out;
	}
	LUIOut(L2,"Verify the returned Properties");

	for ( i = 0; i < (int) cEntries; i++ ) {
		LUIOut(L3,"Entry #: %d",i);
		if (lpAdrList->aEntries[i].cValues != (ULONG)(cPropCount + 1)) {
			LUIOut(LFAIL4, "Number of returned properties is incorrect");
			retval = FALSE;
			goto out;
		}
		else LUIOut(LPASS4, "Number of returned properties is correct");
		for ( j = 0; j < cPropCount; j++ )	{
			if ( PROP_ID(lpAdrList->aEntries[i].rgPropVals[j].ulPropTag) !=
				PROP_ID(lpPropTagArray->aulPropTag[j])) {
				LUIOut(LFAIL4, "Property IDs do not match in the returned data");
				retval = FALSE;
				goto out;
			}
		}
		LUIOut(LPASS4, "All Property IDs match in the returned data");		
		if (lpAdrList->aEntries[i].rgPropVals[j].ulPropTag != PR_ENTRYID ) 	{
				LUIOut(LFAIL4, "Last Property Tag != PR_ENTRYID");
				retval = FALSE;
				goto out;
		} else 	LUIOut(LPASS4, "Last Property Tag == PR_ENTRYID");
				
	}

out:
		if (cEntries > 0)
			for (i=0;i<(int)cEntries; i++) {
				MAPIFreeBuffer( lpAdrList->aEntries[i].rgPropVals );
		}
		
		if (lpAdrList) {
			MAPIFreeBuffer( lpAdrList );
			lpAdrList = NULL;
		}
		if (lpPABCont)
				lpPABCont->Release();
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpSPropValueAddress)
			MAPIFreeBuffer(lpSPropValueAddress);
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpUserEid)
			MAPIFreeBuffer(lpUserEid);
		if (lpAddress)
			lpAddress->Release();
		if (lpPropTagArray)
			MAPIFreeBuffer(lpPropTagArray);
		if (lpAdrBook)
			  lpAdrBook->Release();
		if (lpMAPISession)
			  lpMAPISession->Release();

		MAPIUninitialize();
#endif
		return retval;
}

BOOL PABCopyEntries()
{

	HRESULT hr      = hrSuccess;
    int		retval=TRUE;

#ifdef PAB

	SizedSPropTagArray(2,SPTTagArray) = {2, {PR_DISPLAY_NAME, PR_ENTRYID } };
    LPMAPISESSION lpMAPISession   = NULL;
    LPADRBOOK	  lpAdrBook       = NULL;
	LPABCONT	  lpPABCont= NULL,lpABCont = NULL, lpABPCont = NULL;
	LPMAPITABLE lpABTable = NULL,lpABPTable= NULL;
    LPSRowSet   lpRowSet    = NULL, lpPRowSet = NULL;
	ULONG     cbEid = 0, cbEidPAB = 0;
	LPENTRYID lpEid = NULL, lpEidPAB = NULL;
	ULONG   ulObjType=NULL, ulSeed=0,ulMaxEntries = 0;	
	ULONG ulPRowCount=0, ulTotalCount=0;
	int idx=0;
	LONG lSeekRow=0,lRowsSeeked=0,lPRowsSeeked=0,lPSeekRow=0;
	LPENTRYLIST lpEntries= NULL;


	LUIOut(L1," ");
	LUIOut(L1,"Running CopyEntries");
		LUIOut(L2,"-> Copies Entries from other Providers into PAB");
		LUIOut(L1," ");

	if (!(MapiInitLogon(OUT &lpMAPISession))) {
		LUIOut(LFAIL2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT &lpAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(LFAIL2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	hr = OpenPABID(  IN lpAdrBook, OUT &cbEidPAB,
							OUT &lpEidPAB,OUT &lpPABCont, OUT &ulObjType);
						
	if (HR_FAILED(hr)) {
				LUIOut(L2,"OpenPABID Failed");
				LUIOut(L3,"Could not Open PAB");
		 		retval=FALSE;
				goto out;
	}
	assert(lpAdrBook != NULL);
	hr = lpAdrBook->OpenEntry(0, NULL, NULL,0,&ulObjType, (LPUNKNOWN *) &lpABCont);
	if (!(retval = LogIt(hr,2, "OpenEntry on Root Container AddressBook")))
		goto out;
	
	if (ulObjType != MAPI_ABCONT) {
		LUIOut(LFAIL2, "Object type is not MAPI_ABCONT");
		retval = FALSE;
		goto out;
	}
	LUIOut(LPASS2, "Object type is MAPI_ABCONT");
	
	hr = lpABCont->GetHierarchyTable(CONVENIENT_DEPTH,&lpABTable);
//	hr = lpABCont->GetHierarchyTable(0,&lpABTable);
	if (!(retval = LogIt(hr,2, "GetHierarchyTable on Root Container")))
		goto out;
	
	hr = lpABTable->GetRowCount(0,&ulTotalCount);
	if (!(retval = LogIt(hr,2, "GetRowCount on Root Container")))
		goto out;
	if (ulTotalCount == 0)
	{
		LUIOut(LFAIL2,"No rows in Root AddressBook table.");
		retval = FALSE;
		goto out;
	}

	hr = lpABTable->SetColumns(IN  (LPSPropTagArray) &SPTTagArray,
                                IN  0);
	if (!(retval = LogIt(hr,2, "SetColumns")))
		goto out;

	ulSeed = (unsigned)time( NULL );
	//LUIOut(LPASS3, "Random seed = %lu", ulSeed );
	srand(ulSeed);
	ulMaxEntries = GetPrivateProfileInt("CopyEntries","ulMaxEntries", 3, INIFILENAME);
	for(idx = 0; (idx < ((int)ulTotalCount) && (idx < (int) ulMaxEntries)); ++idx)
	{
		/* Generate a random number */
		/* Seek to that row */
		lSeekRow = idx;
		hr = lpABTable->SeekRow(BOOKMARK_BEGINNING, (LONG)lSeekRow,
					   &lRowsSeeked);
		if (!(retval = LogIt(hr,2, "SeekRow on Root Address Book Table")))
			goto out;
	
		hr = lpABTable->QueryRows(1, TBL_NOADVANCE, &lpRowSet);
		if (!(retval = LogIt(hr,2, "QueryRows on Root Address Book Table")))
			goto out;
		LUIOut(L3," # %d: Provider is %s",idx+1,lpRowSet->aRow[0].lpProps[0].Value.LPSZ);
		cbEid = lpRowSet->aRow[0].lpProps[1].Value.bin.cb;
		lpEid = (LPENTRYID)lpRowSet->aRow[0].lpProps[1].Value.bin.lpb;

		/* Open the entry */
		hr = lpAdrBook->OpenEntry(cbEid,lpEid, NULL, 0, &ulObjType,
					 OUT (LPUNKNOWN *) &lpABPCont);
		if (!(retval = LogIt(hr,4, "OpenEntry on an entry in the hierarchy table")))
			goto out;
		
		hr = lpABPCont->GetContentsTable(0, &lpABPTable);
		if (HR_FAILED(hr))
			goto directory;

		LUIOut(LPASS4,"GetContentsTable");
		
		hr = lpABPTable->GetRowCount(0, &ulPRowCount);
		if (!(retval = LogIt(hr,4, "GetRowCount on Provider table")))
			goto out;
		
		if(ulPRowCount > 0)
		{
			hr = lpABPTable->SetColumns(IN  (LPSPropTagArray) &SPTTagArray, 0);
			if (!(retval = LogIt(hr,4, "SetColumns on Provider table")))
			goto out;
	
			lPSeekRow = (rand() % ulPRowCount);
			hr = lpABPTable->SeekRow(BOOKMARK_BEGINNING, (LONG)lPSeekRow,
						&lPRowsSeeked);
			if (!(retval = LogIt(hr,4, "SeekRows on Provider table")))
			goto out;

			hr = lpABPTable->QueryRows(1, TBL_NOADVANCE, &lpPRowSet);
			if (!(retval = LogIt(hr,4, "QueryRows on Provider table")))
			goto out;

			if(!lpPRowSet->cRows)
				goto directory;
			else
			{
				LUIOut(L3,"Entry to Copy is %s",lpPRowSet->aRow[0].lpProps[0].Value.LPSZ);
		
				/* Copy the entry */
				int temp = sizeof(ENTRYLIST);
				MAPIAllocateBuffer(sizeof(ENTRYLIST),(LPVOID *)&lpEntries);
				if (lpEntries ) {
					lpEntries->cValues = 1;	
					lpEntries->lpbin = NULL;
					MAPIAllocateBuffer((sizeof(SBinary)*lpEntries->cValues),
								(LPVOID *) &(lpEntries->lpbin));
					if (lpEntries->lpbin) {
						lpEntries->lpbin->cb = lpPRowSet->aRow[0].lpProps[1].Value.bin.cb;
						lpEntries->lpbin->lpb = NULL;
						MAPIAllocateBuffer(lpPRowSet->aRow[0].lpProps[1].Value.bin.cb,
									(LPVOID *)&(lpEntries->lpbin->lpb));
						if (lpEntries->lpbin->lpb) {
					
							CopyMemory(lpEntries->lpbin->lpb,
								 lpPRowSet->aRow[0].lpProps[1].Value.bin.lpb,
								 (size_t)lpPRowSet->aRow[0].lpProps[1].Value.bin.cb);
						}
						else {
								LUIOut(LFAIL3,"MAPIAllocateBuffer" );
								retval = FALSE;
								goto out;
						}
					}	
					else {
								LUIOut(LFAIL3,"MAPIAllocateBuffer" );
								retval = FALSE;
								goto out;
					}
				}
				else {
								LUIOut(LFAIL3,"MAPIAllocateBuffer" );
								retval = FALSE;
								goto out;
				}
				
				/* Add to PAB */
				hr = lpPABCont->CopyEntries(lpEntries, (ULONG)GetActiveWindow(), NULL, CREATE_CHECK_DUP_STRICT);
				if (HR_FAILED(hr))
				{
					LUIOut(LFAIL3,"User could not be added to the PAB." );
					retval = FALSE;
					goto out;
				}
				LUIOut(LPASS3,"User was added to the PAB");
		
				/* Free the EntryList */
				
				MAPIFreeBuffer(lpEntries->lpbin->lpb);
				lpEntries->lpbin->lpb = NULL;
				MAPIFreeBuffer(lpEntries->lpbin);
				lpEntries->lpbin = NULL;
				MAPIFreeBuffer(lpEntries);
				lpEntries = NULL;

				/* Free Row */
				if (lpPRowSet) {
					FreeProws(lpPRowSet);
					lpPRowSet = NULL;
				}
				
			}
			
		}
		else //if (lstrcmpi(lpRowSet->aRow[0].lpProps[0].Value.LPSZ,"Personal Address Book"))
directory:
		{
		//--idx;
			/* We want to decrement our counter so we dont add x-1. */
			LUIOut(L3, "Nothing to add. No Rows in the Provider");
		}
		if(lpABPTable) {
			lpABPTable->Release();
			lpABPTable = NULL;
		}
		
		if(lpABPCont) {
			lpABPCont->Release();
			lpABPCont = NULL;
		}

		if (lpRowSet) {
			FreeProws(lpRowSet);
			lpRowSet = NULL;
		}
}

out:
		if (lpEntries) {
			if (lpEntries->lpbin) {
				if (lpEntries->lpbin->lpb)
					MAPIFreeBuffer(lpEntries->lpbin->lpb);
				MAPIFreeBuffer(lpEntries->lpbin);
			}
			MAPIFreeBuffer(lpEntries);
			lpEntries->lpbin = NULL;
		}
				
		if(lpRowSet)
			FreeProws(lpRowSet);
		if(lpPRowSet)
			FreeProws(lpPRowSet);

		if (lpPABCont)
				lpPABCont->Release();
		if (lpABCont)
				lpABCont->Release();
		if (lpABPCont)
				lpABPCont->Release();	
		if (lpEidPAB)
				MAPIFreeBuffer(lpEidPAB);
		if (lpEid)
			MAPIFreeBuffer(lpEid);
		if (lpABTable)
			lpABTable->Release();
		if (lpABPTable)
			lpABPTable->Release();

	
		//if (lpUserEid)
		//	MAPIFreeBuffer(lpUserEid);
		if (lpAdrBook)
			  lpAdrBook->Release();
		if (lpMAPISession)
			  lpMAPISession->Release();
	MAPIUninitialize();
#endif
	return retval;
}

BOOL PABRunBVT()
{
	LUIOut(L1,"");
	LUIOut(L1,"Running BVT");
	int retval = TRUE;
	//First Clear the PAB
	if (ClearPab(0))  {
		LUIOut(L2,"Clearing PAB");
		LUIOut(LPASS3,"Delete All Entries");
	}
	else  {
		LUIOut(LFAIL3,"Delete All Entries: %d");
		retval = FALSE;
	}
	// Create Entries in the PAB
	if (PabCreateEntry())  {
		LUIOut(L2,"Creating Entries in the PAB");
		LUIOut(LPASS3,"Create Entries");
	}
	else  {
		LUIOut(LFAIL3,"Create Entries");
		retval = FALSE;
	}
	//Enuerate the Entries in PAB
	if (PabEnumerateAll())  {
		LUIOut(L2,"Enumerate All Entries in the PAB");
		LUIOut(LPASS3,"Enumerate All");
	}
	else  {
		LUIOut(LFAIL3,"Enumerate All");
		retval = FALSE;
	}
	
	//Delete Entries in PAB
	if (PabDeleteEntry())  {
		LUIOut(L2,"Delete specified Entries");
		LUIOut(LPASS3,"DeleteEntries");
	}
	else  {
		LUIOut(LFAIL3,"DeleteEntries");
		retval = FALSE;
	}
	// Create a OneOff Entry
	if (CreateOneOff())  {
		LUIOut(L2,"Create a OneOff Entry in the PAB");
		LUIOut(LPASS3,"CreateOneOff");
	}
	else  {
		LUIOut(LFAIL3,"CreateOneOff");
		retval = FALSE;
	}
	// Do a SetProps on a Mail User
	if (PABSetProps())  {
		LUIOut(L2,"SetProps on a Mail User Entry in the PAB");
		LUIOut(LPASS3,"SetProps");
	}
	else  {
		LUIOut(LFAIL3,"SetProps");
		retval = FALSE;
	}
	// CopyEntries from other providers
	if (PABCopyEntries())  {
		LUIOut(L2,"CopyEntries");
		LUIOut(LPASS3,"CopyEntries");
	}
	else  {
		LUIOut(LFAIL3,"CopyEntries");
		retval = FALSE;
	}
	// Resolve Names
	if (PABResolveName())  {
		LUIOut(L2,"ResolveName");
		LUIOut(LPASS3,"ResolveName");
	}
	else  {
		LUIOut(LFAIL3,"ResolveName");
		retval = FALSE;
	}
	// Query Interface
	if (PABQueryInterface())  {
		LUIOut(L2,"ResolveName");
		LUIOut(LPASS3,"QueryInterface");
	}
	else  {
		LUIOut(LFAIL3,"QueryInterface");
		retval = FALSE;
	}
	// PrepareRecips
	if (PABPrepareRecips())  {
		LUIOut(L2,"PrepareRecips");
		LUIOut(LPASS3,"PrepareRecips");
	}
	else  {
		LUIOut(LFAIL3,"PrepareRecips");
		retval = FALSE;
	}
	// Delete Users Only
	if (ClearPab(1))  {
		LUIOut(L2,"Delete Mail Users Only");
		LUIOut(LPASS3,"DeleteUsers");
	}
	else  {
		LUIOut(LFAIL3,"DeleteUsers");
		retval = FALSE;
	}
	return retval;
}

INT_PTR CALLBACK SetIniFile(HWND hWndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{

static char szNewIniFile[BIG_BUF];

	switch(msg)
	{
		case WM_INITDIALOG:	
			SendDlgItemMessage(hWndDlg,IDC_EDIT,WM_SETTEXT, 0,(LPARAM)(LPCTSTR)szIniFile);
			SetFocus(GetDlgItem(hWndDlg,IDC_EDIT));
			return FALSE;			
			
		case WM_COMMAND:
			switch(LOWORD(wParam))
			
			{						
				case IDOK:
					SendDlgItemMessage(hWndDlg,IDC_EDIT,WM_GETTEXT, BIG_BUF,(LPARAM)szNewIniFile);
					if (lstrcmpi(szNewIniFile,szIniFile))
						lstrcpy(szIniFile,szNewIniFile);
					EndDialog(hWndDlg,TRUE);
					return TRUE;
   			
			    		
				case IDCANCEL:
					EndDialog(hWndDlg,FALSE);
					return TRUE;					
			}
			break;
	
		default:
			return FALSE;
	}
	return FALSE;
}

BOOL VerifyBuffer(DWORD ** lppvBufPtr, DWORD dwBufferSize)
{
	DWORD	*lpdwWrkPtr = *lppvBufPtr;
	DWORD	counter, cells, part, cellsize;
	BYTE	*lpbPart;

	// Walk through the allocated buffer's BUFFERSIZE/sizeof(DWORD) cells
	// and fill each DWORD with a pattern (the # of the cell). Then walk
	// the buffer and verify each pattern.

	cellsize = sizeof(DWORD);
	LUIOut(L3,"Writing test patterns to all cells in the buffer.");
	cells = (dwBufferSize/cellsize);	// How many DWORD cells in the buffer?
	part= (ULONG)fmod((double)dwBufferSize, (double)cellsize);	// Is there a remaining section?
	// Write the pattern to memory for the 'cells' portion of the buffer
	for(counter=0; counter < cells; counter++, lpdwWrkPtr++)	{
		*lpdwWrkPtr = counter;
	}
	
	lpbPart = (BYTE*)lpdwWrkPtr;
	// Write the pattern to memory for the 'part' leftover portion of the buffer
	for (counter = 0; counter < part; counter++, lpbPart++)	{
		*lpbPart = PATTERN;
	}

	lpdwWrkPtr = *lppvBufPtr;	//reset work pointer to beginning of buffer
	LUIOut(L3,"Verifying test patterns for %u %u-byte cells in the buffer.",
		cells, cellsize);
	// Verify the pattern in memory for the 'cells' portion of the buffer
	for(counter=0; counter < cells; counter++, lpdwWrkPtr++)	{
		if (*lpdwWrkPtr != counter)	{
			LUIOut(L3,"Verification Failed: Cell %u, expected %u but found %u",
				counter, counter, *lpdwWrkPtr);			
			goto bailout;
		}
	}
	LUIOut(L3,"Verified %u cells succesfully", counter);

	LUIOut(L3,"Verifying test patterns for the remaining %u bytes in the buffer.",
		part);
	// Verify the pattern in memory for the 'part' leftover portion of the buffer
	lpbPart = (BYTE*)lpdwWrkPtr;
	for(counter=0; counter < part; counter++, lpdwWrkPtr++)	{
		if (*lpbPart != PATTERN)	{
			LUIOut(L3,"Verification Failed: Byte %u, expected %u but found %u",
				counter, PATTERN, *lpdwWrkPtr);			
			goto bailout;
		}
	}
	LUIOut(L3,"Verified remaining buffer succesfully");
	return TRUE;

bailout: //verification failed, so I'm outa here!
	return FALSE;

 }

BOOL GetAB(OUT LPADRBOOK* lppAdrBook)
{
	HRESULT	hr;
	BOOL	retval = TRUE;

	//### token to find pab/wab dependencies

#ifdef WAB

	// WAB
	LPVOID	lpReserved = NULL;
	DWORD	dwReserved = 0;
	WAB_PARAM		WP;

	ZeroMemory((void *)&WP, sizeof(WAB_PARAM));
	WP.cbSize=sizeof(WAB_PARAM);
	
	LUIOut(L1, "[ Using the WAB ]");
	lpWABObject=NULL;
//	hr = WABOpen(lppAdrBook, &lpWABObject, &WP, dwReserved);
	hr = WABOpen(lppAdrBook, &lpWABObject, (WAB_PARAM*)lpReserved, dwReserved);
	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"WABOpen FAILED with hr = 0x%x", hr);
			 retval=FALSE;
			 goto out;
	}
	// store the ab pointer in a global variable, temporary kludge to workaround
	// the mulitple wabopen/release bug
	glbllpAdrBook = *lppAdrBook;

#endif

#ifdef PAB

	//	MAPI-PAB


	LUIOut(L1, "[ Using the MAPI-PAB ]");
	if (!(MapiInitLogon(OUT &lpMAPISession))) {
			LUIOut(L2,"MapiInitLogon Failed");
			retval = FALSE;
			goto out;
	}

	// Get the IAddrBook - MAPI
	
	hr = (lpMAPISession)->OpenAddressBook(
						 IN  0,                //window handle
						 IN  NULL,             //Interface identifier
						 IN  0,                //flags
						 OUT lppAdrBook);      //pointer to address book object

	if (HR_FAILED(hr)) {		
			 LUIOut(L2,"OpenAddressBook Failed");
			 LUIOut(L3,"Could not open address book for the profile");
			 retval=FALSE;
			 goto out;
	}

	
#endif
out:
	return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wabtool.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WABTOOL_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDD_DIALOG_PROP                 129
#define IDC_STATIC123                   465
#define IDC_STATIC_FILENAME             987
#define IDC_LIST                        1000
#define IDC_LIST_TAGS                   1002
#define IDC_BUTTON_NEW                  1004
#define IDC_BUTTON_DELETE               1005
#define IDC_EDIT_PROPDATA               1007
#define IDC_BUTTON_BROWSE               1008
#define IDC_BUTTON_REFRESH              1009
#define IDC_BUTTON_DETAILS              1010
#define IDC_STATIC_PROPNAME             1011
#define IDC_STATIC_PROPTYPE             1012
#define IDC_BUTTON_ADDPROP              1013
#define IDC_BUTTON_MODIFYPROP           1014
#define IDC_STATIC_PROPTAG              1015
#define IDC_STATIC_NUMENTRIES           1016
#define IDC_BUTTON_WABVIEW              1017
#define IDC_EDIT_VALUE                  1020
#define IDC_EDIT_TAG                    1021
#define IDC_STATIC_SELECTED             1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wabtool.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__268ADD6D_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
#define AFX_STDAFX_H__268ADD6D_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__268ADD6D_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\wabobject.cpp ===
#include "wabobject.h"



enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
	ieidPR_OBJECT_TYPE,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
		PR_OBJECT_TYPE,
    }
};


enum {
    iemailPR_DISPLAY_NAME = 0,
    iemailPR_ENTRYID,
    iemailPR_EMAIL_ADDRESS,
    iemailPR_OBJECT_TYPE,
    iemailMax
};
static const SizedSPropTagArray(iemailMax, ptaEmail)=
{
    iemailMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_EMAIL_ADDRESS,
        PR_OBJECT_TYPE
    }
};


/*********************************************************************************/


// contructor for CWAB object
//
// pszFileName - FileName of WAB file to open
//          if no file name is specified, opens the default
//
CWAB::CWAB(CString * pszFileName)
{
    // Here we load the WAB Object and initialize it
    m_bInitialized = FALSE;
	m_lpPropArray = NULL;
    m_ulcValues = 0;
    m_hWndModelessWABWindow = NULL;

    {
        TCHAR  szWABDllPath[MAX_PATH];
        DWORD  dwType = 0;
        ULONG  cbData = sizeof(szWABDllPath);
        HKEY hKey = NULL;

        *szWABDllPath = '\0';
        
        // First we look under the default WAB DLL path location in the
        // Registry. 
        // WAB_DLL_PATH_KEY is defined in wabapi.h
        //
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
            RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

        if(hKey) RegCloseKey(hKey);

        // if the Registry came up blank, we do a loadlibrary on the wab32.dll
        // WAB_DLL_NAME is defined in wabapi.h
        //
        m_hinstWAB = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME );
    }

    if(m_hinstWAB)
    {
        // if we loaded the dll, get the entry point 
        //
        m_lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hinstWAB, "WABOpen");

        if(m_lpfnWABOpen)
        {
            HRESULT hr = E_FAIL;
            WAB_PARAM wp = {0};
            wp.cbSize = sizeof(WAB_PARAM);
            wp.szFileName = (LPTSTR) (LPCTSTR) *pszFileName;
        
            // if we choose not to pass in a WAB_PARAM object, 
            // the default WAB file will be opened up
            //
            hr = m_lpfnWABOpen(&m_lpAdrBook,&m_lpWABObject,&wp,0);

            if(!hr)
                m_bInitialized = TRUE;
        }
    }

}


// Destructor
//
CWAB::~CWAB()
{
    if(m_SB.lpb)
        LocalFree(m_SB.lpb);

    if(m_bInitialized)
    {
        if(m_hWndModelessWABWindow)
            DestroyWindow(m_hWndModelessWABWindow);

        if(m_lpPropArray)
            m_lpWABObject->FreeBuffer(m_lpPropArray);

        if(m_lpAdrBook)
            m_lpAdrBook->Release();

        if(m_lpWABObject)
            m_lpWABObject->Release();

        if(m_hinstWAB)
            FreeLibrary(m_hinstWAB);
    }
}


// Opens a wab file and puts its contents into the specified list view
//
HRESULT CWAB::LoadWABContents(CListCtrl * pListView)
{
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
	int cNumRows = 0;
    int nRows=0;

    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    // Get the entryid of the root PAB container
    //
    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    // Open the root PAB container
    // This is where all the WAB contents reside
    //
    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
	
    if(HR_FAILED(hr))
        goto exit;

    // Get a contents table of all the contents in the
    // WABs root container
    //
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);

    if(HR_FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the
    // ones we want - which are mainly DisplayName, EntryID and
    // ObjectType
    // The table is gauranteed to set the columns in the order 
    // requested
    //
	hr =lpAB->SetColumns( (LPSPropTagArray)&ptaEid, 0 );

    if(HR_FAILED(hr))
        goto exit;


    // Reset to the beginning of the table
    //
	hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );

    if(HR_FAILED(hr))
        goto exit;

    // Read all the rows of the table one by one
    //
	do {

		hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(HR_FAILED(hr))
            break;

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

		    if (cNumRows)
		    {
                LPTSTR lpsz = lpRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
                LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
                ULONG cbEID = lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

                // There are 2 kinds of objects - the MAPI_MAILUSER contact object
                // and the MAPI_DISTLIST contact object
                // For the purposes of this sample, we will only consider MAILUSER
                // objects
                //
                if(lpRowAB->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    // We will now take the entry-id of each object and cache it
                    // on the listview item representing that object. This enables
                    // us to uniquely identify the object later if we need to
                    //
                    LPSBinary lpSB = NULL;

                    m_lpWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
                
                    if(lpSB)
                    {
                        m_lpWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));

                        if(!lpSB->lpb)
                        {
                            m_lpWABObject->FreeBuffer(lpSB);
                            continue;
                        }
                    
                        CopyMemory(lpSB->lpb, lpEID, cbEID);
                        lpSB->cb = cbEID;

                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_TEXT | LVIF_PARAM;
                        lvi.iItem = pListView->GetItemCount();
                        lvi.iSubItem = 0;
                        lvi.pszText = lpsz;
                        lvi.lParam = (LPARAM) lpSB;

                        // Now add this item to the list view
                        pListView->InsertItem(&lvi);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

exit:

	if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return hr;
}


// Clears the contents of the specified ListView
//
void CWAB::ClearWABLVContents(CListCtrl * pListView)
{
    int i;
    int nCount = pListView->GetItemCount();
    
    if(nCount<=0)
        return;

    for(i=0;i<nCount;i++)
    {
        LV_ITEM lvi ={0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;
        lvi.iSubItem = 0;
        pListView->GetItem(&lvi);
        if(lvi.lParam)
        {
            LPSBinary lpSB = (LPSBinary) lvi.lParam;
            m_lpWABObject->FreeBuffer(lpSB);
        }
    }
    pListView->DeleteAllItems();
}



void CWAB::FreeProws(LPSRowSet prows)
{
	ULONG		irow;
	if (!prows)
		return;
	for (irow = 0; irow < prows->cRows; ++irow)
		m_lpWABObject->FreeBuffer(prows->aRow[irow].lpProps);
	m_lpWABObject->FreeBuffer(prows);
}

// When an item is selected in the listview, we
// cache its entry id as a special selected item
//
void CWAB::SetSelection(CListCtrl * pListView)
{

    LV_ITEM lvi = {0};
    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        return;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        if(m_SB.lpb)
            LocalFree(m_SB.lpb);
        m_SB.cb = lpSB->cb;
        m_SB.lpb = (LPBYTE) LocalAlloc(LMEM_ZEROINIT, m_SB.cb);
        if(m_SB.lpb)
            CopyMemory(m_SB.lpb, lpSB->lpb, m_SB.cb);
        else
            m_SB.cb = 0;
    }    
}



// Show details on the selected item
//
void CWAB::ShowSelectedItemDetails(HWND hWndParent)
{
    HRESULT hr = S_OK;

    // if we have a specially cached entryid ..
    //
    if(m_SB.cb && m_SB.lpb)
    {
        HWND hWnd = NULL;
        LPSBinary lpSB = (LPSBinary) &m_SB;
        hr = m_lpAdrBook->Details(  (LPULONG) &hWnd,
					        		NULL, NULL,
								    lpSB->cb,
								    (LPENTRYID) lpSB->lpb,
								    NULL, NULL,
								    NULL, 0);
    }
    return;
}

// Gets a SPropValue array for the selected item
// This array contains all the properties for that item
// though we could actually get a subset too if we
// wanted to
//
void CWAB::GetSelectedItemPropArray()
{
    if(m_SB.lpb && m_SB.cb)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) &m_SB;
        ULONG ulObjType = 0;

        // Open the selected entry 
        //
        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              0,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);

        if(lpMailUser)
        {
            // Flush away any old array we might have cached
            //
            if(m_lpPropArray)
                m_lpWABObject->FreeBuffer(m_lpPropArray);
            m_ulcValues = 0;

            lpMailUser->GetProps(NULL, 0, &m_ulcValues, &m_lpPropArray);

            lpMailUser->Release();
        }
    }
    return;
}


// Loads the proptags for the selected entry into the
// PropTags list box
//
void CWAB::LoadPropTags(CListBox * pList)
{
    if(!m_ulcValues || !m_lpPropArray)
        return;

    pList->ResetContent();

    ULONG i;
    TCHAR sz[32];
    for(i=0;i<m_ulcValues;i++)
    {
        wsprintf(sz, "0x%.8x", m_lpPropArray[i].ulPropTag);
        pList->SetItemData(pList->AddString(sz), m_lpPropArray[i].ulPropTag);
    }

    pList->SetCurSel(-1);
    pList->SetCurSel(0);
}


// Sets the property value, if understandable, into the
// given edit box
//
void CWAB::SetPropString(CEdit * pEdit, ULONG ulPropTag)
{
    pEdit->SetWindowText("");

    if(!m_ulcValues || !m_lpPropArray)
        return;

    ULONG i;

    for(i=0;i<m_ulcValues;i++)
    {
        if(m_lpPropArray[i].ulPropTag == ulPropTag)
        {
            switch(PROP_TYPE(ulPropTag))
            {
            case PT_TSTRING:
                pEdit->SetWindowText(m_lpPropArray[i].Value.LPSZ);
                break;
            case PT_MV_TSTRING:
                {
                    ULONG j;
                    LPSPropValue lpProp = &(m_lpPropArray[i]);
                    for(j=0;j<lpProp->Value.MVSZ.cValues;j++)
                    {
                        pEdit->ReplaceSel(lpProp->Value.MVSZ.LPPSZ[j]);
                        pEdit->ReplaceSel("\r\n");
                    }
                }
                break;
            case PT_BINARY:
                pEdit->SetWindowText("Binary data");
                break;
            case PT_I2:
            case PT_LONG:
            case PT_R4:
            case PT_DOUBLE:
            case PT_BOOLEAN:
                {
                    TCHAR sz[256];
                    wsprintf(sz,"%d",m_lpPropArray[i].Value.l);
                    pEdit->SetWindowText(sz);
                }
                break;
            default:
                pEdit->SetWindowText("Unrecognized or undisplayable data");
                break;
            }
            break;
        }
    }

}


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};


// Gets the WABs default Template ID for MailUsers
// or DistLists. These Template IDs are needed for creating
// new mailusers and distlists
//
HRESULT CWAB::HrGetWABTemplateID(ULONG   ulObjectType,
                                ULONG * lpcbEID,
                                LPENTRYID * lppEID)
{
    LPABCONT lpContainer = NULL;
    HRESULT hr  = hrSuccess;
    SCODE sc = ERROR_SUCCESS;
    ULONG ulObjType = 0;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG cNewProps;
    ULONG nIndex;

    if (    (!m_lpAdrBook) ||
           ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID = NULL;

    if (HR_FAILED(hr = m_lpAdrBook->GetPAB( &cbWABEID,
                                      &lpWABEID)))
    {
        goto out;
    }

    if (HR_FAILED(hr = m_lpAdrBook->OpenEntry(cbWABEID,     // size of EntryID to open
                                        lpWABEID,     // EntryID to open
                                        NULL,         // interface
                                        0,            // flags
                                        &ulObjType,
                                        (LPUNKNOWN *)&lpContainer)))
    {
        goto out;
    }

    // Opened PAB container OK

    // Get us the default creation entryids
    if (HR_FAILED(hr = lpContainer->GetProps(   (LPSPropTagArray)&ptaCreate,
                                                0,
                                                &cNewProps,
                                                &lpCreateEIDs)  )   )
    {
        goto out;
    }

    // Validate the properites
    if (    lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
            lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        goto out;
    }

    if(ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;

    m_lpWABObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID);
    
    if (sc != S_OK)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        m_lpWABObject->FreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->Release();

    if (lpWABEID)
        m_lpWABObject->FreeBuffer(lpWABEID);

    return hr;
}


// Shows the NewEntry dialog to enable creating a new contact in the WAB
//
HRESULT CWAB::ShowNewEntryDialog(HWND hWndParent)
{
	ULONG cbEID=0;
	LPENTRYID lpEID=NULL;

    HRESULT hr = hrSuccess;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;

    // Get the template id which is needed to create the
    // new object
    //
    if(HR_FAILED(hr = HrGetWABTemplateID(   MAPI_MAILUSER,
                                            &cbTplEID,
                                            &lpTplEID)))
    {
        goto out;
    }

    // Display the New Entry dialog to create the new entry
    //
	if (HR_FAILED(hr = m_lpAdrBook->NewEntry(	(ULONG) hWndParent,
							            		0,
									            0,NULL,
									            cbTplEID,lpTplEID,
									            &cbEID,&lpEID)))
    {
        goto out;
    }

out:
    return hr;
}


// Delete an entry from the WAB
//
HRESULT CWAB::DeleteEntry()
{
	HRESULT hr = hrSuccess;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpWABCont = NULL;
    ULONG ulObjType;
    SBinaryArray SBA;

    hr = m_lpAdrBook->GetPAB( &cbWABEID,
                              &lpWABEID);
    if(HR_FAILED(hr))
        goto out;

    hr = m_lpAdrBook->OpenEntry(  cbWABEID,     // size of EntryID to open
                                  lpWABEID,     // EntryID to open
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpWABCont);

    if(HR_FAILED(hr))
        goto out;

    SBA.cValues = 1;
    SBA.lpbin = &m_SB;

    hr = lpWABCont->DeleteEntries((LPENTRYLIST) &SBA, 0);

    if(m_lpPropArray)
        m_lpWABObject->FreeBuffer(m_lpPropArray);

    m_lpPropArray = NULL;
    m_ulcValues = 0;

out:
    if(lpWABCont)
        lpWABCont->Release();

    if(lpWABEID)
        m_lpWABObject->FreeBuffer(lpWABEID);

    return hr;
}


// Gets the property value for specified String property
//
BOOL CWAB::GetStringPropVal(HWND hWnd, ULONG ulPropTag, LPTSTR sz, ULONG cbsz)
{

    BOOL bRet = FALSE;

    if(PROP_TYPE(ulPropTag) != PT_TSTRING)
    {
        MessageBox(hWnd, "This tool only supports modifying string type props right now",
            "Error", MB_OK | MB_ICONINFORMATION);
        goto out;
    }

    ULONG i;

    // Since we already cached the proparray for the selected
    // item, all we need to do is look in the cached proparray
    // for the requested proptag
    //
    for(i=0;i<m_ulcValues;i++)
    {
        if(m_lpPropArray[i].ulPropTag == ulPropTag)
        {
            LPTSTR lp = m_lpPropArray[i].Value.LPSZ;
            ULONG nLen = (ULONG) lstrlen(lp);
            if(nLen >= cbsz)
            {
                CopyMemory(sz, lp, cbsz-1);
                sz[cbsz-1]='\0';
            }
            else 
                lstrcpy(sz,lp);
            break;
        }
    }

    bRet = TRUE;
out:
    return bRet;
}


// Sets a single string property onto a mailuser object
//
BOOL CWAB::SetSingleStringProp(HWND hWnd, ULONG ulPropTag, LPTSTR sz)
{
    SPropValue Prop;
    BOOL bRet = FALSE;

    if(PROP_TYPE(ulPropTag) != PT_TSTRING)
    {
        MessageBox(hWnd, "This version of the tool can only set string properties.",
            "Error", MB_OK | MB_ICONINFORMATION);
        goto out;
    }

    Prop.ulPropTag = ulPropTag;
    Prop.Value.LPSZ = sz;

    // Open the cached entry and get a mailuser object
    // representing that entry
    //
    if(m_SB.lpb && m_SB.cb)
    {
        LPMAILUSER lpMailUser = NULL;
        LPSBinary lpSB = (LPSBinary) &m_SB;
        ULONG ulObjType = 0;

        // To modify an object, make sure to specify the 
        // MAPI_MODIFY flag otherwise the object is always
        // opened read-only be default
        //
        m_lpAdrBook->OpenEntry(lpSB->cb,
                               (LPENTRYID) lpSB->lpb,
                              NULL,         // interface
                              MAPI_MODIFY,            // flags
                              &ulObjType,
                              (LPUNKNOWN *)&lpMailUser);

        if(lpMailUser)
        {

            // Knock out this prop if it exists so we can overwrite it
            //
            {
                SPropTagArray SPTA;
                SPTA.cValues = 1;
                SPTA.aulPropTag[0] = ulPropTag;

                lpMailUser->DeleteProps(&SPTA, NULL);
            }

            // Set the new property on the mailuser
            //
            if (!HR_FAILED(lpMailUser->SetProps(1, &Prop, NULL)))
            {
                // **NOTE** if you dont call SaveChanges, the
                // changes are not saved (duh). Also if you didnt
                // open the object with the MAPI_MODIFY flag, you
                // are likely to get an ACCESS_DENIED error
                //
                lpMailUser->SaveChanges(0);
                bRet = TRUE;
            }
            lpMailUser->Release();
        }
    }

out:

    GetSelectedItemPropArray();
    return bRet;
}


void STDMETHODCALLTYPE TestDismissFunction(ULONG ulUIParam, LPVOID lpvContext)
{
    LPDWORD lpdw = (LPDWORD) lpvContext;
    return;
}

DWORD dwContext = 77;

// Shows the Address Book
//
void CWAB::ShowAddressBook(HWND hWnd)
{
    ADRPARM AdrParm = {0};
    
    AdrParm.lpszCaption = "WABTool Address Book View";      

    AdrParm.cDestFields = 0;
    AdrParm.ulFlags = DIALOG_SDI;
    AdrParm.lpvDismissContext = &dwContext;
    AdrParm.lpfnDismiss = &TestDismissFunction;
    AdrParm.lpfnABSDI = NULL;

    m_lpAdrBook->Address(  (ULONG *) &m_hWndModelessWABWindow,     
                            &AdrParm,   
                            NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\wabobject.h ===
#include "stdafx.h"
#include "afxcview.h"
#include "wab.h"

class CWAB
{
public:
    CWAB(CString * pszFileName);
    ~CWAB();
    
    HRESULT LoadWABContents(CListCtrl * pListView);
    void ClearWABLVContents(CListCtrl * pListView);

    void LoadPropTags(CListBox * pList);
    void SetPropString(CEdit * pEdit, ULONG ulPropTag);

    void    ShowSelectedItemDetails(HWND hWndParent);
    HRESULT ShowNewEntryDialog(HWND hWndParent);
    HRESULT DeleteEntry();

    void GetSelectedItemPropArray();

    BOOL GetStringPropVal(HWND hWnd, ULONG ulPropTag, LPTSTR sz, ULONG cbsz);
    BOOL SetSingleStringProp(HWND hWnd, ULONG ulPropTag, LPTSTR sz);

    void SetSelection(CListCtrl * pListView);
    
    void ShowAddressBook(HWND hWnd);

private:
    BOOL        m_bInitialized;
    HINSTANCE   m_hinstWAB;
    LPWABOPEN   m_lpfnWABOpen;
    LPADRBOOK   m_lpAdrBook; 
    LPWABOBJECT m_lpWABObject;
    HWND        m_hWndModelessWABWindow;
    
    // Cache Proparray of currently selected item in the list view
    LPSPropValue m_lpPropArray;
    ULONG       m_ulcValues;
    
    // Cache entry id of currently selected item in the listview
    SBinary     m_SB;

    void FreeProws(LPSRowSet prows);
    HRESULT HrGetWABTemplateID(ULONG   ulObjectType, ULONG * lpcbEID, LPENTRYID * lppEID);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtool.h ===
// wabtool.h : main header file for the WABTOOL application
//

#if !defined(AFX_WABTOOL_H__268ADD69_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
#define AFX_WABTOOL_H__268ADD69_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp:
// See wabtool.cpp for the implementation of this class
//

class CWabtoolApp : public CWinApp
{
public:
	CWabtoolApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabtoolApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWabtoolApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABTOOL_H__268ADD69_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtool.cpp ===
// wabtool.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wabtool.h"
#include "wabtoolDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp

BEGIN_MESSAGE_MAP(CWabtoolApp, CWinApp)
	//{{AFX_MSG_MAP(CWabtoolApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp construction

CWabtoolApp::CWabtoolApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWabtoolApp object

CWabtoolApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWabtoolApp initialization

BOOL CWabtoolApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

	CWabtoolDlg dlg;
    dlg.m_pszFileName = new CString(cmdInfo.m_strFileName);
        

	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

    delete(dlg.m_pszFileName);

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtooldlg.h ===
// wabtoolDlg.h : header file
//

#if !defined(AFX_WABTOOLDLG_H__268ADD6B_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
#define AFX_WABTOOLDLG_H__268ADD6B_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CWabtoolDlg dialog

class CWabtoolDlg : public CDialog
{
// Construction
public:
	CWabtoolDlg(CWnd* pParent = NULL);	// standard constructor

    void LoadContents(BOOL bLoadNew);
    void ClearCurrentWAB(BOOL bLoadNew);

    void UpdatePropTagData();
    void SetPropTagString(LPTSTR lpTag);
    void SetPropTypeString(ULONG ulPropTag);
    void SetPropNameString(ULONG ulPropTag);
    void SetPropDataString(ULONG ulPropTag);

    CString * m_pszFileName;

// Dialog Data
	//{{AFX_DATA(CWabtoolDlg)
	enum { IDD = IDD_WABTOOL_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabtoolDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWabtoolDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonBrowse();
	afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchangeListTags();
	afx_msg void OnButtonDetails();
	afx_msg void OnButtonNew();
	afx_msg void OnButtonDelete();
	afx_msg void OnButtonAddprop();
	afx_msg void OnButtonModifyprop();
	afx_msg void OnDblclkListTags();
	afx_msg void OnButtonRefresh();
	afx_msg void OnButtonWabview();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABTOOLDLG_H__268ADD6B_EF27_11D0_9A7E_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabtool\wabtooldlg.cpp ===
// wabtoolDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wabtool.h"
#include "wabobject.h"
#include "wabtoolDlg.h"
#include "DlgProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWAB * g_pWAB;

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabtoolDlg dialog

CWabtoolDlg::CWabtoolDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWabtoolDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWabtoolDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CWabtoolDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWabtoolDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWabtoolDlg, CDialog)
	//{{AFX_MSG_MAP(CWabtoolDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
	ON_LBN_SELCHANGE(IDC_LIST_TAGS, OnSelchangeListTags)
	ON_BN_CLICKED(IDC_BUTTON_DETAILS, OnButtonDetails)
	ON_BN_CLICKED(IDC_BUTTON_NEW, OnButtonNew)
	ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
	ON_BN_CLICKED(IDC_BUTTON_ADDPROP, OnButtonAddprop)
	ON_BN_CLICKED(IDC_BUTTON_MODIFYPROP, OnButtonModifyprop)
	ON_LBN_DBLCLK(IDC_LIST_TAGS, OnDblclkListTags)
	ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
	ON_BN_CLICKED(IDC_BUTTON_WABVIEW, OnButtonWabview)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabtoolDlg message handlers

BOOL CWabtoolDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
    InitCommonControls();

    LoadContents(TRUE);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CWabtoolDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWabtoolDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWabtoolDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

BOOL CWabtoolDlg::DestroyWindow() 
{
	// TODO: Add your specialized code here and/or call the base class
    ClearCurrentWAB(TRUE);
    
	return CDialog::DestroyWindow();
}

//
// Double-clicking the contents list view shows Details on the 
// selected entries
//
void CWabtoolDlg::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    g_pWAB->ShowSelectedItemDetails(m_hWnd);

	*pResult = 0;
}

//
// Clicking the browse button lets the user select a new WAB file
// to inspect
//
void CWabtoolDlg::OnButtonBrowse() 
{

    char szFilters[]="WAB Files (*.wab)|*.wab|All Files (*.*)|*.*||";
    CFileDialog CFileDlg (TRUE, "wab", "*.wab",
                        OFN_FILEMUSTEXIST, szFilters, this);

    if(CFileDlg.DoModal() == IDOK)
    {
        delete m_pszFileName;
        m_pszFileName = new CString(CFileDlg.GetPathName());

        ClearCurrentWAB(TRUE);
    
        LoadContents(TRUE);

    }
}

// Loads the WAB contents into the list view
// 
// bLoadNew is true if we are loading a new file
//
void CWabtoolDlg::LoadContents(BOOL bLoadNew)
{

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    if(bLoadNew)
        g_pWAB = new CWAB(m_pszFileName);

    g_pWAB->LoadWABContents(pListView);

    CStatic * pFileName = (CStatic *) GetDlgItem(IDC_STATIC_FILENAME);
    pFileName->SetWindowText((LPTSTR) (LPCTSTR) *m_pszFileName);

    TCHAR sz[256];
    wsprintf(sz, "%d entries", pListView->GetItemCount());
    CStatic * pCount = (CStatic *) GetDlgItem(IDC_STATIC_NUMENTRIES);
    pCount->SetWindowText(sz);

    // select the first item in the list view
    pListView->SetItem( 0, 0,
                        LVIF_STATE,NULL,
                        0,
                        LVNI_SELECTED | LVNI_FOCUSED,
                        LVNI_SELECTED | LVNI_FOCUSED,
                        NULL);

}

//
// Clear out the currently loaded WAB
//
void CWabtoolDlg::ClearCurrentWAB(BOOL bLoadNew)
{
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    g_pWAB->ClearWABLVContents(pListView);
    
    if(bLoadNew) // we'll be loading a new address book so lose this object
        delete g_pWAB;
}

void CWabtoolDlg::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    static int oldItem = -1;

    int newItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(newItem != oldItem && newItem != -1)
    {
        g_pWAB->SetSelection(pListView);
        g_pWAB->GetSelectedItemPropArray();

        TCHAR sz[MAX_PATH];
        g_pWAB->GetStringPropVal(m_hWnd, PR_DISPLAY_NAME, sz, sizeof(sz));
        ((CStatic *)GetDlgItem(IDC_STATIC_SELECTED))->SetWindowText(sz);

        UpdatePropTagData();

        OnSelchangeListTags();

        oldItem = newItem;
    }
	
	*pResult = 0;
}

void CWabtoolDlg::UpdatePropTagData()
{
    g_pWAB->LoadPropTags((CListBox *) GetDlgItem(IDC_LIST_TAGS));
}

void CWabtoolDlg::OnSelchangeListTags() 
{
    TCHAR sz[64];

    CListBox * pList = (CListBox *) GetDlgItem(IDC_LIST_TAGS);

    ULONG ulPropTag = (ULONG) pList->GetItemData(pList->GetCurSel());

    pList->GetText(pList->GetCurSel(), sz);

    SetPropTagString(sz);
    SetPropTypeString(ulPropTag);
    SetPropNameString(ulPropTag);
    SetPropDataString(ulPropTag);

}

LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}

void CWabtoolDlg::SetPropTypeString(ULONG ulPropTag)
{
    ((CStatic *) GetDlgItem(IDC_STATIC_PROPTYPE))->SetWindowText(PropTypeString(PROP_TYPE(ulPropTag)));
}

void CWabtoolDlg::SetPropTagString(LPTSTR lpTag)
{
    ((CStatic *) GetDlgItem(IDC_STATIC_PROPTAG))->SetWindowText(lpTag);
}

void CWabtoolDlg::OnButtonDetails() 
{
    g_pWAB->ShowSelectedItemDetails(m_hWnd);
    // refresh the list view
    OnButtonRefresh();
}

#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
LPTSTR PropTagName(ULONG ulPropTag) {
    static TCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {
        RETURN_PROP_CASE(PR_7BIT_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_ALTERNATE_RECIPIENT);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BIRTHDAY);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CHILDRENS_NAMES);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_COMPANY_MAIN_PHONE_NUMBER);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMPUTER_NETWORK_NAME);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_CONTACT_ENTRYIDS);
        RETURN_PROP_CASE(PR_CONTACT_VERSION);
        RETURN_PROP_CASE(PR_CONVERSION_PROHIBITED);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_CUSTOMER_ID);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_DISCLOSE_RECIPIENTS);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_DISPLAY_NAME_PREFIX);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_FTP_SITE);
        RETURN_PROP_CASE(PR_GENDER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_HOBBIES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_FAX_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_KEYWORD);
        RETURN_PROP_CASE(PR_LANGUAGE);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_MAIL_PERMISSION);
        RETURN_PROP_CASE(PR_MANAGER_NAME);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_ORIGINAL_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_ORIGINAL_ENTRYID);
        RETURN_PROP_CASE(PR_ORIGINAL_SEARCH_KEY);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_OTHER_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_PREFERRED_BY_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PROFESSION);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_SEND_INTERNET_ENCODING);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_SPOUSE_NAME);
        RETURN_PROP_CASE(PR_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_STREET_ADDRESS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_TTYTDD_PHONE_NUMBER);
        RETURN_PROP_CASE(PR_USER_CERTIFICATE);
        RETURN_PROP_CASE(PR_USER_X509_CERTIFICATE);
        RETURN_PROP_CASE(PR_WEDDING_ANNIVERSARY);
        RETURN_PROP_CASE(PR_SEARCH_KEY);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x", PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


void CWabtoolDlg::SetPropNameString(ULONG ulPropTag)
{
    LPTSTR lp = PropTagName(ulPropTag);

    CStatic * pType = (CStatic *) GetDlgItem(IDC_STATIC_PROPNAME);

    pType->SetWindowText(lp);
}


void CWabtoolDlg::SetPropDataString(ULONG ulPropTag)
{
    CEdit * pEdit = (CEdit *) GetDlgItem(IDC_EDIT_PROPDATA);
    
    g_pWAB->SetPropString(pEdit, ulPropTag);
}

void CWabtoolDlg::OnButtonNew() 
{

    HRESULT hr = g_pWAB->ShowNewEntryDialog(m_hWnd);

    if(!hr)
        OnButtonRefresh();
}

void CWabtoolDlg::OnButtonDelete() 
{
    g_pWAB->DeleteEntry();
    // refresh the list view
    OnButtonRefresh();
}

void CWabtoolDlg::OnButtonAddprop() 
{
    TCHAR sz[512];
    *sz = '\0';
    CDlgProp dlgProp;

    dlgProp.m_ulPropTag = 0;
    dlgProp.m_lpszPropVal = sz;
    dlgProp.m_cbsz = sizeof(sz);

    if(dlgProp.DoModal())
    {
        g_pWAB->SetSingleStringProp(m_hWnd, dlgProp.m_ulPropTag, sz);
        UpdatePropTagData();
        OnSelchangeListTags();
    }

}

void CWabtoolDlg::OnButtonModifyprop() 
{
	
    CListBox * pList = (CListBox *) GetDlgItem(IDC_LIST_TAGS);

    ULONG ulPropTag = (ULONG) pList->GetItemData(pList->GetCurSel());

    TCHAR sz[512];

    if(g_pWAB->GetStringPropVal(m_hWnd, ulPropTag, sz, sizeof(sz)))
    {
        CDlgProp dlgProp;

        dlgProp.m_ulPropTag = ulPropTag;
        dlgProp.m_lpszPropVal = sz;
        dlgProp.m_cbsz = sizeof(sz);

        if(dlgProp.DoModal())
        {
            g_pWAB->SetSingleStringProp(m_hWnd, ulPropTag, sz);
            UpdatePropTagData();
            OnSelchangeListTags();
        }


    }

}

void CWabtoolDlg::OnDblclkListTags() 
{
    OnButtonModifyprop();	
}

void CWabtoolDlg::OnButtonRefresh() 
{
    // refresh the list view
    ClearCurrentWAB(FALSE);
    LoadContents(FALSE);
}

void CWabtoolDlg::OnButtonWabview() 
{
    g_pWAB->ShowAddressBook(m_hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\callcntr.cpp ===
// CallCntr.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "CallCntr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCallCenter dialog


CCallCenter::CCallCenter(CWnd* pParent /*=NULL*/)
	: CDialog(CCallCenter::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCallCenter)
	m_addrCity = _T("");
	m_addrState = _T("");
	m_addrStreet = _T("");
	m_addrZip = _T("");
	m_callerID = _T("");
	m_employer = _T("");
	m_firstName = _T("");
	m_lastName = _T("");
	m_telFax = _T("");
	m_telHome = _T("");
	m_telWork = _T("");
	//}}AFX_DATA_INIT
}


void CCallCenter::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCallCenter)
	DDX_Text(pDX, IDC_EDIT_ADDRCITY, m_addrCity);
	DDX_Text(pDX, IDC_EDIT_ADDRSTATE, m_addrState);
	DDX_Text(pDX, IDC_EDIT_ADDRSTREET, m_addrStreet);
	DDX_Text(pDX, IDC_EDIT_ADDRZIP, m_addrZip);
	DDX_Text(pDX, IDC_EDIT_CALLERID, m_callerID);
	DDX_Text(pDX, IDC_EDIT_EMPLOYER, m_employer);
	DDX_Text(pDX, IDC_EDIT_FIRSTNAME, m_firstName);
	DDX_Text(pDX, IDC_EDIT_LASTNAME, m_lastName);
	DDX_Text(pDX, IDC_EDIT_TELFAX, m_telFax);
	DDX_Text(pDX, IDC_EDIT_TELHOME, m_telHome);
	DDX_Text(pDX, IDC_EDIT_TELWORK, m_telWork);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCallCenter, CDialog)
	//{{AFX_MSG_MAP(CCallCenter)
	ON_BN_CLICKED(IDC_BUTTON_CLEAR, OnButtonClear)
	ON_BN_CLICKED(IDC_BUTTON_ANSWER, OnButtonAnswer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCallCenter message handlers

void CCallCenter::OnButtonClear() 
{
	m_addrCity = _T("");
	m_addrState = _T("");
	m_addrStreet = _T("");
	m_addrZip = _T("");
	m_callerID = _T("");
	m_employer = _T("");
	m_firstName = _T("");
	m_lastName = _T("");
	m_telFax = _T("");
	m_telHome = _T("");
	m_telWork = _T("");
	UpdateData(FALSE);
}

BOOL CCallCenter::OnInitDialog() 
{
	WINDOWPLACEMENT wndpl;

	CDialog::OnInitDialog();
	
	VERIFY(GetWindowPlacement(&wndpl));
	wndpl.showCmd = SW_SHOWMAXIMIZED;
	VERIFY(SetWindowPlacement(&wndpl));
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCallCenter::OnButtonAnswer() 
{
	//((CVCApp *)AfxGetApp())->ReceiveCard("D:\\VC_DEMO\\Adaptec.vcf");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\childfrm.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// childfrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "VC.h"

#include "childfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style = WS_CHILD | WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
		| FWS_ADDTOTITLE | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_MAXIMIZE;

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\callcntr.h ===
// CallCntr.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCallCenter dialog

class CCallCenter : public CDialog
{
// Construction
public:
	CCallCenter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCallCenter)
	enum { IDD = IDD_DIALOG_CALLCENTER };
	CString	m_addrCity;
	CString	m_addrState;
	CString	m_addrStreet;
	CString	m_addrZip;
	CString	m_callerID;
	CString	m_employer;
	CString	m_firstName;
	CString	m_lastName;
	CString	m_telFax;
	CString	m_telHome;
	CString	m_telWork;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCallCenter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCallCenter)
	afx_msg void OnButtonClear();
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonAnswer();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\clist.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Class List

#include "stdafx.h"
#ifndef __MWERKS__	// gca
#else
#include <assert.h>	// gca
#define	ASSERT assert
#endif
#include <ctype.h>
#include "clist.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CListElement::CListElement()
	{
	m_next = NULL;
	m_prev = NULL;
	m_item = NULL;
	}
	
CListElement::~CListElement()
	{
	}
	
CList::CList()
	{
	m_head = NULL;
	m_tail = NULL;
	m_count = 0;
	}

CList::~CList()
	{
	RemoveAll();
	}

void CList::InsertAfter( CListElement  *here, CListElement  *elem )
	{
	if ( here == NULL )
		{
		// put it at the front (bottom) of the group
		elem->m_prev = NULL;
		elem->m_next = m_head;
		if (m_head != NULL)
			m_head->m_prev = elem;
		m_head = elem;
        if (m_tail == NULL)
			m_tail = elem;
		}
    else
		{
		if ( here == m_tail )
			{
		    elem->m_next = here->m_next;  // NULL
		    elem->m_prev = here;
		    here->m_next = elem;
			m_tail = elem;
			}
        else
			{
		    elem->m_next = here->m_next;
		    elem->m_prev = here;
		    here->m_next->m_prev = elem;
		    here->m_next = elem;
			}
		}
	m_count += 1;
	}

CListElement  * CList::InsertAfter( CListElement  *here, void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertAfter( here, le );
	return (le);
	}
	
void CList::InsertBefore( CListElement  *here, CListElement  *elem )
	{
	if (here != NULL)
        InsertAfter( here->m_prev, elem );
    else
        InsertAfter( here, elem );
    }
    
CListElement  * CList::InsertBefore( CListElement  *here, void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertBefore( here, le );
	return (le);
	}
	
void CList::RemoveNoDel( CListElement  *elem )
	{
    if (elem == m_head)
		m_head = elem->m_next;
    if (elem == m_tail)
		m_tail = elem->m_prev;
    if ( elem->m_prev != NULL )
        elem->m_prev->m_next = elem->m_next;
    if ( elem->m_next != NULL )
		elem->m_next->m_prev = elem->m_prev;
	m_count -= 1;
	}

void CList::RemoveAt( CListElement  *elem )
	{
	RemoveNoDel( elem );
	delete elem;
	}

void CList::RemoveAll()
	{
	while (m_tail)
		RemoveAt(m_tail);
	ASSERT(m_count == 0);
	ASSERT(m_head == NULL);
	}
	
void CList::MoveToTail( CListElement  *elem )
	{
	RemoveNoDel( elem );
	InsertAfter( m_tail, elem );
	}

void CList::MoveToHead( CListElement  *elem )
	{
	RemoveNoDel( elem );
	InsertAfter( NULL, elem );
	}

void CList::InsertAtTail( CListElement  *elem )
	{
	InsertAfter( m_tail, elem );
	}

void CList::InsertAtHead( CListElement  *elem )
	{
	InsertAfter( NULL, elem );
	}
	
CListElement  * CList::AddTail( void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertAfter( m_tail, le );
	return (le);
	}

CListElement  * CList::AddHead( void  *item )
	{
	CListElement  *le;
	
	le = new CListElement;
	le->m_item = item;
	InsertAfter( NULL, le );
	return (le);
	}
	
CListElement  * CList::Find( void  *item )
	{
	CListElement  *le;
	
	for( le = m_head; le != NULL; le = le->m_next )
		if( le->m_item == item )
		    return( le );
	return (NULL);
	}

CListElement * CList::Search(CListSearchFunc compare, void *context)
	{
	CListElement  *le;
	
	for( le = m_head; le != NULL; le = le->m_next )
		if( compare( le->m_item, context ))
		    return( le );
	return (NULL);
	}

void  * CList::GetHead(void)
	{
	return m_head->m_item;
	}

void  * CList::GetTail(void)
	{
	return m_tail->m_item;
	}
	
CListElement  * CList::GetHeadPosition(void)
	{
	return m_head;
	}
	
CListElement  * CList::GetTailPosition(void)
	{
	return m_tail;
	}
	
void  * CList::GetNext( CLISTPOSITION& le )
	{
	void  *temp;
	
	temp = le->m_item;
	le = le->m_next;
	
	return temp;
	}
	
void  * CList::GetPrev( CLISTPOSITION& le )
	{
	void  *temp;
	
	temp = le->m_item;
	le = le->m_prev;
	
	return temp;
	}
	
S32 CList::GetCount(void)
	{
	return m_count;
	}

U32 CList::IsEmpty(void)
	{
	if (m_count == 0)
		return 1;
	else
		return 0;
	}
	
void *  CList::GetAt(CListElement  *elem)
	{
	return (elem->m_item);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\filestf.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// base buffered file input
#include "stdafx.h"
#ifndef __MWERKS__
#else
#define tellg() rdbuf()->pubseekoff(0,ios::cur).offset()	// thanx bjs
#endif

#include <ctype.h>
#include "vcenv.h"
#include "filestf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

P_FILEBUF OpenFile( istream *f )
    {
    P_FILEBUF temp;

	temp = new FILEBUF;
	// if (temp == 0)
	// 	fprintf(stderr, "failed buffer allocation\n");
	temp->nextChar = 0;
	temp->lastChar = 0;
	temp->strm = f;

	if (temp->strm != 0)
		{
		//temp->lastChar = fread( temp->buf, 1, 4096, temp->strm );
		//temp->nextChar = 0;
		temp->nextChar = temp->lastChar = 4096;
		}
	return(temp);
    }

void CloseFile( P_FILEBUF fb )
    {
	//fclose( fb->strm );
	delete fb;
    }

BOOL FileGetC( P_FILEBUF file, P_U8 c )
    {
	if (file->nextChar == file->lastChar)
		{
		if (file->lastChar != 4096)
			return FALSE;
		long pos = file->strm->tellg();
		file->strm->read(file->buf, 4096);
		file->lastChar = file->strm->tellg() - pos;
		if (file->lastChar == 0)
			return FALSE;
		file->nextChar = 0;
		}
    *c = file->buf[file->nextChar];
	file->nextChar += 1;
    return TRUE;
    }

BOOL FilePeekC( P_FILEBUF file, P_U8 c )
    {
	if (file->nextChar == file->lastChar)
		{
		if (file->lastChar != 4096)
			return FALSE;
		long pos = file->strm->tellg();
		file->strm->read(file->buf, 4096);
		file->lastChar = file->strm->tellg() - pos;
		if (file->lastChar == 0)
			return FALSE;
		file->nextChar = 0;
		}
    *c = file->buf[file->nextChar];
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\clist.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Class List

#ifndef __CLIST_H__
#define __CLIST_H__

#include "vcenv.h"

class CListElement
	{
public:
	CListElement  *m_prev;
	CListElement  *m_next;
	void  *m_item;
	CListElement();
	~CListElement();
	};
	
typedef CListElement *CLISTPOSITION;
typedef int (*CListSearchFunc)(void *item, void *context);

class CList
    {
protected:
    CListElement  *m_head;
    CListElement  *m_tail;
    U32 m_count;
public:
	void  *GetHead(void);
	void  *GetTail(void);
	CListElement  *GetHeadPosition(void);
	CListElement  *GetTailPosition(void);
    CListElement  *Find( void  * );
    CListElement *Search(CListSearchFunc compare, void *context);
    void  *GetNext(CLISTPOSITION& );
    void  *GetPrev(CLISTPOSITION& );
    void RemoveAt( CListElement  * );
    void RemoveNoDel( CListElement  * );
    void RemoveAll(void);
    void  *GetAt( CListElement  * );
    void InsertAfter( CListElement  *, CListElement  * );
    CListElement  *InsertAfter( CListElement  *, void * );
    void InsertBefore( CListElement  *, CListElement  * );
    CListElement  *InsertBefore( CListElement  *, void * );
    void InsertAtTail( CListElement  * );
    void InsertAtHead( CListElement  * );
    CListElement  *AddTail( void  * );
    CListElement  *AddHead( void  * );
    void MoveToTail( CListElement  * );
    void MoveToHead( CListElement  * );
    S32 GetCount(void);
    U32 IsEmpty(void);
    CList();
    ~CList();
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\childfrm.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// childfrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\filestf.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/


#ifndef __FILESTF_H__
#define __FILESTF_H__

#include <iostream.h>


typedef struct
	{
	istream *strm;
	U8 buf[4096];
	S32 nextChar;
	S32 lastChar;
	} FILEBUF, *P_FILEBUF, **PP_FILEBUF;
	
P_FILEBUF OpenFile( istream *f );
void CloseFile( P_FILEBUF fb );
BOOL FileGetC( P_FILEBUF file, P_U8 c );
BOOL FilePeekC( P_FILEBUF file, P_U8 c );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\gifread.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/


#ifndef __GIFREAD_H__
#define __GIFREAD_H__

#include "filestf.h"
#include "vcenv.h"

typedef struct
	{
	U8 r, g, b, u;
	} GIFRGB, *P_GIFRGB, **PP_GIFRGB;
	
typedef struct
	{
	S16 r, g, b, u;
	} ERRGB, *P_ERRGB, **PP_ERRGB;

typedef struct
	{
	U8 sig[3];
	U8 version[3];
	} GIFHEADER, *P_GIFHEADER, **PP_GIFHEADER;

typedef struct
	{
	GIFRGB *globalColorTable;
	U16 width;
	U16 height;
	U16 globalColorTableSize;
	U8 flags;
	BOOL hasGlobalColorTable;
	U8 colorResolution;
	BOOL sorted;
	U8 backgroundColor;
	U8 aspect;
	} GIFLOGICALSCREENDESCRIPTOR, *P_GIFLOGICALSCREENDESCRIPTOR, **PP_GIFLOGICALSCREENDESCRIPTOR;

typedef struct
	{
	U16 delayTime;
	U8 flags;
	BOOL hasTransparency;
	U8 transparentColor;
	} GIFGRAPHICCONTROLEXTENSION, *P_GIFGRAPHICCONTROLEXTENSION, **PP_GIFGRAPHICCONTROLEXTENSION;

typedef struct
	{
	U8 *data;
	U16 gridLeft, gridTop, gridWidth, gridHeight;
	U8 cellWidth, cellHeight;
	U8 foregroundColor, backgroundColor;
	} GIFPLAINTEXTEXTENSION;

typedef struct
	{
	U8 *data;
	} GIFCOMMENT;

typedef struct
	{
	U8 *data;
	U8 ID[8];
	U8 auth[3];
	} GIFAPPLICATIONEXTENSION;

typedef struct
	{
	U8 *data;
	GIFRGB *localColorTable;
	U16 left, top, width, height;
	U16 localColorTableSize;
	BOOL hasLocalColorTable;
	BOOL interlaced;
	BOOL sorted;
	U8 flags;
	} GIFIMAGEDESCRIPTOR, *P_GIFIMAGEDESCRIPTOR, **PP_GIFIMAGEDESCRIPTOR;

typedef struct
	{
	GIFHEADER header;
	GIFLOGICALSCREENDESCRIPTOR screen;
	} GIFENTITY, *P_GIFENTITY, **PP_GIFENTITY;

typedef struct
	{
	GIFENTITY *entity;
	GIFGRAPHICCONTROLEXTENSION gext;
	GIFIMAGEDESCRIPTOR image;
	} GIFIMAGE, *P_GIFIMAGE, **PP_GIFIMAGE;

#define MAX_CODES   4095

	
class CGifReader
	{
	CDC *m_maskDC;
	P_FILEBUF m_file;
	P_GIFRGB m_currentColorTable;
	BOOL m_dither;
	BOOL m_errorDiffuse;
	BOOL m_buildMask;
	BOOL m_interlaced;
	U16 m_left, m_top, m_width, m_height;
	U16 m_lineCount;
	U16 m_pass;
	S32 m_bitsPerPixel;
	S32 m_badCodeCount;
	U32 m_currentSize;
	U32 m_clear;
	U32 m_ending;
	U32 m_newCodes;
	U32 m_topSlot;
	U32 m_slot;
    U32 m_availableBytes;              /* # bytes left in block */
    U32 m_availableBits;                /* # bits left in current byte */
    U8 m_currentByte;                           /* Current byte */
	U8 *m_pBytes;                      /* Pointer to next byte in block */
    U8 m_byteBuff[258];               /* Current block */
	U8 m_stack[MAX_CODES + 1];            /* Stack for storing pixels */
	U8 m_suffix[MAX_CODES + 1];           /* Suffix table */
	U16 m_prefix[MAX_CODES + 1];           /* Prefix linked list */ 
	U8 m_transparentIndex;
	P_ERRGB m_errRow;
	U8 *m_imageBytes;
	BOOL GetBlockByte(P_U8 b);
    BOOL ReadHeader( P_FILEBUF file, GIFHEADER *header );
    BOOL ReadColorTable( P_FILEBUF file, U16 count, P_GIFRGB ct );    
	BOOL ReadLogicalScreenDescriptor( P_FILEBUF file,
								  P_GIFLOGICALSCREENDESCRIPTOR screen );
	BOOL ReadImageDescriptor( P_FILEBUF file, P_GIFIMAGEDESCRIPTOR image );
	BOOL ReadGraphicControlExtension( P_FILEBUF file,
									P_GIFGRAPHICCONTROLEXTENSION ext );
	BOOL TrashDataSubBlocks( P_FILEBUF file );
	BOOL TrashCommentExtension( P_FILEBUF file );
	BOOL TrashApplicationExtension( P_FILEBUF file );
	BOOL TrashPlainTextExtension( P_FILEBUF file );
	S16 InitDecoder(S16 size);
	BOOL GetNextCode(P_U32 code);
	BOOL Decode(U32 linewidth);
	BOOL OutputLine(U8 *pixels, U32 linelen); 
	BOOL OutputLineD(U8 *pixels, U32 linelen); 
	BOOL OutputLineE(U8 *pixels, U32 linelen); 
	BOOL OutputLineDefered(U8 *pixels, U32 linelen); 
public:
	CDC *m_pDC;
	BOOL GetGifSize(istream *istrm, P_FCOORD size, BOOL *transparency);
	BOOL ReadGif(istream *istrm, CDC *pDC, CDC *maskDC);
	CGifReader();
	~CGifReader();
	};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\gifread.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// the gif file reader

	#include "stdafx.h"
#ifndef __MWERKS__				// gca 12/19/95
	#include <malloc.h>
#else
	#include "WindowsToMac.h"
	#include <stdlib.h>
#endif							// gca 12/19/95

#include <ctype.h>
#include "vcenv.h"
#include "filestf.h"
#include "gifread.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

U8 DitherRGB( P_GIFRGB grgb, U32 x, U32 y );	// gca 12/19/95
U8 MapRGB( P_GIFRGB grgb, U32 x, U32 y );		// gca  12/19/95

BOOL CGifReader::ReadHeader( P_FILEBUF file, GIFHEADER *header )
	{
	S32 i;

	for (i = 0; i < 3; i++)
		if (!FileGetC( file, &(header->sig[i]) ))
			return FALSE;
	for (i = 0; i < 3; i++)
		if (!FileGetC( file, &(header->version[i]) ))
			return FALSE;
	if((header->sig[0] == 'G') && (header->sig[1] == 'I') && (header->sig[2] == 'F'))
		{
		if (header->version[0] == '8')
			return TRUE;
		else
			return FALSE;
		}
	else
		return FALSE;
	}

/*
void DumpHeader( GIFHEADER *header )
	{
	S32 i;

	for (i = 0; i < 3; i++)
		printf( "%c", header->sig[i]);
	printf( "\n");
	for (i = 0; i < 3; i++)
		printf( "%c", header->version[i]);
	printf( "\n");
	}
*/

BOOL CGifReader::ReadColorTable( P_FILEBUF file, U16 count, P_GIFRGB ct )
	{
	U32 i;

	for (i = 0; i < count; i++)
		{
		if (!FileGetC( file, &(ct->r) ))
			return FALSE;
		if (!FileGetC( file, &(ct->g) ))
			return FALSE;
		if (!FileGetC( file, &(ct->b) ))
			return FALSE;
		// printf( "r %d g %d b %d\n", (int )ct->r, (int )ct->g, (int )ct->b );
		ct++;
		}
	return TRUE;
	}

BOOL CGifReader::ReadLogicalScreenDescriptor( P_FILEBUF file,
								  P_GIFLOGICALSCREENDESCRIPTOR screen )
	{
	S32 i;
	U8 b;

	screen->width = 0;
	screen->height = 0;

	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		screen->width |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		screen->height |= ((U16 )b) << (i << 3);
		}
	if (!FileGetC( file, &(screen->flags) ))
		return FALSE;
	screen->hasGlobalColorTable = screen->flags >> 7;
	screen->colorResolution = (screen->flags >> 4) & 0x07;
	screen->sorted = (screen->flags >> 3) & 0x01;
	screen->globalColorTableSize = ((U16 )0x01) << ((screen->flags & 0x07) + 1);
	if (!FileGetC( file, &(screen->backgroundColor) ))
		return FALSE;
	if (!FileGetC( file, &(screen->aspect) ))
		return FALSE;
	if (screen->hasGlobalColorTable)
		{
		screen->globalColorTable = new GIFRGB[screen->globalColorTableSize];
		ReadColorTable( file, screen->globalColorTableSize,
								 screen->globalColorTable );
		}
	else
		screen->globalColorTable = NULL;
#if __MWERKS__
	m_pDC->CreateOffscreen(screen->width,screen->height);	// create 32 bit color offscreen!!!
	m_pDC->FocusTheWorld();	// the active port!!

#endif
	return TRUE;
	}

/*
void DumpLSD( GIFLOGICALSCREENDESCRIPTOR *screen )
	{
	printf("width %d height %d \n", (int )screen->width, (int )screen->height );
	printf("has table %d color res %d sorted %d size %d \n",
			  (int )screen->hasGlobalColorTable, (int )screen->colorResolution,
			  (int )screen->sorted, (int )screen->globalColorTableSize );
	printf("background %d aspect %d \n", (int )screen->backgroundColor,
			  (int )screen->aspect);
	}
*/

BOOL CGifReader::ReadImageDescriptor( P_FILEBUF file, P_GIFIMAGEDESCRIPTOR image )
	{
	S32 i;
	U8 b;

	image->left = 0;
	image->top = 0;
	image->width = 0;
	image->height = 0;

	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->left |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->top |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->width |= ((U16 )b) << (i << 3);
		}
	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		image->height |= ((U16 )b) << (i << 3);
		}
	m_left = image->left;
	m_top = image->top;
	m_width = image->width;
	m_height = image->height;
	if (!FileGetC( file, &(image->flags )))
		return FALSE;
	image->hasLocalColorTable = image->flags >> 7;
	image->interlaced = (image->flags >> 6) & 0x01;
	m_interlaced = image->interlaced;
	image->sorted = (image->flags >> 5) & 0x01;
	image->localColorTableSize = ((U16 )0x01) << ((image->flags & 0x07) + 1);
	if (image->hasLocalColorTable)
		{
		image->localColorTable = new GIFRGB[image->localColorTableSize];
		ReadColorTable( file, image->localColorTableSize,
								 image->localColorTable );
		}	
	else
		image->localColorTable = NULL;
	return TRUE;
	}

/*
void DumpID( GIFIMAGEDESCRIPTOR *image )
	{
	printf("left %d top %d \n", (int )image->left, (int )image->top );
	printf("width %d height %d \n", (int )image->width, (int )image->height );
	printf("has table %d sorted %d size %d \n",
			  (int )image->hasLocalColorTable,
			  (int )image->sorted, (int )image->localColorTableSize );
	printf("interlaced %d \n", (int )image->interlaced);
	}
*/
BOOL CGifReader::ReadGraphicControlExtension( P_FILEBUF file,
									P_GIFGRAPHICCONTROLEXTENSION ext )
	{
	S32 i;
	U8 b;

	if (!FileGetC( file, &b))
		return FALSE;
	if (b != 4)
		return FALSE;
	
	if (!FileGetC( file, &b))
		return FALSE;
	ext->flags = b;
	if (ext->flags & 0x01)
		m_buildMask = ext->hasTransparency = TRUE;
	else
	    ext->hasTransparency = FALSE;

	for (i = 0; i < 2; i++)
		{
		if (!FileGetC( file, &b ))
			return FALSE;
		ext->delayTime |= ((U16 )b) << (i << 3);
		}

	if (!FileGetC( file, &b))
		return FALSE;
	ext->transparentColor = b;
	m_transparentIndex = b;
	if (!FileGetC( file, &b))
		return FALSE;
	if (b == 0)
		return TRUE;
	else
		return FALSE;
	}
	
BOOL CGifReader::TrashDataSubBlocks( P_FILEBUF file )
	{
	S32 i;
	U8 b, count;
    
    if (!FileGetC( file, &count))
    	return FALSE;
    while (count)
    	{
    	for (i = 0; i < count; i++)
			if (!FileGetC( file, &b))
				return FALSE;
    	if (!FileGetC( file, &count))
    		return FALSE;
    	}
    return TRUE;
	}

BOOL CGifReader::TrashCommentExtension( P_FILEBUF file )
	{
	TrashDataSubBlocks( file );
    return TRUE;
	}
	
BOOL CGifReader::TrashPlainTextExtension( P_FILEBUF file )
	{
	S32 i;
	U8 b;
    
    for (i = 0; i < 12; i++)
		if (!FileGetC( file, &b))
			return FALSE;
	TrashDataSubBlocks( file );
    return TRUE;
	}
	
BOOL CGifReader::TrashApplicationExtension( P_FILEBUF file )
	{
	S32 i;
	U8 b;
    
    for (i = 0; i < 11; i++)
		if (!FileGetC( file, &b))
			return FALSE;
	TrashDataSubBlocks( file );
    return TRUE;
	}


/* Another try... but this doesn't seem too good
const U8 FireOrder[64] = {
59,11,43,31,  50,34, 2,30,
35,27,63, 3,  10,18,58,46,
 7,51,19,39,  54,42,26,14,
23,47,15,55,  22, 6,38,62,

49,33, 1,29,  60,12,44,33,
 9,17,57,45,  36,28,64, 4,
53,41,25,13,   8,52,20,40,
21, 5,37,61,  24,48,16,56 }; */

/* this one is reverse-symetric but it doesn't seem to be better ???  */

const U8 FireOrder[64] = {
 2,53,10,61,   3,56,11,64,
37,18,41,26,  40,19,44,27,
14,57, 6,49,  15,60, 7,52,
45,30,33,22,  48,31,36,23,

 4,55,12,63,   1,54, 9,62,
39,20,43,28,  38,17,42,25,
16,59, 8,51,  13,58, 5,50,
47,32,35,24,  46,29,34,21 };

U8 DitherRGB( P_GIFRGB grgb, U32 x, U32 y )
	{
	U16 RedS, GreenS, BlueS;
	U8 RedP, GreenP, BlueP;
	U8 index;
	
	RedS = (U16 )grgb->r + 1;
	RedS += (RedS >> 2);
	GreenS = (U16 )grgb->g + 1;
	GreenS += (GreenS >> 2);
	BlueS = (U16 )grgb->b + 1;
	BlueS += (BlueS >> 2);

	RedP = (U8 )(RedS >> 6);
	GreenP = (U8 )(GreenS >> 6);
	BlueP = (U8 )(BlueS >> 6);

	if ((RedP < 5) && (FireOrder[((y & 7) << 3)|(x & 7)] <= ((U8 )(RedS & 63))))
		RedP += 1;
	if ((GreenP < 5) && (FireOrder[((y & 7) << 3)|(x & 7)] <= ((U8 )(GreenS & 63))))
		GreenP += 1;
	if ((BlueP < 5) && (FireOrder[((y & 7) << 3)|(x & 7)] <= ((U8 )(BlueS & 63))))
		BlueP += 1;

	index = ((RedP << 5)+(RedP << 2)) + ((GreenP << 2)+(GreenP << 1)) + BlueP;
		
	return index;
    }

U8 MapRGB( P_GIFRGB grgb, U32 x, U32 y )
	{
	U16 RedS, GreenS, BlueS;
	U8 RedP, GreenP, BlueP;
	U8 index;
	
	RedS = (U16 )grgb->r + 1;
	RedS += (RedS >> 2);
	GreenS = (U16 )grgb->g + 1;
	GreenS += (GreenS >> 2);
	BlueS = (U16 )grgb->b + 1;
	BlueS += (BlueS >> 2);

	RedP = (U8 )(RedS >> 6);
	GreenP = (U8 )(GreenS >> 6);
	BlueP = (U8 )(BlueS >> 6);
	index = ((RedP << 5)+(RedP << 2)) + ((GreenP << 2)+(GreenP << 1)) + BlueP;
		
	return index;
    }

extern LOGPALETTE *bublp;
extern CPalette bubPalette;

// stores the pixels to m_imageBytes so that we can do an error diffusion before display
BOOL CGifReader::OutputLineDefered(U8 *pixels, U32 linelen)
	{
	U32 i;
	U8 *tmp;
	
	tmp = m_imageBytes + (m_lineCount * linelen);
	
	for( i = 0; i < linelen; i++)
		tmp[i] = pixels[i];
	
	
    if (m_interlaced)  // this is always true
    	{
    	if ((m_pass == 0) || (m_pass == 1))
    		{
    		m_lineCount += 8;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			if (m_pass == 1)
    				m_lineCount = m_top + 4;
    			else if (m_pass == 2)
    				m_lineCount = m_top + 2;
    			}
    		}
    	else if (m_pass == 2)
    		{
    		m_lineCount += 4;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			m_lineCount = m_top + 1;
    			}
    		}
    	else /* m_pass == 3 */
    		{
    		m_lineCount += 2;
    		}
    	}
    else	
		m_lineCount += 1;
	return TRUE;
	}

// this version has my trial error-diffusion which has potential... 
// if it is going to be used, it could probably stand some simple optimization
BOOL CGifReader::OutputLineE(U8 *pixels, U32 linelen)
	{
#ifndef __MWERKS__
	COLORREF color;
#else
	RGBCOLOR color;		// gca 1/21/96
#endif
	U32 i, j;
	GIFRGB grgb;
	U8 pix, index;
	S16 rerr, gerr, berr;
	S16 rerr1, gerr1, berr1;
	S16 rerr2, gerr2, berr2;
	ERRGB hold;
	
	rerr = gerr = berr = 0;
	rerr1 = gerr1 = berr1 = 0;
	rerr2 = gerr2 = berr2 = 0; 
	
	hold = m_errRow[1];
	
	m_errRow[0].r = 0;
	m_errRow[0].g = 0;
	m_errRow[0].b = 0;
	m_errRow[1].r = 0;
	m_errRow[1].g = 0;
	m_errRow[1].b = 0;
	
    j = 1;
	
	if (m_buildMask && m_maskDC)
		{
		for (i = 0; i < linelen; i++)
			{
			pix = pixels[i];
			grgb = m_currentColorTable[pix];
			if (m_dither)
				{
				rerr = (S16 )grgb.r + rerr1 + hold.r;
				gerr = (S16 )grgb.g + gerr1 + hold.g;
				berr = (S16 )grgb.b + berr1 + hold.b;
				if (rerr > 255)
					rerr = 255;
				else if (rerr < 0)
					rerr = 0;
				if (gerr > 255)
					gerr = 255;
				else if (gerr < 0)
					gerr = 0;
				if (berr > 255)
					berr = 255;
				else if (berr < 0)
					berr = 0;
				grgb.r = (U8 )rerr;
				grgb.g = (U8 )gerr;
				grgb.b = (U8 )berr;
				index = MapRGB(&grgb, i, m_lineCount);
				if (m_bitsPerPixel == 8)
					color = PALETTEINDEX(index);
				else
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				rerr = (S16 )grgb.r - (S16 )bublp->palPalEntry[index].peRed;
				gerr = (S16 )grgb.g - (S16 )bublp->palPalEntry[index].peGreen;
				berr = (S16 )grgb.b - (S16 )bublp->palPalEntry[index].peBlue;
				rerr2 = rerr >> 4;
				gerr2 = gerr >> 4;
				berr2 = berr >> 4;
				rerr1 = (rerr >> 1) - rerr2;
				gerr1 = (gerr >> 1) - gerr2;
				berr1 = (berr >> 1) - berr2;
				m_errRow[j-1].r += (rerr >> 3) - rerr2;
				m_errRow[j-1].g += (gerr >> 3) - gerr2;
				m_errRow[j-1].b += (berr >> 3) - berr2;
				m_errRow[j].r += (rerr >> 2) + rerr2;
				m_errRow[j].g += (gerr >> 2) + gerr2;
				m_errRow[j].b += (berr >> 2) + berr2;
				hold = m_errRow[j+1];
				m_errRow[j+1].r = rerr2;
				m_errRow[j+1].g = gerr2;
				m_errRow[j+1].b = berr2;
				j += 1;
				}
			else
				{
				color = RGB(grgb.r, grgb.g, grgb.b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				}
            if (pix == m_transparentIndex)
            	m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            else
            	m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
			}
		}
	else
		{
		for (i = 0; i < linelen; i++)
			{
			grgb = m_currentColorTable[pixels[i]];
			if (m_dither)
				{
				rerr = (S16 )grgb.r + rerr1 + hold.r;
				gerr = (S16 )grgb.g + gerr1 + hold.g;
				berr = (S16 )grgb.b + berr1 + hold.b;
				if (rerr > 255)
					rerr = 255;
				else if (rerr < 0)
					rerr = 0;
				if (gerr > 255)
					gerr = 255;
				else if (gerr < 0)
					gerr = 0;
				if (berr > 255)
					berr = 255;
				else if (berr < 0)
					berr = 0;
				grgb.r = (U8 )rerr;
				grgb.g = (U8 )gerr;
				grgb.b = (U8 )berr;
				index = MapRGB(&grgb, i, m_lineCount); 
				if (m_bitsPerPixel == 8)
					color = PALETTEINDEX(index);
				else
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				rerr = (S16 )grgb.r - (S16 )bublp->palPalEntry[index].peRed;
				gerr = (S16 )grgb.g - (S16 )bublp->palPalEntry[index].peGreen;
				berr = (S16 )grgb.b - (S16 )bublp->palPalEntry[index].peBlue;
				rerr2 = rerr >> 4;
				gerr2 = gerr >> 4;
				berr2 = berr >> 4;
				rerr1 = (rerr >> 1) - rerr2;
				gerr1 = (gerr >> 1) - gerr2;
				berr1 = (berr >> 1) - berr2;
				m_errRow[j-1].r += (rerr >> 3) - rerr2;
				m_errRow[j-1].g += (gerr >> 3) - gerr2;
				m_errRow[j-1].b += (berr >> 3) - berr2;
				m_errRow[j].r += (rerr >> 2) + rerr2;
				m_errRow[j].g += (gerr >> 2) + gerr2;
				m_errRow[j].b += (berr >> 2) + berr2;
				hold = m_errRow[j+1];
				m_errRow[j+1].r = rerr2;
				m_errRow[j+1].g = gerr2;
				m_errRow[j+1].b = berr2;
				j += 1;
				}
			else
				{
				color = RGB(grgb.r, grgb.g, grgb.b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				}

			}
		}
    if (m_interlaced)
    	{
    	if ((m_pass == 0) || (m_pass == 1))
    		{
    		m_lineCount += 8;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			if (m_pass == 1)
    				m_lineCount = m_top + 4;
    			else if (m_pass == 2)
    				m_lineCount = m_top + 2;
    			}
    		}
    	else if (m_pass == 2)
    		{
    		m_lineCount += 4;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			m_lineCount = m_top + 1;
    			}
    		}
    	else /* m_pass == 3 */
    		{
    		m_lineCount += 2;
    		}
    	}
    else	
		m_lineCount += 1;
	return TRUE;
	}

BOOL CGifReader::OutputLineD(U8 *pixels, U32 linelen)
	{
#ifndef __MWERKS__
	COLORREF color;
#else
	RGBCOLOR color;		// gca 1/21/96
#endif
	U32 i;
	P_GIFRGB grgb;
	U8 pix, index;
         	
	if (m_buildMask && m_maskDC)
		{
		if (m_dither)
			{
			if (m_bitsPerPixel == 8)
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = PALETTEINDEX(index);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
            		if (pix == m_transparentIndex)
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            		else
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
					}
				}
			else
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
            		if (pix == m_transparentIndex)
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            		else
            			m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
            		}
            	}
			}
		else
			{
			for (i = 0; i < linelen; i++)
				{
				pix = pixels[i];
				grgb = &(m_currentColorTable[pix]);
				color = RGB(grgb->r, grgb->g, grgb->b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
            	if (pix == m_transparentIndex)
            		m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(255, 255, 255));
            	else
            		m_maskDC->SetPixelV((int )i, (int )m_lineCount, RGB(0,0,0));
				}
			}
		}
	else
		{
		if (m_dither)
			{
			if (m_bitsPerPixel == 8)
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = PALETTEINDEX(index);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
					}
				}
			else
				{
				for (i = 0; i < linelen; i++)
					{
					pix = pixels[i];
					grgb = &(m_currentColorTable[pix]);
					index = DitherRGB(grgb, i, m_lineCount);
					color = RGB(bublp->palPalEntry[index].peRed, bublp->palPalEntry[index].peGreen, bublp->palPalEntry[index].peBlue);
					m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
					}
				}
			}
		else
			{
			for (i = 0; i < linelen; i++)
				{
				pix = pixels[i];
				grgb = &(m_currentColorTable[pix]);
				color = RGB(grgb->r, grgb->g, grgb->b);
				m_pDC->SetPixelV((int )i, (int )m_lineCount, color);
				}
			}
		}
    if (m_interlaced)
    	{
    	if ((m_pass == 0) || (m_pass == 1))
    		{
    		m_lineCount += 8;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			if (m_pass == 1)
    				m_lineCount = m_top + 4;
    			else if (m_pass == 2)
    				m_lineCount = m_top + 2;
    			}
    		}
    	else if (m_pass == 2)
    		{
    		m_lineCount += 4;
    		if (m_lineCount >= (m_top + m_height))
    			{
    			m_pass += 1;
    			m_lineCount = m_top + 1;
    			}
    		}
    	else /* m_pass == 3 */
    		{
    		m_lineCount += 2;
    		}
    	}
    else	
		m_lineCount += 1;
	return TRUE;
	}
     
BOOL CGifReader::OutputLine(U8 *pixels, U32 linelen)
	{
	if (m_dither && m_errorDiffuse )
		{
        if (m_interlaced)
			return OutputLineDefered(pixels, linelen);
		else
        	return OutputLineE(pixels, linelen);
        }	
    else
    	return OutputLineD(pixels, linelen);
	}

const S32 codeMask[13] = {
     0,
     0x0001, 0x0003,
     0x0007, 0x000F,
     0x001F, 0x003F,
     0x007F, 0x00FF,
     0x01FF, 0x03FF,
     0x07FF, 0x0FFF
     };

BOOL CGifReader::GetBlockByte(P_U8 b)
	{
	U8 c;
	U32 i;
    if (m_availableBytes == 0)
         {

         /* Out of bytes in current block, so read next block
          */
         m_pBytes = m_byteBuff;
		 if(!FileGetC(m_file, &c))
			return FALSE;
		 if (c == 0)
			return FALSE;
		 m_availableBytes = c;
         for (i = 0; i < m_availableBytes; ++i)
            {
            if (!FileGetC(m_file, &c))
               return FALSE;
            m_byteBuff[i] = c;
            }
         m_currentByte = *m_pBytes++;
         --m_availableBytes;
		 }
    else
		{
         m_currentByte = *m_pBytes++;
         --m_availableBytes;
		}
	*b = m_currentByte;
	return TRUE;
	}


/* This function initializes the decoder for reading a new image.
 */
S16 CGifReader::InitDecoder(S16 size)
   {
   m_currentSize = size + 1;
   m_topSlot = 1 << m_currentSize;
   m_clear = 1 << size;
   m_ending = m_clear + 1;
   m_slot = m_newCodes = m_ending + 1;
   m_availableBits = 0;
   m_availableBytes = 0;
   m_lineCount = 0;
   m_pass = 0;
   return(0);
   }

/* get_next_code()
 * - gets the next code from the GIF file.  Returns the code, or else
 * a negative number in case of file errors...
 */
BOOL CGifReader::GetNextCode(P_U32 code)
   {
   U32 ret;

   if (m_availableBits == 0)
      { 
      if (!GetBlockByte(&m_currentByte))
		 return FALSE;
      m_availableBits = 8;
      }

   ret = m_currentByte >> (8 - m_availableBits);
   while (m_currentSize > m_availableBits)
      {
	  if (!GetBlockByte(&m_currentByte))
		return FALSE;
      ret |= m_currentByte << m_availableBits;
      m_availableBits += 8;
      }
   m_availableBits -= m_currentSize;
   ret &= codeMask[m_currentSize];
   *code = ret;
   return TRUE;
   }


/* The reason we have these seperated like this instead of using
 * a structure like the original Wilhite code did, is because this
 * stuff generally produces significantly faster code when compiled...
 * This code is full of similar speedups...  (For a good book on writing
 * C for speed or for space optomisation, see Efficient C by Tom Plum,
 * published by Plum-Hall Associates...)
 */
//U8 m_stack[MAX_CODES + 1];            /* Stack for storing pixels */
//U8 m_suffix[MAX_CODES + 1];           /* Suffix table */
//U16 m_prefix[MAX_CODES + 1];           /* Prefix linked list */

/* S16 decoder(linewidth)
 *    S16 linewidth;               * Pixels per line of image *
 *
 * - This function decodes an LZW image, according to the method used
 * in the GIF spec.  Every *linewidth* "characters" (ie. pixels) decoded
 * will generate a call to OutLine(), which is a user specific function
 * to display a line of pixels.  The function gets it's codes from
 * get_next_code() which is responsible for reading blocks of data and
 * seperating them into the proper size codes.  Finally, get_byte() is
 * the global routine to read the next byte from the GIF file.
 *
 * It is generally a good idea to have linewidth correspond to the actual
 * width of a line (as specified in the Image header) to make your own
 * code a bit simpler, but it isn't absolutely necessary.
 *
 * Returns: 0 if successful, else negative.  (See ERRS.H)
 *
 */

BOOL CGifReader::Decode(U32 linewidth)
   {
   U8 *sp;
   U8 *bufptr;
   U8 *buf;
   U32 fc, oc;
   U32 c, code, bufcnt;
   U8 size, b;

   /* Initialize for decoding a new image... */
   if (!FileGetC( m_file, &b))
	  return FALSE;
   size = b;
   if (size < 2 || 9 < size)
      return FALSE;

   InitDecoder(size);

   /* Initialize in case they forgot to put in a clear code.
    * (This shouldn't happen, but we'll try and decode it anyway...)
    */
   oc = fc = 0;

   /* Allocate space for the decode buffer
    */
   buf = (U8 *)malloc(linewidth + 1);
   if (buf == NULL)
      return FALSE;

   /* Set up the stack pointer and decode buffer pointer
    */
   sp = m_stack;
   bufptr = buf;
   bufcnt = linewidth;

   /* This is the main loop.  For each code we get we pass through the
    * linked list of prefix codes, pushing the corresponding "character" for
    * each code onto the stack.  When the list reaches a single "character"
    * we push that on the stack too, and then start unstacking each
    * character for output in the correct order.  Special handling is
    * included for the clear code, and the whole thing ends when we get
    * an ending code.
    */
   while ((GetNextCode(&c)) && (c != m_ending))
      {


      /* If the code is a clear code, reinitialize all necessary items.
       */
      if (c == m_clear)
         {
         m_currentSize = size + 1;
         m_slot = m_newCodes;
         m_topSlot = 1 << m_currentSize;

         /* Continue reading codes until we get a non-clear code
          * (Another unlikely, but possible case...)
          */
         while ((GetNextCode(&c)) && (c == m_clear))
            ;

         /* If we get an ending code immediately after a clear code
          * (Yet another unlikely case), then break out of the loop.
          */
         if (c == m_ending)
            break;

         /* Finally, if the code is beyond the range of already set codes,
          * (This one had better NOT happen...  I have no idea what will
          * result from this, but I doubt it will look good...) then set it
          * to color zero.
          */
         if (c >= m_slot)
            c = 0;

         oc = fc = c;

         /* And let us not forget to put the char into the buffer... And
          * if, on the off chance, we were exactly one pixel from the end
          * of the line, we have to send the buffer to the OutLine()
          * routine...
          */
         *bufptr++ = (U8 )c;
         if (--bufcnt == 0)
            {
            if (!OutputLine(buf, linewidth))
            	{
            	free(buf);
            	return FALSE;
            	}
            bufptr = buf;
            bufcnt = linewidth;
            }
         }
      else
         {

         /* In this case, it's not a clear code or an ending code, so
          * it must be a code code...  So we can now decode the code into
          * a stack of character codes. (Clear as mud, right?)
          */
         code = c;

         /* Here we go again with one of those off chances...  If, on the
          * off chance, the code we got is beyond the range of those already
          * set up (Another thing which had better NOT happen...) we trick
          * the decoder into thinking it actually got the last code read.
          * (Hmmn... I'm not sure why this works...  But it does...)
          */
         if (code >= m_slot)
            {
            if (code > m_slot)
               ++m_badCodeCount;
            code = oc;
            *sp++ = (U8 )fc;
            }

         /* Here we scan back along the linked list of prefixes, pushing
          * helpless characters (ie. suffixes) onto the stack as we do so.
          */
         while (code >= m_newCodes)
            {
            *sp++ = m_suffix[code];
            code = m_prefix[code];
            }

         /* Push the last character on the stack, and set up the new
          * prefix and suffix, and if the required slot number is greater
          * than that allowed by the current bit size, increase the bit
          * size.  (NOTE - If we are all full, we *don't* save the new
          * suffix and prefix...  I'm not certain if this is correct...
          * it might be more proper to overwrite the last code...
          */
         *sp++ = (U8 )code;
         if (m_slot < m_topSlot)
            {
            fc = code;
            m_suffix[m_slot] = (U8 )fc;
            m_prefix[m_slot++] = (U16 )oc;
            oc = c;
            }
         if (m_slot >= m_topSlot)
            if (m_currentSize < 12)
               {
               m_topSlot <<= 1;
               ++m_currentSize;
               } 

         /* Now that we've pushed the decoded string (in reverse order)
          * onto the stack, lets pop it off and put it into our decode
          * buffer...  And when the decode buffer is full, write another
          * line...
          */
         while (sp > m_stack)
            {
            *bufptr++ = *(--sp);
            if (--bufcnt == 0)
               {
            	if (!OutputLine(buf, linewidth))
            		{
            		free(buf);
            		return FALSE;
            		}
               bufptr = buf;
               bufcnt = linewidth;
               }
            }
         }
      }
   if (bufcnt != linewidth)
		if (!OutputLine(buf, (linewidth - bufcnt)))
            {
            free(buf);
            return FALSE;
            }
   free(buf);
   if (!FileGetC( m_file, &b))
	  return FALSE;
   //printf( "should be zero %d\n", (int )b );
   return TRUE;
   }

BOOL CGifReader::GetGifSize(istream *istrm, P_FCOORD size, BOOL *transparency)
	{
	P_GIFENTITY gif;
	P_GIFIMAGE image;
	U8 code, ext;

	if (!(gif = new GIFENTITY))
		return FALSE;
	
	*transparency = FALSE;
    
   	if (!(m_file = OpenFile(istrm)))
    	{
    	delete gif;
    	return FALSE;
    	}

	if (!ReadHeader( m_file, &(gif->header) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	if (!ReadLogicalScreenDescriptor( m_file, &(gif->screen) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	while (FileGetC(m_file, &code))
		{
		if (code == 0x2C)
			{
			break;
			}
		else if (code == 0x21)
			{
			/* need to read the extension */
			if (!FileGetC(m_file, &ext))
				break;
			if (ext == 0xF9)
				{
				/* read graphic control extension */
				// printf("graphic control ext \n");
				image = new GIFIMAGE;
				image->entity = gif;
                if(!ReadGraphicControlExtension( m_file, &(image->gext) ))
                	{
					delete image;
					if (gif->screen.hasGlobalColorTable)
						delete [] gif->screen.globalColorTable;
    				delete gif;
					CloseFile( m_file );
    				return FALSE;
                	}
                
                *transparency = image->gext.hasTransparency;
                delete image;
                break;
                // this is what we are looking for... the "transparency" flag
				}
			else if (ext == 0xFE)
				{
				/* read the comment extension */
				//printf("comment ext \n");
				TrashCommentExtension( m_file );
				}
			else if (ext == 0x01)
				{
				/* read the plain text extension */
				//printf("plain text ext \n");
				TrashPlainTextExtension( m_file );
				}
			else if (ext == 0xFF)
				{
				/* read the application extension */
				//printf("application ext \n");
				TrashApplicationExtension( m_file );
				}
			else
				break;
			}
		else 
			{
			break;
			}
		
		}

	CloseFile( m_file );
	size->x = (F32 )gif->screen.width;
	size->y = (F32 )gif->screen.height;
	if (gif->screen.hasGlobalColorTable)
		delete [] gif->screen.globalColorTable;
	delete gif;
	return TRUE;
	}
	
BOOL CGifReader::ReadGif(istream *istrm, CDC *pDC, CDC *maskDC)
	{
	P_GIFENTITY gif;
	P_GIFIMAGE image;
	U8 code, ext;
	S32 i;
	U8 *tmp;
	U32 size;
    
	if (!(gif = new GIFENTITY))
		return FALSE;
    
    if (!(m_file = OpenFile(istrm)))
    	{
    	delete gif;
    	return FALSE;
    	}
    
    m_pDC = pDC;
    
    m_maskDC = maskDC;
    
    m_buildMask = FALSE;
    m_interlaced = FALSE;
    
 	m_bitsPerPixel = (S32 )m_pDC->GetDeviceCaps(BITSPIXEL);
   
	if(m_bitsPerPixel <= 8)
		{
    	m_pDC->SelectPalette( &bubPalette, 0 );
    	m_pDC->RealizePalette();
	    m_dither = TRUE;
	    m_errorDiffuse = FALSE;  // could go either way :-)
	    }
	else
	    m_dither = FALSE;
   
	if (!ReadHeader( m_file, &(gif->header) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	// DumpHeader( &(gif->header));
	if (!ReadLogicalScreenDescriptor( m_file, &(gif->screen) ))
    	{
    	delete gif;
		CloseFile( m_file );
    	return FALSE;
    	}
	// DumpLSD( &(gif->screen));
	image = new GIFIMAGE;
	image->entity = gif;
	while (FileGetC(m_file, &code))
		{
		if (code == 0x2C)
			{
			if (ReadImageDescriptor( m_file, &(image->image) ))
				{
				// DumpID( &(image->image));
				if (image->image.hasLocalColorTable)
					m_currentColorTable = image->image.localColorTable;
				else
					m_currentColorTable = gif->screen.globalColorTable;
				m_lineCount = 0;
				m_pass = 0;
				if (m_dither && m_errorDiffuse)
					{
					m_errRow = new ERRGB[ image->image.width + 2 ];
					for (i = 0; i < (S32 )(image->image.width + 2); i++)
						m_errRow[i].r = m_errRow[i].g = m_errRow[i].b = 0;
					if (m_interlaced)
						{
						size = (U32 )image->image.width;
						size = size * (U32 )image->image.height;
						m_imageBytes = (U8 *)malloc((long )size);
						}
					}
		    	if (!Decode( image->image.width ))
					{
					if (image->image.hasLocalColorTable)
						delete [] image->image.localColorTable;
					if (m_dither && m_errorDiffuse)
						{
						delete [] m_errRow;
						if (m_interlaced)
							free( m_imageBytes );
						}
					delete image;
					if (gif->screen.hasGlobalColorTable)
						delete [] gif->screen.globalColorTable;
    				delete gif;
					CloseFile( m_file );
    				return FALSE;
					}
				if (m_dither && m_errorDiffuse)
					{
					if (m_interlaced)
						{
						m_interlaced = FALSE;
						m_lineCount = 0;
						tmp = m_imageBytes;
						for( i = 0; i < (S32 )image->image.height; i++)
							{
							OutputLineE(tmp, image->image.width);
							tmp += image->image.width;
							}
						free( m_imageBytes );
						}
					delete [] m_errRow;
					}
				if (image->image.hasLocalColorTable)
					delete [] image->image.localColorTable;
				}
			else
				{
				delete image;
				if (gif->screen.hasGlobalColorTable)
					delete [] gif->screen.globalColorTable;
    			delete gif;
				CloseFile( m_file );
    			return FALSE;
				}
			}
		else if (code == 0x21)
			{
			/* need to read the extension */
			if (!FileGetC(m_file, &ext))
				break;
			if (ext == 0xF9)
				{
				/* read graphic control extension */
				// printf("graphic control ext \n");
                if (!ReadGraphicControlExtension( m_file, &(image->gext) ))
                	{
					if (image->image.hasLocalColorTable)
						delete [] image->image.localColorTable;
					delete image;
					if (gif->screen.hasGlobalColorTable)
						delete [] gif->screen.globalColorTable;
    				delete gif;
					CloseFile( m_file );
    				return FALSE;
                	}
				}
			else if (ext == 0xFE)
				{
				/* read the comment extension */
				//printf("comment ext \n");
				TrashCommentExtension( m_file );
				}
			else if (ext == 0x01)
				{
				/* read the plain text extension */
				//printf("plain text ext \n");
				TrashPlainTextExtension( m_file );
				}
			else if (ext == 0xFF)
				{
				/* read the application extension */
				//printf("application ext \n");
				TrashApplicationExtension( m_file );
				}
			else
				break;
			}
		else if (code == 0x3B)
			{
			//printf ("clean file termination \n");
			break;   /* this is the gif file terminator */
			}
		else
			{
			//printf ("bad file end %d \n", (int )code);
			break;
			}
		
		}
	if (image)
		delete image;
	CloseFile( m_file );
	if (gif->screen.hasGlobalColorTable)
		delete [] gif->screen.globalColorTable;
	delete gif;
	return TRUE;
	}

CGifReader::CGifReader()
	{
	m_maskDC = NULL;
	m_file = NULL;
	m_currentColorTable = NULL;
	m_dither = FALSE;
	m_errorDiffuse = FALSE;
	m_buildMask = FALSE;
	m_interlaced = FALSE;
	m_left = m_top = m_width = m_height = 0;
	m_lineCount = 0;
	m_pass = 0;
	m_bitsPerPixel = 0;
	m_badCodeCount = 0;
	m_currentSize = 0;
	m_clear = 0;
	m_ending = 0;
	m_newCodes = 0;
	m_topSlot = 0;
	m_slot = 0;
    m_availableBytes = 0;
    m_availableBits = 0;
    m_currentByte = 0;
	m_pBytes = NULL;
	m_transparentIndex = 0;
	m_errRow = NULL;
	m_imageBytes = NULL;
	m_pDC = NULL;
	}
	
CGifReader::~CGifReader()
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mainfrm.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnEditPaste();
	afx_msg void OnEditPasteSpecial();
	afx_msg void OnDebugShowCallCenter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mainfrm.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "VC.h"
#include "mainfrm.h"
#include "callcntr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
	ON_COMMAND(ID_DEBUG_SHOWCALLCENTER, OnDebugShowCallCenter)
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_INDEX, CMDIFrameWnd::OnHelpIndex)
	ON_COMMAND(ID_HELP_USING, CMDIFrameWnd::OnHelpUsing)
	ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpIndex)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars
	
static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY /*| CBRS_SIZE_DYNAMIC*/);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	/*
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar); */

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnEditPaste() 
{
	SendMessage(WM_COMMAND, ID_FILE_NEW);
	// now the newly active view will pick up the following command...
	SendMessage(WM_COMMAND, ID_EDIT_PASTE);
}

void CMainFrame::OnEditPasteSpecial() 
{
	SendMessage(WM_COMMAND, ID_FILE_NEW);
	// now the newly active view will pick up the following command...
	SendMessage(WM_COMMAND, ID_EDIT_PASTE_SPECIAL);
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) 
{
	cs.style = WS_OVERLAPPED | WS_CAPTION | FWS_ADDTOTITLE
		| WS_THICKFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_MAXIMIZE;
	
	return CMDIFrameWnd::PreCreateWindow(cs);
}

void CMainFrame::OnDebugShowCallCenter() 
{
	CCallCenter cc;
	cc.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mime.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __MIME_H__
#define __MIME_H__

#include "parse.h"

extern int mime_lineNum; /* line number for syntax error */
extern int mime_numErrors;

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL Parse_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card		/* Out */
	);

extern BOOL Parse_Many_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

// If successful, the file's seek position is left at the end of the
// parsed card.  If not successful, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_MIME_FromFile(
	CFile *file,		/* In */
	CVCard **card		/* Out */
	);

// This function parses as many cards as possible, in sequence, until EOF
// is reached or a fatal syntax error occurs.  It returns TRUE if it
// successfully parsed at least one card, and in this case the file's
// seek position is left where the parser stopped (at EOF or a syntax
// error).  If FALSE is returned, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_Many_MIME_FromFile(
	CFile *file,		/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

#ifdef __cplusplus
};
#endif

#endif // __MIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\mime_tab.cpp ===
//#ifndef __MWERKS__
#include "stdafx.h"
//#endif
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.10 (Berkeley) 09/07/95 swb";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 10
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#ifdef __cplusplus
#define CFUNCTIONS 		extern "C" {
#define END_CFUNCTIONS	}
#else
#define CFUNCTIONS
#define END_CFUNCTIONS
#endif
#define yyparse mime_parse
#define yylex mime_lex
#define yyerror mime_error
#define yychar mime_char
#define p_yyval p_mime_val
#undef yyval
#define yyval (*p_mime_val)
#define p_yylval p_mime_lval
#undef yylval
#define yylval (*p_mime_lval)
#define yydebug mime_debug
#define yynerrs mime_nerrs
#define yyerrflag mime_errflag
#define yyss mime_ss
#define yyssp mime_ssp
#define yyvs mime_vs
#define yyvsp mime_vsp
#define yylhs mime_lhs
#define yylen mime_len
#define yydefred mime_defred
#define yydgoto mime_dgoto
#define yysindex mime_sindex
#define yyrindex mime_rindex
#define yygindex mime_gindex
#define yytable mime_table
#define yycheck mime_check
#define yyname mime_name
#define yyrule mime_rule
#define YYPREFIX "mime_"
#line 2 "mime.y"

/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

/*
To invoke this parser, see the "Public Interface" section below.

This MS/V parser accepts input such as the following:
	[vCard
	O=AT&T/Versit;
	FN=Roland H. Alden
	TITLE=Consultant (Versit Project Office)
	N=Alden;Roland
	A:DOM,POSTAL,PARCEL,HOME,WORK=Suite 2208;One Pine Street;San Francisco;CA;94111;U.S.A.
	A.FADR:DOM,POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111
	A.FADR:POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111\
	U.S.A.
	B.T:HOME,WORK,PREF,MSG=+1 (415) 296-9106
	C.T:WORK,FAX=+1 (415) 296-9016
	D.T:MSG,CELL=+1 (415) 608-5981
	E.EMAIL:WORK,PREF,INTERNET=sf!rincon!ralden@alden.attmail.com
	F.EMAIL:INTERNET=ralden@sfgate.com
	G.EMAIL:HOME,MCIMail=242-2200
	PN=ROW-LAND ALL-DEN
	PN:WAV,BASE64=<bindata>
		UklGRtQ4AABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0Ya84AACAgoSD
		...
		e319fYCAg4WEhIAA
	</bindata>
	]

For the purposes of the following grammar, a LINESEP token indicates either
a \r char (0x0D), a \n char (0x0A), or a combination of one of each,
in either order (\r\n or \n\r).  This is a bit more lenient than the spec.
*/


#ifdef _WIN32
#include <wchar.h>
#else
#include "wchar.h"
#endif
#include <string.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include "clist.h"
#include "vcard.h"
#include "mime.h"

#if defined(_WIN32) || defined(__MWERKS__)
#define HNEW(_t, _n) new _t[_n]
#define HFREE(_h) delete [] _h
#else
#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1)
/*#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1); {char buf[40]; sprintf(buf, "_halloc(%ld)\n", _n); Parse_Debug(buf);}*/
#define HFREE(_h) _hfree(_h)
#endif


/****  Types, Constants  ****/

#define YYDEBUG			1		/* 1 to compile in some debugging code */
#define MAXTOKEN		256		/* maximum token (line) length */
#define MAXFLAGS		((MAXTOKEN / 2) / sizeof(char *))
#define YYSTACKSIZE 	50
#define MAXASSOCKEY		24
#define MAXASSOCVALUE	64
#define MAXCARD			2		/* max # of nested cards parseable */
								/* (includes outermost) */
typedef enum {none, sevenbit, qp, base64} MIME_ENCODING;

typedef struct {
	const char* known[MAXFLAGS];
	char extended[MAXTOKEN / 2];
} PARAMS_STRUCT;

typedef struct {
	char key[MAXASSOCKEY];
	char value[MAXASSOCVALUE];
} AssocEntry;	/* a simple key/value association, impl'd using CList */

/* some fake property names that represent special cases */
static const char* mime_fam_given		= "family;given";
static const char* mime_orgname_orgunit	= "org_name;org_unit";
static const char* mime_address			= "six part address";

static const char* propNames[] = {
	vcLogoProp,
	vcPhotoProp,
	vcDeliveryLabelProp,
	vcFullNameProp,
	vcTitleProp,
	vcPronunciationProp,
	vcLanguageProp,
	vcTelephoneProp,
	vcEmailAddressProp,
	vcTimeZoneProp,
	vcLocationProp,
	vcCommentProp,
	vcURLProp,
	vcCharSetProp,
	vcLastRevisedProp,
	vcUniqueStringProp,
	vcPublicKeyProp,
	vcMailerProp,
	vcAgentProp,
	vcBirthDateProp,
	vcBusinessRoleProp,
	NULL
};

static const char *mime_addrProps[] = {
	vcPostalBoxProp,
	vcExtAddressProp,
	vcStreetAddressProp,
	vcCityProp,
	vcRegionProp,
	vcPostalCodeProp,
	vcCountryNameProp,
	NULL
};

static const char *mime_nameProps[] = {
	vcFamilyNameProp,
	vcGivenNameProp,
	vcAdditionalNamesProp,
	vcNamePrefixesProp,
	vcNameSuffixesProp,
	NULL
};

static const char *mime_orgProps[] = {
	vcOrgNameProp,
	vcOrgUnitProp,
	vcOrgUnit2Prop,
	vcOrgUnit3Prop,
	vcOrgUnit4Prop,
	NULL
};


/****  Global Variables  ****/

int mime_lineNum, mime_numErrors; /* yyerror() can use these */

static S32 curPos, inputLen;
static int pendingToken;
static const char *inputString;
static CFile* inputFile;
static BOOL paramExp, inBinary, semiSpecial;
static MIME_ENCODING expected;
static char __huge *longString;
static S32 longStringLen, longStringMax;
static CList* global_vcList;

static CVCard *cardBuilt;
static CVCard* cardToBuild[MAXCARD];
static int curCard;
static CVCNode *bodyToBuild;


/****  External Functions  ****/

CFUNCTIONS

extern void Parse_Debug(const char *s);
extern void yyerror(char *s);

END_CFUNCTIONS


/****  Private Forward Declarations  ****/

CFUNCTIONS

/* A helpful utility for the rest of the app. */
extern CVCNode* FindOrCreatePart(CVCNode *node, const char *name);

static const char* StrToProp(const char* str);
static int StrToParam(const char *s, PARAMS_STRUCT *params);
static void StrCat(char *dst, const char *src1, const char *src2);
static void ExpectValue(PARAMS_STRUCT* params);
static BOOL Parse_Assoc(
	const char *groups, const char *prop, PARAMS_STRUCT *params,
	char *value);
static BOOL Parse_Agent(
	const char *groups, const char *prop, PARAMS_STRUCT *params,
	CVCard *agentCard);
int yyparse();
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len);
static BOOL PushVCard();
static CVCard* PopVCard();
static int flagslen(const char **params);
static BOOL FlagsHave(PARAMS_STRUCT *params, const char *propName);
static void AddBoolProps(CVCNode *node, PARAMS_STRUCT *params);

END_CFUNCTIONS

#line 249 "mime.y"
typedef union
{
	char str[MAXTOKEN];
	PARAMS_STRUCT params;
	CVCard *vCard;
} YYSTYPE;
#line 299 "mime_tab.cpp"
#define EQ 257
#define COLON 258
#define DOT 259
#define SEMI 260
#define SPACE 261
#define HTAB 262
#define LINESEP 263
#define NEWLINE 264
#define VCARD 265
#define TERM 266
#define BEGIN 267
#define END 268
#define TYPE 269
#define VALUE 270
#define ENCODING 271
#define WORD 272
#define XWORD 273
#define STRING 274
#define QP 275
#define B64 276
#define PROP 277
#define PROP_AGENT 278
#define LANGUAGE 279
#define CHARSET 280
#define INLINE 281
#define URL 282
#define CONTENTID 283
#define SEVENBIT 284
#define QUOTEDP 285
#define BASE64 286
#define DOM 287
#define INTL 288
#define POSTAL 289
#define PARCEL 290
#define HOME 291
#define WORK 292
#define PREF 293
#define VOICE 294
#define FAX 295
#define MSG 296
#define CELL 297
#define PAGER 298
#define BBS 299
#define MODEM 300
#define CAR 301
#define ISDN 302
#define VIDEO 303
#define AOL 304
#define APPLELINK 305
#define ATTMAIL 306
#define CIS 307
#define EWORLD 308
#define INTERNET 309
#define IBMMAIL 310
#define MSN 311
#define MCIMAIL 312
#define POWERSHARE 313
#define PRODIGY 314
#define TLX 315
#define X400 316
#define GIF 317
#define CGM 318
#define WMF 319
#define BMP 320
#define MET 321
#define PMB 322
#define DIB 323
#define PICT 324
#define TIFF 325
#define ACROBAT 326
#define PS 327
#define JPEG 328
#define QTIME 329
#define MPEG 330
#define MPEG2 331
#define AVI 332
#define WAVE 333
#define AIFF 334
#define PCM 335
#define X509 336
#define PGP 337
#define YYERRCODE 256
short mime_lhs[] = {                                        -1,
   18,   18,   18,   19,   19,   20,   20,   20,   20,   20,
   20,   20,    0,    0,    0,    0,   21,   23,   26,   17,
   24,   24,   28,   27,   29,   27,   27,   27,   27,   27,
    9,   10,   10,   11,   11,   11,   11,   11,   11,   11,
   11,   11,   11,   12,   12,   13,   13,   14,   14,   15,
   15,   16,   16,   16,   16,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    2,    2,    2,    2,
    1,    1,    1,    3,    3,    4,    4,    7,    7,   30,
   30,   30,   30,   32,   32,   22,   22,   25,   25,    5,
    5,    5,    5,    6,    6,   31,
};
short mime_len[] = {                                         2,
    3,    2,    1,    2,    1,    2,    2,    2,    2,    2,
    1,    1,    3,    2,    2,    1,    0,    0,    0,   17,
    3,    1,    0,    6,    0,    6,    7,    7,    2,    2,
    4,    5,    1,    5,    1,    1,    1,    1,    1,    1,
    5,    5,    5,    5,    1,    5,    1,    5,    1,    5,
    1,    5,    5,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    4,    3,    1,    2,
    2,    2,    1,    4,    3,    3,    1,    1,    1,    2,
    2,    1,    1,    2,    1,    1,    1,    1,    1,    2,
    3,    1,    1,    3,    1,    0,
};
short mime_defred[] = {                                      0,
    0,   11,   12,    0,    0,    3,    0,    0,    5,   10,
    9,    0,    6,    7,    8,    2,    0,    0,    4,   17,
    1,    0,    0,  118,    0,  119,   18,    0,  125,    0,
  127,    0,    0,  122,  123,  135,    0,    0,    0,   22,
    0,  133,  124,   30,    0,    0,    0,    0,    0,    0,
    0,  120,  121,   29,    0,    0,    0,  129,    0,    0,
  134,   21,   19,    0,   23,   25,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   51,   54,
   55,   45,   47,   49,   56,   57,   58,   59,   60,   61,
   62,   63,   64,   65,   66,   67,   68,   69,   70,   71,
   72,   73,   74,   75,   76,   77,   78,   79,   80,   81,
   82,   83,   84,   85,   86,   87,   88,   89,   90,   91,
   92,   93,   94,   95,   96,   97,   98,   99,  100,  101,
  102,  103,  104,  105,  106,   35,    0,   33,   36,   37,
   38,   39,   40,    0,    0,    0,    0,    0,    0,  109,
  117,   24,    0,  113,    0,   26,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  110,    0,  111,
    0,  112,    0,    0,    0,    0,    0,    0,    0,    0,
   27,   28,    0,    0,    0,  115,  116,    0,    0,    0,
    0,    0,    0,    0,    0,  114,  107,   34,   50,   52,
   53,   44,   46,   48,   43,   42,   41,   32,   20,
};
short mime_dgoto[] = {                                       5,
  152,  153,  154,  155,   37,   38,   25,  136,   56,  137,
  138,  139,  140,  141,  142,  143,    6,    7,    8,    9,
   23,   30,   28,   39,   49,   70,   40,   71,   72,   50,
   58,   32,
};
short mime_sindex[] = {                                   -178,
 -250,    0,    0, -168,    0,    0, -178, -178,    0,    0,
    0, -242,    0,    0,    0,    0, -178, -178,    0,    0,
    0, -178, -234,    0, -213,    0,    0, -196,    0, -208,
    0, -184, -160,    0,    0,    0, -206, -145, -161,    0,
 -179,    0,    0,    0, -143, -143, -165, -208, -139, -141,
    0,    0,    0,    0, -129, -120, -251,    0, -119, -173,
    0,    0,    0, -165,    0,    0, -126, -143, -143, -143,
 -201, -201, -143, -143, -143, -143, -143, -143,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, -143,    0,    0,    0,
    0,    0,    0, -127, -127, -112, -115, -125, -114,    0,
    0,    0, -214,    0, -113,    0,  -45,  -44,  -42,  -41,
  -40,  -39,  -46,  -38,  -37,  -36, -143,    0,  -35,    0,
  -34,    0, -252, -143, -143, -143, -143, -143, -143, -143,
    0,    0,  -33, -198,  -56,    0,    0,  131, -177, -176,
  -51,  -50,  -49, -126, -143,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,
};
short mime_rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,  224,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  225,  230,    0,    0,
    0,  231,  -30,    0,    0,    0,    0, -220,    0, -186,
    0, -217,    0,    0,    0,    0,    0,    0, -209,    0,
 -155,    0,    0,    0, -163, -163, -152, -186,    0,    1,
 -256,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -150,    0,    0,    0,  -32,  -32,  -24,
    0,    0,  -21,  -21,  -21,  -21,  -21,  -21,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, -163,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  -19,    0,    0,    0,  -28,    0,    0,    0,
    0,    0,    0,  182, -170, -169,  -31,  -31,  -31,   80,
    0,    0,    0,    0, -187,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   81,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,
};
short mime_gindex[] = {                                      0,
  166,    0,    0,   92,    0,  201,    0,   55,  198,    0,
   51,    0,    0,    0,    0,    0,   -3,  238,   59,   29,
    0,  208,    0,    0,  -43,    0,  200,    0,    0,  -20,
  -10,    0,
};
#define YYTABLESIZE 519
short mime_table[] = {                                     127,
  128,   57,   60,   16,  127,  127,   66,   10,   67,   41,
  186,  129,   26,   21,   16,  127,   11,   31,   21,   42,
  127,  127,   20,  187,  144,  145,  146,   41,   51,  157,
  158,  159,  160,  161,  162,  136,   19,   42,  126,   24,
  136,  136,  171,  126,  126,   19,  136,   33,  172,   27,
   19,  136,   34,   35,  126,  147,  136,  136,  136,  126,
  126,  148,  136,   36,  196,   17,   29,  136,  136,  108,
   45,   46,  149,  150,  151,  108,   22,  187,   43,    1,
  136,   52,   53,   54,   69,    2,   67,    3,    4,   12,
  136,  136,   36,  163,  136,   13,  136,   14,   15,   34,
   35,   29,   44,  199,  200,  201,   61,  202,  203,  204,
  136,  136,  136,   47,  136,  136,  136,   34,   35,   52,
   53,  132,  132,  183,  130,  130,  131,  131,   63,   64,
  188,  189,  190,  191,  192,  193,  194,   65,   68,  164,
  165,  166,   73,   74,   75,  167,   76,  168,  170,  173,
  151,  209,   77,   78,   79,   80,   81,   82,   83,   84,
   85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
   95,   96,   97,   98,   99,  100,  101,  102,  103,  104,
  105,  106,  107,  108,  109,  110,  111,  112,  113,  114,
  115,  116,  117,  118,  119,  120,  121,  122,  123,  124,
  125,  126,  127,  128,  129,  130,  131,  132,  133,  134,
  135,  174,  175,  180,  176,  177,  178,  179,  197,   12,
  205,  206,  207,   16,   15,  181,  182,  184,  185,   14,
   13,  195,  136,  136,  136,  136,  136,  156,   31,  169,
  136,   55,  198,   59,  208,   18,   48,   62,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  128,  128,    0,
  128,    0,    0,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,    0,    0,    0,    0,    0,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
  128,  128,  128,  128,  128,  128,  128,  128,  136,    0,
    0,    0,    0,  136,  136,    0,  136,  136,  136,  136,
  136,    0,  136,    0,    0,    0,    0,    0,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,   85,   86,   87,
   88,   89,   90,   91,   92,   93,   94,   95,   96,   97,
   98,   99,  100,  101,  102,  103,  104,  105,  106,  107,
  108,  109,  110,  111,  112,  113,  114,  115,  116,  117,
  118,  119,  120,  121,  122,  123,  124,  125,  126,  127,
  128,  129,  130,  131,  132,  133,  134,  135,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,  136,
  136,  136,  136,  136,  136,  136,  136,  136,  136,
};
short mime_check[] = {                                     256,
    0,   45,   46,    7,  261,  262,  258,  258,  260,   30,
  263,  268,   23,   17,   18,  272,  267,   28,   22,   30,
  277,  278,  265,  276,   68,   69,   70,   48,   39,   73,
   74,   75,   76,   77,   78,  256,    8,   48,  256,  274,
  261,  262,  257,  261,  262,   17,  256,  256,  263,  263,
   22,  272,  261,  262,  272,  257,  277,  278,  268,  277,
  278,  263,  272,  272,  263,    7,  263,  277,  278,  257,
  277,  278,  274,  275,  276,  263,   18,  276,  263,  258,
    0,  261,  262,  263,  258,  264,  260,  266,  267,  258,
  277,  278,  272,  137,  258,  264,  260,  266,  267,  261,
  262,  263,  263,  281,  282,  283,  272,  284,  285,  286,
  281,  282,  283,  259,  284,  285,  286,  261,  262,  261,
  262,  277,  278,  167,  277,  278,  277,  278,  268,  259,
  174,  175,  176,  177,  178,  179,  180,  258,  258,  267,
  144,  145,  269,  270,  271,  258,  273,  263,  263,  263,
  276,  195,  279,  280,  281,  282,  283,  284,  285,  286,
  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,
  297,  298,  299,  300,  301,  302,  303,  304,  305,  306,
  307,  308,  309,  310,  311,  312,  313,  314,  315,  316,
  317,  318,  319,  320,  321,  322,  323,  324,  325,  326,
  327,  328,  329,  330,  331,  332,  333,  334,  335,  336,
  337,  257,  257,  260,  257,  257,  257,  257,  275,  258,
  272,  272,  272,    0,    0,  263,  263,  263,  263,    0,
    0,  265,  263,  258,  267,  257,  265,   72,  258,  148,
  272,   41,  188,   46,  194,    8,   39,   48,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,   -1,
  260,   -1,   -1,  263,  264,  265,  266,  267,  268,  269,
  270,  271,  272,  273,   -1,   -1,   -1,   -1,   -1,  279,
  280,  281,  282,  283,  284,  285,  286,  287,  288,  289,
  290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
  310,  311,  312,  313,  314,  315,  316,  317,  318,  319,
  320,  321,  322,  323,  324,  325,  326,  327,  328,  329,
  330,  331,  332,  333,  334,  335,  336,  337,  258,   -1,
   -1,   -1,   -1,  263,  264,   -1,  266,  267,  269,  270,
  271,   -1,  273,   -1,   -1,   -1,   -1,   -1,  279,  280,
  281,  282,  283,  284,  285,  286,  287,  288,  289,  290,
  291,  292,  293,  294,  295,  296,  297,  298,  299,  300,
  301,  302,  303,  304,  305,  306,  307,  308,  309,  310,
  311,  312,  313,  314,  315,  316,  317,  318,  319,  320,
  321,  322,  323,  324,  325,  326,  327,  328,  329,  330,
  331,  332,  333,  334,  335,  336,  337,  287,  288,  289,
  290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
  310,  311,  312,  313,  314,  315,  316,  317,  318,  319,
  320,  321,  322,  323,  324,  325,  326,  327,  328,  329,
  330,  331,  332,  333,  334,  335,  336,  337,  287,  288,
  289,  290,  291,  292,  293,  294,  295,  296,  297,  298,
  299,  300,  301,  302,  303,  304,  305,  306,  307,  308,
  309,  310,  311,  312,  313,  314,  315,  316,  317,  318,
  319,  320,  321,  322,  323,  324,  325,  326,  327,  328,
  329,  330,  331,  332,  333,  334,  335,  336,  337,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 337
#if YYDEBUG
char *mime_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"EQ","COLON","DOT","SEMI","SPACE",
"HTAB","LINESEP","NEWLINE","VCARD","TERM","BEGIN","END","TYPE","VALUE",
"ENCODING","WORD","XWORD","STRING","QP","B64","PROP","PROP_AGENT","LANGUAGE",
"CHARSET","INLINE","URL","CONTENTID","SEVENBIT","QUOTEDP","BASE64","DOM","INTL",
"POSTAL","PARCEL","HOME","WORK","PREF","VOICE","FAX","MSG","CELL","PAGER","BBS",
"MODEM","CAR","ISDN","VIDEO","AOL","APPLELINK","ATTMAIL","CIS","EWORLD",
"INTERNET","IBMMAIL","MSN","MCIMAIL","POWERSHARE","PRODIGY","TLX","X400","GIF",
"CGM","WMF","BMP","MET","PMB","DIB","PICT","TIFF","ACROBAT","PS","JPEG","QTIME",
"MPEG","MPEG2","AVI","WAVE","AIFF","PCM","X509","PGP",
};
char *mime_rule[] = {
"$accept : mime",
"vcards : vcards junk vcard",
"vcards : vcards vcard",
"vcards : vcard",
"junk : junk atom",
"junk : atom",
"atom : BEGIN NEWLINE",
"atom : BEGIN TERM",
"atom : BEGIN BEGIN",
"atom : COLON BEGIN",
"atom : COLON COLON",
"atom : NEWLINE",
"atom : TERM",
"mime : junk vcards junk",
"mime : junk vcards",
"mime : vcards junk",
"mime : vcards",
"$$1 :",
"$$2 :",
"$$3 :",
"vcard : BEGIN COLON VCARD $$1 opt_str LINESEP $$2 opt_ls items opt_ws END $$3 opt_ws COLON opt_ws VCARD opt_ws",
"items : items opt_ls item",
"items : item",
"$$4 :",
"item : groups PROP params COLON $$4 value",
"$$5 :",
"item : groups PROP opt_ws COLON $$5 value",
"item : groups PROP_AGENT params COLON opt_ws vcard LINESEP",
"item : groups PROP_AGENT opt_ws COLON opt_ws vcard LINESEP",
"item : ws LINESEP",
"item : error LINESEP",
"params : opt_ws SEMI plist opt_ws",
"plist : plist opt_ws SEMI opt_ws param",
"plist : param",
"param : TYPE opt_ws EQ opt_ws ptypeval",
"param : ptypeval",
"param : param_7bit",
"param : param_qp",
"param : param_base64",
"param : param_inline",
"param : param_ref",
"param : CHARSET opt_ws EQ opt_ws WORD",
"param : LANGUAGE opt_ws EQ opt_ws WORD",
"param : XWORD opt_ws EQ opt_ws WORD",
"param_7bit : ENCODING opt_ws EQ opt_ws SEVENBIT",
"param_7bit : SEVENBIT",
"param_qp : ENCODING opt_ws EQ opt_ws QUOTEDP",
"param_qp : QUOTEDP",
"param_base64 : ENCODING opt_ws EQ opt_ws BASE64",
"param_base64 : BASE64",
"param_inline : VALUE opt_ws EQ opt_ws INLINE",
"param_inline : INLINE",
"param_ref : VALUE opt_ws EQ opt_ws URL",
"param_ref : VALUE opt_ws EQ opt_ws CONTENTID",
"param_ref : URL",
"param_ref : CONTENTID",
"ptypeval : DOM",
"ptypeval : INTL",
"ptypeval : POSTAL",
"ptypeval : PARCEL",
"ptypeval : HOME",
"ptypeval : WORK",
"ptypeval : PREF",
"ptypeval : VOICE",
"ptypeval : FAX",
"ptypeval : MSG",
"ptypeval : CELL",
"ptypeval : PAGER",
"ptypeval : BBS",
"ptypeval : MODEM",
"ptypeval : CAR",
"ptypeval : ISDN",
"ptypeval : VIDEO",
"ptypeval : AOL",
"ptypeval : APPLELINK",
"ptypeval : ATTMAIL",
"ptypeval : CIS",
"ptypeval : EWORLD",
"ptypeval : INTERNET",
"ptypeval : IBMMAIL",
"ptypeval : MSN",
"ptypeval : MCIMAIL",
"ptypeval : POWERSHARE",
"ptypeval : PRODIGY",
"ptypeval : TLX",
"ptypeval : X400",
"ptypeval : GIF",
"ptypeval : CGM",
"ptypeval : WMF",
"ptypeval : BMP",
"ptypeval : MET",
"ptypeval : PMB",
"ptypeval : DIB",
"ptypeval : PICT",
"ptypeval : TIFF",
"ptypeval : ACROBAT",
"ptypeval : PS",
"ptypeval : JPEG",
"ptypeval : QTIME",
"ptypeval : MPEG",
"ptypeval : MPEG2",
"ptypeval : AVI",
"ptypeval : WAVE",
"ptypeval : AIFF",
"ptypeval : PCM",
"ptypeval : X509",
"ptypeval : PGP",
"qp : qp EQ LINESEP QP",
"qp : qp EQ LINESEP",
"qp : QP",
"qp : EQ LINESEP",
"value : STRING LINESEP",
"value : qp LINESEP",
"value : base64",
"base64 : LINESEP lines LINESEP LINESEP",
"base64 : lines LINESEP LINESEP",
"lines : lines LINESEP B64",
"lines : B64",
"opt_str : STRING",
"opt_str : empty",
"ws : ws SPACE",
"ws : ws HTAB",
"ws : SPACE",
"ws : HTAB",
"ls : ls LINESEP",
"ls : LINESEP",
"opt_ls : ls",
"opt_ls : empty",
"opt_ws : ws",
"opt_ws : empty",
"groups : grouplist DOT",
"groups : ws grouplist DOT",
"groups : ws",
"groups : empty",
"grouplist : grouplist DOT WORD",
"grouplist : WORD",
"empty :",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE *p_yyval;
YYSTYPE *p_yylval;
short *yyss; /* YYSTACKSIZE long */
YYSTYPE *yyvs; /* YYSTACKSIZE long */
#undef yylval
#define yylval (*p_yylval)
#undef yyval
#define yyval (*p_yyval)
#define yystacksize YYSTACKSIZE
CFUNCTIONS
#line 537 "mime.y"

/***************************************************************************/
/***						The lexical analyzer						****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
#define IsLineBreak(_c) ((_c == '\n') || (_c == '\r'))

/*/////////////////////////////////////////////////////////////////////////*/
/* This appends onto yylval.str, unless MAXTOKEN has been exceeded.
 * In that case, yylval.str is set to 0 length, and longString is used.
 */
static void AppendCharToToken(char c, S32 *len)
{
	if (*len < MAXTOKEN - 1) {
		yylval.str[*len] = c; yylval.str[++(*len)] = 0;
	} else if (*len == MAXTOKEN - 1) { /* copy to "longString" */
		if (!longString) {
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
		}
		memcpy(longString, yylval.str, (size_t)*len + 1);
		longString[*len] = c; longString[++(*len)] = 0;
		yylval.str[0] = 0;
		longStringLen = *len;
	} else {
		if (longStringLen == longStringMax - 1) {
			char __huge *newStr = HNEW(char, longStringMax * 2);
			_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
			longStringMax *= 2;
			HFREE(longString);
			longString = newStr;
		}
		longString[*len] = c; longString[++(*len)] = 0;
		longStringLen = *len;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* StrCat appends onto dst, ensuring that longString is used appropriately.
 * src1 may be of 0 length, in which case "longString" should be used.
 * "longString" would never be used for src2.
 */
static void StrCat(char *dst, const char *src1, const char *src2)
{
	S32 src1Len = strlen(src1);
	S32 src2Len = strlen(src2);
	S32 req;

	if (!src1Len && longString) {
		src1Len = longStringLen;
		src1 = longString;
	}
	if ((req = src1Len + src2Len + 1) > MAXTOKEN) {
		if (longString) { /* longString == src1 */
			if (longStringMax - longStringLen < src2Len) {
				/* since src2Len must be < MAXTOKEN, doubling longString
				   is guaranteed to be enough room */
				char __huge *newStr = HNEW(char, longStringMax * 2);
				_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
				longStringMax *= 2;
				HFREE(longString);
				longString = newStr;
			}
			_hmemcpy((U8 __huge *)(longString + longStringLen), (U8 __huge *)src2, src2Len + 1);
			longStringLen += src2Len;
		} else { /* haven't yet used longString, so set it up */
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
			memcpy(longString, src1, (size_t)src1Len + 1);
			memcpy(longString + src1Len, src2, (size_t)src2Len + 1);
			longStringLen = src1Len + src2Len;
		}
		*dst = 0; /* indicate result is in longString */
	} else { /* both will fit in MAXTOKEN, so src1 can't be longString */
		if (dst != src1)
			strcpy(dst, src1);
		strcat(dst, src2);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Set up the lexor to parse a string value. */
static void ExpectValue(PARAMS_STRUCT* params)
{
	if (FlagsHave(params, vcQuotedPrintableProp))
		expected = qp;
	else if (FlagsHave(params, vcBase64Prop))
		expected = base64;
	else
		expected = sevenbit;
	if (longString) {
		HFREE(longString); longString = NULL;
		longStringLen = 0;
	}
	paramExp = FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
#define FlushWithPending(_t) { \
	if (len) { \
		pendingToken = _t; \
		goto Pending; \
	} else { \
		mime_lineNum += ((_t == LINESEP) || (_t == NEWLINE)); \
		return _t; \
	} \
}

static int peekn;
static char peekc[2];

/*/////////////////////////////////////////////////////////////////////////*/
static char lex_getc()
{
	if (peekn) {
		return peekc[--peekn];
	}
	if (curPos == inputLen)
		return EOF;
	else if (inputString)
		return *(inputString + curPos++);
	else {
		char result;
		return inputFile->Read(&result, 1) == 1 ? result : EOF;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static void lex_ungetc(char c)
{
	ASSERT(peekn < 2);
	peekc[peekn++] = c;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a 7bit string value. */
static int Lex7bit()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return STRING;
} /* Lex7bit */

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a quoted-printable string value. */
static int LexQuotedPrintable()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '=': {
				char c = 0;
				char next[2];
				int i;
				for (i = 0; i < 2; i++) {
					next[i] = lex_getc();
					if (next[i] >= '0' && next[i] <= '9')
						c = c * 16 + next[i] - '0';
					else if (next[i] >= 'A' && next[i] <= 'F')
						c = c * 16 + next[i] - 'A' + 10;
					else
						break;
				}
				if (i == 0) {
					if (next[i] == '\r') {
						next[1] = lex_getc();
						if (next[1] == '\n') {
							lex_ungetc(next[1]); /* so that we'll pick up the LINESEP again */
							pendingToken = EQ;
							goto EndString;
						} else {
							lex_ungetc(next[1]);
							lex_ungetc(next[0]);
							AppendCharToToken('=', &len);
						}
					} else if (next[i] == '\n') {
						lex_ungetc(next[i]); /* so that we'll pick up the LINESEP again */
						pendingToken = EQ;
						goto EndString;
					} else {
						lex_ungetc(next[i]);
						AppendCharToToken('=', &len);
					}
				} else if (i == 1) {
					lex_ungetc(next[1]);
					lex_ungetc(next[0]);
					AppendCharToToken('=', &len);
				} else
					AppendCharToToken(c, &len);

				break;
			} /* '=' */
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return QP;
} /* LexQuotedPrintable */

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a base64 string value. */
static int LexBase64()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return B64;
} /* LexBase64 */

/*/////////////////////////////////////////////////////////////////////////*/
/*
 * Read chars from the input.
 * Return one of the token types (or -1 for EOF).
 * Set yylval to indicate the value of the token, if any.
 */
int mime_lex();
int mime_lex()
{
	char cur;
	S32 len = 0;
	static BOOL beginning = TRUE;

	if (pendingToken) {
		int result = pendingToken;
		pendingToken = 0;
		mime_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	yylval.str[0] = 0;

	switch (expected) {
		case sevenbit: return Lex7bit();
		case qp: return LexQuotedPrintable();
		case base64: return LexBase64();
		default: break;
	}
	
	if (curCard == -1) {
		do {
			cur = lex_getc();
			switch (cur) {
				case ':':  FlushWithPending(COLON);
				case ' ':
				case '\t':
					if (len) goto Pending;
					break;
				case '\r':
				case '\n': {
					char next = lex_getc();
					if (!(((next == '\r') || (next == '\n')) && (cur != next)))
						lex_ungetc(next);
					FlushWithPending(NEWLINE);
				}
				case (char)EOF: FlushWithPending(EOF);
				default:
					yylval.str[len] = cur; yylval.str[++len] = 0;
					break;
			} /* switch */
		} while (len < MAXTOKEN-1);
		goto Pending;
	}

	do {
		cur = lex_getc();
		switch (cur) {
			case '=':  FlushWithPending(EQ);
			case ':':  FlushWithPending(COLON);
			case '.':  FlushWithPending(DOT);
			case ';':  FlushWithPending(SEMI);
			case ' ':  FlushWithPending(SPACE);
			case '\t': FlushWithPending(HTAB);
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				FlushWithPending(LINESEP);
			}
			case (char)EOF: FlushWithPending(EOF);
			default:
				yylval.str[len] = cur; yylval.str[++len] = 0;
				break;
		} /* switch */
	} while (len < MAXTOKEN-1);
	return WORD;

Pending:
	{
		if (stricmp(yylval.str, "begin") == 0) {
			beginning = TRUE;
			return BEGIN;
		} else if (stricmp(yylval.str, "vcard") == 0) {
			if (beginning && curCard == -1 && pendingToken == NEWLINE)
				pendingToken = LINESEP;
			else if (!beginning && curCard == -1 && pendingToken == LINESEP)
				pendingToken = NEWLINE;
			return VCARD;
		} else if (stricmp(yylval.str, "end") == 0) {
			beginning = FALSE;
			return END;
		}
		if (paramExp) {
			PARAMS_STRUCT params;
			int param;
			if ((param = StrToParam(yylval.str, &params))) {
				yylval.params = params;
				return param;
			} else if (stricmp(yylval.str, "type") == 0)
				return TYPE;
			else if (stricmp(yylval.str, "value") == 0)
				return VALUE;
			else if (stricmp(yylval.str, "encoding") == 0)
				return ENCODING;
			else if (stricmp(yylval.str, "charset") == 0)
				return CHARSET;
			else if (stricmp(yylval.str, "language") == 0)
				return LANGUAGE;
			else if (strnicmp(yylval.str, "X-", 2) == 0)
				return XWORD;
		} else if ((curCard != -1) && StrToProp(yylval.str)
			|| (strnicmp(yylval.str, "X-", 2) == 0)) {
#if YYDEBUG
			if (yydebug) {
				char buf[80];
				sprintf(buf, "property \"%s\"\n", yylval.str);
				Parse_Debug(buf);
			}
#endif
			paramExp = TRUE;
			/* check for special props that are tokens */
			if (stricmp(yylval.str, "AGENT") == 0)
				return PROP_AGENT;
			else
				return PROP;
		}
	}
	return (curCard == -1) ? TERM : WORD;
}


/***************************************************************************/
/***							Public Functions						****/
/***************************************************************************/

static BOOL Parse_MIMEHelper(CList *vcList)
{
	BOOL success = FALSE;

	curCard = -1;
	mime_numErrors = 0;
	pendingToken = 0;
	mime_lineNum = 1;
	peekn = 0;
	global_vcList = vcList;

	expected = none;
	paramExp = FALSE;
	longString = NULL; longStringLen = 0; longStringMax = 0;

	/* this winds up invoking the Parse_* callouts. */
	if (yyparse() != 0)
		goto Done;

	success = TRUE;

Done:
	if (longString) { HFREE(longString); longString = NULL; }
	if (!success) {
		for (int i = 0; i < MAXCARD; i++)
			if (cardToBuild[i]) {
				delete cardToBuild[i];
				cardToBuild[i] = NULL;
			}
		if (cardBuilt) delete cardBuilt;
	}
	cardBuilt = NULL;
	return success;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;

	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	result = Parse_MIMEHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else
		*card = NULL;
	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
extern BOOL Parse_Many_MIME(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	return Parse_MIMEHelper(vcList);
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MIME_FromFile(
	CFile *file,		/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;
	DWORD startPos;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	result = Parse_MIMEHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else {
		*card = NULL;
		file->Seek(startPos, CFile::begin);
	}
	return result;
}

extern BOOL Parse_Many_MIME_FromFile(
	CFile *file,		/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	DWORD startPos;
	BOOL result;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	if (!(result = Parse_MIMEHelper(vcList)))
		file->Seek(startPos, CFile::begin);
	return result;
}


/***************************************************************************/
/***						Parser Callout Functions					****/
/***************************************************************************/

typedef struct {
	const char *name;
	int token;
} PARAM_PAIR;

static PARAM_PAIR typePairs[] = {
	vcDomesticProp,			DOM,
	vcInternationalProp,	INTL,
	vcPostalProp,			POSTAL,
	vcParcelProp,			PARCEL,
	vcHomeProp,				HOME,
	vcWorkProp,				WORK,
	vcPreferredProp,		PREF,
	vcVoiceProp,			VOICE,
	vcFaxProp,				FAX,
	vcMessageProp,			MSG,
	vcCellularProp,			CELL,
	vcPagerProp,			PAGER,
	vcBBSProp,				BBS,
	vcModemProp,			MODEM,
	vcCarProp,				CAR,
	vcISDNProp,				ISDN,
	vcVideoProp,			VIDEO,
	vcAOLProp,				AOL,
	vcAppleLinkProp,		APPLELINK,
	vcATTMailProp,			ATTMAIL,
	vcCISProp,				CIS,
	vcEWorldProp,			EWORLD,
	vcInternetProp,			INTERNET,
	vcIBMMailProp,			IBMMAIL,
	vcMSNProp,				MSN,
	vcMCIMailProp,			MCIMAIL,
	vcPowerShareProp,		POWERSHARE,
	vcProdigyProp,			PRODIGY,
	vcTLXProp,				TLX,
	vcX400Prop,				X400,
	vcGIFProp,				GIF,
	vcCGMProp,				CGM,
	vcWMFProp,				WMF,
	vcBMPProp,				BMP,
	vcMETProp,				MET,
	vcPMBProp,				PMB,
	vcDIBProp,				DIB,
	vcPICTProp,				PICT,
	vcTIFFProp,				TIFF,
	vcAcrobatProp,			ACROBAT,
	vcPSProp,				PS,
	vcJPEGProp,				JPEG,
	vcQuickTimeProp,		QTIME,
	vcMPEGProp,				MPEG,
	vcMPEG2Prop,			MPEG2,
	vcAVIProp,				AVI,
	vcWAVEProp,				WAVE,
	vcAIFFProp,				AIFF,
	vcPCMProp,				PCM,
	vcX509Prop,				X509,
	vcPGPProp,				PGP,
	NULL,					NULL
};

static PARAM_PAIR valuePairs[] = {
	vcInlineProp,			INLINE,
	//vcURLValueProp,		URL,
	vcContentIDProp,		CONTENTID,
	NULL,					NULL
};

static PARAM_PAIR encodingPairs[] = {
	vc7bitProp,				SEVENBIT,
	//vcQuotedPrintableProp,QUOTEDP,
	vcBase64Prop,			BASE64,
	NULL,					NULL
};

/*/////////////////////////////////////////////////////////////////////////*/
static void YYDebug(const char *s)
{
	Parse_Debug(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
static int StrToParam(const char *s, PARAMS_STRUCT *params)
{
	int i;

	params->known[1] = NULL;
	params->extended[0] = 0;
	
	for (i = 0; typePairs[i].name; i++)
		if (stricmp(s, strrchr(typePairs[i].name, '/') + 1) == 0) {
			params->known[0] = typePairs[i].name;
			return typePairs[i].token;
		}
	for (i = 0; valuePairs[i].name; i++)
		if (stricmp(s, strrchr(valuePairs[i].name, '/') + 1) == 0) {
			params->known[0] = valuePairs[i].name;
			return valuePairs[i].token;
		}
	for (i = 0; encodingPairs[i].name; i++)
		if (stricmp(s, strrchr(encodingPairs[i].name, '/') + 1) == 0) {
			params->known[0] = encodingPairs[i].name;
			return encodingPairs[i].token;
		}
	if (stricmp(s, "quoted-printable") == 0) {
		params->known[0] = vcQuotedPrintableProp;
		return QUOTEDP;
	} else if (stricmp(s, "url") == 0) {
		params->known[0] = vcURLValueProp;
		return URL;
	}
	return 0;
}

/*/////////////////////////////////////////////////////////////////////////*/
static const char* StrToProp(const char* str)
{
	int i;
	
	if (stricmp(str, "N") == 0)
		return mime_fam_given;
	else if (stricmp(str, "ORG") == 0)
		return mime_orgname_orgunit;
	else if (stricmp(str, "ADR") == 0)
		return mime_address;
	for (i = 0; propNames[i]; i++)
		if (stricmp(str, strrchr(propNames[i], '/') + 1) == 0) {
			return propNames[i];
		}
	return NULL;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void AddParam(PARAMS_STRUCT* dst, PARAMS_STRUCT* src)
{
	if (src->known[0]) {
		int len = flagslen(dst->known);
		dst->known[len] = src->known[0];
		dst->known[len+1] = NULL;
	} else {
		char *p = dst->extended;
		int len = strlen(src->extended);
		while (*p) p += strlen(p) + 1;
		memcpy(p, src->extended, len + 1);
		*(p + len + 1) = 0;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static int ComponentsSeparatedByChar(
	char* str, char pat, CList& list)
{
	char* p;
	char* s = str;
	int num = 0;

	while ((p = strchr(s, pat))) {
		if (p == s || *(p-1) != '\\') {
			*p = 0;
			list.AddTail(str);
			num++;
			s = str = p + 1;
		} else {
			s = p + 1;
		}
	}
	list.AddTail(str);
	num++;

    for (CLISTPOSITION pos = list.GetHeadPosition(); pos; ) {
		s = (char*)list.GetNext(pos);
		while ((p = strchr(s, pat))) {
			int len = strlen(p+1);
			memmove(p-1, p, len+1);
			*(p+len) = 0;
			s = p;
		}
	}

	return num;
}

static void AddStringProps(
	CVCNode* node, const char** props, char* val)
{
	CList list;

	ComponentsSeparatedByChar(val, ';', list);
    for (CLISTPOSITION pos = list.GetHeadPosition(); pos && *props; props++) {
		char* s = (char*)list.GetNext(pos);
		if (*s)
			node->AddStringProp(*props, s);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Assoc(
	const char *groups, const char *prop, PARAMS_STRUCT *params, char *value)
{
	CVCNode *node = NULL;
	const char *propName;
	char *val = *value ? value : longString;
	S32 valLen = *value ? strlen(value) : longStringLen;
	U8 __huge *bytes = NULL;

	if (!valLen)
		return TRUE; /* don't treat an empty value as a syntax error */

	propName = StrToProp(prop);
	/* prop is a word like "PN", and propName is now */
	/* the real prop name of the form "+//ISBN 1-887687-00-9::versit..." */
	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		if (propName) {
			if (strcmp(propName, vcCharSetProp) == 0
				|| strcmp(propName, vcLanguageProp) == 0) {
				node = bodyToBuild;
				node->RemoveProp(propName);
			} else
				node = bodyToBuild->AddPart();
		} else 
			node = bodyToBuild->AddPart();
	}

	if (FlagsHave(params, vcBase64Prop)) {
		S32 len;
		bytes = DataFromBase64(val, valLen, &len);
		valLen = len;
		if (!bytes)
			return FALSE;
	}

	if (!propName) { /* it's an extended property */
		if (bytes) {
			node->AddProp(new CVCProp(prop, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(prop, value);
			AddBoolProps(node, params);
		}
		return TRUE;
	}

	if ((strcmp(propName, vcLogoProp) == 0)
		|| (strcmp(propName, vcPhotoProp) == 0)) {
		if (bytes) {
			if (FlagsHave(params, vcGIFProp)
				&& !FlagsHave(params, vcURLValueProp)
				&& !FlagsHave(params, vcContentIDProp))
				node->AddProp(new CVCProp(propName, vcGIFType, bytes, valLen));
			else
				node->AddProp(new CVCProp(propName, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, params);
		}
	} else if (strcmp(propName, vcPronunciationProp) == 0) {
		if (bytes) {
			if (FlagsHave(params, vcWAVEProp)
				&& !FlagsHave(params, vcURLValueProp)
				&& !FlagsHave(params, vcContentIDProp))
				node->AddProp(new CVCProp(propName, vcWAVType, bytes, valLen));
			else
				node->AddProp(new CVCProp(propName, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, params);
		}
	} else if (strcmp(propName, vcPublicKeyProp) == 0) {
		if (bytes) {
			node->AddProp(new CVCProp(propName, vcOctetsType, bytes, valLen));
			HFREE(bytes);
			AddBoolProps(node, params);
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, params);
		}
	} else if (strcmp(propName, mime_fam_given) == 0) {
		AddStringProps(node, mime_nameProps, val);
		AddBoolProps(node, params);
	} else if (strcmp(propName, mime_orgname_orgunit) == 0) {
		AddStringProps(node, mime_orgProps, val);
		AddBoolProps(node, params);
	} else if (strcmp(propName, mime_address) == 0) {
		AddStringProps(node, mime_addrProps, val);
		AddBoolProps(node, params);
	} else {
		node->AddStringProp(propName, value);
		AddBoolProps(node, params);
	}

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Agent(
	const char *groups, const char *prop, PARAMS_STRUCT *params,
	CVCard *agentCard)
{
	CVCNode *node = NULL;

	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		node = bodyToBuild->AddPart();
	}

	node->AddProp(new CVCProp(vcAgentProp, VCNextObjectType, agentCard));
	AddBoolProps(node, params);

	return TRUE;
}


/***************************************************************************/
/***						Private Utility Functions					****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
/* This parses and converts the base64 format for binary encoding into
 * a decoded buffer (allocated with new).  See RFC 1521.
 */
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len)
{
	S32 cur = 0, bytesLen = 0, bytesMax = 0;
	int quadIx = 0, pad = 0;
	U32 trip = 0;
	U8 b;
	char c;
	U8 __huge *bytes = NULL;

	while (cur < strLen) {
		c = str[cur];
		if ((c >= 'A') && (c <= 'Z'))
			b = (U8)(c - 'A');
		else if ((c >= 'a') && (c <= 'z'))
			b = (U8)(c - 'a') + 26;
		else if ((c >= '0') && (c <= '9'))
			b = (U8)(c - '0') + 52;
		else if (c == '+')
			b = 62;
		else if (c == '/')
			b = 63;
		else if (c == '=') {
			b = 0;
			pad++;
		} else if ((c == '\n') || (c == ' ') || (c == '\t')) {
			cur++;
			continue;
		} else { /* error condition */
			if (bytes) delete [] bytes;
			return NULL;
		}
		trip = (trip << 6) | b;
		if (++quadIx == 4) {
			U8 outBytes[3];
			int numOut;
			for (int i = 0; i < 3; i++) {
				outBytes[2-i] = (U8)(trip & 0xFF);
				trip >>= 8;
			}
			numOut = 3 - pad;
			if (bytesLen + numOut > bytesMax) {
				if (!bytes) {
					bytes = HNEW(U8, 1024L);
					bytesMax = 1024;
				} else {
					U8 __huge *newBytes = HNEW(U8, bytesMax * 2);
					_hmemcpy(newBytes, bytes, bytesLen);
					HFREE(bytes);
					bytes = newBytes;
					bytesMax *= 2;
				}
			}
			memcpy(bytes + bytesLen, outBytes, numOut);
			bytesLen += numOut;
			trip = 0;
			quadIx = 0;
		}
		cur++;
	} /* while */
	*len = bytesLen;
	return bytes;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This creates an empty CVCard shell with an English body in preparation
 * for parsing properties onto it.  This is used for both the outermost
 * card, as well as any AGENT properties, which are themselves vCards.
 */
static BOOL PushVCard()
{
	CVCard *card;
	CVCNode *root, *english;

	if (curCard == MAXCARD - 1)
		return FALSE;

	card = new CVCard;
	card->AddObject(root = new CVCNode);					/* create root */
	root->AddProp(new CVCProp(VCRootObject));				/* mark it so */

	/* add a body having the default language */
	english = root->AddObjectProp(vcBodyProp, VCBodyObject);
	cardToBuild[++curCard] = card;
	bodyToBuild = english;

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This pops the recently built vCard off the stack and returns it. */
static CVCard* PopVCard()
{
	CVCard *result = cardToBuild[curCard];

	cardToBuild[curCard--] = NULL;
	bodyToBuild = (curCard == -1) ? NULL : cardToBuild[curCard]->FindBody();

	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
static int flagslen(const char **params)
{
	int i;
	for (i = 0; *params; params++, i++) ;
	return i;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL FlagsHave(PARAMS_STRUCT *params, const char *propName)
{
	const char **kf;
	
	if (!params)
		return FALSE;
	kf = params->known;
	while (*kf)
		if (*kf++ == propName)
			return TRUE;
	return FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void AddBoolProps(CVCNode *node, PARAMS_STRUCT *params)
{
	const char **kf;
	const char *ext;

	if (!params)
		return;
	kf = params->known;
	ext = params->extended;

	// process the known boolean properties
	while (*kf) {
		node->AddBoolProp(*kf);
		kf++;
	}

	// process the extended properties
	while (*ext) {
		const char* eq = strchr(ext, '=');
		ASSERT(eq);
		if (eq-ext == 7 && strnicmp(ext, "charset", 7) == 0) {
			if (!node->GetProp(vcCharSetProp))
				node->AddProp(new CVCProp(vcCharSetProp, vcFlagsType, (void*)(eq+1), strlen(eq+1)+1));
		} else if (eq-ext == 8 && strnicmp(ext, "language", 8) == 0) {
			if (!node->GetProp(vcLanguageProp))
				node->AddProp(new CVCProp(vcLanguageProp, vcFlagsType, (void*)(eq+1), strlen(eq+1)+1));
		} else {
			char buf[256];
			strncpy(buf, ext, eq-ext);
			buf[eq-ext] = 0;
			node->AddProp(new CVCProp(buf, vcFlagsType, (void*)(eq+1), strlen(eq+1)+1));
		}
		ext += strlen(ext) + 1;
	}
}

#line 1849 "mime_tab.cpp"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    int yym, yyn, yystate, yyresult;
#if YYDEBUG
    char *yys;
    char debugbuf[1024];

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    p_yyval = NULL; p_yylval = NULL; yyss = NULL; yyvs = NULL;
    if ((p_yyval = (YYSTYPE*)malloc(sizeof(*p_yyval))) == NULL) goto yyabort;
    if ((p_yylval = (YYSTYPE*)malloc(sizeof(*p_yylval))) == NULL) goto yyabort;
    if ((yyss = (short*)malloc(sizeof(*yyss) * YYSTACKSIZE)) == NULL) goto yyabort;
    if ((yyvs = (YYSTYPE*)malloc(sizeof(*yyvs) * YYSTACKSIZE)) == NULL) goto yyabort;

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, "%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]); YYDebug(debugbuf);}
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, 
                        "%sdebug: state %d, error recovery shifting to state %d\n",
                        YYPREFIX, *yyssp, yytable[yyn]); YYDebug(debugbuf);}
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, "%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp); YYDebug(debugbuf);}
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, error recovery discards token %d(%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, "%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]); YYDebug(debugbuf);}
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 307 "mime.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 2:
#line 309 "mime.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 3:
#line 311 "mime.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 17:
#line 334 "mime.y"
{
				if (!PushVCard())
					YYERROR;
				ExpectValue(NULL);
			}
break;
case 18:
#line 340 "mime.y"
{ expected = none; }
break;
case 19:
#line 342 "mime.y"
{ yyval.vCard = PopVCard(); }
break;
case 20:
#line 344 "mime.y"
{ yyval.vCard = yyvsp[-5].vCard; }
break;
case 23:
#line 352 "mime.y"
{ ExpectValue(&(yyvsp[-1].params)); }
break;
case 24:
#line 353 "mime.y"
{
				expected = none;
				if (!Parse_Assoc(yyvsp[-5].str, yyvsp[-4].str, &(yyvsp[-3].params), yyvsp[0].str))
					YYERROR;
			}
break;
case 25:
#line 359 "mime.y"
{ ExpectValue(NULL); }
break;
case 26:
#line 360 "mime.y"
{
				expected = none;
				if (!Parse_Assoc(yyvsp[-5].str, yyvsp[-4].str, NULL, yyvsp[0].str))
					YYERROR;
			}
break;
case 27:
#line 366 "mime.y"
{
				expected = none;
				if (!Parse_Agent(yyvsp[-6].str, yyvsp[-5].str, &(yyvsp[-4].params), yyvsp[-1].vCard)) {
					delete yyvsp[-1].vCard;
					YYERROR;
				}
			}
break;
case 28:
#line 374 "mime.y"
{
				expected = none;
				if (!Parse_Agent(yyvsp[-6].str, yyvsp[-5].str, NULL, yyvsp[-1].vCard)) {
					delete yyvsp[-1].vCard;
					YYERROR;
				}
			}
break;
case 30:
#line 383 "mime.y"
{
				expected = none;
				paramExp = FALSE;
				yyerrok;
				yyclearin;
			}
break;
case 31:
#line 391 "mime.y"
{ yyval.params = yyvsp[-1].params; }
break;
case 32:
#line 394 "mime.y"
{
						yyval.params = yyvsp[-4].params;
						AddParam(&(yyval.params), &(yyvsp[0].params));
					}
break;
case 34:
#line 401 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 41:
#line 409 "mime.y"
{
						yyval.params.known[0] = NULL;
						strcpy(yyval.params.extended, yyvsp[-4].str);
						strcat(yyval.params.extended, "=");
						strcat(yyval.params.extended, yyvsp[0].str);
						yyval.params.extended[strlen(yyval.params.extended)+1] = 0;
					}
break;
case 42:
#line 417 "mime.y"
{
						yyval.params.known[0] = NULL;
						strcpy(yyval.params.extended, yyvsp[-4].str);
						strcat(yyval.params.extended, "=");
						strcat(yyval.params.extended, yyvsp[0].str);
						yyval.params.extended[strlen(yyval.params.extended)+1] = 0;
					}
break;
case 43:
#line 425 "mime.y"
{
						yyval.params.known[0] = NULL;
						strcpy(yyval.params.extended, yyvsp[-4].str);
						strcat(yyval.params.extended, "=");
						strcat(yyval.params.extended, yyvsp[0].str);
						yyval.params.extended[strlen(yyval.params.extended)+1] = 0;
					}
break;
case 44:
#line 434 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 46:
#line 438 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 48:
#line 442 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 50:
#line 446 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 52:
#line 450 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 53:
#line 451 "mime.y"
{ yyval.params = yyvsp[0].params; }
break;
case 107:
#line 470 "mime.y"
{
				StrCat(yyval.str, yyvsp[-3].str, yyvsp[0].str);
			}
break;
case 108:
#line 474 "mime.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "");
			}
break;
case 110:
#line 479 "mime.y"
{
				yyval.str[0] = 0;
			}
break;
case 114:
#line 487 "mime.y"
{ StrCat(yyval.str, yyvsp[-2].str, ""); }
break;
case 115:
#line 489 "mime.y"
{ StrCat(yyval.str, yyvsp[-2].str, ""); }
break;
case 116:
#line 493 "mime.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\n");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 119:
#line 500 "mime.y"
{ yyval.str[0] = 0; }
break;
case 131:
#line 518 "mime.y"
{ StrCat(yyval.str, yyvsp[-1].str, ""); }
break;
case 132:
#line 520 "mime.y"
{ yyval.str[0] = 0; }
break;
case 133:
#line 522 "mime.y"
{ yyval.str[0] = 0; }
break;
case 134:
#line 526 "mime.y"
{
				strcpy(yyval.str, yyvsp[-2].str);
				strcat(yyval.str, ".");
				strcat(yyval.str, yyvsp[0].str);
			}
break;
#line 2208 "mime_tab.cpp"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, 
                "%sdebug: after reduction, shifting from state 0 to state %d\n",
                YYPREFIX, YYFINAL); YYDebug(debugbuf);}
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys); YYDebug(debugbuf);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, 
            "%sdebug: after reduction, shifting from state %d to state %d\n",
            YYPREFIX, *yyssp, yystate); YYDebug(debugbuf);}
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    yyresult = 1;
    goto yyfinish;
yyaccept:
    yyresult = 0;
yyfinish:
    if (p_yyval) free(p_yyval);
    if (p_yylval) free(p_yylval);
    if (yyss) free(yyss);
    if (yyvs) free(yyvs);
    return yyresult;
}
END_CFUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\msv.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __MSV_H__
#define __MSV_H__

#include "parse.h"

extern int msv_lineNum; /* line number for syntax error */
extern int msv_numErrors;

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL Parse_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card		/* Out */
	);

extern BOOL Parse_Many_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

// If successful, the file's seek position is left at the end of the
// parsed card.  If not successful, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_MSV_FromFile(
	CFile *file,		/* In */
	CVCard **card		/* Out */
	);

// This function parses as many cards as possible, in sequence, until EOF
// is reached or a fatal syntax error occurs.  It returns TRUE if it
// successfully parsed at least one card, and in this case the file's
// seek position is left where the parser stopped (at EOF or a syntax
// error).  If FALSE is returned, the file's seek position is reset
// back to where it was when this function was invoked.
extern BOOL Parse_Many_MSV_FromFile(
	CFile *file,		/* In */
	CList *vcList		/* Out: CVCard objects added to existing list */
	);

#ifdef __cplusplus
};
#endif

#endif // __MSV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\msv_tab.cpp ===
//#ifndef __MWERKS__
#include "stdafx.h"
//#endif
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.10 (Berkeley) 09/07/95 swb";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 10
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#ifdef __cplusplus
#define CFUNCTIONS 		extern "C" {
#define END_CFUNCTIONS	}
#else
#define CFUNCTIONS
#define END_CFUNCTIONS
#endif
#define yyparse msv_parse
#define yylex msv_lex
#define yyerror msv_error
#define yychar msv_char
#define p_yyval p_msv_val
#undef yyval
#define yyval (*p_msv_val)
#define p_yylval p_msv_lval
#undef yylval
#define yylval (*p_msv_lval)
#define yydebug msv_debug
#define yynerrs msv_nerrs
#define yyerrflag msv_errflag
#define yyss msv_ss
#define yyssp msv_ssp
#define yyvs msv_vs
#define yyvsp msv_vsp
#define yylhs msv_lhs
#define yylen msv_len
#define yydefred msv_defred
#define yydgoto msv_dgoto
#define yysindex msv_sindex
#define yyrindex msv_rindex
#define yygindex msv_gindex
#define yytable msv_table
#define yycheck msv_check
#define yyname msv_name
#define yyrule msv_rule
#define YYPREFIX "msv_"
#line 2 "msv.y"

/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

/*
To invoke this parser, see the "Public Interface" section below.

This MS/V parser accepts input such as the following:
	[vCard
	O=AT&T/Versit;
	FN=Roland H. Alden
	TITLE=Consultant (Versit Project Office)
	N=Alden;Roland
	A:DOM,POSTAL,PARCEL,HOME,WORK=Suite 2208;One Pine Street;San Francisco;CA;94111;U.S.A.
	A.FADR:DOM,POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111
	A.FADR:POSTAL,PARCEL,HOME,WORK=Roland H. Alden\
	Suite 2208\
	One Pine Street\
	San Francisco, CA 94111\
	U.S.A.
	B.T:HOME,WORK,PREF,MSG=+1 (415) 296-9106
	C.T:WORK,FAX=+1 (415) 296-9016
	D.T:MSG,CELL=+1 (415) 608-5981
	E.EMAIL:WORK,PREF,INTERNET=sf!rincon!ralden@alden.attmail.com
	F.EMAIL:INTERNET=ralden@sfgate.com
	G.EMAIL:HOME,MCIMail=242-2200
	PN=ROW-LAND ALL-DEN
	PN:WAV,BASE64=<bindata>
		UklGRtQ4AABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0Ya84AACAgoSD
		...
		e319fYCAg4WEhIAA
	</bindata>
	]

For the purposes of the following grammar, a LINESEP token indicates either
a \r char (0x0D), a \n char (0x0A), or a combination of one of each,
in either order (\r\n or \n\r).  This is a bit more lenient than the spec.
*/


#ifdef _WIN32
#include <wchar.h>
#else
#include "wchar.h"
#endif
#include <string.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include "clist.h"
#include "vcard.h"
#include "msv.h"

#if defined(_WIN32) || defined(__MWERKS__)
#define HNEW(_t, _n) new _t[_n]
#define HFREE(_h) delete [] _h
#else
#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1)
/*#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1); {char buf[40]; sprintf(buf, "_halloc(%ld)\n", _n); Parse_Debug(buf);}*/
#define HFREE(_h) _hfree(_h)
#endif


/****  Types, Constants  ****/

#define YYDEBUG			1		/* 1 to compile in some debugging code */
#define MAXTOKEN		256		/* maximum token (line) length */
#define MAXFLAGS		((MAXTOKEN / 2) / sizeof(char *))
#define YYSTACKSIZE 	50
#define MAXASSOCKEY		24
#define MAXASSOCVALUE	64
#define MAXCARD			2		/* max # of nested cards parseable */
								/* (includes outermost) */

typedef struct {
	const char* known[MAXFLAGS];
	char extended[MAXTOKEN / 2];
} FLAGS_STRUCT;

typedef struct {
	char key[MAXASSOCKEY];
	char value[MAXASSOCVALUE];
} AssocEntry;	/* a simple key/value association, impl'd using CList */

/* some fake property names that represent special cases */
#define msv_fam_given			"family;given"
#define msv_orgname_orgunit		"org_name;org_unit"
#define msv_address				"six part address"

/*
 * These strings are defined as a courtesy for the rest of the app code.
 * They are useful here because the tail end of each is the cleartext
 * string to match according to this grammar.
 */
const char* vcDefaultLang			= "en-US";

const char* vcISO9070Prefix			= VCISO9070Prefix;
const char* vcClipboardFormatVCard	= VCClipboardFormatVCard;

const char* vcISO639Type			= VCISO639Type;
const char* vcStrIdxType			= VCStrIdxType;
const char* vcFlagsType				= VCFlagsType;
const char* vcNextObjectType		= VCNextObjectType;
const char* vcOctetsType 			= VCOctetsType;
const char* vcGIFType				= VCGIFType;
const char* vcWAVType				= VCWAVType;
const char* vcNullType 				= VCNullType;

const char* vcRootObject			= VCRootObject;
const char* vcBodyObject			= VCBodyObject;
const char* vcPartObject			= VCPartObject;
const char* vcBodyProp				= VCBodyProp;
const char* vcPartProp				= VCPartProp;
const char* vcNextObjectProp		= VCNextObjectProp;

const char* vcLogoProp				= VCLogoProp;
const char* vcPhotoProp				= VCPhotoProp;
const char* vcDeliveryLabelProp     = VCDeliveryLabelProp;
const char* vcPostalBoxProp			= VCPostalBoxProp;
const char* vcStreetAddressProp		= VCStreetAddressProp;
const char* vcExtAddressProp		= VCExtAddressProp;
const char* vcCountryNameProp		= VCCountryNameProp;
const char* vcPostalCodeProp		= VCPostalCodeProp;
const char* vcRegionProp			= VCRegionProp;
const char* vcCityProp				= VCCityProp;
const char* vcFullNameProp			= VCFullNameProp;
const char* vcTitleProp				= VCTitleProp;
const char* vcOrgNameProp			= VCOrgNameProp;
const char* vcOrgUnitProp			= VCOrgUnitProp;
const char* vcOrgUnit2Prop			= VCOrgUnit2Prop;
const char* vcOrgUnit3Prop			= VCOrgUnit3Prop;
const char* vcOrgUnit4Prop			= VCOrgUnit4Prop;
const char* vcFamilyNameProp		= VCFamilyNameProp;
const char* vcGivenNameProp			= VCGivenNameProp;
const char* vcAdditionalNamesProp	= VCAdditionalNamesProp;
const char* vcNamePrefixesProp		= VCNamePrefixesProp;
const char* vcNameSuffixesProp		= VCNameSuffixesProp;
const char* vcPronunciationProp		= VCPronunciationProp;
const char* vcLanguageProp			= VCLanguageProp;
const char* vcTelephoneProp			= VCTelephoneProp;
const char* vcEmailAddressProp		= VCEmailAddressProp;
const char* vcTimeZoneProp			= VCTimeZoneProp;
const char* vcLocationProp			= VCLocationProp;
const char* vcCommentProp			= VCCommentProp;
const char* vcCharSetProp			= VCCharSetProp;
const char* vcLastRevisedProp		= VCLastRevisedProp;
const char* vcUniqueStringProp		= VCUniqueStringProp;
const char* vcPublicKeyProp			= VCPublicKeyProp;
const char* vcMailerProp			= VCMailerProp;
const char* vcAgentProp				= VCAgentProp;
const char* vcBirthDateProp			= VCBirthDateProp;
const char* vcBusinessRoleProp		= VCBusinessRoleProp;
const char* vcCaptionProp			= VCCaptionProp;
const char* vcURLProp				= VCURLProp;

const char* vcDomesticProp			= VCDomesticProp;
const char* vcInternationalProp		= VCInternationalProp;
const char* vcPostalProp			= VCPostalProp;
const char* vcParcelProp			= VCParcelProp;
const char* vcHomeProp				= VCHomeProp;
const char* vcWorkProp				= VCWorkProp;
const char* vcPreferredProp			= VCPreferredProp;
const char* vcVoiceProp				= VCVoiceProp;
const char* vcFaxProp				= VCFaxProp;
const char* vcMessageProp			= VCMessageProp;
const char* vcCellularProp			= VCCellularProp;
const char* vcPagerProp				= VCPagerProp;
const char* vcBBSProp				= VCBBSProp;
const char* vcModemProp				= VCModemProp;
const char* vcCarProp				= VCCarProp;
const char* vcISDNProp				= VCISDNProp;
const char* vcVideoProp				= VCVideoProp;

const char* vcInlineProp			= VCInlineProp;
const char* vcURLValueProp			= VCURLValueProp;
const char* vcContentIDProp			= VCContentIDProp;

const char* vc7bitProp				= VC7bitProp;
const char* vcQuotedPrintableProp	= VCQuotedPrintableProp;
const char* vcBase64Prop			= VCBase64Prop;

const char* vcAOLProp				= VCAOLProp;
const char* vcAppleLinkProp			= VCAppleLinkProp;
const char* vcATTMailProp			= VCATTMailProp;
const char* vcCISProp				= VCCISProp;
const char* vcEWorldProp			= VCEWorldProp;
const char* vcInternetProp			= VCInternetProp;
const char* vcIBMMailProp			= VCIBMMailProp;
const char* vcMSNProp				= VCMSNProp;
const char* vcMCIMailProp			= VCMCIMailProp;
const char* vcPowerShareProp		= VCPowerShareProp;
const char* vcProdigyProp			= VCProdigyProp;
const char* vcTLXProp				= VCTLXProp;
const char* vcX400Prop				= VCX400Prop;

const char* vcGIFProp				= VCGIFProp;
const char* vcCGMProp				= VCCGMProp;
const char* vcWMFProp				= VCWMFProp;
const char* vcBMPProp				= VCBMPProp;
const char* vcMETProp				= VCMETProp;
const char* vcPMBProp				= VCPMBProp;
const char* vcDIBProp				= VCDIBProp;
const char* vcPICTProp				= VCPICTProp;
const char* vcTIFFProp				= VCTIFFProp;
const char* vcAcrobatProp			= VCAcrobatProp;
const char* vcPSProp				= VCPSProp;
const char* vcJPEGProp				= VCJPEGProp;
const char* vcQuickTimeProp			= VCQuickTimeProp;
const char* vcMPEGProp				= VCMPEGProp;
const char* vcMPEG2Prop				= VCMPEG2Prop;
const char* vcAVIProp				= VCAVIProp;

const char* vcWAVEProp				= VCWAVEProp;
const char* vcAIFFProp				= VCAIFFProp;
const char* vcPCMProp				= VCPCMProp;

const char* vcX509Prop				= VCX509Prop;
const char* vcPGPProp				= VCPGPProp;

const char* vcNodeNameProp			= VCNodeNameProp;

typedef struct {
	const char *name;
	unsigned long value;
} VC_FLAG_PAIR;

static VC_FLAG_PAIR generalFlags[] = {
	vcDomesticProp,			VC_DOM,
	vcInternationalProp,	VC_INTL,
	vcPostalProp,			VC_POSTAL,
	vcParcelProp,			VC_PARCEL,
	vcHomeProp,				VC_HOME,
	vcWorkProp,				VC_WORK,
	vcPreferredProp,		VC_PREF,
	vcVoiceProp,			VC_VOICE,
	vcFaxProp,				VC_FAX,
	vcMessageProp,			VC_MSG,
	vcCellularProp,			VC_CELL,
	vcPagerProp,			VC_PAGER,
	vcBBSProp,				VC_BBS,
	vcModemProp,			VC_MODEM,
	vcCarProp,				VC_CAR,
	vcISDNProp,				VC_ISDN,
	vcVideoProp,			VC_VIDEO,
	vcBase64Prop,			VC_BASE64,
	NULL,					NULL
};

static VC_FLAG_PAIR emailFlags[] = {
	vcAOLProp,				VC_AOL,
	vcAppleLinkProp,		VC_AppleLink,
	vcATTMailProp,			VC_ATTMail,
	vcCISProp,				VC_CIS,
	vcEWorldProp,			VC_eWorld,
	vcInternetProp,			VC_INTERNET,
	vcIBMMailProp,			VC_IBMMail,
	vcMSNProp,				VC_MSN,
	vcMCIMailProp,			VC_MCIMail,
	vcPowerShareProp,		VC_POWERSHARE,
	vcProdigyProp,			VC_PRODIGY,
	vcTLXProp,				VC_TLX,
	vcX400Prop,				VC_X400,
	NULL,					NULL
};

static VC_FLAG_PAIR videoFlags[] = {
	vcGIFProp,				VC_GIF,
	vcCGMProp,				VC_CGM,
	vcWMFProp,				VC_WMF,
	vcBMPProp,				VC_BMP,
	vcMETProp,				VC_MET,
	vcPMBProp,				VC_PMB,
	vcDIBProp,				VC_DIB,
	vcPICTProp,				VC_PICT,
	vcTIFFProp,				VC_TIFF,
	vcAcrobatProp,			VC_ACROBAT,
	vcPSProp,				VC_PS,
	NULL,					NULL
};

static VC_FLAG_PAIR audioFlags[] = {
	vcWAVEProp,				VC_WAV,
	NULL,					NULL
};

static const char *addrProps[] = {
	vcExtAddressProp,
	vcStreetAddressProp,
	vcCityProp,
	vcRegionProp,
	vcPostalCodeProp,
	vcCountryNameProp,
	NULL
};

static const char *nameProps[] = {
	vcFamilyNameProp,
	vcGivenNameProp,
	vcAdditionalNamesProp,
	vcNamePrefixesProp,
	vcNameSuffixesProp,
	NULL
};

static const char *orgProps[] = {
	vcOrgNameProp,
	vcOrgUnitProp,
	vcOrgUnit2Prop,
	vcOrgUnit3Prop,
	vcOrgUnit4Prop,
	NULL
};


/****  Global Variables  ****/

int msv_lineNum, msv_numErrors; /* yyerror() can use these */

static S32 curPos, inputLen;
static int pendingToken;
static const char *inputString;
static CFile* inputFile;
static BOOL stringExpected, flagExpected, inBinary, semiSpecial;
static CList *mapProps;
static char __huge *longString;
static S32 longStringLen, longStringMax;
static CList* global_vcList;

static CVCard *cardBuilt;
static CVCard* cardToBuild[MAXCARD];
static int curCard;
static CVCNode *bodyToBuild;


/****  External Functions  ****/

CFUNCTIONS

extern void Parse_Debug(const char *s);
extern void yyerror(char *s);

END_CFUNCTIONS


/****  Private Forward Declarations  ****/

CFUNCTIONS

/* A helpful utility for the rest of the app. */
CVCNode* FindOrCreatePart(CVCNode *node, const char *name);

static BOOL StrToFlags(const char *s, FLAGS_STRUCT *flags, VC_PTR_FLAGS capFlags);
static void StrCat(char *dst, const char *src1, const char *src2);
static void ExpectString(void);
static BOOL Parse_Assoc(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	const char *value);
static BOOL Parse_SemiValue(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	char *parts, const char **props);
static BOOL Parse_TwoPart(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	char *parts);
static BOOL Parse_Agent(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	CVCard *agentCard);
static void AddAssoc(CList *table, const char *key, const char *value);
/*static void SetAssoc(CList *table, const char *key, const char *value);*/
static const char *Lookup(CList *table, const char *key);
static void RemoveAll(CList *table);
static void InitMapProps(void);
int yyparse();
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len);
static BOOL PushVCard();
static CVCard* PopVCard();
static int flagslen(const char **flags);
static BOOL FlagsHave(FLAGS_STRUCT *flags, const char *propName);
static void AddBoolProps(CVCNode *node, FLAGS_STRUCT *flags);

END_CFUNCTIONS

#line 428 "msv.y"
typedef union
{
	char str[MAXTOKEN];
	FLAGS_STRUCT flags;
	CVCard *vCard;
} YYSTYPE;
#line 478 "msv_tab.cpp"
#define OBRKT 257
#define CBRKT 258
#define EQ 259
#define COLON 260
#define DOT 261
#define COMMA 262
#define SEMI 263
#define SPACE 264
#define HTAB 265
#define LINESEP 266
#define NEWLINE 267
#define VCARD 268
#define BBINDATA 269
#define EBINDATA 270
#define BKSLASH 271
#define TERM 272
#define WORD 273
#define STRING 274
#define PROP 275
#define PROP_A 276
#define PROP_N 277
#define PROP_O 278
#define PROP_AGENT 279
#define FLAG 280
#define YYERRCODE 256
short msv_lhs[] = {                                        -1,
   11,   11,   11,   12,   12,   13,   13,   13,   13,   13,
   13,   13,    0,    0,    0,    0,   14,   16,   10,   15,
   15,   19,   17,   20,   17,   21,   17,   22,   17,   17,
   17,    7,    7,   24,   24,   24,   24,   18,   18,    6,
    6,    6,   25,   26,    5,    1,    1,    1,    1,    8,
    8,    2,    2,    3,    3,    3,    3,    4,    4,    9,
   27,    9,    9,   23,
};
short msv_len[] = {                                         2,
    3,    2,    1,    2,    1,    2,    2,    2,    2,    2,
    1,    1,    3,    2,    2,    1,    0,    0,    8,    2,
    1,    0,    8,    0,    8,    0,    8,    0,    8,    8,
    2,    1,    1,    2,    2,    1,    1,    1,    1,    1,
    1,    1,    0,    0,    9,    4,    3,    1,    2,    3,
    1,    3,    1,    2,    3,    1,    1,    3,    1,    3,
    0,    3,    1,    0,
};
short msv_defred[] = {                                      0,
    0,   11,    0,   12,    0,    3,    0,    0,    5,    8,
    6,   17,    7,    9,   10,    2,    0,    0,    4,    0,
    1,    0,    0,   48,    0,    0,   33,   49,    0,   18,
    0,    0,   46,    0,   36,   37,   59,    0,    0,    0,
   21,   57,    0,   31,    0,    0,    0,    0,    0,    0,
   19,   20,   34,   35,    0,   61,    0,   63,    0,    0,
    0,    0,   58,    0,    0,    0,    0,   39,    0,    0,
    0,    0,    0,   62,   60,   22,   24,   26,   28,    0,
    0,    0,    0,    0,    0,    0,   43,    0,   41,    0,
   42,   51,    0,    0,    0,    0,    0,   23,    0,   25,
   27,   29,   30,    0,   50,   53,    0,    0,   52,    0,
    0,    0,   45,
};
short msv_dgoto[] = {                                       5,
   25,  107,   38,   39,   89,   90,   92,   93,   57,    6,
    7,    8,    9,   20,   40,   32,   41,   67,   81,   82,
   83,   84,   68,   69,   97,  110,   65,
};
short msv_sindex[] = {                                   -227,
 -224,    0, -221,    0,    0,    0, -227, -227,    0,    0,
    0,    0,    0,    0,    0,    0, -227, -227,    0, -236,
    0, -227, -257,    0, -237, -214,    0,    0, -212,    0,
 -218, -254,    0, -196,    0,    0,    0, -184, -201, -241,
    0,    0, -206,    0, -170, -170, -170, -170, -170, -145,
    0,    0,    0,    0, -130,    0, -177,    0, -177, -177,
 -177, -177,    0, -145, -148, -147, -125,    0, -243, -124,
 -123, -122, -121,    0,    0,    0,    0,    0,    0, -118,
 -185, -236, -236, -236, -128, -190,    0, -237,    0, -120,
    0,    0, -143, -142, -141, -119, -117,    0, -236,    0,
    0,    0,    0, -133,    0,    0, -116, -132,    0, -190,
 -127, -190,    0,
};
short msv_rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,  144,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  145,  148,    0, -115,
    0,  152,    0,    0, -137,    0,    0,    0,    0,    0,
 -198, -179,    0,    0,    0,    0,    0,    0,    0, -179,
    0,    0, -174,    0, -193, -193, -193, -193, -193, -169,
    0,    0,    0,    0,    0,    0, -106,    0, -106, -106,
 -106, -106,    0, -164,    0,    0,    0,    0, -217,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -115, -136, -136, -136,    0, -115,    0, -112,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, -136,    0,
    0,    0,    0,    0,    0,    0,    0, -187,    0, -114,
    0, -115,    0,
};
short msv_gindex[] = {                                      0,
   74,    0,    0,  114,    0,    0,  -19,   -2,   70,   -4,
  150,   32,   29,    0,    0,    0,  119,  -55,    0,    0,
    0,    0,  -20,  -24,    0,    0,    0,
};
#define YYTABLESIZE 159
short msv_table[] = {                                      27,
   26,   34,   16,   70,   71,   72,   73,   43,   28,   35,
   36,   42,   21,   16,   34,   43,   51,   21,   37,   42,
   53,   54,   35,   36,   58,   58,   58,   58,   58,    1,
   96,   37,   10,   29,   23,   14,   19,   24,   17,    2,
    3,   38,   11,   12,    4,   19,   15,   13,   38,   22,
   19,   30,   38,   31,  111,   33,  113,   53,   54,   50,
   91,   27,   27,   27,   47,   64,   37,   47,   64,   44,
   64,   64,   47,   35,   36,   86,   44,   44,   27,  105,
   94,   95,   44,   87,   66,   23,   35,   36,   24,   56,
   45,   46,   47,   48,   49,   64,   64,   64,   64,   64,
   56,   56,   56,   56,   56,   54,   54,   54,   54,   54,
   55,   55,   55,   55,   55,   59,   60,   61,   62,   99,
   99,   99,  100,  101,  102,   32,   64,   63,   32,   64,
   64,   74,   75,   76,   77,   78,   79,   80,   85,   12,
  106,  109,  112,   16,   15,   98,  103,   14,  104,  108,
   64,   13,   64,   40,   88,   64,   55,   18,   52,
};
short msv_check[] = {                                      20,
   20,  256,    7,   59,   60,   61,   62,   32,  266,  264,
  265,   32,   17,   18,  256,   40,  258,   22,  273,   40,
  264,  265,  264,  265,   45,   46,   47,   48,   49,  257,
   86,  273,  257,  271,  271,  257,    8,  274,    7,  267,
  268,  259,  267,  268,  272,   17,  268,  272,  266,   18,
   22,  266,  270,  266,  110,  274,  112,  264,  265,  261,
   81,   82,   83,   84,  263,  259,  273,  266,  262,  266,
  264,  265,  271,  264,  265,   80,  264,  265,   99,   99,
   83,   84,  270,  269,  262,  271,  264,  265,  274,  260,
  275,  276,  277,  278,  279,  275,  276,  277,  278,  279,
  275,  276,  277,  278,  279,  275,  276,  277,  278,  279,
  275,  276,  277,  278,  279,   46,   47,   48,   49,  263,
  263,  263,  266,  266,  266,  263,  263,  273,  266,  266,
  261,  280,  280,  259,  259,  259,  259,  259,  257,  268,
  274,  274,  270,    0,    0,  266,  266,    0,  266,  266,
  266,    0,  259,  266,   81,  270,   43,    8,   40,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 280
#if YYDEBUG
char *msv_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"OBRKT","CBRKT","EQ","COLON",
"DOT","COMMA","SEMI","SPACE","HTAB","LINESEP","NEWLINE","VCARD","BBINDATA",
"EBINDATA","BKSLASH","TERM","WORD","STRING","PROP","PROP_A","PROP_N","PROP_O",
"PROP_AGENT","FLAG",
};
char *msv_rule[] = {
"$accept : msv",
"vcards : vcards junk vcard",
"vcards : vcards vcard",
"vcards : vcard",
"junk : junk atom",
"junk : atom",
"atom : OBRKT NEWLINE",
"atom : OBRKT TERM",
"atom : OBRKT OBRKT",
"atom : VCARD OBRKT",
"atom : VCARD VCARD",
"atom : NEWLINE",
"atom : TERM",
"msv : junk vcards junk",
"msv : junk vcards",
"msv : vcards junk",
"msv : vcards",
"$$1 :",
"$$2 :",
"vcard : OBRKT VCARD $$1 opt_str LINESEP $$2 items CBRKT",
"items : items item",
"items : item",
"$$3 :",
"item : groups PROP flags opt_ws EQ $$3 value LINESEP",
"$$4 :",
"item : groups PROP_A flags opt_ws EQ $$4 semistrings LINESEP",
"$$5 :",
"item : groups PROP_N flags opt_ws EQ $$5 semistrings LINESEP",
"$$6 :",
"item : groups PROP_O flags opt_ws EQ $$6 semistrings LINESEP",
"item : groups PROP_AGENT flags opt_ws EQ vcard opt_ws LINESEP",
"item : error LINESEP",
"opt_str : string",
"opt_str : empty",
"ws : ws SPACE",
"ws : ws HTAB",
"ws : SPACE",
"ws : HTAB",
"opt_ws : ws",
"opt_ws : empty",
"value : string",
"value : binary",
"value : empty",
"$$7 :",
"$$8 :",
"binary : BBINDATA $$7 LINESEP lines LINESEP $$8 opt_ws EBINDATA opt_ws",
"string : string BKSLASH LINESEP STRING",
"string : string BKSLASH LINESEP",
"string : STRING",
"string : BKSLASH LINESEP",
"semistrings : semistrings SEMI opt_str",
"semistrings : opt_str",
"lines : lines LINESEP STRING",
"lines : STRING",
"groups : grouplist DOT",
"groups : ws grouplist DOT",
"groups : ws",
"groups : empty",
"grouplist : grouplist DOT WORD",
"grouplist : WORD",
"flags : flags COMMA FLAG",
"$$9 :",
"flags : COLON $$9 FLAG",
"flags : empty",
"empty :",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE *p_yyval;
YYSTYPE *p_yylval;
short *yyss; /* YYSTACKSIZE long */
YYSTYPE *yyvs; /* YYSTACKSIZE long */
#undef yylval
#define yylval (*p_yylval)
#undef yyval
#define yyval (*p_yyval)
#define yystacksize YYSTACKSIZE
CFUNCTIONS
#line 665 "msv.y"

/***************************************************************************/
/***						The lexical analyzer						****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
#define IsLineBreak(_c) ((_c == '\n') || (_c == '\r'))

/*/////////////////////////////////////////////////////////////////////////*/
/* This appends onto yylval.str, unless MAXTOKEN has been exceeded.
 * In that case, yylval.str is set to 0 length, and longString is used.
 */
static void AppendCharToToken(char c, S32 *len)
{
	if (*len < MAXTOKEN - 1) {
		yylval.str[*len] = c; yylval.str[++(*len)] = 0;
	} else if (*len == MAXTOKEN - 1) { /* copy to "longString" */
		if (!longString) {
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
		}
		memcpy(longString, yylval.str, (size_t)*len + 1);
		longString[*len] = c; longString[++(*len)] = 0;
		yylval.str[0] = 0;
		longStringLen = *len;
	} else {
		if (longStringLen == longStringMax - 1) {
			char __huge *newStr = HNEW(char, longStringMax * 2);
			_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
			longStringMax *= 2;
			HFREE(longString);
			longString = newStr;
		}
		longString[*len] = c; longString[++(*len)] = 0;
		longStringLen = *len;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* StrCat appends onto dst, ensuring that longString is used appropriately.
 * src1 may be of 0 length, in which case "longString" should be used.
 * "longString" would never be used for src2.
 */
static void StrCat(char *dst, const char *src1, const char *src2)
{
	S32 src1Len = strlen(src1);
	S32 src2Len = strlen(src2);
	S32 req;

	if (!src1Len && longString) {
		src1Len = longStringLen;
		src1 = longString;
	}
	if ((req = src1Len + src2Len + 1) > MAXTOKEN) {
		if (longString) { /* longString == src1 */
			if (longStringMax - longStringLen < src2Len) {
				/* since src2Len must be < MAXTOKEN, doubling longString
				   is guaranteed to be enough room */
				char __huge *newStr = HNEW(char, longStringMax * 2);
				_hmemcpy((U8 __huge *)newStr, (U8 __huge *)longString, longStringLen + 1);
				longStringMax *= 2;
				HFREE(longString);
				longString = newStr;
			}
			_hmemcpy((U8 __huge *)(longString + longStringLen), (U8 __huge *)src2, src2Len + 1);
			longStringLen += src2Len;
		} else { /* haven't yet used longString, so set it up */
			longStringMax = MAXTOKEN * 2;
			longString = HNEW(char, longStringMax);
			memcpy(longString, src1, (size_t)src1Len + 1);
			memcpy(longString + src1Len, src2, (size_t)src2Len + 1);
			longStringLen = src1Len + src2Len;
		}
		*dst = 0; /* indicate result is in longString */
	} else { /* both will fit in MAXTOKEN, so src1 can't be longString */
		if (dst != src1)
			strcpy(dst, src1);
		strcat(dst, src2);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Set up the lexor to parse a string value. */
static void ExpectString(void)
{
	stringExpected = TRUE;
	if (longString) {
		HFREE(longString); longString = NULL;
		longStringLen = 0;
	}
	flagExpected = FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
#define FlushWithPending(_t) { \
	if (len) { \
		pendingToken = _t; \
		goto Pending; \
	} else { \
		msv_lineNum += ((_t == LINESEP) || (_t == NEWLINE)); \
		return _t; \
	} \
}

static int peekn;
static char peekc[2];

/*/////////////////////////////////////////////////////////////////////////*/
static char lex_getc()
{
	if (peekn) {
		return peekc[--peekn];
	}
	if (curPos == inputLen)
		return EOF;
	else if (inputString)
		return *(inputString + curPos++);
	else {
		char result;
		return inputFile->Read(&result, 1) == 1 ? result : EOF;
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
static void lex_ungetc(char c)
{
	ASSERT(peekn < 2);
	peekc[peekn++] = c;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* Collect up a string value. */
static int LexString()
{
	char cur;
	S32 len = 0;

	do {
		cur = lex_getc();
		switch (cur) {
			case '\\': { /* check for CR-LF combos after the backslash */
				char next = lex_getc();
				if (semiSpecial && (next == ';')) {
					AppendCharToToken(';', &len);
				} else if (!inBinary && ((next == '\r') || (next == '\n'))) {
					char next2;
					next2 = lex_getc();
					if (!(((next2 == '\r') || (next2 == '\n')) && (next != next2)))
						lex_ungetc(next2);
					lex_ungetc(next); /* so that we'll pick up the LINESEP again */
					pendingToken = BKSLASH;
					goto EndString;
				} else if (!inBinary && (next == '\\')) {
					/* double backslash detected */
					next = lex_getc();
					if ((next == '\r') || (next == '\n')) {
						/* found \\ at end of line */
						char next2;
						next2 = lex_getc();
						if (!(((next2 == '\r') || (next2 == '\n')) && (next != next2)))
							lex_ungetc(next2);
						AppendCharToToken('\\', &len);
						pendingToken = LINESEP;
						goto EndString;
					}
					/* within a line */
					AppendCharToToken('\\', &len);
					lex_ungetc(next); /* now pointing at second backslash */
					/* here we let the top level switch handle it the next
					   time around */
				} else {
					AppendCharToToken(cur, &len);
				}
				break;
			} /* backslash */
			case ';':
				if (semiSpecial) {
					pendingToken = SEMI;
					goto EndString;
				} else
					AppendCharToToken(cur, &len);
				break;
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				pendingToken = LINESEP;
				goto EndString;
			}
			case (char)EOF:
				pendingToken = EOF;
				break;
			default:
				AppendCharToToken(cur, &len);
				break;
		} /* switch */
	} while (cur != (char)EOF);

EndString:
	if (strncmp(yylval.str + strspn(yylval.str, " \t"), "<bindata>", 9) == 0)
		return BBINDATA;
	else if (strncmp(yylval.str + strspn(yylval.str, " \t"), "</bindata>", 10) == 0)
		return EBINDATA;
	else if (!len) {
		/* must have hit something immediately, in which case pendingToken
		   is set.  return it. */
		int result = pendingToken;
		pendingToken = 0;
		msv_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	return STRING;
} /* LexString */

/*/////////////////////////////////////////////////////////////////////////*/
/*
 * Read chars from the input.
 * Return one of the token types (or -1 for EOF).
 * Set yylval to indicate the value of the token, if any.
 */
int msv_lex();
int msv_lex()
{
	char cur;
	S32 len = 0;

	if (pendingToken) {
		int result = pendingToken;
		pendingToken = 0;
		msv_lineNum += ((result == LINESEP) || (result == NEWLINE));
		return result;
	}

	yylval.str[0] = 0;

	if (stringExpected)
		return LexString();
	else if (curCard == -1) {
		do {
			cur = lex_getc();
			switch (cur) {
				case '[':  FlushWithPending(OBRKT);
				case ' ':
				case '\t':
					if (len) goto Pending;
					break;
				case '\r':
				case '\n': {
					char next = lex_getc();
					if (!(((next == '\r') || (next == '\n')) && (cur != next)))
						lex_ungetc(next);
					FlushWithPending(NEWLINE);
				}
				case (char)EOF: FlushWithPending(EOF);
				default:
					yylval.str[len] = cur; yylval.str[++len] = 0;
					break;
			} /* switch */
		} while (len < MAXTOKEN-1);
		goto Pending;
	}

	do {
		cur = lex_getc();
		switch (cur) {
			case '[':  FlushWithPending(OBRKT);
			case ']':  FlushWithPending(CBRKT);
			case '=':  FlushWithPending(EQ);
			case ':':  FlushWithPending(COLON);
			case '.':  FlushWithPending(DOT);
			case ',':  FlushWithPending(COMMA);
			case ' ':  FlushWithPending(SPACE);
			case '\t': FlushWithPending(HTAB);
			case '\\': FlushWithPending(BKSLASH);
			case '\r':
			case '\n': {
				char next = lex_getc();
				if (!(((next == '\r') || (next == '\n')) && (cur != next)))
					lex_ungetc(next);
				FlushWithPending(LINESEP);
			}
			case (char)EOF: FlushWithPending(EOF);
			default:
				yylval.str[len] = cur; yylval.str[++len] = 0;
				break;
		} /* switch */
	} while (len < MAXTOKEN-1);
	return WORD;

Pending:
	{
		if (strcmp(yylval.str, "vCard") == 0) {
			if (pendingToken == NEWLINE)
				pendingToken = LINESEP;
			return VCARD;
		}
		if (flagExpected) {
			FLAGS_STRUCT flags;
			if (StrToFlags(yylval.str, &flags, NULL)) {
				yylval.flags = flags;
				return FLAG;
			} else {
				char buf[40];
				sprintf(buf, "unknown flag name \"%s\"", yylval.str);
				yyerror(buf);
			}
		} else if ((curCard != -1) && Lookup(mapProps, yylval.str)
			|| (strnicmp(yylval.str, "X-", 2) == 0)) {
#if YYDEBUG
			if (yydebug) {
				char buf[80];
				sprintf(buf, "property \"%s\"\n", yylval.str);
				Parse_Debug(buf);
			}
#endif
			/* check for special props that are tokens */
			if (stricmp(yylval.str, "A") == 0)
				return PROP_A;
			else if (stricmp(yylval.str, "N") == 0)
				return PROP_N;
			else if (stricmp(yylval.str, "O") == 0)
				return PROP_O;
			else if (stricmp(yylval.str, "AGENT") == 0)
				return PROP_AGENT;
			else
				return PROP;
		}
	}
	return (curCard == -1) ? TERM : WORD;
}


/***************************************************************************/
/***							Public Functions						****/
/***************************************************************************/

static BOOL Parse_MSVHelper(CList *vcList)
{
	BOOL success = FALSE;

	curCard = -1;
	msv_numErrors = 0;
	InitMapProps();
	pendingToken = 0;
	msv_lineNum = 1;
	peekn = 0;
	global_vcList = vcList;

	stringExpected = flagExpected = FALSE;
	longString = NULL; longStringLen = 0; longStringMax = 0;

	/* this winds up invoking the Parse_* callouts. */
	if (yyparse() != 0)
		goto Done;

	success = TRUE;

Done:
	if (longString) { HFREE(longString); longString = NULL; }
	RemoveAll(mapProps); delete mapProps; mapProps = NULL;
	if (!success) {
		for (int i = 0; i < MAXCARD; i++)
			if (cardToBuild[i]) {
				delete cardToBuild[i];
				cardToBuild[i] = NULL;
			}
		if (cardBuilt) delete cardBuilt;
	}
	cardBuilt = NULL;
	return success;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;

	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	result = Parse_MSVHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else
		*card = NULL;
	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
extern BOOL Parse_Many_MSV(
	const char *input,	/* In */
	S32 len,			/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	inputString = input;
	inputLen = len;
	curPos = 0;
	inputFile = NULL;
	return Parse_MSVHelper(vcList);
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This is the public API to call to parse a buffer and create a CVCard. */
BOOL Parse_MSV_FromFile(
	CFile *file,		/* In */
	CVCard **card)		/* Out */
{
	CList vcList;
	BOOL result;
	DWORD startPos;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	result = Parse_MSVHelper(&vcList);
	if (vcList.GetCount()) {
		BOOL first = TRUE;
		for (CLISTPOSITION pos = vcList.GetHeadPosition(); pos; ) {
			CVCard *vCard = (CVCard *)vcList.GetNext(pos);
			if (first) {
				*card = vCard;
				first = FALSE;
			} else
				delete vCard;
		}
	} else {
		*card = NULL;
		file->Seek(startPos, CFile::begin);
	}
	return result;
}

extern BOOL Parse_Many_MSV_FromFile(
	CFile *file,		/* In */
	CList *vcList)		/* Out: CVCard objects added to existing list */
{
	DWORD startPos;
	BOOL result;

	inputString = NULL;
	inputLen = -1;
	curPos = 0;
	inputFile = file;
	startPos = file->GetPosition();
	if (!(result = Parse_MSVHelper(vcList)))
		file->Seek(startPos, CFile::begin);
	return result;
}


/***************************************************************************/
/***						Parser Callout Functions					****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
static void YYDebug(const char *s)
{
	Parse_Debug(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL StrToFlags(const char *s, FLAGS_STRUCT *flags, VC_PTR_FLAGS capFlags)
{
	int i;

	memset(flags, 0, sizeof(*flags));
	
	if (strnicmp(s, "X-", 2) == 0) {
		strcpy(flags->extended, s);
		return TRUE;
	}

	for (i = 0; generalFlags[i].name; i++)
		if (stricmp(s, strrchr(generalFlags[i].name, '/') + 1) == 0) {
			flags->known[0] = generalFlags[i].name;
			if (capFlags) capFlags->general |= generalFlags[i].value;
			return TRUE;
		}
	for (i = 0; emailFlags[i].name; i++)
		if (stricmp(s, strrchr(emailFlags[i].name, '/') + 1) == 0) {
			flags->known[0] = emailFlags[i].name;
			if (capFlags)
				capFlags->email = (VC_EMAIL_TYPE)emailFlags[i].value;
			return TRUE;
		}
	for (i = 0; videoFlags[i].name; i++)
		if (stricmp(s, strrchr(videoFlags[i].name, '/') + 1) == 0) {
			flags->known[0] = videoFlags[i].name;
			if (capFlags)
				capFlags->video = (VC_VIDEO_TYPE)videoFlags[i].value;
			return TRUE;
		}
	if (stricmp(s, "WAV") == 0) {
		flags->known[0] = audioFlags[0].name;
		if (capFlags)
			capFlags->audio = (VC_AUDIO_TYPE)audioFlags[0].value;
		return TRUE;
	}
	return FALSE;
}

static BOOL NeedsQP(const char* str)
{
	while (*str) {
		if (!((*str >= 32 && *str <= 60) || (*str >= 62 && *str <= 126)))
			return TRUE;
		str++;
	}
	return FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Assoc(
	const char *groups, const char *prop, FLAGS_STRUCT *flags, const char *value)
{
	CVCNode *node = NULL;
	const char *propName;
	const char *val = *value ? value : longString;
	S32 valLen = *value ? strlen(value) : longStringLen;

	if (!valLen)
		return TRUE; /* don't treat an empty value as a syntax error */

	propName = Lookup(mapProps, prop);
	/* prop is a word like "PN", and propName is now */
	/* the real prop name of the form "+//ISBN 1-887687-00-9::versit..." */
	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		node = bodyToBuild->AddPart();
	}

	if (!propName) { /* it's an extended property */
		if (FlagsHave(flags, vcBase64Prop)) {
			U8 __huge *bytes;
			S32 len;
			bytes = DataFromBase64(val, valLen, &len);
			if (bytes) {
				node->AddProp(new CVCProp(prop, vcOctetsType, bytes, len));
				HFREE(bytes);
				AddBoolProps(node, flags);
			} else
				return FALSE;
		} else {
			node->AddStringProp(prop, value);
			AddBoolProps(node, flags);
			node->AddBoolProp(vcQuotedPrintableProp);
		}
		return TRUE;
	}

	if ((strcmp(propName, vcLogoProp) == 0)
		|| (strcmp(propName, vcPhotoProp) == 0)) {
		if (FlagsHave(flags, vcGIFProp) && FlagsHave(flags, vcBase64Prop)) {
			U8 *bytes;
			S32 len;
			bytes = DataFromBase64(val, valLen, &len);
			if (bytes) {
				node->AddProp(new CVCProp(propName, VCGIFType, bytes, len));
				HFREE(bytes);
				AddBoolProps(node, flags);
			} else
				return FALSE;
		}
	} else if (strcmp(propName, vcPronunciationProp) == 0) {
		if (FlagsHave(flags, vcBase64Prop)) {
			if (FlagsHave(flags, vcWAVEProp) && FlagsHave(flags, vcBase64Prop)) {
				U8 __huge *bytes;
				S32 len;
				bytes = DataFromBase64(val, valLen, &len);
				if (bytes) {
					node->AddProp(new CVCProp(propName, VCWAVType, bytes, len));
					HFREE(bytes);
					AddBoolProps(node, flags);
				} else
					return FALSE;
			}
		} else {
			node->AddStringProp(propName, value);
			AddBoolProps(node, flags);
			if (NeedsQP(value))
				node->AddBoolProp(vcQuotedPrintableProp);
		}
	} else if ((strcmp(propName, vcPublicKeyProp) == 0)
		&& FlagsHave(flags, vcBase64Prop)) {
		U8 __huge *bytes;
		S32 len;
		bytes = DataFromBase64(val, valLen, &len);
		if (bytes) {
			node->AddProp(new CVCProp(propName, VCOctetsType, bytes, len));
			HFREE(bytes);
			AddBoolProps(node, flags);
		} else
			return FALSE;
	} else {
		node->AddStringProp(propName, value);
		AddBoolProps(node, flags);
		if (NeedsQP(value))
			node->AddBoolProp(vcQuotedPrintableProp);
	}

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_SemiValue(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	char *parts, const char **props)
{
	CVCNode *node = NULL;
	const char *propName = Lookup(mapProps, prop);
	char *p = *parts ? parts : longString;
	int i = 0;
	char *sep;
	BOOL needsQP = FALSE;

	if (!*p)
		return TRUE; /* don't treat an empty value as a syntax error */

	do {
		if ((sep = strchr(p, '\177')))
			*sep = 0;
		if (strlen(p)) {
			if (!node) {
				if (*groups) {
					node = FindOrCreatePart(bodyToBuild, groups);
				} else { /* this is a "top level" property name */
					node = bodyToBuild->AddPart();
				}
			}
			node->AddStringProp(props[i], p);
			needsQP |= NeedsQP(p);
		}
		if (sep)
			p = sep + 1;
	} while (sep && props[++i]);

	if (node) {
		AddBoolProps(node, flags);
		if (needsQP)
			node->AddBoolProp(vcQuotedPrintableProp);
	}

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL Parse_Agent(
	const char *groups, const char *prop, FLAGS_STRUCT *flags,
	CVCard *agentCard)
{
	CVCNode *node = NULL;

	if (*groups) {
		node = FindOrCreatePart(bodyToBuild, groups);
	} else { /* this is a "top level" property name */
		node = bodyToBuild->AddPart();
	}

	node->AddProp(new CVCProp(vcAgentProp, VCNextObjectType, agentCard));
	AddBoolProps(node, flags);

	return TRUE;
}


/***************************************************************************/
/***						Private Utility Functions					****/
/***************************************************************************/

/*/////////////////////////////////////////////////////////////////////////*/
static void AddAssoc(CList *table, const char *key, const char *value)
{
	AssocEntry *entry = new AssocEntry;
	int len;

	if ((len = strlen(key)) < MAXASSOCKEY)
		strcpy(entry->key, key);
	else {
		strncpy(entry->key, key, MAXASSOCKEY - 1);
		entry->key[MAXASSOCKEY - 1] = 0;
	}

	if ((len = strlen(value)) < MAXASSOCVALUE)
		strcpy(entry->value, value);
	else {
		strncpy(entry->value, value, MAXASSOCVALUE - 1);
		entry->value[MAXASSOCVALUE - 1] = 0;
	}
	table->AddTail(entry);
}

/*/////////////////////////////////////////////////////////////////////////*/
# if 0
static void SetAssoc(CList *table, const char *key, const char *value)
{
	for (CLISTPOSITION pos = table->GetHeadPosition(); pos; ) {
		AssocEntry *entry = (AssocEntry *)table->GetNext(pos);
		if (strcmp(key, entry->key) == 0) {
			int len;
			if ((len = strlen(value)) < MAXASSOCVALUE)
				strcpy(entry->value, value);
			else {
				strncpy(entry->value, value, MAXASSOCVALUE - 1);
				entry->value[MAXASSOCVALUE - 1] = 0;
			}
			return;
		}
	}
	AddAssoc(table, key, value);
}
#endif

/*/////////////////////////////////////////////////////////////////////////*/
static const char *Lookup(CList *table, const char *key)
{
	for (CLISTPOSITION pos = table->GetHeadPosition(); pos; ) {
		AssocEntry *entry = (AssocEntry *)table->GetNext(pos);
		if (stricmp(key, entry->key) == 0)
			return entry->value;
	}
	return NULL;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void RemoveAll(CList *table)
{
	for (CLISTPOSITION pos = table->GetHeadPosition(); pos; ) {
		AssocEntry *entry = (AssocEntry *)table->GetNext(pos);
		delete entry;
	}
	table->RemoveAll();
}

/*/////////////////////////////////////////////////////////////////////////*/
/* "name" is of the form A.FOO.BAZ, where each is a node name. */
/* Walk the node tree starting at "node" looking for part objects */
/* having the given name for that level.  At each level, if a part */
/* object isn't found, create one and give it that name. */
CVCNode* FindOrCreatePart(CVCNode *node, const char *name)
{
	const char *remain = name;
	char *dot = strchr(remain, '.');
	int size, len;
	char thisName[128];
	wchar_t *thisUnicode;
	CVCNode *thisNode = node, *thisPart;
	CList *props;

	do {
		if (dot) {
			len = dot - remain;
			strncpy(thisName, remain, len);
			*(thisName + len) = 0;
		} else
			strcpy(thisName, remain);
		thisUnicode = FakeUnicode(thisName, &size);
		props = thisNode->GetProps();
		thisPart = NULL;

		for (CLISTPOSITION pos = props->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)props->GetNext(pos);

			if (strcmp(prop->GetName(), vcPartProp) != 0)
				continue;

			CVCNode *part = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			CVCProp *nodeNameProp;
			if (!(nodeNameProp = part->GetProp(vcNodeNameProp)))
				continue;
			if (wcscmp(thisUnicode, (wchar_t *)nodeNameProp->FindValue(VCStrIdxType)->GetValue()) == 0) {
				thisPart = part;
				break;
			}
		}

		delete [] thisUnicode;

		if (!thisPart) {
			thisPart = thisNode->AddPart();
			thisPart->AddStringProp(vcNodeNameProp, thisName);
		}

		if (!dot)
			return thisPart;

		remain = dot + 1;
		dot = strchr(remain, '.');
		thisNode = thisPart;
	} while (TRUE);
	return NULL; /* never reached */
} /* FindOrCreatePart */

/*/////////////////////////////////////////////////////////////////////////*/
static void InitMapProps(void)
{
	mapProps = new CList;

	AddAssoc(mapProps, "LOGO", vcLogoProp);
	AddAssoc(mapProps, "PHOTO", vcPhotoProp);
	AddAssoc(mapProps, "FADR", vcDeliveryLabelProp);
	AddAssoc(mapProps, "A", msv_address);
	AddAssoc(mapProps, "FN", vcFullNameProp);
	AddAssoc(mapProps, "TITLE", vcTitleProp);
	AddAssoc(mapProps, "O", msv_orgname_orgunit);
	AddAssoc(mapProps, "N", msv_fam_given);
	AddAssoc(mapProps, "PN", vcPronunciationProp);
	AddAssoc(mapProps, "LANG", vcLanguageProp);
	AddAssoc(mapProps, "T", vcTelephoneProp);
	AddAssoc(mapProps, "EMAIL", vcEmailAddressProp);
	AddAssoc(mapProps, "TZ", vcTimeZoneProp);
	AddAssoc(mapProps, "GEO", vcLocationProp);
	AddAssoc(mapProps, "NOTE", vcCommentProp);
	AddAssoc(mapProps, "URL", vcURLProp);
	AddAssoc(mapProps, "CS", vcCharSetProp);
	AddAssoc(mapProps, "REV", vcLastRevisedProp);
	AddAssoc(mapProps, "UID", vcUniqueStringProp);
	AddAssoc(mapProps, "KEY", vcPublicKeyProp);
	AddAssoc(mapProps, "MAILER", vcMailerProp);
	AddAssoc(mapProps, "AGENT", vcAgentProp);
	AddAssoc(mapProps, "BD", vcBirthDateProp);
	AddAssoc(mapProps, "ROLE", vcBusinessRoleProp);
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This parses and converts the base64 format for binary encoding into
 * a decoded buffer (allocated with new).  See RFC 1521.
 */
static U8 __huge * DataFromBase64(
	const char __huge *str, S32 strLen, S32 *len)
{
	S32 cur = 0, bytesLen = 0, bytesMax = 0;
	int quadIx = 0, pad = 0;
	U32 trip = 0;
	U8 b;
	char c;
	U8 __huge *bytes = NULL;

	while (cur < strLen) {
		c = str[cur];
		if ((c >= 'A') && (c <= 'Z'))
			b = (U8)(c - 'A');
		else if ((c >= 'a') && (c <= 'z'))
			b = (U8)(c - 'a') + 26;
		else if ((c >= '0') && (c <= '9'))
			b = (U8)(c - '0') + 52;
		else if (c == '+')
			b = 62;
		else if (c == '/')
			b = 63;
		else if (c == '=') {
			b = 0;
			pad++;
		} else if ((c == '\n') || (c == ' ') || (c == '\t')) {
			cur++;
			continue;
		} else { /* error condition */
			if (bytes) delete [] bytes;
			return NULL;
		}
		trip = (trip << 6) | b;
		if (++quadIx == 4) {
			U8 outBytes[3];
			int numOut;
			for (int i = 0; i < 3; i++) {
				outBytes[2-i] = (U8)(trip & 0xFF);
				trip >>= 8;
			}
			numOut = 3 - pad;
			if (bytesLen + numOut > bytesMax) {
				if (!bytes) {
					bytes = HNEW(U8, 1024L);
					bytesMax = 1024;
				} else {
					U8 __huge *newBytes = HNEW(U8, bytesMax * 2);
					_hmemcpy(newBytes, bytes, bytesLen);
					HFREE(bytes);
					bytes = newBytes;
					bytesMax *= 2;
				}
			}
			memcpy(bytes + bytesLen, outBytes, numOut);
			bytesLen += numOut;
			trip = 0;
			quadIx = 0;
		}
		cur++;
	} /* while */
	*len = bytesLen;
	return bytes;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This creates an empty CVCard shell with an English body in preparation
 * for parsing properties onto it.  This is used for both the outermost
 * card, as well as any AGENT properties, which are themselves vCards.
 */
static BOOL PushVCard()
{
	CVCard *card;
	CVCNode *root, *english;

	if (curCard == MAXCARD - 1)
		return FALSE;

	card = new CVCard;
	card->AddObject(root = new CVCNode);					/* create root */
	root->AddProp(new CVCProp(VCRootObject));				/* mark it so */

	/* add a body having the default language */
	english = root->AddObjectProp(vcBodyProp, VCBodyObject);
	cardToBuild[++curCard] = card;
	bodyToBuild = english;

	return TRUE;
}

/*/////////////////////////////////////////////////////////////////////////*/
/* This pops the recently built vCard off the stack and returns it. */
static CVCard* PopVCard()
{
	CVCard *result = cardToBuild[curCard];

	cardToBuild[curCard--] = NULL;
	bodyToBuild = (curCard == -1) ? NULL : cardToBuild[curCard]->FindBody();

	return result;
}

/*/////////////////////////////////////////////////////////////////////////*/
static int flagslen(const char **flags)
{
	int i;
	for (i = 0; *flags; flags++, i++) ;
	return i;
}

/*/////////////////////////////////////////////////////////////////////////*/
static BOOL FlagsHave(FLAGS_STRUCT *flags, const char *propName)
{
	const char **kf = flags->known;

	while (*kf)
		if (*kf++ == propName)
			return TRUE;
	return FALSE;
}

/*/////////////////////////////////////////////////////////////////////////*/
static void AddBoolProps(CVCNode *node, FLAGS_STRUCT *flags)
{
	const char **kf = flags->known;
	const char *ext = flags->extended;

	// process the known boolean properties
	while (*kf) {
		node->AddBoolProp(*kf);
		kf++;
	}

	// process the extended boolean properties
	while (*ext) {
		node->AddBoolProp(ext);
		ext += strlen(ext) + 1;
	}
}

#line 1712 "msv_tab.cpp"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    int yym, yyn, yystate, yyresult;
#if YYDEBUG
    char *yys;
    char debugbuf[1024];

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    p_yyval = NULL; p_yylval = NULL; yyss = NULL; yyvs = NULL;
    if ((p_yyval = (YYSTYPE*)malloc(sizeof(*p_yyval))) == NULL) goto yyabort;
    if ((p_yylval = (YYSTYPE*)malloc(sizeof(*p_yylval))) == NULL) goto yyabort;
    if ((yyss = (short*)malloc(sizeof(*yyss) * YYSTACKSIZE)) == NULL) goto yyabort;
    if ((yyvs = (YYSTYPE*)malloc(sizeof(*yyvs) * YYSTACKSIZE)) == NULL) goto yyabort;

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, "%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]); YYDebug(debugbuf);}
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, 
                        "%sdebug: state %d, error recovery shifting to state %d\n",
                        YYPREFIX, *yyssp, yytable[yyn]); YYDebug(debugbuf);}
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug) {
                    sprintf(debugbuf, "%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp); YYDebug(debugbuf);}
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            sprintf(debugbuf, "%sdebug: state %d, error recovery discards token %d(%s)\n",
                    YYPREFIX, yystate, yychar, yys); YYDebug(debugbuf);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, "%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]); YYDebug(debugbuf);}
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 472 "msv.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 2:
#line 474 "msv.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 3:
#line 476 "msv.y"
{ global_vcList->AddTail(yyvsp[0].vCard); }
break;
case 17:
#line 499 "msv.y"
{
				if (!PushVCard())
					YYERROR;
				ExpectString();
			}
break;
case 18:
#line 505 "msv.y"
{ stringExpected = FALSE; }
break;
case 19:
#line 507 "msv.y"
{ yyval.vCard = PopVCard(); }
break;
case 22:
#line 515 "msv.y"
{ ExpectString(); }
break;
case 23:
#line 517 "msv.y"
{
				if (!Parse_Assoc(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str))
					YYERROR;
			}
break;
case 24:
#line 522 "msv.y"
{ ExpectString(); semiSpecial = TRUE; }
break;
case 25:
#line 524 "msv.y"
{
				semiSpecial = stringExpected = FALSE;
				if (!Parse_SemiValue(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str, addrProps))
					YYERROR;
			}
break;
case 26:
#line 530 "msv.y"
{ ExpectString(); semiSpecial = TRUE; }
break;
case 27:
#line 532 "msv.y"
{
				semiSpecial = stringExpected = FALSE;
				if (!Parse_SemiValue(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str, nameProps))
					YYERROR;
			}
break;
case 28:
#line 538 "msv.y"
{ ExpectString(); semiSpecial = TRUE; }
break;
case 29:
#line 540 "msv.y"
{
				semiSpecial = stringExpected = FALSE;
				if (!Parse_SemiValue(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-1].str, orgProps))
					YYERROR;
			}
break;
case 30:
#line 546 "msv.y"
{
				if (!Parse_Agent(yyvsp[-7].str, yyvsp[-6].str, &(yyvsp[-5].flags), yyvsp[-2].vCard)) {
					delete yyvsp[-2].vCard;
					YYERROR;
				}
			}
break;
case 31:
#line 553 "msv.y"
{
				stringExpected = flagExpected = FALSE;
				yyerrok;
				yyclearin;
			}
break;
case 33:
#line 560 "msv.y"
{ yyval.str[0] = 0; }
break;
case 40:
#line 573 "msv.y"
{ stringExpected = FALSE; }
break;
case 41:
#line 575 "msv.y"
{ stringExpected = FALSE; }
break;
case 42:
#line 577 "msv.y"
{
				yyval.str[0] = 0;
				stringExpected = FALSE;
			}
break;
case 43:
#line 583 "msv.y"
{ inBinary = TRUE; }
break;
case 44:
#line 585 "msv.y"
{ inBinary = FALSE; }
break;
case 45:
#line 586 "msv.y"
{
				StrCat(yyval.str, yyvsp[-5].str, "");
			}
break;
case 46:
#line 592 "msv.y"
{
				StrCat(yyval.str, yyvsp[-3].str, "\n");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 47:
#line 597 "msv.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\n");
			}
break;
case 49:
#line 602 "msv.y"
{
				StrCat(yyval.str, "\n", "");
			}
break;
case 50:
#line 608 "msv.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\177");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 52:
#line 616 "msv.y"
{
				StrCat(yyval.str, yyvsp[-2].str, "\n");
				StrCat(yyval.str, yyval.str, yyvsp[0].str);
			}
break;
case 55:
#line 625 "msv.y"
{ StrCat(yyval.str, yyvsp[-1].str, ""); }
break;
case 56:
#line 627 "msv.y"
{ yyval.str[0] = 0; }
break;
case 57:
#line 629 "msv.y"
{ yyval.str[0] = 0; }
break;
case 58:
#line 633 "msv.y"
{
				strcpy(yyval.str, yyvsp[-2].str);
				strcat(yyval.str, ".");
				strcat(yyval.str, yyvsp[0].str);
			}
break;
case 60:
#line 642 "msv.y"
{
				yyval.flags = yyvsp[-2].flags;
				if (yyvsp[0].flags.known[0]) {
					int len = flagslen(yyvsp[-2].flags.known);
					yyval.flags.known[len] = yyvsp[0].flags.known[0];
					yyval.flags.known[len+1] = NULL;
				} else {
					char *p = yyval.flags.extended;
					int len = strlen(yyvsp[0].flags.extended);
					while (*p) p += strlen(p) + 1;
					memcpy(p, yyvsp[0].flags.extended, len + 1);
					*(p + len + 1) = 0;
				}
			}
break;
case 61:
#line 656 "msv.y"
{ flagExpected = TRUE; }
break;
case 62:
#line 657 "msv.y"
{ yyval.flags = yyvsp[0].flags; }
break;
case 63:
#line 659 "msv.y"
{ yyval.flags.known[0] = NULL; yyval.flags.extended[0] = 0; }
break;
#line 2067 "msv_tab.cpp"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug) {
            sprintf(debugbuf, 
                "%sdebug: after reduction, shifting from state 0 to state %d\n",
                YYPREFIX, YYFINAL); YYDebug(debugbuf);}
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                sprintf(debugbuf, "%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys); YYDebug(debugbuf);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug) {
        sprintf(debugbuf, 
            "%sdebug: after reduction, shifting from state %d to state %d\n",
            YYPREFIX, *yyssp, yystate); YYDebug(debugbuf);}
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    yyresult = 1;
    goto yyfinish;
yyaccept:
    yyresult = 0;
yyfinish:
    if (p_yyval) free(p_yyval);
    if (p_yylval) free(p_yylval);
    if (yyss) free(yyss);
    if (yyvs) free(yyvs);
    return yyresult;
}
END_CFUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\parse.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __PARSE_H__
#define __PARSE_H__

extern const char* vcDefaultLang;

extern const char* vcISO9070Prefix;
extern const char* vcClipboardFormatVCard;

extern const char* vcISO639Type;
extern const char* vcStrIdxType;
extern const char* vcFlagsType;
extern const char* vcNextObjectType;
extern const char* vcNullType;

// These three types have __huge values
extern const char* vcOctetsType;
extern const char* vcGIFType;
extern const char* vcWAVType;

extern const char* vcRootObject;
extern const char* vcBodyObject;
extern const char* vcPartObject;
extern const char* vcBodyProp;
extern const char* vcPartProp;
extern const char* vcNextObjectProp;

extern const char* vcLogoProp;
extern const char* vcPhotoProp;
extern const char* vcDeliveryLabelProp;
extern const char* vcPostalBoxProp;
extern const char* vcStreetAddressProp;
extern const char* vcExtAddressProp;
extern const char* vcCountryNameProp;
extern const char* vcPostalCodeProp;
extern const char* vcRegionProp;
extern const char* vcCityProp;
extern const char* vcFullNameProp;
extern const char* vcTitleProp;
extern const char* vcOrgNameProp;
extern const char* vcOrgUnitProp;
extern const char* vcOrgUnit2Prop;
extern const char* vcOrgUnit3Prop;
extern const char* vcOrgUnit4Prop;
extern const char* vcFamilyNameProp;
extern const char* vcGivenNameProp;
extern const char* vcAdditionalNamesProp;
extern const char* vcNamePrefixesProp;
extern const char* vcNameSuffixesProp;
extern const char* vcPronunciationProp;
extern const char* vcLanguageProp;
extern const char* vcTelephoneProp;
extern const char* vcEmailAddressProp;
extern const char* vcTimeZoneProp;
extern const char* vcLocationProp;
extern const char* vcCommentProp;
extern const char* vcCharSetProp;
extern const char* vcLastRevisedProp;
extern const char* vcUniqueStringProp;
extern const char* vcPublicKeyProp;
extern const char* vcMailerProp;
extern const char* vcAgentProp;
extern const char* vcBirthDateProp;
extern const char* vcBusinessRoleProp;
extern const char* vcCaptionProp;
extern const char* vcURLProp;

extern const char* vcDomesticProp;
extern const char* vcInternationalProp;
extern const char* vcPostalProp;
extern const char* vcParcelProp;
extern const char* vcHomeProp;
extern const char* vcWorkProp;
extern const char* vcPreferredProp;
extern const char* vcVoiceProp;
extern const char* vcFaxProp;
extern const char* vcMessageProp;
extern const char* vcCellularProp;
extern const char* vcPagerProp;
extern const char* vcBBSProp;
extern const char* vcModemProp;
extern const char* vcCarProp;
extern const char* vcISDNProp;
extern const char* vcVideoProp;

extern const char* vcInlineProp;
extern const char* vcURLValueProp;
extern const char* vcContentIDProp;

extern const char* vc7bitProp;
extern const char* vcQuotedPrintableProp;
extern const char* vcBase64Prop;

extern const char* vcAOLProp;
extern const char* vcAppleLinkProp;
extern const char* vcATTMailProp;
extern const char* vcCISProp;
extern const char* vcEWorldProp;
extern const char* vcInternetProp;
extern const char* vcIBMMailProp;
extern const char* vcMSNProp;
extern const char* vcMCIMailProp;
extern const char* vcPowerShareProp;
extern const char* vcProdigyProp;
extern const char* vcTLXProp;
extern const char* vcX400Prop;

extern const char* vcGIFProp;
extern const char* vcCGMProp;
extern const char* vcWMFProp;
extern const char* vcBMPProp;
extern const char* vcMETProp;
extern const char* vcPMBProp;
extern const char* vcDIBProp;
extern const char* vcPICTProp;
extern const char* vcTIFFProp;
extern const char* vcAcrobatProp;
extern const char* vcPSProp;
extern const char* vcJPEGProp;
extern const char* vcQuickTimeProp;
extern const char* vcMPEGProp;
extern const char* vcMPEG2Prop;
extern const char* vcAVIProp;

extern const char* vcWAVEProp;
extern const char* vcAIFFProp;
extern const char* vcPCMProp;

extern const char* vcX509Prop;
extern const char* vcPGPProp;

extern const char* vcNodeNameProp;

#endif // __PARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\propemal.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// propemal.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "propemal.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropEmail property page

IMPLEMENT_DYNCREATE(CPropEmail, CPropertyPage)

CPropEmail::CPropEmail() : CPropertyPage(CPropEmail::IDD)
{
	//{{AFX_DATA_INIT(CPropEmail)
	m_popup_std1 = _T("");
	m_popup_std2 = _T("");
	m_popup_std3 = _T("");
	m_edit_email1 = _T("");
	m_edit_email2 = _T("");
	m_edit_email3 = _T("");
	m_button_pref2 = FALSE;
	m_button_pref1 = FALSE;
	m_button_pref3 = FALSE;
	m_button_office1 = FALSE;
	m_button_office2 = FALSE;
	m_button_office3 = FALSE;
	m_button_home1 = FALSE;
	m_button_home2 = FALSE;
	m_button_home3 = FALSE;
	//}}AFX_DATA_INIT

	m_node1 = m_node2 = m_node3 = NULL;
}

CPropEmail::~CPropEmail()
{
}

void CPropEmail::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropEmail)
	DDX_CBString(pDX, IDC_EDIT_EMAIL_STANDARD, m_popup_std1);
	DDX_CBString(pDX, IDC_EDIT_EMAIL_STANDARD2, m_popup_std2);
	DDX_CBString(pDX, IDC_EDIT_EMAIL_STANDARD3, m_popup_std3);
	DDX_Text(pDX, IDC_EDIT_EMAIL_STRING, m_edit_email1);
	DDX_Text(pDX, IDC_EDIT_EMAIL_STRING2, m_edit_email2);
	DDX_Text(pDX, IDC_EDIT_EMAIL_STRING3, m_edit_email3);
	DDX_Check(pDX, IDC_EDIT_PREFERRED4, m_button_pref2);
	DDX_Check(pDX, IDC_EDIT_PREFERRED, m_button_pref1);
	DDX_Check(pDX, IDC_EDIT_PREFERRED5, m_button_pref3);
	DDX_Check(pDX, IDC_EDIT_OFFICE, m_button_office1);
	DDX_Check(pDX, IDC_EDIT_OFFICE4, m_button_office2);
	DDX_Check(pDX, IDC_EDIT_OFFICE5, m_button_office3);
	DDX_Check(pDX, IDC_EDIT_HOME, m_button_home1);
	DDX_Check(pDX, IDC_EDIT_HOME2, m_button_home2);
	DDX_Check(pDX, IDC_EDIT_HOME4, m_button_home3);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropEmail, CPropertyPage)
	//{{AFX_MSG_MAP(CPropEmail)
	ON_BN_CLICKED(IDC_BUTTON_MAIL, OnButtonMail)
	ON_BN_CLICKED(IDC_BUTTON_MAIL2, OnButtonMail2)
	ON_BN_CLICKED(IDC_BUTTON_MAIL3, OnButtonMail3)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
void CPropEmail::Mail(const CString &recip)
{
	// TODO: implement MAPI calls here
}

/////////////////////////////////////////////////////////////////////////////
// CPropEmail message handlers

void CPropEmail::OnButtonMail() 
{
	Mail(m_edit_email1);
}

void CPropEmail::OnButtonMail2() 
{
	Mail(m_edit_email2);
}

void CPropEmail::OnButtonMail3() 
{
	Mail(m_edit_email3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocb.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocb.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "proplocb.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropLocBasic property page

IMPLEMENT_DYNCREATE(CPropLocBasic, CPropertyPage)

CPropLocBasic::CPropLocBasic() : CPropertyPage(CPropLocBasic::IDD)
{
	//{{AFX_DATA_INIT(CPropLocBasic)
	m_button_home = FALSE;
	m_edit_location = _T("");
	m_button_office = FALSE;
	m_button_parcel = FALSE;
	m_button_postal = FALSE;
	m_edit_postdom = _T("");
	m_edit_postintl = _T("");
	m_edit_timezone = _T("");
	//}}AFX_DATA_INIT

	m_nodeloc = m_nodetz = m_nodepostdom = m_nodepostintl = NULL;
}

CPropLocBasic::~CPropLocBasic()
{
}

void CPropLocBasic::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropLocBasic)
	DDX_Check(pDX, IDC_EDIT_HOME, m_button_home);
	DDX_Text(pDX, IDC_EDIT_LOCATION, m_edit_location);
	DDX_Check(pDX, IDC_EDIT_OFFICE, m_button_office);
	DDX_Check(pDX, IDC_EDIT_PARCEL, m_button_parcel);
	DDX_Check(pDX, IDC_EDIT_POSTAL, m_button_postal);
	DDX_Text(pDX, IDC_EDIT_POSTDOM, m_edit_postdom);
	DDX_Text(pDX, IDC_EDIT_POSTINTL, m_edit_postintl);
	DDX_Text(pDX, IDC_EDIT_TIME_ZONE, m_edit_timezone);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropLocBasic, CPropertyPage)
	//{{AFX_MSG_MAP(CPropLocBasic)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropLocBasic message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocx.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocx.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "proplocx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropLocX property page

IMPLEMENT_DYNCREATE(CPropLocX, CPropertyPage)

CPropLocX::CPropLocX() : CPropertyPage(CPropLocX::IDD)
{
	//{{AFX_DATA_INIT(CPropLocX)
	m_edit_city = _T("");
	m_edit_cntry = _T("");
	m_edit_xaddr = _T("");
	m_edit_pobox = _T("");
	m_edit_pocode = _T("");
	m_edit_region = _T("");
	m_edit_straddr = _T("");
	//}}AFX_DATA_INIT

	m_node = NULL;
}

CPropLocX::~CPropLocX()
{
}

void CPropLocX::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropLocX)
	DDX_Text(pDX, IDC_EDIT_CITY, m_edit_city);
	DDX_Text(pDX, IDC_EDIT_COUNTRY_NAME, m_edit_cntry);
	DDX_Text(pDX, IDC_EDIT_EXTENDED_ADDRESS, m_edit_xaddr);
	DDX_Text(pDX, IDC_EDIT_POSTAL_BOX, m_edit_pobox);
	DDX_Text(pDX, IDC_EDIT_POSTAL_CODE, m_edit_pocode);
	DDX_Text(pDX, IDC_EDIT_REGION, m_edit_region);
	DDX_Text(pDX, IDC_EDIT_STREET_ADDRESS, m_edit_straddr);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropLocX, CPropertyPage)
	//{{AFX_MSG_MAP(CPropLocX)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropLocX message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\propemal.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// propemal.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropEmail dialog

class CVCNode;

class CPropEmail : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropEmail)

// Construction
public:
	CPropEmail();
	~CPropEmail();

// Dialog Data
	//{{AFX_DATA(CPropEmail)
	enum { IDD = IDD_EMAIL_ADDRESS };
	CString	m_popup_std1;
	CString	m_popup_std2;
	CString	m_popup_std3;
	CString	m_edit_email1;
	CString	m_edit_email2;
	CString	m_edit_email3;
	BOOL	m_button_pref2;
	BOOL	m_button_pref1;
	BOOL	m_button_pref3;
	BOOL	m_button_office1;
	BOOL	m_button_office2;
	BOOL	m_button_office3;
	BOOL	m_button_home1;
	BOOL	m_button_home2;
	BOOL	m_button_home3;
	//}}AFX_DATA

	CVCNode *m_node1, *m_node2, *m_node3;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropEmail)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	void Mail(const CString &recip);

	// Generated message map functions
	//{{AFX_MSG(CPropEmail)
	afx_msg void OnButtonMail();
	afx_msg void OnButtonMail2();
	afx_msg void OnButtonMail3();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocb.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocb.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropLocBasic dialog

class CVCNode;

class CPropLocBasic : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropLocBasic)

// Construction
public:
	CPropLocBasic();
	~CPropLocBasic();

// Dialog Data
	//{{AFX_DATA(CPropLocBasic)
	enum { IDD = IDD_PROP_LOCATION_BASIC };
	BOOL	m_button_home;
	CString	m_edit_location;
	BOOL	m_button_office;
	BOOL	m_button_parcel;
	BOOL	m_button_postal;
	CString	m_edit_postdom;
	CString	m_edit_postintl;
	CString	m_edit_timezone;
	//}}AFX_DATA

	CVCNode *m_nodeloc, *m_nodetz, *m_nodepostdom, *m_nodepostintl;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropLocBasic)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropLocBasic)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proplocx.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proplocx.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropLocX dialog

class CVCNode;

class CPropLocX : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropLocX)

// Construction
public:
	CPropLocX();
	~CPropLocX();

// Dialog Data
	//{{AFX_DATA(CPropLocX)
	enum { IDD = IDD_LOCATION_EXTENDED };
	CString	m_edit_city;
	CString	m_edit_cntry;
	CString	m_edit_xaddr;
	CString	m_edit_pobox;
	CString	m_edit_pocode;
	CString	m_edit_region;
	CString	m_edit_straddr;
	//}}AFX_DATA

	CVCNode *m_node;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropLocX)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropLocX)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_comp.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_comp.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "prp_comp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropCompany property page

IMPLEMENT_DYNCREATE(CPropCompany, CPropertyPage)

CPropCompany::CPropCompany() : CPropertyPage(CPropCompany::IDD)
{
	//{{AFX_DATA_INIT(CPropCompany)
	m_edit_orgname = _T("");
	m_edit_orgunit = _T("");
	m_edit_title = _T("");
	//}}AFX_DATA_INIT
	m_nodeOrg = NULL;
	m_nodeTitle = NULL;
}

CPropCompany::~CPropCompany()
{
}

void CPropCompany::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropCompany)
	DDX_Text(pDX, IDC_EDIT_ORGNAME, m_edit_orgname);
	DDX_Text(pDX, IDC_EDIT_ORGUNIT, m_edit_orgunit);
	DDX_Text(pDX, IDC_EDIT_TITLE, m_edit_title);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropCompany, CPropertyPage)
	//{{AFX_MSG_MAP(CPropCompany)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropCompany message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proptel.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proptel.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "proptel.h"
#include "tapi.h"
#include "vcard.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropTel property page

IMPLEMENT_DYNCREATE(CPropTel, CPropertyPage)

CPropTel::CPropTel() : CPropertyPage(CPropTel::IDD)
{
	//{{AFX_DATA_INIT(CPropTel)
	m_button_fax1 = FALSE;
	m_button_fax2 = FALSE;
	m_button_fax3 = FALSE;
	m_edit_fullName1 = _T("");
	m_edit_fullName2 = _T("");
	m_edit_fullName3 = _T("");
	m_button_home1 = FALSE;
	m_button_home2 = FALSE;
	m_button_home3 = FALSE;
	m_button_message1 = FALSE;
	m_button_message2 = FALSE;
	m_button_message3 = FALSE;
	m_button_office1 = FALSE;
	m_button_office2 = FALSE;
	m_button_office3 = FALSE;
	m_button_pref1 = FALSE;
	m_button_pref2 = FALSE;
	m_button_pref3 = FALSE;
	m_button_cell1 = FALSE;
	m_button_cell2 = FALSE;
	m_button_cell3 = FALSE;
	//}}AFX_DATA_INIT

	m_node1 = m_node2 = m_node3 = NULL;
}

CPropTel::~CPropTel()
{
}

void CPropTel::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropTel)
	DDX_Check(pDX, IDC_EDIT_FAX, m_button_fax1);
	DDX_Check(pDX, IDC_EDIT_FAX2, m_button_fax2);
	DDX_Check(pDX, IDC_EDIT_FAX3, m_button_fax3);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME, m_edit_fullName1);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME2, m_edit_fullName2);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME3, m_edit_fullName3);
	DDX_Check(pDX, IDC_EDIT_HOME, m_button_home1);
	DDX_Check(pDX, IDC_EDIT_HOME2, m_button_home2);
	DDX_Check(pDX, IDC_EDIT_HOME3, m_button_home3);
	DDX_Check(pDX, IDC_EDIT_MESSAGE, m_button_message1);
	DDX_Check(pDX, IDC_EDIT_MESSAGE2, m_button_message2);
	DDX_Check(pDX, IDC_EDIT_MESSAGE3, m_button_message3);
	DDX_Check(pDX, IDC_EDIT_OFFICE, m_button_office1);
	DDX_Check(pDX, IDC_EDIT_OFFICE2, m_button_office2);
	DDX_Check(pDX, IDC_EDIT_OFFICE3, m_button_office3);
	DDX_Check(pDX, IDC_EDIT_PREFERRED, m_button_pref1);
	DDX_Check(pDX, IDC_EDIT_PREFERRED2, m_button_pref2);
	DDX_Check(pDX, IDC_EDIT_PREFERRED3, m_button_pref3);
	DDX_Check(pDX, IDC_EDIT_CELLULAR, m_button_cell1);
	DDX_Check(pDX, IDC_EDIT_CELLULAR2, m_button_cell2);
	DDX_Check(pDX, IDC_EDIT_CELLULAR3, m_button_cell3);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropTel, CPropertyPage)
	//{{AFX_MSG_MAP(CPropTel)
	ON_BN_CLICKED(IDC_BUTTON_DIAL, OnButtonDial1)
	ON_BN_CLICKED(IDC_BUTTON_DIAL2, OnButtonDial2)
	ON_BN_CLICKED(IDC_BUTTON_DIAL3, OnButtonDial3)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropTel message handlers

void CPropTel::OnButtonDial1() 
{
	if (m_edit_fullName1.IsEmpty())
		return;

	CString fullName("");
	CVCProp *prop;

	if ((prop = m_body->GetProp(VCFullNameProp))) {
		char buf[1024];
		fullName = UI_CString(
			(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
	}

	tapiRequestMakeCall(
		m_edit_fullName1, NULL,
		fullName.IsEmpty() ? NULL : fullName, NULL);
}

void CPropTel::OnButtonDial2() 
{
	if (m_edit_fullName2.IsEmpty())
		return;

	CString fullName("");
	CVCProp *prop;

	if ((prop = m_body->GetProp(VCFullNameProp))) {
		char buf[1024];
		fullName = UI_CString(
			(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
	}

	tapiRequestMakeCall(
		m_edit_fullName2, NULL,
		fullName.IsEmpty() ? NULL : fullName, NULL);
}

void CPropTel::OnButtonDial3() 
{
	if (m_edit_fullName3.IsEmpty())
		return;

	CString fullName("");
	CVCProp *prop;

	if ((prop = m_body->GetProp(VCFullNameProp))) {
		char buf[1024];
		fullName = UI_CString(
			(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
	}

	tapiRequestMakeCall(
		m_edit_fullName3, NULL,
		fullName.IsEmpty() ? NULL : fullName, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_comp.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_comp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropCompany dialog

class CVCNode;

class CPropCompany : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropCompany)

// Construction
public:
	CPropCompany();
	~CPropCompany();

// Dialog Data
	//{{AFX_DATA(CPropCompany)
	enum { IDD = IDD_PROP_COMPANY };
	CString	m_edit_orgname;
	CString	m_edit_orgunit;
	CString	m_edit_title;
	//}}AFX_DATA

	CVCNode *m_nodeOrg;
	CVCNode *m_nodeTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropCompany)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropCompany)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_pers.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_pers.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "prp_pers.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPers property page

IMPLEMENT_DYNCREATE(CPropPers, CPropertyPage)

CPropPers::CPropPers() : CPropertyPage(CPropPers::IDD)
{
	//{{AFX_DATA_INIT(CPropPers)
	m_edit_famname = _T("");
	m_edit_fullname = _T("");
	m_edit_givenname = _T("");
	m_edit_pronun = _T("");
	//}}AFX_DATA_INIT

	m_nodeName = NULL;
	m_nodeFullName = NULL;
	m_nodePronun = NULL;
}

CPropPers::~CPropPers()
{
}

void CPropPers::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPers)
	DDX_Text(pDX, IDC_EDIT_FAMILY_NAME, m_edit_famname);
	DDX_Text(pDX, IDC_EDIT_FULL_NAME, m_edit_fullname);
	DDX_Text(pDX, IDC_EDIT_GIVEN_NAME, m_edit_givenname);
	DDX_Text(pDX, IDC_EDIT_PRONUNCIATION, m_edit_pronun);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPers, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPers)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropPers message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\proptel.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// proptel.h : header file
//

class CVCNode;

/////////////////////////////////////////////////////////////////////////////
// CPropTel dialog

class CPropTel : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropTel)

// Construction
public:
	CPropTel();
	~CPropTel();

	CVCNode *m_body;

// Dialog Data
	//{{AFX_DATA(CPropTel)
	enum { IDD = IDD_TELEPHONES };
	BOOL	m_button_fax1;
	BOOL	m_button_fax2;
	BOOL	m_button_fax3;
	CString	m_edit_fullName1;
	CString	m_edit_fullName2;
	CString	m_edit_fullName3;
	BOOL	m_button_home1;
	BOOL	m_button_home2;
	BOOL	m_button_home3;
	BOOL	m_button_message1;
	BOOL	m_button_message2;
	BOOL	m_button_message3;
	BOOL	m_button_office1;
	BOOL	m_button_office2;
	BOOL	m_button_office3;
	BOOL	m_button_pref1;
	BOOL	m_button_pref2;
	BOOL	m_button_pref3;
	BOOL	m_button_cell1;
	BOOL	m_button_cell2;
	BOOL	m_button_cell3;
	//}}AFX_DATA

	CVCNode *m_node1, *m_node2, *m_node3;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropTel)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropTel)
	afx_msg void OnButtonDial1();
	afx_msg void OnButtonDial2();
	afx_msg void OnButtonDial3();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\stdafx.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	VC.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\prp_pers.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// prp_pers.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropPers dialog

class CVCNode;

class CPropPers : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPers)

// Construction
public:
	CPropPers();
	~CPropPers();

// Dialog Data
	//{{AFX_DATA(CPropPers)
	enum { IDD = IDD_PROP_NAME };
	CString	m_edit_famname;
	CString	m_edit_fullname;
	CString	m_edit_givenname;
	CString	m_edit_pronun;
	//}}AFX_DATA

	CVCNode *m_nodeName;
	CVCNode *m_nodeFullName;
	CVCNode *m_nodePronun;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPers)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPers)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\stdafx.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VC.rc
//
#define IDR_VCTYPE_SRVR_IP              4
#define IDR_VCTYPE_SRVR_EMB             5
#define IDR_VCTYPE_CNTR_IP              6
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDP_SOCKETS_INIT_FAILED         104
#define IDR_MAINFRAME                   128
#define IDR_VCTYPE                      129
#define IDD_PROP_PERS                   130
#define IDD_PROP_NAME                   130
#define IDD_PROP_CO                     131
#define IDD_PROP_COMPANY                131
#define IDD_PROP_LOCATION_BASIC         132
#define IDD_LOCATION_EXTENDED           133
#define IDD_TELEPHONES                  134
#define IDD_EMAIL_ADDRESS               135
#define IDD_DIALOG_COMM                 137
#define IDB_PRONUN_U                    139
#define IDB_PRONUN_D                    140
#define IDD_DIALOG_CALLCENTER           142
#define IDC_EDIT_FULLNAME               1000
#define IDC_EDIT_FULL_NAME              1000
#define IDC_EDIT_FIRSTNAME              1000
#define IDC_EDIT_FAMNAME                1001
#define IDC_EDIT_FAMILY_NAME            1001
#define IDC_EDIT_FULL_NAME2             1001
#define IDC_EDIT_LASTNAME               1001
#define IDC_EDIT_GIVENNAME              1002
#define IDC_EDIT_GIVEN_NAME             1002
#define IDC_EDIT_FULL_NAME3             1002
#define IDC_EDIT_ADDRSTREET             1002
#define IDC_EDIT_TITLE                  1003
#define IDC_EDIT_PRONUNCIATION          1003
#define IDC_EDIT_ADDRCITY               1003
#define IDC_EDIT_ORGUNIT                1004
#define IDC_EDIT_ADDRSTATE              1004
#define IDC_EDIT_ORGNAME                1005
#define IDC_EDIT_ADDRZIP                1005
#define IDC_EDIT_POSTDOM                1006
#define IDC_EDIT_TELHOME                1006
#define IDC_EDIT_POSTINTL               1007
#define IDC_EDIT_TELWORK                1007
#define IDC_EDIT_TELFAX                 1008
#define IDC_EDIT_EXTENDED_ADDRESS       1009
#define IDC_EDIT_EMPLOYER               1009
#define IDC_EDIT_TIME_ZONE              1010
#define IDC_EDIT_CALLERID               1010
#define IDC_EDIT_STREET_ADDRESS         1011
#define IDC_BUTTON_ANSWER               1011
#define IDC_EDIT_CITY                   1012
#define IDC_BUTTON_CLEAR                1012
#define IDC_EDIT_POSTAL_CODE            1013
#define IDC_BUTTON3                     1013
#define IDC_EDIT_REGION                 1014
#define IDC_EDIT_COUNTRY_NAME           1015
#define IDC_EDIT_POSTAL_BOX             1016
#define IDC_EDIT_LOCATION               1017
#define IDC_EDIT_OFFICE                 1018
#define IDC_EDIT_HOME                   1019
#define IDC_EDIT_PARCEL                 1020
#define IDC_EDIT_Voice                  1020
#define IDC_EDIT_OFFICE4                1020
#define IDC_EDIT_CELLULAR               1020
#define IDC_EDIT_POSTAL                 1021
#define IDC_EDIT_MESSAGE                1021
#define IDC_EDIT_EMAIL_STANDARD         1021
#define IDC_EDIT_FAX                    1022
#define IDC_EDIT_EMAIL_STRING           1022
#define IDC_EDIT_PREFERRED              1023
#define IDC_EDIT_OFFICE2                1024
#define IDC_EDIT_EMAIL_STRING2          1024
#define IDC_EDIT_HOME2                  1025
#define IDC_EDIT_Voice2                 1026
#define IDC_EDIT_PREFERRED4             1026
#define IDC_EDIT_CELLULAR2              1026
#define IDC_EDIT_MESSAGE2               1027
#define IDC_EDIT_EMAIL_STANDARD2        1027
#define IDC_EDIT_FAX2                   1028
#define IDC_EDIT_EMAIL_STRING3          1028
#define IDC_EDIT_PREFERRED2             1029
#define IDC_EDIT_OFFICE5                1029
#define IDC_EDIT_OFFICE3                1030
#define IDC_EDIT_HOME4                  1030
#define IDC_EDIT_HOME3                  1031
#define IDC_EDIT_PREFERRED5             1031
#define IDC_EDIT_Voice3                 1032
#define IDC_EDIT_EMAIL_STANDARD3        1032
#define IDC_EDIT_CELLULAR3              1032
#define IDC_EDIT_MESSAGE3               1033
#define IDC_EDIT_FAX3                   1034
#define IDC_EDIT_PREFERRED3             1035
#define IDC_BUTTON_DIAL                 1036
#define IDC_BUTTON_DIAL2                1037
#define IDC_BUTTON_DIAL3                1038
#define IDC_LIST_PORT                   1039
#define IDC_LIST_BAUD                   1040
#define IDC_BUTTON_MAIL                 1043
#define IDC_BUTTON_MAIL2                1044
#define IDC_BUTTON_MAIL3                1045
#define ID_CANCEL_EDIT_CNTR             32768
#define ID_CANCEL_EDIT_SRVR             32769
#define ID_FILE_SAVEAS                  32772
#define ID_EDIT_COPY_SPECIAL            32774
#define ID_EDIT_PROPERTIES              32775
#define ID_INSERT_NAME                  32776
#define ID_INSERT_COMPANY               32777
#define ID_INSERT_ADDRESS               32778
#define ID_INSERT_TEL                   32779
#define ID_INSERT_EMAIL                 32780
#define ID_INSERT_URL                   32781
#define ID_VIEW_OPTIONS                 32782
#define ID_INSERT_PAGE                  32783
#define ID_VIEW_TEXT                    32784
#define ID_VIEW_DEBUG                   32785
#define ID_VIEW_SIMPLEGRAM              32786
#define ID_VIEW_NORMAL                  32787
#define ID_DEBUG_TESTVCCLASSES          32788
#define ID_IRDA_SEND                    32789
#define ID_IRDA_RECEIVE                 32790
#define ID_IRDA_OPTIONS                 32791
#define ID_IRDA_CONNECT                 32792
#define ID_IRDA_DISCONNECT              32793
#define ID_DEBUG_TRACE_PARSER           32794
#define ID_DEBUG_TRACE_COMM             32795
#define ID_EDIT_PASTE_MSV               32796
#define ID_IRDA_SEND_IRLMP              32797
#define ID_INSERT_LOGO                  32798
#define ID_INSERT_PHOTO                 32799
#define ID_INSERT_PRONUN                32800
#define ID_SEND_IRDA                    32801
#define ID_SEND_MAIL                    32811
#define ID_DEBUG_SHOWCALLCENTER         32812

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         32813
#define _APS_NEXT_CONTROL_VALUE         1044
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\ref.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __REF_H__
#define __REF_H__

/* The following pragma is compiler specific. The objective is to obtain
*  "packed" structures as defined in the section of the specification
*  dealing with "Bit-Level Data Representation". You may have to change
*  this pragma, set compiler options, or edit the declarations in this file
*  to achieve the same effect.
*/
#pragma pack(1)

#define	VCISO9070Prefix			"+//ISBN 1-887687-00-9::versit::PDI//"
#define	VCClipboardFormatVCard	"+//ISBN 1-887687-00-9::versit::PDI//vCard"

#define	VCISO639Type			"+//ISBN 1-887687-00-9::versit::PDI//ISO639Type"
#define	VCStrIdxType			"+//ISBN 1-887687-00-9::versit::PDI//StrIdxType"
#define	VCFlagsType				"+//ISBN 1-887687-00-9::versit::PDI//FlagsType"
#define	VCNextObjectType		"+//ISBN 1-887687-00-9::versit::PDI//NextType"
#define	VCOctetsType 			"+//ISBN 1-887687-00-9::versit::PDI//OctetsType"
#define	VCGIFType				"+//ISBN 1-887687-00-9::versit::PDI//GIFType"
#define VCWAVType				"+//ISBN 1-887687-00-9::versit::PDI//WAVType"
#define	VCNullType 				"+//ISBN 1-887687-00-9::versit::PDI//NULL"

#define	VCRootObject			"+//ISBN 1-887687-00-9::versit::PDI//RootObj"
#define	VCBodyObject			"+//ISBN 1-887687-00-9::versit::PDI//BodyObj"
#define	VCPartObject			"+//ISBN 1-887687-00-9::versit::PDI//PartObj"
#define	VCBodyProp				"+//ISBN 1-887687-00-9::versit::PDI//Body"
#define	VCPartProp				"+//ISBN 1-887687-00-9::versit::PDI//Part"
#define	VCNextObjectProp		"+//ISBN 1-887687-00-9::versit::PDI//Object"

#define	VCLogoProp				"+//ISBN 1-887687-00-9::versit::PDI//LOGO"
#define	VCPhotoProp				"+//ISBN 1-887687-00-9::versit::PDI//PHOTO"
#define	VCDeliveryLabelProp     "+//ISBN 1-887687-00-9::versit::PDI//LABEL"
#define	VCPostalBoxProp			"+//ISBN 1-887687-00-9::versit::PDI//BOX"
#define	VCStreetAddressProp		"+//ISBN 1-887687-00-9::versit::PDI//STREET"
#define	VCExtAddressProp		"+//ISBN 1-887687-00-9::versit::PDI//EXT ADD"
#define	VCCountryNameProp		"+//ISBN 1-887687-00-9::versit::PDI//C"
#define	VCPostalCodeProp		"+//ISBN 1-887687-00-9::versit::PDI//PC"
#define	VCRegionProp			"+//ISBN 1-887687-00-9::versit::PDI//R"
#define	VCCityProp				"+//ISBN 1-887687-00-9::versit::PDI//L"
#define	VCFullNameProp			"+//ISBN 1-887687-00-9::versit::PDI//FN"
#define	VCTitleProp				"+//ISBN 1-887687-00-9::versit::PDI//TITLE"
#define	VCOrgNameProp			"+//ISBN 1-887687-00-9::versit::PDI//ORG"
#define	VCOrgUnitProp			"+//ISBN 1-887687-00-9::versit::PDI//OUN"
#define	VCOrgUnit2Prop			"+//ISBN 1-887687-00-9::versit::PDI//OUN2"
#define	VCOrgUnit3Prop			"+//ISBN 1-887687-00-9::versit::PDI//OUN3"
#define	VCOrgUnit4Prop			"+//ISBN 1-887687-00-9::versit::PDI//OUN4"
#define	VCFamilyNameProp		"+//ISBN 1-887687-00-9::versit::PDI//F"
#define	VCGivenNameProp			"+//ISBN 1-887687-00-9::versit::PDI//G"
#define	VCAdditionalNamesProp	"+//ISBN 1-887687-00-9::versit::PDI//ADDN"
#define	VCNamePrefixesProp		"+//ISBN 1-887687-00-9::versit::PDI//NPRE"
#define	VCNameSuffixesProp		"+//ISBN 1-887687-00-9::versit::PDI//NSUF"
#define	VCPronunciationProp		"+//ISBN 1-887687-00-9::versit::PDI//SOUND"
#define	VCLanguageProp			"+//ISBN 1-887687-00-9::versit::PDI//LANG"
#define	VCTelephoneProp			"+//ISBN 1-887687-00-9::versit::PDI//TEL"
#define	VCEmailAddressProp		"+//ISBN 1-887687-00-9::versit::PDI//EMAIL"
#define	VCTimeZoneProp			"+//ISBN 1-887687-00-9::versit::PDI//TZ"
#define	VCLocationProp			"+//ISBN 1-887687-00-9::versit::PDI//GEO"
#define	VCCommentProp			"+//ISBN 1-887687-00-9::versit::PDI//NOTE"
#define	VCCharSetProp			"+//ISBN 1-887687-00-9::versit::PDI//CS"
#define	VCLastRevisedProp		"+//ISBN 1-887687-00-9::versit::PDI//REV"
#define	VCUniqueStringProp		"+//ISBN 1-887687-00-9::versit::PDI//UID"
#define	VCPublicKeyProp			"+//ISBN 1-887687-00-9::versit::PDI//KEY"
#define	VCMailerProp			"+//ISBN 1-887687-00-9::versit::PDI//MAILER"
#define	VCAgentProp				"+//ISBN 1-887687-00-9::versit::PDI//AGENT"
#define	VCBirthDateProp			"+//ISBN 1-887687-00-9::versit::PDI//BDAY"
#define	VCBusinessRoleProp		"+//ISBN 1-887687-00-9::versit::PDI//ROLE"
#define	VCCaptionProp			"+//ISBN 1-887687-00-9::versit::PDI//CAP"
#define	VCURLProp				"+//ISBN 1-887687-00-9::versit::PDI//URL"

#define	VCDomesticProp			"+//ISBN 1-887687-00-9::versit::PDI//DOM"
#define	VCInternationalProp		"+//ISBN 1-887687-00-9::versit::PDI//INTL"
#define	VCPostalProp			"+//ISBN 1-887687-00-9::versit::PDI//POSTAL"
#define	VCParcelProp			"+//ISBN 1-887687-00-9::versit::PDI//PARCEL"
#define	VCHomeProp				"+//ISBN 1-887687-00-9::versit::PDI//HOME"
#define	VCWorkProp				"+//ISBN 1-887687-00-9::versit::PDI//WORK"
#define	VCPreferredProp			"+//ISBN 1-887687-00-9::versit::PDI//PREF"
#define	VCVoiceProp				"+//ISBN 1-887687-00-9::versit::PDI//VOICE"
#define	VCFaxProp				"+//ISBN 1-887687-00-9::versit::PDI//FAX"
#define	VCMessageProp			"+//ISBN 1-887687-00-9::versit::PDI//MSG"
#define	VCCellularProp			"+//ISBN 1-887687-00-9::versit::PDI//CELL"
#define	VCPagerProp				"+//ISBN 1-887687-00-9::versit::PDI//PAGER"
#define	VCBBSProp				"+//ISBN 1-887687-00-9::versit::PDI//BBS"
#define	VCModemProp				"+//ISBN 1-887687-00-9::versit::PDI//MODEM"
#define	VCCarProp				"+//ISBN 1-887687-00-9::versit::PDI//CAR"
#define	VCISDNProp				"+//ISBN 1-887687-00-9::versit::PDI//ISDN"
#define	VCVideoProp				"+//ISBN 1-887687-00-9::versit::PDI//VIDEO"

#define	VCInlineProp			"+//ISBN 1-887687-00-9::versit::PDI//INLINE"
#define	VCURLValueProp			"+//ISBN 1-887687-00-9::versit::PDI//URLVAL"
#define	VCContentIDProp			"+//ISBN 1-887687-00-9::versit::PDI//CONTENT-ID"

#define	VC7bitProp				"+//ISBN 1-887687-00-9::versit::PDI//7BIT"
#define	VCQuotedPrintableProp	"+//ISBN 1-887687-00-9::versit::PDI//QP"
#define	VCBase64Prop			"+//ISBN 1-887687-00-9::versit::PDI//BASE64"

#define	VCAOLProp				"+//ISBN 1-887687-00-9::versit::PDI//AOL"
#define	VCAppleLinkProp			"+//ISBN 1-887687-00-9::versit::PDI//AppleLink"
#define	VCATTMailProp			"+//ISBN 1-887687-00-9::versit::PDI//ATTMail"
#define	VCCISProp				"+//ISBN 1-887687-00-9::versit::PDI//CIS"
#define	VCEWorldProp			"+//ISBN 1-887687-00-9::versit::PDI//eWorld"
#define	VCInternetProp			"+//ISBN 1-887687-00-9::versit::PDI//INTERNET"
#define	VCIBMMailProp			"+//ISBN 1-887687-00-9::versit::PDI//IBMMail"
#define	VCMSNProp				"+//ISBN 1-887687-00-9::versit::PDI//MSN"
#define	VCMCIMailProp			"+//ISBN 1-887687-00-9::versit::PDI//MCIMail"
#define	VCPowerShareProp		"+//ISBN 1-887687-00-9::versit::PDI//POWERSHARE"
#define	VCProdigyProp			"+//ISBN 1-887687-00-9::versit::PDI//Prodigy"
#define	VCTLXProp				"+//ISBN 1-887687-00-9::versit::PDI//TLX"
#define	VCX400Prop				"+//ISBN 1-887687-00-9::versit::PDI//X400"

#define	VCGIFProp				"+//ISBN 1-887687-00-9::versit::PDI//GIF"
#define	VCCGMProp				"+//ISBN 1-887687-00-9::versit::PDI//CGM"
#define	VCWMFProp				"+//ISBN 1-887687-00-9::versit::PDI//WMF"
#define	VCBMPProp				"+//ISBN 1-887687-00-9::versit::PDI//BMP"
#define	VCMETProp				"+//ISBN 1-887687-00-9::versit::PDI//MET"
#define	VCPMBProp				"+//ISBN 1-887687-00-9::versit::PDI//PMB"
#define	VCDIBProp				"+//ISBN 1-887687-00-9::versit::PDI//DIB"
#define	VCPICTProp				"+//ISBN 1-887687-00-9::versit::PDI//PICT"
#define	VCTIFFProp				"+//ISBN 1-887687-00-9::versit::PDI//TIFF"
#define	VCAcrobatProp			"+//ISBN 1-887687-00-9::versit::PDI//ACROBAT"
#define	VCPSProp				"+//ISBN 1-887687-00-9::versit::PDI//PS"
#define	VCJPEGProp				"+//ISBN 1-887687-00-9::versit::PDI//JPEG"
#define	VCQuickTimeProp			"+//ISBN 1-887687-00-9::versit::PDI//QTIME"
#define	VCMPEGProp				"+//ISBN 1-887687-00-9::versit::PDI//MPEG"
#define	VCMPEG2Prop				"+//ISBN 1-887687-00-9::versit::PDI//MPEG2"
#define	VCAVIProp				"+//ISBN 1-887687-00-9::versit::PDI//AVI"

#define	VCWAVEProp				"+//ISBN 1-887687-00-9::versit::PDI//WAVE"
#define	VCAIFFProp				"+//ISBN 1-887687-00-9::versit::PDI//AIFF"
#define	VCPCMProp				"+//ISBN 1-887687-00-9::versit::PDI//PCM"

#define	VCX509Prop				"+//ISBN 1-887687-00-9::versit::PDI//X509"
#define	VCPGPProp				"+//ISBN 1-887687-00-9::versit::PDI//PGP"

#define	VCNodeNameProp			"+//ISBN 1-887687-00-9::versit::PDI//NodeName"


/* Currently Unused, and To Be Removed

#define	VCListObject			"+//ISBN 1-887687-00-9::versit::PDI//LIST"
#define VCStringDataObject		"+//ISBN 1-887687-00-9::versit::PDI//StringDataObj"
#define VCStringDataLSBProp		"+//ISBN 1-887687-00-9::versit::PDI//StringDataLSB"
#define VCStringDataMSBProp		"+//ISBN 1-887687-00-9::versit::PDI//StringDataMSB"
#define	VCMsgProp				"+//ISBN 1-887687-00-9::versit::PDI//MSG"
#define	VCEncryptionProp		"+//ISBN 1-887687-00-9::versit::PDI//KEY"
#define	VCNextObjectProp		"+//ISBN 1-887687-00-9::versit::PDI//NextObject"
#define	VCMyReferenceProp		"+//ISBN 1-887687-00-9::versit::PDI//M"
#define	VCYourReferenceProp		"+//ISBN 1-887687-00-9::versit::PDI//Y"

#define VCCharSetType			"+//ISBN 1-887687-00-9::versit::PDI//CharSetType"
#define	VCReferenceType			"+//ISBN 1-887687-00-9::versit::PDI//ReferenceType"
#define VCLocationType			"+//ISBN 1-887687-00-9::versit::PDI//LocationType"
*/

typedef enum {
	VC_EMAIL_NONE = 0,
	VC_AOL, VC_AppleLink, VC_ATTMail, VC_CIS, VC_eWorld, VC_INTERNET, VC_IBMMail, VC_MSN, VC_MCIMail,
	VC_POWERSHARE, VC_PRODIGY, VC_TLX, VC_X400
} VC_EMAIL_TYPE;

typedef enum {
	VC_VIDEO_NONE = 0,
	VC_GIF, VC_CGM, VC_WMF, VC_BMP, VC_MET, VC_PMB, VC_DIB, VC_PICT, VC_TIFF, VC_ACROBAT, VC_PS
} VC_VIDEO_TYPE;

typedef enum {
	VC_AUDIO_NONE = 0,
	VC_WAV
} VC_AUDIO_TYPE;

typedef struct {
	unsigned long general;
	VC_EMAIL_TYPE email;
	VC_AUDIO_TYPE audio;
	VC_VIDEO_TYPE video;
} VC_FLAGS, * VC_PTR_FLAGS;

// General flags
#define VC_DOM           ((unsigned long)0x00000001) 
#define VC_INTL			 ((unsigned long)0x00000002) 
#define VC_POSTAL        ((unsigned long)0x00000004) 
#define VC_PARCEL        ((unsigned long)0x00000008) 
#define VC_HOME          ((unsigned long)0x00000010) 
#define VC_WORK			 ((unsigned long)0x00000020) 
#define VC_PREF          ((unsigned long)0x00000040) 
#define VC_VOICE         ((unsigned long)0x00000080) 
#define VC_FAX           ((unsigned long)0x00000100) 
#define VC_MSG           ((unsigned long)0x00000200) 
#define VC_CELL          ((unsigned long)0x00000400) 
#define VC_PAGER         ((unsigned long)0x00000800) 
#define VC_BBS           ((unsigned long)0x00001000) 
#define VC_MODEM         ((unsigned long)0x00002000) 
#define VC_CAR           ((unsigned long)0x00004000) 
#define VC_ISDN          ((unsigned long)0x00008000) 
#define VC_VIDEO         ((unsigned long)0x00010000) 
#define VC_BASE64        ((unsigned long)0x00020000) 
#define VC_HEX           ((unsigned long)0x00040000) 
#define VC_UUENCODE      ((unsigned long)0x00080000) 


// stuff added for the demo code

#define	VCDisplayInfoTextType "+//ISBN 1-887687-00-9::versit::PDI//EXTENSION//DisplayInfoText"
#define	VCDisplayInfoGIFType "+//ISBN 1-887687-00-9::versit::PDI//EXTENSION//DisplayInfoGIF"
#define	VCDisplayInfoProp  		"+//ISBN 1-887687-00-9::versit::PDI//EXTENSION//DisplayInfoProp"

#define VC_LEFT 		1
#define VC_CENTER  	(~0)
#define VC_RIGHT 		3

#define VC_CLASSIC 	1
#define VC_MODERN 	2
#define VC_BOLD		 	1
#define VC_ITALIC 	2

typedef struct 									// VCDisplayInfoTextType
{
  signed short  	x,y;					// absolute position or VC_CENTER
	unsigned char		typeSize,			// range of 6..144, units are points
									textAlign,		// VC_LEFT, VC_CENTER or VC_RIGHT
									textClass,		// VC_CLASSIC or VC_MODERN
									textAttrs;		// VC_BOLD | VC_ITALIC

} VC_DISPTEXT, * VC_PTR_DISPTEXT;

typedef struct 										// VCDisplayInfoTIFFType
{
  signed short  	left, bottom, right, top;
  BOOL				hasMask;

} VC_DISPGIF, * VC_PTR_DISPGIF;

#pragma pack()

#endif // __REF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vc.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VC.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "VC.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "VCDoc.h"
#include "VCView.h"
#include "vcard.h"
#include "vcir.h"
#include "msv.h"
#include "mime.h"
#include "callcntr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL traceComm = FALSE;
IVCServer_IR *vcServer_IR = NULL;
UINT cf_eCard;
extern CCallCenter *callCenter;


/////////////////////////////////////////////////////////////////////////////
// CVCApp

BEGIN_MESSAGE_MAP(CVCApp, CWinApp)
	//{{AFX_MSG_MAP(CVCApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_DEBUG_TESTVCCLASSES, OnDebugTestVCClasses)
	ON_COMMAND(ID_DEBUG_TRACE_COMM, OnDebugTraceComm)
	ON_UPDATE_COMMAND_UI(ID_DEBUG_TRACE_COMM, OnUpdateDebugTraceComm)
	ON_COMMAND(ID_DEBUG_TRACE_PARSER, OnDebugTraceParser)
	ON_UPDATE_COMMAND_UI(ID_DEBUG_TRACE_PARSER, OnUpdateDebugTraceParser)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVCApp construction

CVCApp::CVCApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	m_incomingHeader = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CVCApp object

CVCApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {3007AD10-D013-11CE-A9E6-000000000000}
static const CLSID clsid =
{ 0x3007ad10, 0xd013, 0x11ce, { 0xa9, 0xe6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } };

/////////////////////////////////////////////////////////////////////////////
// CVCApp initialization

// create a palette for use on 8-bit display devices

CPalette bubPalette;

LOGPALETTE *bublp;

void InitBubPalette(void)
{
	int i, r, g, b, size;
	
	size = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 216);
	i = 0;
	
	bublp = (LOGPALETTE *) new char[size];
	
	for( r=0; r < 6; r++ )
		{
		for( g=0; g < 6; g++ )
			{
			for( b=0; b < 6; b++ )
				{
				bublp->palPalEntry[i].peRed = 51 * r;
				bublp->palPalEntry[i].peGreen = 51 * g;
				bublp->palPalEntry[i].peBlue = 51 * b;
				bublp->palPalEntry[i].peFlags = 4;
				i += 1;
				}
			}
		}
	bublp->palVersion = 0x300;  // GAK!
	bublp->palNumEntries = 216;
	
	bubPalette.CreatePalette(bublp);
}

static BOOL InitVCServer()
{
	// create the vcServer_IR object that we'll drive through OLE automation
	COleException e;
	CLSID clsid;
	if (CLSIDFromProgID(OLESTR("VCIR.VCSERVER"), &clsid) != NOERROR)
	{
		//AfxMessageBox(IDP_UNABLE_TO_CREATE);
		return FALSE;
	}

	vcServer_IR = new IVCServer_IR;

	// try to get the active vcServer_IR before creating a new one
	LPUNKNOWN lpUnk;
	LPDISPATCH lpDispatch;
	if (GetActiveObject(clsid, NULL, &lpUnk) == NOERROR)
	{
		HRESULT hr = lpUnk->QueryInterface(IID_IDispatch, 
			(LPVOID*)&lpDispatch);
		lpUnk->Release();
		if (hr == NOERROR)
			vcServer_IR->AttachDispatch(lpDispatch, TRUE);
	}

	// if not dispatch ptr attached yet, need to create one
	if (vcServer_IR->m_lpDispatch == NULL && 
		!vcServer_IR->CreateDispatch(clsid, &e))
	{
		//AfxMessageBox(IDP_UNABLE_TO_CREATE);
		delete vcServer_IR; vcServer_IR = NULL;
		return FALSE;
	}

	return TRUE;
}

// The default impl for FileOpen doesn't handle file paths that contain
// spaces, since the system doesn't enquote such paths (and so the 
// pieces show up in successive arguments).  This is a more flexible
// approach, but it still won't handle paths that originally had
// more than one space in a row.
BOOL CVCApp::ProcessShellCommand(CCommandLineInfo& rCmdInfo)
{
	if (rCmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen) {
		CString path;
		for (int i = 1; i < __argc; i++) {
			if (*(__argv[i]) == '-' || *(__argv[i]) == '/')
				continue;
			path = path + __argv[i] + " ";
		}
		path.TrimRight();
		return OpenDocumentFile(path) != NULL;
	}
	return CWinApp::ProcessShellCommand(rCmdInfo);
}

BOOL CVCApp::InitInstance()
{
	InitBubPalette();

	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	LoadStdProfileSettings(6);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_VCTYPE,
		RUNTIME_CLASS(CVCDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CVCView));
	AddDocTemplate(pDocTemplate);

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);

	// Register all OLE server factories as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleTemplateServer::RegisterAll();
		// Note: MDI applications register all server objects without regard
		//  to the /Embedding or /Automation on the command line.

	InitVCServer();
	cf_eCard = RegisterClipboardFormat(VCClipboardFormatVCard);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Check to see if launched as OLE server
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
	COleObjectFactory::UpdateRegistryAll();

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(
		m_nCmdShow == SW_SHOWNORMAL ? SW_SHOWMAXIMIZED : m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CVCApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CVCApp commands

/////////////////////////////////////////////////////////////////////////////
// This is used for debugging output only.  Its implementation is platform
// specific.  This impl works for MS MFC.
void debugf(const char *s)
{
	TRACE0(s);
}

CM_CFUNCTIONS

void Parse_Debug(const char *s)
{
	TRACE0(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
void msv_error(char *s)
{
	if (++msv_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, msv_lineNum);
		//AfxMessageBox(buf);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
void mime_error(char *s)
{
	if (++mime_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, mime_lineNum);
		AfxMessageBox(buf);
	}
}

CM_END_CFUNCTIONS

void CVCApp::OnDebugTestVCClasses() 
{
	if (OpenDocumentFile("Alden.htm")) { // powerful magic here
		// play the card's pronunciation, if any
		CView *view = ((CMainFrame *)GetMainWnd())->MDIGetActive()->GetActiveView();
		view->SendMessage(WM_COMMAND, VC_PLAY_BUTTON_ID);
	}
}

int CVCApp::ExitInstance() 
{
	if (bublp)
		delete bublp;

	if (m_incomingHeader) delete [] m_incomingHeader;
	if (vcServer_IR) delete vcServer_IR;

	return CWinApp::ExitInstance();
}

void CVCApp::OnDebugTraceComm() 
{
	traceComm = !traceComm;
}

void CVCApp::OnUpdateDebugTraceComm(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(traceComm);
}

void CVCApp::OnDebugTraceParser() 
{
	char *str = getenv("YYDEBUG");
	if (str && (*str == '1'))
		putenv("YYDEBUG=0");
	else
		putenv("YYDEBUG=1");
}

void CVCApp::OnUpdateDebugTraceParser(CCmdUI* pCmdUI) 
{
	char *str = getenv("YYDEBUG");
	pCmdUI->SetCheck(str && (*str == '1'));
}

BOOL CVCApp::CanSendFileViaIR() { return vcServer_IR != NULL; }

long CVCApp::SendFileViaIR(LPCTSTR nativePath, LPCTSTR asPath, BOOL isCardFile)
{
	if (!vcServer_IR)
		return 0;

	return vcServer_IR->SendFile(nativePath);
}

long CVCApp::ReceiveCard(LPCTSTR nativePath)
{
	if (OpenDocumentFile(nativePath)) { // powerful magic here
		CVCView *view = (CVCView*)((CMainFrame *)GetMainWnd())->MDIGetActive()->GetActiveView();
		view->GetDocument()->SetModifiedFlag();
		if (callCenter) {
			view->InitCallCenter(*callCenter);
			callCenter->UpdateData(FALSE);
		} else
			// play the card's pronunciation, if any
			view->SendMessage(WM_COMMAND, VC_PLAY_BUTTON_ID);
	}
	unlink(nativePath);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vc32.h ===
/////////////////////////////////////////////////////////////////////////////
// CVc32App
// See vc32.cpp for the implementation of this class
//

class CVc32App : public CWinApp
{
public:
	CVc32App();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVc32App)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CVc32App)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vc.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VC.h : main header file for the VC application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "vcenv.h"
#include "ref.h"
#include "clist.h"

/////////////////////////////////////////////////////////////////////////////
// CVCApp:
// See VC.cpp for the implementation of this class
//

class CVCApp : public CWinApp
{
public:
	CVCApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVCApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CVCApp)
	afx_msg void OnAppAbout();
	afx_msg void OnDebugTestVCClasses();
	afx_msg void OnDebugTraceComm();
	afx_msg void OnUpdateDebugTraceComm(CCmdUI* pCmdUI);
	afx_msg void OnDebugTraceParser();
	afx_msg void OnUpdateDebugTraceParser(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);
	void ResetIncomingInfo();
	void ProcessIncomingBytes(const char *bytes, int len);
	long ReceiveCard(LPCTSTR nativePath);

	BOOL CanSendFileViaIR();
	long SendFileViaIR(LPCTSTR nativePath, LPCTSTR asPath, BOOL isCardFile);

protected:
	P_U8 m_incomingHeader; // ex.: "VERSIT/size/checksum/V/lenpath/path..." (all are string representations)
	int m_incomingHeaderLen, m_incomingHeaderMaxLen;
	CString m_incomingPath;
	FILE *m_incomingFile;
	int m_incomingChecksum;
	int m_incomingSize;
	int m_incomingPathLen;
	int m_sizeWritten;
	U32 m_checksumInProgress;
	int m_incomingIsCardFile;
};


/////////////////////////////////////////////////////////////////////////////
extern BOOL traceComm;
extern UINT cf_eCard;

// Simple-minded conversion from UNICODE to char string
extern char *UI_CString(const wchar_t *u, char *dst);

extern VC_DISPTEXT *DisplayInfoForProp(const char *name, VC_DISPTEXT *info);

extern CString FirstEmailPropStr(CList *plist);
extern int VCMatchProp(void *item, void *context);

#define VC_PLAY_BUTTON_ID	2711 // arbitrary
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcard.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include "stdafx.h" // PORTING: comment out this line on non-Windows platforms
#ifdef _WIN32
#include <wchar.h>
#else
#include "wchar.h"
#ifdef __MWERKS__
#include <assert.h>	// gca
#define	ASSERT assert
#endif
#endif

#include <string.h>
#include <malloc.h>
#include <fstream.h>
#include "vcard.h"
#include "clist.h"
#include "msv.h"

#ifdef _WIN32
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
#endif

#if defined(_WIN32) || defined(__MWERKS__)
#define HNEW(_t, _n) new _t[_n]
#define HFREE(_h) delete [] _h
#else
#define HNEW(_t, _n) (_t __huge *)_halloc(_n, 1)
#define HFREE(_h) _hfree(_h)
#endif

extern void debugf(const char *s);

// This translates wide char strings into 8-bit, and also translates
// 0x2028 into \n
extern char *UI_CString(const wchar_t *u, char *dst);

static char *NewStr(const char *str);
static char * ShortName(char * ps);
static void NewlineTab(int nl, int tab);
static char *FakeCString(wchar_t *u, char *dst);
static void WriteLineBreakString(ostream& strm, wchar_t *str, BOOL qp);

static char buf[80];

typedef struct {
	BOOL didFamGiven, didOrg, didLocA;
	CVCard* card;
} MSVContext;

static char *paramsep = ";";


/**** class CVCard  ****/

/////////////////////////////////////////////////////////////////////////////
CVCard::CVCard()
{
	m_roots = new CList;
}

/////////////////////////////////////////////////////////////////////////////
CVCard::~CVCard()
{
    CLISTPOSITION pos;

    for (pos = m_roots->GetHeadPosition(); pos; ) {
    	CVCObject *node = (CVCObject *)m_roots->GetNext(pos);
    	delete node;
    }
    m_roots->RemoveAll();
    delete m_roots;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCard::Copy()
{
	CVCard *result = new CVCard;
	CLISTPOSITION pos;

	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCObject *node = (CVCObject *)m_roots->GetNext(pos);
		result->AddObject((CVCNode *)node->Copy());
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CList* CVCard::GetObjects()
{
	return m_roots;
}

/////////////////////////////////////////////////////////////////////////////
CVCard& CVCard::AddObject(CVCNode *object)
{
	m_roots->AddTail(object);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCard& CVCard::RemoveObject(CVCNode *object, BOOL destroy)
{
	CLISTPOSITION pos;

	if ((pos = m_roots->Find(object))) {
		m_roots->RemoveAt(pos);
		if (destroy)
			delete object;
	}
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCard::ParentForObject(CVCNode *object)
{
	CLISTPOSITION pos;
	CList *anc = new CList;
	CVCNode *result = NULL;

	// for each root object
	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *root = (CVCNode *)m_roots->GetNext(pos);
		if (root == object) {
			result = object;
			break;
		}
		// try finding the ancestry chain for each root
		if (root->AncestryForObject(object, anc)) {
			// BINGO!  The chain has 'object' at the head, so skip that.
			pos = anc->GetHeadPosition();
			anc->GetNext(pos);
			// and return object's parent
			result = (CVCNode *)anc->GetAt(pos);
			break;
		}
	}
	anc->RemoveAll();
	delete anc;
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// This method tries to get an ancestry chain from each root to the
// passed object.  When it finds one, it walks the chain from head to tail
// (i.e. from child to root) looking for the named property.
CVCProp* CVCard::GetInheritedProp(CVCNode *object, const char *name, CVCNode **node)
{
	CLISTPOSITION pos;
	CList *anc = new CList;
	CVCProp *result = NULL;

	// for each root
	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *root = (CVCNode *)m_roots->GetNext(pos);
		if (root == object) {
			result = object->GetProp(name);
			if (node) *node = object;
			break;
		}
		if (root->AncestryForObject(object, anc)) {
			// Aha!  Found the chain, so walk it from head to tail.
			for (pos = anc->GetHeadPosition(); pos; ) {
				CVCNode *obj = (CVCNode *)anc->GetNext(pos);
				if ((result = obj->GetProp(name))) {
					if (node) *node = obj;
					break;
				}
			}
			break;
		}
	}
	anc->RemoveAll();
	delete anc;
	return result;
}

/////////////////////////////////////////////////////////////////////////////
void CVCard::GetPropsInEffect(CVCNode *object, CList *list)
{
	CLISTPOSITION pos;
	CList *anc = new CList;

	// for each root
	for (pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *root = (CVCNode *)m_roots->GetNext(pos);
		if (root == object) {
			CList *props = object->GetProps();
			for (pos = props->GetHeadPosition(); pos; )
				list->AddTail((CVCProp *)props->GetNext(pos));
			break;
		}
		if (root->AncestryForObject(object, anc)) {
			// Aha!  Found the chain, so walk it from head to tail.
			for (pos = anc->GetHeadPosition(); pos; ) {
				CVCNode *obj = (CVCNode *)anc->GetNext(pos);
				CList *props = obj->GetProps();
				for (CLISTPOSITION p = props->GetHeadPosition(); p; )
					list->AddTail((CVCProp *)props->GetNext(p));
			}
			break;
		}
	}
	anc->RemoveAll();
	delete anc;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCard::FindBody(const char* language)
{
	CVCNode *root = (CVCNode *)GetObjects()->GetHead();
	CList *rootProps = root->GetProps();
	CVCNode *firstBody = NULL, *body = NULL;

	for (CLISTPOSITION pos = rootProps->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)rootProps->GetNext(pos);
		if (strcmp(vcBodyProp, prop->GetName()) == 0) {
			CVCNode *thisBody = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			CVCProp *langProp;
			CVCValue *value;
			char buf[256];
			if (!firstBody) {
				firstBody = thisBody;
				if (!language)
					return firstBody;
			}
			if ((langProp = thisBody->GetProp(vcLanguageProp))
				&& (value = langProp->FindValue(VCStrIdxType))
				&& (strcmp(FakeCString((wchar_t*)value->GetValue(), buf), language) == 0)) {
				body = thisBody;
				break;
			}
		}
	}
	if (!firstBody)
		body = root;
	else if (!body)
		body = firstBody;

	return body;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCard::Write(FILE *outputFile)
{
	ofstream strm(_fileno(outputFile));
	return Write(strm);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCard::Write(ostream& strm)
{
	wchar_t null = 0;
	MSVContext ctx;

	memset(&ctx, 0, sizeof(ctx));
	ctx.card = this;

	strm << "BEGIN:VCARD\n";
	for (CLISTPOSITION pos = m_roots->GetHeadPosition(); pos; ) {
		CVCNode *node = (CVCNode *)m_roots->GetNext(pos);
		if (!node->Write(strm, &null, &ctx))
			return FALSE;
	}
	strm << "END:VCARD\n";
	return TRUE;
}


/**** class CVCNode  ****/

/////////////////////////////////////////////////////////////////////////////
CVCNode::CVCNode(CVCProp *prop)
{
	m_props = new CList;
	if (prop)
		m_props->AddTail(prop);
}

/////////////////////////////////////////////////////////////////////////////
CVCNode::~CVCNode()
{
    CLISTPOSITION pos;

    for (pos = m_props->GetHeadPosition(); pos; ) {
    	CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
    	delete prop;
    }
    m_props->RemoveAll();
    delete m_props;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCNode::Copy()
{
	CVCNode *result = new CVCNode;
	CLISTPOSITION pos;
	CList *props = result->GetProps();

	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		props->AddTail(prop->Copy());
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CList* CVCNode::GetProps()
{
	return m_props;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCNode::GetProp(const char *name)
{
	CLISTPOSITION pos;

	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		if (strcmp(name, prop->GetName()) == 0)
			return prop;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode& CVCNode::AddProp(CVCProp *prop)
{
	m_props->AddTail(prop);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCNode::AddObjectProp(const char *propName, const char *marker)
{
	CVCNode *newobj = new CVCNode;
																			
	if (marker)
		newobj->AddProp(new CVCProp(marker));     			 	
	AddProp(new CVCProp(propName, VCNextObjectType, newobj));			

	return newobj;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode* CVCNode::AddPart()
{
	return AddObjectProp(vcPartProp, VCPartObject);
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCNode::AddStringProp(
	const char *propName, const char *value, VC_DISPTEXT *dispText)
{
	CVCProp *prop;
	int size;
	wchar_t *uniValue = FakeUnicode(value, &size);

	FixCRLF(uniValue);
	AddProp(prop = new CVCProp(propName, VCStrIdxType, uniValue, size));
	delete [] uniValue;
	if (dispText)
		prop->AddValue(
			new CVCValue(VCDisplayInfoTextType, dispText, sizeof(*dispText)));

	return prop;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCNode::AddBoolProp(const char *propName)
{
	CVCProp *prop = new CVCProp(propName, vcFlagsType);
	AddProp(prop);			
	return prop;
}

/////////////////////////////////////////////////////////////////////////////
CVCNode& CVCNode::RemoveProp(const char *name, BOOL destroy)
{
	CLISTPOSITION pos, lastPos;

	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop;
		lastPos = pos;
		prop = (CVCProp *)m_props->GetNext(pos);
		if (strcmp(name, prop->GetName()) == 0) {
			m_props->RemoveAt(lastPos);
			if (destroy)
				delete prop;
			break;

		}
	}
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// This is a recursive method, and it adjusts ancestry as described in the
// header file comment.  The only tricky part is that it skips over objects
// held by vcNextObjectProp values, as these don't represent "child" objects.
BOOL CVCNode::AncestryForObject(CVCNode *object, CList *ancestry)
{
	CLISTPOSITION pos, headPos;

	headPos = ancestry->AddHead(this);
	// for every property of self
	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		if ((strcmp(prop->GetName(), vcBodyProp) == 0)
			|| (strcmp(prop->GetName(), vcPartProp) == 0)
			|| (strcmp(prop->GetName(), vcNextObjectProp) == 0)) {
			CVCNode *obj = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			if (obj) {
				if (obj == object) {
					// Eureka!  Self was added above, and so just add
					// the object itself and return success.
					ancestry->AddHead(object);
					return TRUE;
				} else {
					// This is a non-matching, non-NULL object value, so
					// try recursing downward as long as it's not
					// a vcNextObjectProp.
					if ((strcmp(prop->GetName(), vcNextObjectProp) != 0)
						&& obj->AncestryForObject(object, ancestry))
						return TRUE;
				}
			}
		}
	}
	ancestry->RemoveAt(headPos);
	return FALSE;
}

void CVCNode::WriteMultipart(
	ostream& strm, const char *propName,
	const char *propName1, const char *propName2, const char *propName3,
	const char *propName4, const char *propName5, BOOL qp)
{
	CVCProp *prop1 = GetProp(propName1);
	CVCProp *prop2 = GetProp(propName2);
	CVCProp *prop3 = GetProp(propName3);
	CVCProp *prop4 = GetProp(propName4);
	CVCProp *prop5 = GetProp(propName5);
	wchar_t propVal[256];
	char outName[128];
	char flagsStr[80];

	strcpy(outName, propName);
	FlagsToOutput(flagsStr);
	if (*flagsStr) {
		strcat(outName, ";");
		strcat(outName, flagsStr);
	}

	propVal[0] = 0;
	if (prop1) wcscpy(propVal, (wchar_t *)prop1->FindValue(VCStrIdxType)->GetValue());
	strm << outName << ":";
	WriteLineBreakString(strm, propVal, qp);
	strm << ";";
	propVal[0] = 0;
	if (prop2) wcscpy(propVal, (wchar_t *)prop2->FindValue(VCStrIdxType)->GetValue());
	WriteLineBreakString(strm, propVal, qp);

	if (prop3 || prop4 || prop5) {
		strm << ";";
		propVal[0] = 0;
		if (prop3) wcscpy(propVal, (wchar_t *)prop3->FindValue(VCStrIdxType)->GetValue());
		WriteLineBreakString(strm, propVal, qp);
	}
	if (prop4 || prop5) {
		strm << ";";
		propVal[0] = 0;
		if (prop4) wcscpy(propVal, (wchar_t *)prop4->FindValue(VCStrIdxType)->GetValue());
		WriteLineBreakString(strm, propVal, qp);
	}
	if (prop5) {
		strm << ";";
		propVal[0] = 0;
		if (prop5) wcscpy(propVal, (wchar_t *)prop5->FindValue(VCStrIdxType)->GetValue());
		WriteLineBreakString(strm, propVal, qp);
	}

	strm << "\n";
}

/////////////////////////////////////////////////////////////////////////////
void CVCNode::FlagsToOutput(char *str)
{
	str[0] = 0;

	for (CLISTPOSITION pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		const char *propName = prop->GetName();
		if (prop->IsBool()) {
			if (strnicmp(propName, "X-", 2) == 0) {
				strcat(str, propName);
				strcat(str, "=");
				strcat(str, (const char*)prop->FindValue(VCFlagsType)->GetValue());
				strcat(str, paramsep);
			} else if (strcmp(propName, vcCharSetProp) == 0) {
				strcat(str, "CHARSET=");
				strcat(str, (const char*)prop->FindValue(VCFlagsType)->GetValue());
				strcat(str, paramsep);
			} else if (strcmp(propName, vcLanguageProp) == 0) {
				strcat(str, "LANGUAGE=");
				strcat(str, (const char*)prop->FindValue(VCFlagsType)->GetValue());
				strcat(str, paramsep);
			} else {
				const char *tail;
				if (strcmp(propName, vcQuotedPrintableProp) == 0)
					tail = "QUOTED-PRINTABLE";
				else if (strcmp(propName, vcURLValueProp) == 0)
					tail = "URL";
				else 
					tail = strrchr(propName, '/') + 1;
				strcat(str, tail);
				strcat(str, paramsep);
			}
		}
	} // for

	if (*str) str[strlen(str)-1] = 0; // remove last comma
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCNode::Write(ostream& strm, const wchar_t *prefix, void *context)
{
	CVCProp *nodeNameProp = GetProp(vcNodeNameProp), *prop;
	wchar_t myPrefix[128];
	CLISTPOSITION pos;
	MSVContext *ctx = (MSVContext *)context;
	BOOL qp = ctx->card->GetInheritedProp(this, vcQuotedPrintableProp) != NULL;

	wcscpy(myPrefix, prefix);
	if (nodeNameProp) {
		if (wcslen(myPrefix)) {
			wchar_t dot[2];
			dot[0] = '.';
			dot[1] = 0;
			wcscat(myPrefix, dot);
		}
		wcscat(myPrefix, (wchar_t *)nodeNameProp->FindValue(VCStrIdxType)->GetValue());
	}

	for (pos = m_props->GetHeadPosition(); pos; ) {
		const char *propName;

		prop = (CVCProp *)m_props->GetNext(pos);
		propName = prop->GetName();

		if (!prop->IsBool() && (strcmp(propName, vcCharSetProp) == 0
			|| strcmp(propName, vcLanguageProp) == 0))
			if (!prop->Write(strm, myPrefix, this, context))
				return FALSE;
	}

	// for each non-bool prop that isn't Logo, Photo, or Pronunciation...
	for (pos = m_props->GetHeadPosition(); pos; ) {
		const char *propName;

		prop = (CVCProp *)m_props->GetNext(pos);
		propName = prop->GetName();

		if ((strcmp(propName, vcLogoProp) == 0)
			|| (strcmp(propName, vcPhotoProp) == 0)
			|| (strcmp(propName, vcPronunciationProp) == 0)
			|| (strcmp(propName, vcCharSetProp) == 0)
			|| (strcmp(propName, vcLanguageProp) == 0)
			|| prop->IsBool())
			continue;

		if ((strcmp(propName, vcFamilyNameProp) == 0)
			|| (strcmp(propName, vcGivenNameProp) == 0)
			|| (strcmp(propName, vcAdditionalNamesProp) == 0)
			|| (strcmp(propName, vcNamePrefixesProp) == 0)
			|| (strcmp(propName, vcNameSuffixesProp) == 0)) {
			if (!ctx->didFamGiven) {
				WriteMultipart(strm, "N",
					vcFamilyNameProp, vcGivenNameProp, vcAdditionalNamesProp,
					vcNamePrefixesProp, vcNameSuffixesProp, qp);
				ctx->didFamGiven = TRUE;
			}
		} else if ((strcmp(propName, vcOrgNameProp) == 0)
			|| (strcmp(propName, vcOrgUnitProp) == 0)
			|| (strcmp(propName, vcOrgUnit2Prop) == 0)
			|| (strcmp(propName, vcOrgUnit3Prop) == 0)
			|| (strcmp(propName, vcOrgUnit4Prop) == 0)) {
			if (!ctx->didOrg) {
				WriteMultipart(strm, "ORG",
					vcOrgNameProp, vcOrgUnitProp, vcOrgUnit2Prop,
					vcOrgUnit3Prop, vcOrgUnit4Prop, qp);
				ctx->didOrg = TRUE;
			}
		} else if ((strcmp(propName, vcPostalBoxProp) == 0)
			|| (strcmp(propName, vcExtAddressProp) == 0)
			|| (strcmp(propName, vcStreetAddressProp) == 0)
			|| (strcmp(propName, vcCityProp) == 0)
			|| (strcmp(propName, vcRegionProp) == 0)
			|| (strcmp(propName, vcPostalCodeProp) == 0)
			|| (strcmp(propName, vcCountryNameProp) == 0)) {
			if (ctx->didLocA)
				continue;
			CVCProp *prop1 = GetProp(vcPostalBoxProp);
			CVCProp *prop2 = GetProp(vcExtAddressProp);
			CVCProp *prop3 = GetProp(vcStreetAddressProp);
			CVCProp *prop4 = GetProp(vcCityProp);
			CVCProp *prop5 = GetProp(vcRegionProp);
			CVCProp *prop6 = GetProp(vcPostalCodeProp);
			CVCProp *prop7 = GetProp(vcCountryNameProp);
			wchar_t propVal[256];
			char flagsStr[80];

			FlagsToOutput(flagsStr);
			if (strlen(flagsStr))
				strm << "ADR;" << flagsStr << ":";
			else
				strm << "ADR:";
			propVal[0] = 0;
			if (prop1) wcscpy(propVal, (wchar_t *)prop1->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop2) wcscpy(propVal, (wchar_t *)prop2->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop3) wcscpy(propVal, (wchar_t *)prop3->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop4) wcscpy(propVal, (wchar_t *)prop4->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop5) wcscpy(propVal, (wchar_t *)prop5->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop6) wcscpy(propVal, (wchar_t *)prop6->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << ";";
			propVal[0] = 0;
			if (prop7) wcscpy(propVal, (wchar_t *)prop7->FindValue(VCStrIdxType)->GetValue());
			WriteLineBreakString(strm, propVal, qp);
			strm << "\n";
			ctx->didLocA = TRUE;
		} else if (!prop->Write(strm, myPrefix, this, context))
			return FALSE;
	}

	// finally write the logo/photo/pronunciation props	
	for (pos = m_props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)m_props->GetNext(pos);
		if ((strcmp(prop->GetName(), vcLogoProp) == 0)
			|| (strcmp(prop->GetName(), vcPhotoProp) == 0)
			|| (strcmp(prop->GetName(), vcPronunciationProp) == 0))
			if (!prop->Write(strm, myPrefix, this, context))
				return FALSE;
	}

	return TRUE;
}


/**** class CVCProp  ****/

/////////////////////////////////////////////////////////////////////////////
CVCProp::CVCProp(const char *name, CVCValue *value)
{
	m_name = NewStr(name);
	m_values = new CList;
	m_values->AddTail(value ? value : new CVCValue());
}

/////////////////////////////////////////////////////////////////////////////
CVCProp::CVCProp(const char *name, const char *type, void *value, S32 size)
{
	m_name = NewStr(name);
	m_values = new CList;
	m_values->AddTail(new CVCValue(type, value, size));
}

/////////////////////////////////////////////////////////////////////////////
CVCProp::~CVCProp()
{
    CLISTPOSITION pos;

    for (pos = m_values->GetHeadPosition(); pos; ) {
    	CVCValue *val = (CVCValue *)m_values->GetNext(pos);
    	delete val;
    }
    m_values->RemoveAll();
    delete m_values;
	delete [] m_name;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCProp::Copy()
{
	CVCProp *result = new CVCProp(m_name);
	CLISTPOSITION pos;
	CList *values = result->GetValues();

	// clear out every value that is in result's prop list before adding copies
    for (pos = values->GetHeadPosition(); pos; ) {
    	CVCValue *val = (CVCValue *)values->GetNext(pos);
    	delete val;
    }
    values->RemoveAll();

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *value = (CVCValue *)m_values->GetNext(pos);
		values->AddTail(value->Copy());
	}
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CList* CVCProp::GetValues()
{
	return m_values;
}

/////////////////////////////////////////////////////////////////////////////
const char *CVCProp::GetName()
{
	return m_name;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::SetName(const char *name)
{
	if (m_name)
		delete [] m_name;
	m_name = NewStr(name);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::AddValue(CVCValue *value)
{
	m_values->AddTail(value);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::RemoveValue(CVCValue *value, BOOL destroy)
{
	CLISTPOSITION pos, lastPos;

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *val;
		lastPos = pos;
		val = (CVCValue *)m_values->GetNext(pos);
		if (val == value) {
			m_values->RemoveAt(lastPos);
			if (destroy)
				delete value;
			break;

		}
	}
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp& CVCProp::RemoveValue(const char *type, BOOL destroy)
{
	CLISTPOSITION pos, lastPos;

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *value;
		lastPos = pos;
		value = (CVCValue *)m_values->GetNext(pos);
		if (strcmp(type, value->GetType()) == 0) {
			m_values->RemoveAt(lastPos);
			if (destroy)
				delete value;
			break;

		}
	}
	return *this;
}

CVCValue* CVCProp::FindValue(const char *type, void *value)
{
	CLISTPOSITION pos;

	for (pos = m_values->GetHeadPosition(); pos; ) {
		CVCValue *val = (CVCValue *)m_values->GetNext(pos);
		if (type) {
			if (strcmp(type, val->GetType()) == 0)
				return val;
		} else {
			if (value == val->GetValue())
				return val;
		}
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
static void WriteLineBreakString(ostream& strm, wchar_t *str, BOOL qp)
{
	if (qp) {
		while (*str) {
			if ((*str >= 32 && *str <= 60) || (*str >= 62 && *str <= 126))
				strm << (char)*str;
			else if (*str == 0x2028)
				strm << "=0A=\n";
			else if (HIBYTE(*str) == 0) {
				U8 c = LOBYTE(*str);
				char n[2];
				U8 d = c >> 4;
				n[0] = d > 9 ? d - 10 + 'A' : d + '0';
				d = c & 0xF;
				n[1] = d > 9 ? d - 10 + 'A' : d + '0';
				strm << "=" << n[0] << n[1];
			}
			str++;
		}
	} else {
		while (*str) {
			if (*str >= 32 && *str <= 126)
				strm << (char)*str;
			str++;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
static BOOL WriteBase64(ostream& strm, U8 __huge *bytes, S32 len)
{
	S32 cur = 0;
	int i, numQuads = 0;
	U32 trip;
	U8 b;
	char quad[5];
#define MAXQUADS 16

	quad[4] = 0;

	while (cur < len) {
		// collect the triplet of bytes into 'trip'
		trip = 0;
		for (i = 0; i < 3; i++) {
			b = (cur < len) ? *(bytes + cur) : 0;
			cur++;
			trip = trip << 8 | b;
		}
		// fill in 'quad' with the appropriate four characters
		for (i = 3; i >= 0; i--) {
			b = (U8)(trip & 0x3F);
			trip = trip >> 6;
			if ((3 - i) < (cur - len))
				quad[i] = '='; // pad char
			else if (b < 26) quad[i] = (char)b + 'A';
			else if (b < 52) quad[i] = (char)(b - 26) + 'a';
			else if (b < 62) quad[i] = (char)(b - 52) + '0';
			else if (b == 62) quad[i] = '+';
			else quad[i] = '/';
		}
		// now output 'quad' with appropriate whitespace and line ending
		strm
			<< (numQuads == 0 ? "    " : "")
			<< quad
			<< ((cur >= len) ? "\n" : (numQuads == MAXQUADS - 1 ? "\n" : ""));
		numQuads = (numQuads + 1) % MAXQUADS;
	}
	strm << "\n";

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCProp::IsBool()
{
	return FindValue(vcFlagsType) != NULL;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCProp::Write(
	ostream& strm, const wchar_t *prefix, CVCNode *node, void *context)
{
	CVCValue *value;
	char outName[128];
	char flagsStr[80];
	MSVContext *ctx = (MSVContext *)context;

	if (strcmp(m_name, vcPartProp) == 0) {
		CVCNode *node = (CVCNode *)FindValue(VCNextObjectType)->GetValue();
		return node->Write(strm, prefix, context);
	} else if (strcmp(m_name, vcBodyProp) == 0) {
		CVCNode *node = (CVCNode *)FindValue(VCNextObjectType)->GetValue();
		return node->Write(strm, prefix, context);
	} else if (strcmp(m_name, vcNodeNameProp) == 0) {
		// don't write this "property" out
		return TRUE;
	}
	
	outName[0] = 0;
	if (strnicmp(m_name, "X-", 2) == 0)
		strcpy(outName, m_name);
	else
		strcpy(outName, strrchr(m_name, '/') + 1);
	node->FlagsToOutput(flagsStr);
	if (*flagsStr) {
		strcat(outName, ";");
		strcat(outName, flagsStr);
	}

	if (((strcmp(m_name, vcPronunciationProp) == 0) && (value = FindValue(VCWAVType)))
		|| ((strcmp(m_name, vcPublicKeyProp) == 0) && (value = FindValue(VCOctetsType)))
		|| ((strcmp(m_name, vcLogoProp) == 0) && (value = FindValue(VCGIFType)))
		|| ((strcmp(m_name, vcPhotoProp) == 0) && (value = FindValue(VCGIFType)))
		|| ((strnicmp(m_name, "X-", 2) == 0) && (value = FindValue(VCOctetsType)))
		) {
		//char buf[80];
		ASSERT(*outName);
		if (wcslen(prefix)) {
			strm
				<< UI_CString(prefix, buf) << "."
				<< outName << ":\n";
			return WriteBase64(strm, (U8 __huge *)value->GetValue(), value->GetSize());
		} else {
			strm
				<< outName << ":\n";
			return WriteBase64(strm, (U8 __huge *)value->GetValue(), value->GetSize());
		}
	} else if (strcmp(m_name, vcAgentProp) == 0) {
		//char buf[80];
		ASSERT(*outName);
		value = FindValue(VCNextObjectType);
		if (wcslen(prefix))
			strm
				<< UI_CString(prefix, buf) << "."
				<< outName << ":";
		else
			strm << outName << ":";
		return ((CVCard *)value->GetValue())->Write(strm);
	} else if ((value = FindValue(VCStrIdxType)) && *outName) {
		//char buf[80];
		BOOL qp = ctx->card->GetInheritedProp(node, vcQuotedPrintableProp) != NULL;
		if (wcslen(prefix)) {
			strm
				<< UI_CString(prefix, buf) << "."
				<< outName << ":";
			WriteLineBreakString(strm, (wchar_t *)value->GetValue(), qp);
			strm << "\n";
		} else {
			strm << outName << ":";
			WriteLineBreakString(strm, (wchar_t *)value->GetValue(), qp);
			strm << "\n";
		}
	}
	
	return TRUE;
}


/**** class CVCValue  ****/

/////////////////////////////////////////////////////////////////////////////
CVCValue::CVCValue(const char *type, void *value, S32 size)
{
	m_type = NewStr(type ? type : VCNullType);
	m_value = value;
	m_size = size;
	if (size) {
		U8 __huge *newVal = HNEW(U8, size);
		_hmemcpy(newVal, (U8 __huge *)value, size);
		m_value = newVal;
	}
}

/////////////////////////////////////////////////////////////////////////////
CVCValue::~CVCValue()
{
	if (m_value)
		if (strcmp(m_type, VCNextObjectType) == 0)
			delete (CVCObject *)m_value;
		else
			if (m_size)
				HFREE((char*)m_value);
	delete [] m_type;
}

/////////////////////////////////////////////////////////////////////////////
CVCObject* CVCValue::Copy()
{
	CVCValue *result;
	
	if (strcmp(m_type, VCNextObjectType) == 0)
		result = new CVCValue(m_type, ((CVCObject *)m_value)->Copy(), m_size);
	else
		result = new CVCValue(m_type, m_value, m_size);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
const char *CVCValue::GetType()
{
	return m_type;
}

/////////////////////////////////////////////////////////////////////////////
CVCValue& CVCValue::SetType(const char *type)
{
	SetValue(); // to clean up any old value before changing the type
	delete [] m_type;
	m_type = NewStr(type);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
void* CVCValue::GetValue()
{
	return m_value;
}

/////////////////////////////////////////////////////////////////////////////
CVCValue& CVCValue::SetValue(void *value, S32 size)
{
	if (m_value)
		if (strcmp(m_type, VCNextObjectType) == 0)
			delete (CVCObject *)m_value;
		else
			if (m_size)
				HFREE((char*)m_value);
	if (size) {
		m_value = HNEW(char, size);
		_hmemcpy((U8 __huge *)m_value, (U8 __huge *)value, size);
	} else
		m_value = value;
	m_size = size;
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
S32 CVCValue::GetSize()
{
	return m_size;
}


/**** class CVCPropEnumerator  ****/

/////////////////////////////////////////////////////////////////////////////
CVCPropEnumerator::CVCPropEnumerator(CVCNode *root)
{
	m_objects = new CList;
	m_objects->AddHead(root);
	m_positions = new CList;
	m_positions->AddHead(root->GetProps()->GetHeadPosition());
}

/////////////////////////////////////////////////////////////////////////////
CVCPropEnumerator::~CVCPropEnumerator()
{
    m_objects->RemoveAll();
    delete m_objects;
    m_positions->RemoveAll();
    delete m_positions;
}

/////////////////////////////////////////////////////////////////////////////
CVCProp* CVCPropEnumerator::NextProp(CVCNode **node)
{
	CLISTPOSITION curPos = NULL;

	if (node) *node = NULL;

	// if the current pos is NULL, "pop" the stack until we find
	// a non-NULL position or stack is empty
	while (!m_objects->IsEmpty()
		&& !(curPos = (CLISTPOSITION)m_positions->GetHead())) {
		m_objects->RemoveAt(m_objects->GetHeadPosition());
		m_positions->RemoveAt(m_positions->GetHeadPosition());
		if (m_objects->IsEmpty())
			curPos = NULL;
	}

	if (curPos) {
		CVCNode *curObj = (CVCNode *)m_objects->GetHead();
		CList *props = curObj->GetProps();
		CVCProp *prop = (CVCProp *)props->GetNext(curPos);

		// advance position at top of stack to next in list.
		m_positions->GetHeadPosition()->m_item = curPos;

		// we'll return 'prop', but set up for next time by going deep.
		if ((strcmp(prop->GetName(), vcBodyProp) == 0)
			|| (strcmp(prop->GetName(), vcPartProp) == 0)
			|| (strcmp(prop->GetName(), vcNextObjectProp) == 0)) {
			CVCNode *nextObj = (CVCNode *)prop->FindValue(
				VCNextObjectType)->GetValue();
			m_objects->AddHead(nextObj);
			m_positions->AddHead(nextObj->GetProps()->GetHeadPosition());
		}
		if (node) *node = curObj;
		return prop;
	}

	return NULL;
}


/**** Utility Functions  ****/

static char *NewStr(const char *str)
{
	char *buf = new char[strlen(str) + 1];
	strcpy(buf, str);
	return buf;
}

/* ShortName takes a ISO 9070 string and checks to see if it is one
*  defined by versitcard. If so, it shortens it to the final substring
*  after the last //. These substrings are, by definition, the property
*  labels used in Simplegrams. (It doesn't have to be done this way, a
*  lookup table could be used, but this provides a convenient defacto
*  idiom for extending Simplegrams. In fact, we might want to change this
*  algorithm to "remove everything up to the final //" and not even check
*  if it is a versit-defined identifier?
*/
static char * ShortName(char * ps)
{
	if (strstr(ps,"+//ISBN 1-887687-00-9::versit::PDI//"))	 // if it's one of ours
	{
	  ps = strrchr(ps,'/');														 // abbreviate it
		ps++;
	}
	return ps;

} // ShortName

/* FixCRLF takes a pointer to a wide character (Unicode) string and searches
*  for old-fashioned ASCII \n and \r characters and hammers them into Unicode
*  line and paragraph separator characters.
*/
void FixCRLF(wchar_t * ps)
{
	do {	

		if (*ps == (wchar_t)'\n')			// translate linefeed to
			*ps = 0x2028;		 						// Unicode line separator 

		if (*ps == (wchar_t)'\r')			// translate carriage return to
			*ps = 0x2029;								// Unicode paragraph separator

	}	while (*ps++ != (wchar_t)NULL);

}	// FixCRLF

/* FakeUnicode takes a char * string and returns a wide character (Unicode)
*  equivalent. It does so by simply transforming 8-bits into 16 which will
*  not generally be a perfect translation. For purposes of this code the only
*  imperfection that is critical is handled by a followup call to FixCRLF.
*  If 'bytes' is non_NULL, *bytes is set to the number of bytes allocated.
*/
wchar_t * FakeUnicode(const char * ps, int * bytes)
{
	wchar_t	*r, *pw;
	int len = strlen(ps)+1;

	pw = r = new wchar_t[len];
	if (bytes)
		*bytes = len * sizeof(wchar_t);

	for (;;)
	{ 
		*pw++ = (wchar_t)(unsigned char)*ps;
			
	  if (*ps == 0)
			break;
		else
			ps++;
	}				 
	
	return r;

}	// FakeUnicode

// Simple-minded conversion from UNICODE to char string
static char *FakeCString(wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\n';
			u++;
		} else if (*u == 0x2029) {
			*dst++ = '\r';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}

/* NewlineTab outputs the number of newlines and tabs requested.
*/
static void NewlineTab(int nl, int tab)
{
	char s[128];

	s[0] = 0;

	while (nl-- > 0)	strcat(s,"\n");
	while (tab-- > 0)	strcat(s,"\t");

	debugf(s);
}

U8 __huge * _hmemcpy(U8 __huge * dst, U8 __huge * src, S32 len)
{
	U8 *d = dst;
	U8 *s = src;
	S32 l = 0;
	S32 c;
	do {
		c = min(len - l, 0xFFFF);
		memcpy(d, s, (size_t)c);
		d += c;
		s += c;
		l += c;
	} while (l < len);
	return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdatsrc.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include "stdafx.h"
#include "VCDoc.h"
#include "VCard.h"
#include "VCDatSrc.h"

/////////////////////////////////////////////////////////////////////////////
CVCDataSource::CVCDataSource(CVCDoc *doc)
{
	m_cards = (CVCard *)doc->GetVCard()->Copy();
}

/////////////////////////////////////////////////////////////////////////////
CVCDataSource::~CVCDataSource()
{
	delete m_cards;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCDataSource::OnRenderData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	FILE *file;
	char *tempname;
	HGLOBAL hGlobal = NULL;

	ASSERT(lpFormatEtc->tymed & TYMED_HGLOBAL);
	tempname = _tempnam(NULL, "CARD");
	if (!(file = fopen(tempname, "w+"))) {
		free(tempname);
		return FALSE;
	}

	if (m_cards->Write(file)) {
		fpos_t inLength;
		DWORD count, numAlloc;
		U8 *ptr;

		fclose(file);
		file = fopen(tempname, "rb");
		fseek(file, 0, SEEK_END);
		fgetpos(file, &inLength);
		fseek(file, 0, SEEK_SET);
		count = (int)inLength;
		hGlobal = GlobalAlloc(GMEM_SHARE, count);
		ptr = (U8 *)GlobalLock(hGlobal);
		if ((numAlloc = GlobalSize(hGlobal)) > count)
			memset(ptr + count, 0, numAlloc - count);
		fread(ptr, 1, count, file);
		GlobalUnlock(hGlobal);
		if (ferror(file)) {
			GlobalFree(hGlobal); hGlobal = NULL;
		}
	}

	fclose(file);
	unlink(tempname);
	free(tempname);
	lpStgMedium->tymed = hGlobal ? TYMED_HGLOBAL : TYMED_NULL;
	lpStgMedium->hGlobal = hGlobal;
	lpStgMedium->pUnkForRelease = NULL;
	return hGlobal != NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcard.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __VCARD_H__
#define __VCARD_H__

#if defined(_WIN32)
#include <wchar.h>
#else
#include "wchar.h"
#endif
#include <iostream.h>
#include <stdio.h>
#include "vcenv.h"
#include "ref.h"

#if defined(_WIN32) || defined(__MWERKS__)
#define __huge
#endif

class CVCNode;
class CVCProp;
class CVCValue;
class CList;

/////////////////////////////////////////////////////////////////////////////
class CVCObject
{
public:
	virtual ~CVCObject() {}
	virtual CVCObject *Copy() = 0;
};

/////////////////////////////////////////////////////////////////////////////

// A CVCard represents a VersitCard that can contain zero or more
// root objects.  Class CVCard implements reading from / writing to
// filed representations in either Html or MSV formats.
class CVCard : public CVCObject
{
public:
	CVCard();
	~CVCard();
	CVCObject *Copy();

	CList *GetObjects(); // each is a CVCNode*

	CVCard &AddObject(CVCNode *object);
		// to end of list; object becomes owned by CVCard
	CVCard &RemoveObject(CVCNode *object, BOOL destroy = TRUE);

	CVCNode *ParentForObject(CVCNode *object);
		// Find the parent, if any.  If it was a root, it itself is returned.
		// If the object is nowhere in the CVCard, NULL is returned.

	CVCProp *GetInheritedProp(CVCNode *object, const char *name, CVCNode **node = NULL);
		// Beginning at the object and moving parent-ward to the root,
		// look for a property maching the name along the way.
		// Return the property value, or NULL if none found.
		// If node is supplied, set *node to the node that has the property.

	void GetPropsInEffect(CVCNode *object, CList *list);
		// Collect all the properties in effect for an object.

	CVCNode *FindBody(const char *language = NULL);
		// searches the first root object for a body of the given language.
		// If no body objects match, returns the first body object.
		// If the first root object has no body objects, returns the first
		// root object.  If language is NULL, returns first body.

	BOOL Write(ostream& strm);
	BOOL Write(FILE *outputFile); // older version for compatibility

protected:
	CList *m_roots;
};

/*
 Boolean properties, such as VCDomesticProp, are represented in the card
 as the presence or absence of the property itself.  When present, the
 property has no real value (just one CVCValue of type VCNullType).
*/

/////////////////////////////////////////////////////////////////////////////

// A CVCNode represents an object that can have properties.
class CVCNode : public CVCObject
{
public:
	CVCNode(CVCProp *prop = NULL);
		// if supplied, an initial property is added (and the property
		// becomes owned by CVCNode)
	~CVCNode();
	CVCObject *Copy();

	CList *GetProps(); // each is a CVCProp*

	// These are short forms of using GetProps() and using the list directly.
	CVCProp *GetProp(const char *name);

	CVCNode &AddProp(CVCProp *prop);
		// to end of list; property becomes owned by CVCNode

	CVCNode *AddObjectProp(const char *propName, const char *marker = NULL);
		// Create a new CVCNode, optionally add a "marker" property to it
		// if supplied, and add this new object to self's properties
		// under "propName" (as a CVCValue of type VCNextObjectType).
		// Return the created node.

	CVCNode *AddPart();
		// Convenience for AddObjectProp(VCPartProp, VCPartObject).

	CVCProp *AddStringProp(const char *propName, const char *value, VC_DISPTEXT *dispText = NULL);
		// Add a property under "propName" whose value is a UNICODE string
		// derived from the given 8-bit string.

	CVCProp *AddBoolProp(const char *propName);
		// Sets the boolean property on this node.  By its presence, this
		// indicates a value of TRUE.

	CVCNode &RemoveProp(const char *name, BOOL destroy = TRUE);

	BOOL AncestryForObject(CVCNode *object, CList *ancestry);
		// If the object is a "child" of self, extend the ancestry list
		// to reflect the entire chain.  If not, the ancestry list remains
		// untouched.  Answer whether the object was found as a child.
		// This method assumes that the ancestry list passed is non-NULL
		// and contains self's parent (as head) thru the root object (as tail).

	BOOL Write(ostream& strm, const wchar_t *prefix, void *context);
	void FlagsToOutput(char *str);

protected:
	void WriteMultipart(
		ostream& strm, const char *outName, const char *propName1,
		const char *propName2, const char *propName3,
		const char *propName4, const char *propName5, BOOL qp);

	CList *m_props; // each item is a CVCProp*
};

/////////////////////////////////////////////////////////////////////////////

// A CVCProp represents a named list of type/value associations.
class CVCProp : public CVCObject
{
public:
	CVCProp(const char *name, CVCValue *value = NULL);
		// name is copied; value, if supplied, would become owned by CVCProp
	CVCProp(const char *name, const char *type, void *value = NULL, S32 size = 0);
		// name is copied.  Creates a new CVCValue from other arguments
		// and adds that value.
	~CVCProp();
	CVCObject *Copy();

	CList *GetValues(); // each is a CVCValue*

	const char *GetName();
	CVCProp &SetName(const char *name); // name is copied

	CVCProp &AddValue(CVCValue *value);
		// to end of list; value becomes owned by CVCProp
	CVCProp &RemoveValue(CVCValue *value, BOOL destroy = TRUE);
	CVCProp &RemoveValue(const char *type, BOOL destroy = TRUE);

	CVCValue *FindValue(const char *type = NULL, void *value = NULL);
		// Find and return the first value that has either the given type or value.
		// For value comparisons, only pointer equality is used.

	BOOL IsBool();
	
	BOOL Write(
		ostream& strm, const wchar_t *prefix, CVCNode *node, void *context);

protected:
	char *m_name;
	CList *m_values;
};

/////////////////////////////////////////////////////////////////////////////

// A CVCValue represents a typed, but otherwise nameless, value.
// Values of type VCNextObjectType hold a pointer to a CVCNode object.
// The 'size' quantity for such values is 0.
// All other values hold a void* pointer together with a size in bytes of
// that storage.  A size of 0 indicates that the void* pointer wasn't
// allocated, and the void* should be considered to be a U32.
class CVCValue : public CVCObject
{
public:
	CVCValue(const char *type = NULL, void *value = NULL, S32 size = 0);
		// type and value are copied
		// If type is NULL, the value's type will be VCNullType

	~CVCValue();
	CVCObject *Copy();

	const char *GetType();
	CVCValue &SetType(const char *type); // type is copied
		// does a SetValue() first so that an old value
		// is cleaned up properly

	void *GetValue();
	CVCValue &SetValue(void *value = NULL, S32 size = 0);
		// value is copied; old value is destroyed, if any

	S32 GetSize();

protected:
	char *m_type;
	void *m_value;
	S32 m_size;
};

/////////////////////////////////////////////////////////////////////////////

// CVCPropEnumerator provides for deep enumeration of properties beginning at
// some arbitrary object.  CVCPropEnumerator knows about VCBodyProp,
// VCPartProp, and VCNextObjectProp, and will search down those lists.
class CVCPropEnumerator
{
public:
	CVCPropEnumerator(CVCNode *root);

	virtual ~CVCPropEnumerator();

	CVCProp *NextProp(CVCNode **node = NULL);

protected:
	CList *m_objects;
	CList *m_positions;
};

extern void FixCRLF(wchar_t * ps);
extern wchar_t *FakeUnicode(const char * ps, int * bytes);
U8 __huge * _hmemcpy(U8 __huge * dst, U8 __huge * src, S32 len);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdatsrc.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include <afxole.h>

class CVCard;

class CVCDataSource : public COleDataSource
{
public:
	CVCDataSource(CVCDoc *doc);
	virtual ~CVCDataSource();

	BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
	
protected:
	CVCard *m_cards;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdll.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef _VCDLL_H_
#define _VCDLL_H_

#include "wchar.h"

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define VC_PROPNAME_MAX		64	// includes null terminator

typedef DWORD HVCEnumCard;
typedef DWORD HVCEnumProp;
typedef DWORD HVCEnumBoolProp;

#define VCARDAPI CALLBACK __export 


//---------------------------------------------------------------------------
// vCard enumeration functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Use this to begin an enumeration of the vCards in a file.
// lpszFileName is the path to the file.  The returned value indicates
// the first vCard in the file.  Pass this value to VCGetNextCard to find
// more vCards in the file, if any.  Use VCGetCardClose on the returned value
// to close the enumeration.  This function will return NULL if no vCard
// could be successfully parsed from the file (and so VCGetCardClose does not
// need to be called).
HVCEnumCard VCARDAPI VCGetFirstCardFromPath(LPCSTR lpszFileName);

/////////////////////////////////////////////////////////////////////////////
// Same as above, but takes a block of memory.
HVCEnumCard VCARDAPI VCGetFirstCardFromMem(HGLOBAL hGlobal);

/////////////////////////////////////////////////////////////////////////////
// Same as above, but creates a new card.
// Although there isn't much point in enumerating this, it is useful
// to then use the VCAdd* functions to construct the new card, then save it.
HVCEnumCard VCARDAPI VCGetNewCard();

/////////////////////////////////////////////////////////////////////////////
// VCGetNextCard sets the hVCEnum to indicate the next vCard in the file.
// hVCEnum is a handle obtained previously from VCGetFirstCard*.
// This function returns non-zero if successful, and 0 if there were no
// more cards that could be parsed from the file.  Use VCGetCardClose on the
// hVCEnum when finished.
DWORD VCARDAPI VCGetNextCard(HVCEnumCard hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Closes a card enumeration.
void VCARDAPI VCGetCardClose(HVCEnumCard hVCEnum);


//---------------------------------------------------------------------------
// property enumeration functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Gets the first non-boolean prop.  Has the same enumeration semantics
// as with VCGetFirstCard*.
HVCEnumProp VCARDAPI VCGetFirstProp(HVCEnumCard hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Gets the next non-boolean prop.  Has the same enumeration semantics
// as with VCGetNextCard.
DWORD VCARDAPI VCGetNextProp(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Closes a property enumeration.
void VCARDAPI VCGetPropClose(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Gets the first boolean prop associated with hVCProp.
HVCEnumBoolProp VCARDAPI VCGetFirstBoolProp(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Gets the next boolean prop associated with hVCEnum.
DWORD VCARDAPI VCGetNextBoolProp(HVCEnumBoolProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Closes a bool property enumeration.
void VCARDAPI VCGetBoolPropClose(HVCEnumBoolProp hVCEnum);


//---------------------------------------------------------------------------
// property data functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Copies into lpstr the name of the property.
// The buffer must be of at least VC_PROPNAME_MAX in length.
void VCARDAPI VCPropName(HVCEnumProp hVCEnum, LPSTR lpstr);

/////////////////////////////////////////////////////////////////////////////
// Copies into lpstr the name of the property.
// The buffer must be of at least VC_PROPNAME_MAX in length.
void VCARDAPI VCBoolPropName(HVCEnumBoolProp hVCEnum, LPSTR lpstr);

/////////////////////////////////////////////////////////////////////////////
// Copies into lpstr the string value of the property, if any.
// If the property has no string value, lpstr[0] is set to 0 and the
// function returns 0.  If there isn't enough room in the buffer,
// the function returns the negative of the number of characters needed.
// When successful, the function returns the length of the returned string.
int VCARDAPI VCPropStringValue(HVCEnumProp hVCEnum, LPWSTR lpwstr, int len);

/////////////////////////////////////////////////////////////////////////////
// This function returns a copy of the prop's value of the given type,
// or NULL if the prop has no such type.  lpszType should be one of
// VCOctetsType, VCGIFType, or VCWAVType.  The client is responsible
// for freeing the returned data.
HGLOBAL VCARDAPI VCPropBinaryValue(HVCEnumProp hVCEnum, LPCSTR lpszType);


//---------------------------------------------------------------------------
// editing functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// This adds a string property to a card.
// The returned prop won't have any associated boolean props.
// The client must call VCGetPropClose on the returned prop when finished.
// The returned enumeration is restricted to just this new property,
// so calling VCGet*Prop on it is pointless.
// Note: any open enumerations of this card may or may not discover and
// return this new property.  The client should close any open enumerations
// of the card and begin with new enumerations after using VCAddStringProp
// in order to achieve predictable results.
HVCEnumProp VCARDAPI VCAddStringProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCWSTR value);

/////////////////////////////////////////////////////////////////////////////
// Adds a binary prop to the card.  The value is copied, so the parameter
// value is still "owned" by the caller.
// The parameter type should be one of VCOctetsType, VCGIFType, or VCWAVType.
// This function has the same semantics as VCAddStringProp with respect to
// using VCGetPropClose and the effects on open enumerations.
HVCEnumProp VCARDAPI VCAddBinaryProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType, HGLOBAL value);

/////////////////////////////////////////////////////////////////////////////
// Changes the value of an existing string prop.
// This function returns non-zero if successful.
DWORD VCARDAPI VCSetStringProp(HVCEnumProp hVCEnum, LPCWSTR value);

/////////////////////////////////////////////////////////////////////////////
// Changes the value of an existing binary prop.
// This function returns non-zero if successful.
// The value is copied.
// The parameter type should be one of VCOctetsType, VCGIFType, or VCWAVType.
DWORD VCARDAPI VCSetBinaryProp(HVCEnumProp hVCEnum, LPCSTR lpszType, HGLOBAL value);

/////////////////////////////////////////////////////////////////////////////
// Associates a boolean prop with the given property.
// This function returns non-zero if successful.
// Note: any open enumerations of this card may or may not discover and
// return this new property.  The client should close any open enumerations
// of the card and begin with new enumerations after using VCAddBoolProp
// in order to achieve predictable results.
DWORD VCARDAPI VCAddBoolProp(LPCSTR lpszPropName, HVCEnumProp addTo);

/////////////////////////////////////////////////////////////////////////////
// Removes a prop.  This will remove all associated boolean props.
// Note: the actual removal won't happen until the prop enumeration is closed
// with VCGetPropClose.
void VCARDAPI VCRemoveProp(HVCEnumProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Removes a bool prop.
// Note: the actual removal won't happen until the enclosing non-bool prop
// enumeration is closed with VCGetPropClose.
// See Also: VCRemoveBoolPropByName.
void VCARDAPI VCRemoveBoolProp(HVCEnumBoolProp hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// This is a convenience function that opens up a new bool prop enumeration
// for the given prop, searches for any bool props of the given name, and
// removes them (typically just one will be found).  This function uses
// VCRemoveBoolProp.
// See Also: VCRemoveBoolProp.
void VCARDAPI VCRemoveBoolPropByName(HVCEnumProp hVCEnum, LPCSTR name);


//---------------------------------------------------------------------------
// card output functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// Writes a vCard to a file.
DWORD VCARDAPI VCSaveCardToPath(LPCSTR path, HVCEnumCard hVCEnum);

/////////////////////////////////////////////////////////////////////////////
// Same as above, but writes to a new memory block.
// The caller is responsible for freeing it.
HGLOBAL VCARDAPI VCSaveCardToMem(HVCEnumCard hVCEnum);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _VCDLL_H_ */

/***************************************************************************/

#if 0
// This is some sample code.  It will print to the debugging output
// the VCFullNameProp and all VCTelephoneProp's that are FAX numbers
// (those that have the associated boolean prop VCFaxProp).
void ProcessCardFile(LPCSTR path)
{
	HVCEnumCard hVCEnumCard;
	
	hVCEnumCard = VCGetFirstCardFromPath(path);
	if (hVCEnumCard) {
		ProcessCard(hVCEnumCard);
		// process remaining cards
		while (VCGetNextCard(hVCEnumCard)) {
			// process a card
		}
		VCGetCardClose(hVCEnumCard);
	}
} // ProcessCardFile

void ProcessCard(HVCEnumCard hVCEnumCard)
{
	HVCEnumProp hVCEnumProp;

	hVCEnumProp = VCGetFirstProp(hVCEnumCard);
	if (hVCEnumProp) {
		ProcessProp(hVCEnumProp);
		// process remaining props
		while (VCGetNextProp(hVCEnumProp)) {
			ProcessProp(hVCEnumProp);
		}
		VCGetPropClose(hVCEnumProp);
	}
} // ProcessCard

void ProcessProp(HVCEnumProp hVCEnumProp)
{
#define STRBUFLEN 128
	char propName[VC_PROPNAME_MAX];
	wchar_t stackUniBuf[STRBUFLEN];
	char stackStrBuf[STRBUFLEN];
	int len;
	
	VCPropName(hVCEnumProp, propName);
	if (strcmp(propName, VCFullNameProp) == 0) {
		if ((len = VCPropStringValue(hVCEnumProp, stackUniBuf, STRBUFLEN)) < 0) {
			// need to allocate because it's bigger than STRBUFLEN
			// -(len) is number of characters required
		} else {
			// string value fits within STRBUFLEN
			TRACE1("full name is %s\n", UI_CString(stackUniBuf, stackStrBuf));
		}
	} else if (strcmp(propName, VCTelephoneProp) == 0) {
		HVCEnumBoolProp hVCEnumBoolProp;
		BOOL isFax = FALSE;
		
		hVCEnumBoolProp = VCGetFirstBoolProp(hVCEnumProp);
		if (hVCEnumBoolProp) {
			VCBoolPropName(hVCEnumBoolProp, propName);
			if (strcmp(propName, VCFaxProp) == 0) {
				isFax = TRUE;
			} else {
				while (VCGetNextBoolProp(hVCEnumBoolProp)) {
					VCBoolPropName(hVCEnumBoolProp, propName);
					if (strcmp(propName, VCFaxProp) == 0) {
						isFax = TRUE;
						break;
					}
				}
			}
			if (isFax) {
				if ((len = VCPropStringValue(hVCEnumProp, stackUniBuf, STRBUFLEN)) < 0) {
					// need to allocate because it's bigger than STRBUFLEN
					// -(len) is number of characters required
				} else {
					// string value fits within STRBUFLEN
					TRACE1("FAX TEL is %s\n", UI_CString(stackUniBuf, stackStrBuf));
				}
			}
			VCGetBoolPropClose(hVCEnumBoolProp);
		}
	}
} // ProcessProp

// Simple-minded conversion from UNICODE to char string
char *UI_CString(const wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\r';
			*dst++ = '\n';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdll.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// vc32.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <fstream.h>
#include "vc32.h"
#include "vcdll.h"
#include "clist.h"
#include "vcard.h"
#include "msv.h"
#include "mime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVc32App

BEGIN_MESSAGE_MAP(CVc32App, CWinApp)
	//{{AFX_MSG_MAP(CVc32App)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVc32App construction

CVc32App::CVc32App()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CVc32App object

CVc32App theApp;

typedef struct {
	CVCard *vCard;
	CVCPropEnumerator *pEnum; // if NULL, indicates a "one-shot" enum
	CVCProp *prop;
	CVCNode *node;
	CList *pendingRemove;
} VCEnumPropPriv, *HVCEnumPropPriv;

typedef struct {
	CList list;
	CLISTPOSITION pos;
	CVCNode *node;
	HVCEnumPropPriv parentPropEnum;
} VCEnumListPriv, *HVCEnumListPriv;

typedef struct {
	CVCProp *prop;
	CVCNode *node;
} VCPendingRemove;

static HGLOBAL LoadFile(LPCSTR path);
static HVCEnumProp NewProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType,
	void *value, S32 size);

//---------------------------------------------------------------------------
// Exported functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumCard VCGetFirstCardFromPath(LPCSTR lpszFileName)
{
    HVCEnumListPriv hVCEnumPriv = new VCEnumListPriv;
    CStdioFile file(lpszFileName, CFile::modeRead | CFile::typeBinary);
    
    if (!Parse_Many_MSV_FromFile(&file, &hVCEnumPriv->list)
    	&& !Parse_Many_MIME_FromFile(&file, &hVCEnumPriv->list)) {
    	delete hVCEnumPriv; hVCEnumPriv = NULL;
    } else {
    	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
    	hVCEnumPriv->parentPropEnum = NULL;
    	hVCEnumPriv->node = NULL;
    }
	return (HVCEnumCard)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumCard VCGetFirstCardFromMem(HGLOBAL hGlobal)
{
    HVCEnumListPriv hVCEnumPriv;
    const char *data = (const char *)GlobalLock(hGlobal);
    
    if (!data)
    	return (HVCEnumCard)NULL;
    
    hVCEnumPriv = new VCEnumListPriv;
    if (!Parse_Many_MSV(data, GlobalSize(hGlobal), &hVCEnumPriv->list)
    	&& !Parse_Many_MIME(data, GlobalSize(hGlobal), &hVCEnumPriv->list)) {
    	delete hVCEnumPriv; hVCEnumPriv = NULL;
    } else {
    	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
    	hVCEnumPriv->parentPropEnum = NULL;
    	hVCEnumPriv->node = NULL;
    }
    GlobalUnlock(hGlobal);
	return (HVCEnumCard)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumCard VCGetNewCard()
{
    HVCEnumListPriv hVCEnumPriv = new VCEnumListPriv;
	CVCard *vCard = new CVCard;
	CVCNode *root, *english;
	CVCProp *prop;
	
	vCard->AddObject(root = new CVCNode);					// create root
	root->AddProp(new CVCProp(vcRootObject));				// mark it so
	english = root->AddObjectProp(vcBodyProp, vcBodyObject);
	english->AddProp(prop = new CVCProp(vcLanguageProp));	
	prop->AddValue(new CVCValue(vcISO639Type, "en", (size_t)2));
	
	hVCEnumPriv->list.AddTail(vCard);
	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
	hVCEnumPriv->parentPropEnum = NULL;
    hVCEnumPriv->node = NULL;

	return (HVCEnumCard)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport DWORD VCGetNextCard(HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    
    hVCEnumPriv->list.GetNext(hVCEnumPriv->pos);
    if (hVCEnumPriv->pos == NULL)
    	return 0;
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport void VCGetCardClose(HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;

    for (CLISTPOSITION pos = hVCEnumPriv->list.GetHeadPosition(); pos; ) {
    	CVCard* vCard = (CVCard*)hVCEnumPriv->list.GetNext(pos);
    	delete vCard;
    }
    delete hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HVCEnumProp VCGetFirstProp(HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumListPriv = (HVCEnumListPriv)hVCEnum;
    CVCard *vCard = (CVCard*)hVCEnumListPriv->list.GetAt(hVCEnumListPriv->pos);
	CVCNode *body = vCard->FindBody();
    HVCEnumPropPriv hVCEnumPriv = new VCEnumPropPriv;

	hVCEnumPriv->pEnum = new CVCPropEnumerator(body);
	hVCEnumPriv->pendingRemove = NULL;
	hVCEnumPriv->vCard = vCard;
	while ((hVCEnumPriv->prop = hVCEnumPriv->pEnum->NextProp(&(hVCEnumPriv->node)))) {
		if (!hVCEnumPriv->prop->IsBool())
			return (HVCEnumProp)hVCEnumPriv;
	}
	delete hVCEnumPriv->pEnum;
	delete hVCEnumPriv;
	return (HVCEnumProp)NULL;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport DWORD VCGetNextProp(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    
	if (!hVCEnumPriv->pEnum)
		return FALSE;
	while ((hVCEnumPriv->prop = hVCEnumPriv->pEnum->NextProp(&(hVCEnumPriv->node)))) {
		if (!hVCEnumPriv->prop->IsBool())
			return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCGetPropClose(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;

	if (hVCEnumPriv->pEnum)
		delete hVCEnumPriv->pEnum;
    if (hVCEnumPriv->pendingRemove) {
    	for (CLISTPOSITION pos = hVCEnumPriv->pendingRemove->GetHeadPosition(); pos; ) {
    		VCPendingRemove *pr = (VCPendingRemove*)hVCEnumPriv->pendingRemove->GetNext(pos);
			if (pr->prop->IsBool()) {
				CList *props = pr->node->GetProps();
				CLISTPOSITION pos2;
				if ((pos2 = props->Find(pr->prop))) {
					props->RemoveAt(pos2);
					delete pr->prop;
				}
			} else {
				CVCNode *parent = hVCEnumPriv->vCard->ParentForObject(pr->node);
				CList *props = parent->GetProps();
		    	for (CLISTPOSITION pos2 = props->GetHeadPosition(); pos2; ) {
		    		CVCProp *prop = (CVCProp*)props->GetNext(pos2);
		    		CVCValue *value = prop->FindValue(vcNextObjectType);
		    		if (value && (CVCObject*)value->GetValue() == pr->node) {
		    			props->RemoveAt(pos2 ? pos2->m_prev : props->GetTailPosition());
		    			delete prop;
		    			break;
		    		}
		    	}
		    }
    		delete pr;
    	}
    	delete hVCEnumPriv->pendingRemove;
    }
	delete hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HVCEnumBoolProp VCGetFirstBoolProp(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPropPriv = (HVCEnumPropPriv)hVCEnum;
    HVCEnumListPriv hVCEnumPriv = new VCEnumListPriv;
    CList *props = hVCEnumPropPriv->node->GetProps();

    for (CLISTPOSITION pos = props->GetHeadPosition(); pos; ) {
    	CVCProp *prop = (CVCProp*)props->GetNext(pos);
    	if (prop->IsBool())
    		hVCEnumPriv->list.AddTail(prop);
    }
    if (hVCEnumPriv->list.GetCount() == 0) {
    	delete hVCEnumPriv; hVCEnumPriv = NULL;
    } else {
    	hVCEnumPriv->pos = hVCEnumPriv->list.GetHeadPosition();
    	hVCEnumPriv->parentPropEnum = hVCEnumPropPriv;
        hVCEnumPriv->node = hVCEnumPropPriv->node;
	}
	return (HVCEnumBoolProp)hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCGetNextBoolProp(HVCEnumBoolProp hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    
    hVCEnumPriv->list.GetNext(hVCEnumPriv->pos);
    if (hVCEnumPriv->pos == NULL)
    	return 0;
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCGetBoolPropClose(HVCEnumBoolProp hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
	delete hVCEnumPriv;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCPropName(HVCEnumProp hVCEnum, LPSTR lpstr)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
	strcpy(lpstr, hVCEnumPriv->prop->GetName());
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCBoolPropName(HVCEnumBoolProp hVCEnum, LPSTR lpstr)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    CVCProp *prop = (CVCProp*)hVCEnumPriv->list.GetAt(hVCEnumPriv->pos);
	strcpy(lpstr, prop->GetName());
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport int VCPropStringValue(HVCEnumProp hVCEnum, LPWSTR lpwstr, int len)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *value = (CVCValue*)hVCEnumPriv->prop->FindValue(vcStrIdxType);
    if (!value)
		return 0;
	LPCWSTR str = (LPCWSTR)value->GetValue();
	int strlen = wcslen(str);
	if (strlen + 1 > len)
		return -(strlen + 1);
	wcscpy(lpwstr, str);
	return strlen;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HGLOBAL VCPropBinaryValue(HVCEnumProp hVCEnum, LPCSTR lpszType)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *value = (CVCValue*)hVCEnumPriv->prop->FindValue(lpszType);
    long count;
    HGLOBAL hGlobal;
    U8 __huge *ptr;
    
    if (!value)
		return NULL;
	count = value->GetSize();
	if ((hGlobal = GlobalAlloc(GMEM_SHARE, count)) == NULL)
		return hGlobal;
	if ((ptr = (U8 __huge *)GlobalLock(hGlobal)) == NULL) {
		GlobalUnlock(hGlobal);
		return NULL;
	}
	_hmemcpy(ptr, (U8 __huge *)value->GetValue(), count);
	GlobalUnlock(hGlobal);
	return hGlobal;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HVCEnumProp VCAddStringProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCWSTR value)
{
    return NewProp(
    	hVCEnum, lpszPropName, vcStrIdxType, (void*)value,
		(wcslen(value) + 1) * sizeof(wchar_t));
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport HVCEnumProp VCAddBinaryProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType, HGLOBAL value)
{
	HVCEnumProp hVCEnumProp;
    U8 __huge *ptr;
    
	if ((ptr = (U8 __huge *)GlobalLock(value)) == NULL)
		return NULL;
    hVCEnumProp = NewProp(
    	hVCEnum, lpszPropName, lpszType, (void*)ptr, GlobalSize(value));
	GlobalUnlock(value);
	return hVCEnumProp;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCSetStringProp(HVCEnumProp hVCEnum, LPCWSTR value)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *val = (CVCValue*)hVCEnumPriv->prop->FindValue(vcStrIdxType);
    if (!val)
		return FALSE;
	val->SetValue((void*)value, (wcslen(value) + 1) * sizeof(wchar_t));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCSetBinaryProp(HVCEnumProp hVCEnum, LPCSTR lpszType, HGLOBAL value)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    CVCValue *val = (CVCValue*)hVCEnumPriv->prop->FindValue(lpszType);
    U8 __huge *ptr;
    
    if (!val)
		return FALSE;
	if ((ptr = (U8 __huge *)GlobalLock(value)) == NULL)
		return FALSE;
	val->SetValue((void*)ptr, GlobalSize(value));
	GlobalUnlock(value);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport DWORD VCAddBoolProp(LPCSTR lpszPropName, HVCEnumProp addTo)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)addTo;
    hVCEnumPriv->node->AddBoolProp(lpszPropName);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCRemoveProp(HVCEnumProp hVCEnum)
{
    HVCEnumPropPriv hVCEnumPriv = (HVCEnumPropPriv)hVCEnum;
    VCPendingRemove *pr;
    
    if (!hVCEnumPriv->pendingRemove)
    	hVCEnumPriv->pendingRemove = new CList;
    pr = new VCPendingRemove;
    pr->node = hVCEnumPriv->node;
    pr->prop = hVCEnumPriv->prop;
    hVCEnumPriv->pendingRemove->AddTail(pr);
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCRemoveBoolProp(HVCEnumBoolProp hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
    CVCProp *prop = (CVCProp*)hVCEnumPriv->list.GetAt(hVCEnumPriv->pos);
    VCPendingRemove *pr;
    
    if (!hVCEnumPriv->parentPropEnum->pendingRemove)
    	hVCEnumPriv->parentPropEnum->pendingRemove = new CList;
    pr = new VCPendingRemove;
    pr->node = hVCEnumPriv->node;
    pr->prop = prop;
    hVCEnumPriv->parentPropEnum->pendingRemove->AddTail(pr);
}

/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport void VCRemoveBoolPropByName(HVCEnumProp hVCEnum, LPCSTR name)
{
	HVCEnumBoolProp bprop = VCGetFirstBoolProp(hVCEnum);
	
	if (bprop) {
		char propName[VC_PROPNAME_MAX];
		VCBoolPropName(bprop, propName);
		if (strcmp(propName, name) == 0)
			VCRemoveBoolProp(bprop);
		// process remaining props
		while (VCGetNextBoolProp(bprop)) {
			VCBoolPropName(bprop, propName);
			if (strcmp(propName, name) == 0)
				VCRemoveBoolProp(bprop);
		}
		VCGetBoolPropClose(bprop);
	}
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport DWORD VCSaveCardToPath(LPCSTR path, HVCEnumCard hVCEnum)
{
    HVCEnumListPriv hVCEnumPriv = (HVCEnumListPriv)hVCEnum;
	CVCard *vCard = (CVCard*)hVCEnumPriv->list.GetAt(hVCEnumPriv->pos);
	ofstream strm(path, ios::app);
	vCard->Write(strm);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
extern "C" 
DllExport HGLOBAL VCSaveCardToMem(HVCEnumCard hVCEnum)
{
	char *tempname;
	HGLOBAL hGlobal = NULL;

	tempname = _tempnam(NULL, "CARD");
	if (VCSaveCardToPath(tempname, hVCEnum)) {
		hGlobal = LoadFile(tempname);
		unlink(tempname);
	}
	free(tempname);
	return hGlobal;
}


//---------------------------------------------------------------------------
// Private functions
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
static HGLOBAL LoadFile(LPCSTR path)
{
	fpos_t inLength;
	DWORD count, numAlloc, num;
	FILE *file;
	U8 __huge *ptr;
	BOOL error = FALSE;
	HGLOBAL hGlobal = NULL;

	file = fopen(path, "rb");
	fseek(file, 0, SEEK_END);
	fgetpos(file, &inLength);
	fseek(file, 0, SEEK_SET);
	count = (DWORD)inLength;
	if ((hGlobal = GlobalAlloc(GMEM_SHARE, count)) == NULL)
		goto Done;
	if ((ptr = (U8 __huge *)GlobalLock(hGlobal)) == NULL) {
		GlobalFree(hGlobal); hGlobal = NULL;
		goto Done;
	}
	if ((numAlloc = GlobalSize(hGlobal)) > count)
		memset(ptr + count, 0, (int)(numAlloc - count));
	do {
		num = min(count, 0x7FFF);
		fread(ptr, 1, (size_t)num, file);
		if (ferror(file))
			error = TRUE;
		else {
			count -= num;
			ptr += num;
		}
	} while (count && !error);
	GlobalUnlock(hGlobal);
	if (error) {
		GlobalFree(hGlobal); hGlobal = NULL;
	}
Done:
	fclose(file);
	return hGlobal;
}

static const char *groupAddr[] = {
	vcExtAddressProp,
	vcStreetAddressProp,
	vcCityProp,
	vcRegionProp,
	vcPostalCodeProp,
	vcCountryNameProp,
	NULL
};

static const char *groupPersonName[] = {
	vcFamilyNameProp,
	vcGivenNameProp,
	NULL
};

static const char *groupCompanyName[] = {
	vcOrgNameProp,
	vcOrgUnitProp,
	NULL
};

static BOOL IsMemberOfGroup(const char *propName, const char **group)
{
	while (*group) {
		if (strcmp(propName, *group) == 0)
			return TRUE;
		group++;
	}
	return FALSE;
}

static CVCNode* FindGroup(CVCNode* body, const char **group)
{
	CVCPropEnumerator enumerator(body);
	CVCNode* node;
	CVCProp* prop;
	
	while ((prop = enumerator.NextProp(&node))) {
		if (IsMemberOfGroup(prop->GetName(), group))
			return node;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
static HVCEnumProp NewProp(
	HVCEnumCard hVCEnum, LPCSTR lpszPropName, LPCSTR lpszType,
	void *value, S32 size)
{
    HVCEnumListPriv hVCEnumListPriv = (HVCEnumListPriv)hVCEnum;
    CVCard *vCard = (CVCard*)hVCEnumListPriv->list.GetAt(hVCEnumListPriv->pos);
	CVCNode *body = vCard->FindBody();
    HVCEnumPropPriv hVCEnumPriv = new VCEnumPropPriv;
	
	if (IsMemberOfGroup(lpszPropName, groupAddr))
		hVCEnumPriv->node = FindGroup(body, groupAddr);
	else if (IsMemberOfGroup(lpszPropName, groupPersonName))
		hVCEnumPriv->node = FindGroup(body, groupPersonName);
	else if (IsMemberOfGroup(lpszPropName, groupCompanyName))
		hVCEnumPriv->node = FindGroup(body, groupCompanyName);
	else
		hVCEnumPriv->node = body->AddPart();
	if (!hVCEnumPriv->node)
		hVCEnumPriv->node = body->AddPart();
	hVCEnumPriv->node->AddProp(
		hVCEnumPriv->prop = new CVCProp(lpszPropName, lpszType, value, size));

	hVCEnumPriv->pEnum = NULL;
	hVCEnumPriv->pendingRemove = NULL;
	hVCEnumPriv->vCard = vCard;
	return (HVCEnumProp)hVCEnumPriv;
}

// Simple-minded conversion from UNICODE to char string
char *UI_CString(const wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\r';
			*dst++ = '\n';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}

CM_CFUNCTIONS

void Parse_Debug(const char *s)
{
	::AfxTrace(s);
}

/*/////////////////////////////////////////////////////////////////////////*/
void msv_error(char *s)
{
	if (++msv_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, msv_lineNum);
		//TRACE1("%s\n", buf);
	}
}

/*/////////////////////////////////////////////////////////////////////////*/
void mime_error(char *s)
{
	if (++mime_numErrors <= 3) {
		char buf[80];
		sprintf(buf, "%s at line %d", s, mime_lineNum);
		//TRACE1("%s\n", buf);
	}
}

CM_END_CFUNCTIONS


/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcir.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// IVCServer_IR wrapper class

class IVCServer_IR : public COleDispatchDriver
{
public:
	IVCServer_IR() {}		// Calls COleDispatchDriver default constructor
	IVCServer_IR(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	IVCServer_IR(const IVCServer_IR& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	long SendFile(LPCTSTR path);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcenv.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#ifndef __VCENV_H__
#define __VCENV_H__
                      
typedef char			S8,   *P_S8,   **PP_S8;
typedef unsigned char	U8,   *P_U8,   **PP_U8;
typedef short			S16,  *P_S16,  **PP_S16;
typedef unsigned short	U16,  *P_U16,  **PP_U16;	// WORD and UINT are equivalent
typedef long			S32,  *P_S32,  **PP_S32;
typedef unsigned long	U32,  *P_U32,  **PP_U32;	// DWORD is equivalent
typedef float			F32,  *P_F32,  **PP_F32;
typedef double			F64,  *P_F64,  **PP_F64;
//typedef unsigned short	UNICODE,  *P_UNICODE,  **PP_UNICODE;

#define maxS8  0x7F
#define maxU8  0xFF
#define maxS16 0x7FFF
#define maxU16 0xFFFF
#define maxS32 0x7FFFFFFF
#define maxU32 0xFFFFFFFF

typedef struct
    {
    F32 x, y;
    } FCOORD,  *P_FCOORD,  **PP_FCOORD;

#ifndef BOOL
typedef int                 BOOL;
#ifndef __MWERKS__
#define TRUE 1
#define FALSE 0
#endif
#endif

#ifdef __cplusplus
#define CM_CFUNCTION 		extern "C" {
#define CM_CFUNCTIONS 		extern "C" {
#define CM_END_CFUNCTION	}
#define CM_END_CFUNCTIONS	}
#else
#define CM_CFUNCTION
#define CM_CFUNCTIONS
#define CM_END_CFUNCTION
#define CM_END_CFUNCTIONS
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdoc.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCdoc.cpp : implementation of the CVCDoc class

#include "stdafx.h"
#include "VC.h"

#include <strstrea.h>
#include "VCdoc.h"
#include "vcard.h"
#include "clist.h"
#include "gifread.h"
#include "mainfrm.h"
#include "msv.h"
#include "mime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//#define TRY_CFILE

#define smPt 14
#define bgPt 16

CM_CFUNCTIONS

#if 0
extern BOOL Parse_HTML(
	const char *input,			/* In */
	int len,					/* In */
	const char *dirPath,		/* In */
	CVCard **card,				/* Out */
	int *_posPreambleEnd,		/* Out */
	int *_posPostambleStart,	/* Out */
	char **_unknownTags);		/* Out */
#endif

CM_END_CFUNCTIONS

CString CanonicalPath(const CString &path);
CString NativePath(const CString &path);


/////////////////////////////////////////////////////////////////////////////
// CVCDoc

IMPLEMENT_DYNCREATE(CVCDoc, CDocument)

BEGIN_MESSAGE_MAP(CVCDoc, CDocument)
	//{{AFX_MSG_MAP(CVCDoc)
	ON_COMMAND(ID_INSERT_LOGO, OnInsertLogo)
	ON_COMMAND(ID_INSERT_PHOTO, OnInsertPhoto)
	ON_COMMAND(ID_INSERT_PRONUN, OnInsertPronun)
	ON_COMMAND(ID_SEND_IRDA, OnSendIrda)
	ON_UPDATE_COMMAND_UI(ID_SEND_IRDA, OnUpdateSendIrda)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVCDoc construction/destruction

/////////////////////////////////////////////////////////////////////////////
CVCDoc::CVCDoc()
{
	// TODO: add one-time construction code here
	m_sizeDoc = CSize(8192, 5000);
	m_minSizeDoc = CSize(8192, 5000);
	m_vcard = NULL;
	m_preamble = m_postamble = NULL;
	m_preambleLen = m_postambleLen = 0;
	m_unknownTags = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CVCDoc::~CVCDoc()
{
	if (m_vcard) delete m_vcard;
	if (m_preamble) delete [] m_preamble;
	if (m_postamble) delete [] m_postamble;
	if (m_unknownTags) delete m_unknownTags;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	CVCNode *root, *english;

	if (m_vcard)
		delete m_vcard;

	m_vcard = new CVCard;
	m_vcard->AddObject(root = new CVCNode);					// create root
	root->AddProp(new CVCProp(VCRootObject));				// mark it so

	english = root->AddObjectProp(vcBodyProp, VCBodyObject);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CVCDoc serialization

void CVCDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
		ar << m_sizeDoc;
	}
	else
	{
		// TODO: add loading code here
		ar >> m_sizeDoc;
	}

	// Calling the base class CDocument enables serialization
	//  of the container document's COleClientItem objects.
	CDocument::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CVCDoc diagnostics

#ifdef _DEBUG
void CVCDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CVCDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CVCDoc commands

CString CVCDoc::PathToAuxFile(const char *auxPath)
{
	CString directory = GetPathName(), path;
	int slash = directory.ReverseFind('\\');
	CString auxStr(auxPath);

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);
	path = (auxStr[0] == '/') ? NativePath(auxStr) : (directory + "\\" + NativePath(auxStr));
	return path;
}

/////////////////////////////////////////////////////////////////////////////
CString PathSansVolume(const CString &path)
{
	CString result;
	if (path.Find(':') == 1) // strip the volume name
		result = path.Right(path.GetLength() - 2);
	else if ((path.GetLength() > 2) && (path.Left(2) == "\\\\")) {
		// a path like \\Host\path
		int slash;
		result = path.Right(path.GetLength() - 2);
		VERIFY((slash = result.Find('\\')) != -1);
		result = result.Right(result.GetLength() - slash);
	} else
		result = path;
	return result;
}

HGLOBAL CVCDoc::ReadFileIntoMemory(const char *path, int *inputLen)
{
	fpos_t inLength;
	FILE *inputFile;
	U8 *buf = NULL;

	inputFile = fopen(path, "rb");
	if (!inputFile)
		goto Error;

	fseek(inputFile, 0, SEEK_END);
	fgetpos(inputFile, &inLength);
	fseek(inputFile, 0, SEEK_SET);

	if (!(buf = (U8 *)GlobalAlloc(0, (long)inLength)))
		goto Error;

	if (fread(buf, 1, (long)inLength, inputFile) < (unsigned)inLength)
		goto Error;

	*inputLen = (int)inLength;
	goto Done;

Error:
	if (buf) { GlobalFree(buf); buf = NULL; }

Done:
	if (inputFile)
		fclose(inputFile);
	return buf;
}

/////////////////////////////////////////////////////////////////////////////
// This sets some estimated display locations for some string properties.
// The final locations can be determined only after all the properties have
// been added to the body, and that is done by AdjustDisplayLocations().
VC_DISPTEXT *DisplayInfoForProp(const char *name, VC_DISPTEXT *info)
{
    //CClientDC dc(AfxGetApp()->m_pMainWnd);
    //dc.AssertValid();
	//int ppi = GetDeviceCaps(dc.m_hDC, LOGPIXELSY);

	memset(info, 0, sizeof(*info));
	info->typeSize = smPt;
	info->textAlign = VC_LEFT;
	info->textClass = VC_MODERN;

	/****  middle right group  ****/
	if (strcmp(name, vcFullNameProp) == 0) {
		info->x = 4200;
		info->y = 2500 + (smPt * 3) * 20;
	} else if (strcmp(name, vcTitleProp) == 0) {
		info->x = 4200;
		info->y = 2500 + (smPt * 2) * 20;
		info->textAttrs = VC_ITALIC;
	} else
	/****  lower right group  ****/
	if (strcmp(name, vcTelephoneProp) == 0) {
		info->x = 4200;
		info->y = 300 + (10 * 2) * 20;
		info->typeSize = 10;
	} else if (strcmp(name, vcEmailAddressProp) == 0) {
		info->x = 4200;
		info->y = 300 + (10 * 1) * 20;
		info->typeSize = 10;
	} else
	/****  upper left group  ****/
	if (strcmp(name, vcOrgNameProp) == 0) {
		info->x = 300;
		info->y = 5000 - 300;
		info->typeSize = bgPt;
	} else
	/****  middle left group  ****/
	if (strcmp(name, vcOrgUnitProp) == 0) {
		info->x = 300;
		info->y = 2500 + (smPt * 3) * 20;
	} else if (strcmp(name, vcDeliveryLabelProp) == 0) {
		info->x = 300;
		info->y = 2500 + (smPt * 2) * 20;
	}

	return info->x ? info : NULL;
}

/////////////////////////////////////////////////////////////////////////////
// This is called as a final step in the parsing, after the entire body has
// been built.  Now that all the properties and their estimated locations are
// there, some final tweaking can be done.
void AdjustDisplayLocations(CVCNode *body)
{
	CVCPropEnumerator *enumerator;
	CVCProp *prop;
	VC_DISPGIF *gifInfo = NULL;

	// is there a logo?
	enumerator = new CVCPropEnumerator(body);
	while ((prop = enumerator->NextProp())) {
		if (strcmp(prop->GetName(), vcLogoProp) == 0) {
			CVCValue *value = prop->FindValue(VCDisplayInfoGIFType);
			if (value) {
				gifInfo = (VC_DISPGIF *)value->GetValue();
				if (gifInfo->top < 1700) {
					VC_DISPGIF dt;
					int h = gifInfo->top - gifInfo->bottom;
					dt = *gifInfo;
					dt.top = 1700;
					dt.bottom = dt.top - h;
					value->SetValue(&dt, sizeof(dt));
					gifInfo = (VC_DISPGIF *)value->GetValue();
				}
			}
			break;
		}
	} // while
	delete enumerator;

	if (!gifInfo)
		return;

	// if have a logo, move middle right group (name, title) so that its top
	// is aligned with the top of the logo and adjust the top of the photo, if any
	enumerator = new CVCPropEnumerator(body);
	while ((prop = enumerator->NextProp())) {
		if (strcmp(prop->GetName(), vcFullNameProp) == 0) {
			VC_DISPTEXT *info = (VC_DISPTEXT *)prop->FindValue(VCDisplayInfoTextType)->GetValue();
			info->y = gifInfo->top;
		} else if (strcmp(prop->GetName(), vcTitleProp) == 0) {
			VC_DISPTEXT *info = (VC_DISPTEXT *)prop->FindValue(VCDisplayInfoTextType)->GetValue();
			info->y = gifInfo->top - smPt * 20;
		} else if (strcmp(prop->GetName(), vcPhotoProp) == 0) {
			CVCValue *value = prop->FindValue(VCDisplayInfoGIFType);
			VC_DISPGIF *photoInfo;
			int h;
			if (!value) continue;
			photoInfo = (VC_DISPGIF *)value->GetValue();
			h = photoInfo->top - photoInfo->bottom;
			photoInfo->bottom = gifInfo->top + smPt * 20;
			photoInfo->top = photoInfo->bottom + h;
		}
	} // while
	delete enumerator;
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::SetDisplayInfo(CVCNode *body, const char *docPath)
{
	CVCPropEnumerator enumerator(body);
	CVCProp *prop;
	CString directory(docPath);
	int slash = directory.ReverseFind('\\');
	BOOL hasMask;
	FCOORD size;
	CGifReader gifRdr;

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);

	while ((prop = enumerator.NextProp())) {
		const char *propName = prop->GetName();
		if (strcmp(propName, vcPhotoProp) == 0) {
			CVCValue *value = prop->FindValue(VCGIFType);
			istrstream strm((char *)value->GetValue(), value->GetSize());

			if (gifRdr.GetGifSize(&strm, &size, &hasMask)) {
				/****  upper right group  ****/
				VC_DISPGIF gifInfo;
				gifInfo.left = 4200;
				gifInfo.right = gifInfo.left + (int)size.x * 20;
				gifInfo.top = 5000 - 300;
				gifInfo.bottom = gifInfo.top - (int)size.y * 20;
				gifInfo.hasMask = hasMask;
				prop->AddValue(new CVCValue(VCDisplayInfoGIFType, &gifInfo, sizeof(gifInfo)));
			}
		} else if (strcmp(propName, vcLogoProp) == 0) {
			CVCValue *value = prop->FindValue(VCGIFType);
			istrstream strm((char *)value->GetValue(), value->GetSize());

			if (gifRdr.GetGifSize(&strm, &size, &hasMask)) {
				/****  lower left group  ****/
				VC_DISPGIF gifInfo;
				gifInfo.left = 300;
				gifInfo.right = gifInfo.left + (int)size.x * 20;
				gifInfo.top = 300 + (int)size.y * 20;
				gifInfo.bottom = gifInfo.top - (int)size.y * 20;
				gifInfo.hasMask = hasMask;
				prop->AddValue(new CVCValue(VCDisplayInfoGIFType, &gifInfo, sizeof(gifInfo)));
			}
		} else {
			VC_DISPTEXT dispText;
			if (DisplayInfoForProp(propName, &dispText))
				prop->AddValue(
					new CVCValue(VCDisplayInfoTextType, &dispText, sizeof(dispText)));
		}
	}

	AdjustDisplayLocations(body);
}

#ifdef TRY_CFILE
/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	char *unknownTags = NULL;
	BOOL doPrePostamble = FALSE;
	CFile input(lpszPathName, CFile::modeRead | CFile::shareCompat);
	CString directory(lpszPathName);
	int slash = directory.ReverseFind('\\');

	//if (!CDocument::OnOpenDocument(lpszPathName))
		//return FALSE;
	
	if (m_preamble) { delete [] m_preamble; m_preamble = NULL; }
	if (m_postamble) { delete [] m_postamble; m_postamble = NULL; }
	if (m_unknownTags) { delete m_unknownTags; m_unknownTags = NULL; }
	m_preambleLen = m_postambleLen = 0;

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);

	if (Parse_MSV_FromFile(&input, &m_vcard)) {
	} else if (Parse_MIME_FromFile(&input, &m_vcard)) {
	} else
		return FALSE;

	SetDisplayInfo(m_vcard->FindBody(), lpszPathName);

	if (unknownTags) {
		if (strlen(unknownTags))
			m_unknownTags = new CString(unknownTags);
		delete [] unknownTags;
	}

	return TRUE;
}
#else
/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	int posPreambleEnd, posPostambleStart;
	char *unknownTags = NULL;
	BOOL doPrePostamble = FALSE;
	char *input = NULL;
	int inputLen;
	CString directory(lpszPathName);
	int slash = directory.ReverseFind('\\');

	//if (!CDocument::OnOpenDocument(lpszPathName))
		//return FALSE;
	
	if (!(input = (char *)ReadFileIntoMemory(lpszPathName, &inputLen)))
		return FALSE;

	if (m_preamble) { delete [] m_preamble; m_preamble = NULL; }
	if (m_postamble) { delete [] m_postamble; m_postamble = NULL; }
	if (m_unknownTags) { delete m_unknownTags; m_unknownTags = NULL; }
	m_preambleLen = m_postambleLen = 0;

	if (slash == -1)
		directory = "";
	else
		directory = directory.Left(slash);

	if (Parse_MSV(input, inputLen, &m_vcard)) {
	} else if (Parse_MIME(input, inputLen, &m_vcard)) {
	} else
		return FALSE;

	if (doPrePostamble) { // now read in and store the preamble and postamble
		if ((m_preambleLen = posPreambleEnd)) {
			m_preamble = new char[m_preambleLen];
			memcpy(m_preamble, input, m_preambleLen);
		}

		if ((m_postambleLen = inputLen - posPostambleStart)) {
			m_postamble = new char[m_postambleLen];
			memcpy(m_postamble, input + posPostambleStart, m_postambleLen);
		}
	}
	
	SetDisplayInfo(m_vcard->FindBody(), lpszPathName);

	if (unknownTags) {
		if (strlen(unknownTags))
			m_unknownTags = new CString(unknownTags);
		delete [] unknownTags;
	}

	if (input) GlobalFree(input);
	return TRUE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
BOOL CVCDoc::OnSaveDocument(LPCTSTR lpszPathName) 
{
	FILE *outputFile;
	char *tempname;
	BOOL error = FALSE;
	//int len;

	tempname = _tempnam(NULL, "CARD");
	outputFile = fopen(tempname, "w+");
#if 0
	if (m_preambleLen
		&& (fwrite(m_preamble, 1, m_preambleLen, outputFile) < (unsigned)m_preambleLen)) {
		error = TRUE;
		goto Done;
	}
#endif

	if ((error = !m_vcard->Write(outputFile)))
		goto Done;
#if 0
	if (m_unknownTags && (len = m_unknownTags->GetLength())
		&& (fwrite((const char *)*m_unknownTags, 1, len, outputFile) < (unsigned)len)) {
		error = TRUE;
		goto Done;
	}
	
	if (m_postambleLen
		&& (fwrite(m_postamble, 1, m_postambleLen, outputFile) < (unsigned)m_postambleLen)) {
		error = TRUE;
		goto Done;
	}
#endif

Done:
	fclose(outputFile);
	if (error) {
		CString msg;
		msg.Format("Could not write to file \"%s\":\n%s", tempname, strerror(errno));
		AfxMessageBox(msg);
	} else {
		unlink(lpszPathName); // remove it if it's already there
		rename(tempname, lpszPathName);
		SetModifiedFlag(FALSE);
	}
	free(tempname);
	return !error;
	// return CDocument::OnSaveDocument(lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
CString CanonicalPath(const CString &path)
{
	CString result(path);
	int len = path.GetLength();
	for (int i = 0; i < len; i++)
		if (path[i] == '\\')
			result.SetAt(i, '/');
	return result;
}

/////////////////////////////////////////////////////////////////////////////
CString NativePath(const CString &path)
{
	CString result(path);
	int len = path.GetLength();
	for (int i = 0; i < len; i++)
		if (path[i] == '/')
			result.SetAt(i, '\\');
	return result;
}


/////////////////////////////////////////////////////////////////////////////
void CVCDoc::InsertFile(const char *propName, const char *theType, const char *path)
{
	int size;
	HGLOBAL contents = ReadFileIntoMemory(path, &size);
	CVCNode *body = m_vcard->FindBody();
	CVCPropEnumerator enumerator(body);
	CVCProp *prop, *existing = NULL;

	while ((prop = enumerator.NextProp()))
		if (strcmp(prop->GetName(), propName) == 0) {
			existing = prop;
			break;
		}

	if (existing) {
		BOOL didReplace = FALSE;
		for (CLISTPOSITION pos = existing->GetValues()->GetHeadPosition(); pos; ) {
			CVCValue *value = (CVCValue *)existing->GetValues()->GetNext(pos);
			if (strcmp(value->GetType(), VCStrIdxType) == 0)
				continue;
			if (strcmp(value->GetType(), VCDisplayInfoGIFType) == 0) {
				existing->RemoveValue(value);
				continue;
			}
			if (strcmp(value->GetType(), theType) != 0)
				value->SetType(theType);
			value->SetValue(contents, size);
			didReplace = TRUE;
		}
		if (!didReplace)
			existing->AddValue(new CVCValue(theType, (void *)contents, size));
	} else {
		CVCNode *node = body->AddPart();
		node->AddProp(new CVCProp(propName, theType, (void *)contents, size));
		node->AddBoolProp(vcBase64Prop);
		node->AddBoolProp((strcmp(theType, vcGIFType) == 0) ? vcGIFProp : vcWAVEProp);
	}
	GlobalFree(contents);
	SetDisplayInfo(body, GetPathName());
	SetModifiedFlag();
	UpdateAllViews(NULL);
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnInsertLogo() 
{
	CFileDialog dialog(
		TRUE, NULL, NULL, 0,
		"Image Files (*.gif) | *.gif; | All Files (*.*) | *.* ||");

	if (dialog.DoModal() == IDOK) {
		CString ext(dialog.GetFileExt());
		InsertFile(vcLogoProp, VCGIFType, dialog.GetPathName());
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnInsertPhoto() 
{
	CFileDialog dialog(
		TRUE, NULL, NULL, 0,
		"Image Files (*.gif;) | *.gif; | All Files (*.*) | *.* ||");

	if (dialog.DoModal() == IDOK) {
		CString ext(dialog.GetFileExt());
		InsertFile(vcPhotoProp, VCGIFType, dialog.GetPathName());
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnInsertPronun() 
{
	CFileDialog dialog(
		TRUE, NULL, NULL, 0,
		"Wave Files (*.wav) | *.wav | All Files (*.*) | *.* ||");

	if (dialog.DoModal() == IDOK) {
		InsertFile(vcPronunciationProp, VCWAVType, dialog.GetPathName());
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnSendIrda() 
{
	char *tempname;
	BOOL savedFlag = IsModified();
	CString path(GetPathName()), directory, name;
	CVCNode *body = m_vcard->FindBody();
	CVCApp *app = (CVCApp *)AfxGetApp();

	if (!app->CanSendFileViaIR())
		return;
	// save the card file to a temporary location
	tempname = _tempnam(NULL, "CARD");
	OnSaveDocument(tempname);
	SetModifiedFlag(savedFlag);

	{ // get the directory containing the card file
		int slash = path.ReverseFind('\\');

		if (slash == -1) {
			directory = "";
			name = path;
		} else {
			directory = CanonicalPath(PathSansVolume(path.Left(slash)));
			name = path.Right(path.GetLength() - slash - 1);
		}
	}

	// now send the card file
	app->SendFileViaIR(tempname, name, TRUE);

	// and remove the temporary card file
	unlink(tempname);
	free(tempname);
}

/////////////////////////////////////////////////////////////////////////////
void CVCDoc::OnUpdateSendIrda(CCmdUI* pCmdUI) 
{
	CVCApp *app = (CVCApp *)AfxGetApp();
	pCmdUI->Enable(app->CanSendFileViaIR());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcir.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "vcir.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// IVCServer_IR properties

/////////////////////////////////////////////////////////////////////////////
// IVCServer_IR operations

long IVCServer_IR::SendFile(LPCTSTR path)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		path);
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcview.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCview.h : interface of the CVCView class
//
/////////////////////////////////////////////////////////////////////////////

#include <afxole.h>

class CVCCntrItem;
class CVCProp;
class CVCNode;
class CVCard;
class CVCDoc;
class CCallCenter;

typedef struct {
	CBitmap *bitmap, *mask;
	CSize devSize;
} VC_IMAGEINFO;

typedef enum {
	vc_normal, vc_text, vc_debug
} VC_VIEWSTYLE;

class CVCView : public CScrollView
{
protected: // create from serialization only
	CVCView();
	DECLARE_DYNCREATE(CVCView)

// Attributes
public:
	CVCDoc* GetDocument();

// Operations
public:
	void InitCallCenter(CCallCenter& cc);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVCView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual BOOL OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVCView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	BOOL Paste(const char *data, int dataLen);

protected:
	CString m_language; // indicates current language to display
	VC_IMAGEINFO m_photo, m_logo;
	VC_VIEWSTYLE m_viewStyle;
	CBitmapButton *m_playPronun;
	COleDropTarget m_dropTarget;

	void DrawGif(CVCProp *prop, CVCNode *body, CRect &r, CDC *pDC);
	void DrawCard(CVCard *card, CRect &r, CDC *pDC);
	void OnDrawNormal(CDC* pDC);
	CString ClipboardStringForFormat(int format);
	COleDataSource* CreateDataSourceForCopyAndDrag();

// Generated message map functions
protected:
	//{{AFX_MSG(CVCView)
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditProperties();
	afx_msg void OnViewDebug();
	afx_msg void OnViewNormal();
	afx_msg void OnViewOptions();
	afx_msg void OnViewSimplegram();
	afx_msg void OnViewText();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDebugShowCallCenter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in VCview.cpp
inline CVCDoc* CVCView::GetDocument()
   { return (CVCDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcdoc.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCdoc.h : interface of the CVCDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CVCSrvrItem;
class CVCard;
class CVCNode;

class CVCDoc : public CDocument
{
protected: // create from serialization only
	CVCDoc();
	DECLARE_DYNCREATE(CVCDoc)

// Attributes
public:
	CSize GetDocSize() { return m_sizeDoc; }
	CSize GetMinDocSize() { return m_minSizeDoc; }
	CVCard *GetVCard() { return m_vcard; }
	CString PathToAuxFile(const char *auxPath);
	void SetDisplayInfo(CVCNode *body, const char *docPath);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVCDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVCDoc();
	CSize SetDocSize(CSize &size) { CSize old = m_sizeDoc; m_sizeDoc = size; return old; }
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	HGLOBAL ReadFileIntoMemory(const char *path, int *inputLen);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	void InsertFile(const char *propName, const char *theType, const char *path);

	CSize m_sizeDoc;
	CSize m_minSizeDoc;
	CVCard *m_vcard;
	char *m_preamble, *m_postamble;
	int m_preambleLen, m_postambleLen;
	CString *m_unknownTags;

// Generated message map functions
protected:
	//{{AFX_MSG(CVCDoc)
	afx_msg void OnInsertLogo();
	afx_msg void OnInsertPhoto();
	afx_msg void OnInsertPronun();
	afx_msg void OnSendIrda();
	afx_msg void OnUpdateSendIrda(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcview.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCview.cpp : implementation of the CVCView class
//

#include "stdafx.h"
#include <mmsystem.h>
#include <fstream.h>
#include <strstrea.h>
#include "vcard.h"
#include "clist.h"
#include "VC.h"
#include "VCdoc.h"
#include "VCview.h"
#include "VCDatSrc.h"
#include "gifread.h"
#include "mainfrm.h"
#include "msv.h"
#include "mime.h"
#include "callcntr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

typedef enum {
	vc_top, vc_right, vc_bottom, vc_left
} VCsides;

#define vc_white	255
#define vc_ltgray	192
#define vc_gray		128
#define vc_dkgray	64
#define vc_black	0

static void DrawStringProp(CVCard *card, CVCProp *prop, char *prefix, CVCNode *body, CRect &r, CDC *pDC);
//static void DrawGrays(CRect &r, P_U8 sides, P_U8 grays, int len, CDC *pDC);
static void DrawText(CPoint &pt, int h, wchar_t *u, CDC *pDC);
static BOOL CacheBitmap(istream *strm, VC_IMAGEINFO *info, CDC *devDC, CDC *tempDC);

extern CPalette bubPalette;

CCallCenter *callCenter = NULL;


/////////////////////////////////////////////////////////////////////////////
// CVCView

IMPLEMENT_DYNCREATE(CVCView, CScrollView)

BEGIN_MESSAGE_MAP(CVCView, CScrollView)
	//{{AFX_MSG_MAP(CVCView)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_PROPERTIES, OnEditProperties)
	ON_COMMAND(ID_VIEW_DEBUG, OnViewDebug)
	ON_COMMAND(ID_VIEW_NORMAL, OnViewNormal)
	ON_COMMAND(ID_VIEW_OPTIONS, OnViewOptions)
	ON_COMMAND(ID_VIEW_SIMPLEGRAM, OnViewSimplegram)
	ON_COMMAND(ID_VIEW_TEXT, OnViewText)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_WM_LBUTTONDOWN()
	ON_WM_CREATE()
	ON_COMMAND(ID_DEBUG_SHOWCALLCENTER, OnDebugShowCallCenter)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVCView construction/destruction

CVCView::CVCView()
{
	m_language = vcDefaultLang;
	m_photo.bitmap = m_photo.mask = NULL;
	m_logo.bitmap = m_logo.mask = NULL;
	m_viewStyle = vc_normal;
	m_playPronun = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CVCView::~CVCView()
{
	if (m_photo.bitmap) delete m_photo.bitmap;
	if (m_photo.mask) delete m_photo.mask;
	if (m_logo.bitmap) delete m_logo.bitmap;
	if (m_logo.mask) delete m_logo.mask;
	if (m_playPronun) delete m_playPronun;
}

/////////////////////////////////////////////////////////////////////////////
// CVCView drawing

void CVCView::OnDraw(CDC* pDC)
{
	//switch (m_viewStyle) {
	//	default:
			OnDrawNormal(pDC);
	//		break;
	//}
} // OnDraw

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnDrawNormal(CDC* pDC)
{
	CVCDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CSize size = pDoc->GetDocSize();
	CRect r(0, 0, size.cx, -size.cy);
	// CRect rectClip;
	CRect cr;
	BOOL padHorz = FALSE, padVert = FALSE;
	//pDC->GetClipBox(&rectClip);
    GetClientRect(&cr);
	pDC->DPtoLP(&cr);

	if (size.cx < cr.Width()) {
		r.OffsetRect((cr.Width() - size.cx) / 2, 0);
		padHorz = TRUE;
	}
	if (size.cy < -cr.Height()) {
		r.OffsetRect(0, -(-cr.Height() - size.cy) / 2);
		padVert = TRUE;
	}

	if (padHorz || padVert) {
		CRect fr;
		CBrush brush(RGB(vc_ltgray, vc_ltgray, vc_ltgray));
		CBrush *oldBrush = pDC->SelectObject(&brush);
		if (padHorz) {
			fr.SetRect(0, 0, r.left, cr.bottom);
			pDC->FillRect(fr, &brush);
			fr.left = r.right;
			fr.right = cr.right;
			pDC->FillRect(fr, &brush);
		}
		if (padVert) {
			fr.SetRect(0, 0, cr.right, r.top);
			pDC->FillRect(fr, &brush);
			fr.top = r.bottom;
			fr.bottom = cr.bottom;
			pDC->FillRect(fr, &brush);
		}
		pDC->SelectObject(oldBrush);
	}

	{
		CRect fr;
		CBrush dkBrush(RGB(vc_dkgray, vc_dkgray, vc_dkgray));
		CBrush ltBrush(RGB(vc_ltgray, vc_ltgray, vc_ltgray));
		CBrush *oldBrush = pDC->SelectObject(&ltBrush);
		#define thick 60

		// bottom shadow -- small ltgray and long dkgray pieces
		fr.SetRect(r.left, r.bottom + thick, r.left + thick, r.bottom);
		pDC->FillRect(fr, &ltBrush);
		fr.left = fr.right;
		fr.right = r.right;
		pDC->FillRect(fr, &dkBrush);

		// right shadow -- small ltgray and long dkgray pieces
		fr.SetRect(r.right - thick, r.top, r.right, r.top - thick);
		pDC->FillRect(fr, &ltBrush);
		fr.top = fr.bottom;
		fr.bottom = r.bottom;
		pDC->FillRect(fr, &dkBrush);

		pDC->SelectObject(oldBrush);
		r.right -= thick;
		r.bottom += thick;

		// border
		CPen *oldPen, pen;
		pen.CreatePen(PS_SOLID, 20, RGB(vc_black, vc_black, vc_black));
		oldPen = pDC->SelectObject(&pen);
		pDC->Rectangle(r);
		pDC->SelectObject(oldPen);
		pen.DeleteObject();
		r.InflateRect(-20, -20);
	}
#if 0
	{
		U8 sides[] = {vc_top, vc_left,
			vc_right, vc_bottom, vc_right, vc_bottom,
			vc_top, vc_right, vc_bottom, vc_left};
		U8 grays[] = {vc_white, vc_white,
			vc_dkgray, vc_dkgray, vc_dkgray, vc_dkgray,
			vc_gray, vc_gray, vc_gray, vc_gray};
		DrawGrays(r, sides, grays, 10, pDC);
	}
#endif

	DrawCard(pDoc->GetVCard(), r, pDC);
}

/////////////////////////////////////////////////////////////////////////////
#if 0
static void DrawGrays(CRect &r, P_U8 sides, P_U8 grays, int len, CDC *pDC)
{
	CPen *oldPen = NULL;
	CPen pen;

	for (int i = 0; i < len; i++, sides++, grays++) {
		pen.CreatePen(PS_SOLID, 20, RGB(*grays, *grays, *grays));
		if (!oldPen)
			oldPen = pDC->SelectObject(&pen);
		else
			pDC->SelectObject(&pen);
		switch (*sides) {
			case vc_top:
				pDC->MoveTo(r.left, r.top);
				pDC->LineTo(r.right + 1, r.top);
				r.top += 20;
				break;
			case vc_right:
				pDC->MoveTo(r.right, r.top);
				pDC->LineTo(r.right, r.bottom + 1);
				r.right -= 20;
				break;
			case vc_bottom:
				pDC->MoveTo(r.right, r.bottom);
				pDC->LineTo(r.left - 1, r.bottom);
				r.bottom -= 20;
				break;
			default: // vc_left
				pDC->MoveTo(r.left, r.bottom);
				pDC->LineTo(r.left, r.top - 1);
				r.left += 20;
				break;
		}
		pDC->SelectObject(oldPen);
		pen.DeleteObject();
	}
}
#endif

/////////////////////////////////////////////////////////////////////////////
void CVCView::DrawCard(CVCard *card, CRect &r, CDC *pDC)
{
	CVCNode *root, *english, *node;
	CVCProp *prop;
	CVCPropEnumerator *enumerator;
	BOOL haveLogo = FALSE;
	int nTels = 0, nEmails = 0;
	BOOL havePrefTel = FALSE, havePrefEmail = FALSE;
	BOOL haveDrawnTel = FALSE, haveDrawnEmail = FALSE;
	CVCValue *fullNameDispInfVal = NULL;

	if (!card) return;
	// get the first root object
	root = (CVCNode *)card->GetObjects()->GetHead();

	// get the first body prop (english)
	english = (CVCNode *)root->GetProp(vcBodyProp)->FindValue(
		VCNextObjectType)->GetValue();

	enumerator = new CVCPropEnumerator(english);
	while ((prop = enumerator->NextProp(&node))) {
		if ((strcmp(prop->GetName(), vcPhotoProp) == 0)
			&& prop->FindValue(VCDisplayInfoGIFType))
			DrawGif(prop, english, r, pDC);
		else if ((strcmp(prop->GetName(), vcLogoProp) == 0)
			&& prop->FindValue(VCDisplayInfoGIFType)) {
			DrawGif(prop, english, r, pDC);
			haveLogo = TRUE;
		} else if (strcmp(prop->GetName(), vcTelephoneProp) == 0) {
			havePrefTel |= (card->GetInheritedProp(node, vcPreferredProp) != NULL);
			nTels++;
		} else if (strcmp(prop->GetName(), vcEmailAddressProp) == 0) {
			havePrefEmail |= (card->GetInheritedProp(node, vcPreferredProp) != NULL);
			nEmails++;
		} else if (strcmp(prop->GetName(), vcFullNameProp) == 0) {
			fullNameDispInfVal = prop->FindValue(VCDisplayInfoTextType);
		}
	}
	delete enumerator;

	if (!haveLogo) { // try to find the default logo file and cache its bitmap
		if (!m_logo.bitmap) { // need to cache
			char buf[FILENAME_MAX];
			char *filePart;
		    if (SearchPath(
			    NULL, "DEFAULT.GIF", NULL, FILENAME_MAX, buf, &filePart) != 0) {
				CDC tempDC;
				CClientDC devDC(this);
				ifstream strm(buf, ios::in | ios::nocreate | ios::binary);
				tempDC.CreateCompatibleDC(&devDC);
				(void)CacheBitmap(&strm, &m_logo, &devDC, &tempDC);
				// if that failed, m_logo.bitmap would still be NULL
			}
		}
		if (m_logo.bitmap) { // it's cached, so fake a prop so that we can use DrawGif
			VC_DISPGIF gifInfo;
			gifInfo.left = 300;
			gifInfo.right = gifInfo.left + m_logo.devSize.cx * 20;
			gifInfo.top = 300 + m_logo.devSize.cy * 20;
			gifInfo.bottom = gifInfo.top - m_logo.devSize.cy * 20;
			gifInfo.hasMask = (m_logo.mask != NULL);
			prop = new CVCProp(vcLogoProp, VCDisplayInfoGIFType, &gifInfo, sizeof(gifInfo));
			DrawGif(prop, english, r, pDC);
			delete prop;
		}
	}

	enumerator = new CVCPropEnumerator(english);
	while ((prop = enumerator->NextProp(&node))) {
		if ((strcmp(prop->GetName(), vcPhotoProp) == 0)
			|| (strcmp(prop->GetName(), vcLogoProp) == 0))
			continue;
		else if ((strcmp(prop->GetName(), vcPronunciationProp) == 0)
			&& prop->FindValue(VCWAVType)) {
			CRect wr(0, 0, 0, 0);
			CPoint pt;
			BOOL needUpdate = FALSE;
			if (!m_playPronun) {
				m_playPronun = new CBitmapButton();
				m_playPronun->Create(
					NULL, BS_OWNERDRAW | BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE,
					wr, this, VC_PLAY_BUTTON_ID);
				m_playPronun->LoadBitmaps(IDB_PRONUN_U, IDB_PRONUN_D);
				m_playPronun->SizeToContent();
				needUpdate = TRUE;
			}
			m_playPronun->GetWindowRect(&wr);
			if (fullNameDispInfVal) {
				VC_DISPTEXT *dispText = (VC_DISPTEXT *)fullNameDispInfVal->GetValue();
				pt.x = 7700 + r.left;
				pt.y = dispText->y + r.bottom;
			} else {
				pt.x = 7000 + r.left;
				pt.y = 2000 + r.bottom;
			}
			pDC->LPtoDP(&pt);
			wr.OffsetRect(pt.x - wr.left, pt.y - wr.top);
			m_playPronun->SetWindowPos(
				NULL, wr.left, wr.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
			if (needUpdate)
				m_playPronun->Invalidate();
		} else if (strcmp(prop->GetName(), vcTelephoneProp) == 0) {
			if (!haveDrawnTel) {
				if (havePrefTel) {
					if (card->GetInheritedProp(node, vcPreferredProp)) {
						DrawStringProp(card, prop, NULL, english, r, pDC);
						haveDrawnTel = TRUE;
					}
				} else {
					DrawStringProp(card, prop, NULL, english, r, pDC);
					haveDrawnTel = TRUE;
				}
			}
		} else if (strcmp(prop->GetName(), vcEmailAddressProp) == 0) {
			if (!haveDrawnEmail) {
				CList plist;
				char prefix[40];
				card->GetPropsInEffect(node, &plist);
				CString email = FirstEmailPropStr(&plist);
				prefix[0] = 0;
				if (!email.IsEmpty()) {
					strcpy(prefix, email);
					strcat(prefix, ":");
				}
				if (havePrefEmail) {
					if (card->GetInheritedProp(node, vcPreferredProp)) {
						DrawStringProp(card, prop, prefix, english, r, pDC);
						haveDrawnEmail = TRUE;
					}
				} else {
					DrawStringProp(card, prop, prefix, english, r, pDC);
					haveDrawnEmail = TRUE;
				}
			}
		} else if (prop->FindValue(VCStrIdxType))
			DrawStringProp(card, prop, NULL, english, r, pDC);
	}
	delete enumerator;
}

/////////////////////////////////////////////////////////////////////////////
static void RemoveMatchingLine(wchar_t *text, wchar_t *pat)
{
	int lenText = wcslen(text);
	int lenPat = wcslen(pat);
	wchar_t *sub = wcsstr(text, pat);
	if (!sub)
		return;

	BOOL atSOL = (sub == text) || (*(sub - 1) == 0x2028);
	int patStart = sub - text;
	wchar_t ch = *(text + patStart + lenPat);
	BOOL atEOL = (ch == 0x2028) || (ch == 0);

	if (atSOL && atEOL) {
		if ((sub == text) && (patStart + lenPat == lenText))
			*text = 0;
		else if (sub == text) // remove first line
			memmove(text, text + lenPat + 1, 
				(size_t)(lenText - lenPat) * sizeof(wchar_t));
		else if (patStart + lenPat == lenText) // remove last line
			*(text + patStart - 1) = 0;
		else
			memmove(text + patStart, text + patStart + lenPat + 1,
				(size_t)(lenText - (patStart + lenPat)) * sizeof(wchar_t));
	}
}

/////////////////////////////////////////////////////////////////////////////
static void DrawStringProp(CVCard *card, CVCProp *prop, char *prefix, CVCNode *body, CRect &r, CDC *pDC)
{
	CVCValue *dispInfoVal = prop->FindValue(VCDisplayInfoTextType);
	VC_DISPTEXT *dispText = dispInfoVal ? (VC_DISPTEXT *)dispInfoVal->GetValue() : NULL;
	if (!dispText)
		return;
	wchar_t *text = (wchar_t *)prop->FindValue(VCStrIdxType)->GetValue();
	int height = dispText->typeSize * 20;
	//int height = MulDiv(
	//	dispText->typeSize * 20, GetDeviceCaps(pDC->m_hDC, LOGPIXELSY), 72);
	CFont font, *oldFont;
	CPoint pt;
	wchar_t *textCopy = NULL;
	BOOL willDrawOrgUnit = FALSE, willDrawLogo = FALSE, draw = TRUE;
	int nameOrTitleY = 0;
	CVCProp *dom = NULL, *intl = NULL;

	// if this is a postal label, filter out any lines that
	// would duplicate other props.
	if (strcmp(prop->GetName(), vcDeliveryLabelProp) == 0) {
		CVCPropEnumerator enumerator = CVCPropEnumerator(body);
		CVCProp *p;
		CVCNode *node;
		
		textCopy = new wchar_t[wcslen(text)+1];
		wcscpy(textCopy, text);
		text = textCopy;

		while ((p = enumerator.NextProp(&node))) {
			if (strcmp(p->GetName(), vcFullNameProp) == 0) {
				wchar_t *fullName = (wchar_t *)p->FindValue(VCStrIdxType)->GetValue();
				VC_DISPTEXT *dt = (VC_DISPTEXT *)p->FindValue(VCDisplayInfoTextType)->GetValue();
				RemoveMatchingLine(text, fullName);
				if (wcslen(fullName) > 0)
					nameOrTitleY = dt->y;
			} else if (strcmp(p->GetName(), vcTitleProp) == 0) {
				wchar_t *title = (wchar_t *)p->FindValue(VCStrIdxType)->GetValue();
				VC_DISPTEXT *dt = (VC_DISPTEXT *)p->FindValue(VCDisplayInfoTextType)->GetValue();
				if ((wcslen(title) > 0) && !nameOrTitleY)
					nameOrTitleY = dt->y;
			} else if (strcmp(p->GetName(), vcOrgNameProp) == 0) {
				RemoveMatchingLine(text, (wchar_t *)p->FindValue(VCStrIdxType)->GetValue());
			} else if (strcmp(p->GetName(), vcOrgUnitProp) == 0) {
				wchar_t *orgUnit = (wchar_t *)p->FindValue(VCStrIdxType)->GetValue();
				RemoveMatchingLine(text, orgUnit);
				willDrawOrgUnit = wcslen(orgUnit) > 0;
			} else if (strcmp(p->GetName(), vcLogoProp) == 0) {
				willDrawLogo = TRUE;
			} else if (strcmp(p->GetName(), vcDeliveryLabelProp) == 0) {
				if (card->GetInheritedProp(node, vcDomesticProp)) {
					if (!dom)
						dom = p;
				} else if (!intl)
					intl = p;
			}
		} // while
		if (intl)
			draw = intl == prop;
		else
			draw = dom == prop;
	} else if (prefix) {
		int size;
		wchar_t *uniValue = FakeUnicode(prefix, &size);

		textCopy = new wchar_t[wcslen(text) + wcslen(uniValue) + 1];
		wcscpy(textCopy, uniValue);
		wcscat(textCopy, text);
		text = textCopy;
		delete [] uniValue;
	}

	if (!draw)
		goto Done;
	// set up the font.  The stuff that's way indented we probably don't
	// need to muck with.  The key items are indented just one level.
	font.CreateFont(
		height,
					0, 0, 0,
		/*weight*/ dispText->textAttrs & VC_BOLD ? FW_BOLD : FW_NORMAL,
		/*italic*/ dispText->textAttrs & VC_ITALIC,
		/*underline*/ FALSE,
		/*strikeout*/ FALSE,
					ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
					DRAFT_QUALITY, FF_DONTCARE | DEFAULT_PITCH,
		(dispText->textClass == VC_CLASSIC) ? "Times Roman" : "Helvetica");
	oldFont = pDC->SelectObject(&font);
	pt.x = dispText->x + r.left;
	pt.y = dispText->y + r.bottom;
	if (!willDrawOrgUnit && !willDrawLogo && (nameOrTitleY != 0))
		pt.y = nameOrTitleY + r.bottom;
	DrawText(pt, height, text, pDC);
	pDC->SelectObject(oldFont);

Done:
	if (textCopy) delete [] textCopy;
}

/////////////////////////////////////////////////////////////////////////////
static void DrawText(CPoint &pt, int h, wchar_t *u, CDC *pDC)
{
	int n = wcslen(u), i, numThis;
	char *c;
	wchar_t *curU, *endU;

	if (!n) return;
	c = new char[n];

    for (i = 0; i < n; i++)
        c[i] = (char)(S16)u[i];

	curU = u;
	do {
		endU = curU;
		while (*endU && (*endU != 0x2028) && (*endU != 0x2029))
			endU++;
		numThis = endU - curU;
		if (numThis) {
	        if (pDC->TextOut(pt.x, pt.y, c + (curU - u), numThis) == 0)
	            AfxMessageBox("TextOut failed");
		}
		pt.y -= h;
		if (*endU) // must have hit a line break
			curU = endU + 1;
		else
			break;
	} while (TRUE);

	delete [] c;
}

static BOOL CacheBitmap(istream *strm, VC_IMAGEINFO *info, CDC *devDC, CDC *tempDC)
{
	BOOL hasMask;
	FCOORD size;
	CGifReader gifRdr;

	if (!gifRdr.GetGifSize(strm, &size, &hasMask))
		return FALSE;

	strm->clear();
	strm->seekg(0);
	info->devSize.cx = (int)size.x;
	info->devSize.cy = (int)size.y;
	if (hasMask) {
		CDC *maskDC = new CDC;
		maskDC->CreateCompatibleDC(devDC);
    	info->bitmap = new CBitmap;
    	info->mask = new CBitmap;
    	info->bitmap->CreateCompatibleBitmap(devDC, info->devSize.cx, info->devSize.cy);
    	info->mask->CreateBitmap(info->devSize.cx, info->devSize.cy, 1, 1, NULL);
		tempDC->SelectObject(info->bitmap);
		maskDC->SelectObject(info->mask);
		gifRdr.ReadGif(strm, tempDC, maskDC);
		delete maskDC;			
	} else {
    	info->bitmap = new CBitmap;
    	info->bitmap->CreateCompatibleBitmap(devDC, info->devSize.cx, info->devSize.cy);
		tempDC->SelectObject(info->bitmap);
		gifRdr.ReadGif(strm, tempDC, NULL);
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::DrawGif(CVCProp *prop, CVCNode *body, CRect &r, CDC *pDC)
{
	CVCValue *value = prop->FindValue(VCDisplayInfoGIFType);
	VC_DISPGIF *gifInfo = value ? (VC_DISPGIF *)value->GetValue() : NULL;
	VC_IMAGEINFO *info =
		(strcmp(prop->GetName(), vcPhotoProp) == 0) ? &m_photo : &m_logo;
	CDC tempDC;
	CClientDC devDC(this);
	CPoint devPt;

	if (!gifInfo) return;
	devPt.x = gifInfo->left + r.left;
	devPt.y = gifInfo->top + r.bottom;
	
	pDC->LPtoDP(&devPt);
	devDC.AssertValid();
	//pDC = &devDC;
	tempDC.CreateCompatibleDC(&devDC);

	// If we haven't yet cached the bitmap and mask, do so.
	if (!info->bitmap) {
		CVCValue *value = prop->FindValue(VCGIFType);
		istrstream strm((char *)value->GetValue(), value->GetSize());
		if (!CacheBitmap(&strm, info, &devDC, &tempDC))
			return;
	}

	// Now do the blitting.
	if (info->mask) {
		tempDC.SelectObject(info->mask);
    	pDC->BitBlt(
    		devPt.x, devPt.y,
    		info->devSize.cx, info->devSize.cy, &tempDC, 0, 0, SRCAND);
		tempDC.SelectObject(info->bitmap);
    	pDC->BitBlt(
    		devPt.x, devPt.y,
    		info->devSize.cx, info->devSize.cy, &tempDC, 0, 0, SRCPAINT);
	} else {
		tempDC.SelectObject(info->bitmap);
    	devDC.BitBlt(
    		devPt.x, devPt.y,
    		info->devSize.cx, info->devSize.cy, &tempDC, 0, 0, SRCCOPY);
#if 0
		CRect fr(0, 0, 1000, -1000);
		CBrush brush(RGB(vc_ltgray, vc_ltgray, vc_ltgray));
		CBrush *oldBrush = pDC->SelectObject(&brush);
		fr.OffsetRect(gifInfo->left + r.left, gifInfo->top + r.bottom);
		pDC->FillRect(fr, &brush);
		pDC->SelectObject(oldBrush);
#endif
	}
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnInitialUpdate()
{
	CRect cr;
	CSize pageSize;
	GetClientRect(&cr);
	pageSize.cx = MulDiv(cr.Width() * 20, 9, 10);
	pageSize.cy = MulDiv(cr.Height() * 20, 9, 10);

	SetScrollSizes(MM_TWIPS, GetDocument()->GetDocSize(), pageSize);
	//GetParentFrame()->RecalcLayout();
	//ResizeParentToFit();
}

/////////////////////////////////////////////////////////////////////////////
// CVCView printing

BOOL CVCView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CVCView diagnostics

#ifdef _DEBUG
void CVCView::AssertValid() const
{
	CScrollView::AssertValid();
}

void CVCView::Dump(CDumpContext& dc) const
{
	CScrollView::Dump(dc);
}

CVCDoc* CVCView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CVCDoc)));
	return (CVCDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CVCView message handlers

COleDataSource* CVCView::CreateDataSourceForCopyAndDrag()
{
	CVCDoc *doc = GetDocument();
	CVCDataSource *dataSource = new CVCDataSource(doc);

	dataSource->DelayRenderData(CF_TEXT);
	dataSource->DelayRenderData(cf_eCard);
	return dataSource;
} // CreateDataSourceForCopyAndDrag

void CVCView::OnEditCopy() 
{
	COleDataSource *dataSource = CreateDataSourceForCopyAndDrag();
	if (dataSource)
		dataSource->SetClipboard(); // dataSource now owned by clipboard
}

/////////////////////////////////////////////////////////////////////////////
// Helper for paste
CString CVCView::ClipboardStringForFormat(int format)
{
 	COleDataObject clipboardData;
	FORMATETC  formatEtc;
	STGMEDIUM  data;
	CString result("");
	BOOL found = FALSE;

	clipboardData.AttachClipboard();
	clipboardData.BeginEnumFormats();

    while (!found && clipboardData.GetNextFormat(&formatEtc)) {
		if ((formatEtc.cfFormat == format)
			&& (formatEtc.tymed & (TYMED_HGLOBAL | TYMED_ISTREAM)))
		  	found = clipboardData.GetData(format, &data, &formatEtc);
    }

	if (!found)
		return result;

	switch (data.tymed) {
		case TYMED_HGLOBAL: {
			const char *chars = (const char *)GlobalLock(data.hGlobal);
			ASSERT(chars);
			result = CString(chars, GlobalSize(data.hGlobal));
			GlobalUnlock(data.hGlobal);
			break;
		}

		case TYMED_ISTREAM: {
			char *buf = new char[1024], *nullByte;
			ULONG len = 0, maxLen = 1024, count, countRead;
			HRESULT hResult;
			LARGE_INTEGER pos = {0};
			data.pstm->Seek(pos, STREAM_SEEK_SET, NULL);
			do {
				count = maxLen - len;
				if (!count) {
					maxLen += 1024;
					char *newBuf = new char[maxLen];
					memcpy(newBuf, buf, len);
					delete [] buf;
					buf = newBuf;
					count = maxLen - len;
				}
				hResult = data.pstm->Read(buf + len, count, &countRead);
				// It's possible for there to be a null char in that data,
				// in which case we want to end the string there.
				if ((nullByte = (char *)memchr(buf + len, 0, countRead)) != NULL)
					countRead = nullByte - (buf + len);
				len += countRead;
			} while (countRead);
			result = CString(buf, len);
			delete [] buf;
			break;
		} // TYMED_ISTREAM

		default: break;
	} // switch

	ReleaseStgMedium(&data);

	return result;
}

/////////////////////////////////////////////////////////////////////////////
CStringArray* ComponentsSeparatedByString(
	const CString &str, const char *pat)
{
	CStringArray *array = new CStringArray;
	CString remain(str);
	CString patStr(pat);
	int lenPat = patStr.GetLength(), patStart;
	
	while ((patStart = remain.Find(patStr)) != -1) {
		array->Add(remain.Left(patStart));
		remain = remain.Right(remain.GetLength() - patStart - lenPat);
	}
	array->Add(remain);
	return array;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVCView::Paste(const char *data, int dataLen)
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CVCard *tempCard;
	BOOL success = FALSE;

	if (Parse_MSV(data, dataLen, &tempCard)
		|| Parse_MIME(data, dataLen, &tempCard)) { // success!
		// first copy most of the props from tempCard onto body.
		CList *bodyProps = tempCard->FindBody()->GetProps();
		body->RemoveProp(vcLanguageProp);
		for (CLISTPOSITION pos = bodyProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)bodyProps->GetNext(pos);
			if (strcmp(prop->GetName(), VCBodyObject) == 0)
				continue;
			body->AddProp((CVCProp *)prop->Copy());
		}
		delete tempCard;

		// now add display info
		CVCPropEnumerator *enumerator;
		CVCProp *prop;
		enumerator = new CVCPropEnumerator(body);
		while ((prop = enumerator->NextProp())) {
			VC_DISPTEXT dispText;
			if (DisplayInfoForProp(prop->GetName(), &dispText))
				prop->AddValue(new CVCValue(VCDisplayInfoTextType, &dispText, sizeof(dispText)));
		}
		delete enumerator;
		success = TRUE;
	}
	doc->SetModifiedFlag();
	doc->SetDisplayInfo(body, doc->GetPathName());
	doc->UpdateAllViews(NULL);
	return success;
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnEditPaste() 
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CList *props = body->GetProps();
	CString data = ClipboardStringForFormat(CF_TEXT);

	if (data.IsEmpty())
		return;

	// If our doc's body has more than two props (VCBodyObject and vcLanguageProp),
	// it's not empty and so we shouldn't paste into it.  Instead, have the
	// app create a new doc/view and do the paste into that.
	if (props->GetCount() > 2) {
		CVCApp *app = (CVCApp *)AfxGetApp();
		CMainFrame *mainFrame = (CMainFrame *)app->GetMainWnd();
		//CView *view;
		mainFrame->SendMessage(WM_COMMAND, ID_FILE_NEW);
		//view = mainFrame->MDIGetActive()->GetActiveView();
		mainFrame->SendMessage(WM_COMMAND, ID_EDIT_PASTE);
		return;
	}

	// Here, we know our document is "empty", and so we want to paste
	// the properties into "body".
	Paste(data, data.GetLength());
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(TRUE);
}

void CVCView::OnViewDebug() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewNormal() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewOptions() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewSimplegram() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnViewText() 
{
	// TODO: Add your command handler code here
	
}

void CVCView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo) 
{
	CRect cr;
	CSize pageSize;
	GetClientRect(&cr);
	pageSize.cx = MulDiv(cr.Width() * 20, 9, 10);
	pageSize.cy = MulDiv(cr.Height() * 20, 9, 10);

	// On creation of second maximized view on Win95, OnInitialUpdate
	// isn't called before OnPaint(), so it crashes.  Ensure coord
	// system is set up by adding SetScrollSizes here.
	SetScrollSizes(MM_TWIPS, GetDocument()->GetDocSize(), pageSize);
	CScrollView::OnPrepareDC(pDC, pInfo);
	//GetClientRect(&cr);
	//pDC->SetViewportOrg(0, cr.Height());
}

// Simple-minded conversion from UNICODE to char string
char *UI_CString(const wchar_t *u, char *dst)
{
	char *str = dst;
	while (*u) {
		if (*u == 0x2028) {
			*dst++ = '\r';
			*dst++ = '\n';
			u++;
		} else
			*dst++ = (char)*u++;
	}
	*dst = '\000';
	return str;
}


void CVCView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView) 
{
    if (bActivate && (pActivateView == this)) {
	    CClientDC dc(this);
	    dc.AssertValid();
	    OnPrepareDC(&dc);

	    if(dc.GetDeviceCaps(BITSPIXEL) == 8) {
	    	// set up our palette
			if (!UnrealizeObject(bubPalette.m_hObject))
				TRACE0("UnrealizeObject failed\n");
		    dc.SelectPalette( &bubPalette, 0 );
	    	dc.RealizePalette();
	    }
	}
	
	CScrollView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

BOOL CVCView::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	if (wParam == VC_PLAY_BUTTON_ID) {
		CVCDoc *doc = GetDocument();
		CVCard *cards = doc->GetVCard();
		CVCNode *body = cards->FindBody(m_language);
		CVCPropEnumerator *enumerator = new CVCPropEnumerator(body);
		CVCProp *prop;

		while ((prop = enumerator->NextProp())) {
			CVCValue *value;
			if ((strcmp(prop->GetName(), vcPronunciationProp) == 0)
				&& (value = prop->FindValue(VCWAVType))) {
				PlaySound((LPCSTR)value->GetValue(), NULL, SND_MEMORY | SND_ASYNC | SND_NOWAIT);
				break;
			}
		}
		delete enumerator;
	}

	return CScrollView::OnCommand(wParam, lParam);
}

void CVCView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	CScrollView::OnUpdate(pSender, lHint, pHint);

	if (m_photo.bitmap) { delete m_photo.bitmap; m_photo.bitmap = NULL; }
	if (m_photo.mask) { delete m_photo.mask; m_photo.mask = NULL; }
	if (m_logo.bitmap) { delete m_logo.bitmap; m_logo.bitmap = NULL; }
	if (m_logo.mask) { delete m_logo.mask; m_logo.mask = NULL; }
	if (m_playPronun) { delete m_playPronun; m_playPronun = NULL; }
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnLButtonDown(UINT nFlags, CPoint point) 
{
	COleDataSource *dataSource = CreateDataSourceForCopyAndDrag();
	CRect r(point, point);

	ClientToScreen(&r);
	r.InflateRect(4, 4);
	dataSource->DoDragDrop(DROPEFFECT_COPY, &r);
	delete dataSource;
}

int CVCView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CScrollView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// TODO: Add your specialized creation code here
	
	m_dropTarget.Register(this);

	return 0;
}

DROPEFFECT CVCView::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) 
{
	return OnDragOver(pDataObject, dwKeyState, point);
}

DROPEFFECT CVCView::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point) 
{
	DROPEFFECT de;

	if ((dwKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
		de = DROPEFFECT_LINK;
	else if ((dwKeyState & MK_CONTROL) == MK_CONTROL)
		de = DROPEFFECT_COPY;
	// check for force move
	else if ((dwKeyState & MK_ALT) == MK_ALT)
		de = DROPEFFECT_MOVE;
	// default -- recommended action is copy
	else
		de = DROPEFFECT_COPY;

	if (de == DROPEFFECT_COPY) {
		if (!pDataObject->IsDataAvailable(CF_TEXT)
			&& !pDataObject->IsDataAvailable(cf_eCard))
			return DROPEFFECT_NONE;
		return de;
	} else
		return DROPEFFECT_NONE;
}

BOOL CVCView::OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point) 
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CList *props = body->GetProps();
	HGLOBAL data;
	char *chars;
	BOOL success;

	if ((data = pDataObject->GetGlobalData(cf_eCard)) == NULL)
		data = pDataObject->GetGlobalData(CF_TEXT);
	if (!data)
		return FALSE;

	// If our doc's body has more than two props (VCBodyObject and vcLanguageProp),
	// it's not empty and so we shouldn't paste into it.  Instead, have the
	// app create a new doc/view and do the paste into that.
	if (props->GetCount() > 2) {
		CVCApp *app = (CVCApp *)AfxGetApp();
		CMainFrame *mainFrame = (CMainFrame *)app->GetMainWnd();
		CVCView *view;

		mainFrame->SendMessage(WM_COMMAND, ID_FILE_NEW);
		view = (CVCView *)mainFrame->MDIGetActive()->GetActiveView();
		chars = (char *)GlobalLock(data);
		ASSERT(chars);
		success = view->Paste(chars, GlobalSize(data));
		GlobalUnlock(data);
		GlobalFree(data);
		return success;
	}

	// Here, we know our document is "empty", and so we want to paste
	// the properties into "body".
	chars = (char *)GlobalLock(data);
	ASSERT(chars);
	success = Paste(chars, GlobalSize(data));
	GlobalUnlock(data);
	GlobalFree(data);
	return success;
}

void CVCView::InitCallCenter(CCallCenter& cc)
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CVCPropEnumerator enumerator(body);
	CVCNode *node;
	CVCProp *prop;
	char buf[1024];

	while ((prop = enumerator.NextProp(&node))) {
		const char *propName = prop->GetName();
		if (strcmp(propName, vcCityProp) == 0)
			cc.m_addrCity = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcRegionProp) == 0)
			cc.m_addrState = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcStreetAddressProp) == 0)
			cc.m_addrStreet = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcPostalCodeProp) == 0)
			cc.m_addrZip = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcOrgNameProp) == 0)
			cc.m_employer = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcGivenNameProp) == 0)
			cc.m_firstName = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcFamilyNameProp) == 0)
			cc.m_lastName = UI_CString(
				(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
		else if (strcmp(propName, vcTelephoneProp) == 0) {
			CList plist;
			cards->GetPropsInEffect(node, &plist);
			if (plist.Search(VCMatchProp, (void *)vcFaxProp)) {
				if (cc.m_telFax.IsEmpty())
					cc.m_telFax = UI_CString(
						(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
			}
			if (plist.Search(VCMatchProp, (void *)vcHomeProp)) {
				if (cc.m_telHome.IsEmpty())
					cc.m_telHome = UI_CString(
						(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
			}
			if (plist.Search(VCMatchProp, (void *)vcWorkProp)) {
				if (cc.m_telWork.IsEmpty())
					cc.m_telWork = UI_CString(
						(wchar_t *)prop->FindValue(vcStrIdxType)->GetValue(), buf);
			}
		}
	}

	cc.m_callerID = "Versitcard";
}

void CVCView::OnDebugShowCallCenter() 
{
	CCallCenter cc;

	InitCallCenter(cc);
	callCenter = &cc;
	cc.DoModal();
	callCenter = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcviewer.h ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCViewer.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// VCViewer command target

class VCViewer : public CCmdTarget
{
	DECLARE_DYNCREATE(VCViewer)

	VCViewer();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(VCViewer)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~VCViewer();

	// Generated message map functions
	//{{AFX_MSG(VCViewer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE(VCViewer)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(VCViewer)
	afx_msg long ReceiveCard(LPCTSTR nativePath);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\vcviewer.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

// VCViewer.cpp : implementation file
//

#include "stdafx.h"
#include "VC.h"
#include "VCViewer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// VCViewer

IMPLEMENT_DYNCREATE(VCViewer, CCmdTarget)

VCViewer::VCViewer()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

VCViewer::~VCViewer()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}


void VCViewer::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(VCViewer, CCmdTarget)
	//{{AFX_MSG_MAP(VCViewer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(VCViewer, CCmdTarget)
	//{{AFX_DISPATCH_MAP(VCViewer)
	DISP_FUNCTION(VCViewer, "ReceiveCard", ReceiveCard, VT_I4, VTS_BSTR)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IVCViewer to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {128D0C5F-2A69-11CF-8F1F-B06E03C10000}
static const IID IID_IVCViewer =
{ 0x128d0c5f, 0x2a69, 0x11cf, { 0x8f, 0x1f, 0xb0, 0x6e, 0x3, 0xc1, 0x0, 0x0 } };

BEGIN_INTERFACE_MAP(VCViewer, CCmdTarget)
	INTERFACE_PART(VCViewer, IID_IVCViewer, Dispatch)
END_INTERFACE_MAP()

// {128D0C60-2A69-11CF-8F1F-B06E03C10000}
IMPLEMENT_OLECREATE(VCViewer, "VC.VCVIEWER", 0x128d0c60, 0x2a69, 0x11cf, 0x8f, 0x1f, 0xb0, 0x6e, 0x3, 0xc1, 0x0, 0x0)

/////////////////////////////////////////////////////////////////////////////
// VCViewer message handlers

long VCViewer::ReceiveCard(LPCTSTR nativePath) 
{
	CVCApp *app = (CVCApp *)AfxGetApp();

	return app->ReceiveCard(nativePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\viewprop.cpp ===
/***************************************************************************
(C) Copyright 1996 Apple Computer, Inc., AT&T Corp., International             
Business Machines Corporation and Siemens Rolm Communications Inc.             
                                                                               
For purposes of this license notice, the term Licensors shall mean,            
collectively, Apple Computer, Inc., AT&T Corp., International                  
Business Machines Corporation and Siemens Rolm Communications Inc.             
The term Licensor shall mean any of the Licensors.                             
                                                                               
Subject to acceptance of the following conditions, permission is hereby        
granted by Licensors without the need for written agreement and without        
license or royalty fees, to use, copy, modify and distribute this              
software for any purpose.                                                      
                                                                               
The above copyright notice and the following four paragraphs must be           
reproduced in all copies of this software and any software including           
this software.                                                                 
                                                                               
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS AND NO LICENSOR SHALL HAVE       
ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS OR       
MODIFICATIONS.                                                                 
                                                                               
IN NO EVENT SHALL ANY LICENSOR BE LIABLE TO ANY PARTY FOR DIRECT,              
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOST PROFITS ARISING OUT         
OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         
DAMAGE.                                                                        
                                                                               
EACH LICENSOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED,       
INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF NONINFRINGEMENT OR THE            
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR             
PURPOSE.                                                                       

The software is provided with RESTRICTED RIGHTS.  Use, duplication, or         
disclosure by the government are subject to restrictions set forth in          
DFARS 252.227-7013 or 48 CFR 52.227-19, as applicable.                         

***************************************************************************/

#include "stdafx.h"
#include "vcard.h"
#include "clist.h"
#include "vc.h"
#include "vcview.h"
#include "vcdoc.h"
#include "prp_pers.h"
#include "prp_comp.h"
#include "propemal.h"
#include "proplocb.h"
#include "proplocx.h"
#include "proptel.h"
#include "msv.h"

CM_CFUNCTION
extern CVCNode* FindOrCreatePart(CVCNode *node, const char *name);
CM_END_CFUNCTION

static const char* emailProps[] = {
	vcAOLProp,
	vcAppleLinkProp,
	vcATTMailProp,
	vcCISProp,
	vcEWorldProp,
	vcInternetProp,
	vcIBMMailProp,
	vcMSNProp,
	vcMCIMailProp,
	vcPowerShareProp,
	vcProdigyProp,
	vcTLXProp,
	vcX400Prop,
	NULL
};

static char nameGen[4];


/////////////////////////////////////////////////////////////////////////////
// This uses a deep prop enumerator to find the relevant props, because
// they could be legitimately attached to either the body itself or
// a body part object.  There would only ever be one instance of any
// of these props on a given body.
void InitNamePage(CPropPers &propPageName, CVCNode *body, CVCard *card)
{
	char buf[1024];
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;
	CVCValue *value;

	while ((prop = enumerator.NextProp(&node))) {

		if (strcmp(prop->GetName(), vcFamilyNameProp) == 0) {
			propPageName.m_edit_famname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageName.m_nodeName = node;
		} else if (strcmp(prop->GetName(), vcFullNameProp) == 0) {
			propPageName.m_edit_fullname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageName.m_nodeFullName = node;
		} else if (strcmp(prop->GetName(), vcGivenNameProp) == 0) {
			propPageName.m_edit_givenname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageName.m_nodeName = node;
		} else if (strcmp(prop->GetName(), vcPronunciationProp) == 0) {
			if ((value = prop->FindValue(VCStrIdxType))) {
				propPageName.m_edit_pronun = UI_CString(
					(wchar_t *)value->GetValue(), buf);
				propPageName.m_nodePronun = node;
			}
		}
	} // while
} // InitNamePage

/////////////////////////////////////////////////////////////////////////////
// This uses a deep prop enumerator to find the relevant props, because
// they could be legitimately attached to either the body itself or
// a body part object.  There would only ever be one instance of any
// of these props on a given body.
void InitCompanyPage(CPropCompany &propPageCompany, CVCNode *body, CVCard *card)
{
	char buf[1024];
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;

	while ((prop = enumerator.NextProp(&node))) {

		if (strcmp(prop->GetName(), vcOrgNameProp) == 0) {
			propPageCompany.m_edit_orgname = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageCompany.m_nodeOrg = node;
		} else if (strcmp(prop->GetName(), vcOrgUnitProp) == 0) {
			propPageCompany.m_edit_orgunit = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageCompany.m_nodeOrg = node;
		} else if (strcmp(prop->GetName(), vcTitleProp) == 0) {
			propPageCompany.m_edit_title = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageCompany.m_nodeTitle = node;
		}
	} // while
} // InitCompanyPage

CString FirstEmailPropStr(CList *plist)
{
	for (CLISTPOSITION pos = plist->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)plist->GetNext(pos);
		const char **kep = emailProps;
		while (*kep) {
			if (strcmp(prop->GetName(), *kep) == 0)
				return CString(strrchr(*kep, '/') + 1);
			kep++;
		}
	}
	return CString("");
} // FirstEmailPropStr

/////////////////////////////////////////////////////////////////////////////
int VCMatchProp(void *item, void *context)
{
	CVCProp *prop = (CVCProp *)item;
	const char *propName = (const char *)context;
	return strcmp(propName, prop->GetName()) == 0;
}

/////////////////////////////////////////////////////////////////////////////
// This uses a deep enumerator, and so looks at all the part objects
// in every level of the tree.
void InitEmailPage(CPropEmail &propPageEmail, CVCNode *body, CVCard *card)
{
	char buf[1024];
	int partIndex = 0;
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;

	while ((prop = enumerator.NextProp(&node))) {

		if (strcmp(prop->GetName(), vcPartProp) != 0)
			continue;

		CVCNode *part = (CVCNode *)prop->FindValue(
			VCNextObjectType)->GetValue();
		if (!part->GetProp(vcEmailAddressProp))
			continue;

		switch (partIndex) {
			case 0: propPageEmail.m_node1 = part; break;
			case 1: propPageEmail.m_node2 = part; break;
			case 2: propPageEmail.m_node3 = part; break;
		}

		CList *partProps = part->GetProps();
		for (CLISTPOSITION pos = partProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)partProps->GetNext(pos);

			if (strcmp(prop->GetName(), vcEmailAddressProp) == 0) {
				CString str(UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf));
				CList plist;
				card->GetPropsInEffect(part, &plist);
				switch (partIndex) {
					case 0:
						propPageEmail.m_edit_email1 = str;
						propPageEmail.m_popup_std1 = FirstEmailPropStr(&plist);
						propPageEmail.m_button_pref1 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						propPageEmail.m_button_office1 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageEmail.m_button_home1 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						break;
					case 1:
						propPageEmail.m_edit_email2 = str;
						propPageEmail.m_popup_std2 = FirstEmailPropStr(&plist);
						propPageEmail.m_button_pref2 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						propPageEmail.m_button_office2 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageEmail.m_button_home2 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						break;
					case 2:
						propPageEmail.m_edit_email3 = str;
						propPageEmail.m_popup_std3 = FirstEmailPropStr(&plist);
						propPageEmail.m_button_pref3 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						propPageEmail.m_button_office3 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageEmail.m_button_home3 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						break;
				} // switch
			} // email prop
		} // for each part prop

		partIndex++;
	} // for each body prop
} // InitEmailPage

/////////////////////////////////////////////////////////////////////////////
// This looks at only the part objects within the props of body itself,
// and so the properties that make up the basic location are seen only
// if they're at that level.
void InitLocBasicPage(CPropLocBasic &propPageLocBasic, CVCNode *body, CVCard *card)
{
	char buf[1024];
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	CVCNode *node;
	BOOL processedCaption = FALSE;

	while ((prop = enumerator.NextProp(&node))) {
		if (strcmp(prop->GetName(), vcLocationProp) == 0) {
			propPageLocBasic.m_edit_location = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageLocBasic.m_nodeloc = node;
		} else if (strcmp(prop->GetName(), vcDeliveryLabelProp) == 0) {
			CList plist;
			card->GetPropsInEffect(node, &plist);
			if (plist.Search(VCMatchProp, (void *)vcDomesticProp)) {
				propPageLocBasic.m_edit_postdom = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocBasic.m_nodepostdom = node;
			} else {
				propPageLocBasic.m_edit_postintl = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocBasic.m_nodepostintl = node;
			}
			if (!processedCaption) {
				propPageLocBasic.m_button_home = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
				propPageLocBasic.m_button_office = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
				propPageLocBasic.m_button_parcel = plist.Search(VCMatchProp, (void *)vcParcelProp) != NULL;
				propPageLocBasic.m_button_postal = plist.Search(VCMatchProp, (void *)vcPostalProp) != NULL;
				processedCaption = TRUE;
			}
		} else if (strcmp(prop->GetName(), vcTimeZoneProp) == 0) {
			propPageLocBasic.m_edit_timezone = UI_CString(
				(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
			propPageLocBasic.m_nodetz = node;
		}
	} // while
} // InitLocBasicPage

/////////////////////////////////////////////////////////////////////////////
// This looks at only the part objects within the props of body itself,
// and so the properties that make up the extended location are seen only
// if they're at that level.
void InitLocXPage(CPropLocX &propPageLocX, CVCNode *body, CVCard *card)
{
	CList *props = body->GetProps();
	char buf[1024];

	for (CLISTPOSITION pos = props->GetHeadPosition(); pos; ) {
		CVCProp *prop = (CVCProp *)props->GetNext(pos);

		if (strcmp(prop->GetName(), vcPartProp) != 0)
			continue;

		CVCNode *part = (CVCNode *)prop->FindValue(
			VCNextObjectType)->GetValue();
		CList *partProps = part->GetProps();

		for (CLISTPOSITION pos = partProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)partProps->GetNext(pos);

			if (strcmp(prop->GetName(), vcExtAddressProp) == 0) {
				propPageLocX.m_edit_xaddr = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcStreetAddressProp) == 0) {
				propPageLocX.m_edit_straddr = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcPostalBoxProp) == 0) {
				propPageLocX.m_edit_pobox = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcCityProp) == 0) {
				propPageLocX.m_edit_city = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcRegionProp) == 0) {
				propPageLocX.m_edit_region = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcPostalCodeProp) == 0) {
				propPageLocX.m_edit_pocode = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			} else if (strcmp(prop->GetName(), vcCountryNameProp) == 0) {
				propPageLocX.m_edit_cntry = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				propPageLocX.m_node = part;
			}
		} // for each part prop
	} // for each body prop

	// If we don't set up one common node for these props, ApplyProp
	// would end up creating a different part for each.  We want these
	// to be grouped together, so create a holder node for them if
	// necessary.
	if (!propPageLocX.m_node)
		propPageLocX.m_node = body->AddPart();
} // InitLocXPage

/////////////////////////////////////////////////////////////////////////////
// This uses a deep enumerator, and so looks at all the part objects
// in every level of the tree.
void InitTelsPage(CPropTel &propPageTels, CVCNode *body, CVCard *card)
{
	char buf[1024];
	int partIndex = 0;
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;

	propPageTels.m_body = body;

	while ((prop = enumerator.NextProp())) {

		if (strcmp(prop->GetName(), vcPartProp) != 0)
			continue;

		CVCNode *part = (CVCNode *)prop->FindValue(
			VCNextObjectType)->GetValue();
		if (!part->GetProp(vcTelephoneProp))
			continue;
		
		switch (partIndex) {
			case 0: propPageTels.m_node1 = part; break;
			case 1: propPageTels.m_node2 = part; break;
			case 2: propPageTels.m_node3 = part; break;
		}

		CList *partProps = part->GetProps();
		for (CLISTPOSITION pos = partProps->GetHeadPosition(); pos; ) {
			CVCProp *prop = (CVCProp *)partProps->GetNext(pos);

			if (strcmp(prop->GetName(), vcTelephoneProp) == 0) {
				char *str = UI_CString(
					(wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), buf);
				CList plist;
				card->GetPropsInEffect(part, &plist);
				switch (partIndex) {
					case 0:
						propPageTels.m_edit_fullName1 = str;
						propPageTels.m_button_fax1 = plist.Search(VCMatchProp, (void *)vcFaxProp) != NULL;
						propPageTels.m_button_home1 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						propPageTels.m_button_office1 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageTels.m_button_cell1 = plist.Search(VCMatchProp, (void *)vcCellularProp) != NULL;
						propPageTels.m_button_message1 = plist.Search(VCMatchProp, (void *)vcMessageProp) != NULL;
						propPageTels.m_button_pref1 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						break;
					case 1:
						propPageTels.m_edit_fullName2 = str;
						propPageTels.m_button_fax2 = plist.Search(VCMatchProp, (void *)vcFaxProp) != NULL;
						propPageTels.m_button_home2 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						propPageTels.m_button_office2 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageTels.m_button_cell2 = plist.Search(VCMatchProp, (void *)vcCellularProp) != NULL;
						propPageTels.m_button_message2 = plist.Search(VCMatchProp, (void *)vcMessageProp) != NULL;
						propPageTels.m_button_pref2 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						break;
					case 2:
						propPageTels.m_edit_fullName3 = str;
						propPageTels.m_button_fax3 = plist.Search(VCMatchProp, (void *)vcFaxProp) != NULL;
						propPageTels.m_button_home3 = plist.Search(VCMatchProp, (void *)vcHomeProp) != NULL;
						propPageTels.m_button_office3 = plist.Search(VCMatchProp, (void *)vcWorkProp) != NULL;
						propPageTels.m_button_cell3 = plist.Search(VCMatchProp, (void *)vcCellularProp) != NULL;
						propPageTels.m_button_message3 = plist.Search(VCMatchProp, (void *)vcMessageProp) != NULL;
						propPageTels.m_button_pref3 = plist.Search(VCMatchProp, (void *)vcPreferredProp) != NULL;
						break;
				} // switch
			} // telephone prop
		} // for each part prop

		partIndex++;
	} // for each body prop
} // InitTelsPage

static CString FilterUIString(const char *str)
{
	CString filtered(str);
	int len = filtered.GetLength(), index;

	// The passed string came from the UI (a property page), and so
	// line breaks are specified with '\r\n' (by UI_CString).
	// For the intermediate form, we keep just the '\n', which will
	// be changed to 0x2028 -- a line separator.
	while ((index = filtered.Find('\r')) != -1) {
		filtered = filtered.Left(index) + filtered.Right(len - index - 1);
		len--;
	}
	return filtered;
}

void ChangeStringProp(CVCProp *prop, const char *str)
{
	int size;
	wchar_t *uniValue;
	
	uniValue = FakeUnicode(FilterUIString(str), &size);
	FixCRLF(uniValue);
	prop->FindValue(VCStrIdxType)->SetValue(uniValue, size);
	delete [] uniValue;
}

void ApplyProp(
	const char *propName, const CString &newValue, CVCNode **node,
	CVCNode *body)
{
	if (!newValue.IsEmpty()) {
		CVCProp *prop;
		if (!*node) {
			*node = FindOrCreatePart(body, nameGen);
			nameGen[2] += 1;
		}
		prop = (*node)->GetProp(propName);
		if (prop)
			ChangeStringProp(prop, newValue);
		else {
			VC_DISPTEXT dispText;
			(*node)->AddStringProp(
				propName, FilterUIString(newValue), DisplayInfoForProp(propName, &dispText));
		}
	} else {
		if (*node && (strcmp(propName, vcPronunciationProp) != 0))
			(*node)->RemoveProp(propName);
	}
} // ApplyProp

/////////////////////////////////////////////////////////////////////////////
static void ApplyBoolProp(
	const char *propName, CVCard *card, CVCNode *node, CList *plist, BOOL wantTrue)
{
	CLISTPOSITION pos = plist->Search(VCMatchProp, (void *)propName);
	BOOL isTrue = pos != NULL;

	if (isTrue == wantTrue)
		return;

	if (isTrue) { // remove
		CVCNode *obj;
		VERIFY(card->GetInheritedProp(node, propName, &obj));
		plist->RemoveAt(pos);
		obj->RemoveProp(propName);
	} else { // add
		plist->AddTail(node->AddBoolProp(propName));
	}
}

/////////////////////////////////////////////////////////////////////////////
void ApplyNamePage(CPropPers &propPageName, CVCNode *body, CVCard *card)
{
	ApplyProp(vcFamilyNameProp,
		propPageName.m_edit_famname, &propPageName.m_nodeName, body);
	ApplyProp(vcFullNameProp,
		propPageName.m_edit_fullname, &propPageName.m_nodeFullName, body);
	ApplyProp(vcGivenNameProp,
		propPageName.m_edit_givenname, &propPageName.m_nodeName, body);
	ApplyProp(vcPronunciationProp,
		propPageName.m_edit_pronun, &propPageName.m_nodePronun, body);
}

/////////////////////////////////////////////////////////////////////////////
void ApplyCompanyPage(CPropCompany &propPageCompany, CVCNode *body, CVCard *card)
{
	ApplyProp(vcOrgNameProp,
		propPageCompany.m_edit_orgname, &propPageCompany.m_nodeOrg, body);
	ApplyProp(vcOrgUnitProp,
		propPageCompany.m_edit_orgunit, &propPageCompany.m_nodeOrg, body);
	ApplyProp(vcTitleProp,
		propPageCompany.m_edit_title, &propPageCompany.m_nodeTitle, body);
}

/////////////////////////////////////////////////////////////////////////////
static void ApplyEmailProp(
	CVCard *card, CVCNode *node, CList *plist, const char *propName)
{
	do { // remove every email prop currently in effect for this node
		const char *found = NULL;
		CLISTPOSITION foundPos;
		CVCNode *obj;

		for (CLISTPOSITION pos = plist->GetHeadPosition(); pos && (found == NULL); ) {
			foundPos = pos;
			CVCProp *prop = (CVCProp *)plist->GetNext(pos);
			const char **kep = emailProps;
			while (*kep) {
				if (strcmp(prop->GetName(), *kep) == 0) {
					found = *kep;
					break;
				}
				kep++;
			}
		}
		if (!found)
			break;
		VERIFY(card->GetInheritedProp(node, found, &obj));
		plist->RemoveAt(foundPos);
		obj->RemoveProp(found);
	} while (TRUE);

	// now add in the desired property
	plist->AddTail(node->AddBoolProp(propName));
}

/////////////////////////////////////////////////////////////////////////////
static const char* FullEmailName(const char *shortName)
{
	const char **kep = emailProps;
	while (*kep) {
		if (stricmp(strrchr(*kep, '/') + 1, shortName) == 0)
			return *kep;
		kep++;
	}
	return shortName;
}

/////////////////////////////////////////////////////////////////////////////
void ApplyEmailPage(CPropEmail &propPageEmail, CVCNode *body, CVCard *card)
{
	ApplyProp(vcEmailAddressProp,
		propPageEmail.m_edit_email1, &propPageEmail.m_node1, body);
	if (propPageEmail.m_node1) {
		CList plist;
		card->GetPropsInEffect(propPageEmail.m_node1, &plist);
		ApplyEmailProp(card, propPageEmail.m_node1, &plist,
			FullEmailName(propPageEmail.m_popup_std1));
		ApplyBoolProp(vcPreferredProp, card, propPageEmail.m_node1, &plist,
			propPageEmail.m_button_pref1);
		ApplyBoolProp(vcWorkProp, card, propPageEmail.m_node1, &plist,
			propPageEmail.m_button_office1);
		ApplyBoolProp(vcHomeProp, card, propPageEmail.m_node1, &plist,
			propPageEmail.m_button_home1);
	}

	ApplyProp(vcEmailAddressProp,
		propPageEmail.m_edit_email2, &propPageEmail.m_node2, body);
	if (propPageEmail.m_node2) {
		CList plist;
		card->GetPropsInEffect(propPageEmail.m_node2, &plist);
		ApplyEmailProp(card, propPageEmail.m_node2, &plist,
			FullEmailName(propPageEmail.m_popup_std2));
		ApplyBoolProp(vcPreferredProp, card, propPageEmail.m_node2, &plist,
			propPageEmail.m_button_pref2);
		ApplyBoolProp(vcWorkProp, card, propPageEmail.m_node2, &plist,
			propPageEmail.m_button_office2);
		ApplyBoolProp(vcHomeProp, card, propPageEmail.m_node2, &plist,
			propPageEmail.m_button_home2);
	}

	ApplyProp(vcEmailAddressProp,
		propPageEmail.m_edit_email3, &propPageEmail.m_node3, body);
	if (propPageEmail.m_node3) {
		CList plist;
		card->GetPropsInEffect(propPageEmail.m_node3, &plist);
		ApplyEmailProp(card, propPageEmail.m_node3, &plist,
			FullEmailName(propPageEmail.m_popup_std3));
		ApplyBoolProp(vcPreferredProp, card, propPageEmail.m_node3, &plist,
			propPageEmail.m_button_pref3);
		ApplyBoolProp(vcWorkProp, card, propPageEmail.m_node3, &plist,
			propPageEmail.m_button_office3);
		ApplyBoolProp(vcHomeProp, card, propPageEmail.m_node3, &plist,
			propPageEmail.m_button_home3);
	}
}

/////////////////////////////////////////////////////////////////////////////
void ApplyLocBasicPage(CPropLocBasic &propPageLocBasic, CVCNode *body, CVCard *card)
{
	ApplyProp(vcLocationProp,
		propPageLocBasic.m_edit_location, &propPageLocBasic.m_nodeloc, body);
	ApplyProp(vcTimeZoneProp,
		propPageLocBasic.m_edit_timezone, &propPageLocBasic.m_nodetz, body);

	ApplyProp(vcDeliveryLabelProp,
		propPageLocBasic.m_edit_postdom, &propPageLocBasic.m_nodepostdom, body);
	if (propPageLocBasic.m_nodepostdom) {
		CList plist;
		card->GetPropsInEffect(propPageLocBasic.m_nodepostdom, &plist);
		ApplyBoolProp(vcDomesticProp, card, propPageLocBasic.m_nodepostdom, &plist, TRUE);
		ApplyBoolProp(vcHomeProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_home);
		ApplyBoolProp(vcWorkProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_office);
		ApplyBoolProp(vcParcelProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_parcel);
		ApplyBoolProp(vcPostalProp, card, propPageLocBasic.m_nodepostdom, &plist,
			propPageLocBasic.m_button_postal);
		ApplyBoolProp(vcQuotedPrintableProp, card, propPageLocBasic.m_nodepostdom, &plist,
			TRUE);
	}

	ApplyProp(vcDeliveryLabelProp,
		propPageLocBasic.m_edit_postintl, &propPageLocBasic.m_nodepostintl, body);
	if (propPageLocBasic.m_nodepostintl) {
		CList plist;
		card->GetPropsInEffect(propPageLocBasic.m_nodepostintl, &plist);
		ApplyBoolProp(vcHomeProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_home);
		ApplyBoolProp(vcWorkProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_office);
		ApplyBoolProp(vcParcelProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_parcel);
		ApplyBoolProp(vcPostalProp, card, propPageLocBasic.m_nodepostintl, &plist,
			propPageLocBasic.m_button_postal);
		ApplyBoolProp(vcQuotedPrintableProp, card, propPageLocBasic.m_nodepostintl, &plist,
			TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////
void ApplyLocXPage(CPropLocX &propPageLocX, CVCNode *body, CVCard *card)
{
	CVCNode *node = propPageLocX.m_node;
	ApplyProp(vcExtAddressProp,
		propPageLocX.m_edit_xaddr, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcStreetAddressProp,
		propPageLocX.m_edit_straddr, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcPostalBoxProp,
		propPageLocX.m_edit_pobox, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcCityProp,
		propPageLocX.m_edit_city, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcRegionProp,
		propPageLocX.m_edit_region, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcPostalCodeProp,
		propPageLocX.m_edit_pocode, &node, body);
	node = propPageLocX.m_node;
	ApplyProp(vcCountryNameProp,
		propPageLocX.m_edit_cntry, &node, body);
}

/////////////////////////////////////////////////////////////////////////////
void ApplyTelsPage(CPropTel &propPageTels, CVCNode *body, CVCard *card)
{
	ApplyProp(vcTelephoneProp,
		propPageTels.m_edit_fullName1, &propPageTels.m_node1, body);
	if (propPageTels.m_node1) {
		CList plist;
		card->GetPropsInEffect(propPageTels.m_node1, &plist);
		ApplyBoolProp(vcFaxProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_fax1);
		ApplyBoolProp(vcHomeProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_home1);
		ApplyBoolProp(vcWorkProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_office1);
		ApplyBoolProp(vcCellularProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_cell1);
		ApplyBoolProp(vcMessageProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_message1);
		ApplyBoolProp(vcPreferredProp, card, propPageTels.m_node1, &plist,
			propPageTels.m_button_pref1);
	}

	ApplyProp(vcTelephoneProp,
		propPageTels.m_edit_fullName2, &propPageTels.m_node2, body);
	if (propPageTels.m_node2) {
		CList plist;
		card->GetPropsInEffect(propPageTels.m_node2, &plist);
		ApplyBoolProp(vcFaxProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_fax2);
		ApplyBoolProp(vcHomeProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_home2);
		ApplyBoolProp(vcWorkProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_office2);
		ApplyBoolProp(vcCellularProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_cell2);
		ApplyBoolProp(vcMessageProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_message2);
		ApplyBoolProp(vcPreferredProp, card, propPageTels.m_node2, &plist,
			propPageTels.m_button_pref2);
	}

	ApplyProp(vcTelephoneProp,
		propPageTels.m_edit_fullName3, &propPageTels.m_node3, body);
	if (propPageTels.m_node3) {
		CList plist;
		card->GetPropsInEffect(propPageTels.m_node3, &plist);
		ApplyBoolProp(vcFaxProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_fax3);
		ApplyBoolProp(vcHomeProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_home3);
		ApplyBoolProp(vcWorkProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_office3);
		ApplyBoolProp(vcCellularProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_cell3);
		ApplyBoolProp(vcMessageProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_message3);
		ApplyBoolProp(vcPreferredProp, card, propPageTels.m_node3, &plist,
			propPageTels.m_button_pref3);
	}
}

/////////////////////////////////////////////////////////////////////////////
char NextGeneratedNameSeed(CVCNode *body)
{
	CVCPropEnumerator enumerator = CVCPropEnumerator(body);
	CVCProp *prop;
	char nodeName[1024];
	char maxChar = 'A' - 1;

	while ((prop = enumerator.NextProp())) {
		if (strcmp(prop->GetName(), vcNodeNameProp) != 0)
			continue;
		UI_CString((wchar_t *)prop->FindValue(VCStrIdxType)->GetValue(), nodeName);
		if ((strlen(nodeName) == 3) && (strncmp(nodeName, "vc", 2) == 0))
			maxChar = max(nodeName[2], maxChar);
	}

	return maxChar + 1;
}

/////////////////////////////////////////////////////////////////////////////
void CVCView::OnEditProperties() 
{
	CVCDoc *doc = GetDocument();
	CVCard *cards = doc->GetVCard();
	CVCNode *body = cards->FindBody(m_language);
	CList *props = body->GetProps();
	CPropertySheet propSheet(IDR_MAINFRAME /* that'll read "Versitcard" */);
	CPropPers propPageName;
	CPropCompany propPageCompany;
	CPropEmail propPageEmail;
	CPropLocBasic propPageLocBasic;
	CPropLocX propPageLocX;
	CPropTel propPageTels;

	// TRACE0("dump of card before initializing props...\n");
	// cards->WriteSimplegram(NULL);

	InitNamePage(propPageName, body, cards);
	InitCompanyPage(propPageCompany, body, cards);
	InitEmailPage(propPageEmail, body, cards);
	InitLocBasicPage(propPageLocBasic, body, cards);
	InitLocXPage(propPageLocX, body, cards);
	InitTelsPage(propPageTels, body, cards);

	propSheet.AddPage(&propPageName);
	propSheet.AddPage(&propPageCompany);
	propSheet.AddPage(&propPageEmail);
	propSheet.AddPage(&propPageLocBasic);
	propSheet.AddPage(&propPageLocX);
	propSheet.AddPage(&propPageTels);

	if (propSheet.DoModal() == IDOK) {
		nameGen[0] = 'v'; nameGen[1] = 'c';
		nameGen[2] = NextGeneratedNameSeed(body);
		nameGen[3] = 0;
		ApplyNamePage(propPageName, body, cards);
		ApplyCompanyPage(propPageCompany, body, cards);
		ApplyEmailPage(propPageEmail, body, cards);
		ApplyLocBasicPage(propPageLocBasic, body, cards);
		ApplyLocXPage(propPageLocX, body, cards);
		ApplyTelsPage(propPageTels, body, cards);
		doc->SetModifiedFlag();
		doc->UpdateAllViews(NULL);
		// TRACE0("dump of card after applying props...\n");
		// cards->WriteSimplegram(NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wab32res\commonrc.h ===
// resources that are replicated in both wab32.dll and the other WAB files

#define IDS_ALL_FILE_SPEC               60
#define IDI_ICON_VCARD                  1924
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wab32res\makefile.inc ===
WAB32_RC_DEPENDS =  resource.h \
                    resrc1.h

$O\wab32res.res : $(WAB32_RC_DEPENDS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\wchar.h ===
#ifndef __WCHAR_H__
#define __WCHAR_H__

typedef unsigned short wchar_t;

extern wchar_t* wcscpy(wchar_t* dst, const wchar_t* src);
extern wchar_t* wcscat(wchar_t* dst, const wchar_t* src);
extern int wcscmp(const wchar_t* s1, const wchar_t* s2);
extern int wcslen(const wchar_t* str);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wab32res\resource.h ===
/**********************************************************************
/
/ Resource.h - Resource symbol definitions for WAB32.Dll
/
/
/
/
/**********************************************************************/
#include ".\commonrc.h"


#define IDS_WAB_TEMP_FILE_PREFIX        1
#define IDS_ADDRBK_CAPTION              3
#define IDD_FORMVIEW                    4
#define IDC_PIC                         5
#define IDS_ADDRBK_MESSAGE_ACTION       21
#define IDS_ADDRBK_MESSAGE_NO_ITEM      22
#define IDS_ADDRBK_MESSAGE_DELETE       23
#define IDS_ADDRBK_MESSAGE_NO_ITEMS_DELETE 26
#define IDS_ADDRBK_MESSAGE_NO_ITEMS_ADD 27
#define IDS_ADDRBK_RESOLVE_CAPTION      28
#define IDS_DETAILS_CAPTION             33
#define IDS_RESOLVE_NO_MATCHES          38
#define IDS_RESOLVE_NO_MATCHES_FOR      39
#define IDS_DETAILS_MESSAGE_FIRST_LAST_REQUIRED 40
#define IDS_ADDRBK_MESSAGE_DELETING_ERROR 42
#define IDS_VCARD_FILE_SPEC             43
#define IDS_VCARD_EXPORT_TITLE          44
#define IDS_VCARD_IMPORT_TITLE          45
#define IDE_VCARD_IMPORT_FILE_ERROR     46
#define IDE_VCARD_IMPORT_FILE_BAD       47
#define IDE_VCARD_EXPORT_FILE_ERROR     48
#define IDE_VCARD_EXPORT_DISTLIST       50
#define IDE_VCARD_IMPORT_PARTIAL        51
#define IDS_VCARD_IMPORT_COLLISION      52
#define IDS_VCARD_EXPORT_NOT_ASCII      53
#define IDE_VCARD_EXPORT_FILE_EXISTS    55
#define IDS_VISIT_SERVER                56
#define IDE_SERVER_NAME_COLLISION       57
#define IDS_CERT_FILE_SPEC              59
#define IDS_CER_FILE_SPEC               61


#define IDD_DIALOG_DETAILS_PERSONAL     101
#define IDD_DIALOG_DETAILS_NET          105
#define IDD_DIALOG_ADDRESSBOOK          106
#define IDD_DIALOG_PROPERTIES           107
#define IDD_DIALOG_RESOLVENAME          112
#define IDD_DETAILS_PERSONAL            114
#define IDD_DETAILS_HOME                115
#define IDD_DETAILS_BUSINESS            116
#define IDD_DETAILS_NOTES               117
#define IDD_DISTLIST                    118
#define IDD_DETAILS_CERT                119
#define iddConflict                     120
#define iddSyncProgress                 121
#define iddPassword                     123
#define iddChooseServer                 124

#define IDC_DETAILS_EDIT_DISPLAYNAME    1003
#define IDC_DETAILS_EDIT_FIRSTNAME      1004
#define IDC_DETAILS_EDIT_LASTNAME       1005
#define IDC_DETAILS_EDIT_NOTES          1006
#define IDC_DETAILS_COMBO_EMAIL         1007
#define IDC_STATIC1                     1009
#define IDC_STATIC2                     1010
#define IDC_STATIC3                     1011
#define IDC_STATIC4                     1012
#define IDC_STATIC5                     1013
#define IDC_STATIC6                     1014
#define IDC_STATIC7                     1015
#define IDC_STATIC8                     1016
#define IDC_STATIC9                     1017
#define IDC_STATIC10                    1018
#define IDC_STATIC11                    1019
#define IDC_STATIC12                    1020
#define IDC_PROP_STATIC1                1028
#define IDC_PROP_STATIC_2               1029
#define IDC_PROP_STATIC_3               1030
#define IDC_PROP_EDIT_FIRSTNAME         1031
#define IDC_PROP_EDIT_LASTNAME          1032
#define IDC_PROP_EDIT_EMAIL             1033
#define IDC_PROP_STATIC_4               1034
#define IDC_PROP_STATIC_5               1035
#define IDC_PROP_STATIC_6               1036
#define IDC_RESOLVE_BUTTON_OK           1044
#define IDC_RESOLVE_BUTTON_CANCEL       1045
#define IDC_RESOLVE_STATIC_1            1046
#define IDC_RESOLVE_STATIC_ETCHED       1047
#define IDC_RESOLVE_BUTTON_BROWSE       1054
#define IDC_RESOLVE_LIST_MATCHES        1055
#define IDC_RESOLVE_BUTTON_PROPS        1056
#define IDC_RESOLVE_BUTTON_NEWCONTACT   1057
#define IDC_RESOLVE_BUTTON_NEWGROUP     1058
#define IDC_RESOLVE_STATIC_MATCHES      1059

#define IDI_ICON_ABOOK                  1911
#define IDI_ICON_FIND                   1912
#define IDI_ICON_CONTACT                1915
#define IDI_ICON_HOME                   1916
#define IDI_ICON_BUSINESS               1917
#define IDI_ICON_NOTES                  1918
#define IDI_ICON_GROUP                  1919
#define IDI_ICON_IE                     1920
#define IDI_ICON_CERT                   1921
#define IDI_ICON_CHECK                  1922
#define IDI_ICON_UNCHECK                1923
#define IDI_PasswordKeys                1925
#define IDI_ICON_SYNC                   1926

#define IDC_DISTLIST_STATIC_GROUPNAME   2359
#define IDC_DISTLIST_EDIT_GROUPNAME     2360
#define IDC_DISTLIST_FRAME_MEMBERS      2361
#define IDC_DISTLIST_LISTVIEW           2362
#define IDC_DISTLIST_BUTTON_ADD         2363
#define IDC_DISTLIST_BUTTON_REMOVE      2364
#define IDC_DISTLIST_STATIC_NOTES       2365
#define IDC_DISTLIST_EDIT_NOTES         2366
#define IDC_DISTLIST_BUTTON_PROPERTIES  2369
#define IDC_DISTLIST_BUTTON_ADDNEW      2370
#define IDC_DISTLIST_STATIC_COUNT       2371
#define IDC_DISTLIST_STATIC_ADD         2372
#define IDC_DISTLIST_STATIC_ADDNAME     2373
#define IDC_DISTLIST_EDIT_ADDNAME       2374
#define IDC_DISTLIST_STATIC_ADDEMAIL    2375
#define IDC_DISTLIST_EDIT_ADDEMAIL      2376
#define IDC_DISTLIST_BUTTON_ADDUPDATE   2377
#define IDC_DISTLIST_BUTTON_UPDATECANCEL    2378
#define IDD_DISTLIST_OTHER              2379
#define IDC_DISTLIST_STATIC_STREET      2380
#define IDC_DISTLIST_EDIT_ADDRESS       2381
#define IDC_DISTLIST_STATIC_CITY        2382
#define IDC_DISTLIST_EDIT_CITY          2383
#define IDC_DISTLIST_STATIC_STATE       2384
#define IDC_DISTLIST_EDIT_STATE         2385
#define IDC_DISTLIST_STATIC_ZIP         2386
#define IDC_DISTLIST_EDIT_ZIP           2387
#define IDC_DISTLIST_STATIC_COUNTRY     2388
#define IDC_DISTLIST_EDIT_COUNTRY       2389
#define IDC_DISTLIST_STATIC_PHONE       2390
#define IDC_DISTLIST_EDIT_PHONE         2391
#define IDC_DISTLIST_STATIC_FAX         2392
#define IDC_DISTLIST_EDIT_FAX           2393
#define IDC_DISTLIST_STATIC_WEB         2394
#define IDC_DISTLIST_EDIT_URL           2395
#define IDC_DISTLIST_BUTTON_URL         2396



#define IDC_DETAILS_NOTES_STATIC_NOTES          2462
#define IDC_DETAILS_NOTES_EDIT_NOTES            2463

#define IDC_DETAILS_CERT_FRAME                  2474
#define IDC_DETAILS_CERT_LIST                   2475
#define IDC_DETAILS_CERT_BUTTON_PROPERTIES      2476
#define IDC_DETAILS_CERT_BUTTON_REMOVE          2477
#define IDC_DETAILS_CERT_BUTTON_SETDEFAULT      2478
#define IDC_DETAILS_CERT_BUTTON_IMPORT          2479
#define IDC_DETAILS_CERT_BUTTON_EXPORT          2480

#define IDC_DETAILS_BUSINESS_STATIC_COMPANY     2561
#define IDC_DETAILS_BUSINESS_STATIC_JOBTITLE    2562
#define IDC_DETAILS_BUSINESS_STATIC_ADDRESS     2563
#define IDC_DETAILS_BUSINESS_STATIC_CITY        2564
#define IDC_DETAILS_BUSINESS_STATIC_STATE       2565
#define IDC_DETAILS_BUSINESS_STATIC_ZIP         2566
#define IDC_DETAILS_BUSINESS_STATIC_COUNTRY     2567
#define IDC_DETAILS_BUSINESS_STATIC_WEB         2568
#define IDC_DETAILS_BUSINESS_EDIT_COMPANY       2569
#define IDC_DETAILS_BUSINESS_EDIT_JOBTITLE      2570
#define IDC_DETAILS_BUSINESS_EDIT_ADDRESS       2571
#define IDC_DETAILS_BUSINESS_EDIT_CITY          2572
#define IDC_DETAILS_BUSINESS_EDIT_STATE         2573
#define IDC_DETAILS_BUSINESS_EDIT_ZIP           2574
#define IDC_DETAILS_BUSINESS_EDIT_COUNTRY       2575
#define IDC_DETAILS_BUSINESS_EDIT_URL           2576
#define IDC_DETAILS_BUSINESS_EDIT_PHONE         2577
#define IDC_DETAILS_BUSINESS_EDIT_FAX           2578
#define IDC_DETAILS_BUSINESS_EDIT_DEPARTMENT    2579
#define IDC_DETAILS_BUSINESS_EDIT_OFFICE        2580
#define IDC_DETAILS_BUSINESS_EDIT_PAGER         2581
#define IDC_DETAILS_BUSINESS_STATIC_PHONE       2582
#define IDC_DETAILS_BUSINESS_STATIC_FAX         2583
#define IDC_DETAILS_BUSINESS_STATIC_PAGER       2584
#define IDC_DETAILS_BUSINESS_STATIC_DEPARTMENT  2585
#define IDC_DETAILS_BUSINESS_BUTTON_URL         2586
#define IDC_DETAILS_BUSINESS_STATIC_OFFICE      2587

#define IDC_DETAILS_HOME_STATIC_ADDRESS         2659
#define IDC_DETAILS_HOME_STATIC_CITY            2660
#define IDC_DETAILS_HOME_STATIC_STATE           2661
#define IDC_DETAILS_HOME_STATIC_ZIP             2662
#define IDC_DETAILS_HOME_STATIC_COUNTRY         2663
#define IDC_DETAILS_HOME_STATIC_WEB             2664
#define IDC_DETAILS_HOME_STATIC_PHONE           2665
#define IDC_DETAILS_HOME_STATIC_FAX             2666
#define IDC_DETAILS_HOME_STATIC_CELLULAR        2667
#define IDC_DETAILS_HOME_EDIT_ADDRESS           2668
#define IDC_DETAILS_HOME_EDIT_CITY              2669
#define IDC_DETAILS_HOME_EDIT_ZIP               2670
#define IDC_DETAILS_HOME_EDIT_STATE             2671
#define IDC_DETAILS_HOME_EDIT_COUNTRY           2672
#define IDC_DETAILS_HOME_EDIT_URL               2673
#define IDC_DETAILS_HOME_EDIT_PHONE             2674
#define IDC_DETAILS_HOME_EDIT_FAX               2675
#define IDC_DETAILS_HOME_EDIT_CELLULAR          2676
#define IDC_DETAILS_HOME_BUTTON_URL             2677

#define IDC_DETAILS_PERSONAL_FRAME_NAME         2760
#define IDC_DETAILS_PERSONAL_FRAME_EMAIL        2762
#define IDC_DETAILS_PERSONAL_STATIC_FIRSTNAME   2763
#define IDC_DETAILS_PERSONAL_STATIC_LASTNAME    2764
#define IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME     2765
#define IDC_DETAILS_PERSONAL_EDIT_LASTNAME      2766
#define IDC_DETAILS_PERSONAL_STATIC_MIDDLENAME  2767
#define IDC_DETAILS_PERSONAL_STATIC_NICKNAME    2768
#define IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME    2769
#define IDC_DETAILS_PERSONAL_EDIT_NICKNAME      2770
#define IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL      2771
#define IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL    2772
#define IDC_DETAILS_PERSONAL_LIST               2774
#define IDC_DETAILS_PERSONAL_BUTTON_REMOVE      2775
#define IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT  2776
#define IDC_DETAILS_PERSONAL_BUTTON_EDIT        2777
#define IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB    2778

#define IDC_SYNC_NEXT                           2800
#define IDC_SYNC_BACK                           2801
#define IDC_SYNC_CONTACTNAME                    2803
#define IDC_SYNC_LIST                           2806
#define IDC_SYNC_FIELDNAME                      2807
#define IDC_SYNC_ADDRESSBOOK                    2808
#define IDC_SYNC_HOTMAIL                        2809
#define IDC_SYNC_IGNORE                         2810

#define IDC_SYNC_PROGBAR                        2850
#define IDC_SYNC_ANI                            2851
#define IDC_SYNC_MSG                            2852

#define IDS_SERVER                              2860    
#define IDE_PASSWORD                            2861
#define IDCH_REMEMBER                           2863
#define IDE_ACCOUNT                             2864

#define IDC_SERVER_LIST                         2870

#define idsColDisplayName               3990
#define idsColEmailAddress              3991
#define idsColHomePhone                 3992
#define idsColOfficePhone               3993

#define idsButton0                      3994
#define idsButton1                      3995
#define idsButton2                      3996
#define idsButton3                      3997
#define idsButton4                      3998
#define idsButton5                      3999

#define idsQuickFindCaption             4010
#define idsGroupMemberCount             4011
#define idsIncompleteOneoffInfo         4012
#define idsRemove                       4013
#define idsShowMoreNames                4014
#define idsDetailsPersonalTitle         4015
#define idsDetailsHomeTitle             4016
#define idsDetailsBusinessTitle         4017
#define idsDetailsNotesTitle            4018
#define idsInvalidInternetAddress       4019
#define idsToolbarMaxButtonWidth        4020
#define idsDefaultEmail                 4023

#define idsGroupTabName                 4028
#define idsPleaseEnterGroupName         4029
#define idsGroupAddWellButton           4030
#define idsGroupAddCaption              4031
#define idsGroupDestWellsTitle          4032
#define idsCouldNotAddGroupToGroup      4033

#define idsLangDisplayNameIsByLastName  4034
#define idsDisplayNameByLastName        4035
#define idsDisplayNameByFirstName       4036
#define idsDisplayNameByCommaLastName   4037

#define idsSpecifySearchCriteria        4042
#define idsCouldNotSelectUser           4043
#define idsNoItemsSelectedForAdding     4045
#define idsCouldNotAddUserToWAB         4046
#define idsSuccessfullyAddedUsers       4047
#define idsLDAPSearchNoResults          4048
#define idsLDAPAmbiguousRecip           4049
#define idsLDAPAccessDenied             4050
#define idsLDAPSearchTimedOut           4051
#define idsLDAPCouldNotFindServer       4052
#define idsLDAPErrorOccured             4053
#define idsLDAPPartialResults           4060
#define idsLDAPFirstNameOnly            4061
#define idsWABIntegrityError            4062
#define idsWABUnableToRestoreBackup     4063
#define idsWABRestoreSucceeded          4064
#define idsWABUnexpectedError           4065
#define idsEntryAlreadyExists           4066
#define idsWindowTitleProperties        4068
#define idsWABImportString              4069

#define idsContactTextEmail             4070
#define idsContactTextPersonal          4071
#define idsContactTextHomeAddress       4072
#define idsContactTextHomePhone         4073
#define idsContactTextHomeFax           4074
#define idsContactTextHomeCellular      4075
#define idsContactTextPersonalWebPage   4076
#define idsContactTextBusiness          4077
#define idsContactTextTitle             4078
#define idsContactTextDepartment        4079
#define idsContactTextOffice            4080
#define idsContactTextCompany           4081
#define idsContactTextBusinessAddress   4082
#define idsContactTextBusinessPhone     4083
#define idsContactTextBusinessFax       4084
#define idsContactTextBusinessPager     4085
#define idsContactTextBusinessWebPage   4086
#define idsContactTextNotes             4087
#define idsContactAddress               4088
#define idsSendMailTo                   4089
#define idsSendMailToNoEmail            4090
#define idsDetailsCertTitle             4091
#define idsDefaultCert                  4096
#define idsLDAPUnconfigured             4102
#define idsLDAPSearchTimeExceeded       4103


#define idsMenuNewContact               4200
#define idsMenuNewGroup                 4201
#define idsMenuCopy                     4202
#define idsMenuSendMail                 4203
#define idsMenuProperties               4204
#define idsMenuDelete                   4205
#define idsMenuAddToWAB                 4206
#define idsMenuFind                     4207
#define idsMenuDirectoryService         4208
#define idsMenuExit                     4209
#define idsMenuSelectAll                4210
#define idsMenuViewToolbar              4211
#define idsMenuViewStatusBar            4212
#define idsMenuLargeIcon                4213
#define idsMenuSmallIcon                4214
#define idsMenuList                     4215
#define idsMenuDetails                  4216
#define idsMenuDisplayName              4217
#define idsMenuEmail                    4218
#define idsMenuBusinessPhone            4219
#define idsMenuHomePhone                4220
#define idsMenuFirstName                4221
#define idsMenuLastName                 4222
#define idsMenuAscending                4223
#define idsMenuDescending               4224
#define idsMenuRefresh                  4225
#define idsMenuImportVcard              4226
#define idsMenuExportVcard              4227
#define idsMenuImportOther              4228
#define idsMenuHelp                     4229
#define idsUnknown                      4230
#define idsInvalidDBCSInternetAddress   4235
#define idsResolveMatchesOnLDAP         4236
#define idsCertImportTitle              4238
#define idsCertExportTitle              4239
#define idsMenuImportWAB                4278
#define idsMenuExportOther              4287

#ifdef WIN16
#define idsDefaultDialogFace            4400
#endif

#define idsDisplayName                  4501
#define idsGivenName                    4502
#define idsSurname                      4503
#define idsNickname                     4504
#define idsEmail                        4505
#define idsHomeStreet                   4506
#define idsHomeCity                     4507
#define idsHomeState                    4508
#define idsHomePostalCode               4509
#define idsHomeCountry                  4510
#define idsCompany                      4511
#define idsWorkStreet                   4512
#define idsWorkCity                     4513
#define idsWorkState                    4514
#define idsWorkPostalCode               4515
#define idsWorkCountry                  4516
#define idsHomePhone                    4517
#define idsHomeFax                      4518
#define idsWorkPhone                    4519
#define idsWorkFax                      4520
#define idsMobilePhone                  4521
#define idsOtherPhone                   4522
#define idsBirthday                     4523
#define idsPager                        4524

#define idsMultipleSelected             4550
#define idsNicknameFmt                  4551
#define idsSyncConnecting               4552
#define idsSyncSynchronizing            4553
#define idsSyncConflicts                4554
#define idsSyncFinishing                4555
#define idsSyncField                    4556
#define idsSyncABInfo                   4557
#define idsSyncHMInfo                   4558
#define idsSyncGathering                4559
#define idsSyncKeep                     4560
#define idsSyncSkip                     4561
#define idsSyncReplace                  4562
#define idsSyncFailed                   4563
#define idsSyncError                    4564
#define idsSyncAborted                  4565
#define idsOutOfServerSpace             4566
#define idsSyncNotHandled               4567
#define idsNoInternetConnect            4568
#define idsOffline                      4569
#ifdef HM_GROUP_SYNCING
#define idsSyncGroupsTitle              4570
#define idsSyncContactsTitle            4571
#endif
#define idsExpediaURL                   4572
#define idsExpediaIntlURL               4573

#define IDR_MENU_LVCONTEXT              4105
#define IDR_ACCELERATOR1                4107
#define IDB_BITMAP_SMALL                4108
#define IDB_BITMAP_LARGE                4109
#define IDR_MENU_AB                     4110

#define IDB_BITMAP_BUTTONS              4123
//#define IDB_BITMAP_HBG                  4124
#define IDB_COOLBAR_DEFAULT             4129
#define IDB_COOLBAR_HOT                 4130
#define IDB_COOLBAR_DISABLED            4131
#define IDB_DEFAULT_EMAIL               4132
#define IDB_CERT_VALID_INVALID          4133
#define IDB_CERT                        4134
#define IDB_COOLBAR_DEFHI               4136
#define IDB_COOLBAR_HOTHI               4137
#define IDB_COOLBAR_DISHI               4138
#define IDB_SYNC_SYNCOP                 4139

#define IDM_VIEW_LARGEICON               5000
#define IDM_VIEW_SMALLICON               5001
#define IDM_VIEW_LIST                    5002
#define IDM_VIEW_DETAILS                 5003
#define IDM_VIEW_TOOLBAR                 5004
#define IDM_VIEW_REFRESH                 5005
#define IDM_VIEW_SORTBY_FIRSTNAME        5009
#define IDM_VIEW_SORTBY_LASTNAME         5010
#define IDM_VIEW_SORTBY_DISPLAYNAME      5011
#define IDM_VIEW_SORTBY_EMAILADDRESS     5012
#define IDM_VIEW_SORTBY_BUSINESSPHONE    5013
#define IDM_VIEW_SORTBY_HOMEPHONE        5014
#define IDM_VIEW_SORTBY_ASCENDING        5015
#define IDM_VIEW_SORTBY_DESCENDING       5016
#define IDM_VIEW_STATUSBAR               5017

#define IDD_DIALOG_ABOUT                5870
#define IDC_ABOUT_LABEL                 5872
#define IDC_ABOUT_LABEL_VERSION         5873
#define IDC_ABOUT_COPYRIGHT             5874

#define IDC_SEARCH_STATIC_COMBOLABEL    6251
#define IDC_SEARCH_COMBO_SHOWNAMES      6252
#define IDC_SEARCH_STATIC_NAME          6253
#define IDC_SEARCH_STATIC_LABELFIRST    6254
#define IDC_SEARCH_EDIT_FIRST           6255
#define IDC_SEARCH_STATIC_LABELLAST     6256
#define IDC_SEARCH_EDIT_LAST            6257
#define IDC_SEARCH_STATIC_LABELEMAIL    6258
#define IDC_SEARCH_EDIT_EMAIL           6259
#define IDC_SEARCH_STATIC_LABELORG      6260
#define IDC_SEARCH_EDIT_ORG             6261
#define IDC_SEARCH_STATIC_LABELCOUNTRY  6262
#define IDC_SEARCH_COMBO_COUNTRY        6263
#define IDC_SEARCH_BUTTON_SEARCH        6264
#define IDC_SEARCH_BUTTON_CANCEL        6265
#define IDD_DIALOG_SEARCH               6266
#define IDC_SEARCH_STATIC_LABELFIRST_SIMPLE     6267
#define IDC_SEARCH_EDIT_FIRST_SIMPLE    6268
#define IDC_SEARCH_BUTTON_CLEAR         6270
#define IDC_SEARCH_RADIO_SIMPLE         6271
#define IDC_SEARCH_RADIO_DETAILED       6272
#define IDC_SEARCH_STATIC_LABELCOMPANY  6273
#define IDC_SEARCH_EDIT_COMPANY         6274
#define IDC_SEARCH_STATIC_LABELBASE     6275
#define IDC_SEARCH_EDIT_BASE            6276

#define IDC_ADDRBK_COMBO_SHOWNAMES      7000
#define IDC_ADDRBK_EDIT_QUICKFIND       7001
#define IDC_ADDRBK_BUTTON_FIND          7002
#define IDC_ADDRBK_LIST_ADDRESSES       7003
#define IDC_ADDRBK_BUTTON_PROPS         7004
#define IDC_ADDRBK_BUTTON_NEW           7005
#define IDC_ADDRBK_STATIC_CONTENTS      7008
#define IDC_ADDRBK_STATIC_RECIP_TITLE   7009
#define IDC_ADDRBK_BUTTON_CANCEL        7012
#define IDC_ADDRBK_BUTTON_OK            7013
#define IDC_ADDRBK_STATIC_COMBO         7014
#define IDC_ADDRBK_STATIC_15            7015
#define IDC_ADDRBK_STATIC_16            7018
#define IDC_ADDRBK_BUTTON_TO            7020
#define IDC_ADDRBK_BUTTON_CC            7021
#define IDC_ADDRBK_BUTTON_BCC           7022
#define IDC_ADDRBK_LIST_TO              7030
#define IDC_ADDRBK_LIST_CC              7031
#define IDC_ADDRBK_LIST_BCC             7032
#define IDC_ADDRBK_BUTTON_DELETE        7033
#define IDC_ADDRBK_BUTTON_NEWGROUP      7034


#define IDC_LISTVIEW                    9001
#define IDC_STATIC_QUICK_FIND           9002
#define IDC_STATIC_SHOW_NAMES           9003    
#define IDC_EDIT_QUICK_FIND             9004
#define IDC_COMBO_SHOW_NAMES            9005
#define IDC_ABOOK_STATIC_SHOW_NAMES     9006
#define IDC_ABOOK_STATIC_QUICK_FIND     9007
#define IDC_STATUSBAR                   9008
#define IDC_TOOLTIP                     9009


#define IDM_ADDRESS_BOOK                40006
#define IDM_FILE_NEWCONTACT             40012
#define IDM_FILE_NEWGROUP               40013
#define IDM_FILE_PROPERTIES             40014
#define IDM_FILE_DELETE                 40015
#define IDM_EDIT_FIND                   40016
#define IDM_EDIT_SELECTALL              40017
#define IDM_HELP_ADDRESSBOOKHELP        40018
#define IDM_HELP_ABOUTADDRESSBOOK       40019
#define IDM_FILE_EXIT                   40020
#define IDM_FILE_DIRECTORY_SERVICE      40021
#define IDM_TOOLS_OPTIONS               40022
#define IDM_FILE_ADDTOWAB               40023
#define IDM_TOOLS_IMPORT_VCARD          40024
#define IDM_TOOLS_EXPORT_VCARD          40025
#define IDM_EDIT_COPY                   40026
#define IDM_TOOLS_IMPORT_WAB            40027
#define IDM_TOOLS_EXPORT_WAB            40028
#define IDM_TOOLS_IMPORT_OTHER          40029
#define IDM_FILE_SENDMAIL               40030
#define IDM_FILE_PRINT                  40031
#define IDM_TOOLS_EXPORT_OTHER          40032
#define IDM_TOOLS_SYNCHRONIZE_NOW       40033

#define IDM_LVCONTEXT_ADDWELL1          40128
#define IDM_LVCONTEXT_ADDWELL2          40129
#define IDM_LVCONTEXT_ADDWELL3          40130
#define IDM_LVCONTEXT_NEWCONTACT        40131
#define IDM_LVCONTEXT_NEWGROUP          40132
#define IDM_LVCONTEXT_PROPERTIES        40133
#define IDM_LVCONTEXT_DELETE            40134
#define IDM_LVCONTEXT_ADDTOWAB          40135
#define IDM_LVCONTEXT_FIND              40136
#define IDM_LVCONTEXT_COPY              40138
#define IDM_LVCONTEXT_SENDMAIL          40139
#define IDM_LVCONTEXT_INTERNET_CALL     40140


#define  idsCountryCount    7201
#define  idsCountry1    7202
#define  idsCountry2    7203
#define  idsCountry3    7204
#define  idsCountry4    7205
#define  idsCountry5    7206
#define  idsCountry6    7207
#define  idsCountry7    7208
#define  idsCountry8    7209
#define  idsCountry9    7210
#define  idsCountry10    7211
#define  idsCountry11    7212
#define  idsCountry12    7213
#define  idsCountry13    7214
#define  idsCountry14    7215
#define  idsCountry15    7216
#define  idsCountry16    7217
#define  idsCountry17    7218
#define  idsCountry18    7219
#define  idsCountry19    7220
#define  idsCountry20    7221
#define  idsCountry21    7222
#define  idsCountry22    7223
#define  idsCountry23    7224
#define  idsCountry24    7225
#define  idsCountry25    7226
#define  idsCountry26    7227
#define  idsCountry27    7228
#define  idsCountry28    7229
#define  idsCountry29    7230
#define  idsCountry30    7231
#define  idsCountry31    7232
#define  idsCountry32    7233
#define  idsCountry33    7234
#define  idsCountry34    7235
#define  idsCountry35    7236
#define  idsCountry36    7237
#define  idsCountry37    7238
#define  idsCountry38    7239
#define  idsCountry39    7240
#define  idsCountry40    7241
#define  idsCountry41    7242
#define  idsCountry42    7243
#define  idsCountry43    7244
#define  idsCountry44    7245
#define  idsCountry45    7246
#define  idsCountry46    7247
#define  idsCountry47    7248
#define  idsCountry48    7249
#define  idsCountry49    7250
#define  idsCountry50    7251
#define  idsCountry51    7252
#define  idsCountry52    7253
#define  idsCountry53    7254
#define  idsCountry54    7255
#define  idsCountry55    7256
#define  idsCountry56    7257
#define  idsCountry57    7258
#define  idsCountry58    7259
#define  idsCountry59    7260
#define  idsCountry60    7261
#define  idsCountry61    7262
#define  idsCountry62    7263
#define  idsCountry63    7264
#define  idsCountry64    7265
#define  idsCountry65    7266
#define  idsCountry66    7267
#define  idsCountry67    7268
#define  idsCountry68    7269
#define  idsCountry69    7270
#define  idsCountry70    7271
#define  idsCountry71    7272
#define  idsCountry72    7273
#define  idsCountry73    7274
#define  idsCountry74    7275
#define  idsCountry75    7276
#define  idsCountry76    7277
#define  idsCountry77    7278
#define  idsCountry78    7279
#define  idsCountry79    7280
#define  idsCountry80    7281
#define  idsCountry81    7282
#define  idsCountry82    7283
#define  idsCountry83    7284
#define  idsCountry84    7285
#define  idsCountry85    7286
#define  idsCountry86    7287
#define  idsCountry87    7288
#define  idsCountry88    7289
#define  idsCountry89    7290
#define  idsCountry90    7291
#define  idsCountry91    7292
#define  idsCountry92    7293
#define  idsCountry93    7294
#define  idsCountry94    7295
#define  idsCountry95    7296
#define  idsCountry96    7297
#define  idsCountry97    7298
#define  idsCountry98    7299
#define  idsCountry99    7300
#define  idsCountry100    7301
#define  idsCountry101    7302
#define  idsCountry102    7303
#define  idsCountry103    7304
#define  idsCountry104    7305
#define  idsCountry105    7306
#define  idsCountry106    7307
#define  idsCountry107    7308
#define  idsCountry108    7309
#define  idsCountry109    7310
#define  idsCountry110    7311
#define  idsCountry111    7312
#define  idsCountry112    7313
#define  idsCountry113    7314
#define  idsCountry114    7315
#define  idsCountry115    7316
#define  idsCountry116    7317
#define  idsCountry117    7318
#define  idsCountry118    7319
#define  idsCountry119    7320
#define  idsCountry120    7321
#define  idsCountry121    7322
#define  idsCountry122    7323
#define  idsCountry123    7324
#define  idsCountry124    7325
#define  idsCountry125    7326
#define  idsCountry126    7327
#define  idsCountry127    7328
#define  idsCountry128    7329
#define  idsCountry129    7330
#define  idsCountry130    7331
#define  idsCountry131    7332
#define  idsCountry132    7333
#define  idsCountry133    7334
#define  idsCountry134    7335
#define  idsCountry135    7336
#define  idsCountry136    7337
#define  idsCountry137    7338
#define  idsCountry138    7339
#define  idsCountry139    7340
#define  idsCountry140    7341
#define  idsCountry141    7342
#define  idsCountry142    7343
#define  idsCountry143    7344
#define  idsCountry144    7345
#define  idsCountry145    7346
#define  idsCountry146    7347
#define  idsCountry147    7348
#define  idsCountry148    7349
#define  idsCountry149    7350
#define  idsCountry150    7351
#define  idsCountry151    7352
#define  idsCountry152    7353
#define  idsCountry153    7354
#define  idsCountry154    7355
#define  idsCountry155    7356
#define  idsCountry156    7357
#define  idsCountry157    7358
#define  idsCountry158    7359
#define  idsCountry159    7360
#define  idsCountry160    7361
#define  idsCountry161    7362
#define  idsCountry162    7363
#define  idsCountry163    7364
#define  idsCountry164    7365
#define  idsCountry165    7366
#define  idsCountry166    7367
#define  idsCountry167    7368
#define  idsCountry168    7369
#define  idsCountry169    7370
#define  idsCountry170    7371
#define  idsCountry171    7372
#define  idsCountry172    7373
#define  idsCountry173    7374
#define  idsCountry174    7375
#define  idsCountry175    7376
#define  idsCountry176    7377
#define  idsCountry177    7378
#define  idsCountry178    7379
#define  idsCountry179    7380
#define  idsCountry180    7381
#define  idsCountry181    7382
#define  idsCountry182    7383
#define  idsCountry183    7384
#define  idsCountry184    7385
#define  idsCountry185    7386
#define  idsCountry186    7387
#define  idsCountry187    7388
#define  idsCountry188    7389
#define  idsCountry189    7390
#define  idsCountry190    7391
#define  idsCountry191    7392
#define  idsCountry192    7393
#define  idsCountry193    7394
#define  idsCountry194    7395
#define  idsCountry195    7396
#define  idsCountry196    7397
#define  idsCountry197    7398
#define  idsCountry198    7399
#define  idsCountry199    7400
#define  idsCountry200    7401
#define  idsCountry201    7402
#define  idsCountry202    7403
#define  idsCountry203    7404
#define  idsCountry204    7405
#define  idsCountry205    7406
#define  idsCountry206    7407
#define  idsCountry207    7408
#define  idsCountry208    7409
#define  idsCountry209    7410
#define  idsCountry210    7411
#define  idsCountry211    7412
#define  idsCountry212    7413
#define  idsCountry213    7414
#define  idsCountry214    7415
#define  idsCountry215    7416
#define  idsCountry216    7417
#define  idsCountry217    7418
#define  idsCountry218    7419
#define  idsCountry219    7420
#define  idsCountry220    7421
#define  idsCountry221    7422
#define  idsCountry222    7423
#define  idsCountry223    7424
#define  idsCountry224    7425
#define  idsCountry225    7426
#define  idsCountry226    7427
#define  idsCountry227    7428
#define  idsCountry228    7429
#define  idsCountry229    7430
#define  idsCountry230    7431
#define  idsCountry231    7432
#define  idsCountry232    7433
#define  idsCountry233    7434
#define  idsCountry234    7435
#define  idsCountry235    7436
#define  idsCountry236    7437
#define  idsCountry237    7438
#define  idsCountry238    7439
#define  idsCountry239    7440
#define  MAX_COUNTRY_NUM  239

#define ID_EXIT                         65535
#define COLSEL_MENU

#ifdef  COLSEL_MENU
// these are for the additional column selection 
#define MAX_VIEW_COLSEL                          64
#define IDR_MENU_LVCONTEXTMENU_COLSEL            8700
#define IDM_LVCONTEXTMENU_COLSEL_HPHONE          8701
#define IDM_LVCONTEXTMENU_COLSEL_BPHONE          8702
#define IDM_LVCONTEXTMENU_COLSEL_PAGER           8703
#define IDM_LVCONTEXTMENU_COLSEL_MOBILE          8704
#define IDM_LVCONTEXTMENU_COLSEL_BFAX            8705
#define IDM_LVCONTEXTMENU_COLSEL_HFAX            8706
#define IDM_LVCONTEXTMENU_COLSEL_COMPANY         8707
#define IDM_LVCONTEXTMENU_COLSEL_TITLE           8708
#define IDM_LVCONTEXTMENU_COLSEL_DEPT            8709
#define IDM_LVCONTEXTMENU_COLSEL_OFFICE          8710
#define IDM_LVCONTEXTMENU_COLSEL_BIRTHDAY        8711
#define IDM_LVCONTEXTMENU_COLSEL_ANNIVERSARY     8712

#endif // COLSEL_MENU
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wab32res\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ui.rc
//
#define IDC_FIND_BUTTON_FIND            3
#define IDC_FIND_BUTTON_CLEAR           4
#define IDC_FIND_BUTTON_TO              5
#define IDC_FIND_BUTTON_CC              6
#define IDC_FIND_BUTTON_BCC             7
#define IDC_FIND_BUTTON_PROPERTIES      8
#define IDC_FIND_BUTTON_DELETE          9
#define IDC_FIND_BUTTON_ADDTOWAB        10
#define IDC_FIND_BUTTON_SERVER_INFO     11
#define IDC_FIND_BUTTON_STOP            12
#define IDC_LDAPCANCEL_ANIMATE          30
#define IDC_LDAPCANCEL_STATIC_PLEASEWAIT 54
#define idsUnknownDisplayName           54
#define IDC_PRINT_FRAME_RANGE           56
#define IDC_PRINT_RADIO_ALL             57
#define IDC_PRINT_RADIO_SELECTED        58
#define IDC_PRINT_FRAME_STYLE           59
#define IDC_PRINT_RADIO_MEMO            60
#define IDC_PRINT_RADIO_CARD            61
#define IDC_PRINT_RADIO_PHONELIST       62
#define IDC_PRINT_STATIC_PRINTERNAMELABEL 63
#define IDC_PRINTCANCEL_STATIC_STATUS   64
#define IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME 67
#define IDC_FIND_BUTTON_CLOSE           68
#define IDC_DETAILS_OTHER_BUTTON_ADDTOGROUP 70
#define IDC_DETAILS_TRIDENT_GO          71
#define IDC_DETAILS_NOTES_STATIC_NOTES_GROUP 72
#define IDC_DETAILS_TRIDENT_STATIC      74
#define IDC_DETAILS_TRIDENT_STATIC_CAPTION 75
#define IDM_VIEW_GROUPSLIST             76
#define IDC_DETAILS_PERSONAL_CHECK_RICHINFO 77
#define IDC_DETAILS_NTMTG_STATIC_CAPTION2 81
#define IDC_DETAILS_NTMTG_STATIC_CAPTION3 82
#define IDC_DETAILS_NTMTG_COMBO_EMAIL   83
#define IDC_DETAILS_NTMTG_BUTTON_CALL   84
#define IDC_DETAILS_NTMTG_FRAME_SERVERS 85
#define IDC_DETAILS_NTMTG_COMBO_DEFAULTSERVER 86
#define IDC_DETAILS_NTMTG_COMBO_BACKUPSERVER 87
#define IDI_ICON_NETMEETING             89
#define IDC_DETAILS_NTMTG_FRAME_SERVERS2 89
#define IDC_DETAILS_NTMTG_EDIT_ADDSERVER 90
#define IDC_DETAILS_NTMTG_BUTTON_ADDSERVER 91
#define IDC_DETAILS_NTMTG_LIST_SERVERS  92
#define IDC_DETAILS_NTMTG_BUTTON_EDIT   93
#define IDC_DETAILS_NTMTG_BUTTON_REMOVE 94
#define IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT 95
#define IDC_DETAILS_CERT_COMBO          96
#define IDC_DETAILS_PERSONAL_STATIC_CAPTION3 97
#define IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB 98
#define IDC_FIND_COMBO_LIST             99
#define IDC_TAB_FIND                    100
#define IDM_FIND_CONTEXTMENU_CONTAINER  102
#define IDC_FIND_STATIC_LOGO            102
#define IDD_DIALOG_LDAPCANCEL           103
#define IDC_DETAILS_OPS_STATIC_ICON     103
#define IDD_DIALOG_PRINT                104
#define IDC_DETAILS_OPS_STATIC_CAPTION  104
#define IDD_DIALOG_PRINTCANCEL          105
#define IDC_DETAILS_OPS_STATIC_ETCHED   105
#define IDM_TOOLS_INTERNET_CALL         106
#define IDD_DETAILS_NTMTG               107
#define IDD_DETAILS_TRIDENT             108
#define IDC_DETAILS_HOME_COMBO_GENDER   108
#define IDD_DETAILS_OPS                 110
#define IDD_DIALOG_FIND                 139
#define IDC_FIND_STATIC_FINDIN          1149
#define IDC_FIND_STATIC_FRAMESEARCH     1150
#define IDC_FIND_STATIC_NAME            1151
#define IDC_FIND_EDIT_NAME              1152
#define IDC_FIND_STATIC_EMAIL           1153
#define IDC_FIND_EDIT_EMAIL             1154
#define IDC_FIND_STATIC_FINDIN2         1155
#define IDC_FIND_FRAME_LOOKFOR          1155
#define IDC_FIND_STATIC_STREET          1156
#define IDC_FIND_EDIT_STREET            1157
#define IDC_FIND_STATIC_PHONE           1158
#define IDC_FIND_EDIT_PHONE             1159
#define IDC_FIND_STATIC_ANY             1166
#define IDC_FIND_EDIT_ANY               1167
#define IDC_FIND_LIST_RESULTS           1168
#define IDC_FIND_ANIMATE1               1170
#define IDR_AVI_WABFIND                 1171
#define IDD_DIALOG_PRINTDLGORD          1538
#define IDC_DETAILS_NOTES_EDIT_GROUPS   2465
#define IDC_DETAILS_PERSONAL_STATIC_DISPLAYNAME 2779
#define IDC_DETAILS_PERSONAL_EDIT_DISPLAYNAME 2780
#define IDC_DETAILS_NTMTG_BUTTON_SETBACKUP 2781
#define IDC_OPTIONS_RADIO_OUTLOOK       2782
#define IDC_OPTIONS_RADIO_WAB           2783
#define IDC_ABOUT_EDIT_FILENAME         2784
#define IDC_ABOUT_STATIC_FILENAME       2785
#define IDC_ADDRBK_COMBO_CONT           2786
#define IDC_FIND_STATIC_ADVANCED        2789
#define IDC_FIND_COMBO_FIELD            2790
#define IDC_FIND_COMBO_CONDITION        2791
#define IDC_FIND_EDIT_ADVANCED          2792
#define IDC_FIND_LIST_CONDITIONS        2793
#define IDC_FIND_BUTTON_ADDCONDITION    2794
#define IDC_FIND_BUTTON_REMOVECONDITION 2795
#define IDI_ICON_ORG                    2796
#define IDD_DETAILS_ORG                 2797
#define IDC_DETAILS_ORG_STATIC_MANAGER  2800
#define IDC_DETAILS_ORG_LIST_MANAGER    2801
#define IDC_DETAILS_ORG_STATIC_REPORTS  2802
#define IDC_DETAILS_ORG_LIST_REPORTS    2803
#define IDD_DIALOG_SETME                2805
#define IDC_SETME_STATIC                2806
#define IDC_SETME_RADIO_CREATE          2807
#define IDC_SETME_RADIO_SELECT          2808
#define IDC_SETME_LIST                  2809
#define IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT     2810
#define IDC_DETAILS_SUMMARY_STATIC_NAME         2811
#define IDC_DETAILS_SUMMARY_STATIC_HOMEPHONE    2812
#define IDC_DETAILS_SUMMARY_STATIC_BUSINESSPHONE 2813
#define IDC_DETAILS_SUMMARY_STATIC_EMAIL        2814
#define IDC_DETAILS_SUMMARY_STATIC_BUSINESSFAX  2815
#define IDC_DETAILS_SUMMARY_STATIC_PAGER        2816
#define IDC_DETAILS_SUMMARY_STATIC_CELLULAR     2817
#define IDC_DETAILS_SUMMARY_STATIC_JOBTITLE     2818
#define IDC_DETAILS_SUMMARY_STATIC_DEPARTMENT   2819
#define IDC_DETAILS_SUMMARY_STATIC_OFFICE       2820
#define IDC_DETAILS_SUMMARY_STATIC_COMPANYNAME  2821
#define IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB  2822
#define IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB  2823
#define IDC_FIND_BUTTON_MORE                    2824
#define IDC_DETAILS_HOME_BUTTON_MAP             2825
#define IDC_DETAILS_BUSINESS_BUTTON_MAP         2826
#define IDC_DISTLIST_BUTTON_MAP                 2827

#define IDM_FIND_DIRECTORYSERVICES      40001
#define IDM_FIND_CONTAINERPROPERTIES    40002
#define IDD_DIALOG_OPTIONS              6000
#define IDD_DIALOG_REPORTS              6001
#define IDC_REPORTS_LIST                6002
#define IDC_REPORTS_BUTTON_PROPERTIES   6003
#define IDD_DIALOG_FOLDER               6004
#define IDC_FOLDER_STATIC               6005
#define IDC_FOLDER_EDIT_NAME            6006
#define IDD_DETAILS_SUMMARY             6007
#define IDC_PROGRESS                    6008
#define IDC_STATIC_PROGRESS_ICON        6009
#define IDI_ICON_IMPORT                 6010
#define IDI_ICON_PRINT                  6011
#define IDD_NEWCALL                     6012
#define IDC_NEWCALL_GROUP_DIALNUM       6013
#define IDC_NEWCALL_STATIC_CONTACT      6014
#define IDC_NEWCALL_BUTTON_PROPERTIES   6015
#define IDC_NEWCALL_BUTTON_CALL         6016
#define IDC_NEWCALL_STATIC_PHNUM        6017
#define IDC_NEWCALL_COMBO_PHNUM         6018
#define IDC_NEWCALL_COMBO_CONTACT       6019
#define IDC_NEWCALL_BUTTON_DIALPROP     6020
#define IDC_NEWCALL_BUTTON_CLOSE        6021
#define IDC_DETAILS_NOTES_FRAME_FOLDER  6022
#define IDC_DETAILS_NOTES_STATIC_FOLDER 6023
#define IDC_DETAILS_BUSINESS_STATIC_IPPHONE 6024
#define IDC_DETAILS_BUSINESS_EDIT_IPPHONE   6025
#define IDC_STATIC_ETCHED               6026

#define IDD_DIALOG_RUBY                 6027
#define IDC_RUBY_STATIC_LASTNAME        6028
#define IDC_RUBY_STATIC_FIRSTNAME       6029
#define IDC_RUBY_EDIT_YOMILASTNAME      6030
#define IDC_RUBY_EDIT_LASTNAME          6031
#define IDC_RUBY_EDIT_YOMIFIRSTNAME     6032
#define IDC_RUBY_EDIT_FIRSTNAME         6033
#define IDC_DETAILS_PERSONAL_BUTTON_RUBY    6034
#define IDC_DETAILS_PERSONAL_CHECK_WESTERN  6035
#define IDC_DETAILS_PERSONAL_STATIC_RUBYLAST    6036
#define IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST   6037
#define IDD_DETAILS_PERSONAL_RUBY       6038
#define IDM_FILE_SWITCHUSERS            6039
#define IDM_NOTIFY_REFRESHUSER          6040
#define IDM_FILE_SHOWALLCONTENTS        6041
#define IDI_ICON_GROUPOTHER             6042
#define IDI_ICON_PERSONAL               6043
#define IDC_FOLDER_CHECK_SHARE          6044
#define IDI_ICON_FOLDER                 6045
#define IDC_FOLDER_STATIC_CREATEDBY     6046
#define IDD_DIALOG_PRINTDLGEX           6047
#define IDC_DETAILS_PERSONAL_STATIC_TITLE 6048
#define IDC_DETAILS_PERSONAL_EDIT_TITLE 6049
#define IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS 6050
#define IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS 6051

#define IDI_ICON_FAMILY                         6052
#define IDC_DETAILS_FAMILY_STATIC_SPOUSE        6053
#define IDC_DETAILS_FAMILY_EDIT_SPOUSE          6054
#define IDC_DETAILS_FAMILY_STATIC_CHILDREN      6055
#define IDC_DETAILS_FAMILY_LIST_CHILDREN        6056
#define IDC_DETAILS_FAMILY_BUTTON_ADDCHILD      6057
#define IDC_DETAILS_FAMILY_BUTTON_EDITCHILD     6058
#define IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD   6059
#define IDC_DETAILS_FAMILY_STATIC_BIRTHDAY      6060
#define IDC_STATIC_BIRTHDAY                     6061
#define IDC_DETAILS_FAMILY_STATIC_ANNIVERSARY   6062
#define IDC_STATIC_ANNIVERSARY                  6063
#define IDC_DETAILS_FAMILY_DATE_BIRTHDAY        6064 // This ID is used for dynamically created MonthDate control
#define IDC_DETAILS_FAMILY_DATE_ANNIVERSARY     6065 // This ID is used for dynamically created MonthDate control
#define IDD_DETAILS_FAMILY                      6066

/************
//Add new Command IDs above here starting with last id number above
*************/


#define idsButton6                      4000
#define idsNoLocalSearchResults         4100
#define idsLDAPCancelMessage            4241
#define idsPrintDisplayName             4242
#define idsPrintTitle                   4243
#define idsPrintDepartment              4244
#define idsPrintOffice                  4245
#define idsPrintCompany                 4246
#define idsPrintBusinessPhone           4247
#define idsPrintBusinessFax             4248
#define idsPrintBusinessPager           4249
#define idsPrintHomePhone               4250
#define idsPrintHomeFax                 4251
#define idsPrintHomeCellular            4252
#define idsPrintBusinessWebPage         4253
#define idsPrintHomeWebPage             4254
#define idsPrintNotes                   4255
#define idsPrintEmail                   4256
#define idsPrintHomeAddress             4257
#define idsPrintBusinessAddress         4258
#define idsPrintAddressTemplate         4259
#define idsPrintGroupName               4260
#define idsPrintGroupMembers            4261
#define idsPrintDocTitle                4262
#define idsPrintBusCardAddressTemplate  4263
#define idsPrintBusCardBusinessPhone    4264
#define idsPrintBusCardBusinessFax      4265
#define idsPrintBusCardHomePhone        4266
#define idsPrintStatusBarMessage        4267
#define idsPrintNoPhone                 4268
#define idsPrintJobCannotStop           4269
#define idsPrintingPageNumber           4270
#define idsPrintFormattingName          4271
#define idsStatusBarCount               4272
#define idsNowAddingToWAB               4273
#define idsContinueAddingToWAB          4274
#define idsNotEnoughDiskSpace           4275
#define idsDefaultFontFace              4280
#define idsSearchDialogTitle            4281
#define idsSearchDialogTitleWithResults 4282
#define idsPhoneFontReduceBy            4284
#define idsPhoneTextSpaceTwips          4285
#define idsBusCardFontReduceBy          4286
#define idsPickUserSelect               4288
#define idsSendMailError                4291
#define idsDontDisplayInitials          4292
#define idsDetailsTridentTitle          4293
#define idsMenuDeleteRemove             4294
#define idsRemoveGroupFromAB            4295
#define idsRemoveGroupError             4296
#define idsRemoveSelectedFromGroup      4297
#define idsRemoveSelectedFromGroupAndAB 4298
#define idsPrintMenu                    4299
#define idsAboutMenu                    4300
#define idsGroupListMenu                4301
#define idsDefaultServer                4302
#define idsBackupServer                 4303
#define idsDetailsConferencingTitle     4304
#define idsMenuInternetCall             4305
#define idsCertsWithoutEmails           4306
#define idsImportCertNoEmail            4307
#define idsCertAlreadyExists            4308
#define idsUseLCID                      4309
#define idsEntryNotFound                4310
#define idsIncompleteConfInfo           4311
#define idsCouldNotAddSomeEntries       4312
#define idsPreferedPartnerCode          4313
#define idsFindConnecting               4315
#define idsLangPrintingOn               4316
#define idsYourName                     4317
#define idsOPSTitleString               4318
#define idsGender                       4318
#define idsGenderFemale                 4319
#define idsGenderMale                   4320
#define idsStoreChangeOnRestart         4321
#define idsNoFolderSearchResults        4322
#define idsFindTabTitle                 4323
#define idsFindTabTitle2                4324
#define idsLDAPFilterOption1            4325
#define idsLDAPFilterOption2            4326
#define idsLDAPFilterOption3            4327
#define idsLDAPFilterOption4            4328
#define idsLDAPFilterOption5            4329
#define LDAPFilterOptionMax                5 //just # of options
#define idsLDAPFilterField1             4340
#define idsLDAPFilterField2             4341
#define idsLDAPFilterField3             4342
#define idsLDAPFilterField4             4343
#define idsLDAPFilterField5             4344
#define LDAPFilterFieldMax                 5 //just # of fields
#define idsFindFilterAnd                4401
#define idsFindFilter                   4402
#define idsMenuNewFolder                4403
#define idsAddFolderName                4404
#define idsMenuPaste                    4405
#define idsRemoveFolderFromAB           4406
#define idsRemoveFolderError            4407
#define idsContacts                     4408
#define idsDetailsOrgTitle              4409
#define idsConfServer                   4410
#define idsConfEmail                    4411
#define idsConfAdd                      4412
#define idsConfUpdate                   4413
#define idsSendMailNoMapi               4414
#define idsInternetCallNoCallTo         4415
#define idsDetailsSummaryTitle          4416
#define idsSelectWABToImport            4417
#define idsEntryAlreadyInWAB            4418
#define idsImporting                    4419
#define idsImportingName                4420
#define idsImportError                  4421
#define idsImportComplete               4422
#define idsImportCompleteError          4423
#define idsImportProcessing             4424
#define idsUsersContacts                4425
#define idsAllContacts                  4426
#define idsCannotDelete                 4427
#define idsMenuEditProfile              4428
#define idsSomeHaveNoEmail              4429
#define idsNoDialerDataMsg              4430
#define idsPhoneLabelHome               4432
#define idsPhoneLabelBus                4433
#define idsPhoneLabelBus2               4434
#define idsPhoneLabelMobile             4435
#define idsPhoneLabelRadio              4436
#define idsPhoneLabelCar                4437
#define idsPhoneLabelOther              4438
#define idsPhoneLabelPager              4439
#define idsPhoneLabelAst                4440
#define idsPhoneLabelHome2              4441
#define idsPhoneLabelCompMain           4442
#define idsPhoneLabelFaxHome            4443
#define idsPhoneLabelFaxBus             4444
#define idsMenuDialer                   4445
#define idsNoPhoneNumAvailable          4446
#define idsUnableToPlaceCall            4447
#define idsUnableToShowProps            4448
#define idsInsufficientAddressInfo      4449
#define idsSharedContacts               4450
#define idsPhoneLabelIPPhone            4451
#define idsCaptionWithText              4452
#define idsMenuSwitchUser               4453
#define idsMenuShowAllContents          4454
#define idsLDAPSpecificErr              4455
#define idsFindDlgWidth                 4456
#define idsGroupOtherTabName            4457
#define idsName                         4458
#define idsDateTimeFormat               4459
#define idsNewChild                     4460
#define idsLVDateFormatString           4461
#define idsMenuExportWAB                4462
#define idsSelectWABToExport            4463
#define idsWABExportSuccess             4464
#define idsExportError                  4465

/************
//Add new String IDs above here starting with last id number above
*************/


// Reserve ids from 15000 to 15255 for extensible menu items
// When apps register a actino item, we will assign a 
// command id to its menu ..
#define IDM_EXTENDED_START              15000
#define IDM_EXTENDED_END                15255
#define MAX_EXTENDED_MENUS              256

#define IDM_LVCONTEXT_NEWFOLDER         8001
#define IDM_FILE_NEWFOLDER              8002
#define IDM_VIEW_FOLDERS1               8003
#define MAX_VIEW_FOLDERS                512     // When adding folders to the view menu on the fly, we reserve this 512 ids for added folders
#define IDM_VIEW_FOLDERSLAST            8515
#define IDM_SENDMAILTO_START            8532    
#define IDM_SENDMAILTO_MAX              64      // When creating SendMailTo contect menus on the fly, we reserve this 64 IDs for the Added Email addresses so we can identify them
#define IDM_EDIT_PASTE                  8601
#define IDM_LVCONTEXT_PASTE             8602
#define IDM_EDIT_SETME                  8603
#define IDR_MENU_LVCONTEXT_BROWSE_LV    8604
#define IDR_MENU_LVCONTEXT_TV           8605
#define IDR_MENU_LVCONTEXT_DL_LV        8606
#define IDR_MENU_LVCONTEXT_SELECT_LIST  8607
#define IDR_MENU_LVCONTEXT_FIND_LV      8608
#define IDM_DIALDLG_START               8609

/************
//Add new Menu IDs above here starting with last id number above
*************/

//////////////////////////////////////////////////////////////////////////
//  These special ids below are used for customizing the NT5 Print dialog
//
#define rad1        0x0420
#define rad2        0x0421
#define grp1        0x0430
#define grp2        0x0431
#define stc3        0x0442
#define edt2        0x0481
//////////////////////////////////////////////////////////////////////////

#define IDC_DETAILS_CERT_STATIC2        -1
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         109
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\abcont.c ===
/*
 *	ABCONT.C
 *
 *	Generic IMAPIContainer implementation.
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 */

#include "_apipch.h"

#ifdef WIN16
#undef GetLastError
#endif

static HRESULT
HrGetFirstRowInTad(LPTABLEDATA lpTableData,
  LPTABLEINFO lpTableInfo,
  ULONG ulcTableInfo,
  ULONG uliTable,
  ULONG * puliRow);

static HRESULT
HrGetLastRowInTad(LPTABLEDATA lpTableData,
  LPTABLEINFO lpTableInfo,
  ULONG ulcTableInfo,
  ULONG uliTable,
  ULONG * puliRow);

OlkContInfo *FindContainer(LPIAB lpIAB, ULONG cbEntryID, LPENTRYID lpEID);

NOTIFCALLBACK lHierarchyNotifCallBack;

extern CONTAINER_Vtbl vtblROOT;
extern CONTAINER_Vtbl vtblLDAPCONT;

extern HRESULT HrSmartResolve(LPIAB lpIAB, LPABCONT lpContainer, ULONG ulFlags,
  LPADRLIST lpAdrList, LPFlagList lpFlagList, LPAMBIGUOUS_TABLES lpAmbiguousTables);

//   extern CONTAINER_Vtbl vtblDISTLIST;

CONTAINER_Vtbl vtblCONTAINER = {
    VTABLE_FILL
//    (CONTAINER_QueryInterface_METHOD *)     IAB_QueryInterface, //bug 2707:this crashes
    CONTAINER_QueryInterface,
    (CONTAINER_AddRef_METHOD *)             WRAP_AddRef,
    CONTAINER_Release,
    (CONTAINER_GetLastError_METHOD *)       IAB_GetLastError,
    (CONTAINER_SaveChanges_METHOD *)        WRAP_SaveChanges,
    (CONTAINER_GetProps_METHOD *)           WRAP_GetProps,
    (CONTAINER_GetPropList_METHOD *)        WRAP_GetPropList,
    CONTAINER_OpenProperty,
    (CONTAINER_SetProps_METHOD *)           WRAP_SetProps,
    (CONTAINER_DeleteProps_METHOD *)        WRAP_DeleteProps,
    (CONTAINER_CopyTo_METHOD *)             WRAP_CopyTo,
    (CONTAINER_CopyProps_METHOD *)          WRAP_CopyProps,
    (CONTAINER_GetNamesFromIDs_METHOD *)    WRAP_GetNamesFromIDs,
    CONTAINER_GetIDsFromNames,    
    CONTAINER_GetContentsTable,
    CONTAINER_GetHierarchyTable,
    CONTAINER_OpenEntry,
    CONTAINER_SetSearchCriteria,
    CONTAINER_GetSearchCriteria,
    CONTAINER_CreateEntry,
    CONTAINER_CopyEntries,
    CONTAINER_DeleteEntries,
    CONTAINER_ResolveNames
};

//
//  Interfaces supported by this object
//
#define CONTAINER_cInterfaces 3
LPIID CONTAINER_LPIID[CONTAINER_cInterfaces] =
{
    (LPIID) &IID_IABContainer,
    (LPIID) &IID_IMAPIContainer,
    (LPIID) &IID_IMAPIProp
};

#define DISTLIST_cInterfaces 4
LPIID DISTLIST_LPIID[DISTLIST_cInterfaces] =
{
    (LPIID) &IID_IDistList,
    (LPIID) &IID_IABContainer,
    (LPIID) &IID_IMAPIContainer,
    (LPIID) &IID_IMAPIProp
};



SizedSSortOrderSet(1, sosPR_ENTRYID) =
{
	1, 0, 0,
	{
		PR_ENTRYID
	}
};

SizedSSortOrderSet(1, sosPR_ROWID) =
{
	1, 0, 0,
	{
		PR_ROWID
	}
};

SizedSPropTagArray(2, tagaInsKey) =
{
	2,
	{
		PR_INSTANCE_KEY,
		PR_NULL				// Space for PR_ROWID
	}
};


//
// container default properties
// Put essential props first
//
enum {
    icdPR_DISPLAY_NAME,
    icdPR_OBJECT_TYPE,
    icdPR_CONTAINER_FLAGS,
    icdPR_DISPLAY_TYPE,
    icdPR_ENTRYID,              // optional
    icdPR_DEF_CREATE_MAILUSER,  // optional
    icdPR_DEF_CREATE_DL,        // optional
    icdMax
};



/***************************************************************************

    Name      : HrSetCONTAINERAccess

    Purpose   : Sets access flags on a container object

    Parameters: lpCONTAINER -> Container object
                ulOpenFlags = MAPI flags: MAPI_MODIFY | MAPI_BEST_ACCESS

    Returns   : HRESULT

    Comment   : Set the access flags on the container.

***************************************************************************/
HRESULT HrSetCONTAINERAccess(LPCONTAINER lpCONTAINER, ULONG ulFlags) {
    ULONG ulAccess = IPROP_READONLY;

    switch (ulFlags& (MAPI_MODIFY | MAPI_BEST_ACCESS)) {
        case MAPI_MODIFY:
        case MAPI_BEST_ACCESS:
            ulAccess = IPROP_READWRITE;
            break;

        case 0:
            break;

        default:
            Assert(FALSE);
    }

    return(lpCONTAINER->lpPropData->lpVtbl->HrSetObjAccess(lpCONTAINER->lpPropData, ulAccess));
}


/***************************************************************************

    Name      : HrNewCONTAINER

    Purpose   : Creates a container object

    Parameters: lpIAB -> addrbook object
                ulType = {AB_ROOT, AB_WELL, AB_DL, AB_CONTAINER}
                lpInterface -> requested interface
                ulOpenFlags = flags
                cbEID = size of lpEID
                lpEID -> optional entryid of this object
                lpulObjType -> returned object type
                lppContainer -> returned IABContainer object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrNewCONTAINER(LPIAB lpIAB,
  ULONG ulType,
  LPCIID lpInterface,
  ULONG  ulOpenFlags,
  ULONG cbEID,
  LPENTRYID lpEID,
  ULONG  *lpulObjType,
  LPVOID *lppContainer)
{
    HRESULT hResult = hrSuccess;
    LPCONTAINER lpCONTAINER = NULL;
    SCODE sc;
    LPSPropValue lpProps = NULL;
    LPPROPDATA lpPropData = NULL;
    ULONG ulObjectType;
    BYTE bEntryIDType;
    ULONG cProps;
    TCHAR szDisplayName[MAX_PATH] = TEXT("");
    LPTSTR lpDisplayName = szDisplayName;
    BOOL fLoadedLDAP = FALSE;
	OlkContInfo *polkci;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    EnterCriticalSection(&lpIAB->cs);

    if (lpInterface != NULL) {
        if (memcmp(lpInterface, &IID_IABContainer, sizeof(IID)) &&
          memcmp(lpInterface, &IID_IDistList, sizeof(IID)) &&
          memcmp(lpInterface, &IID_IMAPIContainer, sizeof(IID)) &&
          memcmp(lpInterface, &IID_IMAPIProp, sizeof(IID))) {
            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);

            goto exit;
        }
    }

    //
    //  Allocate space for the CONTAINER structure
    //
    if ((sc = MAPIAllocateBuffer(sizeof(CONTAINER), (LPVOID *)&lpCONTAINER))
      != SUCCESS_SUCCESS) {
        return(ResultFromScode(sc));
    }

    // [PaulHi] 12/16/98
    // We don't set all structure variables so zero out first!
    ZeroMemory(lpCONTAINER, sizeof(CONTAINER));

	lpCONTAINER->pmbinOlk = NULL;

    switch (ulType) {
        case AB_ROOT:   // Root container object
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblROOT;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_ROOT;
#ifdef NEW_STUFF
            if (! LoadString(hinstMapiX, idsRootName, szDisplayName, ARRAYSIZE(szDisplayName))) {
                DebugTrace(TEXT("Can't load root name from resource\n"));
            }
#else
            StrCpyN(szDisplayName, TEXT("WAB Root Container"), ARRAYSIZE(szDisplayName));
#endif
            MAPISetBufferName(lpCONTAINER, TEXT("AB Root Container Object"));
            break;

        case AB_WELL:
            // What the heck is this supposed to be?
            Assert(FALSE);
            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto exit;
            break;

        case AB_DL: // Distribution List container
            ulObjectType = MAPI_DISTLIST;
            lpCONTAINER->lpVtbl = &vtblDISTLIST;
            lpCONTAINER->cIID = DISTLIST_cInterfaces;
            lpCONTAINER->rglpIID = DISTLIST_LPIID;
            bEntryIDType = WAB_DISTLIST;
            MAPISetBufferName(lpCONTAINER,  TEXT("AB DISTLIST Container Object"));
            break;

        case AB_PAB:    // "Default" PAB Container
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblCONTAINER;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_PAB;
		    if (pt_bIsWABOpenExSession) {
                // if this is an Outlook Session, then the container is the
                // first one in the list of Outlook containers
				Assert(lpIAB->lpPropertyStore->rgolkci);
				lpDisplayName = lpIAB->lpPropertyStore->rgolkci->lpszName;
			}
            else if(WAB_PABSHARED == IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL))
            {
                // WAB's "shared contacts" container
				if(FAILED(hResult = MAPIAllocateMore( sizeof(SBinary) + cbEID, lpCONTAINER, (LPVOID *)&lpCONTAINER->pmbinOlk)))
					goto exit;
                // The shared contacts container has a special entryid of 0 bytes
                // and NULL entryid to distinguish it from other entryids
                lpCONTAINER->pmbinOlk->cb = 0;
                lpCONTAINER->pmbinOlk->lpb = NULL;
                LoadString(hinstMapiX, idsSharedContacts, szDisplayName, ARRAYSIZE(szDisplayName));
            }
            else if(bAreWABAPIProfileAware(lpIAB) && bIsThereACurrentUser(lpIAB))
            {
                // if calling client asked for profile support and logging into the
                // identity manager was successful and returned a valid profile, then
                // we need to return the user's default folder as the PAB
                //
				if(FAILED(hResult = MAPIAllocateMore( sizeof(SBinary) + cbEID, lpCONTAINER, (LPVOID *)&lpCONTAINER->pmbinOlk)))
					goto exit;
                lpDisplayName = lpIAB->lpWABCurrentUserFolder->lpFolderName;
				lpCONTAINER->pmbinOlk->cb = lpIAB->lpWABCurrentUserFolder->sbEID.cb;//cbEID;
				lpCONTAINER->pmbinOlk->lpb = (LPBYTE)(lpCONTAINER->pmbinOlk + 1);
				CopyMemory(lpCONTAINER->pmbinOlk->lpb, lpIAB->lpWABCurrentUserFolder->sbEID.lpb, lpCONTAINER->pmbinOlk->cb);//lpEID, cbEID);
            }
            else // old style "Contacts" container 
            if (! LoadString(hinstMapiX, idsContacts, szDisplayName, ARRAYSIZE(szDisplayName))) {
                DebugTrace(TEXT("Can't load pab name from resource\n"));
            }
            MAPISetBufferName(lpCONTAINER,  TEXT("AB PAB Container Object"));
            break;

        case AB_CONTAINER: // regular container/folder - we have an identifying entryid
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblCONTAINER;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_CONTAINER;
		    if (pt_bIsWABOpenExSession || bIsWABSessionProfileAware(lpIAB)) 
            {
                // If this is an outlook session or if this is an identity-aware
                // session, look for the specified container and use it
				polkci = FindContainer(lpIAB, cbEID, lpEID);
				if (!polkci) 
                {
					hResult = ResultFromScode(MAPI_E_NOT_FOUND);
					goto exit;
				}
				lpDisplayName = polkci->lpszName;
				hResult = MAPIAllocateMore( sizeof(SBinary) + cbEID, lpCONTAINER,
				                    		(LPVOID *)&lpCONTAINER->pmbinOlk);
				if (FAILED(hResult))
					goto exit;
				lpCONTAINER->pmbinOlk->cb = cbEID;
				lpCONTAINER->pmbinOlk->lpb = (LPBYTE)(lpCONTAINER->pmbinOlk + 1);
				CopyMemory(lpCONTAINER->pmbinOlk->lpb, lpEID, cbEID);
			}
            MAPISetBufferName(lpCONTAINER,  TEXT("AB Container Object"));
            break;

        case AB_LDAP_CONTAINER: // LDAP container
            ulObjectType = MAPI_ABCONT;
            lpCONTAINER->lpVtbl = &vtblLDAPCONT;
            lpCONTAINER->cIID = CONTAINER_cInterfaces;
            lpCONTAINER->rglpIID = CONTAINER_LPIID;
            bEntryIDType = WAB_LDAP_CONTAINER;
            // Extract the server name from the LDAP entryid
            IsWABEntryID(cbEID, lpEID,&lpDisplayName,
                        NULL,NULL, NULL, NULL);
            fLoadedLDAP = InitLDAPClientLib();
            MAPISetBufferName(lpCONTAINER,  TEXT("AB LDAP Container Object"));
            break;

        default: // shouldnt' hit this one.
            MAPISetBufferName(lpCONTAINER,  TEXT("AB Container Object"));
            Assert(FALSE);
    }

    lpCONTAINER->lcInit = 1;
    lpCONTAINER->hLastError = hrSuccess;
    lpCONTAINER->idsLastError = 0;
    lpCONTAINER->lpszComponent = NULL;
    lpCONTAINER->ulContext = 0;
    lpCONTAINER->ulLowLevelError = 0;
    lpCONTAINER->ulErrorFlags = 0;
    lpCONTAINER->lpMAPIError = NULL;

    lpCONTAINER->ulType = ulType;
    lpCONTAINER->lpIAB = lpIAB;
    lpCONTAINER->fLoadedLDAP = fLoadedLDAP;

    // Addref our parent IAB object
    UlAddRef(lpIAB);

    //
    //  Create IPropData
    //
    if (FAILED(sc = CreateIProp(&IID_IMAPIPropData,
      (ALLOCATEBUFFER FAR *	) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *)	MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,
      &lpPropData))) {
        hResult = ResultFromScode(sc);

        goto exit;
    }

    MAPISetBufferName(lpPropData,  TEXT("lpPropData in HrNewCONTAINER"));

    if (sc = MAPIAllocateBuffer(icdMax * sizeof(SPropValue), &lpProps)) {
        hResult = ResultFromScode(sc);
    }

    // Set the basic set of properties on this container object such as 
    // display-name etc

    lpProps[icdPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    lpProps[icdPR_OBJECT_TYPE].Value.l = ulObjectType;

    lpProps[icdPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
    lpProps[icdPR_DISPLAY_NAME].Value.LPSZ = lpDisplayName;


    lpProps[icdPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS;
    lpProps[icdPR_CONTAINER_FLAGS].Value.l = (ulType == AB_ROOT) ? AB_UNMODIFIABLE : AB_MODIFIABLE;

    lpProps[icdPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    lpProps[icdPR_DISPLAY_TYPE].Value.l = DT_LOCAL;

    cProps = 4;

    // in addition to the above properties, add some additional ones depending
    // on what type of container this is...

    switch (ulType) {
        case AB_PAB:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
            if(lpCONTAINER->pmbinOlk)
            {
                // if we have an entryid for the container, just reuse it
			    lpProps[icdPR_ENTRYID].Value.bin.cb = lpCONTAINER->pmbinOlk->cb; //cbEID;
			    lpProps[icdPR_ENTRYID].Value.bin.lpb = lpCONTAINER->pmbinOlk->lpb;//(LPBYTE)lpEID;
            }
            else // create a wab entryid that we can hand about
            if (HR_FAILED(hResult = CreateWABEntryID(bEntryIDType,
                                                NULL, NULL, NULL,0, 0,
                                                (LPVOID) lpProps,
                                                (LPULONG) (&lpProps[icdPR_ENTRYID].Value.bin.cb),
                                                (LPENTRYID *)&lpProps[icdPR_ENTRYID].Value.bin.lpb))) 
            {
                goto exit;
            }
            cProps++;

            // Add the default template IDs used for creating new users
            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_DEF_CREATE_MAILUSER;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_MAILUSER,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;

            lpProps[icdPR_DEF_CREATE_DL].ulPropTag = PR_DEF_CREATE_DL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_DL,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_DL].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_DL].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;
            break;

        case AB_CONTAINER:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
			lpProps[icdPR_ENTRYID].Value.bin.cb = cbEID;
			lpProps[icdPR_ENTRYID].Value.bin.lpb = (LPBYTE)lpEID;
            cProps++;

            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_DEF_CREATE_MAILUSER;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_MAILUSER,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;

            lpProps[icdPR_DEF_CREATE_DL].ulPropTag = PR_DEF_CREATE_DL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_DL,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_DL].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_DL].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;
            break;

        case AB_ROOT:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
            lpProps[icdPR_ENTRYID].Value.bin.cb = 0;
            lpProps[icdPR_ENTRYID].Value.bin.lpb = NULL;
            cProps++;

            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_DEF_CREATE_MAILUSER;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_MAILUSER,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_MAILUSER].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;

            lpProps[icdPR_DEF_CREATE_DL].ulPropTag = PR_DEF_CREATE_DL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_DEF_DL,
              NULL, NULL, NULL,
              0, 0,
              (LPVOID) lpProps,                 // lpRoot
              (LPULONG) (&lpProps[icdPR_DEF_CREATE_DL].Value.bin.cb),
              (LPENTRYID *)&lpProps[icdPR_DEF_CREATE_DL].Value.bin.lpb))) {
                goto exit;
            }
            cProps++;
            break;

        case AB_LDAP_CONTAINER:
            lpProps[icdPR_ENTRYID].ulPropTag = PR_ENTRYID;
            lpProps[icdPR_ENTRYID].Value.bin.cb = cbEID;
            lpProps[icdPR_ENTRYID].Value.bin.lpb = (LPBYTE)lpEID;

            cProps++;

            // Hack!  Don't need PR_DEF_CREATE_* so use those slots for
            // PR_WAB_LDAP_SERVER.
            lpProps[icdPR_DEF_CREATE_MAILUSER].ulPropTag = PR_WAB_LDAP_SERVER;
            lpProps[icdPR_DEF_CREATE_MAILUSER].Value.LPSZ = lpDisplayName;

            cProps++;
            break;
    }

    //
    //  Set the default properties
    //
    if (HR_FAILED(hResult = lpPropData->lpVtbl->SetProps(lpPropData,
      cProps,
      lpProps,
      NULL))) {
        LPMAPIERROR lpMAPIError = NULL;

        lpPropData->lpVtbl->GetLastError(lpPropData,
          hResult,
          0, 			// Ansi only
          &lpMAPIError);

        goto exit;
    }

    // default object access is ReadOnly (means the container object can't
    // be modified but it's data can be modified)
    lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READONLY);

    lpCONTAINER->lpPropData = lpPropData;

    // All we want to do is initialize the Root container's critical section

    InitializeCriticalSection(&lpCONTAINER->cs);

    *lpulObjType = ulObjectType;
    *lppContainer = (LPVOID)lpCONTAINER;

exit:
    FreeBufferAndNull(&lpProps);

    if (HR_FAILED(hResult)) {
        if (fLoadedLDAP) {
            DeinitLDAPClientLib();
        }
        FreeBufferAndNull(&lpCONTAINER);
        UlRelease(lpPropData);
    }

    LeaveCriticalSection(&lpIAB->cs);

    return(hResult);
}


/***************************************************
 *
 *  ABContainer methods
 */

/*
 * IUnknown
 */

/***************************************************************************

    Name      : CONTAINER::QueryInterface

    Purpose   : Calls the IAB_QueryInterface correctly

    Parameters: 

    Returns   : 


***************************************************************************/
STDMETHODIMP
CONTAINER_QueryInterface(LPCONTAINER lpContainer,
  REFIID lpiid,
  LPVOID * lppNewObj)
{

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpContainer, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(E_INVALIDARG));
    }

    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpContainer->lpVtbl, 3*sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(ResultFromScode(E_INVALIDARG));
    }

    // Check to see that it's IAB_QueryInterface
    if (lpContainer->lpVtbl->QueryInterface != CONTAINER_QueryInterface) {
        // Not my jump table
        return(ResultFromScode(E_INVALIDARG));
    }

    // default to the IAB QueryInterface method
    return lpContainer->lpIAB->lpVtbl->QueryInterface(lpContainer->lpIAB, lpiid, lppNewObj);
}

/***************************************************************************

    Name      : CONTAINER::Release

    Purpose   : Releases the container object

    Parameters: lpCONTAINER -> Container object

    Returns   : current reference count

    Comment   : Decrememnt lpInit
                When lcInit == 0, release the parent objects and
                free up the lpCONTAINER structure

***************************************************************************/
STDMETHODIMP_(ULONG)
CONTAINER_Release(LPCONTAINER lpCONTAINER) {
#ifdef PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(1);
    }
#endif	// PARAMETER_VALIDATION

    EnterCriticalSection(&lpCONTAINER->cs);

    --lpCONTAINER->lcInit;

    if (lpCONTAINER->lcInit == 0) {
        // Remove this object from the objects currently on this session.
        // Not yet implemented...

        // Remove the associated lpPropData
        UlRelease(lpCONTAINER->lpPropData);

        // Set the Jump table to NULL.  This way the client will find out
        // real fast if it's calling a method on a released object.  That is,
        // the client will crash.  Hopefully, this will happen during the
        // development stage of the client.
        lpCONTAINER->lpVtbl = NULL;

        // Free error string if allocated from MAPI memory.
        FreeBufferAndNull(&(lpCONTAINER->lpMAPIError));

        // Release the IAB since we addref'd it in root object creation.
        UlRelease(lpCONTAINER->lpIAB);

        if (lpCONTAINER->fLoadedLDAP) {
            DeinitLDAPClientLib();
        }

        LeaveCriticalSection(&lpCONTAINER->cs);
        DeleteCriticalSection(&lpCONTAINER->cs);
        // Need to free the object

        FreeBufferAndNull(&lpCONTAINER);
        return(0);
    }

    LeaveCriticalSection(&lpCONTAINER->cs);
    return(lpCONTAINER->lcInit);
}


/*
 * IMAPIProp
 */

/***************************************************************************

    Name      : CONTAINER::OpenProperty

    Purpose   : Opens an object interface on a particular property

    Parameters: lpCONTAINER -> Container object
                ulPropTag = property to open
                lpiid -> requested interface
                ulInterfaceOptions =
                ulFlags =
                lppUnk -> returned object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_OpenProperty(LPCONTAINER lpCONTAINER,
  ULONG ulPropTag,
  LPCIID lpiid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppUnk)
{
	LPIAB lpIAB;
	LPSTR lpszMessage = NULL;
	ULONG ulLowLevelError = 0;
	HRESULT hr;

#ifdef	PARAMETER_VALIDATION
	 // Validate parameters

	 // Check to see if it has a jump table
	if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
		// No jump table found
		hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
		return(hr);
	}


    if ((ulInterfaceOptions & ~(MAPI_UNICODE)) || (ulFlags & ~(MAPI_DEFERRED_ERRORS))) {
        return(hr = ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (FBadOpenProperty(lpCONTAINER, ulPropTag, lpiid, ulInterfaceOptions, ulFlags,
      lppUnk)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }


#endif	// PARAMETER_VALIDATION

#ifdef IABCONTAINER_OPENPROPERTY_SUPPORT // ??Were we supporting this? - vm 3/25/97??

    EnterCriticalSection(&lpCONTAINER->cs);


    lpIAB = lpCONTAINER->lpIAB;

    //
    //  Check to see if I need a display table
    //
    if (ulPropTag == PR_CREATE_TEMPLATES) {
        //
        //  Looking for the display table
        //

        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        //  Check to see if we already have a table
        EnterCriticalSection(&lpIAB->cs);

        //
        //  Get a view from the TAD
        //
        hr = lpIAB->lpOOData->lpVtbl->HrGetView(
          lpIAB->lpOOData,
          (LPSSortOrderSet)&sosPR_ROWID,
          NULL,
          0,
          (LPMAPITABLE *)lppUnk);

        //	 Leave the critical section after we get our view.
        LeaveCriticalSection(&lpIAB->cs);

#ifdef DEBUG
        if (hr == hrSuccess) {
            MAPISetBufferName(*lppUnk,  TEXT("OneOff Data VUE1 Object"));
        }
#endif

        goto err;  // Maybe error, maybe not...
    } else if (ulPropTag == PR_CONTAINER_CONTENTS) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = lpCONTAINER->lpVtbl->GetContentsTable(lpCONTAINER,
          ulInterfaceOptions,
          (LPMAPITABLE *)lppUnk);
        goto err;

    } else if (ulPropTag == PR_CONTAINER_HIERARCHY) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = lpCONTAINER->lpVtbl->GetHierarchyTable(lpCONTAINER,
          ulInterfaceOptions,
          (LPMAPITABLE *)lppUnk);
        goto err;
    }


    //
    //  Don't recognize the property they want opened.
    //

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

err:
    LeaveCriticalSection(&lpCONTAINER->cs);

#else // IABCONTAINER_OPENPROPERTY_SUPPORT

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

#endif // IABCONTAINER_OPENPROPERTY_SUPPORT

    DebugTraceResult(CONTAINER_OpenProperty, hr);
    return(hr);
}

/***************************************************************************

    Name      : CONTAINER_GetGetIDsFromNames

    Returns   : HRESULT

    Comment   : Just default this to the standard GetIdsFromNames
                that we use everywhere

***************************************************************************/
STDMETHODIMP
CONTAINER_GetIDsFromNames(LPCONTAINER lpRoot,  ULONG cPropNames,
                            LPMAPINAMEID * lppPropNames, ULONG ulFlags, LPSPropTagArray * lppPropTags)
{
    return HrGetIDsFromNames(lpRoot->lpIAB,  
                            cPropNames,
                            lppPropNames, ulFlags, lppPropTags);
}


/*
-
-   HrDupeOutlookContentsTable
*
*   Since Outlook is unable to provide a Unicode contents table and we can't fo into the
*   outlook contents table to modify it's data, we have to recreate the contentstable to
*   create a WAB version of it ..
*   This is likely to be a big performance issue .. :-(
*
*/
HRESULT HrDupeOutlookContentsTable(LPMAPITABLE lpOlkTable, LPMAPITABLE * lppTable)
{
    HRESULT hr = S_OK;
    ULONG ulCount = 0, iRow = 0;
    DWORD dwIndex = 0;
    LPSRowSet lpsRow = 0, lpSRowSet = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;
    LPTABLEDATA lpTableData = NULL;
    SCODE sc = 0;
    // Create a table object
    if (FAILED(sc = CreateTable(  NULL,                                 // LPCIID
                                  (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
                                  (ALLOCATEMORE FAR *)  MAPIAllocateMore,
                                  MAPIFreeBuffer,
                                  NULL,                                 // lpvReserved,
                                  TBLTYPE_DYNAMIC,                      // ulTableType,
                                  PR_ENTRYID,                        // ulPropTagIndexCol,
                                  (LPSPropTagArray)&ITableColumnsRoot,  // LPSPropTagArray lpptaCols,
                                  &lpTableData))) 
    {                     
        DebugTrace(TEXT("CreateTable failed %x\n"), sc);
        hr = ResultFromScode(sc);
        goto out;
    }
    Assert(lpTableData);

    ((TAD *)lpTableData)->bMAPIUnicodeTable = TRUE; //this is only called for retreiving unicode tables so the flag is true

    // How big is the outlook table?
    if(HR_FAILED(hr = lpOlkTable->lpVtbl->GetRowCount(lpOlkTable, 0, &ulCount)))
        goto out;

    DebugTrace( TEXT("Table contains %u rows\n"), ulCount);

    // Allocate the SRowSet
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + ulCount * sizeof(SRow),&lpSRowSet))) 
    {
        DebugTrace(TEXT("Allocation of SRowSet -> %x\n"), sc);
        hr = ResultFromScode(sc);
        goto out;
    }

	MAPISetBufferName(lpSRowSet, TEXT("Outlook_ContentsTable_Copy SRowSet"));
	ZeroMemory( lpSRowSet, (UINT) (sizeof(SRowSet) + ulCount * sizeof(SRow)));

    lpSRowSet->cRows = ulCount;
    iRow = 0;

    // Copy UNICODE versions of all the properties from the Outlook table
    for (dwIndex = 0; dwIndex < ulCount; dwIndex++) 
    {
        // Get the next row
        if(HR_FAILED(hr = lpOlkTable->lpVtbl->QueryRows(lpOlkTable, 1, 0, &lpsRow)))
            goto out;

        if (lpsRow) 
        {
            LPSPropValue lpSPVNew = NULL;

            Assert(lpsRow->cRows == 1); // should have exactly one row

            ///****INVESTIGATE if we can reuse this prop array without duplicating***/
            if(HR_FAILED(hr = HrDupeOlkPropsAtoWC(lpsRow->aRow[0].cValues, lpsRow->aRow[0].lpProps,  &lpSPVNew)))
                goto out;

            // Attach the props to the SRowSet
            lpSRowSet->aRow[iRow].lpProps = lpSPVNew;
            lpSRowSet->aRow[iRow].cValues = lpsRow->aRow[0].cValues;
            lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

            FreeProws(lpsRow);

            iRow++;
        }
    }

    // Add all this data we just created to the the Table.
    if (hr = lpTableData->lpVtbl->HrModifyRows(lpTableData, 0,  lpSRowSet)) 
    {
        DebugTraceResult( TEXT("ROOT_GetContentsTable:HrModifyRows"), hr);
        goto out;
    }

    hr = lpTableData->lpVtbl->HrGetView(lpTableData, NULL, ContentsViewGone, 0, lppTable);

out:

    FreeProws(lpSRowSet);

    // Cleanup table if failure
    if (HR_FAILED(hr)) 
    {
        if (lpTableData) 
        {
            UlRelease(lpTableData);
        }
    }
    return hr;
}




/***************************************************************************

    Name      : CONTAINER::GetContentsTable

    Purpose   : Opens a table of the contents of the container.

    Parameters: lpCONTAINER -> Container object

                ulFlags =   
                WAB_PROFILE_CONTENTS - When caller opens the PAB container and want's to
                    get the complete set of contents for the current identity 
                    without wanting to enumerate each sub-container seperately
                    - they can specify this flag and we'll return everything 
                    corresponding to the current identity all in the same table
                WAB_CONTENTTABLE_NODATA - Internal only flag .. GetContentsTable normally
                    loads a full contents table and if this is followed by SetColumns,
                    SetColumns also loads a full contents table .. so we basically
                    do the same work twice - to reduce this wasted work, caller can
                    specify not to load data the first time but caller must call
                    SetColumns immediately (or this will probably fault)
                                     
                lppTable -> returned table object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_GetContentsTable (LPCONTAINER lpCONTAINER,
	ULONG ulFlags,
	LPMAPITABLE * lppTable)
{

	HRESULT hResult;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

#ifdef	PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_UNICODE|WAB_PROFILE_CONTENTS|WAB_CONTENTTABLE_NODATA)) {
        DebugTraceArg(CONTAINER_GetContentsTable, TEXT("Unknown flags"));
        //return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppTable, sizeof(LPMAPITABLE))) {
        DebugTraceArg(CONTAINER_GetContentsTable, TEXT("Invalid Flags"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    if(pt_bIsWABOpenExSession)
    {
        ULONG ulOlkFlags = ulFlags;

        // This is a WABOpenEx session using outlooks storage provider
        if(!lpCONTAINER->lpIAB->lpPropertyStore->hPropertyStore)
            return MAPI_E_NOT_INITIALIZED;

        // Since the Outlook store doesn't understand the private flags, these
        // flags need to be filtered out otherwise the outlook store
        // provider will fail with E_INVALIDARG or something
        //
        if(ulOlkFlags & WAB_PROFILE_CONTENTS)
            ulOlkFlags &= ~WAB_PROFILE_CONTENTS;
        if(ulOlkFlags & WAB_CONTENTTABLE_NODATA)
            ulOlkFlags &= ~WAB_CONTENTTABLE_NODATA;

        if(ulFlags & MAPI_UNICODE && !pt_bIsUnicodeOutlook)
        {
            // This version of Outlook can't handle Unicode so don't tell it to else it'll barf
            ulOlkFlags &= ~MAPI_UNICODE;
        }
        // Outlook provides it's own implementation of GetContentsTable for
        // efficiencies sake otherwise recreating the table going through the
        // WAB layer would be just too darned slow ...
        {
            LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) lpCONTAINER->lpIAB->lpPropertyStore->hPropertyStore;

			Assert((lpCONTAINER->ulType == AB_PAB) ||
					(lpCONTAINER->ulType == AB_CONTAINER));

            hResult = lpWSP->lpVtbl->GetContentsTable(lpWSP,
            										  lpCONTAINER->pmbinOlk,
                                                      ulOlkFlags,
                                                      lppTable);

            DebugPrintTrace((TEXT("WABStorageProvider::GetContentsTable returned:%x\n"),hResult));

            if( ulFlags & MAPI_UNICODE && !pt_bIsUnicodeOutlook &&
                *lppTable && !HR_FAILED(hResult))                     
            {
                // This version of Outlook can't handle Unicode 
                // but caller wants unicode, so now we have to go in and tweak this data 
                // manually .. 
                LPMAPITABLE lpWABTable = NULL;

                if(!HR_FAILED(hResult = HrDupeOutlookContentsTable(*lppTable, &lpWABTable)))
                {
                    (*lppTable)->lpVtbl->Release(*lppTable);
                    *lppTable = lpWABTable;
                }

            }

            return hResult;
        }
    }

    // Create a new contents table object
    hResult = NewContentsTable((LPABCONT)lpCONTAINER,
      lpCONTAINER->lpIAB,
      ulFlags,
      NULL,
      lppTable);

    if(!(HR_FAILED(hResult)) && *lppTable &&
        (ulFlags & WAB_PROFILE_CONTENTS) && !(ulFlags & WAB_CONTENTTABLE_NODATA))
    {
        // There is a problem with searching multiple subfolders in that the data does not
        // come back sorted when it is collated across multiple folders. 
        // We need to sort the table before we return it .. it's somewhat inefficient to do this
        // sort at this point .. ideally the data should be added to the table sorted...
        LPSSortOrderSet lpSortCriteria = NULL;
        SCODE sc = MAPIAllocateBuffer(sizeof(SSortOrderSet)+sizeof(SSortOrder), &lpSortCriteria);
        if(!sc)
        {
            lpSortCriteria->cCategories = lpSortCriteria->cExpanded = 0;
            lpSortCriteria->cSorts = 1;
            lpSortCriteria->aSort[0].ulPropTag = PR_DISPLAY_NAME;
            if(!(((LPTAD)(*lppTable))->bMAPIUnicodeTable))
                lpSortCriteria->aSort[0].ulPropTag = CHANGE_PROP_TYPE( lpSortCriteria->aSort[0].ulPropTag, PT_STRING8);
            lpSortCriteria->aSort[0].ulOrder = TABLE_SORT_ASCEND;
	    hResult = (*lppTable)->lpVtbl->SortTable((*lppTable), lpSortCriteria, 0);
	    FreeBufferAndNull(&lpSortCriteria);
        }
        else
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        }
    }
	return(hResult);
}


/***************************************************************************

    Name      : CONTAINER::GetHierarchyTable

    Purpose   : Returns the merge of all the root hierarchy tables

    Parameters: lpCONTAINER -> Container object
                ulFlags =
                lppTable -> returned table object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_GetHierarchyTable (LPCONTAINER lpCONTAINER,
	ULONG ulFlags,
	LPMAPITABLE * lppTable)
{
    LPTSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr = hrSuccess;

#ifdef	PARAMETER_VALIDATION
    // Validate parameters
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // See if I can set the return variable
    if (IsBadWritePtr (lppTable, sizeof (LPMAPITABLE))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check flags:
    //  The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS


    if (ulFlags & ~(CONVENIENT_DEPTH|MAPI_DEFERRED_ERRORS|MAPI_UNICODE)) {
        DebugTraceArg(CONTAINER_GetHierarchyTable, TEXT("Invalid Flags"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif

    EnterCriticalSection(&lpCONTAINER->cs);

    if (lpCONTAINER->ulType != AB_ROOT) {
        //
        //  Wrong version of this object.  Pretend this object doesn't exist.
        //
        hr = ResultFromScode(MAPI_E_NO_SUPPORT);
        goto out;
    }


    //
    //  Get a view from the TAD
    //
    hr = lpCONTAINER->lpIAB->lpTableData->lpVtbl->HrGetView(
      lpCONTAINER->lpIAB->lpTableData,
      (LPSSortOrderSet) &sosPR_ROWID,
      NULL,
      0,
      lppTable);

    if (HR_FAILED(hr)) {
        DebugTrace(TEXT("IAB_GetHierarchyTable Get Tad View failed\n"));
        goto out;
    }

#ifdef DEBUG
    if (hr == hrSuccess) {
        MAPISetBufferName(*lppTable,  TEXT("MergeHier VUE Object"));
    }
#endif

    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    if (!(ulFlags & CONVENIENT_DEPTH)) {
        SRestriction restrictDepth;
        SPropValue spvDepth;

        spvDepth.ulPropTag = PR_DEPTH;
        spvDepth.Value.l = 0;

        restrictDepth.rt = RES_PROPERTY;
        restrictDepth.res.resProperty.relop = RELOP_EQ;
        restrictDepth.res.resProperty.ulPropTag = PR_DEPTH;
        restrictDepth.res.resProperty.lpProp = &spvDepth;

        if (HR_FAILED(hr = (*lppTable)->lpVtbl->Restrict(*lppTable, &restrictDepth, 0))) {
            DebugTrace(TEXT("IAB_GetHierarchyTable restriction failed\n"));
            goto out;
        }
    }

out:
    LeaveCriticalSection(&lpCONTAINER->cs);

    DebugTraceResult(CONTAINER_GetHierarchyTable, hr);
    return(hr);
}


/***************************************************************************

    Name      : HrMergeTableRows

    Purpose   : Creates a merged hierarchy r of all the root level
                hierarchies from the AB providers installed.

    Parameters: lptadDst -> TABLEDATA object
                lpmtSrc -> source hierarchy table
                ulProviderNum =

    Returns   : HRESULT

    Comment   : NOTE: This may be irrelevant for WAB.

***************************************************************************/
HRESULT
HrMergeTableRows(LPTABLEDATA lptadDst,
  LPMAPITABLE lpmtSrc,
  ULONG ulProviderNum)
{
    HRESULT hResult = hrSuccess;
    SCODE   sc;
    ULONG   ulRowID = ulProviderNum * ((LONG)IAB_PROVIDER_HIERARCHY_MAX + 1);
    LPSRowSet lpsRowSet = NULL;
    LPSRow lprowT;

    if (hResult = HrQueryAllRows(lpmtSrc, NULL, NULL, NULL, 0, &lpsRowSet)) {
        DebugTrace(TEXT("HrMergeTableRows() - Could not query provider rows.\n"));
        goto ret;
    }

    if (lpsRowSet->cRows >= IAB_PROVIDER_HIERARCHY_MAX) {
        DebugTrace(TEXT("HrMergeTableRows() - Provider has too many rows.\n"));
        hResult = ResultFromScode(MAPI_E_TABLE_TOO_BIG);
        goto ret;
    }


    //	Set the ROWID to the end since will be looping in reverse order.
    ulRowID =   ulProviderNum * ((LONG) IAB_PROVIDER_HIERARCHY_MAX + 1)
      + lpsRowSet->cRows;
    for (lprowT = lpsRowSet->aRow + lpsRowSet->cRows;
      --lprowT >= lpsRowSet->aRow;) {
        ULONG cbInsKey;
        LPBYTE lpbNewKey = NULL;

        //	Make ulRowID zero based
        ulRowID--;

        //
        //  Munge the PR_INSTANCE_KEY
        //
        if ((lprowT->lpProps[0].ulPropTag != PR_INSTANCE_KEY)
          || !(cbInsKey = lprowT->lpProps[0].Value.bin.cb)
          || ((cbInsKey + sizeof(ULONG)) > UINT_MAX)
          || IsBadReadPtr(lprowT->lpProps[0].Value.bin.lpb, (UINT) cbInsKey)) {
            //	Can't create our INSTANCE_KEY without a valid provider
            //	INSTANCE_KEY
            DebugTrace(TEXT("HrMergeTableRows - Provider row has no valid PR_INSTANCE_KEY"));
            continue;
        }

        //	Allocate a new buffer for munging the instance key
        if (FAILED(sc = MAPIAllocateMore(cbInsKey + sizeof(ULONG), lprowT->lpProps, &lpbNewKey))) {
            hResult = ResultFromScode(sc);
            DebugTrace(TEXT("HrMergeTableRows() - MAPIAllocMore Failed"));
            goto ret;
        }

        *((LPULONG) lpbNewKey) = ulProviderNum;
        CopyMemory(lpbNewKey + sizeof(ULONG), lprowT->lpProps[0].Value.bin.lpb, cbInsKey);
        lprowT->lpProps[0].ulPropTag = PR_INSTANCE_KEY;
        lprowT->lpProps[0].Value.bin.lpb = lpbNewKey;
        lprowT->lpProps[0].Value.bin.cb = cbInsKey + sizeof(ULONG);

        //	Add the ROWID so that the original order of the providers is
        //	preserved
        Assert((PROP_ID(lprowT->lpProps[1].ulPropTag) == PROP_ID(PR_ROWID))
          || (PROP_ID(lprowT->lpProps[1].ulPropTag) == PROP_ID(PR_NULL)));
        lprowT->lpProps[1].ulPropTag = PR_ROWID;
        lprowT->lpProps[1].Value.l = ulRowID;
    }

    //	Now put them into the TAD all at once.
    //	Note!	We now rely on PR_ROWID to keep the rows in order
    if (HR_FAILED(hResult = lptadDst->lpVtbl->HrModifyRows(lptadDst, 0, lpsRowSet))) {
        DebugTrace(TEXT("HrMergeTableRows() - Failed to modify destination TAD.\n"));
    }

ret:
    //
    //  Free up the row set
    //
    FreeProws(lpsRowSet);

    return(hResult);
}


/***************************************************************************

    Name      : CONTAINER::OpenEntry

    Purpose   : Opens an entry

    Parameters: lpCONTAINER -> Container object
                cbEntryID = size of entryid
                lpEntryID -> EntryID to open
                lpInterface -> requested interface or NULL for default.
                ulFlags =
                lpulObjType -> returned object type
                lppUnk -> returned object

    Returns   : HRESULT

    Comment   : Calls up to IAB's OpenEntry.

***************************************************************************/
STDMETHODIMP
CONTAINER_OpenEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk)
{

#ifdef	PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, OpenEntry, lpVtbl)) {
    // jump table not large enough to support this method
    return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryids are valid
    /*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID)lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(CONTAINER_OpenEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
           TEXT("Undefined bits set in EntryID flags\n"));
    }
    */
    // Don't check the interface parameter unless the entry is something
    // MAPI itself handles. The provider should return an error if this
    // parameter is something that it doesn't understand.
    // At this point, we just make sure it's readable.
    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("lpInterface fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }	

    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("Unknown flags used"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr((LPVOID)lpulObjType, sizeof(ULONG))) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("lpulObjType"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr((LPVOID)lppUnk, sizeof(LPUNKNOWN))) {
        DebugTraceArg(CONTAINER_OpenEntry, TEXT("lppUnk"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    // Should just call IAB::OpenEntry()...
    return(lpCONTAINER->lpIAB->lpVtbl->OpenEntry(lpCONTAINER->lpIAB,
      cbEntryID,
      lpEntryID,
      lpInterface,
      ulFlags,
      lpulObjType,
      lppUnk));
}


STDMETHODIMP
CONTAINER_SetSearchCriteria(LPCONTAINER lpCONTAINER,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags)
{

#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, SetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(CONTAINER_SetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the restriction
    if (lpRestriction && IsBadReadPtr(lpRestriction, sizeof(SRestriction))) {
        DebugTraceArg(CONTAINER_SetSearchCriteria, TEXT("Bad Restriction parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (FBadEntryList(lpContainerList)) {
        DebugTraceArg(CONTAINER_SetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulSearchFlags & ~(STOP_SEARCH | RESTART_SEARCH | RECURSIVE_SEARCH
      | SHALLOW_SEARCH | FOREGROUND_SEARCH | BACKGROUND_SEARCH)) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : CONTAINER::GetSearchCriteria

    Purpose   :

    Parameters: lpCONTAINER -> Container object
                ulFlags =
                lppRestriction -> Restriction to apply to searches
                lppContainerList ->
                lpulSearchState -> returned state

    Returns   : HRESULT

    Comment   : Not implemented in WAB.

***************************************************************************/
STDMETHODIMP
CONTAINER_GetSearchCriteria(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState)
{
#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, GetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_UNICODE)) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Unknown Flags"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    // ensure we can write the restriction
    if (lppRestriction && IsBadWritePtr(lppRestriction, sizeof(LPSRestriction))) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Bad Restriction write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (lppContainerList && IsBadWritePtr(lppContainerList, sizeof(LPENTRYLIST))) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpulSearchState && IsBadWritePtr(lpulSearchState, sizeof(ULONG))) {
        DebugTraceArg(CONTAINER_GetSearchCriteria, TEXT("lpulSearchState fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : CONTAINER::CreateEntry

    Purpose   : Creates an entry in the container

    Parameters: lpCONTAINER -> Container object
                
                  cbEntryID = size of entryid
                lpEntryID -> entryID of template
                [ cbEID and lpEID are the Template Entryids
                  In reality, these are actually flags that just tell
                  us internally what kind of object to create ]

                ulCreateFlags =
                lppMAPIPropEntry -> returned MAPIProp object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_CreateEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppMAPIPropEntry)
{
    BYTE bType;

#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, CreateEntry, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Bad object/Vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryid are bad
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID) lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(CONTAINER_CreateEntry, TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  TEXT("Undefined bits set in EntryID flags\n"));
    } else {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("lpEntryID NULL"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
*/

    if (ulCreateFlags & ~(CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE
      | CREATE_REPLACE | CREATE_MERGE)) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppMAPIPropEntry, sizeof(LPMAPIPROP))) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Bad MAPI Property write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
				
#endif	// PARAMETER_VALIDATION

#ifdef NEVER
    if (lpCONTAINER->ulType == AB_ROOT)
        return ResultFromScode(MAPI_E_NO_SUPPORT);
#endif // NEVER

    // What kind of entry are we creating?
    // Default is MailUser

    // The passed in entryid is the Tempalte entry ID
    bType = IsWABEntryID(cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL);

    if (bType == WAB_DEF_MAILUSER || cbEntryID == 0) {
        //
        //  Create a new (in memory) entry and return it's mapiprop
        //
        return(HrNewMAILUSER(lpCONTAINER->lpIAB, lpCONTAINER->pmbinOlk, MAPI_MAILUSER, ulCreateFlags, lppMAPIPropEntry));
    } else if (bType == WAB_DEF_DL) {
        //
        // Create a new (in memory) distribution list and return it's mapiprop?
        return(HrNewMAILUSER(lpCONTAINER->lpIAB, lpCONTAINER->pmbinOlk, MAPI_DISTLIST, ulCreateFlags, lppMAPIPropEntry));
    } else {
        DebugTrace(TEXT("CONTAINER_CreateEntry got unknown template entryID\n"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
}


/***************************************************************************

    Name      : CONTAINER::CopyEntries

    Purpose   : Copies a list of entries into this container.

    Parameters: lpCONTAINER -> Container object
                lpEntries -> List of entryid's to copy
                ulUIParam = HWND
                lpPropgress -> progress dialog structure
                ulFlags =

    Returns   : HRESULT

    Comment   : Not implemented in WAB.

***************************************************************************/
STDMETHODIMP
CONTAINER_CopyEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG_PTR ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags)
{
#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, CopyEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulUIParam && ! IsWindow((HWND)ulUIParam)) {
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Invalid window handle"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpProgress && IsBadReadPtr(lpProgress, sizeof(IMAPIProgress))) {
        DebugTraceArg(CONTAINER_CopyEntries, TEXT("Bad MAPI Progress parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(AB_NO_DIALOG | CREATE_CHECK_DUP_LOOSE)) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Unknown flags used"));
    //   return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : CONTAINER::DeleteEntries

    Purpose   : Delete entries from this container.

    Parameters: lpCONTAINER -> Container object
                lpEntries -> list of entryid's to delete
                ulFlags =

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_DeleteEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulFlags)
{
    ULONG i;
    HRESULT hResult = hrSuccess;
    ULONG cDeleted = 0;
    ULONG cToDelete;

#ifndef DONT_ADDREF_PROPSTORE
    {
        SCODE sc;
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpCONTAINER->lpIAB->lpPropertyStore)))) {
            hResult = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
    }
#endif

#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpCONTAINER, CONTAINER_, DeleteEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(CONTAINER_DeleteEntries, TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list

    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(CONTAINER_DeleteEntries, TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags) {
        DebugTraceArg(CONTAINER_CreateEntry, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION

    // List of entryids is in lpEntries.  This is a counted array of
    // entryid SBinary structs.
    cToDelete = lpEntries->cValues;


    // Delete each entry
    for (i = 0; i < cToDelete; i++)
    {
        if(0 != IsWABEntryID(lpEntries->lpbin[i].cb,
                             (LPENTRYID) lpEntries->lpbin[i].lpb,
                             NULL, NULL, NULL, NULL, NULL))
        {
            DebugTrace(TEXT("CONTAINER_DeleteEntries got bad entryid of size %u\n"), lpEntries->lpbin[i].cb);
            continue;
        }

        hResult = DeleteCertStuff((LPADRBOOK)lpCONTAINER->lpIAB, (LPENTRYID)lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb);

        hResult = HrSaveHotmailSyncInfoOnDeletion((LPADRBOOK) lpCONTAINER->lpIAB, &(lpEntries->lpbin[i]));

        if (HR_FAILED(hResult = DeleteRecord(lpCONTAINER->lpIAB->lpPropertyStore->hPropertyStore,
                                            &(lpEntries->lpbin[i])))) {
            DebugTraceResult( TEXT("DeleteEntries: DeleteRecord"), hResult);
            continue;
        }
        cDeleted++;
    }


    if (! hResult) {
        if (cDeleted != cToDelete) {
            hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            DebugTrace(TEXT("DeleteEntries deleted %u of requested %u\n"), cDeleted, cToDelete);
        }
    }

#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpCONTAINER->lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif
    return(hResult);
}


/***************************************************************************

    Name      : CONTAINER::ResolveNames

    Purpose   : Resolve names from this container.

    Parameters: lpCONTAINER -> Container object
                lptagColSet -> Set of property tags to get from each
                  resolved match.
                ulFlags = flags (none valid)
                        WAB_IGNORE_PROFILES means that even if this is 
                        a profile enabled session, search the whole WAB,
                        not just the current container
                        WAB_RESOLVE_ALL_EMAILS - valid if trying to resolve an 
                        e-mail address and we want to search across all e-mail addresses
                        not just the default. Should be used sparingly since it's a labor
                        intensive search
                        MAPI_UNICODE - Adrlist strings are in UNICODE and should return them
                        in Unicode
                lpAdrList -> [in] set of addresses to resolve, [out] resolved
                  addresses.
                lpFlagList -> [in/out] resolve flags.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
STDMETHODIMP
CONTAINER_ResolveNames(LPCONTAINER lpRoot,
  LPSPropTagArray lptagaColSet,
  ULONG ulFlags,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList)
{
    LPADRENTRY lpAdrEntry;
    ULONG i, j;
    ULONG ulCount = 1;
    LPSBinary rgsbEntryIDs = NULL;
    HRESULT hResult = hrSuccess;
    LPMAPIPROP lpMailUser = NULL;
    LPSPropTagArray lpPropTags;
    LPSPropValue lpPropArray = NULL;
    LPSPropValue lpPropArrayNew = NULL;
    ULONG ulObjType, cPropsNew;
    ULONG cValues;
    SCODE sc = SUCCESS_SUCCESS;
    LPTSTR lpsz = NULL;

#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpRoot->lpIAB->lpPropertyStore)))) {
            hResult = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif

#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpRoot, CONTAINER_, ResolveNames, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(CONTAINER_ResolveNames, TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // BUGBUG: Should also check lptagColSet, lpAdrList and lpFlagList!
    if (ulFlags&(~(WAB_IGNORE_PROFILES|WAB_RESOLVE_ALL_EMAILS|MAPI_UNICODE))) {
        DebugTraceArg(CONTAINER_ResolveNames, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif	// PARAMETER_VALIDATION

    // if no set of props to return is specified, return the default set
    lpPropTags = lptagaColSet ? lptagaColSet : (LPSPropTagArray)&ptaResolveDefaults;

    if(ulFlags & WAB_RESOLVE_ALL_EMAILS)
    {
        hResult = HrSmartResolve(lpRoot->lpIAB, (LPABCONT)lpRoot, 
                                WAB_RESOLVE_ALL_EMAILS | (ulFlags & MAPI_UNICODE ? WAB_RESOLVE_UNICODE : 0),
                                lpAdrList, lpFlagList, NULL);
        // If it's too complex, then just search normally
        if (MAPI_E_TOO_COMPLEX != hResult) {
            goto exit;
        }
        else {
            hResult = hrSuccess;
        }
    }


    // search for each name in the lpAdrList
    for (i = 0; i < lpAdrList->cEntries; i++) 
    {

        // Make sure we don't resolve an entry which is already resolved.
        if (lpFlagList->ulFlag[i] == MAPI_RESOLVED) 
        {
            continue;
        }

        lpAdrEntry = &(lpAdrList->aEntries[i]);


        // Search for this address

        // BUGBUG: For now, we only resolve perfect matches in the PR_DISPLAY_NAME or PR_EMAIL_ADDRESS
        // all other properties in ADRLIST are ignored

        // Look through the ADRENTRY for a PR_DISPLAY_NAME and create an SPropRestriction
        // to pass down to the property store.
        for (j = 0; j < lpAdrEntry->cValues; j++) 
        {
            ULONG ulPropTag = lpAdrEntry->rgPropVals[j].ulPropTag;
            if(!(ulFlags & MAPI_UNICODE) && PROP_TYPE(ulPropTag)==PT_STRING8)
                ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

            if ( ulPropTag == PR_DISPLAY_NAME || ulPropTag == PR_EMAIL_ADDRESS) 
            {
                ULONG Flags = AB_FUZZY_FAIL_AMBIGUOUS | AB_FUZZY_FIND_ALL;

                if(!(ulFlags & WAB_IGNORE_PROFILES))
                {
                    // if we didn't ask to surpress profile awareness,
                    // and profile awareness is enabled, restrict this search to
                    // the single folder
                    if(bAreWABAPIProfileAware(lpRoot->lpIAB))
                        Flags |= AB_FUZZY_FIND_PROFILEFOLDERONLY;
                }

                ulCount = 1;

                // Search the property store
                Assert(lpRoot->lpIAB->lpPropertyStore->hPropertyStore);

                if(ulFlags & MAPI_UNICODE)
                {
                    lpsz =  lpAdrEntry->rgPropVals[j].Value.lpszW;
                }
                else
                {
                    LocalFreeAndNull(&lpsz);
                    lpsz = ConvertAtoW(lpAdrEntry->rgPropVals[j].Value.lpszA);
                }
                
                if (HR_FAILED(hResult = HrFindFuzzyRecordMatches(lpRoot->lpIAB->lpPropertyStore->hPropertyStore,
				                                                  lpRoot->pmbinOlk,
                                                                  lpsz,
                                                                  Flags,
                                                                  &ulCount,                  // IN: number of matches to find, OUT: number found
                                                                  &rgsbEntryIDs))) 
                {
                    if (ResultFromScode(hResult) == MAPI_E_AMBIGUOUS_RECIP) 
                    {
                        lpFlagList->ulFlag[i] = MAPI_AMBIGUOUS;
                        continue;
                    } else 
                    {
                        DebugTraceResult( TEXT("HrFindFuzzyRecordMatches"), hResult);
                        goto exit;
                    }
                }

                if (ulCount) {  // Was a match found?
                    Assert(rgsbEntryIDs);
                    if (rgsbEntryIDs) 
                    {
                        if (ulCount == 1) 
                        {
                            // Open the entry and read the properties you care about.

                            if (HR_FAILED(hResult = lpRoot->lpVtbl->OpenEntry(lpRoot,
                                                                              rgsbEntryIDs[0].cb,    // cbEntryID
                                                                              (LPENTRYID)(rgsbEntryIDs[0].lpb),    // entryid of first match
                                                                              NULL,             // interface
                                                                              0,                // ulFlags
                                                                              &ulObjType,       // returned object type
                                                                              (LPUNKNOWN *)&lpMailUser))) 
                            {
                                // Failed!  Hmmm.
                                DebugTraceResult( TEXT("ResolveNames OpenEntry"), hResult);
                                goto exit;
                            }

                            Assert(lpMailUser);

                            if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                                                  lpPropTags,   // lpPropTagArray
                                                                                  (ulFlags & MAPI_UNICODE) ? MAPI_UNICODE : 0,
                                                                                  &cValues,     // how many properties were there?
                                                                                  &lpPropArray))) 
                            {
                                DebugTraceResult( TEXT("ResolveNames GetProps"), hResult);
                                goto exit;
                            }

                            UlRelease(lpMailUser);
                            lpMailUser = NULL;


                            // Now, construct the new ADRENTRY
                            // (Allocate a new one, free the old one.
                            Assert(lpPropArray);

                            // Merge the new props with the ADRENTRY props
                            if (sc = ScMergePropValues(lpAdrEntry->cValues,
                                                      lpAdrEntry->rgPropVals,           // source1
                                                      cValues,
                                                      lpPropArray,                      // source2
                                                      &cPropsNew,
                                                      &lpPropArrayNew)) 
                            {               
                                goto exit;
                            }

                            // [PaulHi] 2/1/99  GetProps now returns the requested tag string
                            // types.  So if our client is non-UNICODE make sure we convert any
                            // UNICODE string properties to ANSI.
                            if (!(ulFlags & MAPI_UNICODE))
                            {
                                if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), (LPSPropValue ) lpPropArrayNew, (ULONG) cPropsNew, 0))
                                    goto exit;
                            }

                            // Free the original prop value array
                            FreeBufferAndNull((LPVOID *) (&(lpAdrEntry->rgPropVals)));

                            lpAdrEntry->cValues = cPropsNew;
                            lpAdrEntry->rgPropVals = lpPropArrayNew;

                            FreeBufferAndNull(&lpPropArray);


                            // Mark this entry as found.
                            lpFlagList->ulFlag[i] = MAPI_RESOLVED;
                        } else 
                        {
                            DebugTrace(TEXT("ResolveNames found more than 1 match... MAPI_AMBIGUOUS\n"));
                            lpFlagList->ulFlag[i] = MAPI_AMBIGUOUS;
                        }

                        FreeEntryIDs(lpRoot->lpIAB->lpPropertyStore->hPropertyStore,
                                     ulCount,
                                     rgsbEntryIDs);
                    }
                }

                break;
            }
        }
    }


exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpRoot->lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif
    FreeBufferAndNull(&lpPropArray);

    UlRelease(lpMailUser);

    if(!(ulFlags & MAPI_UNICODE))
        LocalFreeAndNull(&lpsz);

    return(hResult);
}


#ifdef NOTIFICATION // save for notifications
/***************************************************************************

    Name      : lTableNotifyCallBack

    Purpose   : Callback function for notifications

    Parameters: lpvContext ->
                cNotif =
                lpNotif ->

    Returns   :

    Comment   :

***************************************************************************/
long STDAPICALLTYPE
lTableNotifyCallBack(LPVOID lpvContext,
  ULONG cNotif,
  LPNOTIFICATION lpNotif)
{
    LPTABLEINFO lpTableInfo = (LPTABLEINFO)lpvContext;
    HRESULT     hResult;
    LPSRowSet   lpsrowsetProv = NULL;
    LPIAB       lpIAB = lpTableInfo->lpIAB;
    LPTABLEDATA lpTableData;
    ULONG       ulcTableInfo;
    LPTABLEINFO pargTableInfo;

    Assert(lpvContext);
    Assert(lpNotif);
    Assert(lpTableInfo->lpTable);
    Assert(lpTableInfo->lpIAB);
    Assert(! IsBadWritePtr(lpTableInfo->lpIAB, sizeof(IAB)));


    //	To avoid deadlock we will NOT enter the Address Books critical
    //	section.  The Address Book must enter our critical section BEFORE
    //	it modifies anything our callback needs


    // if the container is null then the tableinfo structure is being
    // used to keep track of the open one off tables otherwise its
    // being used to keep track of the open hierarchy tables.
    if (lpTableInfo->lpContainer == NULL) {
        // open one off table data
        lpTableData = lpIAB->lpOOData;
        ulcTableInfo = lpIAB->ulcOOTableInfo;
        pargTableInfo = lpIAB->pargOOTableInfo;
    } else {
        // open hierarchy table data
        lpTableData		=lpIAB->lpTableData;
        ulcTableInfo	=lpIAB->ulcTableInfo;
        pargTableInfo	=lpIAB->pargTableInfo;

        // While we here, blow away the SearchPath cache

#if defined (WIN32) && !defined (MAC)
        if (fGlobalCSValid) {
            EnterCriticalSection(&csMapiSearchPath);
        } else {
            DebugTrace(TEXT("lTableNotifyCallback: WAB32.DLL already detached.\n"));
        }
#endif
		
        FreeBufferAndNull(&(lpIAB->lpspvSearchPathCache));
        lpIAB->lpspvSearchPathCache = NULL;

#if defined (WIN32) && !defined (MAC)
        if (fGlobalCSValid) {
            LeaveCriticalSection(&csMapiSearchPath);
        } else {
            DebugTrace(TEXT("lTableNotifyCallback: WAB32.DLL got detached.\n"));
        }
#endif
    }

    switch (lpNotif->info.tab.ulTableEvent) {
        case TABLE_ROW_ADDED:
        case TABLE_ROW_DELETED:
        case TABLE_ROW_MODIFIED:
        case TABLE_CHANGED: {
            ULONG 		uliTable;

            // table has changed. We need to delete all the rows of
            // this table in the tad and then add all the rows currently
            // in that table to the tad.  We need to find the start and
            // end row indexes of the tables data in the tad.

            // get the index of the given table in the table info array
            for (uliTable=0; uliTable < ulcTableInfo; uliTable++) {
                if (pargTableInfo[uliTable].lpTable==lpTableInfo->lpTable) {
                    break;
                }
            }

            Assert(uliTable < ulcTableInfo);

            //	Delete all the rows of the table in the tad by querying
            //	all the rows from the TEXT("restricted") view for this provider
            //	and then calling HrDeleteRows.
            //	We'll add all the new rows back later
            if (HR_FAILED(hResult = HrQueryAllRows(lpTableInfo->lpmtRestricted,
              NULL, NULL, NULL, 0, &lpsrowsetProv))) {
                DebugTrace(TEXT("lTableNotifyCallBack() - Can't query rows from restricted view.\n"));
                goto ret;
            }

            if (lpsrowsetProv->cRows) {
                // Only call HrDeleteRows if there are rows to delete
                if (HR_FAILED(hResult = lpTableData->lpVtbl->HrDeleteRows(lpTableData, 0, lpsrowsetProv, NULL))) {
                    DebugTrace(TEXT("lTableNotifyCallBack() - Can't delete rows.\n"));
                    goto ret;
                }
            }

            // Add the contents of the provider table back to the TAD.

            // Seek to the beginning of the input table
            if (HR_FAILED(hResult = lpTableInfo->lpTable->lpVtbl->SeekRow(lpTableInfo->lpTable , BOOKMARK_BEGINNING, 0, NULL))) {
                // table must be empty
                goto ret;
            }

            //	Add all rows from the given provider back to the merged table.
            //	NOTE!	HrMergeTableRows takes a 1 based provider NUMBER not
            //			a provider index.
            if (HR_FAILED(hResult = HrMergeTableRows(lpTableData, lpTableInfo->lpTable, uliTable + 1))) {
                //$BUG	Handle per provider errors.
                DebugTrace(TEXT("lTableNotifyCallBack() - HrMergeTableRows returns (hResult = 0x%08lX)\n"), hResult);
            }

            break;
        }
    }
		
ret:
    // free the row set returned from MAPITABLE::QueryRows
    FreeProws(lpsrowsetProv);

    return(0);
}


/***************************************************************************

    Name      : HrGetBookmarkInTad

    Purpose   : Returns the row number in the tabledata object of the row
                that corresponds to the row at the bookmark in the given table.

    Parameters: lpTableData ->
                lpTable ->
                Bookmark =
                puliRow ->

    Returns   : HRESULT

    Comment   :

***************************************************************************/
static HRESULT
HrGetBookmarkInTad(LPTABLEDATA lpTableData,
  LPMAPITABLE lpTable,
  BOOKMARK Bookmark,
  ULONG * puliRow)
{
    LPSRowSet lpsRowSet = NULL;
    LPSRow lpsRow;
    ULONG uliProp;
    HRESULT hResult = hrSuccess;

    Assert(lpTableData);
    Assert(lpTable);
    Assert(puliRow);

    // seek to the bookmark in the given table
    if (HR_FAILED(hResult=lpTable->lpVtbl->SeekRow(
      lpTable,
      Bookmark,
      0,
      NULL))) {
        goto err;
    }

    // get the row
    if (HR_FAILED(hResult=lpTable->lpVtbl->QueryRows(
      lpTable,
      (Bookmark==BOOKMARK_END ? -1 : 1),
      TBL_NOADVANCE,
      &lpsRowSet))) {
        goto err;
    }

    // find the entryid in the property value array
    for (uliProp = 0; uliProp < lpsRowSet->aRow[0].cValues; uliProp++) {
        if (lpsRowSet->aRow[0].lpProps[uliProp].ulPropTag == PR_ENTRYID) {
            break;
        }
    }

    Assert(uliProp < lpsRowSet->aRow[0].cValues);

    // Look for the row in the tad with the same entryid.
    if (HR_FAILED(hResult=lpTableData->lpVtbl->HrQueryRow(
      lpTableData,
      lpsRowSet->aRow[0].lpProps+uliProp,
      &lpsRow,
      puliRow))) {
        // can't find the row in the table data should never happen
        goto err;
    }

    // free the row set returned from QueryRows on the tad
    FreeBufferAndNull(&lpsRow);

err:
    // free the row set returned from MAPITABLE::QueryRows
    FreeProws(lpsRowSet);
    return(hResult);
}
#endif

/*
-   FindContainer
-
*   Given an entryid, searches in the cached list of containers for
*   the structure containing the container so that we can get
*   additional container properties out of the strucutre painlessly
*   
*   Returns a pointer to an OlkContInfo structure so don't need to free
*   the returned value
*/
OlkContInfo *FindContainer(LPIAB lpIAB, ULONG cbEID, LPENTRYID lpEID)
{
	ULONG iolkci, colkci;
    BOOL ul=FALSE;
	OlkContInfo *rgolkci;

	Assert(lpIAB);
	Assert(lpIAB->lpPropertyStore);

    // If the WAB session is Profile Aware, then the WAB's list of containers
    // is cached on the IAB object
    if(bIsWABSessionProfileAware(lpIAB))
    {
        colkci = lpIAB->cwabci;
        rgolkci = lpIAB->rgwabci;
    }
    else // it's in the list of the Outlook containers
    {
	    colkci = lpIAB->lpPropertyStore->colkci;
	    rgolkci = lpIAB->lpPropertyStore->rgolkci;
    }

    // if we didn't find any cached info, nothing more to do
    if(!colkci || !rgolkci)
        return NULL;

	for (iolkci = 1; iolkci < colkci; iolkci++)
	{
        Assert(rgolkci[iolkci].lpEntryID);
        if (rgolkci[iolkci].lpEntryID &&
            (cbEID == rgolkci[iolkci].lpEntryID->cb))
        {
            // Look for the match and return that item
            Assert(rgolkci[iolkci].lpEntryID->lpb);
            if(cbEID && rgolkci[iolkci].lpEntryID->lpb &&
                (0 == memcmp((LPVOID) lpEID,(LPVOID)rgolkci[iolkci].lpEntryID->lpb, cbEID)))
            {
                ul = TRUE;
                break;
            }
        }
    }
	return(ul ? &(rgolkci[iolkci]) : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\vcard\versit\2.0\wchar.cpp ===
#include "stdafx.h"
#include "wchar.h"


wchar_t* wcscpy(wchar_t* dst, const wchar_t* src)
{
	wchar_t* result = dst;
	while (*src) {
		*dst++ = *src++;
	}
	*dst = 0;
	return result;
}

wchar_t* wcscat(wchar_t* dst, const wchar_t* src)
{
	wchar_t* result = dst;
	dst += wcslen(dst);
	while (*src) {
		*dst++ = *src++;
	}
	*dst = 0;
	return result;
}

int wcscmp(const wchar_t* s1, const wchar_t* s2)
{
	while (*s1 && *s2) {
		if (*s1 < *s2)
			return -1;
		else if (*s1 > *s2)
			return 1;
		s1++;
		s2++;
	}
	if (!*s1 && !*s2)
		return 0;
	else if (*s1)
		return 1;
	else
		return -1;
}

int wcslen(const wchar_t* str)
{
	int len = 0;
	while (*str++) len++;
	return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wab32res\resrc2.h ===
/*
- Resrc2.h - Resource IDs for all the misc wab files other than wab32.dll
-
-
*/
#include ".\commonrc.h"

/*****************************************************************************
-
-   Resources for WAB.EXE
-
******************************************************************************/

#define IDI_ICON1                       101

#define idsWABTitle                     2001
#define idsWABFileNotFound              2002
#define idsWABOpenError                 2003
#define idsWABOpenFileTitle             2004
#define idsWABOpenFileFilter            2005
#define idsWABNewFileTitle              2006
#define idsWABUsage                     2007
#define idsWABPathNotFound              2008
#define idsWABInvalidCmdLine            2009
#define idsWABTitleWithFileName         2010
#define idsWABAddressError              2011
#define idsWABOpenErrorMemory           2012
#define idsWABOpenErrorLocked           2013
#define idsWABOpenErrorCorrupt          2014
#define idsWABOpenErrorDisk             2015
#define idsWABAddressErrorMissing       2016
#define idsWABOpenErrorNotWAB           2017
#define idsWABOpenErrorNotWABName       2018
#define idsWABOpenVCardError            2019
#define idsWABOpenLDAPUrlError          2020
#ifdef WIN16
#define idsWABUsage1                    2100
#endif

#define idsAddToABPaneTitle             2030
#define idsCertificateViewTitle         2031

#define IDD_DIALOG_DEFAULT_VCARD_VIEWER 2200
#define IDC_CHECK_ALWAYS                2201
#define IDC_STATIC_ASK                  2202
#define IDC_STATIC_ICON                 2203

#define IDC_ADD_TO_ADDRESS_BOOK         2204
#define IDD_CERTPROP_ADDRESS_BOOK       2205
#define IDC_ADD_TO_ADDRESS_BOOK_FRAME   2206
#define IDC_ADD_TO_ADDRESS_BOOK_TEXT    2207

#define MAX_RESOURCE_STRING             260



/*****************************************************************************
-
-   Resources for WABMig.EXE
-
******************************************************************************/

// Dialog Boxes
#define IDM_EXIT                        5
#define IDD_ImportDialog                1101
#define IDD_Options                     1102
#define IDD_ImportReplace               1103
#define IDD_ErrorImport                 1104
#define IDD_ExportDialog                1105
#define IDD_ErrorExport                 1106
#define IDD_CSV_EXPORT_WIZARD_FILE      1107
#define IDD_CSV_EXPORT_WIZARD_PICK      1108
#define IDD_ExportReplace               1109
#define IDD_CSV_IMPORT_WIZARD_FILE      1110
#define IDD_CSV_IMPORT_WIZARD_MAP       1111
#define IDD_CSV_CHANGE_MAPPING          1112


// Control Identifiers
// Import Dialog
#define IDC_Progress                    1113
#define IDC_Import                      1114
#define IDC_Options                     1115
#define IDC_Message                     1116
#define IDC_Target                      1117
#define IDC_Export                      1118

// Options Dialog
#define IDC_Replace_Always              1119
#define IDC_Replace_Never               1120
#define IDC_Replace_Prompt              1121

// Replace Dialog
#define IDC_YesToAll                    1122
#define IDC_NoToAll                     1123
#define IDC_Replace_Message             1124
#define IDC_AddDuplicate                1125
#define IDC_AddDuplicateAll             1126

// Error Dialog
#define IDC_NoMoreError                 1127
#define IDC_ErrorMessage                1128

// Test Menu
#define IDC_Test_Replace                1129
#define IDC_Test_Error                  1130

// CSV Import and Export Wizards
#define IDE_CSV_EXPORT_NAME             1131
#define IDC_BROWSE                      1132
#define IDLV_PICKER                     1133
#define IDC_WIZARD_BITMAP               1134
#define IDLV_MAPPER                     1135
#define IDE_CSV_IMPORT_NAME             1136
#define IDC_CHANGE_MAPPING              1137
#define IDC_CSV_CHANGE_MAPPING_TEXT_FIELD           1138
#define IDC_CSV_MAPPING_COMBO                       1139
#define IDC_CSV_MAPPING_SELECT                      1140
#define IDS_NETSCAPE_FILE_SPEC                      1143
#define IDS_NETSCAPE_EXPORT_TITLE                   1144
#define IDS_NETSCAPE_IMPORT_TITLE                   1145
#define IDE_NETSCAPE_IMPORT_FILE_ERROR              1146
#define IDE_NETSCAPE_EXPORT_FILE_ERROR              1147
#define IDS_NETSCAPE_IMPORT_COLLISION               1148
#define IDS_REPLACE_MESSAGE                         1149
#define IDS_NETSCAPE_MAILTO		                    1150
#define IDS_MAILTO					                1151
#define IDS_SMTP					                1152
#define IDS_STRING_SELECTPATH		                1153				
#define IDS_MESSAGE				                    1154
#define IDS_ADDRESS_HTM			                    1155
#define IDS_ERROR					                1156
#define IDS_INVALID_FILE			                1157
#define IDS_NO_ENTRY				                1158
#define IDS_ALIASOF				                    1159
#define IDS_DUMMY					                1160
#define IDS_LOOPING				                    1161
#define IDS_ENTRY_NOIMPORT			                1162
#define IDS_NETSCAPE_PATH			                1163
#define IDS_NETSCAPE_FILE			                1164
#define IDS_NETSCAPE_TITLE			                1165
#define IDS_ATHENA16_PATH			                1166
#define IDS_ATHENA16_FILE			                1167
#define IDS_ATHENA16_TITLE			                1168
#define IDS_EUDORA_PATH			                    1169
#define IDS_EUDORA_FILE			                    1170
#define IDS_EUDORA_TITLE			                1171
#define IDS_NETSCAPE_REGKEY		                    1172
#define IDS_NETSCAPE_ADDRESS_PATH	                1173
#define IDS_EUDORA_REGKEY			                1174
#define IDS_EUDORA_ADDRESS_PATH	                    1175
#define IDS_GERNERIC_ERROR			                1176
#define IDS_WAB_ERROR				                1177
#define IDS_ERROR_ADDRESSBOOK		                1178
#define IDS_EUDORA_ADDRESS			                1179
#define IDS_EUDORA_TOC				                1180
#define IDS_EOL					                    1187
#define IDS_NICKNAME				                1188
#define IDS_ALIAS_ID				                1189
#define IDS_ALIAS_OF				                1190
#define IDS_MEMORY					                1191
#define IDS_NONAME					                1192
#define IDS_EUDORA_NAME			                    1193
#define IDS_IMPORT_BUTTON                           1194
#define IDS_EUDORA_SUBDIR_NAME                      1195
#define IDS_EUDORA_GENERIC_SUFFIX                   1196
#define IDS_EUDORA_32_REGKEY                        1197
#define IDS_EUDORA_DEFAULT_INSTALL                  1198
#define IDS_NETSCAPE_ADDRESSBOOK                    1199

// String Identifiers
#define IDS_STATE_LOGGING_IN            1500
#define IDS_STATE_IMPORT_IDLE           1501
#define IDS_STATE_IMPORT_MU             1502
#define IDS_STATE_IMPORT_DL             1503
#define IDS_STATE_IMPORT_ERROR          1504
#define IDS_STATE_IMPORT_CANCEL         1505
#define IDS_STATE_IMPORT_COMPLETE       1506
#define IDS_STATE_EXPORT_IDLE           1511
#define IDS_STATE_EXPORT_MU             1512
#define IDS_STATE_EXPORT_DL             1513
#define IDS_STATE_EXPORT_ERROR          1514
#define IDS_STATE_EXPORT_CANCEL         1515
#define IDS_STATE_EXPORT_COMPLETE       1516
#define IDS_REPLACE_MESSAGE_IMPORT_1    1530
#define IDS_REPLACE_MESSAGE_IMPORT_2    1531
#define IDS_REPLACE_MESSAGE_EXPORT_1    1532
#define IDS_REPLACE_MESSAGE_EXPORT_2    1533
#define IDS_ERROR_MAPI_LOGON            1534
#define IDS_ERROR_EMAIL_ADDRESS_1       1535
#define IDS_ERROR_EMAIL_ADDRESS_2       1536
#define IDS_ERROR_GENERAL               1537
#define IDS_ERROR_NO_SUPPORT            1538
#define IDS_MESSAGE_IMPORTING_DL        1539
#define IDS_PAB                         1540
#define IDS_ERROR_DLL_NOT_FOUND         1541
#define IDS_ERROR_DLL_INVALID           1542
#define IDS_ERROR_DLL_EXCEPTION         1543
#define IDS_ERROR_MAPI_DLL_NOT_FOUND    1544
#define IDS_BUTTON_CANCEL               1545
#define IDS_BUTTON_CLOSE                1546
#define IDS_APP_TITLE                   1547
#define IDS_MESSAGE_EXPORTING_DL        1548
#define IDS_CSV                         1549
#define IDS_CSV_FILE_SPEC               1550
#define IDE_CSV_EXPORT_FILE_ERROR       1551
#define IDE_CSV_EXPORT_FILE_EXISTS      1552
#define IDS_CSV_EXPORT_PICK_FIELDS      1553
#define IDE_CSV_IMPORT_FILE_ERROR       1554
#define IDS_CSV_IMPORT_MAP_FIELDS       1555
#define IDS_CSV_IMPORT_HEADER_CSV       1556
#define IDS_CSV_IMPORT_HEADER_WAB       1557
#define IDS_CSV_CHANGE_MAPPING_TEXT_FIELD 1558
#define IDE_CSV_NO_COLUMNS              1559
#define IDS_CSV_COLUMN                  1560
#define IDS_ERROR_NOT_ENOUGH_MEMORY     1561
#define IDS_ERROR_NOT_ENOUGH_DISK       1562
#define IDS_MESSAGE_TITLE               1563
#define IDS_NO_WAB                      1564
#define IDS_TEXT_FILE_SPEC                          1566
#define IDE_LDIF_IMPORT_FILE_ERROR                  1567
#define IDS_LDIF_FILE_SPEC                          1568
#define IDS_MESS_FILE_SPEC                          1569
#define IDS_STATE_IMPORT_ERROR_FILEOPEN             1570
#define IDS_STATE_EXPORT_ERROR_NOPAB                1571
#define IDS_STATE_IMPORT_ERROR_NOPAB                1572

//
// Property Name Strigns
//
#define IDS_FIRST_EXPORT_PROP           1600

// Personal Pane
#define ids_ExportGivenName                     IDS_FIRST_EXPORT_PROP + 0
#define ids_ExportSurname                       IDS_FIRST_EXPORT_PROP + 1
#define ids_ExportMiddleName                    IDS_FIRST_EXPORT_PROP + 2
#define ids_ExportDisplayName                   IDS_FIRST_EXPORT_PROP + 3
#define ids_ExportNickname                      IDS_FIRST_EXPORT_PROP + 4
#define ids_ExportEmailAddress                  IDS_FIRST_EXPORT_PROP + 5

// Home Pane
#define ids_ExportHomeAddressStreet             IDS_FIRST_EXPORT_PROP + 6
#define ids_ExportHomeAddressCity               IDS_FIRST_EXPORT_PROP + 7
#define ids_ExportHomeAddressPostalCode         IDS_FIRST_EXPORT_PROP + 8
#define ids_ExportHomeAddressState              IDS_FIRST_EXPORT_PROP + 9
#define ids_ExportHomeAddressCountry            IDS_FIRST_EXPORT_PROP + 10
#define ids_ExportHomeTelephoneNumber           IDS_FIRST_EXPORT_PROP + 11
#define ids_ExportHomeFaxNumber                 IDS_FIRST_EXPORT_PROP + 12
#define ids_ExportCellularTelephoneNumber       IDS_FIRST_EXPORT_PROP + 13
#define ids_ExportPersonalHomePage              IDS_FIRST_EXPORT_PROP + 14

// Business Pane
#define ids_ExportBusinessAddressStreet         IDS_FIRST_EXPORT_PROP + 15
#define ids_ExportBusinessAddressCity           IDS_FIRST_EXPORT_PROP + 16
#define ids_ExportBusinessAddressPostalCode     IDS_FIRST_EXPORT_PROP + 17
#define ids_ExportBusinessAddressStateOrProvince IDS_FIRST_EXPORT_PROP + 18
#define ids_ExportBusinessAddressCountry        IDS_FIRST_EXPORT_PROP + 19
#define ids_ExportBusinessHomePage              IDS_FIRST_EXPORT_PROP + 20
#define ids_ExportBusinessTelephoneNumber       IDS_FIRST_EXPORT_PROP + 21
#define ids_ExportBusinessFaxNumber             IDS_FIRST_EXPORT_PROP + 22
#define ids_ExportPagerTelephoneNumber          IDS_FIRST_EXPORT_PROP + 23
#define ids_ExportCompanyName                   IDS_FIRST_EXPORT_PROP + 24
#define ids_ExportTitle                         IDS_FIRST_EXPORT_PROP + 25
#define ids_ExportDepartmentName                IDS_FIRST_EXPORT_PROP + 26
#define ids_ExportOfficeLocation                IDS_FIRST_EXPORT_PROP + 27

// Notes Pane
#define ids_ExportComment                       IDS_FIRST_EXPORT_PROP + 28
#define IDS_LAST_EXPORT_PROP                    ids_ExportComment
#define NUM_EXPORT_PROPS                        (1 + (IDS_LAST_EXPORT_PROP - IDS_FIRST_EXPORT_PROP))
// these are additional props
#define ids_ExportConfServer                    IDS_FIRST_EXPORT_PROP + 29
#define NUM_MORE_EXPORT_PROPS                   NUM_EXPORT_PROPS+1

// Synonym string identifiers
#define IDS_FIRST_SYNONYM_STRING                1800
#define idsSynonymCount                         IDS_FIRST_SYNONYM_STRING + 0
#define idsSynonym001                           IDS_FIRST_SYNONYM_STRING + 1
#define idsSynonym002                           IDS_FIRST_SYNONYM_STRING + 2
#define idsSynonym003                           IDS_FIRST_SYNONYM_STRING + 3
#define idsSynonym004                           IDS_FIRST_SYNONYM_STRING + 4
#define idsSynonym005                           IDS_FIRST_SYNONYM_STRING + 5
#define idsSynonym006                           IDS_FIRST_SYNONYM_STRING + 6
#define idsSynonym007                           IDS_FIRST_SYNONYM_STRING + 7
#define idsSynonym008                           IDS_FIRST_SYNONYM_STRING + 8
#define idsSynonym009                           IDS_FIRST_SYNONYM_STRING + 9
#define idsSynonym010                           IDS_FIRST_SYNONYM_STRING + 10
#define idsSynonym011                           IDS_FIRST_SYNONYM_STRING + 11
#define idsSynonym012                           IDS_FIRST_SYNONYM_STRING + 12
#define idsSynonym013                           IDS_FIRST_SYNONYM_STRING + 13
#define idsSynonym014                           IDS_FIRST_SYNONYM_STRING + 14
#define idsSynonym015                           IDS_FIRST_SYNONYM_STRING + 15
#define idsSynonym016                           IDS_FIRST_SYNONYM_STRING + 16
#define idsSynonym017                           IDS_FIRST_SYNONYM_STRING + 17
#define idsSynonym018                           IDS_FIRST_SYNONYM_STRING + 18
#define idsSynonym019                           IDS_FIRST_SYNONYM_STRING + 19
#define idsSynonym020                           IDS_FIRST_SYNONYM_STRING + 20
#define idsSynonym021                           IDS_FIRST_SYNONYM_STRING + 21
#define idsSynonym022                           IDS_FIRST_SYNONYM_STRING + 22
#define idsSynonym023                           IDS_FIRST_SYNONYM_STRING + 23
#define idsSynonym024                           IDS_FIRST_SYNONYM_STRING + 24
#define idsSynonym025                           IDS_FIRST_SYNONYM_STRING + 25
#define idsSynonym026                           IDS_FIRST_SYNONYM_STRING + 26
#define idsSynonym027                           IDS_FIRST_SYNONYM_STRING + 27
#define idsSynonym028                           IDS_FIRST_SYNONYM_STRING + 28
#define idsSynonym029                           IDS_FIRST_SYNONYM_STRING + 29
#define idsSynonym030                           IDS_FIRST_SYNONYM_STRING + 30


// ICON Identifiers
#define IDI_WabMig                      4002

// Bitmap Identifiers
#define IDB_CHECKS                      4100
#define IDB_WIZARD                      4101


// State Identifiers
#define ID_STATE_IMPORT_MU              3000
#define ID_STATE_IMPORT_NEXT_MU         3001
#define ID_STATE_IMPORT_DL              3002
#define ID_STATE_IMPORT_NEXT_DL         3003
#define ID_STATE_IMPORT_FINISH          3004
#define ID_STATE_IMPORT_ERROR           3005
#define ID_STATE_IMPORT_CANCEL          3006
#define ID_STATE_EXPORT_MU              3010
#define ID_STATE_EXPORT_NEXT_MU         3011
#define ID_STATE_EXPORT_DL              3012
#define ID_STATE_EXPORT_NEXT_DL         3013
#define ID_STATE_EXPORT_FINISH          3014
#define ID_STATE_EXPORT_ERROR           3015
#define ID_STATE_EXPORT_CANCEL          3016

// Static Identifiers
#define IDC_STATIC                      -1


/*****************************************************************************
-
-   Additional Resources for WABFind.dll
-
******************************************************************************/

#define IDI_INETFIND	    1641   /* My main icon */
#define IDM_ONTHEINTERNET	1642   /* Our sole menu item */
#define IDS_ONTHEINTERNET	1643
#define IDS_FINDHELP		1644
#define IDS_PEOPLE          1645
#define IDS_FORPEOPLE       1646
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\advise.c ===
/*
 *	ADVISE.C
 *
 *	HrAllocAdviseSink
 *
 *	AdviseList helpers
 */

#include "_apipch.h"



#ifndef VTABLE_FILL
#define VTABLE_FILL
#endif

#if !defined(WIN32) || defined(MAC)

#ifndef InitializeCriticalSection
#define InitializeCriticalSection(cs)
#define DeleteCriticalSection(cs)
#define EnterCriticalSection(cs)
#define LeaveCriticalSection(cs)
#define CRITICAL_SECTION int
#endif
#endif

/*
 *	The next several routines implement an IMAPIAdviseSink object
 *	based on a callback function and context pointers.
 */

#undef	INTERFACE
#define INTERFACE struct _ADVS

#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method) MAPIMETHOD_DECLARE(type, method, ADVS_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
#undef	MAPIMETHOD_
#define MAPIMETHOD_(type, method) STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ADVS_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
};

typedef struct _ADVS FAR *LPADVS;

typedef struct _ADVS {
    ADVS_Vtbl * lpVtbl;
    UINT cRef;
    LPVOID lpvContext;
    LPNOTIFCALLBACK lpfnCallback;
} ADVS;

ADVS_Vtbl vtblADVS = {
    VTABLE_FILL
    ADVS_QueryInterface,
    ADVS_AddRef,
    ADVS_Release,
    ADVS_OnNotify
};

#define VALIDATE_ADVS(m, p, v) \
    if (IsBadWritePtr((p), sizeof(ADVS)) || \
      IsBadReadPtr((p)->lpVtbl, sizeof(ADVS_Vtbl)) || \
      (p)->lpVtbl != &vtblADVS) { \
        DebugTraceArg(m,  TEXT("Invalid object pointer")); \
        return v; \
    }

STDMETHODIMP
ADVS_QueryInterface(LPADVS padvs,
  REFIID lpiid,
  LPVOID FAR *lppObject)
{
    VALIDATE_ADVS(ADVS_QueryInterface, padvs, ResultFromScode(E_INVALIDARG));
    if (IsBadReadPtr((LPIID)lpiid, sizeof(IID)) ||
      IsBadWritePtr(lppObject, sizeof(LPVOID))) {
        DebugTraceArg(ADVS_QueryInterface,  TEXT("fails address check"));
        return(ResultFromScode(E_INVALIDARG));
    }

    *lppObject = NULL;
    if (IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IUnknown) ||
      IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IMAPIAdviseSink)) {
        ++(padvs->cRef);
        *lppObject = padvs;
        return(hrSuccess);
    }

    return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG)
ADVS_AddRef(LPADVS padvs)
{
    VALIDATE_ADVS(ADVS_AddRef, padvs, 0L);
    return((ULONG)(++padvs->cRef));
}


STDMETHODIMP_(ULONG)
ADVS_Release(LPADVS padvs)
{
    HLH hlh;

    VALIDATE_ADVS(ADVS_Release, padvs, 0xFFFFFFFF);

    if (--(padvs->cRef) == 0) {
        if (hlh = HlhUtilities()) {
            LH_Free(hlh, padvs);
        } else {
            DebugTrace(TEXT("ADVS_Release: no heap left\n"));
        }

        return(0L);
    }

    return((ULONG)padvs->cRef);
}


STDMETHODIMP_(ULONG)
ADVS_OnNotify(LPADVS padvs,
  ULONG cNotif,
  LPNOTIFICATION lpNotif)
{
    VALIDATE_ADVS(ADVS_OnNotify, padvs, 0L);
//$     Enable when we put this in a DLL -- too many deps for the library
//$     if (FAILED(ScCountNotifications((int)cNotif, lpNotif, NULL))) {
//$         DebugTraceArg(ADVS_OnNotify,  TEXT("lpNotif fails address check"));
//$         return 0L;
//$     }

    return((*(padvs->lpfnCallback))(padvs->lpvContext, cNotif, lpNotif));
}


/*
 -	HrAllocAdviseSink
 -
 *	Purpose:
 *		Creates an IMAPIAdviseSink object based on an old-style
 *		notification callback function and context pointer.
 *
 *	Arguments:
 *		lpfnCallback		in		the notification callback
 *		lpvContext			in		arbitrary context for the
 *									callback
 *		lppAdviseSink		out		the returned AdviseSink object
 *
 *	Returns:
 *		HRESULT
 *
 *	Errors:
 *		out of memory
 *		parameter validation
 */
STDAPI
HrAllocAdviseSink(LPNOTIFCALLBACK lpfnCallback,
  LPVOID lpvContext,
  LPMAPIADVISESINK FAR *lppAdviseSink)
{
    LPADVS		padvs;
    HRESULT		hr = hrSuccess;
    HLH			hlh;

    if (IsBadCodePtr((FARPROC)lpfnCallback) ||
      IsBadWritePtr(lppAdviseSink, sizeof(LPMAPIADVISESINK))) {
        DebugTraceArg(HrAllocAdviseSink,  TEXT("invalid parameter"));
        return(ResultFromScode(E_INVALIDARG));
    }

    *lppAdviseSink = NULL;

    if (! (hlh = HlhUtilities())) {
        hr = ResultFromScode(MAPI_E_NOT_INITIALIZED);
        goto ret;
    }

    padvs = LH_Alloc(hlh, sizeof(ADVS));
    if (! padvs) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto ret;
    }

    padvs->lpVtbl = &vtblADVS;
    padvs->cRef = 1;
    padvs->lpvContext = lpvContext;
    padvs->lpfnCallback = lpfnCallback;

    *lppAdviseSink = (LPMAPIADVISESINK)padvs;

ret:
    DebugTraceResult(HrAllocAdviseSink, hr);
    return(hr);
}

#ifdef SINGLE_THREAD_ADVISE_SINK

/*
 *	Single-thread advise sink wrapper. This object wrapper forces
 *	OnNotify calls to happen on the thread in which it was created,
 *	by forwarding stuff to a window proc on that thread.
 */
#if defined(WIN16) || defined(MAC)

STDAPI
HrThisThreadAdviseSink(LPMAPIADVISESINK lpAdviseSink,
  LPMAPIADVISESINK FAR *lppAdviseSink)
{
//#ifdef	PARAMETER_VALIDATION
    if (FBadUnknown(lpAdviseSink)) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lpAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    if (IsBadWritePtr(lppAdviseSink, sizeof(LPMAPIADVISESINK))) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lppAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
//#endif	

    UlAddRef(lpAdviseSink);
    *lppAdviseSink = lpAdviseSink;

    return(hrSuccess);
}

#else

//	Object goo

#undef	INTERFACE
#define	INTERFACE	struct _SAS

#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, SAS_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
#undef	MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(SAS_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIADVISESINK_METHODS(IMPL)
};

typedef struct _SAS FAR *LPSAS;

typedef struct _SAS {
    SAS_Vtbl * lpVtbl;
    ULONG cRef;

    ULONG cActiveOnNotifies;
    LPMAPIADVISESINK pasOrig;
    HWND hwnd;

} SAS;

SAS_Vtbl vtblSAS =
{
    //	VTABLE_FILL		//	NI on the Mac
    SAS_QueryInterface,
    SAS_AddRef,
    SAS_Release,
    SAS_OnNotify
};

#define VALIDATE_SAS(m, p, v) \
    if (IsBadWritePtr((p), sizeof(SAS)) || \
      IsBadReadPtr((p)->lpVtbl, sizeof(SAS_Vtbl)) || \
      (p)->lpVtbl != &vtblSAS) { \
        DebugTraceArg(m,  TEXT("Invalid object pointer")); \
        return v; \
    }

typedef struct {
    LPMAPIADVISESINK pas;
    LPSAS psas;
    ULONG cb;               // maybe
    ULONG cnotif;
    NOTIFICATION		rgnotif[MAPI_DIM];
} FWDNOTIF, FAR *LPFWDNOTIF;

#define SizedFWDNOTIF(_c, _name) \
    struct _FWDNOTIF_ ## name { \
        LPMAPIADVISESINK	pas; \
        ULONG				cb; \
        ULONG				cnotif; \
        NOTIFICATION		rgnotif[_c]; \
    } _name

#define CbNewFWDNOTIF(_cnotif) \
    (offsetof(FWDNOTIF, rgnotif) + ((_cnotif)*sizeof(NOTIFICATION)))
#define CbFWDNOTIF(_pf) \
    (offsetof(FWDNOTIF, rgnotif) + (((_pf)->cnotif)*sizeof(NOTIFICATION)))

//	Window class globals

#define WND_FLAGS_KEY               0   // NYI
#define cbSTClsExtra                4
#define CLS_REFCOUNT_KEY            0
TCHAR szSTClassName[] =              TEXT("WMS ST Notif Class");

//	Window globals

#define cbSTWndExtra                4
#define WND_REFCOUNT_KEY            GWL_USERDATA
#define wmSingleThreadNotif         (WM_USER + 13)
TCHAR szSTWndFmt[] =                 TEXT("WMS ST Notif Window %08X %08X");
#define NameWindow(_s, cchSize)     wnsprintf(_s, cchSize, szSTWndFmt, \
                                      GetCurrentProcessId(), \
                                      GetCurrentThreadId());


HRESULT		HrWindowUp(HWND *phwnd);
void		WindowRelease(HWND);
LRESULT CALLBACK STWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


STDAPI
HrThisThreadAdviseSink(LPMAPIADVISESINK pas,
  LPMAPIADVISESINK FAR *ppas)
{
    HRESULT hr;
    LPSAS psas = NULL;

//#ifdef	PARAMETER_VALIDATION
    if (FBadUnknown(pas)) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lpAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    if (IsBadWritePtr(ppas, sizeof(LPMAPIADVISESINK))) {
        DebugTraceArg(HrThisThreadAdviseSink,  TEXT("lppAdviseSink fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
//#endif	

    if (HR_FAILED(hr = ResultFromScode((MAPIAllocateBuffer(sizeof(SAS), &psas))))) {
        goto ret;
    }

    MAPISetBufferName(psas,  TEXT("ST Advise Sink"));
    ZeroMemory(psas, sizeof(SAS));
    psas->lpVtbl = &vtblSAS;
    psas->cRef = 1;
    psas->cActiveOnNotifies = 0;

    if (hr = HrWindowUp(&psas->hwnd)) {
        goto ret;
    }

    //	All OK, return the new object
    UlAddRef(pas);
    psas->pasOrig = pas;
    *ppas = (LPMAPIADVISESINK) psas;

ret:
    if (HR_FAILED(hr)) {
        MAPIFreeBuffer(psas);
    }

    DebugTraceResult(HrThisThreadAdviseSink, hr);
    return(hr);
}

HRESULT
HrWindowUp(HWND * phwnd)
{
    HRESULT		hr = hrSuccess;
    CHAR		szWndName[64];
    WNDCLASSA	wc;
    HWND		hwnd;
    LONG		cRef;
    HINSTANCE 	hinst;

    //	Find the window for this thread, if it exists
    NameWindow(szWndName, ARRAYSIZE(szWndName));
    hwnd = FindWindow(szSTClassName, szWndName);

    if (hwnd) {
        //	It already exists -- add a ref to it
        cRef = GetWindowLong(hwnd, WND_REFCOUNT_KEY);
        Assert(cRef != 0L);
        SideAssert(SetWindowLong(hwnd, WND_REFCOUNT_KEY, cRef+1) == cRef);
    } else {
        //	We have to create the window.

        hinst = hinstMapiXWAB;

        if (!GetClassInfo(hinst, szSTClassName, &wc)) {
            //	We have to register the class too.
            ZeroMemory(&wc, sizeof(WNDCLASSA));
            wc.style = CS_GLOBALCLASS;
            wc.lpfnWndProc = STWndProc;
            wc.cbClsExtra = cbSTClsExtra;
            wc.cbWndExtra = cbSTWndExtra;
            wc.hInstance = hinst;
            wc.lpszClassName = szSTClassName;

            RegisterClassA(&wc);
        }

        hwnd = CreateWindowA(szSTClassName,
          szWndName,
          WS_POPUP,	//	bug 6111: pass on Win95 hotkey
          0, 0, 0, 0,
          NULL, NULL, hinst, NULL);
        if (hwnd) {	
            SetWindowLong(hwnd, WND_REFCOUNT_KEY, 1);
            cRef = (LONG) GetClassLong(hwnd, CLS_REFCOUNT_KEY);
            SideAssert((LONG) SetClassLong(hwnd, CLS_REFCOUNT_KEY, cRef+1) == cRef);
        } else {
            hr = ResultFromScode(MAPI_E_NOT_INITIALIZED);
            goto ret;
        }
    }

    *phwnd = hwnd;

ret:
    DebugTraceResult(HrWindowUp, hr);
    return(hr);
}


void
WindowRelease(HWND hwnd)
{
    CHAR	szWndName[64];
    LONG	cRefWnd;
    LONG	cRefCls;

    //	The thread-safeness of this call is not obvious to
    //	the casual observer, so it will NOT be left as an
    //	exercise at the end of the development cycle.
    //
    //	Namely, you do not have access to a window's data
    //	from any thread other than the owning thread.  This
    //	should not suprise anyone (although it did me...).
    //	So in debug builds, we will assert if we call this
    //	from any thread that is not the owning one.  What
    //	this means is that we cannot release on a thread
    //	that does not own the SAS.
    //
    if (! hwnd) {
        //	Find the window for this thread, if it exists
        NameWindow(szWndName, ARRAYSIZE(szWndName));
        hwnd = FindWindow(szSTClassName, szWndName);
    }
#ifdef	DEBUG
    else {
        //	Find the window for this thread, if it exists
        NameWindow(szWndName, ARRAYSIZE(szWndName));
        Assert (hwnd == FindWindow(szSTClassName, szWndName));
    }
#endif	// DEBUG
		
    if (! hwnd) {
        return;
    }

    cRefWnd = GetWindowLong(hwnd, WND_REFCOUNT_KEY);
    cRefCls = (LONG) GetClassLong(hwnd, CLS_REFCOUNT_KEY);
    if (cRefWnd > 1) {
        //	Just deref it
        SideAssert(SetWindowLong(hwnd, WND_REFCOUNT_KEY, cRefWnd-1) == cRefWnd);
    } else {
        SideAssert((LONG) SetClassLong(hwnd, CLS_REFCOUNT_KEY, cRefCls-1) == cRefCls);
        DestroyWindow(hwnd);
        if (cRefCls == 1) {
            UnregisterClass(szSTClassName, hinstMapiXWAB);
        }
    }
}


LRESULT CALLBACK
STWndProc(HWND hwnd,
  UINT msg,
  WPARAM wParam,
  LPARAM lParam)
{
    LPFWDNOTIF	pfwd = NULL;

    if (msg != wmSingleThreadNotif) {
        return(DefWindowProc(hwnd, msg, wParam, lParam));
    } else {
        //	The wparam should be 0.
        //	The lparam is the address of a forwarded notification.
        //	First, validate the structure.
        pfwd = (LPFWDNOTIF)lParam;
        if (IsBadReadPtr(pfwd, CbNewFWDNOTIF(0))) {
            DebugTrace(TEXT("STWndProc: totally invalid FWDNOTIF\n"));
            pfwd = NULL;
            goto ret;
        }
        if (IsBadReadPtr(pfwd, (UINT) pfwd->cb)) {
            DebugTrace(TEXT("STWndProc: partially invalid FWDNOTIF\n"));
            pfwd = NULL;
            goto ret;
        }
        if (FBadUnknown(pfwd->pas)) {
            DebugTrace(TEXT("STWndProc: invalid advise sink\n"));
            goto ret;
        }

        //
        //  Only call OnNotify if there are other references to the SAS other than
        //  those made specifically for the PostMessage in SAS_OnNotify.
        //
        if (pfwd->psas->cRef > pfwd->psas->cActiveOnNotifies) {
            //	Forward the notification.
            pfwd->pas->lpVtbl->OnNotify(pfwd->pas, pfwd->cnotif, pfwd->rgnotif);
        }

        pfwd->psas->cActiveOnNotifies--;

        //	Release the contained advise object
        //
        UlRelease (pfwd->psas);

ret:
        MAPIFreeBuffer(pfwd);
    }
    return(0);
}


STDMETHODIMP
SAS_QueryInterface(LPSAS psas,
  REFIID lpiid,
  LPUNKNOWN FAR *ppunk)
{
// #ifdef	PARAMETER_VALIDATION
    VALIDATE_SAS(QueryInterface, psas, ResultFromScode(E_INVALIDARG));
    if (IsBadWritePtr(ppunk, sizeof(LPUNKNOWN))) {
        DebugTraceArg(SAS_QueryInterface,  TEXT("ppunk fails address check"));
        return(ResultFromScode(E_INVALIDARG));
    }
    *ppunk = NULL;
    if (IsBadReadPtr((LPIID) lpiid, sizeof(IID))) {
        DebugTraceArg(SAS_QueryInterface,  TEXT("lpiid fails address check"));
        return(ResultFromScode(E_INVALIDARG));
    }
// #endif	/* PARAMETER_VALIDATION */

    if (! memcmp(lpiid, &IID_IUnknown, sizeof(IID)) ||
      ! memcmp(lpiid, &IID_IMAPIAdviseSink, sizeof(IID))) {
        InterlockedIncrement((LONG *)&psas->cRef);
        *ppunk = (LPUNKNOWN) psas;
        return(hrSuccess);
    }

    return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG)
SAS_AddRef(LPSAS psas) {
    VALIDATE_SAS(AddRef, psas, 1);

    InterlockedIncrement((LONG *)&psas->cRef);
}


STDMETHODIMP_(ULONG)
SAS_Release(LPSAS psas)
{
    VALIDATE_SAS(SAS_Release, psas, 1);
    InterlockedDecrement((LONG *)&psas->cRef);

    if (psas->cRef) {
        return(psas->cRef);
    }

    WindowRelease(NULL);
    if (! FBadUnknown(psas->pasOrig)) {
        UlRelease(psas->pasOrig);
    } else {
        DebugTrace(TEXT("SAS_Release: pasOrig expired\n"));
    }
    MAPIFreeBuffer(psas);
    return(0);
}


STDMETHODIMP_(ULONG)
SAS_OnNotify(LPSAS psas,
  ULONG cnotif,
  LPNOTIFICATION rgnotif)
{
	ULONG		cb;
	SCODE		sc = S_OK;
	LPFWDNOTIF	pfwd = NULL;

//#ifdef	PARAMETER_VALIDATION
	VALIDATE_SAS(SAS_OnNotify, psas, 0);
	//	notifications validated below
//#endif

    if (! IsWindow(psas->hwnd)) {
        DebugTrace(TEXT("SAS_OnNotify: my window is dead!\n"));
        goto ret;
    }

    if (sc = ScCountNotifications((int) cnotif, rgnotif, &cb)) {
        DebugTrace(TEXT("SAS_OnNotify: ScCountNotifications returns %s\n"), SzDecodeScode(sc));
        goto ret;
    }
    if (sc = MAPIAllocateBuffer(cb + offsetof(FWDNOTIF, rgnotif), &pfwd)) {
        DebugTrace(TEXT("SAS_OnNotify: MAPIAllocateBuffer returns %s\n"), SzDecodeScode(sc));
        goto ret;
    }
    MAPISetBufferName(pfwd,  TEXT("ST Notification copy"));
    UlAddRef (psas);
    pfwd->psas = psas;
    pfwd->pas = psas->pasOrig;
    pfwd->cnotif = cnotif;
    (void) ScCopyNotifications((int) cnotif, rgnotif, pfwd->rgnotif, NULL);
    pfwd->cb = cb + offsetof(FWDNOTIF, rgnotif);	//	used?

    psas->cActiveOnNotifies++;

    if (! PostMessage(psas->hwnd, wmSingleThreadNotif, 0, (LPARAM) pfwd)) {
        DebugTrace(TEXT("SAS_OnNotify: PostMessage failed with %ld\n"), GetLastError());
        MAPIFreeBuffer(pfwd);
    }

ret:
    return(0);
}

#endif	/* WIN16 */

/*
 *	Advise list maintenance.
 *
 *	These functions maintain a list of advise sink objects together
 *	with the connection dwords used to get rid of them. Along with
 *	those two basic items, an additional interface pointer and type
 *	can be remembered; MAPIX uses these to forward Unadvise calls
 *	where necessary.
 *
 *	ScAddAdviseList
 *		Creates or resizes the advise list as necessary, and adds a new
 *		member. It fails if there is already an item in the list with the
 *		same ulConnection. Takes an IMalloc interface for memory; uses
 *		the standard one if none is supplied.
 *
 *	ScDelAdviseList
 *		Removes an item identified by its ulConnection from the advise
 *		list. Does not resize the list.
 *
 *	ScFindAdviseList
 *		Given the ulConnection of an item, returns a pointer into
 *		the advise list.
 *
 *	DestroyAdviseList
 *		What it says.
 */

#define cGrowItems 10

STDAPI_(SCODE)
ScAddAdviseList(LPVOID lpvReserved,
  LPADVISELIST FAR *lppList,
  LPMAPIADVISESINK lpAdvise,
  ULONG ulConnection,
  ULONG ulType,
  LPUNKNOWN lpParent)
{
    SCODE sc = S_OK;
    LPADVISELIST plist;
    LPADVISEITEM pitem;
    HLH hlh;

    // parameter validation

#ifdef	DEBUG
    if (lpvReserved) {
       DebugTrace(TEXT("ScAddAdviseList: pmalloc is unused, now reserved, pass NULL\n"));
    }
#endif	
	
    AssertSz(! IsBadWritePtr(lppList, sizeof(LPADVISELIST)),
       TEXT("lppList fails address check"));

    AssertSz(! *lppList || ! IsBadReadPtr(*lppList, offsetof(ADVISELIST, rgItems)),
       TEXT("*lppList fails address check"));

    AssertSz(! *lppList || ! IsBadReadPtr(*lppList, (UINT)CbADVISELIST(*lppList)),
       TEXT("*lppList fails address check"));

    AssertSz(lpAdvise && ! FBadUnknown(lpAdvise),
       TEXT("lpAdvise fails address check"));

    AssertSz(! lpParent || ! FBadUnknown(lpParent),
       TEXT("lpParent fails address check"));

    if (! (hlh = HlhUtilities())) {
        sc = MAPI_E_NOT_INITIALIZED;
        goto ret;
    }

    //	Ensure space is available for new item

    if (!(plist = *lppList)) {      //  Yup, =
        if (!(plist = LH_Alloc(hlh, CbNewADVISELIST(cGrowItems)))) {
            goto oom;
        }
        LH_SetName (hlh, plist,  TEXT("core: advise list"));

#if defined(WIN32) && !defined(MAC)
        if (!(plist->lpcs = LH_Alloc (hlh, sizeof(CRITICAL_SECTION)))) {
            goto oom;
        }
        memset (plist->lpcs, 0, sizeof(CRITICAL_SECTION));
        LH_SetName (hlh, plist,  TEXT("core: advise list critical section"));
#endif
        plist->cItemsMac = 0;
        plist->cItemsMax = cGrowItems;
        InitializeCriticalSection(plist->lpcs);
        EnterCriticalSection(plist->lpcs);
        *lppList = plist;
    } else {
        EnterCriticalSection(plist->lpcs);
    }

    if (plist->cItemsMac == plist->cItemsMax) {
        if (!(plist = LH_Realloc(hlh, plist,
          (UINT)CbNewADVISELIST(plist->cItemsMax + cGrowItems)))) {
            LeaveCriticalSection((*lppList)->lpcs);	//	plist is bad ptr
            goto oom;
        }
        plist->cItemsMax += cGrowItems;
        *lppList = plist;
    }

    //	Check for duplicate key
    for (pitem = &plist->rgItems[plist->cItemsMac - 1];
      pitem >= plist->rgItems;
      --pitem) {
        if (pitem->ulConnection == ulConnection) {
            sc = MAPI_E_BAD_VALUE;
            LeaveCriticalSection(plist->lpcs);
            goto ret;
        }
    }

    //	Add the new item

    pitem = &plist->rgItems[plist->cItemsMac++];
    pitem->lpAdvise = lpAdvise;
    pitem->ulConnection = ulConnection;
    pitem->ulType = ulType;
    pitem->lpParent = lpParent;

    LeaveCriticalSection(plist->lpcs);

    UlAddRef(lpAdvise);

ret:
    //	note: no LeaveCrit here because of error returns
    DebugTraceSc(ScAddAdviseList, sc);
    return(sc);

oom:
    if (! (*lppList) && plist) {
        LH_Free (hlh, plist);
    }

    sc = MAPI_E_NOT_ENOUGH_MEMORY;
    goto ret;
}


STDAPI_(SCODE)
ScDelAdviseList(LPADVISELIST lpList, ULONG ulConnection)
{
    SCODE sc = S_OK;
    LPADVISEITEM pitem;
    LPMAPIADVISESINK padvise;
#ifndef MAC
    FARPROC FAR *	pfp;
#endif

    AssertSz(!IsBadReadPtr(lpList, offsetof(ADVISELIST, rgItems)),
       TEXT("lpList fails address check"));
    AssertSz(!IsBadReadPtr(lpList, (UINT)CbADVISELIST(lpList)),
       TEXT("lpList fails address check"));

    EnterCriticalSection(lpList->lpcs);

    if (FAILED(sc = ScFindAdviseList(lpList, ulConnection, &pitem))) {
        goto ret;
    }

    Assert(pitem >= lpList->rgItems);
    Assert(pitem < lpList->rgItems + lpList->cItemsMac);
    SideAssert(padvise = pitem->lpAdvise);

    MoveMemory(pitem, pitem+1, sizeof(ADVISEITEM) *
      ((int)lpList->cItemsMac - (pitem + 1 - lpList->rgItems)));

    --(lpList->cItemsMac);

    if (!IsBadReadPtr(padvise, sizeof(LPVOID))
      &&	!IsBadReadPtr((pfp=(FARPROC FAR *)padvise->lpVtbl), 3*sizeof(FARPROC))
      &&	!IsBadCodePtr(pfp[2])) {
        LeaveCriticalSection(lpList->lpcs);
        UlRelease(padvise);
        EnterCriticalSection(lpList->lpcs);
    }

ret:
    LeaveCriticalSection(lpList->lpcs);
    DebugTraceSc(ScDelAdviseList, sc);
    return(sc);
}



STDAPI_(SCODE)
ScFindAdviseList(LPADVISELIST lpList,
  ULONG ulConnection,
  LPADVISEITEM FAR *lppItem)
{
    SCODE sc = MAPI_E_NOT_FOUND;
    LPADVISEITEM pitem;

    AssertSz(! IsBadReadPtr(lpList, offsetof(ADVISELIST, rgItems)),
       TEXT("lpList fails address check"));
    AssertSz(! IsBadReadPtr(lpList, (UINT)CbADVISELIST(lpList)),
       TEXT("lpList Failes addres check"));
    AssertSz(! IsBadWritePtr(lppItem, sizeof(LPADVISEITEM)),
       TEXT("lppItem fails address check"));

    *lppItem = NULL;

    EnterCriticalSection(lpList->lpcs);

    for (pitem = lpList->rgItems + lpList->cItemsMac - 1;
      pitem >= lpList->rgItems;
      --pitem) {
        if (pitem->ulConnection == ulConnection) {
            *lppItem = pitem;
            sc = S_OK;
            break;
        }
    }

    //	Assert that there are no duplicates of the found key
#ifdef	DEBUG
    {
        LPADVISEITEM pitemT;

        for (pitemT = lpList->rgItems; pitemT < pitem; ++pitemT) {
            Assert(pitemT->ulConnection != ulConnection);
        }
    }
#endif

    LeaveCriticalSection(lpList->lpcs);
    DebugTraceSc(ScFindAdviseList, sc);
    return(sc);
}

STDAPI_(void)
DestroyAdviseList(LPADVISELIST FAR *lppList)
{
    LPADVISELIST plist;
    HLH hlh;

    AssertSz(! IsBadWritePtr(lppList, sizeof(LPADVISELIST)),
       TEXT("lppList fails address check"));

    if (! *lppList) {
        return;
    }

    AssertSz(! IsBadReadPtr(*lppList, offsetof(ADVISELIST, rgItems)),
       TEXT("*lppList fails address check"));
    AssertSz(! IsBadReadPtr(*lppList, (UINT)CbADVISELIST(*lppList)),
       TEXT("*lppList fails address check"));

    if (! (hlh = HlhUtilities())) {
        DebugTrace(TEXT("DestroyAdviseList: no heap for me\n")DebugTrace(TEXT(");
        return;
    }

    //	First deref any advise sinks that didn't get freed up
    plist = *lppList;
    EnterCriticalSection(plist->lpcs);
    *lppList = NULL;

    while (plist->cItemsMac > 0) {
        (void)ScDelAdviseList(plist, plist->rgItems[0].ulConnection);
    }

    LeaveCriticalSection(plist->lpcs);

    //	Now destroy the adviselist itself
    DeleteCriticalSection(plist->lpcs);
#if defined(WIN32) && !defined(MAC)
    LH_Free(hlh, plist->lpcs);
#endif
    LH_Free(hlh, plist);
}


STDAPI
HrDispatchNotifications(ULONG ulFlags)
{
    DrainFilteredNotifQueue(FALSE, 0, NULL);

    return(ResultFromScode(S_OK));
}


STDAPI
WrapProgress(LPMAPIPROGRESS lpProgress,
  ULONG ulMin,
  ULONG ulMax,
  ULONG ulFlags,
  LPMAPIPROGRESS FAR *lppProgress)
{
    AssertSz(lpProgress && ! FBadUnknown(lpProgress),
      TEXT( TEXT("lpProgress fails address check")));

    AssertSz(lppProgress && !IsBadWritePtr(lppProgress, sizeof(LPMAPIPROGRESS)),
      TEXT( TEXT("lppProgress fails address check")));

    DebugTraceSc(WrapProgress, MAPI_E_NO_SUPPORT);
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}

#endif //#ifdef SINGLE_THREAD_ADVISE_SINK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\abroot.c ===
/*
 *      ABROOT.C
 *
 *      IMAPIContainer implementation for the address book's root
 *      container.
 */

#include "_apipch.h"

extern SPropTagArray sosPR_ROWID;

/*
 *  Root jump table is defined here...
 */

ROOT_Vtbl vtblROOT =
{
    VTABLE_FILL
    (ROOT_QueryInterface_METHOD *)  CONTAINER_QueryInterface,
    (ROOT_AddRef_METHOD *)          WRAP_AddRef,
    (ROOT_Release_METHOD *)         CONTAINER_Release,
    (ROOT_GetLastError_METHOD *)    IAB_GetLastError,
    (ROOT_SaveChanges_METHOD *)     WRAP_SaveChanges,
    (ROOT_GetProps_METHOD *)        WRAP_GetProps,
    (ROOT_GetPropList_METHOD *)     WRAP_GetPropList,
    (ROOT_OpenProperty_METHOD *)    CONTAINER_OpenProperty,
    (ROOT_SetProps_METHOD *)        WRAP_SetProps,
    (ROOT_DeleteProps_METHOD *)     WRAP_DeleteProps,
    (ROOT_CopyTo_METHOD *)          WRAP_CopyTo,
    (ROOT_CopyProps_METHOD *)       WRAP_CopyProps,
    (ROOT_GetNamesFromIDs_METHOD *) WRAP_GetNamesFromIDs,
    (ROOT_GetIDsFromNames_METHOD *) WRAP_GetIDsFromNames,
    ROOT_GetContentsTable,
    ROOT_GetHierarchyTable,
    ROOT_OpenEntry,
    ROOT_SetSearchCriteria,
    ROOT_GetSearchCriteria,
    ROOT_CreateEntry,
    ROOT_CopyEntries,
    ROOT_DeleteEntries,
    ROOT_ResolveNames
};


//
//  Interfaces supported by this object
//
#define ROOT_cInterfaces 3
LPIID ROOT_LPIID[ROOT_cInterfaces] =
{
    (LPIID)&IID_IABContainer,
    (LPIID)&IID_IMAPIContainer,
    (LPIID)&IID_IMAPIProp
};

// Registry strings
const LPTSTR szWABKey                   = TEXT("Software\\Microsoft\\WAB");

// PR_AB_PROVIDER_ID for Outlook
static const MAPIUID muidCAB = {0xfd,0x42,0xaa,0x0a,0x18,0xc7,0x1a,0x10,0xe8,0x85,0x0B,0x65,0x1C,0x24,0x00,0x00};

/*
-
- SetContainerlpProps
*
*   The ROOT container will have a bunch of entries with props for each entry
*   The props are set in one place here 
*
    lpProps - LPSPropValue array in which we are storing the props
    lpszName - Container name
    iRow    - Row of this entry in the table (?)
    cb, lpb - entryid of the container
    lpEID   - alternat way of passing in the EID
    ulContainerFlags - any flags we want to cache on the container
    ulDepth ?
    bProviderID ?
    bLDAP - identifies LDAP containers which need some extra props
    fLDAPResolve - whether the LDAP container is used for name resolution or not

*/
void SetContainerlpProps(LPSPropValue lpProps, LPTSTR lpszName, ULONG iRow,
                         ULONG cb, LPBYTE lpb, LPSBinary lpEID,
                         ULONG ulContainerFlags,
                         ULONG ulDepth, BOOL bProviderID,
                         ULONG ulFlags,
                         BOOL bLDAP, BOOL fLDAPResolve)
{
    LPSTR lpszNameA = NULL;
    
    if(!(ulFlags & MAPI_UNICODE)) // <note> this assumes UNICODE is defined
        ScWCToAnsiMore((LPALLOCATEMORE) (&MAPIAllocateMore), lpProps, lpszName, &lpszNameA);

    DebugTrace(TEXT("Adding root-table container:%s\n"),lpszName);

    lpProps[ircPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE;
    lpProps[ircPR_DISPLAY_TYPE].Value.l = DT_LOCAL;

    lpProps[ircPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    lpProps[ircPR_OBJECT_TYPE].Value.l = MAPI_ABCONT;

    lpProps[ircPR_ROWID].ulPropTag = PR_ROWID;
    lpProps[ircPR_ROWID].Value.l = iRow;

    lpProps[ircPR_DEPTH].ulPropTag = PR_DEPTH;
    lpProps[ircPR_DEPTH].Value.l = ulDepth;

    lpProps[ircPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS;
    lpProps[ircPR_CONTAINER_FLAGS].Value.l = ulContainerFlags; 

    if(bLDAP)
    {
        if(ulFlags & MAPI_UNICODE) // <note> this assumes UNICODE is defined
        {
            lpProps[ircPR_WAB_LDAP_SERVER].ulPropTag = PR_WAB_LDAP_SERVER;
            lpProps[ircPR_WAB_LDAP_SERVER].Value.lpszW = lpszName;
        }
        else
        {
            lpProps[ircPR_WAB_LDAP_SERVER].ulPropTag =  CHANGE_PROP_TYPE( PR_WAB_LDAP_SERVER, PT_STRING8);
            lpProps[ircPR_WAB_LDAP_SERVER].Value.lpszA = lpszNameA;
        }

        lpProps[ircPR_WAB_RESOLVE_FLAG].ulPropTag = PR_WAB_RESOLVE_FLAG;
        lpProps[ircPR_WAB_RESOLVE_FLAG].Value.b = (USHORT) !!fLDAPResolve;
    }
    else
    {
        lpProps[ircPR_WAB_LDAP_SERVER].ulPropTag = PR_NULL;
        lpProps[ircPR_WAB_RESOLVE_FLAG].ulPropTag = PR_NULL;
    }

    if(ulFlags & MAPI_UNICODE) // <note> this assumes UNICODE is defined
    {
        lpProps[ircPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
        lpProps[ircPR_DISPLAY_NAME].Value.lpszW = lpszName;
    }
    else
    {
       lpProps[ircPR_DISPLAY_NAME].ulPropTag = CHANGE_PROP_TYPE( PR_DISPLAY_NAME, PT_STRING8);
        lpProps[ircPR_DISPLAY_NAME].Value.lpszA = lpszNameA;
    }

    if(bProviderID)
    {
        lpProps[ircPR_AB_PROVIDER_ID].ulPropTag = PR_AB_PROVIDER_ID;
        lpProps[ircPR_AB_PROVIDER_ID].Value.bin.cb = sizeof(MAPIUID);
        lpProps[ircPR_AB_PROVIDER_ID].Value.bin.lpb = (LPBYTE)&muidCAB;
    } else 
    {
        lpProps[ircPR_AB_PROVIDER_ID].ulPropTag = PR_NULL;
    }

    lpProps[ircPR_ENTRYID].ulPropTag = PR_ENTRYID;
    if(lpEID)
        lpProps[ircPR_ENTRYID].Value.bin = *lpEID;
    else
    {
        lpProps[ircPR_ENTRYID].Value.bin.cb = cb;
        lpProps[ircPR_ENTRYID].Value.bin.lpb = lpb;
    }

    // Make certain we have proper indicies.
    // For now, we will equate PR_INSTANCE_KEY and PR_RECORD_KEY to PR_ENTRYID.
    lpProps[ircPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
    lpProps[ircPR_INSTANCE_KEY].Value.bin.cb = lpProps[ircPR_ENTRYID].Value.bin.cb;
    lpProps[ircPR_INSTANCE_KEY].Value.bin.lpb = lpProps[ircPR_ENTRYID].Value.bin.lpb;

    lpProps[ircPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY;
    lpProps[ircPR_RECORD_KEY].Value.bin.cb = lpProps[ircPR_ENTRYID].Value.bin.cb;
    lpProps[ircPR_RECORD_KEY].Value.bin.lpb = lpProps[ircPR_ENTRYID].Value.bin.lpb;

}

/*
-   bIsDupeContainerName 
-
*   The Root_GetContentsTable fails badly if there are multiple containers
*   with the same index name because the Table methods can't handle it ..
*
*   Therefore, to prevent such problems, we double-check if a container name
*   is duplicated before adding it to the container list. 
*   
*/
BOOL bIsDupeContainerName(LPSRowSet lpsrs, LPTSTR lpszName)
{
    ULONG i = 0;
    BOOL bRet = FALSE;

    // walk through the rows one by one
    for(i=0;i<lpsrs->cRows;i++)
    {
        LPSPropValue lpProps = lpsrs->aRow[i].lpProps;
        
        if(!lpProps || !lpsrs->aRow[i].cValues)
            continue;

        if( lpProps[ircPR_DISPLAY_NAME].ulPropTag == PR_DISPLAY_NAME &&
            !lstrcmpi(lpProps[ircPR_DISPLAY_NAME].Value.LPSZ, lpszName))
        {
            DebugTrace(TEXT("Found dupe container name .. skipping ...\n"));
            bRet = TRUE;
            break;
        }
    }
    return bRet;
}


/***************************************************
 *
 *  The actual ABContainer methods
 */

/* ---------
 * IMAPIContainer
 */

/*************************************************************************
 *
 *
 -  ROOT_GetContentsTable
 -
 *
 *  ulFlags -   WAB_LOCAL_CONTAINERS means don't add the LDAP containers to this table
 *          Just do the local WAB containers
 *              WAB_NO_PROFILE_CONTAINERS means don't add the profile containers
 *          Just add a single local container that will have all the contents
 *
 */
STDMETHODIMP
ROOT_GetContentsTable(LPROOT lpROOT, ULONG ulFlags, LPMAPITABLE * lppTable)
{
    LPTABLEDATA lpTableData = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc;
    LPSRowSet lpSRowSet = NULL;
    LPSPropValue lpProps = NULL;
    ULONG i;
    ULONG iRow;
    ULONG cProps, cRows, colkci = 0, cwabci = 0;
    ULONG cLDAPContainers = 0;
    TCHAR szBuffer[MAX_PATH];
    IImnAccountManager2 * lpAccountManager = NULL;
    LPSERVER_NAME lpServerNames = NULL, lpNextServer;
	OlkContInfo *rgolkci, *rgwabci;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    BOOL bUserProfileContainersOnly = FALSE;
    BOOL bAllContactsContainerOnly = FALSE;

	// BUGBUG: This routine actually returns the Hierarchy table, not the
	// contents table, but too much code depends on this to change it right
	// now.
#ifdef  PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpROOT, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check to see that it's ROOTs jump table
    if (lpROOT->lpVtbl != &vtblROOT) {
        // Not my jump table
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_UNICODE|WAB_LOCAL_CONTAINERS|WAB_NO_PROFILE_CONTAINERS)) {
        DebugTraceArg(ROOT_GetContentsTable, TEXT("Unknown flags"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppTable, sizeof(LPMAPITABLE))) {
        DebugTraceArg(ROOT_GetContentsTable, TEXT("Invalid Table parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // PARAMETER_VALIDATION

    EnterCriticalSection(&lpROOT->lpIAB->cs);

    // Create a table object
    // [PaulHi] 4/5/99  Use the Internal CreateTableData() function that takes 
    // the ulFlags and will deal with ANSI/UNICODE requests correctly
    sc = CreateTableData(
                NULL,
                (ALLOCATEBUFFER FAR *	) MAPIAllocateBuffer,
                (ALLOCATEMORE FAR *)	MAPIAllocateMore,
                MAPIFreeBuffer,
                NULL,
                TBLTYPE_DYNAMIC,
                PR_RECORD_KEY,
                (LPSPropTagArray)&ITableColumnsRoot,
                NULL,
                0,
                NULL,
                ulFlags,
                &lpTableData);
    if ( FAILED(sc) )
    {
        DebugTrace(TEXT("CreateTableData() failed %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }       
    Assert(lpTableData);

    if(ulFlags & WAB_NO_PROFILE_CONTAINERS)
        bAllContactsContainerOnly = TRUE;

    if(ulFlags & MAPI_UNICODE)
        ((TAD *)lpTableData)->bMAPIUnicodeTable = TRUE;

    // Enumerate the LDAP accounts
    if(!(ulFlags & WAB_LOCAL_CONTAINERS))
    {
        cLDAPContainers = 0;
        if (! HR_FAILED(hResult = InitAccountManager(lpROOT->lpIAB, &lpAccountManager, NULL))) {
            // Count and enumerate LDAP servers to ServerList
            if (hResult = EnumerateLDAPtoServerList(lpAccountManager, &lpServerNames, &cLDAPContainers)) {
                DebugTrace(TEXT("EnumerateLDAPtoServerList -> %x\n"), GetScode(hResult));
                hResult = hrSuccess;    // not fatal
            }
        } else {
            DebugTrace(TEXT("InitAccountManager -> %x\n"), GetScode(hResult));
            hResult = hrSuccess;
        }
    }

    // If this is an outlook session then use the outlook's list of containers
    // as provided by outlook...
    if (pt_bIsWABOpenExSession) {
		colkci = lpROOT->lpIAB->lpPropertyStore->colkci;
		Assert(colkci);
		rgolkci = lpROOT->lpIAB->lpPropertyStore->rgolkci;
		Assert(rgolkci);
	} else
		colkci = 1;

    // If we have a user profile active, then dont return the virtual PAB folder
    // as part of this table .. only return the actual folders in the user's view
    // The test for this is that (1) Have Profiles enabled (2) Have a current user
    // and (3) The NO_PROFILE_CONTAINERS should not have been specified
    bUserProfileContainersOnly = (  bAreWABAPIProfileAware(lpROOT->lpIAB) && 
                                    bIsThereACurrentUser(lpROOT->lpIAB) &&
                                    !bAllContactsContainerOnly);

    // If we have Profile awareness and no NO_PROFILE flag, 
    // use the wab's list of folder
    if (bAreWABAPIProfileAware(lpROOT->lpIAB) && !bAllContactsContainerOnly) 
    {
		cwabci = lpROOT->lpIAB->cwabci;
		Assert(cwabci);
		rgwabci = lpROOT->lpIAB->rgwabci;
		Assert(rgwabci);
	} else
		cwabci = 1;

    // Since outlook and identity_profiles are mutually exclusive, we can
    // do '-1' here to remove whatever container we don't need
    // and if we don't want ldap containers, we can do another -1
    cRows = cwabci + colkci + cLDAPContainers - 1 - (bUserProfileContainersOnly?1:0); // Outlook and Profiles are mutually exclusive
    iRow = 0;                               // current row

    // Allocate the SRowSet
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + cRows * sizeof(SRow),
      &lpSRowSet))) {
        DebugTrace(TEXT("Allocation of SRowSet -> %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }
	MAPISetBufferName(lpSRowSet, TEXT("Root_ContentsTable SRowSet"));
	//	Set each LPSRow to NULL so we can easily free on error
	ZeroMemory( lpSRowSet, (UINT) (sizeof(SRowSet) + cRows * sizeof(SRow)));

    lpSRowSet->cRows = cRows;

    cProps = ircMax;
    if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
        DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }

    //
    // Add our PAB container
    //
    if(!bUserProfileContainersOnly)
    {
        // Load the display name from resource string
        if (!LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szBuffer, ARRAYSIZE(szBuffer))) 
            StrCpyN(szBuffer, szEmpty, ARRAYSIZE(szBuffer));
        {
            ULONG cb = 0;
            LPENTRYID lpb = NULL;
            if (HR_FAILED(hResult = CreateWABEntryID(WAB_PAB, NULL, NULL, NULL, 0, 0, lpProps, &cb, &lpb))) 
                goto exit;

            // Set props for the pab object
            SetContainerlpProps(lpProps, 
                    pt_bIsWABOpenExSession ? lpROOT->lpIAB->lpPropertyStore->rgolkci->lpszName : szBuffer, 
                    iRow,
                    cb, (LPBYTE)lpb, NULL,
                    AB_MODIFIABLE | AB_RECIPIENTS,
                    pt_bIsWABOpenExSession ? 1 : 0, 
                    pt_bIsWABOpenExSession ? TRUE : FALSE,
                    ulFlags,
                    FALSE, FALSE);
        }

        // Attach the props to the SRowSet
        lpSRowSet->aRow[iRow].lpProps = lpProps;
        lpSRowSet->aRow[iRow].cValues = cProps;
        lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

        iRow++;
    }

	//
	// Next, add any additional containers
	//
	for (i = 1; i < colkci; i++) {

		if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
			DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
			hResult = ResultFromScode(sc);
			goto exit;
		}

        SetContainerlpProps(lpProps, 
                rgolkci[i].lpszName, iRow,
                0, NULL, rgolkci[i].lpEntryID,
                AB_MODIFIABLE | AB_RECIPIENTS,
                1, TRUE,
                ulFlags,
                FALSE, FALSE);

	    // Attach the props to the SRowSet
	    lpSRowSet->aRow[iRow].lpProps = lpProps;
	    lpSRowSet->aRow[iRow].cValues = cProps;
	    lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

		iRow++;
	}

	for (i = 1; i < cwabci; i++) 
    {

		if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
			DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
			hResult = ResultFromScode(sc);
			goto exit;
		}

        SetContainerlpProps(lpProps, 
                rgwabci[i].lpszName, iRow,
                0, NULL, rgwabci[i].lpEntryID,
                AB_MODIFIABLE | AB_RECIPIENTS,
                1, TRUE,
                ulFlags,
                FALSE, FALSE);

	    // Attach the props to the SRowSet
	    lpSRowSet->aRow[iRow].lpProps = lpProps;
	    lpSRowSet->aRow[iRow].cValues = cProps;
	    lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

		iRow++;
	}

    //
    // Now, add the LDAP objects
    //
    lpNextServer = lpServerNames;

    for (i = 0; i < cLDAPContainers && lpNextServer; i++) 
    {
        UNALIGNED WCHAR *lpName = lpNextServer->lpszName;

        if (lpName) 
        {
            LDAPSERVERPARAMS sParams;

            if(bIsDupeContainerName(lpSRowSet, (LPTSTR) lpName))
            {
                lpSRowSet->cRows--;
                goto endloop;
            }

            //DebugTrace(TEXT("LDAP Server: %s\n"), lpNextServer->lpszName);
            cProps = ircMax;

            if (FAILED(sc = MAPIAllocateBuffer(ircMax * sizeof(SPropValue), &lpProps))) {
                DebugTrace(TEXT("ROOT_GetContentsTable: Allocation of props -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            GetLDAPServerParams(lpNextServer->lpszName, &sParams);

            {
                ULONG cb = 0;
                LPENTRYID lpb = NULL;
                LPVOID pv = lpName;

                if (HR_FAILED(hResult = CreateWABEntryID(WAB_LDAP_CONTAINER,
                                      pv,       // server name
                                      NULL, NULL, 0, 0,
                                      lpProps, &cb, &lpb))) 
                {
                    goto exit;
                }

                SetContainerlpProps(lpProps, 
                        (LPTSTR) lpName, iRow,
                        cb, (LPBYTE)lpb, NULL,
                        AB_FIND_ON_OPEN | AB_UNMODIFIABLE,
                        0, FALSE,
                        ulFlags,
                        TRUE, sParams.fResolve);
            }

            FreeLDAPServerParams(sParams);

            // Attach the props to the SRowSet
            lpSRowSet->aRow[iRow].lpProps = lpProps;
            lpSRowSet->aRow[iRow].cValues = cProps;
            lpSRowSet->aRow[iRow].ulAdrEntryPad = 0;

            iRow++;
        }
endloop:
        lpNextServer = lpNextServer->lpNext;
    }


    // Add all this data we just created to the the Table.
    if (hResult = lpTableData->lpVtbl->HrModifyRows(lpTableData,
      0,    // ulFlags
      lpSRowSet)) {
        DebugTraceResult( TEXT("ROOT_GetContentsTable:HrModifyRows"), hResult);
        goto exit;
    }


    hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
      NULL,                     // LPSSortOrderSet lpsos,
      ContentsViewGone,         //  CALLERRELEASE FAR * lpfReleaseCallback,
      0,                        //  ULONG                               ulReleaseData,
      lppTable);                //  LPMAPITABLE FAR *   lplpmt)

exit:

    while(lpServerNames)
    {
        lpNextServer = lpServerNames;
        lpServerNames = lpServerNames->lpNext;
        LocalFreeAndNull(&lpNextServer->lpszName);
        LocalFreeAndNull(&lpNextServer);
    }

    FreeProws(lpSRowSet);

    // Cleanup table if failure
    if (HR_FAILED(hResult)) {
        if (lpTableData) {
            UlRelease(lpTableData);
        }
    }

    LeaveCriticalSection(&lpROOT->lpIAB->cs);

    return(hResult);
}


/*************************************************************************
 *
 *
 -      ROOT_GetHierarchyTable
 -
 *  Returns the merge of all the root hierarchy tables
 *
 *
 *
 */

STDMETHODIMP
ROOT_GetHierarchyTable (LPROOT lpROOT,
        ULONG ulFlags,
        LPMAPITABLE * lppTable)
{
    LPTSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr = hrSuccess;

#ifdef  PARAMETER_VALIDATION
    // Validate parameters
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpROOT, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check to see that it's ROOTs jump table
    if (lpROOT->lpVtbl != &vtblROOT) {
        // Not my jump table
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // See if I can set the return variable
    if (IsBadWritePtr (lppTable, sizeof (LPMAPITABLE))) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check flags:
    //   The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS
    if (ulFlags & ~(CONVENIENT_DEPTH|MAPI_DEFERRED_ERRORS|MAPI_UNICODE)) {
        DebugTraceArg(ROOT_GetHierarchyTable, TEXT("Unknown flags used"));
    //    return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif

	// BUGBUG: We use the code which is incorrectly in GetContentsTable...
    hr = ROOT_GetContentsTable(lpROOT, ulFlags & ~CONVENIENT_DEPTH, lppTable);

    DebugTraceResult(ROOT_GetHierarchyTable, hr);
    return(hr);
}


/*************************************************************************
 *
 *
 -  ROOT_OpenEntry
 -
 *  Just call ABP_OpenEntry
 *
 *
 *
 */
STDMETHODIMP
ROOT_OpenEntry(LPROOT lpROOT,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk)
{
#ifdef  PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, OpenEntry, lpVtbl)) {
        // jump table not large enough to support this method
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryids are valid
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID) lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(ROOT_OpenEntry, TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  TEXT("Undefined bits set in EntryID flags\n"));
    }
*/

    // Don't check the interface parameter unless the entry is something
    // MAPI itself handles. The provider should return an error if this
    // parameter is something that it doesn't understand.
    // At this point, we just make sure it's readable.

    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("lpInterface fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr((LPVOID) lpulObjType, sizeof (ULONG))) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("lpulObjType"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr((LPVOID) lppUnk, sizeof (LPUNKNOWN))) {
        DebugTraceArg(ROOT_OpenEntry, TEXT("lppUnk"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // PARAMETER_VALIDATION

    // Should just call IAB::OpenEntry()...
    return(lpROOT->lpIAB->lpVtbl->OpenEntry(lpROOT->lpIAB,
      cbEntryID,
      lpEntryID,
      lpInterface,
      ulFlags,
      lpulObjType,
      lppUnk));
}


STDMETHODIMP
ROOT_SetSearchCriteria(LPROOT lpROOT,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags)
{

#ifdef PARAMETER_VALIDATION
    // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, SetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(ROOT_SetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the restriction
    if (lpRestriction && IsBadReadPtr(lpRestriction, sizeof(SRestriction))) {
        DebugTraceArg(ROOT_SetSearchCriteria, TEXT("Bad Restriction parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (FBadEntryList(lpContainerList)) {
        DebugTraceArg(ROOT_SetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulSearchFlags & ~(STOP_SEARCH | RESTART_SEARCH | RECURSIVE_SEARCH
      | SHALLOW_SEARCH | FOREGROUND_SEARCH | BACKGROUND_SEARCH)) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif  // PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


STDMETHODIMP
ROOT_GetSearchCriteria(LPROOT lpROOT,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState)
{
#ifdef PARAMETER_VALIDATION

   // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, GetSearchCriteria, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Bad object/vtble"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_UNICODE)) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Unknown Flags"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    // ensure we can write the restriction
    if (lppRestriction && IsBadWritePtr(lppRestriction, sizeof(LPSRestriction))) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Bad Restriction write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list

    if (lppContainerList &&  IsBadWritePtr(lppContainerList, sizeof(LPENTRYLIST))) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("Bad ContainerList parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }


    if (lpulSearchState && IsBadWritePtr(lpulSearchState, sizeof(ULONG))) {
        DebugTraceArg(ROOT_GetSearchCriteria, TEXT("lpulSearchState fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif  // PARAMETER_VALIDATION

        return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


//----------------------------------------------------------------------------
// Synopsis:    ROOT_CreateEntry()
//
// Description:
//                              If called from a OneOff container a OneOff MAIL_USER object
//                              is created via the use of any arbitrary template.
//                              CreateEntry is not supported from a ROOT container.
//
// Parameters:
// Returns:
// Effects:
//
// Notes:               OneOff EntryIDs contain MAPI_UNICODE flag information in
//                              the ulDataType member.
//
// Revision:
//----------------------------------------------------------------------------
STDMETHODIMP
ROOT_CreateEntry(LPROOT lpROOT,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppMAPIPropEntry)
{
    BYTE bType;

#ifdef PARAMETER_VALIDATION

    // Validate the object.
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, CreateEntry, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Bad object/Vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryid are bad
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab)
          || IsBadReadPtr((LPVOID) lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(ROOT_CreateEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  "Undefined bits set in EntryID flags\n");
    } else {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("lpEntryID NULL"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
*/

    if (ulCreateFlags & ~(CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE
      | CREATE_REPLACE | CREATE_MERGE)) {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppMAPIPropEntry, sizeof(LPMAPIPROP))) {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Bad MAPI Property write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // PARAMETER_VALIDATION

#ifdef NEVER
    if (lpROOT->ulType == AB_ROOT)
        return ResultFromScode(MAPI_E_NO_SUPPORT);
#endif // NEVER

    // What kind of entry are we creating?
    // Default is MailUser

    bType = IsWABEntryID(cbEntryID, lpEntryID, NULL, NULL, NULL, NULL, NULL);

    if (bType == WAB_DEF_MAILUSER || cbEntryID == 0) {
        //
        //  Create a new (in memory) entry and return it's mapiprop
        //
        return(HrNewMAILUSER(lpROOT->lpIAB, lpROOT->pmbinOlk, MAPI_MAILUSER, ulCreateFlags, lppMAPIPropEntry));
    } else if (bType == WAB_DEF_DL) {
        //
        // Create a new (in memory) distribution list and return it's mapiprop?
        return(HrNewMAILUSER(lpROOT->lpIAB, lpROOT->pmbinOlk, MAPI_DISTLIST, ulCreateFlags, lppMAPIPropEntry));
    } else {
        DebugTrace(TEXT("ROOT_CreateEntry got unknown template entryID\n"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
}


/*
 -      CopyEntries
 -
 *      Copies a list of entries into this container...  Since you can't
 *      do that with this container we just return not supported.
 */

STDMETHODIMP
ROOT_CopyEntries(LPROOT lpROOT,
  LPENTRYLIST lpEntries,
  ULONG_PTR ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags)
{
#ifdef PARAMETER_VALIDATION

    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, CopyEntries, lpVtbl)) {
        //  jump table not large enough to support this method

        DebugTraceArg(ROOT_CopyEntries,  TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list

    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(ROOT_CopyEntries,  TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulUIParam && !IsWindow((HWND)ulUIParam)) {
        DebugTraceArg(ROOT_CopyEntries,  TEXT("Invalid window handle"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (lpProgress && IsBadReadPtr(lpProgress, sizeof(IMAPIProgress))) {
        DebugTraceArg(ROOT_CopyEntries,  TEXT("Bad MAPI Progress parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(AB_NO_DIALOG | CREATE_CHECK_DUP_LOOSE)) {
        DebugTraceArg(ROOT_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
#endif  // PARAMETER_VALIDATION

    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/*
 -  DeleteEntries
 -
 *
 *  Deletes entries within this container...  Funny that.  There really
 *  isn't a true container here.  Do we just say "Sure, that worked just
 *  fine" or "Sorry this operation not supported."  I don't think it really
 *  matters...  For now it's the former.
 */
STDMETHODIMP
ROOT_DeleteEntries (LPROOT lpROOT,
                                        LPENTRYLIST                     lpEntries,
                                        ULONG                           ulFlags)
{
    ULONG i;
    HRESULT hResult = hrSuccess;
    ULONG cDeleted = 0;
    ULONG cToDelete;
    SCODE sc;

#ifndef DONT_ADDREF_PROPSTORE
    if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpROOT->lpIAB->lpPropertyStore)))) {
        hResult = ResultFromScode(sc);
        goto exitNotAddRefed;
    }
#endif

#ifdef PARAMETER_VALIDATION
    if (BAD_STANDARD_OBJ(lpROOT, ROOT_, DeleteEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(ROOT_DeleteEntries,  TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(ROOT_DeleteEntries,  TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags) {
        DebugTraceArg(ROOT_DeleteEntries,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

#endif  // PARAMETER_VALIDATION


    // List of entryids is in lpEntries.  This is a counted array of
    // entryid SBinary structs.

    cToDelete = lpEntries->cValues;


    // Delete each entry
    for (i = 0; i < cToDelete; i++) 
    {
        if(0 != IsWABEntryID(lpEntries->lpbin[i].cb,
                             (LPENTRYID) IntToPtr(lpEntries->lpbin[i].cb),
                             NULL, NULL, NULL, NULL, NULL)) 
        {
            DebugTrace(TEXT("CONTAINER_DeleteEntries got bad entryid of size %u\n"), lpEntries->lpbin[i].cb);
            continue;
        }

        hResult = DeleteCertStuff((LPADRBOOK)lpROOT->lpIAB, (LPENTRYID)lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb);

        hResult = HrSaveHotmailSyncInfoOnDeletion((LPADRBOOK) lpROOT->lpIAB, &(lpEntries->lpbin[i]));

        if (HR_FAILED(hResult = DeleteRecord(lpROOT->lpIAB->lpPropertyStore->hPropertyStore,
                                            &(lpEntries->lpbin[i])))) {
            DebugTraceResult( TEXT("DeleteEntries: DeleteRecord"), hResult);
            continue;
        }
        cDeleted++;
    }

    if (! hResult) {
        if (cDeleted != cToDelete) {
            hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            DebugTrace(TEXT("DeleteEntries deleted %u of requested %u\n"), cDeleted, cToDelete);
        }
    }

#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpROOT->lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    return(hResult);
}



STDMETHODIMP
ROOT_ResolveNames(      LPROOT                  lpRoot,
                                        LPSPropTagArray lptagaColSet,
                                        ULONG                   ulFlags,
                                        LPADRLIST               lpAdrList,
                                        LPFlagList              lpFlagList)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ansiwrap.h ===
/*
-
-
-	AnsiWrap.h
*
*	Contains the declarations for the Win9x Thunkers implemented in 
*	ansiwrap.c
*
*/

extern BOOL g_bRunningOnNT; //set in entry.c


// ADVAPI32.DLL

LONG WINAPI RegOpenKeyExWrapW(  HKEY       hKey,         // handle to open key
                                LPCTSTR    lpSubKey,     // address of name of subkey to open
                                DWORD      ulOptions,    // reserved
                                REGSAM     samDesired,   // security access mask
                                PHKEY      phkResult);   // address of handle to open key

                            
LONG WINAPI RegQueryValueWrapW(  HKEY       hKey,         // handle to key to query
                                 LPCTSTR    lpSubKey,     // name of subkey to query
                                 LPTSTR     lpValue,      // buffer for returned string
                                 PLONG      lpcbValue);   // receives size of returned string

LONG WINAPI RegEnumKeyExWrapW(   HKEY      hKey,          // handle to key to enumerate
                                 DWORD     dwIndex,       // index of subkey to enumerate
                                 LPTSTR    lpName,        // address of buffer for subkey name
                                 LPDWORD   lpcbName,      // address for size of subkey buffer
                                 LPDWORD   lpReserved,    // reserved
                                 LPTSTR    lpClass,       // address of buffer for class string
                                 LPDWORD   lpcbClass,     // address for size of class buffer
                                 PFILETIME lpftLastWriteTime );
                                                          // address for time key last written to

LONG WINAPI RegSetValueWrapW(    HKEY    hKey,        // handle to key to set value for
                                 LPCTSTR lpSubKey,    // address of subkey name
                                 DWORD   dwType,      // type of value
                                 LPCTSTR lpData,      // address of value data
                                 DWORD   cbData );    // size of value data

LONG WINAPI RegDeleteKeyWrapW(   HKEY    hKey,        // handle to open key
                                 LPCTSTR lpSubKey);   // address of name of subkey to delete

BOOL WINAPI GetUserNameWrapW(    LPTSTR  lpBuffer,    // address of name buffer
                                 LPDWORD nSize );     // address of size of name buffer

LONG WINAPI RegEnumValueWrapW(   HKEY    hKey,           // handle to key to query
                                 DWORD   dwIndex,        // index of value to query
                                 LPTSTR  lpValueName,    // address of buffer for value string
                                 LPDWORD lpcbValueName,  // address for size of value buffer
                                 LPDWORD lpReserved,     // reserved
                                 LPDWORD lpType,         // address of buffer for type code
                                 LPBYTE  lpData,         // address of buffer for value data
                                 LPDWORD lpcbData );     // address for size of data buffer

LONG WINAPI RegDeleteValueWrapW( HKEY    hKey,           // handle to key
                                 LPCTSTR lpValueName );  // address of value name

LONG WINAPI RegCreateKeyWrapW(   HKEY    hKey,          // handle to an open key
                                 LPCTSTR lpSubKey,      // address of name of subkey to open
                                 PHKEY   phkResult  );  // address of buffer for opened handle


// in header file wincrypt.h
BOOL WINAPI CryptAcquireContextWrapW( HCRYPTPROV *phProv,      // out
                                      LPCTSTR    pszContainer, // in
                                      LPCTSTR    pszProvider,  // in
                                      DWORD      dwProvType,   // in
                                      DWORD      dwFlags );    // in

LONG WINAPI RegQueryValueExWrapW( HKEY     hKey,           // handle to key to query
                                  LPCTSTR  lpValueName,    // address of name of value to query
                                  LPDWORD  lpReserved,     // reserved
                                  LPDWORD  lpType,         // address of buffer for value type
                                  LPBYTE   lpData,         // address of data buffer
                                  LPDWORD  lpcbData );     // address of data buffer size

LONG WINAPI RegCreateKeyExWrapW(  HKEY    hKey,                // handle to an open key
                                  LPCTSTR lpSubKey,            // address of subkey name
                                  DWORD   Reserved,            // reserved
                                  LPTSTR  lpClass,             // address of class string
                                  DWORD   dwOptions,           // special options flag
                                  REGSAM  samDesired,          // desired security access
                                  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                              // address of key security structure
                                  PHKEY   phkResult,          // address of buffer for opened handle
                                  LPDWORD lpdwDisposition );  // address of disposition value buffer

LONG WINAPI RegSetValueExWrapW(   HKEY    hKey,           // handle to key to set value for
                                  LPCTSTR lpValueName,    // name of the value to set
                                  DWORD   Reserved,       // reserved
                                  DWORD   dwType,         // flag for value type
                                  CONST BYTE *lpData,     // address of value data
                                  DWORD   cbData );       // size of value data

LONG WINAPI RegQueryInfoKeyWrapW( HKEY    hKey,                  // handle to key to query
                                  LPTSTR  lpClass,               // address of buffer for class string
                                  LPDWORD lpcbClass,             // address of size of class string buffer
                                  LPDWORD lpReserved,            // reserved
                                  LPDWORD lpcSubKeys,            // address of buffer for number of subkeys
                                  LPDWORD lpcbMaxSubKeyLen,      // address of buffer for longest subkey 
                                                                 // name length
                                  LPDWORD lpcbMaxClassLen,       // address of buffer for longest class 
                                                                 // string length
                                  LPDWORD lpcValues,             // address of buffer for number of value 
                                                                 // entries
                                  LPDWORD lpcbMaxValueNameLen,   // address of buffer for longest 
                                                                 // value name length
                                  LPDWORD lpcbMaxValueLen,       // address of buffer for longest value 
                                                                 // data length
                                  LPDWORD lpcbSecurityDescriptor,
                                                                 // address of buffer for security 
                                                                 // descriptor length
                                  PFILETIME lpftLastWriteTime);  // address of buffer for last write time
                                                             


//GDI32.DLL

int WINAPI GetObjectWrapW( HGDIOBJ hgdiobj,      // handle to graphics object of interest
                           int     cbBuffer,     // size of buffer for object information
                           LPVOID  lpvObject );  // pointer to buffer for object information

int WINAPI StartDocWrapW(  HDC           hdc,      // handle to device context
                           CONST DOCINFO *lpdi );  // address of structure with file names

HFONT WINAPI CreateFontIndirectWrapW (CONST LOGFONT *lplf );  // pointer to logical font structure


//KERNEL32.DLL

int WINAPI GetLocaleInfoWrapW( LCID   Locale,       // locale identifier
                               LCTYPE LCType,       // type of information
                               LPTSTR lpLCData,     // address of buffer for information
                               int    cchData );    // size of buffer

BOOL WINAPI CreateDirectoryWrapW(LPCTSTR               lpPathName,           // pointer to directory path string
                                 LPSECURITY_ATTRIBUTES lpSecurityAttributes);// pointer to security descriptor

UINT WINAPI GetWindowsDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for Windows directory
                                      UINT   uSize );   // size of directory buffer

UINT WINAPI GetSystemDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for system directory
                                     UINT   uSize );   // size of directory buffer

BOOL WINAPI GetStringTypeWrapW( DWORD    dwInfoType,
                                LPCWSTR  lpSrcStr,
                                int      cchSrc,
                                LPWORD   lpCharType);

UINT WINAPI GetProfileIntWrapW( LPCTSTR lpAppName,  // address of section name
                                LPCTSTR lpKeyName,  // address of key name
                                INT     nDefault ); // default value if key name is not found

int WINAPI LCMapStringWrapW( LCID    Locale,      // locale identifier
                             DWORD   dwMapFlags,  // mapping transformation type
                             LPCTSTR lpSrcStr,    // address of source string
                             int     cchSrc,      // number of characters in source string
                             LPTSTR  lpDestStr,   // address of destination buffer
                             int     cchDest );   // size of destination buffer

DWORD WINAPI GetFileAttributesWrapW( LPCTSTR lpFileName );  // pointer to the name of a file or directory

int WINAPI CompareStringWrapW( LCID    Locale,        // locale identifier
                               DWORD   dwCmpFlags,    // comparison-style options
                               LPCTSTR lpString1,     // pointer to first string
                               int     cchCount1,     // size, in bytes or characters, of first string
                               LPCTSTR lpString2,     // pointer to second string
                               int     cchCount2 );   // size, in bytes or characters, of second string

HANDLE WINAPI CreateEventWrapW(LPSECURITY_ATTRIBUTES lpEventAttributes, // pointer to security attributes
                               BOOL bManualReset,     // flag for manual-reset event
                               BOOL bInitialState,    // flag for initial state
                               LPCTSTR lpcwszName);   // pointer to event-object name


//  CompareStringA
LPTSTR WINAPI lstrcpyWrapW( LPTSTR  lpString1,     // pointer to buffer
                            LPCTSTR lpString2 );   // pointer to string to copy

int WINAPI lstrcmpiWrapW( LPCTSTR lpString1,    // pointer to first string
                          LPCTSTR lpString2 );  // pointer to second string

HINSTANCE WINAPI LoadLibraryWrapW( LPCTSTR lpLibFileName );  // address of filename of executable module

int WINAPI GetTimeFormatWrapW( LCID    Locale,            // locale for which time is to be formatted
                               DWORD   dwFlags,           // flags specifying function options
                               CONST SYSTEMTIME *lpTime,  // time to be formatted
                               LPCTSTR lpFormat,          // time format string
                               LPTSTR  lpTimeStr,         // buffer for storing formatted string
                               int     cchTime  );        // size, in bytes or characters, of the buffer

BOOL WINAPI GetTextExtentPoint32WrapW(HDC     hdc,
                                      LPCWSTR pwszBuf,
                                      int     nLen,
                                      LPSIZE  psize);

int WINAPI GetDateFormatWrapW( LCID    Locale,             // locale for which date is to be formatted
                               DWORD   dwFlags,            // flags specifying function options
                               CONST SYSTEMTIME *lpDate,   // date to be formatted
                               LPCTSTR lpFormat,           // date format string
                               LPTSTR  lpDateStr,          // buffer for storing formatted string
                               int     cchDate );          // size of buffer


LPTSTR WINAPI lstrcpynWrapW( LPTSTR  lpString1,     // pointer to target buffer
                             LPCTSTR lpString2,     // pointer to source string
                             int     iMaxLength );  // number of bytes or characters to copy


HANDLE WINAPI CreateFileWrapW( LPCTSTR lpFileName,             // pointer to name of the file
                               DWORD   dwDesiredAccess,        // access (read-write) mode
                               DWORD   dwShareMode,            // share mode
                               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                               // pointer to security attributes
                               DWORD   dwCreationDisposition,  // how to create
                               DWORD   dwFlagsAndAttributes,   // file attributes
                               HANDLE  hTemplateFile );        // handle to file with attributes to copy
                               

VOID WINAPI OutputDebugStringWrapW(LPCTSTR lpOutputString );   // pointer to string to be displayed

LPTSTR WINAPI lstrcatWrapW( LPTSTR  lpString1,     // pointer to buffer for concatenated strings
                            LPCTSTR lpString2 );   // pointer to string to add to string1

DWORD WINAPI FormatMessageWrapW( DWORD    dwFlags,       // source and processing options
                                 LPCVOID  lpSource,      // pointer to  message source
                                 DWORD    dwMessageId,   // requested message identifier
                                 DWORD    dwLanguageId,  // language identifier for requested message
                                 LPTSTR   lpBuffer,      // pointer to message buffer
                                 DWORD    nSize,         // maximum size of message buffer
                                 va_list *Arguments );   // pointer to array of message inserts

DWORD WINAPI GetModuleFileNameWrapW( HMODULE hModule,    // handle to module to find filename for
                                     LPTSTR  lpFilename, // pointer to buffer to receive module path
                                     DWORD   nSize );    // size of buffer, in characters

UINT WINAPI GetPrivateProfileIntWrapW( LPCTSTR  lpAppName,    // address of section name
                                       LPCTSTR  lpKeyName,    // address of key name
                                       INT      nDefault,     // return value if key name is not found
                                       LPCTSTR  lpFileName ); // address of initialization filename

BOOL WINAPI IsBadStringPtrWrapW( LPCTSTR lpsz,       // address of string
                                 UINT_PTR    ucchMax );  // maximum size of string

DWORD WINAPI GetPrivateProfileStringWrapW( LPCTSTR lpAppName,          // points to section name
                                           LPCTSTR lpKeyName,          // points to key name
                                           LPCTSTR lpDefault,          // points to default string
                                           LPTSTR  lpReturnedString,   // points to destination buffer
                                           DWORD   nSize,              // size of destination buffer
                                           LPCTSTR lpFileName  );      // points to initialization filename

int WINAPI lstrcmpWrapW( LPCTSTR lpString1,    // pointer to first string
                         LPCTSTR lpString2 );  // pointer to second string

HANDLE WINAPI CreateMutexWrapW( LPSECURITY_ATTRIBUTES lpMutexAttributes,
                                                                       // pointer to security attributes
                                BOOL                  bInitialOwner,   // flag for initial ownership
                                LPCTSTR               lpName );        // pointer to mutex-object name

DWORD WINAPI GetTempPathWrapW( DWORD   nBufferLength,   // size, in characters, of the buffer
                               LPTSTR  lpBuffer );      // pointer to buffer for temp. path

DWORD WINAPI ExpandEnvironmentStringsWrapW( LPCTSTR lpSrc,     // pointer to string with environment variables
                                            LPTSTR  lpDst,     // pointer to string with expanded environment 
                                                               // variables
                                            DWORD   nSize );   // maximum characters in expanded string

UINT WINAPI GetTempFileNameWrapW( LPCTSTR lpPathName,        // pointer to directory name for temporary file
                                  LPCTSTR lpPrefixString,    // pointer to filename prefix
                                  UINT    uUnique,           // number used to create temporary filename
                                  LPTSTR  lpTempFileName  ); // pointer to buffer that receives the new filename                                                           

// BOOL WINAPI ReleaseMutexWrapW( HANDLE hMutex );  // handle to mutex object

                                                        
BOOL WINAPI DeleteFileWrapW( LPCTSTR lpFileName  ); // pointer to name of file to delete

BOOL WINAPI CopyFileWrapW( LPCTSTR lpExistingFileName, // pointer to name of an existing file
                           LPCTSTR lpNewFileName,      // pointer to filename to copy to
                           BOOL    bFailIfExists );    // flag for operation if file exists

HANDLE WINAPI FindFirstChangeNotificationWrapW(LPCTSTR lpcwszFilePath,  // Directory path of file to watch
                                               BOOL    bWatchSubtree,   // Monitor entire tree
                                               DWORD   dwNotifyFilter); // Conditions to watch for


HANDLE WINAPI FindFirstFileWrapW( LPCTSTR           lpFileName,       // pointer to name of file to search for
                                  LPWIN32_FIND_DATA lpFindFileData ); // pointer to returned information
                       

BOOL WINAPI GetDiskFreeSpaceWrapW( LPCTSTR lpRootPathName,       // pointer to root path
                                   LPDWORD lpSectorsPerCluster,  // pointer to sectors per cluster
                                   LPDWORD lpBytesPerSector,     // pointer to bytes per sector
                                   LPDWORD lpNumberOfFreeClusters,
                                                                 // pointer to number of free clusters
                                   LPDWORD lpTotalNumberOfClusters );
                                                                 // pointer to total number of clusters

BOOL WINAPI MoveFileWrapW( LPCTSTR lpExistingFileName,   // pointer to the name of the existing file
                           LPCTSTR lpNewFileName );      // pointer to the new name for the file


//SHELL32.DLL


HINSTANCE WINAPI ShellExecuteWrapW( HWND     hwnd, 
                                    LPCTSTR  lpOperation,
                                    LPCTSTR  lpFile, 
                                    LPCTSTR  lpParameters, 
                                    LPCTSTR  lpDirectory,
                                    INT      nShowCmd );
	

UINT WINAPI DragQueryFileWrapW( HDROP   hDrop,
                                UINT    iFile,
                                LPTSTR  lpszFile,
                                UINT    cch );



//USER32.DLL
LPTSTR WINAPI CharPrevWrapW( LPCTSTR lpszStart,      // pointer to first character
                             LPCTSTR lpszCurrent );  // pointer to current character

int WINAPI DrawTextWrapW( HDC     hDC,          // handle to device context
                          LPCTSTR lpString,     // pointer to string to draw
                          int     nCount,       // string length, in characters
                          LPRECT  lpRect,       // pointer to struct with formatting dimensions
                          UINT    uFormat );    // text-drawing flags

BOOL WINAPI ModifyMenuWrapW( HMENU   hMnu,         // handle to menu
                             UINT    uPosition,    // menu item to modify
                             UINT    uFlags,       // menu item flags
                             UINT_PTR    uIDNewItem,   // menu item identifier or handle to drop-down 
                                                   // menu or submenu
                             LPCTSTR lpNewItem );  // menu item content

BOOL WINAPI InsertMenuWrapW( HMENU   hMenu,       // handle to menu
                             UINT    uPosition,   // menu item that new menu item precedes
                             UINT    uFlags,      // menu item flags
                             UINT_PTR    uIDNewItem,  // menu item identifier or handle to drop-down 
                                                  // menu or submenu
                             LPCTSTR lpNewItem ); // menu item content

HANDLE WINAPI LoadImageWrapW( HINSTANCE hinst,      // handle of the instance containing the image
                              LPCTSTR   lpszName,   // name or identifier of image
                              UINT      uType,      // type of image
                              int       cxDesired,  // desired width
                              int       cyDesired,  // desired height
                              UINT      fuLoad );   // load flags

BOOL WINAPI GetClassInfoExWrapW( HINSTANCE    hinst,      // handle of application instance
                                 LPCTSTR      lpszClass,  // address of class name string
                                 LPWNDCLASSEX lpwcx );    // address of structure for class data

int WINAPI LoadStringWrapW( HINSTANCE hInstance,     // handle to module containing string resource
                            UINT      uID,           // resource identifier
                            LPTSTR    lpBuffer,      // pointer to buffer for resource
                            int       nBufferMax  ); // size of buffer

LPTSTR WINAPI CharNextWrapW( LPCTSTR lpsz );  // pointer to current character

LRESULT WINAPI SendMessageWrapW( HWND   hWnd,      // handle of destination window
                                 UINT   Msg,       // message to send
                                 WPARAM wParam,    // first message parameter
                                 LPARAM lParam );  // second message parameter

LRESULT WINAPI DefWindowProcWrapW( HWND   hWnd,      // handle to window
                                   UINT   Msg,       // message identifier
                                   WPARAM wParam,    // first message parameter
                                   LPARAM lParam );  // second message parameter

int WINAPI wsprintfWrapW( LPTSTR lpOut,      // pointer to buffer for output
                          LPCTSTR lpFmt,     // pointer to format-control string
                          ...            );  // optional arguments

int WINAPI wvsprintfWrapW( LPTSTR lpOutput,    // pointer to buffer for output
                           LPCTSTR lpFormat,   // pointer to format-control string
                           va_list arglist );  // variable list of format-control arguments

INT_PTR WINAPI DialogBoxParamWrapW( HINSTANCE hInstance,       // handle to application instance
                                LPCTSTR   lpTemplateName,  // identifies dialog box template
                                HWND      hWndParent,      // handle to owner window
                                DLGPROC   lpDialogFunc,    // pointer to dialog box procedure
                                LPARAM    dwInitParam );   // initialization value

LRESULT WINAPI SendDlgItemMessageWrapW( HWND   hDlg,        // handle of dialog box
                                     int    nIDDlgItem,  // identifier of control
                                     UINT   Msg,         // message to send
                                     WPARAM wParam,      // first message parameter
                                     LPARAM lParam  );   // second message parameter

LONG WINAPI SetWindowLongWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG dwNewLong );  // new value

LONG WINAPI GetWindowLongWrapW( HWND hWnd,    // handle of window
                                int  nIndex ); // offset of value to retrieve

LONG_PTR WINAPI SetWindowLongPtrWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG_PTR dwNewLong );  // new value

LONG_PTR WINAPI GetWindowLongPtrWrapW( HWND hWnd,    // handle of window
                                int  nIndex ); // offset of value to retrieve

HWND WINAPI CreateWindowExWrapW( DWORD     dwExStyle,    // extended window style
                                 LPCTSTR   lpClassName,  // pointer to registered class name
                                 LPCTSTR   lpWindowName, // pointer to window name
                                 DWORD     dwStyle,      // window style
                                 int       x,            // horizontal position of window
                                 int       y,            // vertical position of window
                                 int       nWidth,       // window width
                                 int       nHeight,      // window height
                                 HWND      hWndParent,   // handle to parent or owner window
                                 HMENU     hMenu,        // handle to menu, or child-window identifier
                                 HINSTANCE hInstance,    // handle to application instance
                                 LPVOID    lpParam  );   // pointer to window-creation data


BOOL WINAPI UnregisterClassWrapW( LPCTSTR    lpClassName,  // address of class name string
                                  HINSTANCE  hInstance );  // handle of application instance

ATOM WINAPI RegisterClassWrapW(CONST WNDCLASS *lpWndClass );  // address of structure with class date

HCURSOR WINAPI LoadCursorWrapW( HINSTANCE hInstance,      // handle to application instance
                                LPCTSTR   lpCursorName ); // name string or cursor resource identifier

UINT WINAPI RegisterWindowMessageWrapW( LPCTSTR lpString );  // address of message string

BOOL WINAPI SystemParametersInfoWrapW( UINT  uiAction,   // system parameter to query or set
                                       UINT  uiParam,    // depends on action to be taken
                                       PVOID pvParam,    // depends on action to be taken
                                       UINT  fWinIni );  // user profile update flag
/*
// No A & W version.

BOOL WINAPI ShowWindow( HWND hWnd,       // handle to window
                        int nCmdShow );  // show state of window
*/

HWND WINAPI CreateDialogParamWrapW( HINSTANCE hInstance,      // handle to application instance
                                    LPCTSTR   lpTemplateName, // identifies dialog box template
                                    HWND      hWndParent,     // handle to owner window
                                    DLGPROC   lpDialogFunc,   // pointer to dialog box procedure
                                    LPARAM    dwInitParam );  // initialization value

BOOL WINAPI SetWindowTextWrapW( HWND    hWnd,         // handle to window or control
                                LPCTSTR lpString );   // address of string

BOOL WINAPI PostMessageWrapW( HWND   hWnd,      // handle of destination window
                              UINT   Msg,       // message to post
                              WPARAM wParam,    // first message parameter
                              LPARAM lParam  ); // second message parameter

BOOL WINAPI GetMenuItemInfoWrapW( HMENU          hMenu,          
                                  UINT           uItem,           
                                  BOOL           fByPosition,     
                                  LPMENUITEMINFO lpmii        );

BOOL WINAPI GetClassInfoWrapW( HINSTANCE   hInstance,     // handle of application instance
                               LPCTSTR     lpClassName,   // address of class name string
                               LPWNDCLASS  lpWndClass );  // address of structure for class data

LPTSTR WINAPI CharUpperWrapW( LPTSTR lpsz );    // single character or pointer to string

UINT WINAPI RegisterClipboardFormatWrapW( LPCTSTR lpszFormat );  // address of name string

LRESULT WINAPI DispatchMessageWrapW( CONST MSG *lpmsg );  // pointer to structure with message

/* No A & W version
BOOL WINAPI TranslateMessage( IN CONST MSG *lpMsg);
*/

BOOL WINAPI IsDialogMessageWrapW( HWND  hDlg,    // handle of dialog box
                                  LPMSG lpMsg ); // address of structure with message

BOOL WINAPI GetMessageWrapW( LPMSG lpMsg,            // address of structure with message
                             HWND  hWnd,             // handle of window
                             UINT  wMsgFilterMin,    // first message
                             UINT  wMsgFilterMax );  // last message

BOOL WINAPI SetDlgItemTextWrapW( HWND    hDlg,        // handle of dialog box
                                 int     nIDDlgItem,  // identifier of control
                                 LPCTSTR lpString );  // text to set

ATOM WINAPI RegisterClassExWrapW( CONST WNDCLASSEX *lpwcx );  // address of structure with class data

HACCEL WINAPI LoadAcceleratorsWrapW( HINSTANCE hInstance,    // handle to application instance
                                     LPCTSTR lpTableName );  // address of table-name string

HMENU WINAPI LoadMenuWrapW( HINSTANCE hInstance,      // handle to application instance
                            LPCTSTR   lpMenuName );   // menu name string or menu-resource identifier
                        

HICON WINAPI LoadIconWrapW( HINSTANCE hInstance,     // handle to application instance
                           LPCTSTR    lpIconName );  // icon-name string or icon resource identifier
                       

int WINAPI GetWindowTextWrapW( HWND   hWnd,         // handle to window or control with text
                               LPTSTR lpString,     // address of buffer for text
                               int    nMaxCount  ); // maximum number of characters to copy

LRESULT WINAPI CallWindowProcWrapW( WNDPROC lpPrevWndFunc,   // pointer to previous procedure
                                    HWND    hWnd,            // handle to window
                                    UINT    Msg,             // message
                                    WPARAM  wParam,          // first message parameter
                                    LPARAM  lParam  );       // second message parameter

int WINAPI GetClassNameWrapW( HWND   hWnd,           // handle of window
                              LPTSTR lpClassName,    // address of buffer for class name
                              int    nMaxCount );    // size of buffer, in characters

int WINAPI TranslateAcceleratorWrapW( HWND   hWnd,        // handle to destination window
                                      HACCEL hAccTable,   // handle to accelerator table
                                      LPMSG  lpMsg );     // address of structure with message

UINT WINAPI GetDlgItemTextWrapW( HWND   hDlg,        // handle of dialog box
                                 int    nIDDlgItem,  // identifier of control
                                 LPTSTR lpString,    // address of buffer for text
                                 int    nMaxCount ); // maximum size of string

BOOL WINAPI SetMenuItemInfoWrapW( HMENU hMenu,          
                                  UINT  uItem,           
                                  BOOL  fByPosition,     
                                  LPMENUITEMINFO lpmii  );

BOOL WINAPI PeekMessageWrapW( LPMSG lpMsg,          // pointer to structure for message
                              HWND  hWnd,           // handle to window
                              UINT  wMsgFilterMin,  // first message
                              UINT  wMsgFilterMax,  // last message
                              UINT  wRemoveMsg );   // removal flags


// in APIs in ComDlg32.dll


BOOL  WINAPI  pfnGetOpenFileNameWrapW(LPOPENFILENAMEW);
BOOL  WINAPI  pfnGetSaveFileNameWrapW(LPOPENFILENAMEW lpOf);

BOOL    WINAPI   pfnPrintDlgWrapW(LPPRINTDLGW lppd);
HRESULT WINAPI   pfnPrintDlgExWrapW(LPPRINTDLGEXW lppdex);

// run time loaded APIs in Comctl32.dll

INT_PTR     WINAPI gpfnPropertySheetWrapW(LPCPROPSHEETHEADERW lppsh);

HPROPSHEETPAGE WINAPI gpfnCreatePropertySheetPageWrapW(LPCPROPSHEETPAGEW lppsp);

HIMAGELIST WINAPI gpfnImageList_LoadImageWrapW( HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags );


DWORD WINAPI CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength );
DWORD WINAPI CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength );
LPWSTR WINAPI CharLowerWrapW( LPWSTR pch );
LPWSTR WINAPI CharUpperWrapW( LPWSTR pch );
BOOL IsCharUpperWrapW(WCHAR wch);
BOOL IsCharLowerWrapW(WCHAR wch);

int WINAPI GetWindowTextLengthWrapW( HWND hWnd);
LRESULT WINAPI ToolTip_UpdateTipText(HWND hWnd,LPARAM lParam);
LRESULT WINAPI ToolTip_AddTool(HWND hWnd,LPARAM lParam);
LRESULT WINAPI ToolBar_AddString(HWND hWnd, LPARAM lParam);
LRESULT WINAPI ToolBar_AddButtons(HWND hWnd, WPARAM wParam, LPARAM lParam);

DWORD GetFileVersionInfoSizeWrapW( LPTSTR lptstrFilename, LPDWORD lpdwHandle );
BOOL GetFileVersionInfoWrapW( LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
BOOL VerQueryValueWrapW( const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ansiwrap.c ===
/*
-
-   AnsiWrap.c
*
*   Contains wrappers for thunking down Unicode calls to the Win 9x ANSI versions
*
*/


#include "_apipch.h"

// we should not define the Macro for the APIs that we will implement the wrappers for.
// lets try to keep this list alphabetical for sanity

#undef CallWindowProcW
#undef CharLowerW
#undef CharNextW
#undef CharPrevW
#undef CharUpperBuffW
#undef CharUpperBuffW
#undef CharUpperW
#undef CompareStringW
#undef CopyFileW
#undef CreateDialogParamW
#undef CreateDirectoryW
#undef CreateEventW
#undef CreateFileW
#undef CreateFontIndirectW
#undef CreateMutexW
#undef CreateWindowExW
//#undef CryptAcquireContextW
#undef DefWindowProcW
#undef DeleteFileW
#undef DialogBoxParamW
#undef DispatchMessageW
#undef DragQueryFileW
#undef DrawTextW
#undef ExpandEnvironmentStringsW
#undef FindFirstChangeNotificationW
#undef FindFirstFileW
#undef FormatMessageW
#undef GetClassInfoExW
#undef GetClassInfoW
#undef GetClassNameW
#undef GetDateFormatW
#undef GetDiskFreeSpaceW
#undef GetDlgItemTextW
#undef GetFileAttributesW
#undef GetLocaleInfoW
#undef GetMenuItemInfoW
#undef GetMessageW
#undef GetModuleFileNameW
#undef GetObjectW
#undef GetPrivateProfileIntW
#undef GetPrivateProfileStringW
#undef GetProfileIntW
#undef GetStringTypeW
#undef GetSystemDirectoryW
#undef GetTempFileNameW
#undef GetTempPathW
#undef GetTextExtentPoint32W
#undef GetTimeFormatW
#undef GetUserNameW
#undef GetWindowLongW
#undef GetWindowsDirectoryW
#undef GetWindowTextLengthW
#undef GetWindowTextW
#undef InsertMenuW
#undef IsBadStringPtrW
#undef IsCharLowerW
#undef IsCharUpperW
#undef IsDialogMessageW
#undef LCMapStringW
#undef LoadAcceleratorsW
#undef LoadCursorW
#undef LoadIconW
#undef LoadImageW
#undef LoadLibraryW
#undef LoadMenuW
#undef LoadStringW
#undef lstrcatW
#undef lstrcmpiW
#undef lstrcmpW
#undef lstrcpynW
#undef lstrcpyW
#undef ModifyMenuW
#undef MoveFileW
#undef OutputDebugStringW
#undef PeekMessageW
#undef PostMessageW
#undef RegCreateKeyExW
#undef RegCreateKeyW
#undef RegDeleteKeyW
#undef RegDeleteValueW
#undef RegEnumKeyExW
#undef RegEnumValueW
#undef RegisterClassExW
#undef RegisterClassW
#undef RegisterClipboardFormatW
#undef RegisterWindowMessageW
#undef RegOpenKeyExW
#undef RegQueryInfoKeyW
#undef RegQueryValueExW
#undef RegQueryValueW
#undef RegSetValueExW
#undef RegSetValueW
#undef SendDlgItemMessageW
#undef SendMessageW
#undef SetDlgItemTextW
#undef SetMenuItemInfoW
#undef SetWindowLongW
#undef SetWindowTextW
#undef ShellExecuteW
#undef StartDocW
#undef SystemParametersInfoW
#undef TranslateAcceleratorW
#undef UnRegisterClassW
#undef wsprintfW
#undef wvsprintfW

//
//  Do this in every wrapper function to make sure the wrapper
//  prototype matches the function it is intending to replace.
//
#define VALIDATE_PROTOTYPE(f) if (f##W == f##WrapW) 0

#define InRange(val, valMin, valMax) (valMin <= val && val <= valMax)

// Because with current build setting, no lib containing wcscpy and wcslen is linked 
// so implement these two functions here.

LPWSTR My_wcscpy( LPWSTR pwszDest, LPCWSTR pwszSrc ) 

{

    LPWSTR   pwszDestT = NULL;
    LPCWSTR  pwszSrcT;

    pwszSrcT  = pwszSrc;
    pwszDestT = pwszDest;

    while ( *pwszSrcT ) 
        *pwszDestT++ =  *pwszSrcT ++;

    *pwszDestT = 0x0000;

    return pwszDest;
}
    

DWORD  My_wcslen( LPCWSTR  lpwszStr ) 
{

   DWORD   dLen =0;
   LPCWSTR  lpwszStrT;

   lpwszStrT = lpwszStr;
   dLen = 0;

   while ( *lpwszStrT ) {
       dLen ++;
       lpwszStrT ++;
   }

   return dLen;

}


LPWSTR My_wcscat( LPWSTR pwszDest, LPCWSTR pwszSrc ) 

{

    LPWSTR   pwszDestT = pwszDest;

    while ( *pwszDestT ) 
        pwszDestT++;

    My_wcscpy(pwszDestT, pwszSrc);

    return pwszDest;
}
    

// ADVAPI32.DLL

/* RegOpenKeyEx */
LONG WINAPI RegOpenKeyExWrapW(  HKEY       hKey,         // handle to open key
                                LPCTSTR    lpSubKey,     // address of name of subkey to open
                                DWORD      ulOptions,    // reserved
                                REGSAM     samDesired,   // security access mask
                                PHKEY      phkResult)    // address of handle to open key
{

    LPSTR lpSubKeyA = NULL;
    LONG  lRetValue = 0;

    VALIDATE_PROTOTYPE(RegOpenKeyEx);
    
    if (g_bRunningOnNT)
        return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);

 
    lpSubKeyA = ConvertWtoA(lpSubKey);

    lRetValue = RegOpenKeyExA(hKey, lpSubKeyA, ulOptions, samDesired, phkResult);

    LocalFreeAndNull( &lpSubKeyA  );

    return lRetValue;

}

/* RegQueryValue */
LONG WINAPI RegQueryValueWrapW(  HKEY       hKey,         // handle to key to query
                                 LPCTSTR    lpSubKey,     // name of subkey to query
                                 LPTSTR     lpValue,      // buffer for returned string
                                 PLONG      lpcbValue)    // receives size of returned string
{

    LPSTR  lpSubKeyA = NULL;
    LPWSTR lpwszValue = NULL;
    LONG   lRetValue =0;
    LPSTR  lpValueA = NULL;
    LONG   cbValueA = 0;
    

    VALIDATE_PROTOTYPE(RegQueryValue);
    
    if (g_bRunningOnNT)
        return RegQueryValueW(hKey, lpSubKey, lpValue, lpcbValue);

 
    lpSubKeyA = ConvertWtoA(lpSubKey);

    lRetValue = RegQueryValueA(hKey, lpSubKeyA, NULL, &cbValueA);

    if ( lRetValue != ERROR_SUCCESS ) {
         LocalFreeAndNull( &lpSubKeyA);
         return lRetValue;
    }    

    lpValueA = LocalAlloc(LMEM_ZEROINIT, cbValueA);

    lRetValue = RegQueryValueA(hKey, lpSubKeyA, lpValueA, &cbValueA);

    lpwszValue = ConvertAtoW(lpValueA);

    *lpcbValue = (My_wcslen(lpwszValue) + 1 )  * sizeof(WCHAR);

    if ( lpValue != NULL )
        My_wcscpy(lpValue, lpwszValue);

    LocalFreeAndNull( &lpSubKeyA  );
    LocalFreeAndNull( &lpValueA );
    LocalFreeAndNull( &lpwszValue );

    return lRetValue;
 
}

// RegEnumKeyEx
LONG WINAPI RegEnumKeyExWrapW(   HKEY      hKey,          // handle to key to enumerate
                                 DWORD     dwIndex,       // index of subkey to enumerate
                                 LPTSTR    lpName,        // address of buffer for subkey name
                                 LPDWORD   lpcbName,      // address for size of subkey buffer
                                 LPDWORD   lpReserved,    // reserved
                                 LPTSTR    lpClass,       // address of buffer for class string
                                 LPDWORD   lpcbClass,     // address for size of class buffer
                                 PFILETIME lpftLastWriteTime )
                                                          // address for time key last written to
{
    LONG    lRetValue = 0;
    CHAR    lpNameA[MAX_PATH];
    CHAR    lpClassA[MAX_PATH];
    LPWSTR  lpNameW = NULL;
    LPWSTR  lpClassW= NULL;
    DWORD   cbName, cbClass;


    // [PaulHi] 1/11/99  Init wide char buffers
    lpNameA[0] = 0;
    lpClassA[0] = 0;

    VALIDATE_PROTOTYPE(RegEnumKeyEx);
    
    if (g_bRunningOnNT)
        return RegEnumKeyExW(hKey, dwIndex, lpName, lpcbName, lpReserved, lpClass, lpcbClass, lpftLastWriteTime);

    cbName = cbClass = MAX_PATH;

    lRetValue = RegEnumKeyExA(hKey,dwIndex,lpNameA,&cbName,lpReserved,lpClassA,&cbClass,lpftLastWriteTime);

    if ( lRetValue != ERROR_SUCCESS )  return lRetValue;

    lpClassW = ConvertAtoW( lpClassA );
    lpNameW  = ConvertAtoW( lpNameA );

    cbName = My_wcslen(lpNameW) + 1;
    cbClass= My_wcslen(lpClassW) + 1;

    // [PaulHi] 1/11/99  Be careful copying to passed in pointers
    if (lpClass && lpcbClass)
    {
        if (cbClass <= *lpcbClass)
        {
            CopyMemory(lpClass, lpClassW, cbClass * sizeof(WCHAR) );
            *lpcbClass = cbClass;
        }
        else
        {
            Assert(0);
            lpClass[0] = 0;
            *lpcbClass = 0;
            lRetValue = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    if (lpName && lpcbName)
    {
        if (cbName <= *lpcbName)
        {
            CopyMemory(lpName, lpNameW, cbName * sizeof(WCHAR) );
            *lpcbName = cbName;
        }
        else
        {
            Assert(0);
            lpName[0] = 0;
            *lpcbName = 0;
            lRetValue = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    LocalFreeAndNull( &lpClassW );
    LocalFreeAndNull( &lpNameW );

    return lRetValue;
}

/* RegSetValue */
LONG WINAPI RegSetValueWrapW(    HKEY    hKey,        // handle to key to set value for
                                 LPCTSTR lpSubKey,    // address of subkey name
                                 DWORD   dwType,      // type of value
                                 LPCTSTR lpData,      // address of value data
                                 DWORD   cbData )     // size of value data
{
    LPSTR  lpSubKeyA =NULL;
    LPSTR  lpDataA=NULL;
    DWORD  cbDataA =0;
    LONG   lRetValue = 0;

    VALIDATE_PROTOTYPE(RegSetValue);
    
    if (g_bRunningOnNT)
        return RegSetValueW(hKey, lpSubKey, dwType, lpData, cbData);

    lpSubKeyA = ConvertWtoA(lpSubKey );
    lpDataA = ConvertWtoA( lpData );
    cbDataA = lstrlenA( lpDataA );
    lRetValue = RegSetValueA(hKey, lpSubKeyA, dwType, lpDataA, cbDataA);
    
    LocalFreeAndNull( &lpSubKeyA );
    LocalFreeAndNull( &lpDataA );
    return lRetValue;
}

// RegDeleteKey
LONG WINAPI RegDeleteKeyWrapW(   HKEY    hKey,        // handle to open key
                                 LPCTSTR lpSubKey)   // address of name of subkey to delete
{

    LPSTR  lpSubKeyA =NULL;
    LONG   lRetValue = 0;

    VALIDATE_PROTOTYPE(RegDeleteKey);
    
    if (g_bRunningOnNT)
        return RegDeleteKeyW(hKey, lpSubKey);

    lpSubKeyA = ConvertWtoA(lpSubKey );
    lRetValue = RegDeleteKeyA(hKey, lpSubKeyA );

    LocalFreeAndNull ( &lpSubKeyA );

    return lRetValue;

}

// GetUserName
BOOL WINAPI GetUserNameWrapW(    LPTSTR  lpBuffer,    // address of name buffer
                                 LPDWORD nSize )      // address of size of name buffer
{

    CHAR    lpBufferA[MAX_PATH];
    DWORD   nSizeA, nSizeW;
    BOOL    bRetValue;
    LPWSTR  lpwszBuffer = NULL;

    VALIDATE_PROTOTYPE(GetUserName);
    
    if (g_bRunningOnNT)
        return GetUserNameW(lpBuffer, nSize);

    nSizeA = MAX_PATH;
    bRetValue = GetUserNameA( lpBufferA, &nSizeA );

    lpwszBuffer = ConvertAtoW(lpBufferA );
    
    if (lpBuffer == NULL )
        bRetValue = FALSE;

    nSizeW = My_wcslen(lpwszBuffer);
    if ( *nSize < nSizeW ) {
        *nSize = nSizeW + 1;
        bRetValue = FALSE;
    }

    if ( bRetValue == TRUE ) {
        My_wcscpy( lpBuffer, lpwszBuffer );
        *nSize = nSizeW + 1;
    }

    
    LocalFreeAndNull( &lpwszBuffer );

    return bRetValue;
        
}

// RegEnumValue
LONG WINAPI RegEnumValueWrapW(   HKEY    hKey,           // handle to key to query
                                 DWORD   dwIndex,        // index of value to query
                                 LPTSTR  lpValueName,    // address of buffer for value string
                                 LPDWORD lpcbValueName,  // address for size of value buffer
                                 LPDWORD lpReserved,     // reserved
                                 LPDWORD lpType,         // address of buffer for type code
                                 LPBYTE  lpData,         // address of buffer for value data
                                 LPDWORD lpcbData )      // address for size of data buffer
{
    LONG    lRetValue = 0;
    CHAR    lpValueNameA[MAX_PATH];
    LPWSTR  lpValueNameW = NULL, lpDataW= NULL;
    LPSTR   lpDataA = NULL;
    DWORD   cbValueName, cbData;


    VALIDATE_PROTOTYPE(RegEnumValue);
    
    if (g_bRunningOnNT)
        return RegEnumValueW(hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData);

    // [PaulHi] Validate return parameters
    if (!lpValueName || !lpcbValueName)
        return ERROR_INVALID_PARAMETER;

    if ( lpData && lpcbData &&( *lpcbData != 0 ) )
    {
       lpDataA = LocalAlloc( LMEM_ZEROINIT, *lpcbData );

       cbData = *lpcbData;
    }

    cbValueName = MAX_PATH;

    lRetValue = RegEnumValueA(hKey, dwIndex, lpValueNameA, &cbValueName, lpReserved, lpType, lpDataA, &cbData);

    if ( lRetValue != ERROR_SUCCESS ) return lRetValue;

    lpValueNameW = ConvertAtoW( lpValueNameA );
    cbValueName = My_wcslen( lpValueNameW ) + 1;
    
    if ( lpType && (*lpType != REG_EXPAND_SZ) && ( *lpType!= REG_MULTI_SZ) && ( *lpType != REG_SZ ) )
    {
        CopyMemory(lpValueName, lpValueNameW, cbValueName * sizeof(WCHAR) );
        *lpcbValueName = cbValueName;

        if ( lpData && lpcbData) {
           CopyMemory(lpData, lpDataA, cbData );
           *lpcbData = cbData;
           LocalFreeAndNull( &lpDataA );
        }

        LocalFreeAndNull( &lpValueNameW );

        return lRetValue;
    }


    if ( lpType && ((*lpType == REG_EXPAND_SZ) || (*lpType == REG_SZ)) )
    {
        CopyMemory(lpValueName, lpValueNameW, cbValueName * sizeof(WCHAR) );
        *lpcbValueName = cbValueName;

        if ( lpData && lpcbData ) {

            LPWSTR  lpDataW;

            lpDataW = ConvertAtoW( lpDataA );

            cbData = My_wcslen(lpDataW) +  1;
            CopyMemory(lpData, lpDataW, cbData * sizeof(WCHAR) );
            *lpcbData = cbData * sizeof(WCHAR);

            LocalFreeAndNull( &lpDataW );
        }

        LocalFreeAndNull( &lpValueNameW );

        return lRetValue;
    }


    // the last case REG_MULTI_SZ.
          
    CopyMemory(lpValueName, lpValueNameW, cbValueName * sizeof(WCHAR) );
    *lpcbValueName = cbValueName;

    if ( lpData && lpcbData ) {
        LPWSTR   lpDataW= NULL;
        LPSTR    lpDataAt = NULL;
        LPWSTR   lpDataT = NULL;
        DWORD    cbDataAll;
        
        lpDataAt = lpDataA;
        cbDataAll = 0;
        lpDataT = (LPWSTR)lpData;

        while ( *lpDataAt != '\0' ) {

            lpDataW = ConvertAtoW( lpDataAt );

            cbDataAll += My_wcslen( lpDataW ) + 1;

            My_wcscpy(lpDataT, lpDataW);

            lpDataT += My_wcslen(lpDataW) + 1;

            lpDataAt += lstrlenA(lpDataAt) + 1;

            LocalFreeAndNull( &lpDataW );

        }

        cbDataAll ++;
        *lpDataT = 0x0000;
         
        *lpcbData = cbDataAll * sizeof(WCHAR);
    }

    LocalFreeAndNull( &lpValueNameW );
    return lRetValue;

}

// RegDeleteValue
LONG WINAPI RegDeleteValueWrapW( HKEY    hKey,           // handle to key
                                 LPCTSTR lpValueName )   // address of value name
{

    LPSTR  lpValueNameA = NULL;
    LONG   lRetValue=0;

    VALIDATE_PROTOTYPE(RegDeleteValue);
    
    if (g_bRunningOnNT)
        return RegDeleteValueW(hKey, lpValueName);

    lpValueNameA = ConvertWtoA( lpValueName );

    lRetValue = RegDeleteValueA( hKey, lpValueNameA );

    LocalFreeAndNull( & lpValueNameA );

    return lRetValue;

}

// RegCreateKey
LONG WINAPI RegCreateKeyWrapW(   HKEY    hKey,          // handle to an open key
                                 LPCTSTR lpSubKey,      // address of name of subkey to open
                                 PHKEY   phkResult  )  // address of buffer for opened handle
{

    LPSTR  lpSubKeyA = NULL;
    LONG   lRetValue =0;

    VALIDATE_PROTOTYPE(RegCreateKey);
    
    if (g_bRunningOnNT)
        return RegCreateKeyW(hKey, lpSubKey, phkResult);

    lpSubKeyA = ConvertWtoA( lpSubKey );

    lRetValue = RegCreateKeyA(hKey, lpSubKeyA, phkResult);

    LocalFreeAndNull( &lpSubKeyA );

    return lRetValue;

}


// in header file wincrypt.h

// CryptAcquireContext
BOOL WINAPI CryptAcquireContextWrapW( HCRYPTPROV *phProv,      // out
                                      LPCTSTR    pszContainer, // in
                                      LPCTSTR    pszProvider,  // in
                                      DWORD      dwProvType,   // in
                                      DWORD      dwFlags )    // in
{

    LPSTR  pszContainerA = NULL;
    LPSTR  pszProviderA = NULL;
    BOOL   bRetValue =0;

    VALIDATE_PROTOTYPE(CryptAcquireContext);
    
    if (g_bRunningOnNT)
        return CryptAcquireContextW(phProv, pszContainer, pszProvider, dwProvType, dwFlags );

    pszContainerA = ConvertWtoA( pszContainer );
    pszProviderA = ConvertWtoA ( pszProvider );

    bRetValue = CryptAcquireContextA(phProv, pszContainerA, pszProviderA, dwProvType, dwFlags );

    LocalFreeAndNull( &pszContainerA );
    LocalFreeAndNull( &pszProviderA );

    return bRetValue;

}

LONG WINAPI RegQueryValueExWrapW( HKEY     hKey,           // handle to key to query
                                  LPCTSTR  lpValueName,    // address of name of value to query
                                  LPDWORD  lpReserved,     // reserved
                                  LPDWORD  lpType,         // address of buffer for value type
                                  LPBYTE   lpData,         // address of data buffer
                                  LPDWORD  lpcbData )      // address of data buffer size
{

    LONG    lRetValue =0;
    LPSTR   lpValueNameA= NULL;
    LPWSTR  lpDataW= NULL;
    LPSTR   lpDataA = NULL;
    DWORD   cbData=0;
    DWORD   dwRealType;

//    VALIDATE_PROTOTYPE(RegQueryValueEx);
    
    if (g_bRunningOnNT)
        return RegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData );

    cbData = 0;

    if ( lpData && lpcbData &&( *lpcbData != 0 ) )
    {
       lpDataA = LocalAlloc( LMEM_ZEROINIT, *lpcbData );
       cbData = *lpcbData;
    }

    lpValueNameA = ConvertWtoA(lpValueName);

    lRetValue = RegQueryValueExA(hKey, lpValueNameA, lpReserved, &dwRealType, lpDataA, &cbData);

    if (lpType)
        *lpType = dwRealType;

    if ( (lRetValue != ERROR_SUCCESS) || (lpData == NULL) || (lpcbData == NULL ) ) {
        LocalFreeAndNull( &lpValueNameA );
        return lRetValue;
    }

    
    if ( (dwRealType != REG_EXPAND_SZ) && ( dwRealType != REG_MULTI_SZ) && ( dwRealType != REG_SZ ) ){

       CopyMemory(lpData, lpDataA, cbData );
       *lpcbData = cbData;
       LocalFreeAndNull( &lpDataA );
       LocalFreeAndNull( &lpValueNameA );

       return lRetValue;
    }


    if ( (dwRealType == REG_EXPAND_SZ) || (dwRealType == REG_SZ) ) {

       
        LPWSTR  lpDataW= NULL;

        lpDataW = ConvertAtoW( lpDataA );

        cbData = My_wcslen(lpDataW) +  1;
        CopyMemory(lpData, lpDataW, cbData * sizeof(WCHAR) );
        *lpcbData = cbData * sizeof(WCHAR);

        LocalFreeAndNull( &lpDataW );        
        LocalFreeAndNull( &lpDataA );
        LocalFreeAndNull( &lpValueNameA );

        return lRetValue;
    }


    // the last case REG_MULTI_SZ.

    if (lpData && lpcbData) {
        LPWSTR   lpDataW= NULL;
        LPSTR    lpDataAt= NULL;
        LPWSTR   lpDataT= NULL;
        DWORD    cbDataAll=0;
        
        lpDataAt = lpDataA;
        cbDataAll = 0;
        lpDataT = (LPWSTR)lpData;

        while ( *lpDataAt != '\0' ) {

            lpDataW = ConvertAtoW( lpDataAt );

            cbDataAll += My_wcslen( lpDataW ) + 1;

            My_wcscpy(lpDataT, lpDataW);

            lpDataT += My_wcslen(lpDataW) + 1;

            lpDataAt += lstrlenA(lpDataAt) + 1;

            LocalFreeAndNull( &lpDataW );

        }

        cbDataAll ++;
        *lpDataT = 0x0000;
         
        *lpcbData = cbDataAll * sizeof(WCHAR);
    }

    LocalFreeAndNull( &lpDataA );
    LocalFreeAndNull( &lpValueNameA );
    return lRetValue;


}

// RegCreateKeyEx
LONG WINAPI RegCreateKeyExWrapW(  HKEY    hKey,                // handle to an open key
                                  LPCTSTR lpSubKey,            // address of subkey name
                                  DWORD   Reserved,            // reserved
                                  LPTSTR  lpClass,             // address of class string
                                  DWORD   dwOptions,           // special options flag
                                  REGSAM  samDesired,          // desired security access
                                  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                              // address of key security structure
                                  PHKEY   phkResult,          // address of buffer for opened handle
                                  LPDWORD lpdwDisposition )   // address of disposition value buffer
{

    LPSTR  lpSubKeyA = NULL;
    LPSTR  lpClassA = NULL;
    LONG   lRetValue=0;

    VALIDATE_PROTOTYPE(RegCreateKeyEx);
    
    if (g_bRunningOnNT)
        return RegCreateKeyExW(hKey, 
                               lpSubKey, 
                               Reserved, 
                               lpClass, 
                               dwOptions,
                               samDesired, 
                               lpSecurityAttributes,
                               phkResult, 
                               lpdwDisposition);

    lpSubKeyA = ConvertWtoA( lpSubKey );
    lpClassA = ConvertWtoA ( lpClass );

    lRetValue = RegCreateKeyExA(hKey, 
                                lpSubKeyA, 
                                Reserved, 
                                lpClassA, 
                                dwOptions,
                                samDesired, 
                                lpSecurityAttributes,
                                phkResult, 
                                lpdwDisposition);

    LocalFreeAndNull( &lpSubKeyA );
    LocalFreeAndNull( &lpClassA );

    return lRetValue;

}

// RegSetValueEx
LONG WINAPI RegSetValueExWrapW(   HKEY    hKey,           // handle to key to set value for
                                  LPCTSTR lpValueName,    // name of the value to set
                                  DWORD   Reserved,       // reserved
                                  DWORD   dwType,         // flag for value type
                                  CONST BYTE *lpData,     // address of value data
                                  DWORD   cbData )        // size of value data
{

    LPSTR  lpValueNameA = NULL;
    LPSTR  lpStrA= NULL;
    BYTE   *lpDataA= NULL;
    DWORD  cbDataA=0;
    LONG   lRetValue=0;

    VALIDATE_PROTOTYPE(RegSetValueEx);
    
    if (g_bRunningOnNT)
        return RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

    lpValueNameA = ConvertWtoA( lpValueName );

    if ( ( dwType != REG_EXPAND_SZ ) && (dwType != REG_MULTI_SZ) && (dwType != REG_SZ) ) {
          
        lRetValue = RegSetValueExA(hKey, lpValueNameA, Reserved, dwType, lpData, cbData);
        LocalFreeAndNull( &lpValueNameA );
        return lRetValue;
    }
    
    if ( ( dwType == REG_EXPAND_SZ) || ( dwType == REG_SZ ) ) {
        lpDataA = ConvertWtoA( (LPWSTR) lpData );
        cbDataA = lstrlenA(lpDataA) + 1;

        lRetValue = RegSetValueExA(hKey, lpValueNameA, Reserved, dwType, lpDataA, cbDataA);
        LocalFreeAndNull( &lpValueNameA );
        LocalFreeAndNull( &lpDataA );

        return lRetValue;
    }

    // the last case is for REG_MULT_SZ
 
    if ( lpData ) {
        LPWSTR   lpDataWt= NULL;
        LPSTR    lpDataAt= NULL;
        DWORD    cbDataAll=0;
        
        lpDataA = LocalAlloc(LMEM_ZEROINIT, cbData);
        lpDataAt = lpDataA;
        cbDataAll = 0;
        lpDataWt = (LPWSTR)lpData;

        while ( *lpDataWt != 0x0000 ) {

            WideCharToMultiByte(CP_ACP,0, lpDataWt, -1, lpDataAt, -1, NULL, NULL ); 

            cbDataAll += lstrlenA(lpDataAt) + 1;

            lpDataWt += My_wcslen(lpDataWt) + 1;

            lpDataAt += lstrlenA(lpDataAt) + 1;


        }

        cbDataAll ++;
        *lpDataAt = 0x00;
        lRetValue = RegSetValueExA(hKey, lpValueNameA, Reserved, dwType, lpDataA, cbDataAll);
        LocalFreeAndNull( &lpDataA );
        LocalFreeAndNull( &lpValueNameA );
        return lRetValue;

    }
    return FALSE;
    return GetLastError();
}

// RegQueryInfoKey
LONG WINAPI RegQueryInfoKeyWrapW( HKEY    hKey,                  // handle to key to query
                                  LPTSTR  lpClass,               // address of buffer for class string
                                  LPDWORD lpcbClass,             // address of size of class string buffer
                                  LPDWORD lpReserved,            // reserved
                                  LPDWORD lpcSubKeys,            // address of buffer for number of subkeys
                                  LPDWORD lpcbMaxSubKeyLen,      // address of buffer for longest subkey 
                                                                 // name length
                                  LPDWORD lpcbMaxClassLen,       // address of buffer for longest class 
                                                                 // string length
                                  LPDWORD lpcValues,             // address of buffer for number of value 
                                                                 // entries
                                  LPDWORD lpcbMaxValueNameLen,   // address of buffer for longest 
                                                                 // value name length
                                  LPDWORD lpcbMaxValueLen,       // address of buffer for longest value 
                                                                 // data length
                                  LPDWORD lpcbSecurityDescriptor,
                                                                 // address of buffer for security 
                                                                 // descriptor length
                                  PFILETIME lpftLastWriteTime)   // address of buffer for last write time
                                                             

{
    LPSTR  lpClassA= NULL;
    LONG   lRetValue=0;


    VALIDATE_PROTOTYPE(RegQueryInfoKey);
    
    if (g_bRunningOnNT)
        return RegQueryInfoKeyW(hKey, lpClass, lpcbClass, lpReserved, lpcSubKeys,
                                lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
                                lpcbMaxValueLen,lpcbSecurityDescriptor,lpftLastWriteTime );

    lpClassA = ConvertWtoA( lpClass );
    lRetValue = RegQueryInfoKeyA(hKey, lpClassA, lpcbClass, lpReserved, lpcSubKeys,
                                 lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
                                 lpcbMaxValueLen,lpcbSecurityDescriptor,lpftLastWriteTime );

    LocalFreeAndNull( &lpClassA );

    return lRetValue;


}

//GDI32.DLL

//GetObject
int WINAPI GetObjectWrapW( HGDIOBJ hgdiobj,      // handle to graphics object of interest
                           int     cbBuffer,     // size of buffer for object information
                           LPVOID  lpvObject )   // pointer to buffer for object information
{

    int iRetValue =0;
    LOGFONTA  lfFontA;
    LOGFONTW  lfFontW;

    VALIDATE_PROTOTYPE(GetObject);
    
    if (g_bRunningOnNT)
        return GetObjectW(hgdiobj, cbBuffer, lpvObject);

    
    if ( GetObjectType(hgdiobj) != OBJ_FONT ) {

        iRetValue = GetObjectA( hgdiobj, cbBuffer, lpvObject );
        return iRetValue;
    }


    // if Object type is HFONT, the return value lpvObject will point to LOGFONT which contains
    // a field lpFaceName with TCHAR * type.

    if ( cbBuffer != sizeof(LOGFONTW) )
        return 0;

    if (lpvObject == NULL )  return sizeof(LOGFONTW);

    iRetValue = GetObjectA( hgdiobj, sizeof(lfFontA), &lfFontA );

    if (iRetValue == 0 ) return 0;

    iRetValue = sizeof(LOGFONTW);

    // copy all the fields except lfFaceName from lfFontA to lfFontW
    CopyMemory(&lfFontW,&lfFontA, sizeof(LOGFONTA) );
    
    // translate the lfFaceName[] from A to W

    MultiByteToWideChar(GetACP(), 0, lfFontA.lfFaceName, LF_FACESIZE, lfFontW.lfFaceName, LF_FACESIZE);
    
    CopyMemory(lpvObject, &lfFontW, sizeof(LOGFONTW) );

    return iRetValue;

}

// StartDoc
int WINAPI StartDocWrapW(  HDC           hdc,      // handle to device context
                           CONST DOCINFO *lpdi )   // address of structure with file names
{
    
    int        iRetValue=0;
    DOCINFOA   diA;
    LPSTR      lpszDocName= NULL, lpszOutput= NULL, lpszDatatype= NULL;
    

    VALIDATE_PROTOTYPE(StartDoc);
    
    if (g_bRunningOnNT)
        return StartDocW(hdc,lpdi);

    diA.cbSize = sizeof(DOCINFOA);

    lpszDocName = ConvertWtoA( lpdi->lpszDocName );
    lpszOutput  = ConvertWtoA( lpdi->lpszOutput );
    lpszDatatype= ConvertWtoA( lpdi->lpszDatatype);

    diA.lpszDocName = lpszDocName;
    diA.lpszOutput = lpszOutput;
    diA.lpszDatatype = lpszDatatype;
    diA.fwType = lpdi->fwType;

    iRetValue = StartDocA( hdc, &diA );

    LocalFreeAndNull( &lpszDocName );
    LocalFreeAndNull( &lpszOutput );
    LocalFreeAndNull( &lpszDatatype );

    return iRetValue;

}

// CreateFontIndirect
HFONT WINAPI CreateFontIndirectWrapW (CONST LOGFONT *lplf )  // pointer to logical font structure
{

    HFONT     hRetValue;
    LOGFONTA  lfFontA;

    VALIDATE_PROTOTYPE(CreateFontIndirect);
    
    if (g_bRunningOnNT)
        return CreateFontIndirectW(lplf);

    // copy LOGFONTW 's fields except lfFaceName to lfFontA.

    CopyMemory(&lfFontA, lplf, sizeof(LOGFONTW) - LF_FACESIZE * sizeof(WCHAR) );

    WideCharToMultiByte(CP_ACP, 0, lplf->lfFaceName, LF_FACESIZE, lfFontA.lfFaceName, LF_FACESIZE, NULL, NULL );

    hRetValue = CreateFontIndirectA( &lfFontA );

    return hRetValue;

}

//KERNEL32.DLL

// GetLocaleInfo
int WINAPI GetLocaleInfoWrapW( LCID   Locale,       // locale identifier
                               LCTYPE LCType,       // type of information
                               LPTSTR lpLCData,     // address of buffer for information
                               int    cchData )     // size of buffer
{

    int    iRetValue=0;
    LPSTR  lpLCDataA= NULL;
    int    cchDataA=0;
    LPWSTR lpLCDataW= NULL;
    int    cchDataW=0;

    VALIDATE_PROTOTYPE(GetLocaleInfo);
    
    if (g_bRunningOnNT)
        return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);

    
    iRetValue = GetLocaleInfoA(Locale, LCType, NULL, 0);

    if ( iRetValue == 0 ) return iRetValue;

    cchDataA = iRetValue;
    lpLCDataA = LocalAlloc(LMEM_ZEROINIT, cchDataA+1 );

    iRetValue = GetLocaleInfoA(Locale, LCType, lpLCDataA, cchDataA);
    lpLCDataA[cchDataA] = '\0';

    lpLCDataW = ConvertAtoW( lpLCDataA );
    cchDataW = My_wcslen( lpLCDataW );

    if ( (cchData == 0) || (lpLCData == NULL) ) {
        
        LocalFreeAndNull(&lpLCDataA);
        LocalFreeAndNull(&lpLCDataW);
        return cchDataW ;
    }

    CopyMemory(lpLCData, lpLCDataW, cchDataW * sizeof(WCHAR) );
    lpLCData[cchDataW] = '\0';

    LocalFreeAndNull(&lpLCDataA);
    LocalFreeAndNull(&lpLCDataW);
    return cchData;

}

// CreateDirectory
BOOL WINAPI CreateDirectoryWrapW(LPCTSTR               lpPathName,           // pointer to directory path string
                                 LPSECURITY_ATTRIBUTES lpSecurityAttributes)// pointer to security descriptor
{

    BOOL  bRetValue = FALSE;
    LPSTR lpPathNameA = NULL;

    VALIDATE_PROTOTYPE(CreateDirectory);
    
    if (g_bRunningOnNT)
        return CreateDirectoryW(lpPathName, lpSecurityAttributes);

    lpPathNameA = ConvertWtoA( lpPathName );

    bRetValue = CreateDirectoryA( lpPathNameA, lpSecurityAttributes );

    LocalFreeAndNull( &lpPathNameA );

    return bRetValue;

}

// GetWindowsDirectory
UINT WINAPI GetWindowsDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for Windows directory
                                      UINT   uSize )    // size of directory buffer
{

    UINT  uRetValue = 0;
    LPSTR lpBufferA = NULL;

    VALIDATE_PROTOTYPE(GetWindowsDirectory);
    
    if (g_bRunningOnNT)
        return GetWindowsDirectoryW(lpBuffer, uSize);

    lpBufferA = LocalAlloc( LMEM_ZEROINIT, uSize * sizeof(WCHAR) );

    uRetValue = GetWindowsDirectoryA( lpBufferA, uSize * sizeof(WCHAR) );

    uRetValue =MultiByteToWideChar(GetACP( ), 0, lpBufferA, -1, lpBuffer, uSize);

    LocalFreeAndNull( &lpBufferA );

    return uRetValue;

}

// GetSystemDirectory
UINT WINAPI GetSystemDirectoryWrapW( LPTSTR lpBuffer,  // address of buffer for system directory
                                     UINT   uSize )   // size of directory buffer
{
    UINT  uRetValue = 0;
    LPSTR lpBufferA = NULL;

    VALIDATE_PROTOTYPE(GetSystemDirectory);
    
    if (g_bRunningOnNT)
        return GetSystemDirectoryW(lpBuffer, uSize);

    lpBufferA = LocalAlloc( LMEM_ZEROINIT, uSize * sizeof(WCHAR) );

    uRetValue = GetSystemDirectoryA( lpBufferA, uSize * sizeof(WCHAR) );

    uRetValue =MultiByteToWideChar(GetACP( ), 0, lpBufferA, -1, lpBuffer, uSize);

    LocalFreeAndNull( &lpBufferA );

    return uRetValue;

}

// GetStringType   the parameters are not the same 


BOOL WINAPI GetStringTypeWrapW( DWORD   dwInfoType,   // information-type options
                                LPCTSTR lpSrcStr,     // pointer to the source string
                                int     cchSrc,       // size, in Characters, of the source string
                                LPWORD  lpCharType )  // pointer to the buffer for output

{
    BOOL  bRetValue = 0;
    LPSTR lpSrcStrA = NULL;
    
    VALIDATE_PROTOTYPE(GetStringType);
    
    if (g_bRunningOnNT)
       return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);

    lpSrcStrA = ConvertWtoA( lpSrcStr );

    bRetValue = GetStringTypeA( LOCALE_USER_DEFAULT, dwInfoType, lpSrcStrA, -1, lpCharType);
    
    LocalFreeAndNull( &lpSrcStrA );

    return bRetValue;
}



// GetProfileInt
UINT WINAPI GetProfileIntWrapW( LPCTSTR lpAppName,  // address of section name
                                LPCTSTR lpKeyName,  // address of key name
                                INT     nDefault )  // default value if key name is not found
{

    UINT  uRetValue = 0;
    LPSTR lpAppNameA = NULL;
    LPSTR lpKeyNameA = NULL;


    VALIDATE_PROTOTYPE(GetProfileInt);
    
    if (g_bRunningOnNT)
        return GetProfileIntW(lpAppName, lpKeyName, nDefault);

    lpAppNameA = ConvertWtoA( lpAppName );
    lpKeyNameA = ConvertWtoA( lpKeyName );

    uRetValue = GetProfileIntA( lpAppNameA, lpKeyNameA, nDefault);

    LocalFreeAndNull( &lpAppNameA );
    LocalFreeAndNull( &lpKeyNameA );

    return uRetValue;

}

// LCMapString
int WINAPI LCMapStringWrapW( LCID    Locale,      // locale identifier
                             DWORD   dwMapFlags,  // mapping transformation type
                             LPCTSTR lpSrcStr,    // address of source string
                             int     cchSrc,      // number of characters in source string
                             LPTSTR  lpDestStr,   // address of destination buffer
                             int     cchDest )    // size of destination buffer
{

    int    iRetValue =0;
    LPSTR  lpSrcStrA = NULL;
    LPSTR  lpDestStrA = NULL;
    LPWSTR lpDestStrW = NULL;
    int    cchSrcA, cchDestA, cchDestW;


    VALIDATE_PROTOTYPE(LCMapString);
    
    if (g_bRunningOnNT)
        return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);

    lpSrcStrA = ConvertWtoA( lpSrcStr );
    cchSrcA = lstrlenA(lpSrcStrA);

    lpDestStrA = LocalAlloc(LMEM_ZEROINIT, cchDest * sizeof(WCHAR) );
    cchDestA = cchDest * sizeof(WCHAR);

    iRetValue = LCMapStringA(Locale,dwMapFlags,lpSrcStrA,cchSrcA,lpDestStrA,cchDestA);

    // [PaulHi] 6/8/99  Don't fill the buffer if the pointer is NULL.
    if (lpDestStr && iRetValue != 0)
    {
        lpDestStrW = ConvertAtoW(lpDestStrA);

        iRetValue = My_wcslen(lpDestStrW) + 1;

        // Ensure that we don't overwrite the output buffer
        iRetValue = (iRetValue <= cchDest) ? iRetValue : cchDest;

        CopyMemory( lpDestStr, lpDestStrW, iRetValue * sizeof(WCHAR) );

        LocalFreeAndNull( &lpDestStrW );
    }
       
    LocalFreeAndNull( &lpDestStrA );
    LocalFreeAndNull( &lpSrcStrA );
        
    return iRetValue;
    
}

// GetFileAttributes
DWORD WINAPI GetFileAttributesWrapW( LPCTSTR lpFileName )  // pointer to the name of a file or directory
{


    DWORD  dRetValue =0;
    LPSTR  lpFileNameA = NULL;

    VALIDATE_PROTOTYPE(GetFileAttributes);
    
    if (g_bRunningOnNT)
        return GetFileAttributes(lpFileName);

    lpFileNameA = ConvertWtoA( lpFileName );

    dRetValue = GetFileAttributesA(lpFileNameA );

    LocalFreeAndNull ( &lpFileNameA );

    return dRetValue;


}

// CompareString
int WINAPI CompareStringWrapW( LCID    Locale,        // locale identifier
                               DWORD   dwCmpFlags,    // comparison-style options
                               LPCWSTR lpString1,     // pointer to first string
                               int     cchCount1,     // size, in bytes or characters, of first string
                               LPCWSTR lpString2,     // pointer to second string
                               int     cchCount2 )    // size, in bytes or characters, of second string
{
    int    iRetValue =0;
    LPSTR   lpString1A = NULL,
            lpString2A = NULL;
    LPWSTR  pszString1 = NULL,
            pszString2 = NULL;
            

    VALIDATE_PROTOTYPE(CompareString);
    
    if (g_bRunningOnNT)
        return CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);

    // [PaulHi] 4/1/99  Raid 75303  If the character count value(s) are -1 then the
    // input string(s) are already zero terminated and can be converted to ANSI directly.
    Assert(lpString1);
    Assert(lpString2);
    if (cchCount1 == -1)
    {
        // Already zero terminated string
        // Not great to cast const to non-const, but we don't modify the string
        pszString1 = (LPWSTR)lpString1;
    }
    else
    {
        // Convert to zero terminated string
        pszString1 = LocalAlloc(LMEM_FIXED, (cchCount1+1)*sizeof(WCHAR));
        if (!pszString1)
            goto exit;

        // Zero inited buffer
        lstrcpynWrapW(pszString1, lpString1, cchCount1+1);
    }

    if (cchCount2 == -1)
    {
        // Already zero terminated string
        // Not great to cast const to non-const, but we don't modify the string
        pszString2 = (LPWSTR)lpString2;
    }
    else
    {
        // Convert to zero terminated string
        pszString2 = LocalAlloc(LMEM_FIXED, (cchCount2+1)*sizeof(WCHAR));
        if (!pszString2)
            goto exit;

        // Zero inited buffer
        lstrcpynWrapW(pszString2, lpString2, cchCount2+1);
    }

    // Convert to ANSI, statistically improve our odds by checking that there
    // wasn't data loss on the first character.  It's too expensive to do a
    // full test every time.
    lpString1A = ConvertWtoA( pszString1 );
    if (!lpString1A || (lpString1A[0]=='?' && pszString1[0]!=L'?'))
        goto exit;

    lpString2A = ConvertWtoA( pszString2 );
    if (!lpString2A || (lpString2A[0]=='?' && pszString2[0]!=L'?'))
        goto exit;

    iRetValue = CompareStringA(Locale,dwCmpFlags,lpString1A,lstrlenA(lpString1A),lpString2A,lstrlenA(lpString2A));

exit:
    LocalFreeAndNull( &lpString1A );
    LocalFreeAndNull( &lpString2A );

    // Only deallocate if allocated locally
    if (pszString1 != (LPWSTR)lpString1)
        LocalFreeAndNull( &pszString1 );
    if (pszString2 != (LPWSTR)lpString2)
        LocalFreeAndNull( &pszString2 );

    return iRetValue;

}

//  lstrcpy
LPTSTR WINAPI lstrcpyWrapW( LPTSTR  lpString1,     // pointer to buffer
                            LPCTSTR lpString2 )    // pointer to string to copy
{

    VALIDATE_PROTOTYPE(lstrcpy);
    
    if (g_bRunningOnNT)
        return lstrcpyW(lpString1, lpString2);

    CopyMemory(lpString1, lpString2, (My_wcslen(lpString2) + 1) * sizeof(WCHAR) );

    return lpString1;
}

// lstrcmpi
int WINAPI lstrcmpiWrapW( LPCTSTR lpString1,    // pointer to first string
                          LPCTSTR lpString2 )   // pointer to second string
{
    int     iRetValue = 0;
    LPSTR   lpString1A = NULL ;
    LPSTR   lpString2A = NULL ;


    VALIDATE_PROTOTYPE(lstrcmpi);
    
    if (g_bRunningOnNT)
        return lstrcmpiW(lpString1, lpString2);

    lpString1A = ConvertWtoA( lpString1 );
    lpString2A = ConvertWtoA( lpString2 );

    iRetValue = lstrcmpiA(lpString1A, lpString2A );

    LocalFreeAndNull( &lpString1A );
    LocalFreeAndNull( &lpString2A );

    return iRetValue;
}

// LoadLibrary
HINSTANCE WINAPI LoadLibraryWrapW( LPCTSTR lpLibFileName )  // address of filename of executable module
{

    HINSTANCE  hRetValue =0;
    LPSTR      lpLibFileNameA = NULL;

    VALIDATE_PROTOTYPE(LoadLibrary);
    
    if (g_bRunningOnNT)
        return LoadLibraryW(lpLibFileName);

    lpLibFileNameA = ConvertWtoA(lpLibFileName);

    hRetValue = LoadLibraryA( lpLibFileNameA );

    LocalFreeAndNull( &lpLibFileNameA );

    return hRetValue;

}

// GetTextExtentPoint32
BOOL WINAPI GetTextExtentPoint32WrapW(HDC     hdc,
                                      LPCWSTR pwszBuf,
                                      int     nLen,
                                      LPSIZE  psize)
{
    LPSTR   pszBuf = NULL;
    BOOL    bRtn = FALSE;

    VALIDATE_PROTOTYPE(GetTextExtentPoint32);

    if (g_bRunningOnNT)
        return GetTextExtentPoint32W(hdc, pwszBuf, nLen, psize);

    pszBuf = ConvertWtoA(pwszBuf);
    if (pszBuf)
    {
        nLen = lstrlenA(pszBuf);
        bRtn = GetTextExtentPoint32A(hdc, pszBuf, nLen, psize);
        LocalFreeAndNull(&pszBuf);
    }
    else
    {
        psize->cx = 0;
        psize->cy = 0;
    }

    return bRtn;
}

// GetTimeFormat
int WINAPI GetTimeFormatWrapW( LCID    Locale,            // locale for which time is to be formatted
                               DWORD   dwFlags,           // flags specifying function options
                               CONST SYSTEMTIME *lpTime,  // time to be formatted
                               LPCTSTR lpFormat,          // time format string
                               LPTSTR  lpTimeStr,         // buffer for storing formatted string
                               int     cchTime  )         // size, in bytes or characters, of the buffer
{
    int    iRetValue =0;
    LPSTR  lpFormatA = NULL;
    LPWSTR lpTimeStrW = NULL;
    LPSTR  lpTimeStrA = NULL;
    int    cchTimeA=0, cchTimeW=0;

    VALIDATE_PROTOTYPE(GetTimeFormat);
    
    if (g_bRunningOnNT)
        return GetTimeFormatW(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);

    lpFormatA = ConvertWtoA( lpFormat );

    cchTimeA = GetTimeFormatA(Locale, dwFlags, lpTime,  lpFormatA, NULL, 0);

    lpTimeStrA = LocalAlloc(LMEM_ZEROINIT, cchTimeA );

    iRetValue = GetTimeFormatA(Locale, dwFlags, lpTime, lpFormatA, lpTimeStrA, cchTimeA );

    if ( iRetValue != 0 ) {
        
        lpTimeStrW = ConvertAtoW( lpTimeStrA );
        cchTimeW = My_wcslen( lpTimeStrW ) + 1;
        iRetValue = cchTimeW;

        if ( (cchTime !=0) && ( lpTimeStr != NULL ) ) {
              
              CopyMemory(lpTimeStr, lpTimeStrW, cchTimeW * sizeof(WCHAR) );
        }

        LocalFreeAndNull( &lpTimeStrW );

    }

    LocalFreeAndNull( &lpFormatA );
    LocalFreeAndNull( &lpTimeStrA );

    return iRetValue;

}

// GetDateFormat
int WINAPI GetDateFormatWrapW( LCID    Locale,             // locale for which date is to be formatted
                               DWORD   dwFlags,            // flags specifying function options
                               CONST SYSTEMTIME *lpDate,   // date to be formatted
                               LPCTSTR lpFormat,           // date format string
                               LPTSTR  lpDateStr,          // buffer for storing formatted string
                               int     cchDate )          // size of buffer
{

    int    iRetValue = 0;
    LPSTR  lpFormatA = NULL;
    LPWSTR lpDateStrW = NULL;
    LPSTR  lpDateStrA = NULL;
    int    cchDateA, cchDateW;

    VALIDATE_PROTOTYPE(GetDateFormat);
    
    if (g_bRunningOnNT)
        return GetDateFormatW(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);

    lpFormatA = ConvertWtoA( lpFormat );

    cchDateA = GetDateFormatA(Locale, dwFlags, lpDate,  lpFormatA, NULL, 0);

    lpDateStrA = LocalAlloc(LMEM_ZEROINIT, cchDateA );

    iRetValue = GetDateFormatA(Locale, dwFlags, lpDate, lpFormatA, lpDateStrA, cchDateA );

    if ( iRetValue != 0 ) {
        
        lpDateStrW = ConvertAtoW( lpDateStrA );
        cchDateW = My_wcslen( lpDateStrW ) + 1;
        iRetValue = cchDateW;

        if ( (cchDate !=0) && ( lpDateStr != NULL ) ) {
              
              CopyMemory(lpDateStr, lpDateStrW, cchDateW * sizeof(WCHAR) );
        }

        LocalFreeAndNull( &lpDateStrW );

    }

    LocalFreeAndNull( &lpFormatA );
    LocalFreeAndNull( &lpDateStrA );

    return iRetValue;




}


// lstrcpyn
LPTSTR WINAPI lstrcpynWrapW( LPTSTR  lpString1,     // pointer to target buffer
                             LPCTSTR lpString2,     // pointer to source string
                             int     iMaxLength )   // number of bytes or characters to copy

{
    int  iLength = 0;

    VALIDATE_PROTOTYPE(lstrcpyn);
    
    if (g_bRunningOnNT)
        return lstrcpynW(lpString1, lpString2, iMaxLength);

    iLength = My_wcslen(lpString2);

    if ( iLength >= iMaxLength )
        iLength = iMaxLength-1;

    CopyMemory(lpString1, lpString2, iLength * sizeof(WCHAR) );

    lpString1[iLength] = 0x0000;

    return lpString1;

}

// CreateFile
HANDLE WINAPI CreateFileWrapW( LPCTSTR lpFileName,             // pointer to name of the file
                               DWORD   dwDesiredAccess,        // access (read-write) mode
                               DWORD   dwShareMode,            // share mode
                               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                               // pointer to security attributes
                               DWORD   dwCreationDisposition,  // how to create
                               DWORD   dwFlagsAndAttributes,   // file attributes
                               HANDLE  hTemplateFile )        // handle to file with attributes to copy
                               
{

    LPSTR lpFileA = NULL;
    HANDLE hFile = NULL;

    VALIDATE_PROTOTYPE(CreateFile);
    
    if (g_bRunningOnNT)
        return CreateFileW( lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

    lpFileA = ConvertWtoA(lpFileName);

    hFile = CreateFileA(lpFileA, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);

    LocalFreeAndNull(&lpFileA);

    return (hFile);


}

// OutputDebugString
VOID WINAPI OutputDebugStringWrapW(LPCTSTR lpOutputString )   // pointer to string to be displayed
{
    LPSTR lpOutputStringA = NULL;

    VALIDATE_PROTOTYPE(OutputDebugString);
    
    if (g_bRunningOnNT) {
        OutputDebugStringW(lpOutputString);
        return;
    }

    lpOutputStringA = ConvertWtoA( lpOutputString );

    OutputDebugStringA( lpOutputStringA );

    LocalFreeAndNull( &lpOutputStringA );

}

// lstrcat
LPTSTR WINAPI lstrcatWrapW( LPTSTR  lpString1,     // pointer to buffer for concatenated strings
                            LPCTSTR lpString2 )    // pointer to string to add to string1
{

    LPWSTR  lpwStr = NULL;

    VALIDATE_PROTOTYPE(lstrcat);
    
    if (g_bRunningOnNT)
        return lstrcatW(lpString1, lpString2);

    lpwStr = lpString1 + My_wcslen(lpString1);

    CopyMemory(lpwStr, lpString2, (My_wcslen(lpString2)+1) * sizeof(WCHAR)  );

    return lpString1;
}


// FormatMessage  with va_list 
//
// Since it's hard to muck with the Argument List, instead, we'll go throught 
// the source string and explicitly turn any %x to %x!ws! indicating that the
// arguments have Wide Strings in them.
//
//  For sanity we assume we won't ever get more than 9 arguments <BUGBUG>
//
static const LPWSTR  lpWideFormat = TEXT("!ws!");

DWORD WINAPI FormatMessageWrapW( DWORD    dwFlags,       // source and processing options
                                 LPCVOID  lpSource,      // pointer to  message source
                                 DWORD    dwMessageId,   // requested message identifier
                                 DWORD    dwLanguageId,  // language identifier for requested message
                                 LPTSTR   lpBuffer,      // pointer to message buffer
                                 DWORD    nSize,         // maximum size of message buffer
                                 va_list *Arguments )    // pointer to array of message inserts
{
    DWORD   dwResult=0, iNumArg, iNum;
    LPSTR   lpSourceA = NULL;
    LPSTR   pszBuffer = NULL;
    LPWSTR  lpTemp1=NULL, lpTemp2=NULL;

    VALIDATE_PROTOTYPE(FormatMessage);
    
    if (g_bRunningOnNT)
        return FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);

    //  FORMAT_MESSAGE_FROM_STRING means that the source is a string.
    //  Otherwise, it's an opaque LPVOID (aka, an atom).
    //
    if ( !(dwFlags & FORMAT_MESSAGE_FROM_STRING) || !(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) )  {
        return 0;
        // we don't handle these cases
    }

    if ( !(dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY) )
    {
        LPWSTR lpModifiedSource;

        DebugTrace(TEXT("WARNING: FormatMessageWrap() is being called in Win9X with wide char argument strings.  DBCS characters may not be converted correctly!"));

        if(!(lpModifiedSource = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpSource)+1)*4))) // Four times is big enough
            goto exit;

        lpTemp1 = (LPWSTR)lpSource;
        My_wcscpy(lpModifiedSource, lpSource);
        lpTemp2 = lpModifiedSource;

        while(lpTemp1 && *lpTemp1)
        {
            if( *lpTemp1 == '%' && 
                (*(lpTemp1+1) >= '1' && *(lpTemp1+1) <= '9') &&
                *(lpTemp1+2) != '!') //if there isn't a hard-coded printf format specified here
            {
                lpTemp2 += 2; //skip 2 to get past the %9
                lpTemp1 += 2;
                My_wcscpy(lpTemp2, lpWideFormat);
                My_wcscat(lpTemp2, lpTemp1);
                lpTemp2 += My_wcslen(lpWideFormat);
            }
            else
            {
                lpTemp1++;
                lpTemp2++;
            }
        }

        lpSourceA = ConvertWtoA( lpModifiedSource );
        FormatMessageA(
                dwFlags,
                lpSourceA,
                dwMessageId,
                dwLanguageId,
                (LPSTR)&pszBuffer,
                0,
                Arguments);

        LocalFreeAndNull(&lpModifiedSource);
    }
    else
    {
        // We have an argument array.  Convert wide strings to DBCS
        // Create a new argument array and fill with converted (wide to DBCS)
        // strings to ensure International DBCS conversion occurs correctly.
        int      n, nArgCount = 0, nBytes = 0;
        LPVOID * pvArgArray = NULL;

        lpTemp1 = (LPWSTR)lpSource;
        while (*lpTemp1)
        {
            if (*lpTemp1 == '%')
            {
                if ( *(lpTemp1+1) == '%')
                    ++lpTemp1;      // "%%" not valid argument, step passed
                else
                    ++nArgCount;    // valid argument
            }
            ++lpTemp1;
        }

        pvArgArray = LocalAlloc(LMEM_ZEROINIT, (nArgCount * sizeof(LPVOID)));
        if (!pvArgArray)
            goto exit;

        lpTemp1 = (LPWSTR)lpSource;
        n = 0;
        while (*lpTemp1)
        {
            if (*lpTemp1 == '%')
            {
                if (*(lpTemp1+1) == '%')    // Skip "%%"
                    ++lpTemp1;
                else
                {
                    if ( *(lpTemp1+1) >= '1' && *(lpTemp1+1) <= '9' &&
                         *(lpTemp1+2) != '!' )     // Default Unicode string arg
                    {
                        pvArgArray[n] = (LPVOID)ConvertWtoA( (LPWSTR) ((LPVOID *)Arguments)[n] );
                        nBytes += lstrlenA(pvArgArray[n]);
                    }
                    else
                        pvArgArray[n] = ((LPVOID *)Arguments)[n];   // unknown arg type

                    ++n;
                    Assert(n <= nArgCount);
                }
            }

            ++lpTemp1;
        }

        // Check if known argument string lengths exceed 1023 bytes. If it does
        // abort because Win9X will overrun a buffer and crash.
        if (nBytes <= 1000)
        {
            lpSourceA = ConvertWtoA((LPWSTR)lpSource);
            FormatMessageA(
                    dwFlags,
                    lpSourceA,
                    dwMessageId,
                    dwLanguageId,
                    (LPSTR)&pszBuffer,
                    0,
                    (va_list *)pvArgArray);
        }

        // Clean up
        lpTemp1 = (LPWSTR)lpSource;
        n = 0;
        while (*lpTemp1)
        {
            if (*lpTemp1 == '%')
            {
                if (*(lpTemp1+1) == '%')    // Skip "%%"
                    ++lpTemp1;
                else
                {
                    if ( *(lpTemp1+1) >= '1' && *(lpTemp1+1) <= '9' &&
                         *(lpTemp1+2) != '!' )
                    {
                        LocalFree(pvArgArray[n]);
                        ++n;
                        Assert(n <= nArgCount);
                    }
                }
            }

            ++lpTemp1;
        }
        LocalFree(pvArgArray);
    }

    if (pszBuffer)
    {

        LPWSTR   *lpwBuffer;

        lpwBuffer =(LPWSTR *)(lpBuffer);
        *lpwBuffer = ConvertAtoW(pszBuffer);
        dwResult = My_wcslen(*lpwBuffer);

        LocalFree( pszBuffer );
    }

exit:
    LocalFreeAndNull(&lpSourceA);

    return dwResult;    
}

// GetModuleFileName
DWORD WINAPI GetModuleFileNameWrapW( HMODULE hModule,    // handle to module to find filename for
                                     LPTSTR  lpFileName, // pointer to buffer to receive module path
                                     DWORD   nSize )     // size of buffer, in characters
{

    DWORD  dRetValue =0;
    CHAR   FileNameA[MAX_PATH];
    LPWSTR lpFileNameW = NULL;
    
    VALIDATE_PROTOTYPE(GetModuleFileName);
    
    if (g_bRunningOnNT)
        return GetModuleFileNameW(hModule, lpFileName, nSize);

    dRetValue = GetModuleFileNameA(hModule, FileNameA, MAX_PATH);

    if ( dRetValue == 0 )  return 0;

    lpFileNameW = ConvertAtoW( FileNameA );

    dRetValue = My_wcslen( lpFileNameW );

    if ( dRetValue > nSize )
        dRetValue = nSize;

    CopyMemory(lpFileName, lpFileNameW, (dRetValue+1) * sizeof(WCHAR) );

    LocalFreeAndNull( &lpFileNameW );

    return dRetValue;

}

// GetPrivateProfileInt
UINT WINAPI GetPrivateProfileIntWrapW( LPCTSTR  lpAppName,    // address of section name
                                       LPCTSTR  lpKeyName,    // address of key name
                                       INT      nDefault,     // return value if key name is not found
                                       LPCTSTR  lpFileName )  // address of initialization filename
{
    UINT   uRetValue = 0;
    LPSTR  lpAppNameA = NULL;
    LPSTR  lpKeyNameA = NULL;
    LPSTR  lpFileNameA = NULL;

    VALIDATE_PROTOTYPE(GetPrivateProfileInt);
    
    if (g_bRunningOnNT)
        return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);

    lpAppNameA = ConvertWtoA( lpAppName );
    lpKeyNameA = ConvertWtoA( lpKeyName );
    lpFileNameA= ConvertWtoA( lpFileName);

    uRetValue = GetPrivateProfileIntA( lpAppNameA, lpKeyNameA, nDefault, lpFileNameA);

    LocalFreeAndNull( &lpAppNameA );
    LocalFreeAndNull( &lpKeyNameA );
    LocalFreeAndNull( &lpFileNameA);

    return uRetValue;

}

// IsBadStringPtr
BOOL WINAPI IsBadStringPtrWrapW( LPCTSTR lpsz,       // address of string
                                 UINT_PTR    ucchMax )  // maximum size of string
{
    
    VALIDATE_PROTOTYPE(IsBadStringPtr);
    
    if (g_bRunningOnNT)
        return IsBadStringPtrW(lpsz, ucchMax);

    return IsBadStringPtrA( (LPSTR)lpsz, ucchMax * sizeof(WCHAR) );

}

// GetPrivateProfileString
DWORD WINAPI GetPrivateProfileStringWrapW( LPCTSTR lpAppName,          // points to section name
                                           LPCTSTR lpKeyName,          // points to key name
                                           LPCTSTR lpDefault,          // points to default string
                                           LPTSTR  lpReturnedString,   // points to destination buffer
                                           DWORD   nSize,              // size of destination buffer
                                           LPCTSTR lpFileName  )       // points to initialization filename
{

    DWORD  dRetValue = 0;
    LPSTR  lpAppNameA = NULL;
    LPSTR  lpKeyNameA = NULL;
    LPSTR  lpDefaultA = NULL;
    LPSTR  lpReturnedStringA = NULL;
    LPWSTR lpReturnedStringW = NULL;
    LPSTR  lpFileNameA = NULL;
    DWORD  nSizeA = 0;


    VALIDATE_PROTOTYPE(GetPrivateProfileString);
    
    if (g_bRunningOnNT)
        return GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);


    lpAppNameA = ConvertWtoA( lpAppName );
    lpKeyNameA = ConvertWtoA( lpKeyName );
    lpDefaultA = ConvertWtoA( lpDefault );
    lpFileNameA= ConvertWtoA( lpFileName );

    nSizeA = nSize * sizeof(WCHAR)+1;
    lpReturnedStringA = LocalAlloc( LMEM_ZEROINIT,  nSizeA );

    nSizeA = GetPrivateProfileStringA(lpAppNameA,lpKeyNameA,lpDefaultA,lpReturnedStringA,nSizeA,lpFileNameA);

    lpReturnedStringW = ConvertAtoW( lpReturnedStringA );

    dRetValue = My_wcslen( lpReturnedStringW );

    My_wcscpy(lpReturnedString, lpReturnedStringW);

    LocalFreeAndNull( &lpAppNameA );
    LocalFreeAndNull( &lpKeyNameA );
    LocalFreeAndNull( &lpDefaultA );
    LocalFreeAndNull( &lpReturnedStringA );
    LocalFreeAndNull( &lpReturnedStringW );
    LocalFreeAndNull( &lpFileNameA );

    return dRetValue;

}


// lstrcmp
int WINAPI lstrcmpWrapW( LPCTSTR lpString1,    // pointer to first string
                         LPCTSTR lpString2 )   // pointer to second string
{

    int     iRetValue = 0;
    LPSTR   lpString1A = NULL ;
    LPSTR   lpString2A = NULL ;


    VALIDATE_PROTOTYPE(lstrcmp);
    
    if (g_bRunningOnNT)
        return lstrcmpW(lpString1, lpString2);

    lpString1A = ConvertWtoA( lpString1 );
    lpString2A = ConvertWtoA( lpString2 );

    iRetValue = lstrcmpA(lpString1A, lpString2A );

    LocalFreeAndNull( &lpString1A );
    LocalFreeAndNull( &lpString2A );

    return iRetValue;


}

HANDLE WINAPI CreateMutexWrapW( LPSECURITY_ATTRIBUTES lpMutexAttributes,
                                                                       // pointer to security attributes
                                BOOL                  bInitialOwner,   // flag for initial ownership
                                LPCTSTR               lpName )        // pointer to mutex-object name
{

    LPSTR lpNameA = NULL;
    HANDLE hMutex = NULL;

    VALIDATE_PROTOTYPE(CreateMutex);

    if (g_bRunningOnNT)
        return CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);

    lpNameA = ConvertWtoA(lpName);

    hMutex = CreateMutexA(lpMutexAttributes, bInitialOwner, lpNameA);

    LocalFreeAndNull(&lpNameA);

    return hMutex;

}

// GetTempPath
DWORD WINAPI GetTempPathWrapW( DWORD   nBufferLength,  // size, in characters, of the buffer
                               LPTSTR  lpBuffer )      // pointer to buffer for temp. path
{

    DWORD  nRequired = 0;
    CHAR   lpBufferA[MAX_PATH];
    LPWSTR lpBufferW = NULL;

    VALIDATE_PROTOTYPE(GetTempPath);
    
    if (g_bRunningOnNT)
        return GetTempPathW(nBufferLength, lpBuffer);

    nRequired = GetTempPathA(MAX_PATH, lpBufferA);

    lpBufferW = ConvertAtoW(lpBufferA);

    nRequired = My_wcslen(lpBufferW);

    if ( nRequired < nBufferLength) 
        CopyMemory(lpBuffer, lpBufferW, (nRequired+1)*sizeof(WCHAR) );

    return nRequired;
}

// ExpandEnvironmentStrings
DWORD WINAPI ExpandEnvironmentStringsWrapW( LPCTSTR lpSrc,     // pointer to string with environment variables
                                            LPTSTR  lpDst,     // pointer to string with expanded environment 
                                                               // variables
                                            DWORD   nSize )   // maximum characters in expanded string
{


    DWORD   dRetValue = 0;
    LPSTR   lpSrcA = NULL;
    LPSTR   lpDstA = NULL;
    LPWSTR  lpDstW = NULL;
    DWORD   nSizeA = 0;

    VALIDATE_PROTOTYPE(ExpandEnvironmentStrings);
    
    if (g_bRunningOnNT)
        return ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);


    nSizeA = nSize * sizeof(WCHAR);

    lpDstA = LocalAlloc( LMEM_ZEROINIT, nSizeA );

    lpSrcA = ConvertWtoA( lpSrc );

    dRetValue = ExpandEnvironmentStringsA( lpSrcA, lpDstA, nSizeA );

    lpDstW = ConvertAtoW( lpDstA );

    dRetValue = My_wcslen( lpDstW );

    if ( dRetValue < nSize ) 
        My_wcscpy(lpDst, lpDstW);

    LocalFreeAndNull( &lpSrcA );
    LocalFreeAndNull( &lpDstA );
    LocalFreeAndNull( &lpDstW );

    return dRetValue;
}

// GetTempFileName
UINT WINAPI GetTempFileNameWrapW( LPCTSTR lpPathName,        // pointer to directory name for temporary file
                                  LPCTSTR lpPrefixString,    // pointer to filename prefix
                                  UINT    uUnique,           // number used to create temporary filename
                                  LPTSTR  lpTempFileName  ) // pointer to buffer that receives the new filename                                                           
{

    UINT     uRetValue = 0;
    LPSTR    lpPathNameA = NULL;
    LPSTR    lpPrefixStringA = NULL;
    CHAR     lpTempFileNameA[MAX_PATH];
    LPWSTR   lpTempFileNameW = NULL;

    VALIDATE_PROTOTYPE(GetTempFileName);
    
    if (g_bRunningOnNT)
        return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    lpPathNameA = ConvertWtoA( lpPathName );
    lpPrefixStringA = ConvertWtoA( lpPrefixString );

    uRetValue = GetTempFileNameA(lpPathNameA, lpPrefixStringA, uUnique, lpTempFileNameA);

    if ( uRetValue != 0 ) {

        lpTempFileNameW = ConvertAtoW( lpTempFileNameA );
        My_wcscpy( lpTempFileName, lpTempFileNameW );
        LocalFreeAndNull( &lpTempFileNameW );
    }

    LocalFreeAndNull( &lpPathNameA );
    LocalFreeAndNull( &lpPrefixStringA );
    
    return uRetValue;

}

// BOOL WINAPI ReleaseMutexWrapW( HANDLE hMutex )  // handle to mutex object

// DeleteFile                                                        
BOOL WINAPI DeleteFileWrapW( LPCTSTR lpFileName  ) // pointer to name of file to delete
{
    BOOL    bRetValue ;
    LPSTR   lpFileNameA = NULL;

    VALIDATE_PROTOTYPE(DeleteFile);
    
    if (g_bRunningOnNT)
        return DeleteFileW(lpFileName);


    lpFileNameA = ConvertWtoA( lpFileName );

    bRetValue = DeleteFileA( lpFileNameA );

    LocalFreeAndNull( &lpFileNameA );

    return bRetValue;

}

// CopyFile
BOOL WINAPI CopyFileWrapW( LPCTSTR lpExistingFileName, // pointer to name of an existing file
                           LPCTSTR lpNewFileName,      // pointer to filename to copy to
                           BOOL    bFailIfExists )     // flag for operation if file exists
{

    BOOL    bRetValue;
    LPSTR   lpExistingFileNameA = NULL;
    LPSTR   lpNewFileNameA = NULL;

    VALIDATE_PROTOTYPE(CopyFile);
    
    if (g_bRunningOnNT)
        return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);


    lpExistingFileNameA = ConvertWtoA( lpExistingFileName );
    lpNewFileNameA = ConvertWtoA( lpNewFileName );

    bRetValue = CopyFileA( lpExistingFileNameA, lpNewFileNameA, bFailIfExists);

    LocalFreeAndNull( & lpExistingFileNameA );
    LocalFreeAndNull( & lpNewFileNameA );

    return bRetValue;
}


// FindFirstChangeNotification
HANDLE WINAPI FindFirstChangeNotificationWrapW(LPCTSTR  lpcwszFilePath, // Directory path of file to watch
                                           BOOL     bWatchSubtree,      // Monitor entire tree
                                           DWORD    dwNotifyFilter)     // Conditions to watch for
{
    HANDLE  hRet;
    LPSTR   lpszFilePath;

    VALIDATE_PROTOTYPE(FindFirstChangeNotification);

    Assert(lpcwszFilePath);

    if (g_bRunningOnNT)
        return FindFirstChangeNotification(lpcwszFilePath, bWatchSubtree, dwNotifyFilter);

    lpszFilePath = ConvertWtoA(lpcwszFilePath);
    hRet = FindFirstChangeNotificationA(lpszFilePath, bWatchSubtree, dwNotifyFilter);
    LocalFreeAndNull(&lpszFilePath);

    return hRet;
}


// FindFirstFile
HANDLE WINAPI FindFirstFileWrapW( LPCTSTR           lpFileName,       // pointer to name of file to search for
                                  LPWIN32_FIND_DATA lpFindFileData )  // pointer to returned information
                       
{
    HANDLE            hRetValue;
    LPSTR             lpFileNameA = NULL;
    WIN32_FIND_DATAA  FindFileDataA;
    WIN32_FIND_DATAW  FindFileDataW;


    VALIDATE_PROTOTYPE(FindFirstFile);
    
    if (g_bRunningOnNT)
        return FindFirstFileW(lpFileName, lpFindFileData);


    lpFileNameA = ConvertWtoA(lpFileName);
    
    hRetValue = FindFirstFileA( lpFileNameA, &FindFileDataA );

    if ( hRetValue != INVALID_HANDLE_VALUE ) {
        
        CopyMemory( &FindFileDataW, &FindFileDataA,  sizeof(WIN32_FIND_DATAA)-MAX_PATH-14 );

        MultiByteToWideChar(GetACP(),0,FindFileDataA.cFileName,MAX_PATH,FindFileDataW.cFileName,MAX_PATH); 
        MultiByteToWideChar(GetACP(),0,FindFileDataA.cAlternateFileName,14,FindFileDataW.cAlternateFileName,14); 

        CopyMemory( lpFindFileData, &FindFileDataW, sizeof(WIN32_FIND_DATAW) );
    }

    LocalFreeAndNull( &lpFileNameA );

    return hRetValue;

}

// GetDiskFreeSpace
BOOL WINAPI GetDiskFreeSpaceWrapW( LPCTSTR lpRootPathName,       // pointer to root path
                                   LPDWORD lpSectorsPerCluster,  // pointer to sectors per cluster
                                   LPDWORD lpBytesPerSector,     // pointer to bytes per sector
                                   LPDWORD lpNumberOfFreeClusters,
                                                                 // pointer to number of free clusters
                                   LPDWORD lpTotalNumberOfClusters )
                                                                 // pointer to total number of clusters
{
    BOOL   bRetValue;
    LPSTR  lpRootPathNameA = NULL;

    VALIDATE_PROTOTYPE(GetDiskFreeSpace);
    
    if (g_bRunningOnNT)
        return GetDiskFreeSpaceW(lpRootPathName, 
                                 lpSectorsPerCluster, 
                                 lpBytesPerSector, 
                                 lpNumberOfFreeClusters,
                                 lpTotalNumberOfClusters);

    lpRootPathNameA = ConvertWtoA( lpRootPathName );

    bRetValue = GetDiskFreeSpaceA(lpRootPathNameA, 
                                 lpSectorsPerCluster, 
                                 lpBytesPerSector, 
                                 lpNumberOfFreeClusters,
                                 lpTotalNumberOfClusters);

    LocalFreeAndNull( & lpRootPathNameA );

    return bRetValue;

}

// MoveFile
BOOL WINAPI MoveFileWrapW( LPCTSTR lpExistingFileName,   // pointer to the name of the existing file
                           LPCTSTR lpNewFileName )       // pointer to the new name for the file

{

    BOOL  bRetValue;
    LPSTR lpExistingFileNameA = NULL;
    LPSTR lpNewFileNameA = NULL;

    VALIDATE_PROTOTYPE(MoveFile);
    
    if (g_bRunningOnNT)
        return MoveFileW(lpExistingFileName, lpNewFileName);


    lpExistingFileNameA = ConvertWtoA( lpExistingFileName );
    lpNewFileNameA = ConvertWtoA( lpNewFileName );

    bRetValue = MoveFileA( lpExistingFileNameA, lpNewFileNameA );

    LocalFreeAndNull( &lpExistingFileNameA );
    LocalFreeAndNull( &lpNewFileNameA );

    return bRetValue;

}

// CreateEvent
HANDLE WINAPI CreateEventWrapW(LPSECURITY_ATTRIBUTES lpEventAttributes, // pointer to security attributes
                               BOOL bManualReset,     // flag for manual-reset event
                               BOOL bInitialState,    // flag for initial state
                               LPCTSTR lpcwszName)    // pointer to event-object name
{
    HANDLE  hRet;
    LPSTR   lpszName;

    VALIDATE_PROTOTYPE(CreateEvent);

    if (g_bRunningOnNT)
        return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpcwszName);

    lpszName = ConvertWtoA(lpcwszName);     // Handles NULL lpcwszName case
    hRet = CreateEventA(lpEventAttributes, bManualReset, bInitialState, lpszName);
    LocalFreeAndNull(&lpszName);

    return hRet;
}


//SHELL32.DLL


HINSTANCE WINAPI ShellExecuteWrapW( HWND     hwnd, 
                                    LPCTSTR  lpOperation,
                                    LPCTSTR  lpFile, 
                                    LPCTSTR  lpParameters, 
                                    LPCTSTR  lpDirectory,
                                    INT      nShowCmd )
	
{
    HINSTANCE  hRetValue;
    LPSTR      lpOperationA = NULL;
    LPSTR      lpFileA = NULL; 
    LPSTR      lpParametersA = NULL; 
    LPSTR      lpDirectoryA = NULL;

    VALIDATE_PROTOTYPE(ShellExecute);
    
    if (g_bRunningOnNT)
        return ShellExecuteW(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);


    lpOperationA = ConvertWtoA( lpOperation );
    lpFileA      = ConvertWtoA( lpFile );
    lpParametersA= ConvertWtoA( lpParameters );
    lpDirectoryA = ConvertWtoA( lpDirectory );

    hRetValue = ShellExecuteA(hwnd, lpOperationA, lpFileA, lpParametersA, lpDirectoryA, nShowCmd);

    LocalFreeAndNull( &lpOperationA);
    LocalFreeAndNull( &lpFileA );
    LocalFreeAndNull( &lpParametersA );
    LocalFreeAndNull( &lpDirectoryA );

    return hRetValue;

}

// DragQueryFile
UINT WINAPI DragQueryFileWrapW( HDROP   hDrop,
                                UINT    iFile,
                                LPTSTR  lpszFile,
                                UINT    cch )


{
    UINT   uRetValue = 0;
    LPSTR  lpszFileA = NULL;
    LPWSTR lpszFileW = NULL;
    UINT   cchA, cchW =0;

    VALIDATE_PROTOTYPE(DragQueryFile);
    
    if (g_bRunningOnNT)
        return DragQueryFileW(hDrop, iFile, lpszFile, cch);

    cchA = DragQueryFileA( hDrop, iFile, NULL, 0 );

    lpszFileA = LocalAlloc(LMEM_ZEROINIT, cchA+1 );

    uRetValue = DragQueryFileA(hDrop, iFile, lpszFileA, cchA+1);

    lpszFileW = ConvertAtoW( lpszFileA );
    cchW = My_wcslen( lpszFileW );

    if ( lpszFile )

        CopyMemory( lpszFile, lpszFileW, (cchW+1)*sizeof(WCHAR) );

    LocalFreeAndNull( &lpszFileA );
    LocalFreeAndNull( &lpszFileW );

    return cchW;

}

//USER32.DLL
// CharPrev
LPTSTR WINAPI CharPrevWrapW( LPCTSTR lpszStart,      // pointer to first character
                             LPCTSTR lpszCurrent )   // pointer to current character
{

    LPWSTR lpszReturn = NULL;

    VALIDATE_PROTOTYPE(CharPrev);
    
    if (g_bRunningOnNT)
        return CharPrevW(lpszStart, lpszCurrent);

    if (lpszCurrent == lpszStart)
         lpszReturn = (LPWSTR)lpszStart;

    lpszReturn = (LPWSTR)lpszCurrent - 1;

    return lpszReturn;

}

// DrawText
int WINAPI DrawTextWrapW( HDC     hDC,          // handle to device context
                          LPCTSTR lpString,     // pointer to string to draw
                          int     nCount,       // string length, in characters
                          LPRECT  lpRect,       // pointer to struct with formatting dimensions
                          UINT    uFormat )     // text-drawing flags
{
    int    iRetValue = 0;
    LPSTR  lpStringA = NULL;

    VALIDATE_PROTOTYPE(DrawText);
    
    if (g_bRunningOnNT)
        return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);

    lpStringA = ConvertWtoA( lpString );

    iRetValue = DrawTextA(hDC, lpStringA, nCount, lpRect, uFormat);

    LocalFreeAndNull( &lpStringA );

    return iRetValue;

}

// ModifyMenu
BOOL WINAPI ModifyMenuWrapW( HMENU   hMenu,         // handle to menu
                             UINT    uPosition,    // menu item to modify
                             UINT    uFlags,       // menu item flags
                             UINT_PTR    uIDNewItem,   // menu item identifier or handle to drop-down 
                                                   // menu or submenu
                             LPCTSTR lpNewItem )   // menu item content
{

    BOOL   bRetValue;
    LPSTR  lpNewItemA = NULL;

    VALIDATE_PROTOTYPE(ModifyMenu);
    
    if (g_bRunningOnNT)
        return ModifyMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

    Assert(lpNewItem);

    // [PaulHi] 4/5/99 Raid 75428  MF_STRING is defined to be 0x00000000.  Need
    // to check alternative interpretations of lpNewItem.
    // MF_BITMAP = 0x00000004L
    // MF_OWNERDRAW = 0x00000100L
    // If this Assert fires then it implies that a new bit defining lpNewItem may have
    // been added to this API!!!  If so add this definition to the uFlags if statement.
    Assert( !(uFlags & ~(MF_BITMAP|MF_BYCOMMAND|MF_BYPOSITION|MF_CHECKED|MF_DISABLED|MF_GRAYED|MF_MENUBARBREAK|MF_MENUBREAK|MF_OWNERDRAW|MF_POPUP|MF_SEPARATOR|MF_UNCHECKED)));
    if (uFlags  & (MF_BITMAP | MF_OWNERDRAW))   // lpNewItem is NOT a string pointer
        return ModifyMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPCSTR)lpNewItem);

    lpNewItemA = ConvertWtoA( lpNewItem );

    bRetValue = ModifyMenuA(hMenu, uPosition, uFlags, uIDNewItem, lpNewItemA);

    LocalFreeAndNull( &lpNewItemA );

    return bRetValue;
}

// InsertMenu
BOOL WINAPI InsertMenuWrapW( HMENU   hMenu,       // handle to menu
                             UINT    uPosition,   // menu item that new menu item precedes
                             UINT    uFlags,      // menu item flags
                             UINT_PTR    uIDNewItem,  // menu item identifier or handle to drop-down 
                                                  // menu or submenu
                             LPCTSTR lpNewItem ) // menu item content
{
    BOOL   bRetValue;
    LPSTR  lpNewItemA = NULL;

    VALIDATE_PROTOTYPE(InsertMenu);
    
    if (g_bRunningOnNT)
        return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

   if (uFlags & MF_BITMAP || uFlags & MF_OWNERDRAW) // if anything but MF_STRING .. note: MF_STRING = 0x00000000
        return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPCSTR)lpNewItem);

    lpNewItemA = ConvertWtoA( lpNewItem );

    bRetValue = InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, lpNewItemA);

    LocalFreeAndNull( &lpNewItemA );

    return bRetValue;

}

// LoadImage
HANDLE WINAPI LoadImageWrapW( HINSTANCE hinst,      // handle of the instance containing the image
                              LPCTSTR   lpszName,   // name or identifier of image
                              UINT      uType,      // type of image
                              int       cxDesired,  // desired width
                              int       cyDesired,  // desired height
                              UINT      fuLoad )    // load flags
{
    HANDLE hRetValue;
    LPSTR  lpszNameA = NULL;

    VALIDATE_PROTOTYPE(LoadImage);
    
    if (g_bRunningOnNT)
        return LoadImageW(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);


    lpszNameA = ConvertWtoA( lpszName );

    hRetValue = LoadImageA(hinst, lpszNameA, uType, cxDesired, cyDesired, fuLoad);

    LocalFreeAndNull( & lpszNameA );

    return hRetValue;

}

// GetClassInfoEx
BOOL WINAPI GetClassInfoExWrapW( HINSTANCE    hinst,      // handle of application instance
                                 LPCTSTR      lpszClass,  // address of class name string
                                 LPWNDCLASSEX lpwcx )    // address of structure for class data
{

    BOOL        bRetValue;
    LPSTR       lpszClassA = NULL;
    WNDCLASSEXA wcxA;
    WNDCLASSEXW wcxW;

    VALIDATE_PROTOTYPE(GetClassInfoEx);
    
    if (g_bRunningOnNT)
        return GetClassInfoExW(hinst, lpszClass, lpwcx);

    lpszClassA = ConvertWtoA( lpszClass );

    wcxA.cbSize = sizeof( WNDCLASSEXA );

    bRetValue = GetClassInfoExA( hinst, lpszClassA, &wcxA );

    if ( bRetValue == FALSE ) {
        LocalFreeAndNull( &lpszClassA );
        return bRetValue;
    }

    CopyMemory( &wcxW, &wcxA, sizeof(WNDCLASSEXA) );
    wcxW.cbSize = sizeof(WNDCLASSEXW);

    if ( wcxA.lpszMenuName && !IS_INTRESOURCE(wcxA.lpszMenuName) ) 
       wcxW.lpszMenuName = ConvertAtoW( wcxA.lpszMenuName );

    if ( wcxA.lpszClassName && !IS_INTRESOURCE(wcxA.lpszClassName) ) // lpszClassName can be an atom, high word is null
       wcxW.lpszClassName = ConvertAtoW( wcxA.lpszClassName );

    CopyMemory(lpwcx, &wcxW, sizeof(WNDCLASSEXW) );

    LocalFreeAndNull( &lpszClassA );

    return bRetValue;
}

// LoadString
int WINAPI LoadStringWrapW( HINSTANCE hInstance,     // handle to module containing string resource
                            UINT      uID,           // resource identifier
                            LPTSTR    lpBuffer,      // pointer to buffer for resource
                            int       nBufferMax  ) // size of buffer
{
    int    iRetValue = 0;
    LPSTR  lpBufferA = NULL;
    int    nBuffer = 0;
    LPWSTR lpBufferW= NULL;

    VALIDATE_PROTOTYPE(LoadString);
    
    if (g_bRunningOnNT)
        return LoadStringW(hInstance, uID, lpBuffer, nBufferMax);

    nBuffer = nBufferMax * sizeof(WCHAR);
    lpBufferA = LocalAlloc(LMEM_ZEROINIT, nBuffer );

    iRetValue = LoadStringA(hInstance, uID, lpBufferA, nBuffer);

    lpBufferW = ConvertAtoW( lpBufferA );
    nBuffer = My_wcslen( lpBufferW );

    if ( nBuffer >= nBufferMax )
        nBuffer = nBufferMax - 1;

    CopyMemory(lpBuffer, lpBufferW, nBuffer * sizeof( WCHAR) );

    lpBuffer[nBuffer] = 0x0000;

    LocalFreeAndNull( &lpBufferA );
    LocalFreeAndNull( &lpBufferW );

    return nBuffer;
}

// CharNext
LPTSTR WINAPI CharNextWrapW( LPCTSTR lpsz )  // pointer to current character
{

    LPWSTR  lpwsz = NULL;

    VALIDATE_PROTOTYPE(CharNext);
    
    if (g_bRunningOnNT)
        return CharNextW(lpsz);

    if ( *lpsz == 0x0000 )
        lpwsz = (LPWSTR)lpsz;
    else
        lpwsz = (LPWSTR)lpsz + 1;

    return  lpwsz;

}



LRESULT WINAPI ListView_GetItemTextA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam) 
{
    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText;
    LPWSTR      lpszTextW;
    DWORD       iMinLen;

    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    iMinLen = lplviW->cchTextMax * sizeof( WCHAR );
    lpszText = LocalAlloc( LMEM_ZEROINIT, iMinLen  );

    lviA.cchTextMax = iMinLen ;
    lviA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_GETITEMTEXTA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

    lpszTextW = ConvertAtoW( lviA.pszText );

    if ( iMinLen > (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR)  )
        iMinLen = (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR) ;

    CopyMemory( lplviW->pszText, lpszTextW, iMinLen );

    LocalFreeAndNull( &lpszText );
    LocalFreeAndNull( &lpszTextW );

    return lRetValue;

}


LRESULT WINAPI ListView_GetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam) 
{
    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW = NULL;
    LPSTR       lpszText = NULL;
    LPWSTR      lpszTextW = NULL;
    DWORD       iMinLen;

    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    iMinLen = 0;

    if ( lplviW->mask & LVIF_TEXT ) {
    
       iMinLen = lplviW->cchTextMax * sizeof( WCHAR );
       lpszText = LocalAlloc( LMEM_ZEROINIT, iMinLen  );
       lviA.cchTextMax = iMinLen ;
       lviA.pszText = lpszText;
    }


    lRetValue = SendMessageA(hWnd, LVM_GETITEMA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

 
    lplviW->mask      = lviA.mask;
    lplviW->iItem     = lviA.iItem;
    lplviW->iSubItem  = lviA.iSubItem;
    lplviW->state     = lviA.state;
    lplviW->stateMask = lviA.stateMask;
    lplviW->iImage    = lviA.iImage;
    lplviW->lParam    = lviA.lParam;

#if (_WIN32_IE >= 0x0300)
    lplviW->iIndent   = lviA.iIndent;
#endif

    if ( lplviW->mask & LVIF_TEXT ) {

       lpszTextW = ConvertAtoW( lviA.pszText );

       if ( iMinLen > (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR)  )
           iMinLen = (lstrlenW( lpszTextW ) + 1) * sizeof( WCHAR) ;

       CopyMemory( lplviW->pszText, lpszTextW, iMinLen );
    }

   
   LocalFreeAndNull( &lpszText );

   LocalFreeAndNull( &lpszTextW );

    return lRetValue;

}



LRESULT WINAPI ListView_InsertItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText = NULL;
    
    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    if ( (lplviW->mask & LVIF_TEXT) && (lplviW->pszText != NULL)  ) {
       lpszText = ConvertWtoA( lplviW->pszText );
       lviA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    }

    lviA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_INSERTITEMA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

    LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText = NULL;
    
    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    if ( (lplviW->mask & LVIF_TEXT ) && (lplviW->pszText != NULL) ) {
       lpszText = ConvertWtoA( lplviW->pszText );
       lviA.cchTextMax = lstrlenA( lpszText ) + 1 ;
       lviA.pszText = lpszText;

    }


    lRetValue = SendMessageA(hWnd, LVM_SETITEMA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

   LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SetItemTextA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVITEMA     lviA;
    LPLVITEMW   lplviW;
    LPSTR       lpszText;
    
    lplviW = (LPLVITEMW) lParam;

    CopyMemory( &lviA, lplviW, sizeof( LVITEMA ) );

    lpszText = ConvertWtoA( lplviW->pszText );
    lviA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    lviA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_SETITEMTEXTA, wParam, (LPARAM)(LVITEMA FAR *)&lviA );

    LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SetColumnA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVCOLUMNA   lvcA;
    LPLVCOLUMNW lplvcW;
    LPSTR       lpszText = NULL;
    
    lplvcW = (LPLVCOLUMNW) lParam;

    CopyMemory( &lvcA, lplvcW, sizeof( LVCOLUMNA ) );

    if ( (lplvcW->mask & LVCF_TEXT ) && (lplvcW->pszText != NULL) ) {
       lpszText = ConvertWtoA( lplvcW->pszText );
       lvcA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    }

    lvcA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_SETCOLUMNA, wParam, (LPARAM)(LPLVCOLUMNA)&lvcA );

   LocalFreeAndNull( &lpszText );
    

    return lRetValue;


}



LRESULT WINAPI ListView_InsertColumnA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    LVCOLUMNA   lvcA;
    LPLVCOLUMNW lplvcW;
    LPSTR       lpszText = NULL;
    
    lplvcW = (LPLVCOLUMNW) lParam;

    CopyMemory( &lvcA, lplvcW, sizeof( LVCOLUMNA ) );

    if ( (lplvcW->mask & LVCF_TEXT ) && (lplvcW->pszText != NULL)  ) {
       lpszText = ConvertWtoA( lplvcW->pszText );
       lvcA.cchTextMax = lstrlenA( lpszText ) + 1 ;
    }

    lvcA.pszText = lpszText;

    lRetValue = SendMessageA(hWnd, LVM_INSERTCOLUMNA, wParam, (LPARAM)(LPLVCOLUMNA)&lvcA );

   LocalFreeAndNull( &lpszText );
    

    return lRetValue;

}


LRESULT WINAPI ListView_FindItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT        lRetValue;
    LPSTR          lpsz = NULL;
    LVFINDINFOA    lvfiA;
    LPFINDINFOW    lplvfiW;
    
    lplvfiW = (LPFINDINFOW) lParam;

    CopyMemory( &lvfiA, lplvfiW, sizeof(LVFINDINFOA ) );

    if ( (lplvfiW->flags & LVFI_PARTIAL) ||  (lplvfiW->flags & LVFI_STRING) ) {

        if ( lplvfiW->psz != NULL ) {
           lpsz = ConvertWtoA( lplvfiW->psz );
        }

    }

    lvfiA.psz = lpsz;

    if ( lplvfiW->flags  & LVFI_PARAM ) {
        // we must convert field lParam, but this is not the case in our current code 
        // so ignore it.

        if ( lplvfiW->lParam )
            lvfiA.lParam = lplvfiW->lParam;

    }

    lRetValue = SendMessageA(hWnd, LVM_FINDITEMA, wParam, (LPARAM)(LVFINDINFOA FAR *)&lvfiA );

   LocalFreeAndNull( &lpsz );
    

    return lRetValue;

}



LRESULT WINAPI ListView_SortItemsA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{


    // not implement yet.

    return SendMessageA( hWnd, Msg, wParam, lParam );
}


LRESULT WINAPI ListView_EditLabelA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{
        return SendMessageA(hWnd, LVM_EDITLABELA, wParam, lParam );
}


LRESULT WINAPI ToolBar_AddString(HWND hWnd, LPARAM lParam)
{

    LRESULT lRetValue;
    LPSTR   pStringA = NULL;
    LPWSTR  pStringW = NULL;
    LPSTR   pStringA_T = NULL, pStringAA = NULL;
    DWORD   dwLen;
    WPARAM  wParam = 0;

   // get the total length of pStringW       
    if (g_bRunningOnNT)
       return SendMessageW(hWnd, TB_ADDSTRINGW, wParam, lParam );

   dwLen = 0;

   pStringW = (LPWSTR)(lParam);

   while ( *pStringW != TEXT('\0') ) {
        dwLen += lstrlenW(pStringW) + 1;
        pStringW += lstrlenW(pStringW) + 1;
   }

   dwLen += 1;  // for the last null terminator

   pStringW = (LPWSTR)( lParam );
   pStringA = LocalAlloc( LMEM_ZEROINIT, dwLen * sizeof(WCHAR) );
   
   pStringA_T = pStringA;

   while ( *pStringW != TEXT('\0') ) { 
         pStringAA = ConvertWtoA(pStringW );
         pStringW += lstrlenW(pStringW) + 1;
         strcpy(pStringA_T, pStringAA );
         LocalFreeAndNull( &pStringAA );
         pStringA_T += lstrlenA( pStringA_T ) + 1;
   }

   pStringA_T[lstrlenA(pStringA_T)+1] = '\0';


   lRetValue = SendMessageA(hWnd, TB_ADDSTRINGA, wParam, (LPARAM)pStringA );

   LocalFreeAndNull( &pStringA );

   return lRetValue;

}


LRESULT WINAPI ToolBar_AddButtons(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    if (g_bRunningOnNT)
       return SendMessageW( hWnd, TB_ADDBUTTONSW, wParam, lParam );

   return SendMessageA( hWnd, TB_ADDBUTTONSA, wParam, lParam );

}

LRESULT WINAPI TreeView_GetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT    lRetValue;
    TVITEMA    tviA;
    LPTVITEMW  lptviW;
    LPWSTR     lpszTextW = NULL;
    LPSTR      lpszTextA = NULL;



    lptviW = (LPTVITEMW) lParam;

    CopyMemory( &tviA, lptviW, sizeof( TVITEMA ) );

    if ( lptviW->mask & TVIF_TEXT ) {

        lpszTextA = ConvertWtoA( lptviW->pszText ) ;
        tviA.pszText = lpszTextA;
        tviA.cchTextMax = lstrlenA( lpszTextA ) + 1;
    }

    lRetValue = SendMessageA( hWnd, TVM_GETITEMA, wParam, (LPARAM)(LPTVITEMA)&tviA );

    if ( lptviW->mask & TVIF_TEXT ) 
        lpszTextW = ConvertAtoW( tviA.pszText );

    lptviW->mask = tviA.mask;
    lptviW->hItem = tviA.hItem;
    lptviW->state = tviA.state;
    lptviW->stateMask = tviA.stateMask;
    if ( lpszTextW ) {
       CopyMemory(lptviW->pszText, lpszTextW, (lstrlenW(lpszTextW)+1) * sizeof(WCHAR) );
       lptviW->cchTextMax = lstrlenW( lpszTextW ) + 1;
    }
    
    lptviW->iImage = tviA.iImage;
    lptviW->iSelectedImage = tviA.iSelectedImage;
    lptviW->cChildren = tviA.cChildren;
    lptviW->lParam = tviA.lParam;


    LocalFreeAndNull( &lpszTextA );

    LocalFreeAndNull( &lpszTextW );

    return lRetValue;

}


LRESULT WINAPI TreeView_SetItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT     lRetValue;
    TVITEMA     tviA;
    LPTVITEMW   lptviW;
    LPSTR       pszTextA = NULL;


    lptviW = (LPTVITEMW) lParam;
    CopyMemory( &tviA, lptviW, sizeof( TVITEMA ) );

    if ( (lptviW->mask & TVIF_TEXT)  && (lptviW->pszText != NULL) ) {
        pszTextA = ConvertWtoA( lptviW->pszText );
        tviA.cchTextMax = lstrlenA( pszTextA );
    }

    tviA.pszText = pszTextA;

    lRetValue = SendMessageA( hWnd, TVM_SETITEMA, wParam, (LPARAM)(const TV_ITEM FAR*)&tviA );
    
    LocalFreeAndNull( &pszTextA );

    return lRetValue;

}


LRESULT WINAPI TreeView_InsertItemA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{

    LRESULT            lRetValue;
    LPSTR              pszTextA = NULL;
    TVINSERTSTRUCTA    tvisA;
    LPTVINSERTSTRUCTW  lptvisW;

    lptvisW = (LPTVINSERTSTRUCTW)lParam;
    CopyMemory( &tvisA, lptvisW, sizeof( TVINSERTSTRUCTA ) );

    if ( ((lptvisW->item).mask & TVIF_TEXT) && ((lptvisW->item).pszText != NULL)  ) {
        
        pszTextA = ConvertWtoA( (lptvisW->item).pszText );
        tvisA.item.cchTextMax = lstrlenA( pszTextA );
        tvisA.item.pszText = pszTextA;
    }

  
    lRetValue = SendMessageA( hWnd, TVM_INSERTITEMA, wParam, (LPARAM)(LPTVINSERTSTRUCTA)&tvisA );
    
    LocalFreeAndNull( &pszTextA );

    return lRetValue;

}


// Tab Control Message Wrapper

LRESULT  WINAPI TabCtrl_InsertItemA( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam )
{

    LRESULT     lRetValue;
    TCITEMA     tciA;
    LPTCITEMW   lptciW = NULL;
    LPSTR       pszText = NULL;

    lptciW = (LPTCITEMW) lParam;

    CopyMemory( &tciA, lptciW,  sizeof(TCITEMA ) );

    if ( lptciW->mask & TCIF_TEXT ) {
        pszText = ConvertWtoA( lptciW->pszText );
        tciA.pszText = pszText;
        tciA.cchTextMax = lstrlenA( pszText ) + 1;
    }

    lRetValue = SendMessageA( hWnd, TCM_INSERTITEMA, wParam, (LPARAM)(LPTCITEMA)&tciA);

    LocalFreeAndNull( &pszText );

    return lRetValue;

}


// List Box Control Message wrapper

LRESULT WINAPI ListBox_AddStringA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRetValue;
    LPSTR   lpszStrA = NULL;
    LPWSTR  lpszStrW = NULL;

    lpszStrW = (LPWSTR)lParam;
    lpszStrA = ConvertWtoA(lpszStrW);
    lRetValue = SendMessageA(hWnd, LB_ADDSTRING, wParam, (LPARAM)lpszStrA);

    LocalFreeAndNull(&lpszStrA);
    return lRetValue;
}


// Combo List Control Message wrapper

LRESULT WINAPI Combo_AddStringA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{

   LRESULT  lRetValue;
   LPSTR    lpszStrA = NULL;
   LPWSTR   lpszStrW = NULL;

   lpszStrW = (LPWSTR)lParam;

   lpszStrA = ConvertWtoA( lpszStrW );

   lRetValue = SendMessageA(hWnd, CB_ADDSTRING, wParam, (LPARAM)lpszStrA );

   LocalFreeAndNull( &lpszStrA );

   return lRetValue;

}

LRESULT WINAPI Combo_GetLBTextA(HWND hWnd,UINT Msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRetValue;
    LPSTR   lpszStrA = NULL;
    LPWSTR  lpszStrW = NULL;
    int     nBytes;

    Assert(lParam);
    *((LPWSTR)lParam) = '\0';

    // Allocate the single byte char buffer to the correct size
    nBytes = (int) SendMessageA(hWnd, CB_GETLBTEXTLEN, wParam, 0) + 1;
    lpszStrA = LocalAlloc(LMEM_FIXED, nBytes);
    if (!lpszStrA)
    {
        Assert(0);
        return 0;
    }
    *lpszStrA = '\0';
    lRetValue = SendMessageA(hWnd, CB_GETLBTEXT, wParam, (LPARAM)(lpszStrA));

    if ( lRetValue == CB_ERR )
        return CB_ERR;

    // lRetValue is the length of string lpszStrA, in Bytes.
    // to make sure lpszStrA is Null-terminated.

    lpszStrA[lRetValue] = '\0';

    lpszStrW = ConvertAtoW( lpszStrA );

    lRetValue = lstrlenW( lpszStrW ) * sizeof(WCHAR);

    CopyMemory( (LPWSTR)lParam,  lpszStrW, lRetValue + sizeof(WCHAR) );

    LocalFreeAndNull(&lpszStrW);
    LocalFreeAndNull(&lpszStrA);

    return (LRESULT)lRetValue;
}

LRESULT WINAPI Combo_InsertStringA(HWND hWnd,UINT Msg, WPARAM wParam,LPARAM lParam)
{

   LRESULT  lRetValue;
   LPSTR    lpszStrA = NULL;
   LPWSTR   lpszStrW = NULL;

   lpszStrW = (LPWSTR)lParam;

   lpszStrA = ConvertWtoA( lpszStrW );

   lRetValue = SendMessageA(hWnd, CB_INSERTSTRING, wParam, (LPARAM)lpszStrA );

   LocalFreeAndNull( &lpszStrA );

   return lRetValue;


}

LRESULT WINAPI Combo_FindStringA(HWND hWnd,UINT Msg, WPARAM wParam,LPARAM lParam)
{

   LRESULT  lRetValue;
   LPSTR    lpszStrA = NULL;
   LPWSTR   lpszStrW = NULL;

   lpszStrW = (LPWSTR)lParam;

   lpszStrA = ConvertWtoA( lpszStrW );

   lRetValue = SendMessageA(hWnd, CB_FINDSTRING, wParam, (LPARAM)lpszStrA );

   LocalFreeAndNull( &lpszStrA );

   return lRetValue;

}


// Animation Control wrappers

LRESULT WINAPI Animate_OpenA( HWND hWnd,UINT Msg, WPARAM wParam,LPARAM lParam)
{
    
  LRESULT  lRetValue;
  

  // lParam pointers to a string or resource String ID, 
  // in our codes, only Resources IDs are passed to this function
  // so we don't want to convert value for this parameter

  lRetValue = SendMessageA( hWnd, ACM_OPENA, wParam, lParam );

  return lRetValue;

}


// Tooltip Wrappers
LRESULT WINAPI ToolTip_AddTool(HWND hWnd,LPARAM lParam)
{

    LRESULT  lRetValue;
    LPSTR    lpszStrA = NULL;
    LPWSTR   lpszStrW = NULL;
    TOOLINFOA TIA = {0}; 
    LPTOOLINFOW lpTIW = (LPTOOLINFOW)lParam;
    WPARAM wParam = 0;

    if (g_bRunningOnNT)
        return SendMessageW(hWnd, TTM_ADDTOOLW, wParam, lParam);

    if(!lpTIW)
        return 0;

    CopyMemory(&TIA, lpTIW, sizeof(TOOLINFOA));

    TIA.lpszText = ConvertWtoA(lpTIW->lpszText); 

    lRetValue = SendMessageA(hWnd, TTM_ADDTOOLA, wParam, (LPARAM)&TIA );

    LocalFreeAndNull( &TIA.lpszText );

    return lRetValue;

}

//
// Guess what TTM_UPDATETIPTEXT is the same as EM_FORMATRANGE .. therefore can't use it 
// through the SendMessage wrapper .. need our own function for this 
LRESULT WINAPI ToolTip_UpdateTipText(HWND hWnd,LPARAM lParam)
{

    LRESULT  lRetValue;
    LPSTR    lpszStrA = NULL;
    LPWSTR   lpszStrW = NULL;
    TOOLINFOA TIA = {0}; 
    LPTOOLINFOW lpTIW = (LPTOOLINFOW)lParam;
    WPARAM wParam = 0;

    if (g_bRunningOnNT)
        return SendMessageW(hWnd, TTM_UPDATETIPTEXTW, wParam, lParam);

    if(!lpTIW)
        return 0;

    CopyMemory(&TIA, lpTIW, sizeof(TOOLINFOA));

    TIA.lpszText = ConvertWtoA(lpTIW->lpszText); 

    lRetValue = SendMessageA(hWnd, TTM_UPDATETIPTEXTA, wParam, (LPARAM)&TIA );

    LocalFreeAndNull( &TIA.lpszText );

    return lRetValue;

}

// SendMessage WM_SETTEXT
LRESULT WINAPI WM_SetTextA( HWND   hWnd,  UINT   Msg,       // message to send
                                 WPARAM wParam,    // first message parameter
                                 LPARAM lParam )  // second message parameter
{
    LRESULT lRetValue = 0;
    LPSTR lpA = ConvertWtoA((LPCWSTR)lParam);
    lRetValue = SendMessageA(hWnd, WM_SETTEXT, wParam, (LPARAM)lpA);
    LocalFreeAndNull(&lpA);
    return lRetValue;
}


// SendMessage
//
// There is a big potential problem with this function .. since we
// are passing ALL the messages through this function, if there are any over-lapping
// message ids (e.g. TTM_UPDATETIPTEXT for tooltips is the same as EM_FORMATRANGE
// for the RichEdit control) with the result that we may route the wrong message to the
// wrong handler.. need to be careful about handling any messages in the WM_USER range ..
// This is specially true for a bunch of CommCtrls.
//  
LRESULT WINAPI SendMessageWrapW( HWND   hWnd,      // handle of destination window
                                 UINT   Msg,       // message to send
                                 WPARAM wParam,    // first message parameter
                                 LPARAM lParam )  // second message parameter
{


    VALIDATE_PROTOTYPE(SendMessage);
    
    if (g_bRunningOnNT)
        return SendMessageW(hWnd, Msg, wParam, lParam);


    switch (Msg) {
        
    case WM_SETTEXT:
                            return WM_SetTextA(hWnd, Msg, wParam, lParam);

 // for ListView Message
    case LVM_GETITEMTEXT :
                            return ListView_GetItemTextA(hWnd, Msg, wParam, lParam);
    case LVM_GETITEM :
                            return ListView_GetItemA(hWnd, Msg, wParam, lParam);
    case LVM_INSERTCOLUMN :
                            return ListView_InsertColumnA( hWnd, Msg, wParam, lParam);
    case LVM_INSERTITEM :
                            return ListView_InsertItemA(hWnd, Msg, wParam, lParam);
    case LVM_SETITEM :
                            return ListView_SetItemA(hWnd, Msg, wParam, lParam);
    case LVM_SETITEMTEXT :   
                            return ListView_SetItemTextA(hWnd, Msg, wParam, lParam);
    case LVM_SETCOLUMN :    
                            return ListView_SetColumnA(hWnd, Msg, wParam, lParam);
    case LVM_FINDITEM :     
                            return ListView_FindItemA(hWnd, Msg, wParam, lParam);
    case LVM_SORTITEMS :    
                            return ListView_SortItemsA(hWnd, Msg, wParam, lParam);
    case LVM_EDITLABEL :    
                            return ListView_EditLabelA(hWnd, Msg, wParam, lParam);

// For TreeView Message
    case TVM_GETITEM :
                            return TreeView_GetItemA(hWnd, Msg, wParam, lParam);
    case TVM_SETITEM :
                            return TreeView_SetItemA(hWnd, Msg, wParam, lParam);
    case TVM_INSERTITEM :
                            return TreeView_InsertItemA(hWnd, Msg, wParam, lParam);

// For TabCtrl Message
    case TCM_INSERTITEM :
                            return TabCtrl_InsertItemA( hWnd, Msg, wParam, lParam);


// For ComBo List Control
    case CB_ADDSTRING :
                            return Combo_AddStringA(hWnd, Msg, wParam, lParam);
    case CB_GETLBTEXT :
                            return Combo_GetLBTextA(hWnd, Msg, wParam, lParam);
    case CB_INSERTSTRING :
                            return Combo_InsertStringA(hWnd, Msg, wParam, lParam);
    case CB_FINDSTRING :
                            return Combo_FindStringA(hWnd, Msg, wParam, lParam);

// For ListBox Control
    case LB_ADDSTRING:
                            return ListBox_AddStringA(hWnd, Msg, wParam, lParam);

// For Animation Control 
    case ACM_OPEN :
                            return Animate_OpenA( hWnd, Msg, wParam, lParam);

// For Others
    default :
                            return SendMessageA(hWnd, Msg, wParam, lParam);
    }

}

// DefWindowProc
LRESULT WINAPI DefWindowProcWrapW( HWND   hWnd,      // handle to window
                                   UINT   Msg,       // message identifier
                                   WPARAM wParam,    // first message parameter
                                   LPARAM lParam )  // second message parameter
{


    VALIDATE_PROTOTYPE(DefWindowProc);
    
    if (g_bRunningOnNT)
        return DefWindowProcW(hWnd, Msg, wParam, lParam);


    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

// wsprintf

int WINAPI wsprintfWrapW( LPTSTR lpOut,      // pointer to buffer for output
                          LPCTSTR lpFmt,     // pointer to format-control string
                          ...            )  // optional arguments
{
    va_list ArgList;
    va_start(ArgList, lpFmt);

    return wvsprintfWrapW(lpOut, lpFmt, ArgList);
/*
    LPSTR lpFmtA = NULL, lpTemp = NULL;
    char szOut[1024]; //wsprintf has a 1k limit
    int nRet = 0;
    LPWSTR lpOutW = NULL;

    VALIDATE_PROTOTYPE(wsprintf);
    
    if (g_bRunningOnNT)
        return wsprintfW(lpOut, lpFmt, ... );

    // The argument list can have variable number of LPWSTR parameters which would
    // be too hard to check individually .. instead we can do one of 2 things:
    //  - we can change every %s to %S in the format string .. %S will tell the wsprintfA
    //      that the argument is a wide string
    //  - if this doesn't work then we can try making sure the input format string uses %ws always
    //
    lpFmtA = ConvertWtoA((LPWSTR)lpFmt);

    lpTemp = lpFmtA;

    while(lpTemp && *lpTemp)
    {
        if(*lpTemp == '%' && *(lpTemp+1) == 's')
            *(lpTemp+1) = 'S';
        lpTemp++;
    }

    nRet = wsprintfA(szOut,lpFmtA, ...);

    lpOutW = ConvertAtoW(szOut);

    My_wcscpy(lpOut, lpOutW);
    
    LocalFreeAndNull(&lpOutW);
    LocalFreeAndNull(&lpFmtA);

    return nRet;
*/
}

// wvsprintf
int WINAPI wvsprintfWrapW( LPTSTR lpOut,    // pointer to buffer for output
                           LPCTSTR lpFmt,   // pointer to format-control string
                           va_list arglist )  // variable list of format-control arguments
{
    LPSTR lpFmtA = NULL, lpTemp = NULL;
    char szOut[1024]; 
    int nRet = 0;
    LPWSTR lpOutW = NULL;

    VALIDATE_PROTOTYPE(wvsprintf);
    
    if (g_bRunningOnNT)
        return wvsprintfW(lpOut, lpFmt, arglist);

    // The argument list can have variable number of LPWSTR parameters which would
    // be too hard to check individually .. instead we can do one of 2 things:
    //  - we can change every %s to %S in the format string .. %S will tell the wsprintfA
    //      that the argument is a wide string
    //  - if this doesn't work then we can try making sure the input format string uses %ws always
    //
    lpFmtA = ConvertWtoA((LPWSTR)lpFmt);

    lpTemp = lpFmtA;

    while(lpTemp && *lpTemp)
    {
        if(*lpTemp == '%' && *(lpTemp+1) == 's')
            *(lpTemp+1) = 'S';
        lpTemp++;
    }

    nRet = wvsprintfA(szOut,lpFmtA, arglist);

    lpOutW = ConvertAtoW(szOut);

    My_wcscpy(lpOut, lpOutW);
    
    LocalFreeAndNull(&lpOutW);
    LocalFreeAndNull(&lpFmtA);

    return nRet;

}


// DialogBoxParam
INT_PTR WINAPI DialogBoxParamWrapW( HINSTANCE hInstance,       // handle to application instance
                                LPCTSTR   lpTemplateName,  // identifies dialog box template
                                HWND      hWndParent,      // handle to owner window
                                DLGPROC   lpDialogFunc,    // pointer to dialog box procedure
                                LPARAM    dwInitParam )   // initialization value
{
    INT_PTR    iRetValue = 0;
 //   LPSTR  lpTemplateNameA = NULL;

    VALIDATE_PROTOTYPE(DialogBoxParam);
    
    if (g_bRunningOnNT)
        return DialogBoxParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);


    // all templateName passed in our current codes are just IDD.
    // so don't do A/W conversion.

    // lpTemplateNameA = ConvertWtoA( lpTemplateName );

    iRetValue = DialogBoxParamA(hInstance, (LPCSTR)lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);

 //   LocalFreeAndNull( &lpTemplateNameA );
    if(iRetValue == -1)
        DebugTrace(TEXT("Error creating dialog: %d\n"), GetLastError());

    return iRetValue;

}


// SendDlgItemMessage
LRESULT WINAPI SendDlgItemMessageWrapW( HWND   hDlg,        // handle of dialog box
                                     int    nIDDlgItem,  // identifier of control
                                     UINT   Msg,         // message to send
                                     WPARAM wParam,      // first message parameter
                                     LPARAM lParam  )    // second message parameter
{
    VALIDATE_PROTOTYPE(SendDlgItemMessage);
    
    if (g_bRunningOnNT)
        return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);

    // [PaulHi] 1/19/99  Raid 66195
    // Must special case Win9X wrapper failures, just like with SendMessage
    // command
    {
        LPWSTR  lpszStrW = NULL;
        LPSTR   lpszStrA = NULL;
        LRESULT lRetValue = 0;

        switch (Msg)
        {
        case LB_GETTEXT:
        case CB_GETLBTEXT:
        case WM_GETTEXT:
            // Wrapper function returns single byte string instead of double byte.
            // Note that caller should be expecting double byte and should set lParam
            // size accordingly.
            lRetValue = SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
            lpszStrW = ConvertAtoW((LPSTR)lParam);
            lstrcpyWrapW((LPTSTR)lParam, lpszStrW);
            LocalFreeAndNull(&lpszStrW);
            break;

        case CB_ADDSTRING:
            Assert(lParam);
            lpszStrA = ConvertWtoA((LPCWSTR)lParam);
            lRetValue = SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, (LPARAM)lpszStrA);
            LocalFreeAndNull(&lpszStrA);
            break;

        default:
            lRetValue = SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
        }

        return lRetValue;
    }
}

// SetWindowLong
LONG WINAPI SetWindowLongWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG dwNewLong )  // new value
{

    VALIDATE_PROTOTYPE(SetWindowLong);
    
    if (g_bRunningOnNT)
        return SetWindowLongW(hWnd, nIndex, dwNewLong);

    return SetWindowLongA(hWnd, nIndex, dwNewLong);

}


// GetWindowLong
LONG WINAPI GetWindowLongWrapW( HWND hWnd,    // handle of window
                                int  nIndex ) // offset of value to retrieve
{


    VALIDATE_PROTOTYPE(GetWindowLong);
    
    if (g_bRunningOnNT)
        return GetWindowLongW(hWnd, nIndex);

    return GetWindowLongA(hWnd, nIndex);

}

// SetWindowLong
LONG_PTR WINAPI SetWindowLongPtrWrapW( HWND hWnd,         // handle of window
                                int  nIndex,       // offset of value to set
                                LONG_PTR dwNewLong )  // new value
{

    VALIDATE_PROTOTYPE(SetWindowLongPtr);
    
    if (g_bRunningOnNT)
        return SetWindowLongPtrW(hWnd, nIndex, dwNewLong);

    return SetWindowLongPtrA(hWnd, nIndex, dwNewLong);

}


// GetWindowLong
LONG_PTR WINAPI GetWindowLongPtrWrapW( HWND hWnd,    // handle of window
                                int  nIndex ) // offset of value to retrieve
{


    VALIDATE_PROTOTYPE(GetWindowLongPtr);
    
    if (g_bRunningOnNT)
        return GetWindowLongPtrW(hWnd, nIndex);

    return GetWindowLongPtrA(hWnd, nIndex);

}


// CreateWindowEx
HWND WINAPI CreateWindowExWrapW( DWORD     dwExStyle,    // extended window style
                                 LPCTSTR   lpClassName,  // pointer to registered class name
                                 LPCTSTR   lpWindowName, // pointer to window name
                                 DWORD     dwStyle,      // window style
                                 int       x,            // horizontal position of window
                                 int       y,            // vertical position of window
                                 int       nWidth,       // window width
                                 int       nHeight,      // window height
                                 HWND      hWndParent,   // handle to parent or owner window
                                 HMENU     hMenu,        // handle to menu, or child-window identifier
                                 HINSTANCE hInstance,    // handle to application instance
                                 LPVOID    lpParam  )    // pointer to window-creation data

{

    HWND    hRetValue = NULL;
    LPSTR   lpClassNameA = NULL;
    LPSTR   lpWindowNameA = NULL;

    VALIDATE_PROTOTYPE(CreateWindowEx);
    
    if (g_bRunningOnNT)
        return CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, x, y, 
                               nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);

    lpClassNameA  = ConvertWtoA( lpClassName );
    lpWindowNameA = ConvertWtoA( lpWindowName );

    hRetValue = CreateWindowExA(dwExStyle, lpClassNameA, lpWindowNameA, dwStyle, x, y, 
                                nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);

    LocalFreeAndNull( &lpClassNameA );
    LocalFreeAndNull( &lpWindowNameA );

    return hRetValue;

}

// UnregisterClass
BOOL WINAPI UnregisterClassWrapW( LPCTSTR    lpClassName,  // address of class name string
                                  HINSTANCE  hInstance )   // handle of application instance
{
    BOOL  bRetValue;
    LPSTR lpClassNameA = NULL;

    VALIDATE_PROTOTYPE(UnregisterClass);
    
    if (g_bRunningOnNT)
        return UnregisterClassW(lpClassName, hInstance);

    lpClassNameA = ConvertWtoA( lpClassName );

    bRetValue = UnregisterClassA(lpClassNameA, hInstance);

    LocalFreeAndNull( &lpClassNameA );

    return bRetValue;

}

// RegisterClass
ATOM WINAPI RegisterClassWrapW(CONST WNDCLASS *lpWndClass )  // address of structure with class date
{
    ATOM        aRetValue;
    WNDCLASSA   CLassA;
    LPSTR       lpszMenuName = NULL;
    LPSTR       lpszClassName = NULL;


    VALIDATE_PROTOTYPE(RegisterClass);
    
    if (g_bRunningOnNT)
        return RegisterClassW(lpWndClass);

    CLassA.style         = lpWndClass->style;
    CLassA.lpfnWndProc   = lpWndClass->lpfnWndProc;
    CLassA.cbClsExtra    = lpWndClass->cbClsExtra;
    CLassA.cbWndExtra    = lpWndClass->cbWndExtra;
    CLassA.hInstance     = lpWndClass->hInstance;
    CLassA.hIcon         = lpWndClass->hIcon;
    CLassA.hCursor       = lpWndClass->hCursor;
    CLassA.hbrBackground = lpWndClass->hbrBackground;
    CLassA.lpszMenuName  = NULL;
    CLassA.lpszClassName = NULL;

    if ( lpWndClass->lpszMenuName) {
       lpszMenuName  = ConvertWtoA(lpWndClass->lpszMenuName);
       CLassA.lpszMenuName  = lpszMenuName;

    }

    if ( lpWndClass->lpszClassName ) {
       lpszClassName = ConvertWtoA(lpWndClass->lpszClassName);
       CLassA.lpszClassName = lpszClassName;
    }

    aRetValue = RegisterClassA(&CLassA);

    LocalFreeAndNull( &lpszMenuName );
    LocalFreeAndNull( &lpszClassName );

    return aRetValue;

}

// LoadCursor
HCURSOR WINAPI LoadCursorWrapW( HINSTANCE hInstance,      // handle to application instance
                                LPCTSTR   lpCursorName )  // name string or cursor resource identifier
{


    VALIDATE_PROTOTYPE(LoadCursor);
    
    if (g_bRunningOnNT)
        return LoadCursorW(hInstance, lpCursorName);

    return LoadCursorA(hInstance, (LPSTR)lpCursorName);

}

// RegisterWindowMessage
UINT WINAPI RegisterWindowMessageWrapW( LPCTSTR lpString )  // address of message string
{
    UINT  uRetValue = 0;
    LPSTR lpStringA = NULL;

    VALIDATE_PROTOTYPE(RegisterWindowMessage);
    
    if (g_bRunningOnNT)
        return RegisterWindowMessageW(lpString);


    lpStringA = ConvertWtoA( lpString );

    uRetValue = RegisterWindowMessageA( lpStringA );

    LocalFreeAndNull( &lpStringA );

    return uRetValue;
}


// SystemParametersInfo
BOOL WINAPI SystemParametersInfoWrapW( UINT  uiAction,   // system parameter to query or set
                                       UINT  uiParam,    // depends on action to be taken
                                       PVOID pvParam,    // depends on action to be taken
                                       UINT  fWinIni )   // user profile update flag

{
    BOOL      bRetValue;
    LOGFONTA  lfFontA;
    LOGFONTW  lfFontW;
    
    VALIDATE_PROTOTYPE(SystemParametersInfo);
    
    if (g_bRunningOnNT)
        return SystemParametersInfoW(uiAction, uiParam, pvParam, fWinIni);

    if ( uiAction != SPI_GETICONTITLELOGFONT )

        return SystemParametersInfoA(uiAction, uiParam, pvParam, fWinIni);

    // we handle SPI_GETICONTITLELOGFONT only for our special requirement. ...

    bRetValue = SystemParametersInfoA(uiAction, uiParam, &lfFontA, fWinIni);

    if ( bRetValue == FALSE )  return FALSE;

  // copy all the fields except lfFaceName from lfFontA to lfFontW
    CopyMemory(&lfFontW,&lfFontA, sizeof(LOGFONTA) );
    
    // translate the lfFaceName[] from A to W

    MultiByteToWideChar(GetACP(), 0, lfFontA.lfFaceName, LF_FACESIZE, lfFontW.lfFaceName, LF_FACESIZE);
    
    CopyMemory(pvParam, &lfFontW, sizeof(LOGFONTW) );

    return bRetValue;
}                                                         
/*
// No A & W version.

BOOL WINAPI ShowWindow( HWND hWnd,       // handle to window
                        int nCmdShow )  // show state of window
*/

// CreateDialogParam
HWND WINAPI CreateDialogParamWrapW( HINSTANCE hInstance,      // handle to application instance
                                    LPCTSTR   lpTemplateName, // identifies dialog box template
                                    HWND      hWndParent,     // handle to owner window
                                    DLGPROC   lpDialogFunc,   // pointer to dialog box procedure
                                    LPARAM    dwInitParam )  // initialization value
{
    VALIDATE_PROTOTYPE(CreateDialogParam);
    
    if (g_bRunningOnNT)
        return CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);

    return CreateDialogParamA(hInstance, (LPCSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

// SetWindowText
BOOL WINAPI SetWindowTextWrapW( HWND    hWnd,         // handle to window or control
                                LPCTSTR lpString )   // address of string
{
    BOOL  bRetValue;
    LPSTR lpStringA = NULL;

    VALIDATE_PROTOTYPE(SetWindowText);
    
    if (g_bRunningOnNT)
        return SetWindowTextW(hWnd, lpString);


    lpStringA = ConvertWtoA( lpString );

    bRetValue = SetWindowTextA( hWnd, lpStringA);

    LocalFreeAndNull( &lpStringA );

    return bRetValue;
}

// PostMessage
BOOL WINAPI PostMessageWrapW( HWND   hWnd,      // handle of destination window
                              UINT   Msg,       // message to post
                              WPARAM wParam,    // first message parameter
                              LPARAM lParam  ) // second message parameter
{


    VALIDATE_PROTOTYPE(PostMessage);
    
    if (g_bRunningOnNT)
        return PostMessageW(hWnd, Msg, wParam, lParam);

    return PostMessageA(hWnd, Msg, wParam, lParam);
 
}

// GetMenuItemInfo
BOOL WINAPI GetMenuItemInfoWrapW( HMENU          hMenu,          
                                  UINT           uItem,           
                                  BOOL           fByPosition,     
                                  LPMENUITEMINFO lpmii        )
{

    BOOL           bRetValue;
    MENUITEMINFOA  miiA = {0};
    LPSTR           lpA = NULL;    
    LPWSTR          lpW = NULL;
    LPWSTR          lpOld = NULL;

    VALIDATE_PROTOTYPE(GetMenuItemInfo);
    
    if (g_bRunningOnNT)
        return GetMenuItemInfoW(hMenu, uItem, fByPosition, lpmii);

    CopyMemory(&miiA, lpmii, sizeof(MENUITEMINFOA) );
    miiA.cbSize = sizeof (MENUITEMINFOA);

    if(miiA.fMask & MIIM_TYPE)
    {
        lpA = LocalAlloc(LMEM_ZEROINIT, lpmii->cch+1);

        miiA.dwTypeData = lpA;
        miiA.cch = lpmii->cch;
    }

    bRetValue = GetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA);

    if(bRetValue)
    {
        lpOld = lpmii->dwTypeData;
        CopyMemory(lpmii, &miiA, sizeof(MENUITEMINFOA) );
        lpmii->dwTypeData = lpOld;

        if ( miiA.fMask & MIIM_TYPE ) 
        {
            lpW = ConvertAtoW(miiA.dwTypeData);
            lstrcpyWrapW(lpmii->dwTypeData,lpW);
            lpmii->cch = My_wcslen( lpmii->dwTypeData );
        }
    }

    LocalFreeAndNull(&lpA);
    LocalFreeAndNull(&lpW);
    
    return bRetValue;
}

// GetClassInfo
BOOL WINAPI GetClassInfoWrapW( HINSTANCE   hInstance,     // handle of application instance
                               LPCTSTR     lpClassName,   // address of class name string
                               LPWNDCLASS  lpWndClass )   // address of structure for class data
{
    
    BOOL       bRetValue;
    LPSTR      lpClassNameA = NULL;
    WNDCLASSA  ClassA;

    VALIDATE_PROTOTYPE(GetClassInfo);
    
    if (g_bRunningOnNT)
        return GetClassInfoW(hInstance, lpClassName, lpWndClass);

    lpClassNameA = ConvertWtoA( lpClassName );

    bRetValue = GetClassInfoA(hInstance, lpClassNameA, &ClassA );

    if (bRetValue == FALSE) {
         LocalFreeAndNull( & lpClassNameA );
         return FALSE;
    }

    CopyMemory(lpWndClass, &ClassA, sizeof(WNDCLASSA)-2*sizeof(LPSTR) );

    if ( ClassA.lpszMenuName && !IS_INTRESOURCE(ClassA.lpszMenuName) )
        lpWndClass->lpszMenuName = ConvertAtoW( ClassA.lpszMenuName );
    else
        lpWndClass->lpszMenuName = NULL;

    if ( ClassA.lpszClassName && !IS_INTRESOURCE(ClassA.lpszClassName) ) // lpszClassName can be an atom, high word is null
        lpWndClass->lpszClassName = ConvertAtoW( ClassA.lpszClassName);
    else
        lpWndClass->lpszClassName = NULL;

    LocalFreeAndNull( & lpClassNameA );
    return bRetValue;
    
}

//----------------------------------------------------------------------
//
// function:    CharLowerWrapW( LPWSTR pch )
//
// purpose:     Converts character to lowercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Lowercased character or string.  In the string case,
//              the lowercasing is done inplace.
//
//----------------------------------------------------------------------
LPWSTR WINAPI
CharLowerWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharLower);

    if (g_bRunningOnNT)
    {
        return CharLowerW( pch );
    }

    if (!HIWORD(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharLowerBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharLowerBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}


//----------------------------------------------------------------------
//
// function:    CharLowerBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to lowercase.  String must be cch
//              characters in length.
//
// returns:     Character count (cch).  The lowercasing is done inplace.
//
//----------------------------------------------------------------------
DWORD WINAPI
CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    DWORD cch;

    VALIDATE_PROTOTYPE(CharLowerBuff);

    if (g_bRunningOnNT)
    {
        return CharLowerBuffW( pch, cchLength );
    }

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharUpperWrapW(ch))
        {
            if (ch < 0x0100)
            {
                *pch += 32;             // Get Latin-1 out of the way first
            }
            else if (ch < 0x0531)
            {
                if (ch < 0x0391)
                {
                    if (ch < 0x01cd)
                    {
                        if (ch <= 0x178)
                        {
                            if (ch < 0x0178)
                            {
                                *pch += (ch == 0x0130) ? 0 : 1;
                            }
                            else
                            {
                                *pch -= 121;
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                            {  // 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
            /* 0x0179-0x17f */           1,   0,   1,   0,   1,   0,   0,
            /* 0x0180-0x187 */      0, 210,   1,   0,   1,   0, 206,   1,
            /* 0x0188-0x18f */      0, 205, 205,   1,   0,   0,  79, 202,
            /* 0x0190-0x197 */    203,   1,   0, 205, 207,   0, 211, 209,
            /* 0x0198-0x19f */      1,   0,   0,   0, 211, 213,   0, 214,
            /* 0x01a0-0x1a7 */      1,   0,   1,   0,   1,   0,   0,   1,
            /* 0x01a8-0x1af */      0, 218,   0,   0,   1,   0, 218,   1,
            /* 0x01b0-0x1b7 */      0, 217, 217,   1,   0,   1,   0, 219,
            /* 0x01b8-0x1bf */      1,   0,   0,   0,   1,   0,   0,   0,
            /* 0x01c0-0x1c7 */      0,   0,   0,   0,   2,   0,   0,   2,
            /* 0x01c8-0x1cb */      0,   0,   2,   0
                            };

                            *pch += abLookup[ch-0x0179];
                        }
                    }
                    else if (ch < 0x0386)
                    {
                        switch (ch)
                        {
                            case 0x01f1: *pch += 2; break;
                            case 0x01f2: break;
                            default: *pch += 1;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                            { 38, 0, 37, 37, 37, 0, 64, 0, 63, 63 };

                        *pch += abLookup[ch-0x0386];
                    }
                }
                else
                {
                    if (ch < 0x0410)
                    {
                        if (ch < 0x0401)
                        {
                            if (ch < 0x03e2)
                            {
                                if (!InRange(ch, 0x03d2, 0x03d4) &&
                                    !(InRange(ch, 0x3da, 0x03e0) & !(ch & 1)))
                                {
                                    *pch += 32;
                                }
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else
                        {
                            *pch += 80;
                        }
                    }
                    else
                    {
                        if (ch < 0x0460)
                        {
                            *pch += 32;
                        }
                        else
                        {
                            *pch += 1;
                        }
                    }
                }
            }
            else
            {
                if (ch < 0x2160)
                {
                    if (ch < 0x1fba)
                    {
                        if (ch < 0x1f08)
                        {
                            if (ch < 0x1e00)
                            {
                                *pch += 48;
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else if (!(InRange(ch, 0x1f88, 0x1faf) && (ch & 15)>7))
                        {
                            *pch -= 8;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                        {  // 8    9    a    b    c    d    e    f
                              0,   0,  74,  74,   0,   0,   0,   0,
                             86,  86,  86,  86,   0,   0,   0,   0,
                              8,   8, 100, 100,   0,   0,   0,   0,
                              8,   8, 112, 112,   7,   0,   0,   0,
                            128, 128, 126, 126,   0,   0,   0,   0
                        };
                        int i = (ch-0x1fb0);

                        *pch -= (int)abLookup[((i>>1) & ~7) | (i & 7)];
                    }
                }
                else
                {
                    if (ch < 0xff21)
                    {
                        if (ch < 0x24b6)
                        {
                            *pch += 16;
                        }
                        else
                        {
                            *pch += 26;
                        }
                    }
                    else
                    {
                        *pch += 32;
                    }
                }
            }
        }
        else
        {
            // These are Unicode Number Forms.  They have lowercase counter-
            // parts, but are not considered uppercase.  Why, I don't know.

            if (InRange(ch, 0x2160, 0x216f))
            {
                *pch += 16;
            }
        }
    }

    return cchLength;
}

//----------------------------------------------------------------------
//
// function:    CharUpperBuffWrapW( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to uppercase.  String must be cch
//              characters in length.  Note that this function is
//              is messier that CharLowerBuffWrap, and the reason for
//              this is many Unicode characters are considered uppercase,
//              even when they don't have an uppercase counterpart.
//
// returns:     Character count (cch).  The uppercasing is done inplace.
//
//----------------------------------------------------------------------
DWORD WINAPI
CharUpperBuffWrapW( LPWSTR pch, DWORD cchLength )
{
    DWORD cch;

    VALIDATE_PROTOTYPE(CharUpperBuff);

    if (g_bRunningOnNT)
    {
        return CharUpperBuffW( pch, cchLength );
    }

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharLowerWrapW(ch))
        {
            if (ch < 0x00ff)
            {
                *pch -= ((ch != 0xdf) << 5);
            }
            else if (ch < 0x03b1)
            {
                if (ch < 0x01f5)
                {
                    if (ch < 0x01ce)
                    {
                        if (ch < 0x017f)
                        {
                            if (ch < 0x0101)
                            {
                                *pch += 121;
                            }
                            else
                            {
                                *pch -= (ch != 0x0131 &&
                                         ch != 0x0138 &&
                                         ch != 0x0149);
                            }
                        }
                        else if (ch < 0x01c9)
                        {
                            static const BYTE abMask[] =
                            {                       // 6543210f edcba987
                                0xfc, 0xbf,         // 11111100 10111111
                                0xbf, 0x67,         // 10111111 01100111
                                0xff, 0xef,         // 11111111 11101111
                                0xff, 0xf7,         // 11111111 11110111
                                0xbf, 0xfd          // 10111111 11111101
                            };

                            int i = ch - 0x017f;

                            *pch -= ((abMask[i>>3] >> (i&7)) & 1) +
                                    (ch == 0x01c6);
                        }
                        else
                        {
                            *pch -= ((ch != 0x01cb)<<1);
                        }
                    }
                    else
                    {
                        if (ch < 0x01df)
                        {
                            if (ch < 0x01dd)
                            {
                                *pch -= 1;
                            }
                            else
                            {
                                *pch -= 79;
                            }
                        }
                        else
                        {
                            *pch -= 1 + (ch == 0x01f3) -
                                    InRange(ch,0x01f0,0x01f2);
                        }
                    }
                }
                else if (ch < 0x0253)
                {
                    *pch -= (ch < 0x0250);
                }
                else if (ch < 0x03ac)
                {
                    static const BYTE abLookup[] =
                    {// 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
    /* 0x0253-0x0257 */                210, 206,   0, 205, 205,
    /* 0x0258-0x025f */   0, 202,   0, 203,   0,   0,   0,   0,
    /* 0x0260-0x0267 */ 205,   0,   0, 207,   0,   0,   0,   0,
    /* 0x0268-0x026f */ 209, 211,   0,   0,   0,   0,   0, 211,
    /* 0x0270-0x0277 */   0,   0, 213,   0,   0, 214,   0,   0,
    /* 0x0278-0x027f */   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0x0280-0x0287 */   0,   0,   0, 218,   0,   0,   0,   0,
    /* 0x0288-0x028f */ 218,   0, 217, 217,   0,   0,   0,   0,
    /* 0x0290-0x0297 */   0,   0, 219
                    };

                    if (ch <= 0x0292)
                    {
                        *pch -= abLookup[ch - 0x0253];
                    }
                }
                else
                {
                    *pch -= (ch == 0x03b0) ? 0 : (37 + (ch == 0x03ac));
                }
            }
            else
            {
                if (ch < 0x0561)
                {
                    if (ch < 0x0451)
                    {
                        if (ch < 0x03e3)
                        {
                            if (ch < 0x03cc)
                            {
                                *pch -= 32 - (ch == 0x03c2);
                            }
                            else
                            {
                                int i = (ch < 0x03d0);
                                *pch -= (i<<6) - i + (ch == 0x03cc);
                            }
                        }
                        else if (ch < 0x0430)
                        {
                            *pch -= (ch < 0x03f0);
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                    else if (ch < 0x0461)
                    {
                        *pch -= 80;
                    }
                    else
                    {
                        *pch -= 1;
                    }
                }
                else
                {
                    if (ch < 0x1fb0)
                    {
                        if (ch < 0x1f70)
                        {
                            if (ch < 0x1e01)
                            {
                                int i = ch != 0x0587 && ch < 0x10d0;
                                *pch -= ((i<<5)+(i<<4)); /* 48 */
                            }
                            else if (ch < 0x1f00)
                            {
                                *pch -= !InRange(ch, 0x1e96, 0x1e9a);
                            }
                            else
                            {
                                int i = !InRange(ch, 0x1f50, 0x1f56)||(ch & 1);
                                *pch += (i<<3);
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                                { 74, 86, 86, 100, 128, 112, 126 };

                            if ( ch <= 0x1f7d )
                            {
                                *pch += abLookup[(ch-0x1f70)>>1];
                            }
                        }
                    }
                    else
                    {
                        if (ch < 0x24d0)
                        {
                            if (ch < 0x1fe5)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 8 : 0;
                            }
                            else if (ch < 0x2170)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 7 : 0;
                            }
                            else
                            {
                                *pch -= ((ch > 0x24b5)<<4);
                            }
                        }
                        else if (ch < 0xff41)
                        {
                            int i = !InRange(ch, 0xfb00, 0xfb17);
                            *pch -= (i<<4)+(i<<3)+(i<<1); /* 26 */
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                }
            }
        }
        else
        {
            int i = InRange(ch, 0x2170, 0x217f);
            *pch -= (i<<4);
        }
    }

    return cchLength;
}

// CharUpper
//----------------------------------------------------------------------
//
// function:    CharUpperWrapW( LPWSTR pch )
//
// purpose:     Converts character to uppercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Uppercased character or string.  In the string case,
//              the uppercasing is done inplace.
//
//----------------------------------------------------------------------
LPWSTR WINAPI
CharUpperWrapW( LPWSTR pch )
{
    VALIDATE_PROTOTYPE(CharUpper);

    if (g_bRunningOnNT)
    {
        return CharUpperW( pch );
    }

    if (!HIWORD(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharUpperBuffWrapW( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharUpperBuffWrapW( pch, lstrlenW(pch) );
    }

    return pch;
}

/*
LPTSTR WINAPI CharUpperWrapW( LPTSTR lpsz )    // single character or pointer to string
{

    LPWSTR  lpszW = NULL;
    LPSTR   lpszA = NULL;
    LPSTR   lpszUpperA = NULL;


    VALIDATE_PROTOTYPE(CharUpper);
    
    if (g_bRunningOnNT)
        return CharUpperW(lpsz);

    lpszA = ConvertWtoA( lpsz );

    lpszUpperA = CharUpperA( lpszA );

    lpszW = ConvertAtoW( lpszUpperA );

    CopyMemory( lpsz, lpszW, My_wcslen(lpszW) * sizeof(WCHAR) );

    LocalFreeAndNull( &lpszW );
    LocalFreeAndNull( &lpszA );

    return lpsz;
}
*/

// RegisterClipboardFormat
UINT WINAPI RegisterClipboardFormatWrapW( LPCTSTR lpszFormat )  // address of name string
{
    UINT   uRetValue =0;
    LPSTR  lpszFormatA = NULL;

    VALIDATE_PROTOTYPE(RegisterClipboardFormat);
    
    if (g_bRunningOnNT)
        return RegisterClipboardFormatW(lpszFormat);

    lpszFormatA = ConvertWtoA( lpszFormat );

    uRetValue = RegisterClipboardFormatA( lpszFormatA );

    LocalFreeAndNull( &lpszFormatA );

    return uRetValue;

}

// DispatchMessage
LRESULT WINAPI DispatchMessageWrapW( CONST MSG *lpmsg )  // pointer to structure with message
{


    VALIDATE_PROTOTYPE(DispatchMessage);
    
    if (g_bRunningOnNT)
        return DispatchMessageW(lpmsg);

    return DispatchMessageA(lpmsg);

}
/* No A & W version
BOOL WINAPI TranslateMessage( IN CONST MSG *lpMsg)
*/

// IsDialogMessage
BOOL WINAPI IsDialogMessageWrapW( HWND  hDlg,    // handle of dialog box
                                  LPMSG lpMsg ) // address of structure with message
{


    VALIDATE_PROTOTYPE(IsDialogMessage);
    
    if (g_bRunningOnNT)
        return IsDialogMessageW(hDlg, lpMsg);

    return IsDialogMessageA(hDlg, lpMsg);

}

// GetMessage
BOOL WINAPI GetMessageWrapW( LPMSG lpMsg,            // address of structure with message
                             HWND  hWnd,             // handle of window
                             UINT  wMsgFilterMin,    // first message
                             UINT  wMsgFilterMax )  // last message
{


    VALIDATE_PROTOTYPE(GetMessage);
    
    if (g_bRunningOnNT)
        return GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);

    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);

}

// SetDlgItemText
BOOL WINAPI SetDlgItemTextWrapW( HWND    hDlg,        // handle of dialog box
                                 int     nIDDlgItem,  // identifier of control
                                 LPCTSTR lpString )  // text to set
{

    BOOL  bRetValue;
    LPSTR lpStringA = NULL;

    VALIDATE_PROTOTYPE(SetDlgItemText);
    
    if (g_bRunningOnNT)
        return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);

    lpStringA = ConvertWtoA( lpString );

    bRetValue = SetDlgItemTextA(hDlg, nIDDlgItem, lpStringA);

    LocalFreeAndNull( &lpStringA );

    return bRetValue;

}

// RegisterClassEx
ATOM WINAPI RegisterClassExWrapW( CONST WNDCLASSEX *lpwcx )  // address of structure with class data
{

    ATOM        aReturn;
    WNDCLASSEXA wcxA;
    PSTR       lpszClassName = NULL;
    PSTR       lpszMenuName = NULL;

    VALIDATE_PROTOTYPE(RegisterClassEx);
    
    if (g_bRunningOnNT)
        return RegisterClassExW(lpwcx);

    wcxA.cbSize        = sizeof(WNDCLASSEXA);
    wcxA.style         = lpwcx->style; 
    wcxA.lpfnWndProc   = lpwcx->lpfnWndProc; 
    wcxA.cbClsExtra    = lpwcx->cbClsExtra; 
    wcxA.cbWndExtra    = lpwcx->cbWndExtra; 
    wcxA.hInstance     = lpwcx->hInstance;
    wcxA.hIcon         = lpwcx->hIcon; 
    wcxA.hCursor       = lpwcx->hCursor; 
    wcxA.hbrBackground = lpwcx->hbrBackground; 
    wcxA.hIconSm       = lpwcx->hIconSm;
    
    if ( lpwcx->lpszMenuName) {
       lpszMenuName  = ConvertWtoA(lpwcx->lpszMenuName);
       wcxA.lpszMenuName  = lpszMenuName; 
    }

    if (lpwcx->lpszClassName) {
       lpszClassName = ConvertWtoA(lpwcx->lpszClassName);
       wcxA.lpszClassName = lpszClassName;
    } 

    aReturn = RegisterClassExA( &wcxA );

    if ( wcxA.lpszMenuName)
       LocalFreeAndNull( &lpszMenuName ); 

    if (wcxA.lpszClassName)
       LocalFreeAndNull( &lpszClassName ); 
    
    return aReturn;

}


// LoadAccelerators
HACCEL WINAPI LoadAcceleratorsWrapW( HINSTANCE hInstance,    // handle to application instance
                                     LPCTSTR lpTableName )  // address of table-name string
{

    HACCEL  hRetValue = NULL;
    LPSTR   lpTableNameA = NULL;

    VALIDATE_PROTOTYPE(LoadAccelerators);
    
    if (g_bRunningOnNT)
        return LoadAcceleratorsW(hInstance, lpTableName);

    lpTableNameA = ConvertWtoA( lpTableName );

    hRetValue = LoadAcceleratorsA( hInstance, lpTableNameA );

    LocalFreeAndNull( &lpTableNameA );

    return hRetValue;


}

// LoadMenu
HMENU WINAPI LoadMenuWrapW( HINSTANCE hInstance,      // handle to application instance
                            LPCTSTR   lpMenuName )   // menu name string or menu-resource identifier
                        
{
    HMENU  hRetValue = NULL;
    LPSTR  lpMenuNameA = NULL;

    VALIDATE_PROTOTYPE(LoadMenu);
    
    if (g_bRunningOnNT)
        return LoadMenuW(hInstance, lpMenuName);

    // becuause all the calling to this functions in our project just pass 
    // and Resource ID as lpMenuName. so don't need to covert like a string

    lpMenuNameA = MAKEINTRESOURCEA(lpMenuName);

    hRetValue = LoadMenuA(hInstance,lpMenuNameA);

    return hRetValue;
}

//LoadIcon
HICON WINAPI LoadIconWrapW( HINSTANCE hInstance,     // handle to application instance
                           LPCTSTR    lpIconName )  // icon-name string or icon resource identifier
                       
{
    HICON  hRetValue = NULL;
    LPSTR  lpIconNameA = NULL;

    VALIDATE_PROTOTYPE(LoadIcon);
    
    if (g_bRunningOnNT)
        return LoadIconW(hInstance, lpIconName);

    // becuause all the calling to this functions in our project just pass 
    // and Resource ID as lpMenuName. so don't need to covert like a string

    lpIconNameA = MAKEINTRESOURCEA(lpIconName );

    hRetValue = LoadIconA(hInstance, lpIconNameA);

    return hRetValue;
}

// GetWindowText
int WINAPI GetWindowTextWrapW( HWND   hWnd,         // handle to window or control with text
                               LPTSTR lpString,     // address of buffer for text
                               int    nMaxCount  ) // maximum number of characters to copy
{
    int     iRetValue =0;
    LPSTR   lpStringA = NULL;
    LPWSTR  lpStringW = NULL;
    int     nCount =0;

    VALIDATE_PROTOTYPE(GetWindowText);
    
	*lpString = '\0';

    if (g_bRunningOnNT)
        return GetWindowTextW(hWnd, lpString, nMaxCount);


    nCount = nMaxCount * sizeof( WCHAR );
    lpStringA = LocalAlloc( LMEM_ZEROINIT, nCount );

    iRetValue = GetWindowTextA(hWnd, lpStringA, nCount);

    if ( iRetValue == 0 ) {
        LocalFreeAndNull( &lpStringA );
        return iRetValue;
    }

    lpStringW = ConvertAtoW( lpStringA );
    nCount = My_wcslen( lpStringW );

    if ( nCount >= nMaxCount )
        nCount = nMaxCount - 1;

    CopyMemory( lpString, lpStringW,  nCount * sizeof(WCHAR) );

    lpString[nCount] = 0x0000;

    iRetValue = nCount;

    LocalFreeAndNull( &lpStringA );
    LocalFreeAndNull( &lpStringW );

    return iRetValue;
}

// CallWindowProcWrap
LRESULT WINAPI CallWindowProcWrapW( WNDPROC lpPrevWndFunc,   // pointer to previous procedure
                                    HWND    hWnd,            // handle to window
                                    UINT    Msg,             // message
                                    WPARAM  wParam,          // first message parameter
                                    LPARAM  lParam  )       // second message parameter
{


    VALIDATE_PROTOTYPE(CallWindowProc);
    
    if (g_bRunningOnNT)
        return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);


    return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);


}

// GetClassName
int WINAPI GetClassNameWrapW( HWND   hWnd,           // handle of window
                              LPTSTR lpClassName,    // address of buffer for class name
                              int    nMaxCount )    // size of buffer, in characters
{

    int     iRetValue =0;
    LPSTR   lpClassNameA = NULL;
    LPWSTR  lpClassNameW = NULL;
    int     nCount =0;

    VALIDATE_PROTOTYPE(GetClassName);
    
    if (g_bRunningOnNT)
        return GetClassNameW(hWnd, lpClassName, nMaxCount);


    nCount = nMaxCount * sizeof( WCHAR );
    lpClassNameA = LocalAlloc( LMEM_ZEROINIT, nCount );

    iRetValue = GetClassNameA(hWnd, lpClassNameA, nCount);

    if ( iRetValue == 0 ) {
        LocalFreeAndNull( &lpClassNameA );
        return iRetValue;
    }

    lpClassNameW = ConvertAtoW( lpClassNameA );
    nCount = My_wcslen( lpClassNameW );

    if ( nCount >= nMaxCount )
        nCount = nMaxCount - 1;

    CopyMemory( lpClassName, lpClassNameW,  nCount * sizeof(WCHAR) );

    lpClassName[nCount] = 0x0000;

    iRetValue = nCount;

    LocalFreeAndNull( &lpClassNameA );
    LocalFreeAndNull( &lpClassNameW );

    return iRetValue;


}

// TranslateAccelerator
int WINAPI TranslateAcceleratorWrapW( HWND   hWnd,        // handle to destination window
                                      HACCEL hAccTable,   // handle to accelerator table
                                      LPMSG  lpMsg )     // address of structure with message
{


    VALIDATE_PROTOTYPE(TranslateAccelerator);
    
    if (g_bRunningOnNT)
        return TranslateAcceleratorW(hWnd, hAccTable, lpMsg);

    
    return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);

}


// GetDlgItemText
UINT WINAPI GetDlgItemTextWrapW( HWND   hDlg,        // handle of dialog box
                                 int    nIDDlgItem,  // identifier of control
                                 LPTSTR lpString,    // address of buffer for text
                                 int    nMaxCount ) // maximum size of string
{

    int     iRetValue = 0;
    LPSTR   lpStringA = NULL;
    LPWSTR  lpStringW = NULL;
    int     nCount =0;

    VALIDATE_PROTOTYPE(GetDlgItemText);

    *lpString = '\0';

    if (g_bRunningOnNT)
        return GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount);


    nCount = nMaxCount * sizeof( WCHAR );
    lpStringA = LocalAlloc( LMEM_ZEROINIT, nCount );

    iRetValue = GetDlgItemTextA(hDlg, nIDDlgItem, lpStringA, nMaxCount);

    if ( iRetValue == 0 ) {
        LocalFreeAndNull( &lpStringA );
        return iRetValue;
    }

    lpStringW = ConvertAtoW( lpStringA );
    nCount = My_wcslen( lpStringW );

    if ( nCount >= nMaxCount )
        nCount = nMaxCount - 1;

    CopyMemory( lpString, lpStringW,  nCount * sizeof(WCHAR) );

    lpString[nCount] = 0x0000;

    iRetValue = nCount;

    LocalFreeAndNull( &lpStringA );
    LocalFreeAndNull( &lpStringW );

    return iRetValue;
}

// SetMenuItemInfo
BOOL WINAPI SetMenuItemInfoWrapW( HMENU hMenu,          
                                  UINT  uItem,           
                                  BOOL  fByPosition,     
                                  LPMENUITEMINFO lpmii  )
{

    BOOL             bRetValue;
    MENUITEMINFOA    miiA;

//    VALIDATE_PROTOTYPE(SetMenuItemInfo);
    
    if (g_bRunningOnNT)
        return SetMenuItemInfoW(hMenu, uItem, fByPosition, lpmii);

    // Bug 1723 WinSE: MFT_STRING is defined as 0. So lpmii->fType can never have MFT_STRING bit set
    //if ( ((lpmii->fMask & MIIM_TYPE) == 0 ) || ((lpmii->fType & MFT_STRING) == 0 ) )
    if ( ((lpmii->fMask & MIIM_TYPE) == 0 ) || lpmii->fType != MFT_STRING )
    {
        return SetMenuItemInfoA(hMenu, uItem, fByPosition, (MENUITEMINFOA *)lpmii );
    }

    CopyMemory(&miiA, lpmii, sizeof(MENUITEMINFOA) );

    miiA.cbSize = sizeof(MENUITEMINFOA);
    miiA.dwTypeData = ConvertWtoA( lpmii->dwTypeData );
    miiA.cch = lstrlenA( miiA.dwTypeData );

    bRetValue = SetMenuItemInfoA(hMenu, uItem, fByPosition, &miiA );

    LocalFreeAndNull( &miiA.dwTypeData );

    return bRetValue;
}

// PeekMessage
BOOL WINAPI PeekMessageWrapW( LPMSG lpMsg,          // pointer to structure for message
                              HWND  hWnd,           // handle to window
                              UINT  wMsgFilterMin,  // first message
                              UINT  wMsgFilterMax,  // last message
                              UINT  wRemoveMsg )   // removal flags
{

    VALIDATE_PROTOTYPE(PeekMessage);
    
    if (g_bRunningOnNT)
        return PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

    return PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

}

// run time loaded APIs in Comctl32.dll

extern LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA;
extern LPPROPERTYSHEET_A            gpfnPropertySheetA;
extern LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA;
extern LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW;
extern LPPROPERTYSHEET_W            gpfnPropertySheetW;
extern LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW;


HIMAGELIST  WINAPI gpfnImageList_LoadImageWrapW(HINSTANCE hi,
                                                LPCWSTR lpbmp,
                                                int cx,
                                                int cGrow,
                                                COLORREF crMask,
                                                UINT uType,
                                                UINT uFlags)
{

    WORD   rID;


    VALIDATE_PROTOTYPE( gpfnImageList_LoadImage );

    if (g_bRunningOnNT)
       return gpfnImageList_LoadImageW(hi, lpbmp, cx, cGrow, crMask, uType, uFlags) ;

    // in our case, all the calling functions pass resources ID to lpbmp, 
    // so we don't want to convert this arguement.

    rID = (WORD)lpbmp;

    return gpfnImageList_LoadImageA(hi,(LPCSTR)((DWORD_PTR)(rID)), cx, cGrow, crMask, uType, uFlags) ; 

}


INT_PTR     WINAPI gpfnPropertySheetWrapW(LPCPROPSHEETHEADERW lppsh)
{

    INT_PTR           iRetValue;
    PROPSHEETHEADERA  pshA;
    LPSTR             pszCaption = NULL;

    VALIDATE_PROTOTYPE( gpfnPropertySheet );

    if (g_bRunningOnNT)
       return gpfnPropertySheetW( lppsh );

    CopyMemory( &pshA, lppsh, sizeof( PROPSHEETHEADERA ) );
    pshA.dwSize = sizeof(PROPSHEETHEADERA);

    pszCaption = ConvertWtoA( lppsh->pszCaption );
    pshA.pszCaption = pszCaption;

    iRetValue = gpfnPropertySheetA( &pshA );

    LocalFreeAndNull( &pszCaption );

    return iRetValue;

}

HPROPSHEETPAGE WINAPI gpfnCreatePropertySheetPageWrapW(LPCPROPSHEETPAGEW lppsp) 
{

    PROPSHEETPAGEA  pspA;
    HPROPSHEETPAGE  hRetValue;
    LPSTR           lpTitle = NULL;


    VALIDATE_PROTOTYPE( gpfnCreatePropertySheetPage );

    if (g_bRunningOnNT)
       return gpfnCreatePropertySheetPageW( lppsp );

    
    CopyMemory( &pspA, lppsp, sizeof(PROPSHEETPAGEA) ); 
    pspA.dwSize = sizeof( PROPSHEETPAGEA );
    lpTitle = ConvertWtoA( lppsp->pszTitle );
    pspA.pszTitle  = lpTitle;
    hRetValue = gpfnCreatePropertySheetPageA( &pspA );
    LocalFreeAndNull( &lpTitle );
    return hRetValue; 
    
}

// APIs in Commdlg32.dll


extern BOOL (*pfnGetOpenFileNameA)(LPOPENFILENAMEA pof);
extern BOOL (*pfnGetOpenFileNameW)(LPOPENFILENAMEW pof);

BOOL  WINAPI  pfnGetOpenFileNameWrapW(LPOPENFILENAMEW lpOf) 
{

   BOOL           bRetValue;
   OPENFILENAMEA  ofA;
   LPSTR          lpstrFilterA = NULL;
   LPSTR          lpstrFilterA_T = NULL,lpstrFilterAA=NULL ;
   LPWSTR         lpstrFilterW = NULL;
   CHAR           lpstrFileA[MAX_PATH+1] ="";
   LPSTR          lpstrFileTitleA = NULL;
   LPSTR          lpstrTitleA = NULL;
   LPSTR          lpstrDefExtA= NULL;
   LPSTR          lpTemplateNameA = NULL;
   LPSTR          lpstrInitialDirA = NULL;
   
   LPWSTR         lpstrFileW = NULL;
   DWORD          dwLen;

   VALIDATE_PROTOTYPE(pfnGetOpenFileName);

   if (g_bRunningOnNT)
      return pfnGetOpenFileNameW( lpOf );

   
   CopyMemory( &ofA,  lpOf, sizeof( OPENFILENAMEA ) );

   ofA.lStructSize = sizeof( OPENFILENAMEA );

   if ( lpOf->lpTemplateName )  {
      lpTemplateNameA = ConvertWtoA( lpOf->lpTemplateName );
      ofA.lpTemplateName = lpTemplateNameA;
   } 
   else 
      ofA.lpTemplateName =  NULL;

   if ( lpOf->lpstrDefExt ) {
      lpstrDefExtA = ConvertWtoA( lpOf->lpstrDefExt );
      ofA.lpstrDefExt = lpstrDefExtA;
   }
   else
      ofA.lpstrDefExt = NULL;

   if ( lpOf->lpstrTitle )  {
      lpstrTitleA = ConvertWtoA( lpOf->lpstrTitle );
      ofA.lpstrTitle = lpstrTitleA;
   }
   else
       ofA.lpstrTitle = NULL;

   if ( lpOf->lpstrFileTitle ) {
      lpstrFileTitleA = ConvertWtoA( lpOf->lpstrFileTitle );
      ofA.lpstrFileTitle = lpstrFileTitleA;
   }
   else
       ofA.lpstrFileTitle = NULL;

   if ( lpOf->lpstrInitialDir ) {
      lpstrInitialDirA = ConvertWtoA( lpOf->lpstrInitialDir );
      ofA.lpstrInitialDir = lpstrInitialDirA;
   }
   else
       ofA.lpstrInitialDir = NULL;

   ofA.lpstrCustomFilter = NULL;

   // get the total length of lpOf->lpstrFilter       

   dwLen = 0;
   lpstrFilterW = (LPWSTR)(lpOf->lpstrFilter);

   while ( *lpstrFilterW != TEXT('\0') ) {
        dwLen += lstrlenW(lpstrFilterW) + 1;
        lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
   }

   dwLen += 1;  // for the last null terminator

   lpstrFilterW = (LPWSTR)( lpOf->lpstrFilter );
   lpstrFilterA = LocalAlloc( LMEM_ZEROINIT, dwLen * sizeof(WCHAR) );
   
   lpstrFilterA_T = lpstrFilterA;

   while ( *lpstrFilterW != TEXT('\0') ) { 
         lpstrFilterAA = ConvertWtoA(lpstrFilterW );
         lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
         strcpy(lpstrFilterA_T, lpstrFilterAA );
         LocalFreeAndNull( &lpstrFilterAA );
         lpstrFilterA_T += lstrlenA( lpstrFilterA_T ) + 1;
   }

   lpstrFilterA_T[lstrlenA(lpstrFilterA_T)+1] = '\0';


   ofA.lpstrFilter = lpstrFilterA;
   ofA.lpstrFile   = lpstrFileA;
   ofA.nMaxFile = MAX_PATH + 1;

   bRetValue = pfnGetOpenFileNameA( &ofA );

    LocalFreeAndNull( &lpTemplateNameA );

    LocalFreeAndNull( &lpstrDefExtA );


    LocalFreeAndNull( &lpstrTitleA );


    LocalFreeAndNull( &lpstrFileTitleA );


    LocalFreeAndNull( &lpstrInitialDirA );
  
  LocalFreeAndNull( &lpstrFilterA );

   if ( bRetValue != FALSE ) {
      lpstrFileW = ConvertAtoW( lpstrFileA );
      CopyMemory( lpOf->lpstrFile, lpstrFileW, (lstrlenW(lpstrFileW)+1) * sizeof( WCHAR) ); 
      LocalFreeAndNull( &lpstrFileW );
   }

   return bRetValue; 
      
}

extern BOOL (*pfnGetSaveFileNameA)(LPOPENFILENAMEA pof);
extern BOOL (*pfnGetSaveFileNameW)(LPOPENFILENAMEW pof);

BOOL  WINAPI  pfnGetSaveFileNameWrapW(LPOPENFILENAMEW lpOf) 
{

   BOOL           bRetValue;
   OPENFILENAMEA  ofA;
   LPSTR          lpstrFilterA = NULL;
   LPSTR          lpstrFilterA_T = NULL,lpstrFilterAA=NULL ;
   LPWSTR         lpstrFilterW = NULL;
   CHAR           lpstrFileA[MAX_PATH+1] ="";
   LPSTR          lpFileA = NULL;
   LPSTR          lpstrFileTitleA = NULL;
   LPSTR          lpstrTitleA = NULL;
   LPSTR          lpstrDefExtA= NULL;
   LPSTR          lpTemplateNameA = NULL;
   LPSTR          lpstrInitialDirA = NULL;
   
   LPWSTR         lpstrFileW = NULL;
   DWORD          dwLen;

   VALIDATE_PROTOTYPE(pfnGetOpenFileName);

   if (g_bRunningOnNT)
      return pfnGetSaveFileNameW( lpOf );

   
   CopyMemory( &ofA,  lpOf, sizeof( OPENFILENAMEA ) );

   ofA.lStructSize = sizeof( OPENFILENAMEA );

   if ( lpOf->lpTemplateName )  {
      lpTemplateNameA = ConvertWtoA( lpOf->lpTemplateName );
      ofA.lpTemplateName = lpTemplateNameA;
   } 
   else 
      ofA.lpTemplateName =  NULL;

   if ( lpOf->lpstrDefExt ) {
      lpstrDefExtA = ConvertWtoA( lpOf->lpstrDefExt );
      ofA.lpstrDefExt = lpstrDefExtA;
   }
   else
      ofA.lpstrDefExt = NULL;

   if ( lpOf->lpstrTitle )  {
      lpstrTitleA = ConvertWtoA( lpOf->lpstrTitle );
      ofA.lpstrTitle = lpstrTitleA;
   }
   else
       ofA.lpstrTitle = NULL;

   if ( lpOf->lpstrFileTitle ) {
      lpstrFileTitleA = ConvertWtoA( lpOf->lpstrFileTitle );
      ofA.lpstrFileTitle = lpstrFileTitleA;
   }
   else
       ofA.lpstrFileTitle = NULL;

   if ( lpOf->lpstrFile ) {
      lpFileA = ConvertWtoA( lpOf->lpstrFile );
      lstrcpyA(lpstrFileA, lpFileA);
      ofA.lpstrFile = lpstrFileA;
       ofA.nMaxFile = MAX_PATH + 1;
   }
   else
       ofA.lpstrFile = NULL;

   if ( lpOf->lpstrInitialDir ) {
      lpstrInitialDirA = ConvertWtoA( lpOf->lpstrInitialDir );
      ofA.lpstrInitialDir = lpstrInitialDirA;
   }
   else
       ofA.lpstrInitialDir = NULL;

   ofA.lpstrCustomFilter = NULL;

   // get the total length of lpOf->lpstrFilter       

   dwLen = 0;
   lpstrFilterW = (LPWSTR)(lpOf->lpstrFilter);

   while ( *lpstrFilterW != TEXT('\0') ) {
        dwLen += lstrlenW(lpstrFilterW) + 1;
        lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
   }

   dwLen += 1;  // for the last null terminator

   lpstrFilterW = (LPWSTR)( lpOf->lpstrFilter );
   lpstrFilterA = LocalAlloc( LMEM_ZEROINIT, dwLen * sizeof(WCHAR) );
   
   lpstrFilterA_T = lpstrFilterA;

   while ( *lpstrFilterW != TEXT('\0') ) { 
         lpstrFilterAA = ConvertWtoA(lpstrFilterW );
         lpstrFilterW += lstrlenW(lpstrFilterW) + 1;
         strcpy(lpstrFilterA_T, lpstrFilterAA );
         LocalFreeAndNull( &lpstrFilterAA );
         lpstrFilterA_T += lstrlenA( lpstrFilterA_T ) + 1;
   }

   lpstrFilterA_T[lstrlenA(lpstrFilterA_T)+1] = '\0';


   ofA.lpstrFilter = lpstrFilterA;

   bRetValue = pfnGetSaveFileNameA( &ofA );

  LocalFreeAndNull( &lpTemplateNameA );

  LocalFreeAndNull( &lpstrDefExtA );
   
  LocalFreeAndNull( &lpstrTitleA );
   
  LocalFreeAndNull( &lpstrFileTitleA );
   
  LocalFreeAndNull( &lpstrInitialDirA );
  
  LocalFreeAndNull( &lpstrFilterA );

  LocalFreeAndNull( &lpFileA );

   if ( bRetValue != FALSE ) {
      lpstrFileW = ConvertAtoW( lpstrFileA );
      CopyMemory( lpOf->lpstrFile, lpstrFileW, (lstrlenW(lpstrFileW)+1) * sizeof( WCHAR) ); 
      LocalFreeAndNull( &lpstrFileW );
   }

   return bRetValue; 
      
}

extern BOOL (*pfnPrintDlgA)(LPPRINTDLGA lppd);
extern BOOL (*pfnPrintDlgW)(LPPRINTDLGW lppd);

BOOL    WINAPI   pfnPrintDlgWrapW(LPPRINTDLGW lppd)
{

    BOOL        bRetValue;
    PRINTDLGA   pdA;

    VALIDATE_PROTOTYPE(pfnPrintDlg);

    if (g_bRunningOnNT)
      return pfnPrintDlgW( lppd );


    CopyMemory( &pdA, lppd, sizeof( PRINTDLGA ) );

    pdA.lStructSize = sizeof( PRINTDLGA );

    // Only lpPrintTemplateName and lpSetupTemplateName has STR type, 
    // but in our case, only IDD of Resources are passed to these two parameters.

    // so don't do conversion.

    pdA.lpPrintTemplateName = (LPCSTR)(lppd->lpPrintTemplateName);
    pdA.lpSetupTemplateName = (LPCSTR)(lppd->lpSetupTemplateName);

    bRetValue = pfnPrintDlgA ( &pdA );

    lppd->hDC = pdA.hDC;
    lppd->Flags = pdA.Flags;

    lppd->nFromPage = pdA.nFromPage;
    lppd->nToPage =  pdA.nToPage;
    lppd->nMinPage = pdA.nMinPage;
    lppd->nMaxPage = pdA.nMaxPage;
    
    lppd->nCopies = pdA.nCopies;

    return bRetValue;
}


extern HRESULT (*pfnPrintDlgExA)(LPPRINTDLGEXA lppdex);
extern HRESULT (*pfnPrintDlgExW)(LPPRINTDLGEXW lppdex);

HRESULT WINAPI   pfnPrintDlgExWrapW(LPPRINTDLGEXW lppdex)
{

    HRESULT      hRetValue;
    PRINTDLGEXA  pdexA;

    VALIDATE_PROTOTYPE(pfnPrintDlgEx);

    if (g_bRunningOnNT)
       return pfnPrintDlgExW( lppdex );


    CopyMemory( &pdexA, lppdex, sizeof( PRINTDLGEXA ) );

    pdexA.lStructSize = sizeof( PRINTDLGEXA );

    // Only lpPrintTemplateName and lpSetupTemplateName has STR type, 
    // but in our case, only IDD of Resources are passed to these two parameters.

    // so don't do conversion.

    hRetValue = pfnPrintDlgExA( &pdexA );

    lppdex->dwResultAction = pdexA.dwResultAction;
    lppdex->hDC = pdexA.hDC;

    lppdex->lpPageRanges = pdexA.lpPageRanges;
    lppdex->nCopies = pdexA.nCopies;
    lppdex->nMaxPage = pdexA.nMaxPage;

    lppdex->nMaxPageRanges = pdexA.nMaxPageRanges;
    lppdex->nMinPage = pdexA.nMinPage;

    lppdex->nPageRanges = pdexA.nPageRanges;
    lppdex->nPropertyPages = pdexA.nPropertyPages;

    lppdex->nStartPage = pdexA.nStartPage;

    return hRetValue;

}

// GetWindowTextLength
int WINAPI GetWindowTextLengthWrapW( HWND hWnd)
{
    VALIDATE_PROTOTYPE(GetWindowTextLength);

    if (g_bRunningOnNT)
        return GetWindowTextLengthW(hWnd);
    else
        return GetWindowTextLengthA(hWnd);

}


// GetFileVersionInfoSize
DWORD GetFileVersionInfoSizeWrapW( LPTSTR lptstrFilename, LPDWORD lpdwHandle )
{
    LPSTR lpFileA = NULL;
    DWORD dwRet = 0;

    VALIDATE_PROTOTYPE(GetFileVersionInfoSize);

    if (g_bRunningOnNT)
        return GetFileVersionInfoSizeW(lptstrFilename, lpdwHandle);

    lpFileA = ConvertWtoA(lptstrFilename);
    dwRet = GetFileVersionInfoSizeA(lpFileA, lpdwHandle);
    LocalFreeAndNull(&lpFileA);
    return dwRet;
}

// GetFileVersionInfo
BOOL GetFileVersionInfoWrapW( LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
    LPSTR lpFileA = NULL;
    BOOL bRet = FALSE;

    VALIDATE_PROTOTYPE(GetFileVersionInfo);

    if (g_bRunningOnNT)
        return GetFileVersionInfoW(lptstrFilename, dwHandle, dwLen, lpData);

    // Note this is assuming that the dwLen and dwHandle are the same as those returned by 
    // GetFileVersionInfoSize ..

    lpFileA = ConvertWtoA(lptstrFilename);
    bRet = GetFileVersionInfoA(lpFileA, dwHandle, dwLen, lpData);
    LocalFreeAndNull(&lpFileA);
    return bRet;
}

// VerQueryValue 
// This one assumes that pBlock etc are all returned by GetFileVersionInfo and GetFileVersionInfoSize etc
BOOL VerQueryValueWrapW( const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
{
    LPSTR lpBlockA = NULL;
    BOOL bRet = FALSE;

    VALIDATE_PROTOTYPE(GetFileVersionInfo);

    if (g_bRunningOnNT)
        return VerQueryValueW(pBlock, lpSubBlock, lplpBuffer, puLen);

    // Note this is assuming that the dwLen and dwHandle are the same as those returned by 
    // GetFileVersionInfoSize ..

    lpBlockA = ConvertWtoA(lpSubBlock);
    bRet = VerQueryValueA(pBlock, lpBlockA, lplpBuffer, puLen);
    LocalFreeAndNull(&lpBlockA);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\certs.c ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CERT.C
//
//  PURPOSE:  Certificate functions for WAB.
//
//  HISTORY:
//  96/09/23  vikramm Created.
//  96/11/14  markdu  BUG 10132 Updated to post-SDR CAPI.
//  96/11/14  markdu  BUG 10267 Remove static link to functions in advapi32.dll
//  96/11/14  markdu  BUG 10741 Call DeinitCryptoLib in DLL_PROCESS_DETACH
//            only, so don't bother ref counting.
//  96/11/20  markdu  Set a global flag if we fail to load the crypto library.
//            Then, check this flag before we try to load again, and if the flag
//            is set, skip the load.
//            Also, now we only zero the APIFCN arrays if the associated library
//            was just freed.
//  96/12/14  markdu  Clean up for code review.
//  96/12/19  markdu  Post- code review clean up.
//  96/12/20  markdu  Allow BuildCertSBinaryData to do MAPIAllocateMore
//            on a passed-in object instead of LocalAlloc if desired.
//  96/12/20  markdu  Move some strings into resource.
//  96/12/21  markdu  Added support for getting UNICODE strings from certs.
//  97/02/07  t-erikne  Updated to new CAPI functions and fixed bugs.
//  97/02/15  t-erikne  Moved trust from MAPI to PStore
//  97/07/02  t-erikne  Moved trust from PSTore to CTLs
//
//*******************************************************************

#include "_apipch.h"
#define _WIN32_OE 0x0501
#undef CHARFORMAT
#undef GetProp
#undef SetProp
#include <mimeole.h>
#define CHARFORMAT CHARFORMATW
#define GetProp GetPropW
#define SetProp SetPropW

// Global handles for Crypto  DLLs
HINSTANCE       ghCryptoDLLInst = NULL;
HINSTANCE       ghAdvApiDLLInst = NULL;
BOOL            gfPrevCryptoLoadFailed = FALSE;

// Name of cert stores
static const LPTSTR cszWABCertStore       = TEXT("AddressBook");
static const LPTSTR cszCACertStore        = TEXT("CA");
static const LPTSTR cszROOTCertStore      = TEXT("ROOT");

// Crypto function names
static const LPTSTR cszCryptoDLL                          = TEXT("CRYPT32.DLL");
static const LPTSTR cszAdvApiDLL                        = TEXT("ADVAPI32.DLL");
static const char cszCertAddEncodedCertificateToStore[]   =  "CertAddEncodedCertificateToStore";
static const char cszCertCreateCertificateContext[]       =  "CertCreateCertificateContext";
static const char cszCertDeleteCertificateFromStore[]     =  "CertDeleteCertificateFromStore";
static const char cszCertFindCertificateInStore[]         =  "CertFindCertificateInStore";
static const char cszCertFreeCertificateContext[]         =  "CertFreeCertificateContext";
static const char cszCertGetCertificateContextProperty[]  =  "CertGetCertificateContextProperty";
static const char cszCertGetIssuerCertificateFromStore[]  =  "CertGetIssuerCertificateFromStore";
static const char cszCertOpenSystemStore[]                =  "CertOpenSystemStoreW";
static const char cszCryptDecodeObject[]                  =  "CryptDecodeObject";
static const char cszCryptMsgClose[]                      =  "CryptMsgClose";
static const char cszCryptMsgGetParam[]                   =  "CryptMsgGetParam";
static const char cszCryptMsgOpenToDecode[]               =  "CryptMsgOpenToDecode";
static const char cszCryptMsgUpdate[]                     =  "CryptMsgUpdate";
static const char cszCertNameToStr[]                      =  "CertNameToStrW";
static const char cszCertFindRDNAttr[]                    =  "CertFindRDNAttr";
static const char cszCertEnumCertificatesInStore[]        =  "CertEnumCertificatesInStore";
static const char cszCertCompareCertificate[]             =  "CertCompareCertificate";
static const char cszCertRDNValueToStr[]                  =  "CertRDNValueToStrW";
static const char cszCertVerifyTimeValidity[]             =  "CertVerifyTimeValidity";

// Global function pointers for Crypto API
LPCERTADDENCODEDCERTIFICATETOSTORE  gpfnCertAddEncodedCertificateToStore  = NULL;
LPCERTCREATECERTIFICATECONTEXT      gpfnCertCreateCertificateContext      = NULL;
LPCERTDELETECERTIFICATEFROMSTORE    gpfnCertDeleteCertificateFromStore    = NULL;
LPCERTFINDCERTIFICATEINSTORE        gpfnCertFindCertificateInStore        = NULL;
LPCERTFREECERTIFICATECONTEXT        gpfnCertFreeCertificateContext        = NULL;
LPCERTGETCERTIFICATECONTEXTPROPERTY gpfnCertGetCertificateContextProperty = NULL;
LPCERTGETISSUERCERTIFICATEFROMSTORE gpfnCertGetIssuerCertificateFromStore = NULL;
LPCERTOPENSYSTEMSTORE               gpfnCertOpenSystemStore               = NULL;
LPCRYPTDECODEOBJECT                 gpfnCryptDecodeObject                 = NULL;
LPCERTNAMETOSTR                     gpfnCertNameToStr                     = NULL;
LPCRYPTMSGCLOSE                     gpfnCryptMsgClose                     = NULL;
LPCRYPTMSGGETPARAM                  gpfnCryptMsgGetParam                  = NULL;
LPCRYPTMSGOPENTODECODE              gpfnCryptMsgOpenToDecode              = NULL;
LPCRYPTMSGUPDATE                    gpfnCryptMsgUpdate                    = NULL;
LPCERTFINDRDNATTR                   gpfnCertFindRDNAttr                   = NULL;
LPCERTRDNVALUETOSTR                 gpfnCertRDNValueToStr                 = NULL;
LPCERTENUMCERTIFICATESINSTORE       gpfnCertEnumCertificatesInStore       = NULL;
LPCERTCOMPARECERTIFICATE            gpfnCertCompareCertificate            = NULL;
LPCERTVERIFYTIMEVALIDITY            gpfnCertVerifyTimeValidity            = NULL;

// API table for Crypto function addresses in crypt32.dll
// BUGBUG this global array should go away
#define NUM_CRYPT32_CRYPTOAPI_PROCS   19
APIFCN Crypt32CryptoAPIList[NUM_CRYPT32_CRYPTOAPI_PROCS] =
{
  { (PVOID *) &gpfnCertAddEncodedCertificateToStore,  cszCertAddEncodedCertificateToStore   },
  { (PVOID *) &gpfnCertCreateCertificateContext,      cszCertCreateCertificateContext       },
  { (PVOID *) &gpfnCertDeleteCertificateFromStore,    cszCertDeleteCertificateFromStore     },
  { (PVOID *) &gpfnCertFindCertificateInStore,        cszCertFindCertificateInStore         },
  { (PVOID *) &gpfnCertFreeCertificateContext,        cszCertFreeCertificateContext         },
  { (PVOID *) &gpfnCertGetCertificateContextProperty, cszCertGetCertificateContextProperty  },
  { (PVOID *) &gpfnCertGetIssuerCertificateFromStore, cszCertGetIssuerCertificateFromStore  },
  { (PVOID *) &gpfnCertOpenSystemStore,               cszCertOpenSystemStore                },
  { (PVOID *) &gpfnCryptDecodeObject,                 cszCryptDecodeObject                  },
  { (PVOID *) &gpfnCertNameToStr,                     cszCertNameToStr                      },
  { (PVOID *) &gpfnCryptMsgClose,                     cszCryptMsgClose                      },
  { (PVOID *) &gpfnCryptMsgGetParam,                  cszCryptMsgGetParam                   },
  { (PVOID *) &gpfnCryptMsgOpenToDecode,              cszCryptMsgOpenToDecode               },
  { (PVOID *) &gpfnCryptMsgUpdate,                    cszCryptMsgUpdate                     },
  { (PVOID *) &gpfnCertFindRDNAttr,                   cszCertFindRDNAttr                    },
  { (PVOID *) &gpfnCertRDNValueToStr,                 cszCertRDNValueToStr                  },
  { (PVOID *) &gpfnCertEnumCertificatesInStore,       cszCertEnumCertificatesInStore        },
  { (PVOID *) &gpfnCertCompareCertificate,            cszCertCompareCertificate             },
  { (PVOID *) &gpfnCertVerifyTimeValidity,            cszCertVerifyTimeValidity             },
};

// Local function prototypes
HRESULT OpenSysCertStore(
    HCERTSTORE* phcsSysCertStore,
    HCRYPTPROV* phCryptProvider,
    LPTSTR      lpszCertStore);

HRESULT CloseCertStore(
    HCERTSTORE hcsWABCertStore,
    HCRYPTPROV hCryptProvider);

HRESULT FileTimeToDateTimeString(
    IN  LPFILETIME   lpft,
    IN  LPTSTR FAR*  lplpszBuf);

HRESULT GetNameString(
    LPTSTR FAR * lplpszName,
    DWORD dwEncoding,
    PCERT_NAME_BLOB pNameBlob,
    DWORD dwType);

HRESULT GetIssuerName(
    LPTSTR FAR * lplpszIssuerName,
    PCERT_INFO pCertInfo);

HRESULT GetAttributeString(
    LPTSTR FAR * lplpszDisplayName,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    LPSTR lpszObjID);

HRESULT GetCertsDisplayInfoFromContext(
    HWND                hwndParent,
    PCCERT_CONTEXT      pccCertContext,
    LPCERT_DISPLAY_INFO lpCDI);

HRESULT ReadMessageFromFile(
    LPTSTR      lpszFileName,
    HCRYPTPROV  hCryptProvider,
    PBYTE*      ppbEncoded,
    PDWORD      pcbEncoded);

HRESULT WriteDERToFile(
    LPTSTR  lpszFileName,
    PBYTE   pbEncoded,
    DWORD   cbEncoded);

HRESULT GetCertThumbPrint(
    PCCERT_CONTEXT      pccCertContext,
    PCRYPT_DIGEST_BLOB  pblobCertThumbPrint);

HRESULT GetIssuerContextAndStore(
    PCCERT_CONTEXT      pccCertContext,
    PCCERT_CONTEXT*     ppccIssuerCertContext,
    HCRYPTPROV          hCryptProvider,
    HCERTSTORE*         phcsIssuerStore);

HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  BOOL                  fIsThumbprint,
  PCRYPT_DIGEST_BLOB    pPrint,
  BLOB *                pSymCaps,
  FILETIME              ftSigningTime,
  LPVOID                lpObject,
  LPBYTE FAR*           lplpbData,
  ULONG FAR*            lpcbData);

HRESULT IsCertExpired(
    PCERT_INFO            pCertInfo);

HRESULT IsCertRevoked(
    PCERT_INFO            pCertInfo);

HRESULT ReadDataFromFile(
    LPTSTR      lpszFileName,
    PBYTE*      ppbData,
    PDWORD      pcbData);

HRESULT HrGetTrustState(HWND hwndParent, PCCERT_CONTEXT pcCert, DWORD *pdwTrust);

LPTSTR SzConvertRDNString(PCERT_RDN_ATTR pRdnAttr);


/*  HrGetLastError
**
**  Purpose:
**      Convert a GetLastError value to an HRESULT
**      A failure HRESULT must have the high bit set.
**
**  Takes:
**      none
**
**  Returns:
**      HRESULT
*/
HRESULT HrGetLastError(void)
{
    DWORD error;
    HRESULT hr;

    error = GetLastError();

    if (error && ! (error & 0x80000000)) {
        hr = error | 0x80070000;    // system error
    } else {
        hr = (HRESULT)error;
    }

    return(hr);
}

//*******************************************************************
//
//  FUNCTION:   HrUserSMimeToCDI
//
//  PURPOSE:    Convert the data contained in a CMS message for the userSMimeCertificate
//              property and place into the display info structure.
//
//  PARAMETERS: pbIn - data bytes for the CMS message
//              cbIn - size of pbIn
//              lpCDI - structure to receive the cert data.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  98/10/23  jimsch  Created.
//
//*******************************************************************

HRESULT HrUserSMimeToCDI(LPBYTE pbIn, DWORD cbIn, LPCERT_DISPLAY_INFO lpCDI)
{
    DWORD                       cb;
    DWORD                       cbCert;
    DWORD                       cbMax;
    DWORD                       cbSMimeCaps;
    DWORD                       cCerts;
    CERT_INFO                   certInfo;
    DWORD                       cSigners;
    DWORD                       cval;
    DWORD                       dwDefaults;
    DWORD                       dwNortelAlg;
    BOOL                        f;
    BOOL                        fSMime = TRUE;
    HCRYPTMSG                   hmsg = NULL;
    HRESULT                     hr = S_OK;
    ULONG                       i;
    DWORD                       ival;
    PCRYPT_ATTRIBUTE            pattr;
    LPBYTE                      pbCert;
    LPBYTE                      pbData;
    LPBYTE                      pbSMimeCaps;
    PCCERT_CONTEXT              pccert;
    PCMSG_SIGNER_INFO           pinfo = NULL;
    PCRYPT_RECIPIENT_ID         prid = NULL;

    // Parse out and verify the signature on the message.  If that operation fails, then
    //  this is a bad record

    hmsg = CryptMsgOpenToDecode(PKCS_7_ASN_ENCODING, 0, 0, 0,
                                NULL, NULL);
    if (hmsg == 0) {
        goto CryptError;
    }

    if (!CryptMsgUpdate(hmsg, pbIn, cbIn, TRUE)) {
        goto CryptError;
    }

    cb = sizeof(cSigners);
    if (!CryptMsgGetParam(hmsg, CMSG_SIGNER_COUNT_PARAM, 0, &cSigners, &cb) ||
        (cSigners == 0)) {
        goto CryptError;
    }
    Assert(cSigners == 1);

    if (!CryptMsgGetParam(hmsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &cb)) {
        goto CryptError;
    }

    pinfo = (PCMSG_SIGNER_INFO) LocalAlloc(0, cb);
    if (!pinfo) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    f = CryptMsgGetParam(hmsg, CMSG_SIGNER_INFO_PARAM, 0, pinfo, &cb);
    Assert(f);

    // M00BUG -- verify signature on message

    for (i=0; i<pinfo->AuthAttrs.cAttr; i++) {
      pattr = &pinfo->AuthAttrs.rgAttr[i];
        if (strcmp(pattr->pszObjId, szOID_RSA_SMIMECapabilities) == 0) {
          Assert(pattr->cValue == 1);
          lpCDI->blobSymCaps.pBlobData = LocalAlloc(LMEM_ZEROINIT,
            pattr->rgValue[0].cbData);
          if (NULL == lpCDI->blobSymCaps.pBlobData)
          {
            hr = E_OUTOFMEMORY;
            goto Exit;
          }
          lpCDI->blobSymCaps.cbSize = pattr->rgValue[0].cbData;
          memcpy(lpCDI->blobSymCaps.pBlobData, pattr->rgValue[0].pbData,
            pattr->rgValue[0].cbData);
        }
//        else if (strcmp(pattr->pszObjId, szOID_Microsoft_Encryption_Cert) == 0) {
//          Assert(pattr->cValue == 1);
//          Assert(pattr->rgValue[0].cbData == 3);
//          lpCDI->bIsDefault = pattr->rgValue[0].pbData[2];
//        }
        else if (strcmp(pattr->pszObjId, szOID_Microsoft_Encryption_Cert) == 0) {
            Assert(pattr->cValue == 1);
            f = CryptDecodeObjectEx(X509_ASN_ENCODING,
              szOID_Microsoft_Encryption_Cert,
              pattr->rgValue[0].pbData,
              pattr->rgValue[0].cbData, CRYPT_DECODE_ALLOC_FLAG, 0,
              (LPVOID *) &prid, &cb);
            Assert(f);
        }
    }

    //

    if (prid == NULL)
        goto Exit;
    certInfo.SerialNumber = prid->SerialNumber;
    certInfo.Issuer = prid->Issuer;

    //  Enumerate all certs and pack into the structure

    cbCert = sizeof(cCerts);
    if (!CryptMsgGetParam(hmsg, CMSG_CERT_COUNT_PARAM, 0, &cCerts, &cbCert)) {
        goto CryptError;
    }

    for (i=0, cbMax = 0; i<cCerts; i++)
    {
      if (!CryptMsgGetParam(hmsg, CMSG_CERT_PARAM, i, NULL, &cbCert))
        goto CryptError;

      if (cbMax < cbCert)
        cbMax = cbCert;
    }


    pbCert = (LPBYTE) LocalAlloc(0, cbCert);
    for (i=0; i<cCerts; i++) {
        cbCert = cbMax;
        if (!CryptMsgGetParam(hmsg, CMSG_CERT_PARAM, i, pbCert, &cbCert))
            goto CryptError;

        pccert = gpfnCertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
        if (pccert == NULL)
            continue;

        if (CertCompareCertificate(X509_ASN_ENCODING, pccert->pCertInfo,
                                   &certInfo)) {
            lpCDI->pccert = CertDuplicateCertificateContext(pccert);
        }
    }


    hr = S_OK;

Exit:
    if (prid != NULL) LocalFree(prid);
    if (pinfo != NULL)  LocalFree(pinfo);
    if (hmsg != NULL)   CryptMsgClose(hmsg);
    return hr;

CryptError:
    hr = E_FAIL;
    goto Exit;
}

//*******************************************************************
//
//  FUNCTION:   HrGetCertsDisplayInfo
//
//  PURPOSE:    Takes an input array of certs in a SPropValue structure
//              and outputs a list of cert data structures by parsing through
//              the array and looking up the cert data in the store.
//
//  PARAMETERS: lpPropValue - PR_USER_X509_CERTIFICATE property array
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrGetCertsDisplayInfo(
  IN  HWND hwndParent,
  IN  LPSPropValue lpPropValue,
  OUT LPCERT_DISPLAY_INFO * lppCDI)
{
  CRYPT_HASH_BLOB     blob;
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;
  ULONG               i;
  ULONG               ulcCerts;
  LPCERTTAGS          lpCurrentTag;
  LPCERT_DISPLAY_INFO lpHead=NULL;
  LPCERT_DISPLAY_INFO lpTemp=NULL;
  HCERTSTORE          hcsWABCertStore = NULL;
  HCRYPTPROV          hCryptProvider = 0;
  LPBYTE              lpbTagEnd;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpPropValue, sizeof(SPropValue)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lppCDI, sizeof(LPCERT_DISPLAY_INFO)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Make sure we have the right kind of proparray.
  if ((NULL == lpPropValue) || (PR_USER_X509_CERTIFICATE != lpPropValue->ulPropTag))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  // See if we really have any certs
  ulcCerts = lpPropValue->Value.MVbin.cValues;
  if (0 == ulcCerts)
  {
    goto out;
  }

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Open the store since we need to lookup certs
  hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
  if (hrSuccess != hr)
  {
    goto out;
  }

  // Create a structure for each certificate in the array.
  for (i=0;i<ulcCerts;i++)
  {
    // Allocate memory for the structure, and initialize pointers
    LPCERT_DISPLAY_INFO lpCDI = LocalAlloc(LMEM_ZEROINIT, sizeof(CERT_DISPLAY_INFO));
    if (NULL == lpCDI)
    {
      hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
      goto out;
    }

    if(NULL == lpHead)
    {
      lpHead = lpCDI;
    }

    lpCDI->lpPrev = lpTemp;
    lpCDI->lpNext = NULL;
    if(NULL != lpTemp)
    {
      lpTemp->lpNext = lpCDI;
    }
    lpTemp = lpCDI;

    if (CERT_TAG_SMIMECERT == lpPropValue->Value.MVbin.lpbin[i].lpb[0]) {
        hr = HrUserSMimeToCDI(lpPropValue->Value.MVbin.lpbin[i].lpb,
                              lpPropValue->Value.MVbin.lpbin[i].cb,
                              lpCDI);
        if (FAILED(hr))
            goto out;
    }
    else
    {
    // Loop through the tags for this certificate and extract the data we want
    lpCurrentTag = (LPCERTTAGS)lpPropValue->Value.MVbin.lpbin[i].lpb;
    lpbTagEnd = (LPBYTE)lpCurrentTag + lpPropValue->Value.MVbin.lpbin[i].cb;
    while ((LPBYTE)lpCurrentTag < lpbTagEnd)
    {
      LPCERTTAGS lpTempTag = lpCurrentTag;

      // Check if this is the tag that indicates whether this is the default cert
      if (CERT_TAG_DEFAULT == lpCurrentTag->tag)
      {
        memcpy((void*)&lpCDI->bIsDefault,
          &lpCurrentTag->rgbData,
          sizeof(lpCDI->bIsDefault));
      }

      // Check if this is just the raw cert itself
      else if (CERT_TAG_BINCERT == lpCurrentTag->tag)
      {
        AssertSz(lpCDI->pccert == NULL, TEXT("Two certs in a single record"));
        lpCDI->pccert = gpfnCertCreateCertificateContext(
          X509_ASN_ENCODING,
          lpCurrentTag->rgbData,
          lpCurrentTag->cbData);
      }

      // Check if this is the tag that contains the thumbprint
      else if (CERT_TAG_THUMBPRINT == lpCurrentTag->tag)
      {
        AssertSz(lpCDI->pccert == NULL, TEXT("Two certs in a single record"));
        blob.cbData = lpCurrentTag->cbData - sizeof(DWORD);
        blob.pbData = lpCurrentTag->rgbData;

        // Get the certificate from the WAB store using the thumbprint
        lpCDI->pccert = CertFindCertificateInStore(
          hcsWABCertStore,
          X509_ASN_ENCODING,
          0,
          CERT_FIND_HASH,
          (void *)&blob,
          NULL);
      }

      // Check if this is the tag that contains the symcaps
      else if (CERT_TAG_SYMCAPS == lpCurrentTag->tag)
      {
        lpCDI->blobSymCaps.pBlobData = LocalAlloc(LMEM_ZEROINIT,
          lpCurrentTag->cbData - SIZE_CERTTAGS);
        if (NULL == lpCDI->blobSymCaps.pBlobData)
        {
          hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
          goto out;
        }

        lpCDI->blobSymCaps.cbSize = lpCurrentTag->cbData - SIZE_CERTTAGS;
        memcpy(lpCDI->blobSymCaps.pBlobData,
          &lpCurrentTag->rgbData,
          lpCurrentTag->cbData - SIZE_CERTTAGS);
      }

      // Check if this is the tag that contains the signing time
      else if (CERT_TAG_SIGNING_TIME == lpCurrentTag->tag)
      {
        memcpy(&lpCDI->ftSigningTime,
          &lpCurrentTag->rgbData,
          min(lpCurrentTag->cbData - SIZE_CERTTAGS, sizeof(FILETIME)));
      }

      lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + LcbAlignLcb(lpCurrentTag->cbData));
      if (lpCurrentTag == lpTempTag) {
          AssertSz(FALSE, TEXT("Bad CertTag in PR_USER_X509_CERTIFICATE\n"));
          break;        // Safety valve, prevent infinite loop if bad data
      }
    }
    }

    // If we can't get the cert, delete this node of the linked list.
    if (NULL == lpCDI->pccert)
    {
      if(lpHead == lpCDI)
      {
        lpHead = NULL;
      }

      lpTemp = lpCDI->lpPrev;
      if (NULL != lpTemp)
      {
        lpTemp->lpNext = NULL;
      }

      FreeCertdisplayinfo(lpCDI);
    }
    else
    {
      // Get the context-specific display info from the cert.
      hr = GetCertsDisplayInfoFromContext(hwndParent, lpCDI->pccert, lpCDI);
      if (hrSuccess != hr)
      {
        goto out;
      }
    }
  }

out:
  // Close the cert store.
  hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);

  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  if ((hrSuccess == hr) && (NULL != lppCDI))
  {
    *lppCDI = lpHead;
  }
  else
  {
    // Free the list of structures we allocated.
    while (NULL != lpHead)
    {
      lpTemp = lpHead->lpNext;
      FreeCertdisplayinfo(lpHead);
      lpHead = lpTemp;
    }
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrSetCertsFromDisplayInfo
//
//  PURPOSE:    Takes a linked list of cert data structures and outputs
//              an SPropValue array of PR_USER_X509_CERTIFICATE properties.
//
//  PARAMETERS: lpCDI - linked list of input structures to convert to
//              SPropValue array
//              lpulcPropCount - receives the number of SPropValue's returned
//              Note that this will always be one.
//              lppPropValue - receives a MAPI-allocated SPropValue structure
//              containing an X509_USER_CERTIFICATE property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrSetCertsFromDisplayInfo(
  IN  LPCERT_ITEM lpCItem,
  OUT ULONG * lpulcPropCount,
  OUT LPSPropValue * lppPropValue)
{
  CRYPT_DIGEST_BLOB   blob;
  HRESULT             hr = hrSuccess;
  HCERTSTORE          hcertstore = NULL;
  LPCERT_ITEM         lpTemp;
  LPSPropValue        lpPropValue = NULL;
  ULONG               ulcCerts = 0;
  ULONG               ulCert = 0;
  ULONG               cbData = 0;
  LPBYTE              lpbData;
  SCODE               sc;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpCItem, sizeof(CERT_ITEM)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lpulcPropCount, sizeof(ULONG)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lppPropValue, sizeof(LPSPropValue)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Find out how many certs there are in the list
  lpTemp = lpCItem;
  while (NULL != lpTemp)
  {
    ulcCerts++;
    lpTemp = lpTemp->lpNext;
  }
  Assert(ulcCerts);

  // Allocate a new buffer for the MAPI property structure
  sc = MAPIAllocateBuffer(sizeof(SPropValue),
    (LPVOID *)&lpPropValue);
  if (sc)
  {
    hr = ResultFromScode(sc);
    goto out;
  }
  lpPropValue->ulPropTag = PR_USER_X509_CERTIFICATE;
  lpPropValue->dwAlignPad = 0;

  // Allocate more space for the SBinaryArray.  We need SBinary's for
  // each of the certs
  lpPropValue->Value.MVbin.cValues = ulcCerts;
  sc = MAPIAllocateMore(ulcCerts * sizeof(SBinary), lpPropValue,
    (LPVOID *)&(lpPropValue->Value.MVbin.lpbin));
  if (sc)
  {
    hr = ResultFromScode(sc);
    goto out;
  }

  hr = OpenSysCertStore(&hcertstore, NULL, cszWABCertStore);
  if (hrSuccess != hr)
    goto out;

  // Create the SPropValue entries by walking the list
  while (NULL != lpCItem)
  {
    hr = GetCertThumbPrint(lpCItem->lpCDI->pccert, &blob);
    if (hr != hrSuccess)
      goto out;

    if (!CertAddCertificateContextToStore(hcertstore, lpCItem->lpCDI->pccert,
                                          CERT_STORE_ADD_USE_EXISTING, NULL))
    {
        hr = E_FAIL;
        goto out;
    }

    // Pack up all the cert data and stuff it in the property
    hr = HrBuildCertSBinaryData(
      lpCItem->lpCDI->bIsDefault,
      TRUE,
      (PCRYPT_DIGEST_BLOB ) &blob,
      (BLOB * ) &(lpCItem->lpCDI->blobSymCaps),
      lpCItem->lpCDI->ftSigningTime,
      lpPropValue,
      (LPBYTE FAR*) &(lpPropValue->Value.MVbin.lpbin[ulCert].lpb),
      (ULONG FAR* ) &(lpPropValue->Value.MVbin.lpbin[ulCert].cb));

    LocalFree(blob.pbData);
    if (hrSuccess != hr)
    {
      goto out;
    }

    // Next certificate
    ulCert++;
    lpCItem = lpCItem->lpNext;
  }

out:
  if (hcertstore != NULL)       
    CloseCertStore(hcertstore, 0);
  if ((hrSuccess == hr) && (NULL != lppPropValue) && (NULL != lpulcPropCount))
  {
    *lppPropValue = lpPropValue;
    *lpulcPropCount = 1;
  }
  else
  {
    // Free the list of structures we allocated.
    MAPIFreeBuffer(lpPropValue);
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrImportCertFromFile
//
//  PURPOSE:    Import a cert from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the cert.
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrImportCertFromFile(
  IN  LPTSTR  lpszFileName,
  OUT LPCERT_DISPLAY_INFO * lppCDI)
{
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;
  HCERTSTORE          hcsWABCertStore = NULL;
  HCRYPTPROV          hCryptProvider = 0;
  PCCERT_CONTEXT      pccCertContext = NULL;
  LPCERT_DISPLAY_INFO lpCDI=NULL;
  BYTE*               pbEncoded = NULL;
  DWORD               cbEncoded = 0;
  BOOL                fRet;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpszFileName, sizeof(TCHAR)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
  if (IsBadWritePtr(lppCDI, sizeof(CERT_DISPLAY_INFO)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Open the store
  hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
  if (hrSuccess != hr)
  {
    DebugTrace(TEXT("OpenSysCertStore -> 0x%08x\n"), GetScode(hr));
    goto out;
  }

  // Import the cert into a CERT_CONTEXT structure
#ifndef WIN16
  hr = ReadMessageFromFile(
    lpszFileName,
    hCryptProvider,
    &pbEncoded,
    &cbEncoded);
#else  // !WIN16
  hr = ReadMessageFromFile(
    lpszFileName,
    hCryptProvider,
    (PBYTE *)&pbEncoded,
    (PDWORD)&cbEncoded);
#endif // !WIN16
  if (hrSuccess != hr)
  {
    // Try reading it as just a DER encoded blob
#ifndef WIN16
    hr = ReadDataFromFile(
      lpszFileName,
      &pbEncoded,
      &cbEncoded);
#else  // !WIN16
    hr = ReadDataFromFile(
      lpszFileName,
      (PBYTE *)&pbEncoded,
      (PDWORD)&cbEncoded);
#endif // !WIN16
    if (hrSuccess != hr)
    {
      goto out;
    }
  }

  // Add the cert to the store
  fRet = gpfnCertAddEncodedCertificateToStore(
    hcsWABCertStore,
    X509_ASN_ENCODING,
    pbEncoded,
    cbEncoded,
    CERT_STORE_ADD_USE_EXISTING,
    &pccCertContext);
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    DebugTrace(TEXT("CertAddEncodedCertificateToStore -> 0x%08x\n"), GetScode(hr));
    goto out;
  }

  // Allocate memory for the structure, and initialize pointers
  // Since we read only one cert, there are no more entries in the linked list
  lpCDI = LocalAlloc(LMEM_ZEROINIT, sizeof(CERT_DISPLAY_INFO));
  if (NULL == lpCDI)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }
  lpCDI->lpNext = NULL;
  lpCDI->lpPrev = NULL;

  // Fill in the defaults for info we don't know
  lpCDI->bIsDefault = FALSE;

  // Get the certificate
  lpCDI->pccert = CertDuplicateCertificateContext(pccCertContext);

  // Get the context-specific display info from the cert.
  hr = GetCertsDisplayInfoFromContext(GetDesktopWindow(), pccCertContext, lpCDI);
  if (hrSuccess != hr)
  {
    DebugTrace(TEXT("GetCertsDisplayInfoFromContext -> 0x%08x\n"), GetScode(hr));
    goto out;
  }

out:
  // Free the cert context.  Ignore errors since there is nothing we can do.
  if (NULL != pccCertContext)
  {
    gpfnCertFreeCertificateContext(pccCertContext);
  }

  // Close the cert store if we were able to free the cert context.
  if (hrSuccess == hrOut)
  {
    hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);
  }

  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  if ((hrSuccess == hr) && (NULL != lppCDI))
  {
    *lppCDI = lpCDI;
  }
  else
  {
    LocalFreeAndNull(&lpCDI);
  }

  LocalFreeAndNull(&pbEncoded);

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrExportCertToFile
//
//  PURPOSE:    Export a cert to a file.
//
//  PARAMETERS: lpszFileName - name of file in which to store the cert.
//              If the file exists, it will be overwritten, so the caller
//              must verify that this is OK first if so desired.
//              pblobCertThumbPrint - thumb print of certificate to export.
//              lpCertDataBuffer - needs to be freed by caller, data is 
//              filled here when flag is true.
//              lpcbBufLen - how long the buffer is
//              fWriteDataToBuffer - flag indicating where to write data
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//  98/07/22  t-jstaj updated to take 3 add'l parameters, a data buffer, its length 
//                    and flag which will indicate whether or not to 
//                    write data to buffer or file.  The memory allocated to 
//                    to the buffer needs to be freed by caller.
//
//
//*******************************************************************

HRESULT HrExportCertToFile(
  IN  LPTSTR  lpszFileName,
  IN  PCCERT_CONTEXT pccert,
  OUT LPBYTE *lppCertDataBuffer,
  OUT PULONG  lpcbBufLen,
  IN  BOOL    fWriteDataToBuffer)
{
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;

#ifdef  PARAMETER_VALIDATION
  if( !fWriteDataToBuffer )
  {  
      if (IsBadReadPtr(lpszFileName, sizeof(TCHAR)))
      {
          return ResultFromScode(MAPI_E_INVALID_PARAMETER);
      }
  }
  if (IsBadReadPtr(pccert, sizeof(*pccert)))
  {
      return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Export the cert to the file
  if( !fWriteDataToBuffer )
  {
      hr = WriteDERToFile(
          lpszFileName,
          (PBYTE)pccert->pbCertEncoded,
          pccert->cbCertEncoded);
      if (hrSuccess != hr)
      {
          goto out;
      }
  }
// write cert to buffer
  else
  {
      *lppCertDataBuffer = LocalAlloc( LMEM_ZEROINIT, /*sizeof( BYTE ) **/ pccert->cbCertEncoded);
      if( *lppCertDataBuffer )
        CopyMemory( *lppCertDataBuffer, pccert->pbCertEncoded, pccert->cbCertEncoded);
      else
      {
          hr = MAPI_E_NOT_ENOUGH_MEMORY;
          goto out;
      }
      *lpcbBufLen = pccert->cbCertEncoded;
  }
out:
  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   FreeCertdisplayinfo
//
//  PURPOSE:    Release memory allocated for a CERT_DISPLAY_INFO structure.
//              Assumes all info in the structure was LocalAlloced
//
//  PARAMETERS: lpCDI - structure to free.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

void FreeCertdisplayinfo(LPCERT_DISPLAY_INFO lpCDI)
{
    if (lpCDI)
    {
        if (lpCDI->lpszDisplayString != lpCDI->lpszEmailAddress)
        {
            LocalFreeAndNull(&lpCDI->lpszDisplayString);
        }
        if (lpCDI->pccert != NULL)
        {
          CertFreeCertificateContext(lpCDI->pccert);
          lpCDI->pccert = NULL;
        }
        LocalFreeAndNull(&lpCDI->lpszEmailAddress);
        LocalFreeAndNull(&lpCDI->blobSymCaps.pBlobData);
        LocalFreeAndNull(&lpCDI);
    }
}


//*******************************************************************
//
//  FUNCTION:   InitCryptoLib
//
//  PURPOSE:    Load the Crypto API libray and get the proc addrs.
//
//  PARAMETERS: None.
//
//  RETURNS:    TRUE if successful, FALSE otherwise.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just use the global
//            library handles.
//
//*******************************************************************

BOOL InitCryptoLib(void)
{

#ifndef WIN16 // Disable until we get crypt16.dll
  // See if we already tried to load and failed.
  if (TRUE == gfPrevCryptoLoadFailed)
  {
    return FALSE;
  }

  // See if we already initialized.
  if ((NULL == ghCryptoDLLInst) && (NULL == ghAdvApiDLLInst))
  {
    // open Crypto API library
    ghCryptoDLLInst = LoadLibrary(cszCryptoDLL);
    if (!ghCryptoDLLInst)
    {
      DebugTrace(TEXT("InitCryptoLib: Failed to LoadLibrary CRYPT32.DLL.\n"));
      goto error;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghCryptoDLLInst,Crypt32CryptoAPIList,NUM_CRYPT32_CRYPTOAPI_PROCS))
    {
      DebugTrace(TEXT("InitCryptoLib: Failed to load Crypto API from CRYPT32.DLL.\n"));
      goto error;
    }

    // open AdvApi32 library
    ghAdvApiDLLInst = LoadLibrary(cszAdvApiDLL);
    if (!ghAdvApiDLLInst)
    {
      DebugTrace(TEXT("InitCryptoLib: Failed to LoadLibrary ADVAPI32.DLL.\n"));
      goto error;
    }
  }

  // Make sure both libraries are loaded
  if ((NULL != ghCryptoDLLInst) && (NULL != ghAdvApiDLLInst))
  {
    return TRUE;
  }


error:
  // Unload the libraries we just loaded and indicate that we should not try to
  // load again this session.
  gfPrevCryptoLoadFailed = TRUE;
  DeinitCryptoLib();
#endif // !WIN16

  return FALSE;
}


//*******************************************************************
//
//  FUNCTION:   DeinitCryptoLib
//
//  PURPOSE:    Release the Crypto API libraries.
//
//  PARAMETERS: None.
//
//  RETURNS:    None.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just call this in
//            DLL_PROCESS_DETACH.
//
//*******************************************************************

void DeinitCryptoLib(void)
{
  UINT nIndex;

  // No clients using the Crypto API library.  Release it.
  if (ghCryptoDLLInst)
  {
    FreeLibrary(ghCryptoDLLInst);
    ghCryptoDLLInst = NULL;

    // cycle through the API table and NULL proc addresses for all the APIs
    for (nIndex = 0; nIndex < NUM_CRYPT32_CRYPTOAPI_PROCS; nIndex++)
    {
      *Crypt32CryptoAPIList[nIndex].ppFcnPtr = NULL;
    }
  }

  // Now releaes the crypto functions in advapi32.dll
  if (ghAdvApiDLLInst)
  {
    FreeLibrary(ghAdvApiDLLInst);
    ghAdvApiDLLInst = NULL;
  }

  return;
}


//*******************************************************************
//
//  FUNCTION:   FileTimeToDateTimeString
//
//  PURPOSE:    Convert a filetime structure to displayable text.
//
//  PARAMETERS: lpft - FILETIME to convert to a string
//              lplpszBuf - receives buffer to hold the string
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/10/02  markdu  Copied from shdocvw code
//  96/12/16  markdu  Made more robust, and LocalAlloc the buffer here
//
//*******************************************************************

HRESULT FileTimeToDateTimeString(
  IN  LPFILETIME   lpft,
  IN  LPTSTR FAR*  lplpszBuf)
{
  HRESULT hr = hrSuccess;
  SYSTEMTIME st;
  LPTSTR     szBuf;
  int cbBuf = 0;
  int cb = 0;

  FileTimeToLocalFileTime(lpft, lpft);
  FileTimeToSystemTime(lpft, &st);

  // Figure out how much space we need, then allocate 2 times that just
  // in case it's DBCS.
  cbBuf += GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, NULL, 0);
  cbBuf += GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, NULL, 0);
  cbBuf *= 2;

  szBuf = LocalAlloc(LMEM_ZEROINIT, cbBuf);
  if (NULL == szBuf)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }
  *lplpszBuf = szBuf;

  // First fill in the date portion.
  GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, szBuf, cbBuf);
  cb = lstrlen(szBuf);
  szBuf += cb;
  cbBuf -= cb;

  // Separate the time and date with a space. and null terminate this
  // (in case GetTimeFormat doesn't add anything).
  *szBuf = TEXT(' ');
  szBuf = CharNext(szBuf);
  *szBuf = TEXT('\0');
  cbBuf-=2;

  GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, szBuf, cbBuf);

out:
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   OpenSysCertStore
//
//  PURPOSE:    Open the specified system cert store.
//
//  PARAMETERS: phcsSysCertStore - receives handle to the cert store
//              phCryptProvider - If this points to a valid handle,
//              this handle is used as the provider to open the store.
//              otherwise, it receives a handle to the store provider
//              lpszCertStore - name of the store to open
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/03  markdu  Created.
//
//*******************************************************************

HRESULT OpenSysCertStore(
  HCERTSTORE* phcsSysCertStore,
  HCRYPTPROV* phCryptProvider,
  LPTSTR      lpszCertStore)
{
  HRESULT hr = hrSuccess;
  BOOL    fRet;
  BOOL    fWeAcquiredContext = FALSE;

  if (phCryptProvider != NULL)
  {
    // Get a handle to the crypto provider if we need one
    if (0 == *phCryptProvider)
    {
      fRet = CryptAcquireContextWrapW(
        phCryptProvider,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT);
      if (FALSE == fRet)
      {
        hr = HrGetLastError();
        goto out;
      }
      fWeAcquiredContext = TRUE;
    }
  }

  // Open the store
  *phcsSysCertStore = gpfnCertOpenSystemStore(
    ((phCryptProvider == NULL) ? (HCRYPTPROV) NULL : (*phCryptProvider)),
    lpszCertStore);
  if (NULL == *phcsSysCertStore)
  {
    hr = HrGetLastError();

    // Release the crypto provider if we were unable to open the store.
    if (TRUE == fWeAcquiredContext)
    {
      CryptReleaseContext(*phCryptProvider, 0);
      *phCryptProvider = 0;
    }

    goto out;
  }

out:
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   CloseCertStore
//
//  PURPOSE:    Close the specified cert store.
//
//  PARAMETERS: hcsCertStore - handle to the cert store
//              hCryptProvider - handle to the store provider.  The
//              provider will be closed as well, unless 0 is passed.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/03  markdu  Created.
//
//*******************************************************************

HRESULT CloseCertStore(
  HCERTSTORE hcsCertStore,
  HCRYPTPROV hCryptProvider)
{
  HRESULT hr = hrSuccess;
  BOOL    fRet;

  if (NULL != hcsCertStore)
  {
    fRet = CertCloseStore(hcsCertStore, 0);
    if (FALSE == fRet)
    {
      hr = HrGetLastError();
    }
  }

  // Release the crypto provider if we were able to close the store.
  if ((0 != hCryptProvider) && (hrSuccess == hr))
  {
    fRet = CryptReleaseContext(hCryptProvider, 0);
    if (FALSE == fRet)
    {
      hr = HrGetLastError();
    }
  }

  return hr;
}

//*******************************************************************
//
//  FUNCTION:   GetNameString
//
//  PURPOSE:    Get the string associated with the given attribute
//
//  PARAMETERS: lplpszName - pointer that will be
//                  allocated to hold the string
//              dwEncoding - certificate's encoding
//              pNameBlob - the encoded blob
//              dwType    - type of string, e.g. CERT_SIMPLE_NAME_STR
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  97/02/03  t-erikne  Copied and revamped from GetAttributeString
//  96/10/03  markdu    Created.
//
//*******************************************************************
HRESULT GetNameString(
  LPTSTR FAR * lplpszName,
  DWORD dwEncoding,
  PCERT_NAME_BLOB pNameBlob,
  DWORD dwType)
{
  DWORD     cch;
  HRESULT   hr = hrSuccess;

  Assert(lplpszName && pNameBlob);

  // Initialize so we know if any data was copied in.
  *lplpszName = NULL;

  cch = gpfnCertNameToStr(
    dwEncoding,                 // indicates X509 encoding
    pNameBlob,                  // name_blob to decode
    dwType,                     // style for output
    NULL,                       // NULL used when just getting length
    0);                         // length of buffer

  *lplpszName = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cch);
  if (NULL == lplpszName)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }

  gpfnCertNameToStr(dwEncoding, pNameBlob,
      dwType, *lplpszName, cch);

out:
  return hr;
}

//*******************************************************************
//
//  FUNCTION:   GetAttributeString
//
//  PURPOSE:    Get the string associated with the given attribute
//              by parsing through the relative
//              distinguished names in the object.
//
//  PARAMETERS: lplpszAttributeString - pointer that will be allocated to
//                hold the string
//              pbEncoded - the encoded blob
//              cbEncoded - size of the encoded blob
//              lpszObjID - object ID of attribute to retrieve
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/03  markdu  Created.
//
//*******************************************************************

HRESULT GetAttributeString(
  LPTSTR FAR * lplpszAttributeString,
  BYTE *pbEncoded,
  DWORD cbEncoded,
  LPSTR lpszObjID)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;
  PCERT_RDN_ATTR      pRdnAttr;
  PCERT_NAME_INFO     pNameInfo = NULL;
  DWORD               cbInfo;
  DWORD               cbData;  //N need both?

  // Initialize so we know if any data was copied in.
  *lplpszAttributeString = NULL;

  // Get the size of the subject name data
  cbInfo = 0;
  gpfnCryptDecodeObject(
    X509_ASN_ENCODING,    // indicates X509 encoding
    (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
    pbEncoded,            // pointer to a buffer holding the encoded name
    cbEncoded,            // length in bytes of the encoded name
    //N maybe can use nocopy flag
    0,                    // flags
    NULL,                 // NULL used when just geting length
    &cbInfo);             // length in bytes of the decoded name
  if (0 == cbInfo)
  {
    hr = HrGetLastError();
    goto out;
  }

  // Allocate space for the decoded name
  pNameInfo = (PCERT_NAME_INFO) LocalAlloc(LMEM_ZEROINIT, cbInfo);
  if (NULL == pNameInfo)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }

  // Get the subject name
  fRet = gpfnCryptDecodeObject(
    X509_ASN_ENCODING,    // indicates X509 encoding
    (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
    pbEncoded,            // pointer to a buffer holding the encoded name
    cbEncoded,            // length in bytes of the encoded name
    0,                    // flags
    pNameInfo,            // the buffer where the decoded name is written to
    &cbInfo);             // length in bytes of the decoded name
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    goto out;
  }

  // Now we have a decoded name RDN array, so find the oid we want
  pRdnAttr = gpfnCertFindRDNAttr(lpszObjID, pNameInfo);

  if (!pRdnAttr)
    {
    hr = MAPI_E_NOT_FOUND;
    goto out;
    }

   *lplpszAttributeString = SzConvertRDNString(pRdnAttr);

out:
  if (NULL != pNameInfo)
  {
    LocalFreeAndNull(&pNameInfo);
  }
  return hr;
}


//*******************************************************************
//
//  FUNCTION:   GetCertThumbPrint
//
//  PURPOSE:    Gets the thumbprint of the cert.
//
//  PARAMETERS: pccCertContext - cert whose thumbprint to get
//              pblobCertThumbPrint - receives thumb print
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/13  markdu  Created.
//
//*******************************************************************

HRESULT GetCertThumbPrint(
  PCCERT_CONTEXT      pccCertContext,
  PCRYPT_DIGEST_BLOB  pblobCertThumbPrint)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;

  // Get the size of the thumbprint data
  pblobCertThumbPrint->cbData = 0;
  fRet = gpfnCertGetCertificateContextProperty(
    pccCertContext,
    CERT_HASH_PROP_ID,
    NULL,
    &pblobCertThumbPrint->cbData);
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    goto out;
  }

  // Allocate memory for the thumbprint data
  pblobCertThumbPrint->pbData = LocalAlloc(LMEM_ZEROINIT,
    pblobCertThumbPrint->cbData);
  if (NULL == pblobCertThumbPrint->pbData)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto out;
  }

  // Get the thumbprint
  fRet = gpfnCertGetCertificateContextProperty(
    pccCertContext,
    CERT_HASH_PROP_ID,
    pblobCertThumbPrint->pbData,
    &pblobCertThumbPrint->cbData);
  if (FALSE == fRet)
  {
    hr = HrGetLastError();
    goto out;
  }

out:
  return hr;
}


/*  SzConvertRDNString
**
**  Purpose:
**      Figure out what kind of string data is in the RDN, allocate
**      a buffer and convert the string data to DBCS/ANSI.
**
**  Takes:
**      IN pRdnAttr - Certificate RDN atteribute
**  Returns:
**      A LocalAlloc'd buffer containing the string.
*/
LPTSTR SzConvertRDNString(PCERT_RDN_ATTR pRdnAttr) {
    LPTSTR szRet = NULL;
    ULONG cbData = 0;

    // We only handle certain types
    //N look to see if we should have a stack var for the ->
    if ((CERT_RDN_NUMERIC_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_PRINTABLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_IA5_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_VISIBLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_ISO646_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNIVERSAL_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_TELETEX_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNICODE_STRING != pRdnAttr->dwValueType)) {
        Assert((CERT_RDN_NUMERIC_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_PRINTABLE_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_IA5_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_VISIBLE_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_ISO646_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_UNIVERSAL_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_TELETEX_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_UNICODE_STRING == pRdnAttr->dwValueType));
        return(NULL);
    }

    // Find out how much space to allocate.

    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            cbData = WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              NULL,
              0,
              NULL,
              NULL);
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            cbData = gpfnCertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              NULL,
              0);
            break;

        default:
            cbData = pRdnAttr->Value.cbData + 1;
        break;
    }

    // Allocate the space for the string.
    if (! (szRet = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cbData))) {
        Assert(szRet);
        return(NULL);
    }

    // Copy the string
    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            StrCpyN(szRet, (LPWSTR)pRdnAttr->Value.pbData, cbData);
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            gpfnCertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              szRet,
              cbData);
            break;

        default:
            ScAnsiToWCMore(NULL, NULL, pRdnAttr->Value.pbData, &szRet);
            szRet[cbData - 1] = '\0';
            break;
    }
    return(szRet);
}


/*  PVDecodeObject:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to decode an
**      object.  Give it a thing to get and it will alloc the mem.
**  Takes:
**      IN pbEncoded        - encoded data
**      IN cbEncoded        - size of data in pbData
**      IN item             - X509_* ... the thing to get
**      OUT OPTIONAL cbOut  - (def value of NULL) size of the return
**  Notes:
**      pbEncoded can't be freed until return is freed.
**  Returns:
**      data that was obtained, NULL if failed.  Caller must LocalFree buffer.
*/
LPVOID PVDecodeObject(
    BYTE   *pbEncoded,
    DWORD   cbEncoded,
    LPCSTR  item,
    DWORD  *cbOut)
{
    DWORD cbData;
    void *pvData = NULL;

    if (!(pbEncoded && cbEncoded))
        {
        SetLastError((DWORD)E_INVALIDARG);
        goto ErrorReturn;
        }

    cbData = 0;
    gpfnCryptDecodeObject(
        X509_ASN_ENCODING,    // indicates X509 encoding
        item,                 // flag indicating type to be decoded
        pbEncoded,            // pointer to a buffer holding the encoded data
        cbEncoded,            // length in bytes of the encoded data
        CRYPT_DECODE_NOCOPY_FLAG,
        NULL,                 // NULL used when just geting length
        &cbData);             // length in bytes of the decoded data

    if (!cbData || ! (pvData = LocalAlloc(LPTR, cbData))) {
        goto ErrorReturn;
    }

    if (!gpfnCryptDecodeObject(
        X509_ASN_ENCODING,    // indicates X509 encoding
        item,                 // flag indicating type is to be decoded
        pbEncoded,            // pointer to a buffer holding the encoded data
        cbEncoded,            // length in bytes of the encoded name
        CRYPT_DECODE_NOCOPY_FLAG,
        pvData,               // out buffer
        &cbData))             // length in bytes of the decoded data
        goto ErrorReturn;

exit:
    if (cbOut)
        *cbOut = cbData;
    return pvData;

ErrorReturn:
    if (pvData)
        {
        IF_WIN32(LocalFree(pvData);)
        IF_WIN16(LocalFree((HLOCAL)pvData);)
        pvData = NULL;
        }
    cbData = 0;
    goto exit;
}


/*  SzGetAltNameEmail:
**
**  Input:
**      pCert -> certificate context
**      lpszOID -> OID or predefined id of alt name to look in.  ie, OID_SUBJECT_ALT_NAME or
**        X509_ALTERNATE_NAME.
**
**  Returns:
**      Buffer containing email name or NULL if not found.
**      Caller must LocalFree the buffer.
*/
LPTSTR SzGetAltNameEmail(
  const PCCERT_CONTEXT pCert,
  LPSTR lpszOID) {
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    PCERT_ALT_NAME_ENTRY pAltNameEntry = NULL;
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;
    ULONG i, j, cbData;
    LPSTR szRet = NULL;
    LPTSTR sz = NULL;


    if (lpszOID == (LPCSTR)X509_ALTERNATE_NAME) {
        lpszOID = szOID_SUBJECT_ALT_NAME;
    }

    for (i = 0; i < pCertInfo->cExtension; i++) 
    {
        if (! lstrcmpA(pCertInfo->rgExtension[i].pszObjId, lpszOID)) 
        {
            // Found the OID.  Look for the email tag

            if (pAltNameInfo = (PCERT_ALT_NAME_INFO)PVDecodeObject(   pCertInfo->rgExtension[i].Value.pbData,
                                                                      pCertInfo->rgExtension[i].Value.cbData,
                                                                      lpszOID,
                                                                      NULL)) 
            {
                // Cycle through the alt name entries
                for (j = 0; j < pAltNameInfo->cAltEntry; j++) 
                {
                    if (pAltNameEntry = &pAltNameInfo->rgAltEntry[j]) 
                    {
                        if (pAltNameEntry->dwAltNameChoice == CERT_ALT_NAME_RFC822_NAME) 
                        {
                            // This is it, copy it out to a new allocation
                            if (pAltNameEntry->pwszRfc822Name)
                            {
                                DWORD cchSize = (lstrlen(pAltNameEntry->pwszRfc822Name)+1);
                                if (sz = LocalAlloc(LPTR, sizeof(TCHAR)*cchSize))
                                {
                                    StrCpyN(sz, pAltNameEntry->pwszRfc822Name, cchSize);
                                    break;
                                }
                            }
                        }
                    }
                }
                IF_WIN32(LocalFree(pAltNameInfo);)
                IF_WIN16(LocalFree((HLOCAL)pAltNameInfo);)
                pAltNameInfo = NULL;
            }

        }
    }
    LocalFreeAndNull(&pAltNameInfo);
    return(sz);
}

/*  SzGetCertificateEmailAddress:
**
**  Returns:
**      NULL if there is no email address
*/
LPTSTR SzGetCertificateEmailAddress(
    const PCCERT_CONTEXT    pCert)
{
    PCERT_NAME_INFO pNameInfo;
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;
    PCERT_RDN_ATTR  pRDNAttr;
    LPTSTR           szRet = NULL;

    Assert(pCert && pCert->pCertInfo);

    pNameInfo = (PCERT_NAME_INFO)PVDecodeObject(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData, X509_NAME, 0);
    if (pNameInfo)
        {
        pRDNAttr = gpfnCertFindRDNAttr(szOID_RSA_emailAddr, pNameInfo);
        if (pRDNAttr)
            {
            Assert(0 == lstrcmpA(szOID_RSA_emailAddr, pRDNAttr->pszObjId));
            szRet = SzConvertRDNString(pRDNAttr);
            }
        IF_WIN32(LocalFree(pNameInfo);)
        IF_WIN16(LocalFree((HLOCAL)pNameInfo);)
        }

    if (! szRet)
        {
        if (! (szRet = SzGetAltNameEmail(pCert, szOID_SUBJECT_ALT_NAME)))
            {
            szRet = SzGetAltNameEmail(pCert, szOID_SUBJECT_ALT_NAME2);
            }
        }

    return(szRet);
}


//*******************************************************************
//
//  FUNCTION:   GetCertsDisplayInfoFromContext
//
//  PURPOSE:    Gets the display info that is available in the cert
//              context structure.
//
//  PARAMETERS: pccCertContext - cert data
//              lpCDI - structure to receive the cert data
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/04  markdu  Created.
//
//*******************************************************************

HRESULT GetCertsDisplayInfoFromContext(
  HWND                hwndParent,
  PCCERT_CONTEXT      pccCertContext,
  LPCERT_DISPLAY_INFO lpCDI)
{
  HRESULT             hr = hrSuccess;
  PCERT_INFO          pCertInfo;

  pCertInfo = pccCertContext->pCertInfo;
  lpCDI->lpszDisplayString = NULL,
  lpCDI->lpszEmailAddress = NULL;

  hr = GetAttributeString(
    &lpCDI->lpszDisplayString,
    pCertInfo->Subject.pbData,
    pCertInfo->Subject.cbData,
    szOID_COMMON_NAME);
  if (hrSuccess != hr)
  {
    DebugTrace(TEXT("Cert has no common name\n"));
  }

  lpCDI->lpszEmailAddress = SzGetCertificateEmailAddress(pccCertContext);

  // In case there is no common name (weird, but true)
  if (! lpCDI->lpszDisplayString) {
      lpCDI->lpszDisplayString = lpCDI->lpszEmailAddress;
  }
  if (! lpCDI->lpszDisplayString) {
      DebugTrace(TEXT("Certificate had no name or email!  What a pathetic cert!\n"));
  }

  // Some certificates won't have email addresses in them which means that
  //    Failure is not a (valid) option.
  //    just set it to empty
  if (hrSuccess != hr)
  {
    hr = S_OK;
  }

  DebugTrace(TEXT("Certificate for '%s'. Email: '%s'\n"), lpCDI->lpszDisplayString ? lpCDI->lpszDisplayString : NULL, (lpCDI->lpszEmailAddress ? lpCDI->lpszEmailAddress : szEmpty));

  // Determine if cert has expired
  lpCDI->bIsExpired = IsCertExpired(pCertInfo);

  // Determine if cert has been revoked
  lpCDI->bIsRevoked = IsCertRevoked(pCertInfo);

  // Determine if this certificate is trusted or not
  if (FAILED(HrGetTrustState(hwndParent, pccCertContext, &lpCDI->dwTrust)))
  {
    lpCDI->dwTrust = CERT_VALIDITY_NO_TRUST_DATA;
    hr = S_OK;      // we handled this
  }

  if (0 == lpCDI->dwTrust)
      lpCDI->bIsTrusted = TRUE;
  else
      lpCDI->bIsTrusted = FALSE;

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   DebugTraceCertContextName
//
//  PURPOSE:    Dump the subject name of a cert context
//
//  PARAMETERS: pcCertContext = cert context to dump
//              lpDescription = description text
//
//  RETURNS:    none
//
//*******************************************************************
void DebugTraceCertContextName(PCCERT_CONTEXT pcCertContext, LPTSTR lpDescription) {
#ifdef DEBUG
    LPTSTR lpName = NULL;
    PCERT_INFO pCertInfo = pcCertContext->pCertInfo;
    GetAttributeString(
      &lpName,
      pCertInfo->Subject.pbData,
      pCertInfo->Subject.cbData,
      szOID_COMMON_NAME);
    if (! lpName) {
        GetAttributeString(
          &lpName,
          pCertInfo->Subject.pbData,
          pCertInfo->Subject.cbData,
          szOID_ORGANIZATION_NAME);
    }

    DebugTrace(TEXT("%s %s\n"), lpDescription, lpName ? lpName : TEXT("<unknown>"));
    if (lpName) {
        IF_WIN32(LocalFree(lpName);)
        IF_WIN16(LocalFree((HLOCAL)lpName);)
    }
#endif
}


//*******************************************************************
//
//  FUNCTION:   ReadMessageFromFile
//
//  PURPOSE:    Reads a single cert from a PKCS7 message file
//
//  PARAMETERS: lpszFileName - name of file containing the PKCS7 encoded
//              message
//              hCryptProvider - handle to the store provider
//              ppbEncoded - receives the encoded cert blob
//              pcbEncoded - receives the size of the encoded cert blob
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/06  markdu  Created.
//
//*******************************************************************

HRESULT ReadMessageFromFile(
  LPTSTR        lpszFileName,
  HCRYPTPROV    hCryptProvider,
  PBYTE*        ppbEncoded,
  PDWORD        pcbEncoded)
{
    HRESULT         hr = hrSuccess;
    BOOL            fRet;
    DWORD           cCert, cbData;
    HCRYPTMSG       hMsg = NULL;
    PBYTE           lpBuf = 0;
    ULONG           i, j;
    DWORD           dwIssuerFlags = 0;
    BOOL            fFound = FALSE, fIssuer;
    PCERT_CONTEXT * rgpcCertContext = NULL;
    HCERTSTORE      hCertStoreMsg = NULL;
    PCCERT_CONTEXT  pcCertContextTarget = NULL, pcCertContextIssuer;
    PCERT_INFO      pCertInfoTarget = NULL;


    if ((NULL == ppbEncoded) || (NULL == pcbEncoded)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
    *ppbEncoded = 0;
    *pcbEncoded = 0;

    // Read the data from the file.
    if (hr = ReadDataFromFile(lpszFileName, &lpBuf, (PDWORD)&cbData)) {
        goto out;
    }

    hMsg = gpfnCryptMsgOpenToDecode(
      PKCS_7_ASN_ENCODING,
      0,                          // dwFlags
      0,                          // dwMsgType
      hCryptProvider,
      NULL,                       // pRecipientInfo (not supported)
      NULL);                      // pStreamInfo (not supported)
    if (NULL == hMsg) {
        hr = HrGetLastError();
        DebugTrace(TEXT("CryptMsgOpenToDecode(PKCS_7_ASN_ENCODING) -> 0x%08x\n"), GetScode(hr));
        goto error;
    }

    fRet = gpfnCryptMsgUpdate(hMsg, lpBuf, cbData, TRUE);
    if (FALSE == fRet) {
        hr = HrGetLastError();
        DebugTrace(TEXT("CryptMsgUpdate -> 0x%08x\n"), GetScode(hr));
        goto error;
    }

    cbData = sizeof(cCert);
    fRet = gpfnCryptMsgGetParam(
      hMsg,
      CMSG_CERT_COUNT_PARAM,        // dwParamType
      0,                            // dwIndex
      (void *)&cCert,
      &cbData);                     // pcbData
    if (FALSE == fRet) {
        hr = HrGetLastError();
        DebugTrace(TEXT("CryptMsgGetParam(CMSG_CERT_COUNT_PARAM) -> 0x%08x\n"), GetScode(hr));
        goto error;
    }
    if (cbData != sizeof(cCert)) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
        goto error;
    }

    if (cCert == 1) {
        // Just one cert.  No decisions to make.
        cbData = 0;
        fRet = gpfnCryptMsgGetParam(
          hMsg,
          CMSG_CERT_PARAM,
          0,                      // dwIndex
          NULL,                   // pvData
          &cbData
          );
        if ((!fRet) || (0 == cbData)) {
            hr = ResultFromScode(MAPI_E_CALL_FAILED);
            DebugTrace(TEXT("CryptMsgGetParam(CMSG_CERT_PARAM) -> 0x%08x\n"), GetScode(hr));
            goto error;
        }

        IF_WIN32(*ppbEncoded = (BYTE *)LocalAlloc(LMEM_ZEROINIT, cbData);)
        IF_WIN16(*ppbEncoded = (PBYTE)LocalAlloc(LMEM_ZEROINIT, cbData);)
        if (NULL == *ppbEncoded) {
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto error;
        }

        fRet = gpfnCryptMsgGetParam(
          hMsg,
          CMSG_CERT_PARAM,
          0,
          *ppbEncoded,
          &cbData
          );
        if (FALSE == fRet) {
            hr = HrGetLastError();
            DebugTrace(TEXT("CryptMsgGetParam(CMSG_CERT_PARAM) -> 0x%08x\n"), GetScode(hr));
            IF_WIN32(LocalFreeAndNull(ppbEncoded);) IF_WIN16(LocalFreeAndNull((LPVOID *)ppbEncoded);)
            goto error;
        }
        *pcbEncoded = cbData;
    } else {
        // More than one cert in the message.  Which one is it?
        //
        // Look for one that's a "Leaf" node.
        // Unfortunately, there is no easy way to tell, so we'll have
        // to loop through each cert, checking to see if it is an issuer of any other cert
        // in the message.  If it is not an issuer of any other cert, it must be the leaf cert.
        //
        hCertStoreMsg = CertOpenStore(
          CERT_STORE_PROV_MSG,
          X509_ASN_ENCODING,
          hCryptProvider,
          CERT_STORE_NO_CRYPT_RELEASE_FLAG,
          hMsg);

        if (hCertStoreMsg == NULL) {
            hr = HrGetLastError();
            DebugTrace(TEXT("CertOpenStore(msg) -> %u\n"), hr);
        } else {
            if (! (rgpcCertContext = LocalAlloc(LPTR, cCert * sizeof(PCERT_CONTEXT)))) {
                DebugTrace(TEXT("LocalAlloc of cert table -> %u\n"), HrGetLastError());
                hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto error;
            }

            // Enumerate all certs on this message
            i = 0;
            while (pcCertContextTarget = gpfnCertEnumCertificatesInStore(hCertStoreMsg,
              pcCertContextTarget)) {

                if (! (rgpcCertContext[i] = (PCERT_CONTEXT)CertDuplicateCertificateContext(
                  pcCertContextTarget))) {
                    DebugTrace(TEXT("CertCertificateContext -> %x\n"), HrGetLastError());
                }

#ifdef DEBUG
                DebugTraceCertContextName(rgpcCertContext[i], TEXT("Found Cert:"));
#endif
                i++;
            };

            // Now we've got a table full of certs
            for (i = 0; i < cCert; i++) {
                pCertInfoTarget = rgpcCertContext[i]->pCertInfo;
                fIssuer = FALSE;

                for (j = 0; j < cCert; j++) {
                    if (i != j) {
                        dwIssuerFlags = 0;

                        if (pcCertContextIssuer = gpfnCertGetIssuerCertificateFromStore(hCertStoreMsg,
                          rgpcCertContext[j],
                          NULL,
                          &dwIssuerFlags)) {

                            // Found an issuer
                            // Is it the same as the target?
                            fIssuer = gpfnCertCompareCertificate(X509_ASN_ENCODING,
                              pCertInfoTarget,   // target
                              pcCertContextIssuer->pCertInfo);     // test issuer

                            gpfnCertFreeCertificateContext(pcCertContextIssuer);

                            if (fIssuer) {
                                // This test cert is issued by the target, so
                                // we know that Target is NOT a leaf cert
                                break;
                            } // else, loop back to the enumerate where the test cert context will be freed.
                        }
                    }
                }

                if (! fIssuer) {
                    DebugTrace(TEXT("Found a Cert which is not an issuer.\n"));
#ifdef DEBUG
                    DebugTraceCertContextName(rgpcCertContext[i],  TEXT("Non-issuer cert:"));
#endif
                    // Copy the cert encoded data to a seperate allocation
                    cbData = rgpcCertContext[i]->cbCertEncoded;
#ifndef WIN16
                    if (! (*ppbEncoded = (BYTE *)LocalAlloc(LPTR, cbData))) {
                        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                        goto error;
                    }
#else
                    if (! (*ppbEncoded = (PBYTE)LocalAlloc(LPTR, cbData))) {
                        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                        goto error;
                    }
#endif

                    CopyMemory(*ppbEncoded, rgpcCertContext[i]->pbCertEncoded, cbData);
                    *pcbEncoded = cbData;
                    fFound = TRUE;
                    break;  // done with loop
                }
            }

            // Free the table of certs
            for (i = 0; i < cCert; i++) {
                gpfnCertFreeCertificateContext(rgpcCertContext[i]);
            }
            IF_WIN32(LocalFree((LPVOID)rgpcCertContext);)
            IF_WIN16(LocalFree((HLOCAL)rgpcCertContext);)

            if (! fFound) {
                // Didn't find a cert that isn't an issuer.  Fail.
                hr = ResultFromScode(MAPI_E_NOT_FOUND);
                goto error;
            }
        }
    }

out:
    if (hCertStoreMsg) {
        CertCloseStore(hCertStoreMsg, 0);
    }

    if (hMsg) {
        gpfnCryptMsgClose(hMsg);
    }

    if (lpBuf) {
        IF_WIN32(LocalFreeAndNull(&lpBuf);) IF_WIN16(LocalFreeAndNull((LPVOID *)&lpBuf);)
    }

    return(hr);

error:
    // some of the GetLastError calls above may not have worked.
    if (hrSuccess == hr) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
    }

    goto out;
}


//*******************************************************************
//
//  FUNCTION:   WriteDERToFile
//
//  PURPOSE:    Writes a single cert to a file as a DER encoded blob
//
//  PARAMETERS: lpszFileName - name of file to hold the encoded blob
//              pccCertContext - the cert to be written
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/29  markdu  Created.
//
//*******************************************************************

HRESULT WriteDERToFile(
  LPTSTR  lpszFileName,
  PBYTE   pbEncoded,
  DWORD   cbEncoded)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;
  HANDLE              hFile = 0;
  DWORD               cbFile;

  // Open the file
  hFile = CreateFile(
    lpszFileName,
    GENERIC_READ | GENERIC_WRITE,
    0,
    NULL,
    CREATE_ALWAYS,
    0,
    NULL);
  if(INVALID_HANDLE_VALUE == hFile)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto out;
  }

  // Write the data to the file
  fRet = WriteFile(
    hFile,                      // handle of file to write
    pbEncoded,                  // address of buffer to write
    cbEncoded,                  // number of bytes to write
    &cbFile,                    // address of number of bytes written
    NULL                        // address of structure for data
    );
  if (FALSE == fRet)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto out;
  }
  if (cbEncoded != cbFile)
  {
    hr = ResultFromScode(MAPI_E_CALL_FAILED);
    goto out;
  }

out:
  if (hFile)
  {
    IF_WIN32(CloseHandle(hFile);) IF_WIN16(CloseFile(hFile);)
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   GetIssuerContextAndStore
//
//  PURPOSE:    Get the context of the issuer by first looking in the
//              CA store, then the root store.
//
//  PARAMETERS: pccCertContext - cert whose issuer to find
//              ppccIssuerCertContext - receives context of issuer,
//              or NULL if no issuer cert found.
//              phcsIssuerStore - receives handle of store containing cert.
//              hCryptProvider - must be a valid provider
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/10/14  markdu  Created.
//
//*******************************************************************

HRESULT GetIssuerContextAndStore(
  PCCERT_CONTEXT      pccCertContext,
  PCCERT_CONTEXT*     ppccIssuerCertContext,
  HCRYPTPROV          hCryptProvider,
  HCERTSTORE*         phcsIssuerStore)
{
  HRESULT             hr = hrSuccess;
  DWORD               dwFlags;

  // Open the CA store to get the issuer data.
  hr = OpenSysCertStore(phcsIssuerStore, &hCryptProvider, cszCACertStore);
  if (hrSuccess == hr)
  {
    // Get the issuer cert context
    dwFlags = 0;
    *ppccIssuerCertContext = gpfnCertGetIssuerCertificateFromStore(
      *phcsIssuerStore,
      pccCertContext,
      NULL,
      &dwFlags);
    if (NULL != *ppccIssuerCertContext)
    {
      goto out;
    }
    else
    {
      // Close the store, but don't goto error, becuase we want to try again.
      CloseCertStore(*phcsIssuerStore, 0);
      *phcsIssuerStore = NULL;
      hr = ResultFromScode(MAPI_E_NOT_FOUND);
    }
  }

  // We didn't find the issuer, so try the root store
  hr = OpenSysCertStore(phcsIssuerStore, &hCryptProvider, cszROOTCertStore);
  if (hrSuccess == hr)
  {
    // Get the issuer cert context
    dwFlags = 0;
    *ppccIssuerCertContext = gpfnCertGetIssuerCertificateFromStore(
      *phcsIssuerStore,
      pccCertContext,
      NULL,
      &dwFlags);
    if (NULL != *ppccIssuerCertContext)
    {
      goto out;
    }
    else
    {
      goto error;
    }
  }

out:
  // Make sure we didn't get back the same cert (ie it was self-signed).
  if (hrSuccess == hr)
  {
    // First compare sizes since that is faster.
    if (pccCertContext->cbCertEncoded == (*ppccIssuerCertContext)->cbCertEncoded)
    {
      // Sizes are the same, now compare the encoded cert blobs
      if (0 == memcmp(
        pccCertContext->pbCertEncoded,
        (*ppccIssuerCertContext)->pbCertEncoded,
        pccCertContext->cbCertEncoded))
      {
        // Certs are identical.  There is no issuer.
        goto error;
      }
    }
  }

  return hr;

error:
  CloseCertStore(*phcsIssuerStore, 0);
  *phcsIssuerStore = NULL;
  return ResultFromScode(MAPI_E_NOT_FOUND);
}


/***************************************************************************

    Name      : HrBuildCertSBinaryData

    Purpose   : Takes as input all the data needed for a cert entry
                in PR_USER_X509_CERTIFICATE and returns a pointer to
                memory that contains all the input data in the correct
                format to be plugged in to the lpb member of an SBinary
                structure.  This memory should be Freed by the caller.


    Parameters: bIsDefault - TRUE if this is the default cert
                pblobCertThumbPrint - The actual certificate thumbprint
                pblobSymCaps - symcaps blob
                ftSigningTime - Signing time
                lpObject - object to alloc more onto, or NULL to LocalAlloc
                lplpbData - receives the buffer with the data
                lpcbData - receives size of the data

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  BOOL                  fIsThumbprint,
  PCRYPT_DIGEST_BLOB    pPrint,
  BLOB *                pSymCaps,
  FILETIME              ftSigningTime,
  LPVOID                lpObject,
  LPBYTE FAR*           lplpbData,
  ULONG FAR*            lpcbData)
{
	WORD		cbDefault, cbPrint;
    DWORD       cbSymCaps;
    HRESULT     hr = S_OK;
    LPCERTTAGS  lpCurrentTag;
    ULONG       cbSize, cProps;
    LPBYTE      lpb = NULL;


    cbDefault   = sizeof(bIsDefault);
    cbPrint     = (WORD) pPrint->cbData;
    cbSymCaps   = pSymCaps ? pSymCaps->cbSize : 0;
    cProps      = 2;
    cbSize      = cbDefault + cbPrint;
    if (cbSymCaps) {
        cProps++;
        cbSize += cbSymCaps;
    }
    if (ftSigningTime.dwLowDateTime || ftSigningTime.dwHighDateTime) {
        cProps++;
        cbSize += sizeof(FILETIME);
    }
    cbSize += (cProps * SIZE_CERTTAGS);

    if (NULL == lpObject)
    {
      lpb = LocalAlloc(LMEM_ZEROINIT, cbSize);
      if (NULL == lpb)
      {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
      }
    }
    else
    {
      SCODE sc;
      sc = MAPIAllocateMore(cbSize, lpObject, (LPVOID *)&lpb);
      if (sc)
      {
        hr = ResultFromScode(sc);
        goto exit;
      }
    }

    // Set the default property
    lpCurrentTag = (LPCERTTAGS)lpb;
    lpCurrentTag->tag       = CERT_TAG_DEFAULT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbDefault;
    memcpy(&lpCurrentTag->rgbData,
        &bIsDefault,
        cbDefault);

    // Set the thumbprint property
    lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
    lpCurrentTag->tag       = fIsThumbprint ? CERT_TAG_THUMBPRINT : CERT_TAG_BINCERT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbPrint;
    memcpy(&lpCurrentTag->rgbData, pPrint->pbData, cbPrint);

    // Set the SymCaps property
    if (cbSymCaps) {
        lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
        lpCurrentTag->tag       = CERT_TAG_SYMCAPS;
        lpCurrentTag->cbData    = (WORD) (SIZE_CERTTAGS + pSymCaps->cbSize);
        memcpy(&lpCurrentTag->rgbData, pSymCaps->pBlobData, cbSymCaps);
    }

    // Signing time property
    if (ftSigningTime.dwLowDateTime || ftSigningTime.dwHighDateTime) {
        lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
        lpCurrentTag->tag       = CERT_TAG_SIGNING_TIME;
        lpCurrentTag->cbData    = SIZE_CERTTAGS + sizeof(FILETIME);
        memcpy(&lpCurrentTag->rgbData, &ftSigningTime, sizeof(FILETIME));
    }


    *lpcbData = cbSize;
    *lplpbData = lpb;
exit:
    return(hr);
}

//*******************************************************************
//
//  FUNCTION:   HrLDAPCertToMAPICert
//
//  PURPOSE:    Convert cert(s) returned from LDAP server to MAPI props.
//              Two properties are required.  The certs are placed in the
//              WAB store, and all necessary indexing data is placed in
//              PR_USER_X509_CERTIFICATE property.  If this certificate
//              didn't already exist in the WAB store, it's thumbprint is
//              added to PR_WAB_TEMP_CERT_HASH so that these certs can
//              be deleted from the store if the user cancels the add.
//
//  PARAMETERS: lpPropArray - the prop array where the 2 props are stored
//              ulX509Index - the index to the PR_USER_X509_CERTIFICATE prop
//              ulTempCertIndex - the index to the PR_WAB_TEMP_CERT_HASH prop
//              cbCert, lpCert - encoded cert data from the LDAP ppberval struct
//              ulcCerts - the number of certs from the LDAP server
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/12  markdu  Created.
//
//*******************************************************************

HRESULT HrLDAPCertToMAPICert(
                             LPSPropValue    lpPropArray,
                             ULONG           ulX509Index,
                             ULONG           ulTempCertIndex,
                             ULONG           cbCert,
                             PBYTE           lpCert,
                             ULONG           ulcCerts)
{
    HRESULT             hr = hrSuccess;
    HRESULT             hrOut = hrSuccess;
    CRYPT_DIGEST_BLOB   blobCertThumbPrint = {0};
    PCCERT_CONTEXT      pccCertToAdd;
    PCCERT_CONTEXT      pccCertFromStore;
    HCERTSTORE          hcsWABCertStore = NULL;
    HCRYPTPROV          hCryptProvider = 0;
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    ULONG               i;
    ULONG               cbData = 0;
    LPBYTE              lpbData = NULL;
    FILETIME            ftNull = {0, 0};
    
#ifdef  PARAMETER_VALIDATION
    ULONG ulcProps = max(ulX509Index, ulTempCertIndex);
    if (ulcProps && IsBadReadPtr(lpPropArray, ulcProps * sizeof(SPropValue)))
    {
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }
    /*  if (ulcCerts && IsBadReadPtr(ppberval, ulcCerts * sizeof(struct berval)))
    {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }
    */
#endif  // PARAMETER_VALIDATION
    
    // Make sure we have the right kind of proparray.
    if ((NULL == lpPropArray) ||
        (PR_USER_X509_CERTIFICATE != lpPropArray[ulX509Index].ulPropTag) ||
        (PR_WAB_TEMP_CERT_HASH != lpPropArray[ulTempCertIndex].ulPropTag))
    {
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }
    
    // Load the crypto functions
    if (FALSE == InitCryptoLib())
    {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        return hr;
    }
    
    // Open the store since we need to lookup certs
    hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
    if (hrSuccess != hr)
    {
        goto out;
    }
    
    // Add each cert to the props, unless it is a duplicate.
    for (i=0;i<ulcCerts;i++)
    {
        // Convert the cert into a form we can deal with.
        // BUGBUG this assumes the cert is DER encoded.
        pbEncoded = lpCert; //(PBYTE)ppberval[i]->bv_val;
        cbEncoded = cbCert; //(DWORD)ppberval[i]->bv_len;
        
        // Get a context for the cert so we can get the thumbprint
        pccCertToAdd = gpfnCertCreateCertificateContext(
            X509_ASN_ENCODING,
            pbEncoded,
            cbEncoded);
        if (NULL == pccCertToAdd)
        {
            hr = GetLastError();
            goto out;
        }
        
        // Get the thumbprint for this cert.
        hr = GetCertThumbPrint(
            pccCertToAdd,
            &blobCertThumbPrint);
        if (hrSuccess != hr)
        {
            goto out;
        }
        
        // See if this cert is in the store already.  If it is, we don't want to
        // add it to the temp property for deletion later.
        pccCertFromStore = gpfnCertFindCertificateInStore(
            hcsWABCertStore,
            X509_ASN_ENCODING,
            0,
            CERT_FIND_HASH,
            (void *)&blobCertThumbPrint,
            NULL);
        if (NULL == pccCertFromStore)
        {
            BOOL fRet;
            
            // Add the cert to the store
            fRet = gpfnCertAddEncodedCertificateToStore(
                hcsWABCertStore,
                X509_ASN_ENCODING,
                pbEncoded,
                cbEncoded,
                CERT_STORE_ADD_NEW,
                NULL);
            if (FALSE == fRet)
            {
                hr = GetLastError();
                goto out;
            }
            
            // Add the thumbprint to the temp prop so we can delete it later if the user cancels.
            hr = AddPropToMVPBin(
                lpPropArray,
                ulTempCertIndex,
                blobCertThumbPrint.pbData,
                blobCertThumbPrint.cbData,
                TRUE);
            if (hrSuccess != hr)
            {
                goto out;
            }
        }
        else
        {
            // We don't need to add this one to the store.
            gpfnCertFreeCertificateContext(pccCertFromStore);
        }
        
        // Pack up all the cert data
        cbData = 0;
        hr = HrBuildCertSBinaryData(
            FALSE,
            TRUE,
            &blobCertThumbPrint,
            NULL,         // SymCaps blob
            ftNull,       // Signing time
            NULL,         // This NULL means lpbData is allocated with LocalAlloc()
            &lpbData,
            &cbData);
        if ((hrSuccess != hr) || (0 == cbData))
        {
            goto out;
        }
        
        // Add the cert data to the real cert prop.
        hr = AddPropToMVPBin(
            lpPropArray,
            ulX509Index,
            lpbData,
            cbData,
            TRUE);
        if (hrSuccess != hr)
        {
            goto out;
        }
        
        // Add the trust for this LDAP cert to the pstore
        // (doesn't have to be done because we won't trust this
        //  certificate by default)
        // This is the way it was, wonder if that is correct
        // (t-erikne)
        
        // Free the cert context so we can do the next one.
        gpfnCertFreeCertificateContext(pccCertToAdd);
        pccCertToAdd = NULL;
        LocalFreeAndNull(&lpbData);
        cbData = 0;

        // Also free the blobCertThumbPrint.pbData which is allocated with LocalAlloc()
        LocalFreeAndNull(&(blobCertThumbPrint.pbData));
        blobCertThumbPrint.cbData = 0;
  }
  
out:
  // Both blobCertThumbPrint.pbData and lpbData above are allocated using LocalAlloc()
  // Be sure and free this memory.
  LocalFreeAndNull(&lpbData);
  LocalFreeAndNull(&(blobCertThumbPrint.pbData));

  // Destroy any data we created if the function failed.
  if (hrSuccess != hr)
  {
      lpPropArray[ulX509Index].ulPropTag = PR_NULL;
      lpPropArray[ulTempCertIndex].ulPropTag = PR_NULL;
  }
  
  // Free the cert context.  Ignore errors since there is nothing we can do.
  if (NULL != pccCertToAdd)
  {
      gpfnCertFreeCertificateContext(pccCertToAdd);
  }
  
  // Close the cert store.
  hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);
  
  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
      hr = hrOut;
  }
  
  return hr;
}

//*******************************************************************
//
//  FUNCTION:   HrRemoveCertsFromWABStore
//
//  PURPOSE:    Remove the certs whose thumbprints are in the supplied
//              PR_WAB_TEMP_CERT_HASH property.
//
//  PARAMETERS: lpPropValue - the PR_WAB_TEMP_CERT_HASH property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/13  markdu  Created.
//
//*******************************************************************

HRESULT HrRemoveCertsFromWABStore(
  LPSPropValue    lpPropValue)
{
  HRESULT             hr = hrSuccess;
  HRESULT             hrOut = hrSuccess;
	CRYPT_DIGEST_BLOB   blobCertThumbPrint;
  PCCERT_CONTEXT      pccCertContext;
  HCERTSTORE          hcsWABCertStore = NULL;
  HCRYPTPROV          hCryptProvider = 0;
  ULONG               i;
  ULONG               ulcCerts;
  BOOL                fRet;

#ifdef  PARAMETER_VALIDATION
  if (IsBadReadPtr(lpPropValue, sizeof(SPropValue)))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }
#endif  // PARAMETER_VALIDATION

  // Make sure we have the right kind of proparray.
  if ((NULL == lpPropValue) ||
      (PR_WAB_TEMP_CERT_HASH != lpPropValue->ulPropTag))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  // Count the number of certs in the input.
  ulcCerts = lpPropValue->Value.MVbin.cValues;
  if (0 == ulcCerts)
  {
    return hr;
  }

  // Load the crypto functions
  if (FALSE == InitCryptoLib())
  {
    hr = ResultFromScode(MAPI_E_UNCONFIGURED);
    return hr;
  }

  // Open the store since we need to delete certs
  hr = OpenSysCertStore(&hcsWABCertStore, &hCryptProvider, cszWABCertStore);
  if (hrSuccess != hr)
  {
    return hr;
  }

  // Delete each cert.
  for (i=0;i<ulcCerts;i++)
  {
    // Get the thumbprint from the propval.
    blobCertThumbPrint.cbData = lpPropValue->Value.MVbin.lpbin[i].cb;
    blobCertThumbPrint.pbData = lpPropValue->Value.MVbin.lpbin[i].lpb;

    // Get the certificate from the WAB store using the thumbprint
    // If we don't find the cert, ignore it and go on to the next one.
    pccCertContext = gpfnCertFindCertificateInStore(
      hcsWABCertStore,
      X509_ASN_ENCODING,
      0,
      CERT_FIND_HASH,
      (void *)&blobCertThumbPrint,
      NULL);
    if (NULL != pccCertContext)
    {
      // Delete the cert
      fRet = gpfnCertDeleteCertificateFromStore(pccCertContext);
      if (FALSE == fRet)
      {
        hr = HrGetLastError();
        goto out;
      }
    }
  }

out:
  // Close the cert store.
  hrOut = CloseCertStore(hcsWABCertStore, hCryptProvider);

  // If an error occurred in the function body, return that instead of
  // any errors that occurred here in cleanup.
  if (hrSuccess == hr)
  {
    hr = hrOut;
  }

  return hr;
}



//*******************************************************************
//
//  FUNCTION:   IsCertExpired
//
//  PURPOSE:    Check the cert info to see if it is expired or not yet valid.
//
//  PARAMETERS: pCertInfo - Cert to verify
//
//  RETURNS:    TRUE if cert is expired, FALSE otherwise.
//
//  HISTORY:
//  96/12/16  markdu  Created.
//  98/03/225 brucek  Use CAPI fn and be a little lenient on the start time.
//
//*******************************************************************
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds
#define FILETIME_SECOND    10000000     // 100ns intervals per second
HRESULT IsCertExpired(
  PCERT_INFO            pCertInfo)
{
    LONG                lRet;
    FILETIME            ftDelta;
    __int64             i64Delta;
    __int64             i64Offset;
    FILETIME            ftNow;

    Assert(pCertInfo);

    lRet = gpfnCertVerifyTimeValidity(NULL, pCertInfo);

    if (lRet < 0) {
        // Get the current time in filetime format so we can add the offset
        GetSystemTimeAsFileTime(&ftNow);

        i64Delta = ftNow.dwHighDateTime;
        i64Delta = i64Delta << 32;
        i64Delta += ftNow.dwLowDateTime;

        // Add the offset into the original time to get us a new time to check
        i64Offset = FILETIME_SECOND;
        i64Offset *= TIME_DELTA_SECONDS;
        i64Delta += i64Offset;

        ftDelta.dwLowDateTime = (ULONG)i64Delta & 0xFFFFFFFF;
        ftDelta.dwHighDateTime = (ULONG)(i64Delta >> 32);

        lRet = gpfnCertVerifyTimeValidity(&ftDelta, pCertInfo);
    }

  return(lRet != 0);
}


//*******************************************************************
//
//  FUNCTION:   IsCertRevoked
//
//  PURPOSE:    Check the cert info to see if it is revoked.
//
//  PARAMETERS: pCertInfo - Cert to verify
//
//  RETURNS:    TRUE if cert is revoked, FALSE otherwise.
//
//  HISTORY:
//  96/12/16  markdu  Created.
//
//*******************************************************************

HRESULT IsCertRevoked(
  PCERT_INFO            pCertInfo)
{
  Assert(pCertInfo);

  // Determine if cert has been revoked
  // BUGBUG How to do this?
  return FALSE;
}


//*******************************************************************
//
//  FUNCTION:   ReadDataFromFile
//
//  PURPOSE:    Read data from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the data to be read
//              ppbData - receives the data that is read
//              pcbData - receives the size of the data that is read
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/12/16  markdu  Created.
//
//*******************************************************************

HRESULT ReadDataFromFile(
  LPTSTR      lpszFileName,
  PBYTE*      ppbData,
  PDWORD      pcbData)
{
  HRESULT             hr = hrSuccess;
  BOOL                fRet;
  HANDLE              hFile = 0;
  DWORD               cbFile;
  DWORD               cbData;
  PBYTE               pbData = 0;

  if ((NULL == ppbData) || (NULL == pcbData))
  {
    return ResultFromScode(MAPI_E_INVALID_PARAMETER);
  }

  // Open the file and find out how big it is
  hFile = CreateFile(
    lpszFileName,
    GENERIC_READ,
    FILE_SHARE_READ | FILE_SHARE_WRITE,
    NULL,
    OPEN_EXISTING,
    0,
    NULL);
  if(INVALID_HANDLE_VALUE == hFile)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto error;
  }

  cbData = GetFileSize(hFile, NULL);
  if (0xFFFFFFFF == cbData)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto error;
  }

  IF_WIN32(pbData = (BYTE *)LocalAlloc(LMEM_ZEROINIT, cbData);)
  IF_WIN16(pbData = (PBYTE)LocalAlloc(LMEM_ZEROINIT, cbData);)
  if (NULL == pbData)
  {
    hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
    goto error;
  }

  fRet = ReadFile(
    hFile,                      // handle of file to read
    pbData,                      // address of buffer that receives data
    cbData,                     // number of bytes to read
    &cbFile,                    // address of number of bytes read
    NULL                        // address of structure for data
    );
  if (FALSE == fRet)
  {
    hr = ResultFromScode(MAPI_E_DISK_ERROR);
    goto error;
  }
  if (cbData != cbFile)
  {
    hr = ResultFromScode(MAPI_E_CALL_FAILED);
    goto error;
  }

  *ppbData = pbData;
  *pcbData = cbData;

out:
  if (hFile)
  {
    IF_WIN32(CloseHandle(hFile);) IF_WIN16(CloseFile(hFile);)
  }

  return hr;

error:
  // BUGBUG some of the GetLastError calls above may not have worked.
  if (hrSuccess == hr)
  {
    hr = ResultFromScode(MAPI_E_CALL_FAILED);
  }

  goto out;
}


//*******************************************************************
//
//  FUNCTION:   GetIssuerName
//
//  PURPOSE:    Wraps the several calls that one can make to try to
//              get a usable name from a certificate.  Esp in the
//              case of self-signed certs, the issuer may just have a
//              common name.
//
//  PARAMETERS: lplpszIssuerName - OUT, for the name, NULL on err
//              pCertInfo - IN, place from which to retrieve the data
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  97/02/04  t-erikne  Created.
//
//*******************************************************************

HRESULT GetIssuerName(
    LPTSTR FAR * lplpszIssuerName,
    PCERT_INFO pCertInfo)
{
  HRESULT hr;

  Assert(lplpszIssuerName);

  *lplpszIssuerName = '\000';

  hr = GetAttributeString(
    lplpszIssuerName,
    pCertInfo->Issuer.pbData,
    pCertInfo->Issuer.cbData,
    szOID_ORGANIZATION_NAME);

  if (hrSuccess != hr)
    if (MAPI_E_NOT_FOUND == hr)
      hr = GetAttributeString(
        lplpszIssuerName,
        pCertInfo->Issuer.pbData,
        pCertInfo->Issuer.cbData,
        szOID_COMMON_NAME);

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   HrGetTrustState
//
//  PURPOSE:    For newly imported certs, need to determine if an
//                  issuer exists for this cert or not ...
//
//  HISTORY:
//  2/17/97     t-erikne created
//  7/02/97     t-erikne updated to WinTrust
//
//*******************************************************************
HRESULT HrGetTrustState(
    HWND            hwndParent,
    PCCERT_CONTEXT  pcCert,
    DWORD *         pdwTrust)
{
    HRESULT     hr;
    DWORD       dwErr;
    GUID        guidAction = CERT_CERTIFICATE_ACTION_VERIFY;
    // CERT_VERIFY_CERTIFICATE_TRUST   cvct = {0};

    CERT_VERIFY_CERTIFICATE_TRUST       trust = {0};
    WINTRUST_BLOB_INFO                  blob = {0};
    WINTRUST_DATA                       data = {0};


    if (!(pcCert || pdwTrust))
        return E_INVALIDARG;

    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE)&trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pcCert;
    trust.pdwErrors = pdwTrust;
    trust.pszUsageOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    trust.dwIgnoreErr =
      CERT_VALIDITY_NO_CRL_FOUND |
      CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION;

    return (0 <= WinVerifyTrust(hwndParent, &guidAction, &data))
        ? S_OK
        : E_FAIL;
}


HRESULT DeleteCertStuff(LPADRBOOK lpAdrBook,
                        LPENTRYID lpEntryID,
                        ULONG cbEntryID)
{
    SizedSPropTagArray(1, ptaCert)=
                    { 1, {PR_USER_X509_CERTIFICATE} };
    LPMAPIPROP      lpMailUser = NULL;
    HRESULT         hr = E_FAIL;
    LPSPropValue    ppv = NULL;
    ULONG           ul;
    BLOB            thumbprint;
    LPWSTR          szW = NULL;

    //N2 not sure what to do yet about trust removal
    goto out;

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                    cbEntryID,    // cbEntryID
                                                    lpEntryID,    // entryid
                                                    NULL,         // interface
                                                    0,                // ulFlags
                                                    &ul,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugTraceResult( TEXT("DeleteCertStuff: IAB->OpenEntry:"), hr);
        goto out;
    }

    Assert(lpMailUser);

    if(MAPI_DISTLIST == ul)
        {
        hr = S_OK;
        goto out;
        }

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    (LPSPropTagArray)&ptaCert,   // lpPropTagArray
                                                    MAPI_UNICODE,          // ulFlags
                                                    &ul,        // how many properties were there?
                                                    &ppv)))
    {
        DebugTraceResult( TEXT("DeleteCertStuff: IAB->GetProps:"), hr);
        goto out;
    }

    if (MAPI_W_ERRORS_RETURNED == hr)
        {
        if (PROP_TYPE(ppv->ulPropTag) == PT_ERROR)
            // the property doesn't exist, so we have no certs
            // for this entry
            hr = S_OK;  // cool
        goto out;
        }
    else if (1 != ul)
        {
        hr = E_FAIL;
        goto out;
        }
    else if (FAILED(hr))
        goto out;

    // Now need to loop over the SBinary structures to look at each cert
    for (ul = 0; ul < ppv->Value.MVbin.cValues; ul++)
        {
        LPCERTTAGS  lpCurrentTag, lpTempTag;
        LPBYTE      lpbTagEnd;

        lpCurrentTag = (LPCERTTAGS)ppv->Value.MVbin.lpbin[ul].lpb;
        lpbTagEnd = (LPBYTE)lpCurrentTag + ppv->Value.MVbin.lpbin[ul].cb;

        // either this is the last cert or it is the default, so get the data
        // scan for "thumbprint" tag
        while ((LPBYTE)lpCurrentTag < lpbTagEnd && (CERT_TAG_THUMBPRINT != lpCurrentTag->tag)) {
            lpTempTag = lpCurrentTag;
            lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
            if (lpCurrentTag == lpTempTag) {
                AssertSz(FALSE,  TEXT("Bad CertTag in PR_USER_X509_CERTIFICATE\n"));
                break;        // Safety valve, prevent infinite loop if bad data
            }
        }
        if (CERT_TAG_THUMBPRINT == lpCurrentTag->tag)
            {
            // we need to remove the trust blob

#ifdef DEBUG
            if (SUCCEEDED(hr))
                DebugTraceResult( TEXT("DeleteCertStuff: trust blob deleted -- "), hr);
            else
                DebugTraceResult( TEXT("DeleteCertStuff: FAILED trust blob delete --"), hr);
#endif

            }
        else
            {
            // no data, so go to next cert
            DebugTrace(TEXT("DeleteCertStuff: odd... no data for the cert\n"));
            continue;
            }
        } // for loop over certs

out:
    if (ppv)
        MAPIFreeBuffer(ppv);
    if (lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);
    return hr;
}

PCCERT_CONTEXT WabGetCertFromThumbprint(CRYPT_DIGEST_BLOB thumbprint)
{
    HCERTSTORE      hcWAB;
    PCCERT_CONTEXT  pcRet;

    hcWAB = CertOpenStore(
#ifdef UNICODE
                            CERT_STORE_PROV_SYSTEM_W,
#else
                            CERT_STORE_PROV_SYSTEM_A,
#endif
                            X509_ASN_ENCODING, 0, CERT_SYSTEM_STORE_CURRENT_USER, cszWABCertStore);

    if (hcWAB)
    {
        pcRet =  CertFindCertificateInStore(
            hcWAB,
            X509_ASN_ENCODING,
            0,                  //dwFindFlags
            CERT_FIND_HASH,
            (void *)&thumbprint,
            NULL);
        CertCloseStore(hcWAB, 0);
    }
    else
    {
        pcRet = NULL;
    }

    return pcRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\btnbar.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     BtnBar.h
//
//  PURPOSE:    Defines a class that can be used as a generic button bar.
//

#ifndef __BTNBAR_H__
#define __BTNBAR_H__

static const TCHAR    c_szButtonBar[] = TEXT("WABButtonBar");
static const int      c_cxButtons = 20;
static const COLORREF c_crMask = RGB(255, 0, 255);
static COLORREF g_clrSelText = RGB(255, 0, 0);
static COLORREF g_clrText = RGB(0, 0, 0);


// BTNCREATEPARAMS: This structure is used to pass information about each
//                  button to the CButtonBar::Create() function.  
typedef struct tagBTNCREATEPARAMS
{
    UINT id;            // WM_COMMAND ID to be sent to the parent when pressed
    UINT iIcon;         // Index of the icon in the image list to display
    UINT idsLabel;      // String resource ID of the title text for the button
} BTNCREATEPARAMS, *PBTNCREATEPARAMS;



HWND CBB_Create(    HWND hwndParent, 
                    UINT idButtons, 
                    UINT idHorzBackground, 
                    PBTNCREATEPARAMS pBtnCreateParams, 
                    UINT cParams);
static LRESULT CALLBACK CBB_ButtonBarProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void CBB_OnPaint(HWND hwnd);
void CBB_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
void CBB_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
void CBB_OnTimer(HWND hwnd, UINT id);
int CBB_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg);
   


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\certs.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CERT.H
//
//  PURPOSE:  Header file for certificate functions in cert.c.
//
//  HISTORY:
//  96/09/23  vikramm Created.
//  96/11/14  markdu  BUG 10132 Updated to post-SDR CAPI.
//  96/11/14  markdu  BUG 10267 Remove static link to functions in advapi32.dll
//
//*******************************************************************

#ifndef __CERT_H
#define __CERT_H

#ifndef IN
#define IN
#endif
#ifndef OUT
#define OUT
#endif
#ifndef OPTIONAL
#define OPTIONAL
#endif

// Note:
// Some data types  are assumed and may need to be changed
//

// other defines
#define MAX_STR                 256       // Sting buffer size
#define NUM_CHARS_PER_SN_BYTE   3         // Number of characters needed to display
                                          // each byte of the serial number

// This struct and tags will be published by the exchange group -- this is temporary.
#define NUM_CERT_TAGS           4
#define CERT_TAG_DEFAULT        0x20
#define CERT_TAG_THUMBPRINT     0x22
#define CERT_TAG_BINCERT        0x03
#define CERT_TAG_SYMCAPS        0x02
#define CERT_TAG_SIGNING_TIME   0x0D
#define CERT_TAG_SMIMECERT      0x30
// SIZE_CERTTAGS is the size of the structure excluding the byte array.
#define SIZE_CERTTAGS       (2 * sizeof(WORD))

// useless warning, should probably just remove the []
#pragma warning (disable:4200)
typedef struct _CertTag
{
  WORD  tag;
  WORD  cbData;
  BYTE  rgbData[];
} CERTTAGS, FAR * LPCERTTAGS;
#pragma warning (default:4200)

/************************************************************************************/
// Bare minimum info needed for each cert in the details certificate pane
//
typedef struct _CertDisplayInfo
{
	LPTSTR lpszDisplayString;   // String to display for this certificate
    LPTSTR lpszEmailAddress;
	DWORD   dwTrust;            // One of above trust flags
	BOOL bIsDefault;            // Is this the default cert
	BOOL bIsRevoked;            // Has this been revoked
    BOOL bIsExpired;            // Is this expired
    BOOL bIsTrusted;            // Is this a trusted certificate
    PCCERT_CONTEXT      pccert; // THis is the actual cert
	BLOB blobSymCaps;            // Symetric Capabilities
   FILETIME ftSigningTime;      // Signing Time
  struct _CertDisplayInfo * lpNext;
  struct _CertDisplayInfo * lpPrev;
} CERT_DISPLAY_INFO, * LPCERT_DISPLAY_INFO;
/************************************************************************************/


/************************************************************************************/
// Details needed to display properties
//
typedef struct _CertDisplayProps
{
	BOOL    bIsRevoked;         // Has this been revoked
    BOOL    bIsExpired;         // Is this expired
	DWORD   dwTrust;            // One of above trust flags
    BOOL    bIsTrusted;         // Whether its trusted or not
  LPTSTR  lpszSerialNumber;   // Serial Number for the cert
  LPTSTR  lpszValidFromTo;    // Valid from XXX to XXX
  LPTSTR  lpszSubjectName;    // Subject's name (same as display name in CERT_DISPLAY_INFO)
  LPTSTR  lpszIssuerName;     // Issuer's name - NULL if no name (self-issued)
  CRYPT_DIGEST_BLOB blobIssuerCertThumbPrint; // The actual certificate thumbprint of the issuer cert
  int     nFieldCount;        // Number of fields for which data exists (other that what we already have)
  LPTSTR* lppszFieldCount;    // LPTSTR array of field names
  LPTSTR* lppszDetails;       // LPTSTR array of details with one to one correspondence with field names
  struct _CertDisplayProps * lpIssuer;  // Next cert up in the issuer chain.
  struct _CertDisplayProps * lpPrev;    // previous cert in the issuer chain.
} CERT_DISPLAY_PROPS, * LPCERT_DISPLAY_PROPS;
/************************************************************************************/


/************************************************************************************/
// This is used by Cert UI elements
typedef struct _CertItem
{
    LPCERT_DISPLAY_INFO lpCDI;
    PCCERT_CONTEXT  pcCert;
    TCHAR szDisplayText[MAX_PATH]; //should really be MAX_UI_STR
    struct _CertItem * lpNext;
    struct _CertItem * lpPrev;
} CERT_ITEM, * LPCERT_ITEM;
/************************************************************************************/


// Function prototypes

//*******************************************************************
//
//  FUNCTION:   HrGetCertsDisplayInfo
//
//  PURPOSE:    Takes an input array of certs in a SPropValue structure
//              and outputs a list of cert data structures by parsing through
//              the array and looking up the cert data in the store.
//
//  PARAMETERS: hwndParent - any UI is modal to this
//              lpPropValue - PR_USER_X509_CERTIFICATE property array
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrGetCertsDisplayInfo(
  IN  HWND hwndParent,
  IN  LPSPropValue lpPropValue,
  OUT LPCERT_DISPLAY_INFO * lppCDI);


//*******************************************************************
//
//  FUNCTION:   HrSetCertsFromDisplayInfo
//
//  PURPOSE:    Takes a linked list of cert data structures and outputs
//              an SPropValue array of PR_USER_X509_CERTIFICATE properties.
//
//  PARAMETERS: lpCDI - linked list of input structures to convert to
//              SPropValue array
//              lpulcPropCount - receives the number of SPropValue's returned
//              Note that this will always be one.
//              lppPropValue - receives a MAPI-allocated SPropValue structure
//              containing an X509_USER_CERTIFICATE property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrSetCertsFromDisplayInfo(
  IN  LPCERT_ITEM lpCItem,
  OUT ULONG * lpulcPropCount,
  OUT LPSPropValue * lppPropValue);


//*******************************************************************
//
//  FUNCTION:   HrGetCertDisplayProps
//
//  PURPOSE:    Get displayable properties and other data for a certificate.
//
//  PARAMETERS: pblobCertThumbPrint - thumb print of certificate to look up
//              hcsCertStore - the store that holds the cert.  Use NULL to
//              open the WAB store.
//              hCryptProvider - the provider to use for store access.  Use
//              zero to get the provider.
//              dwTrust - trust flags for this cert.
//              bIsTrusted - trusted or not ...
//              lppCDP - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayprops.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrGetCertDisplayProps(
  IN  PCRYPT_DIGEST_BLOB  pblobCertThumbPrint,
  IN  HCERTSTORE hcsCertStore,
  IN  HCRYPTPROV hCryptProvider,
  IN  DWORD dwTrust,
  IN  BOOL  bIsTrusted,
  OUT LPCERT_DISPLAY_PROPS * lppCDP);


//*******************************************************************
//
//  FUNCTION:   HrImportCertFromFile
//
//  PURPOSE:    Import a cert from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the cert.
//              lppCDI - recieves an allocated structure  containing
//              the cert data.  Must be freed by calling FreeCertdisplayinfo.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

HRESULT HrImportCertFromFile(
  IN  LPTSTR  lpszFileName,
  OUT LPCERT_DISPLAY_INFO * lppCDI);


//*******************************************************************
//
//  FUNCTION:   HrExportCertToFile
//
//  PURPOSE:    Export a cert to a file.
//
//  PARAMETERS: lpszFileName - name of file in which to store the cert.
//              If the file exists, it will be overwritten, so the caller
//              must verify that this is OK first if so desired.
//              pblobCertThumbPrint - thumb print of certificate to export.
//              lpCertDataBuffer - buffer to write cert data to instead of file 
//              fWriteDataToBuffer - flag indicating where cert data should be written
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//  98/07/22  t-jstaj updated to take 3 add'l parameters, a data buffer, its length 
//                    and flag which will indicate whether or not to 
//                    write data to buffer or file.  The memory allocated to 
//                    to the buffer needs to be freed by caller.
//
//*******************************************************************

HRESULT HrExportCertToFile(
  IN  LPTSTR  lpszFileName,
  IN  PCCERT_CONTEXT pccert,
  OUT LPBYTE *lpCertDataBuffer,
  OUT PULONG  lpcbBufLen,
  IN  BOOL    fWriteDataToBuffer );


//*******************************************************************
//
//  FUNCTION:   FreeCertdisplayinfo
//
//  PURPOSE:    Release memory allocated for a CERT_DISPLAY_INFO structure.
//              Assumes all info in the structure was LocalAlloced
//
//  PARAMETERS: lpCDI - structure to free.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

void FreeCertdisplayinfo(LPCERT_DISPLAY_INFO lpCDI);


//*******************************************************************
//
//  FUNCTION:   FreeCertdisplayprops
//
//  PURPOSE:    Release memory allocated for a CERT_DISPLAY_PROPS structure.
//              THIS INCLUDES the entire linked list below this sturcture,
//              so an entire list can be free by passing in the head of the list.
//              Assumes all info in the structure was LocalAlloced
//
//  PARAMETERS: lpCDP - structure (list) to free.
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/09/24  markdu  Created.
//
//*******************************************************************

void FreeCertdisplayprops(LPCERT_DISPLAY_PROPS lpCDP);


//*******************************************************************
//
//  FUNCTION:   InitCryptoLib
//
//  PURPOSE:    Load the Crypto API libray and get the proc addrs.
//
//  PARAMETERS: None.
//
//  RETURNS:    TRUE if successful, FALSE otherwise.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just use the global
//            library handles.
//
//*******************************************************************

BOOL InitCryptoLib(void);


//*******************************************************************
//
//  FUNCTION:   DeinitCryptoLib
//
//  PURPOSE:    Release the Crypto API libraries.
//
//  PARAMETERS: None.
//
//  RETURNS:    None.
//
//  HISTORY:
//  96/10/01  markdu  Created.
//  96/11/19  markdu  No longer keep a ref count, just call this in
//            DLL_PROCESS_DETACH.
//
//*******************************************************************

void DeinitCryptoLib(void);


//*******************************************************************
//
//  FUNCTION:   HrLDAPCertToMAPICert
//
//  PURPOSE:    Convert cert(s) returned from LDAP server to MAPI props.
//              Two properties are required.  The certs are placed in the
//              WAB store, and all necessary indexing data is placed in
//              PR_USER_X509_CERTIFICATE property.  If this certificate
//              didn't already exist in the WAB store, it's thumbprint is
//              added to PR_WAB_TEMP_CERT_HASH so that these certs can
//              be deleted from the store if the user cancels the add.
//
//  PARAMETERS: lpPropArray - the prop array where the 2 props are stored
//              ulX509Index - the index to the PR_USER_X509_CERTIFICATE prop
//              ulTempCertIndex - the index to the PR_WAB_TEMP_CERT_HASH prop
//              lpCert, cbCert, - cert from LDAP ppberval struct
//              ulcCerts - the number of certs from the LDAP server
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/12  markdu  Created.
//
//*******************************************************************

HRESULT HrLDAPCertToMAPICert(
  LPSPropValue    lpPropArray,
  ULONG           ulX509Index,
  ULONG           ulTempCertIndex,
  ULONG           cbCert,
  PBYTE           lpCert,
  ULONG           ulcCerts);


//*******************************************************************
//
//  FUNCTION:   HrRemoveCertsFromWABStore
//
//  PURPOSE:    Remove the certs whose thumbprints are in the supplied
//              PR_WAB_TEMP_CERT_HASH property.
//
//  PARAMETERS: lpPropValue - the PR_WAB_TEMP_CERT_HASH property
//
//  RETURNS:    HRESULT.
//
//  HISTORY:
//  96/12/13  markdu  Created.
//
//*******************************************************************

HRESULT HrRemoveCertsFromWABStore(
  LPSPropValue    lpPropValue);



//*******************************************************************
//
//  FUNCTION:   DeinitPStore
//
//  PURPOSE:    Release the protected store.
//
//  PARAMETERS: None.
//
//  RETURNS:    None.
//
//  HISTORY:
//  97/02/17  t-erikne  Created.
//
//*******************************************************************

void DeinitPStore(void);

//*******************************************************************
//
//  FUNCTION:   DeleteCertStuff
//
//  PURPOSE:    Remove trust from the pstore and (later) certs from
//              the CAPI store
//
//  PARAMETERS:
//              LPADRBOOK lpIAB - container to use
//              LPENTRYID lpEntryID - eid of item to clean up
//              ULONG cbEntryID - cb of above
//
//  RETURNS:    I promise it does.
//
//  HISTORY:
//  97/03/19  t-erikne  Created.
//
//*******************************************************************
HRESULT DeleteCertStuff(LPADRBOOK lpIAB,
                        LPENTRYID lpEntryID,
                        ULONG cbEntryID);


//*******************************************************************
//
//  FUNCTION:   WabGetCertFromThumbprint
//
//  PURPOSE:    Opens the WAB's cert store and tries to find the cert
//              the CAPI store
//
//  PARAMETERS:
//              CRYPT_DIGEST_BLOB thumbprint - the thumbprint to
//              search on.
//
//  RETURNS:    the cert.  NULL if not found
//
//  HISTORY:
//  97/06/27  t-erikne  Created.
//
//*******************************************************************
PCCERT_CONTEXT WabGetCertFromThumbprint(CRYPT_DIGEST_BLOB thumbprint);


//************************************************************************************
// Crypto function typedefs

//
// Updated as of 2/3
// (t-erikne)
//

// CertAddEncodedCertificateToStore
typedef BOOL (WINAPI * LPCERTADDENCODEDCERTIFICATETOSTORE) (
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppCertContext
    );

// CertCloseStore
typedef BOOL (WINAPI * LPCERTCLOSESTORE) (
  IN HCERTSTORE hCertStore,
  DWORD dwFlags
  );

// CertCreateCertificateContext
typedef PCCERT_CONTEXT (WINAPI * LPCERTCREATECERTIFICATECONTEXT) (
  IN DWORD dwCertEncodingType,
  IN const BYTE *pbCertEncoded,
  IN DWORD cbCertEncoded
  );

// CertDeleteCertificateFromStore
typedef BOOL (WINAPI * LPCERTDELETECERTIFICATEFROMSTORE) (
  IN PCCERT_CONTEXT pCertContext
  );

// CertFindCertificateInStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTFINDCERTIFICATEINSTORE) (
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    );

// CertFreeCertificateContext
typedef BOOL (WINAPI * LPCERTFREECERTIFICATECONTEXT) (
    IN PCCERT_CONTEXT pCertContext
    );

// CertGetCertificateContextProperty
typedef BOOL (WINAPI * LPCERTGETCERTIFICATECONTEXTPROPERTY) (
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

// CertGetIssuerCertificateFromStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTGETISSUERCERTIFICATEFROMSTORE) (
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    );

// CertOpenSystemStore
typedef HCERTSTORE (WINAPI * LPCERTOPENSYSTEMSTORE) (
  HCRYPTPROV      hProv,
  LPTSTR		szSubsystemProtocol
  );

// CertOpenStore
typedef HCERTSTORE (WINAPI * LPCERTOPENSTORE) (
  IN DWORD         dwStoreProvType,
  IN DWORD         dwCertEncodingType,
  IN HCRYPTPROV    hCryptProv,
  IN DWORD         dwFlags,
  IN void *        pvPara
);

// CertEnumCertificatesInStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTENUMCERTIFICATESINSTORE) (
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
);

// CertGetSubjectCertificateFromStore
typedef PCCERT_CONTEXT (WINAPI * LPCERTGETSUBJECTCERTIFICATEFROMSTORE) (
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId
);


// CertCompareCertificate
typedef BOOL (WINAPI * LPCERTCOMPARECERTIFICATE) (
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId1,
    IN PCERT_INFO pCertId2
);

// CertDuplicateCertificateContext
typedef PCCERT_CONTEXT (WINAPI * LPCERTDUPLICATECERTIFICATECONTEXT) (
    IN PCCERT_CONTEXT pCertContext
);

// CertNameToStrA
//N the right thing to do is use WINCRYPT32API
//N and fixt the import stuff
typedef DWORD (WINAPI * LPCERTNAMETOSTR) (
  IN DWORD dwCertEncodingType,
  IN PCERT_NAME_BLOB pName,
  IN DWORD dwStrType,
  OUT OPTIONAL LPTSTR psz,
  IN DWORD csz
  );

// CryptAcquireContext
typedef BOOL (WINAPI * LPCRYPTACQUIRECONTEXT) (
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

// CryptDecodeObject
typedef BOOL (WINAPI * LPCRYPTDECODEOBJECT) (
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    );

// CryptMsgClose
typedef BOOL (WINAPI * LPCRYPTMSGCLOSE) (
    IN HCRYPTMSG hCryptMsg
    );

// CryptMsgGetParam
typedef BOOL (WINAPI * LPCRYPTMSGGETPARAM) (
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

// CryptMsgOpenToDecode
typedef HCRYPTMSG (WINAPI * LPCRYPTMSGOPENTODECODE) (
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );

// CryptMsgUpdate
typedef BOOL (WINAPI * LPCRYPTMSGUPDATE) (
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    );

// CryptReleaseContext
typedef BOOL (WINAPI * LPCRYPTRELEASECONTEXT) (
    HCRYPTPROV hProv,
    DWORD dwFlags);


typedef PCERT_RDN_ATTR (WINAPI * LPCERTFINDRDNATTR) (
    IN LPCSTR pszObjId,
    IN PCERT_NAME_INFO pName
    );

// CertRDNValueToStr
typedef DWORD (WINAPI * LPCERTRDNVALUETOSTR) (
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT LPTSTR pszValueString,
    IN DWORD cszValueString);

// CertVerifyTimeValidity
typedef LONG (WINAPI * LPCERTVERIFYTIMEVALIDITY) (
  IN LPFILETIME pTimeToVerify,
  IN PCERT_INFO pCertInfo);


#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\cntxtmnu.c ===
/**********************************************************************************
*
*
*   contxtmnu.c - contains functions for handling/creating context menu extension 
*
*   Created - 9/97 - vikramm
*
**********************************************************************************/
#include "_apipch.h"

static const TCHAR szActionPropsRegKey[] = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtContext");
BOOL fContextExtCoinit = FALSE;

//$$//////////////////////////////////////////////////////////////////////
//
// UninitContextExtInfo
//
//  OLE Unintialization
//
//////////////////////////////////////////////////////////////////////////
void UninitContextExtInfo()
{
    if(fContextExtCoinit)
    {
        CoUninitialize();
        fContextExtCoinit = FALSE;
    }
}

/*
 - FreeActionItemList
 -
 *  Frees up the Action Items list cached on the IAB object
 *
 */
void FreeActionItemList(LPIAB lpIAB)
{
    LPWABACTIONITEM lpItem = lpIAB->lpActionList;
    while(lpItem)
    {
        lpIAB->lpActionList = lpItem->lpNext;
        SafeRelease(lpItem->lpWABExtInit);
        SafeRelease(lpItem->lpContextMenu);
        LocalFree(lpItem);
        lpItem = lpIAB->lpActionList;
    }
    lpIAB->lpActionList = NULL;
}


/*
 - HrUpdateActionItemList
 -
 *  Apps can register with the WAB for rt-click and toolbar Action items
 *  We load a list of registered action items here upfront and cache it on
 *  the IAB object. 
 *
 */

HRESULT HrUpdateActionItemList(LPIAB lpIAB)
{
    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;
    LPWABACTIONITEM lpList = NULL;
    DWORD dwIndex = 0, dwSize = 0;
    int nCmdID = IDM_EXTENDED_START, nActionItems = 0;

    EnterCriticalSection(&lpIAB->cs);

    if(lpIAB->lpActionList)
        FreeActionItemList(lpIAB);

    lpIAB->lpActionList = NULL;

    // 
    // We will look in the registry under HKLM\Software\Microsoft\WAB\WAB4\Actions
    // If this key exists, we get all the key values under it - these key values
    // are all GUIDs
    // The format for this key is
    //
    // HKLM\Software\Microsoft\WAB\WAB4\Action Extensions
    //              GUID1
    //              GUID2
    //              GUID3 etc
    //

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    szActionPropsRegKey,
                                    0, KEY_READ,&hKey))
    {
        goto out;
    }

    {
        // Enumerate the GUIDs under this key one by one
        //
        TCHAR szGUIDName[MAX_PATH];
        DWORD dwGUIDIndex = 0, dwGUIDSize = CharSizeOf(szGUIDName), dwType = 0;

        *szGUIDName = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwGUIDIndex, 
                                            szGUIDName, &dwGUIDSize, 
                                            0, &dwType, 
                                            NULL, NULL))
        {
            // The values under this entry are all GUIDs
            // Read the GUID string and translate it into a GUID
            //
            GUID guidTmp = {0};
            WCHAR szW[MAX_PATH];
            StrCpyNW(szW, szGUIDName, ARRAYSIZE(szW));
            if( !(HR_FAILED(hr = CLSIDFromString(szW, &guidTmp))) )
            {
                LPWABACTIONITEM lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(WABACTIONITEM));
                if(!lpTemp)
                {
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }
                // Temporarily cache the GUID
                CopyMemory(&(lpTemp->guidContextMenu), &guidTmp, sizeof(GUID));
                lpTemp->lpNext = lpList;
                lpList = lpTemp;
            }

            dwGUIDIndex++;
            *szGUIDName = '\0';
            dwGUIDSize = CharSizeOf(szGUIDName);
        }
    }

    if(lpList)
    {
        // If we have a list of GUIDs from the registry, we now
        // need to open CoCreateInstance them one by one and get a handle
        // to their method pointers
        LPWABACTIONITEM lpItem = lpList;

        if (CoInitialize(NULL) == S_FALSE) 
            CoUninitialize(); // Already initialized, undo the extra.
        else
            fContextExtCoinit = TRUE;

        while(lpItem)
        {
            hr = CoCreateInstance(  &(lpItem->guidContextMenu), 
                                    NULL, 
                                    CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                    &IID_IContextMenu, 
                                    (LPVOID *)&(lpItem->lpContextMenu));
            if(lpItem->lpContextMenu && !HR_FAILED(hr))
            {
                // Found an IContextMenu object, aslo want a IWABExtInit object
                hr = lpItem->lpContextMenu->lpVtbl->QueryInterface(lpItem->lpContextMenu,
                                                        &IID_IWABExtInit,
                                                        (LPVOID *)&(lpItem->lpWABExtInit));
                if(HR_FAILED(hr) || !lpItem->lpWABExtInit)
                {
                    // Can't work without an IWABExtInit object
                    SafeRelease(lpItem->lpContextMenu);
                }
            }
            else
            {
                hr = S_OK; //ignore error
                lpItem->lpContextMenu = NULL;
            }
            lpItem = lpItem->lpNext;
        }
    }

    lpIAB->lpActionList = lpList;

    hr = S_OK;
out:
    if(hKey)
        RegCloseKey(hKey);

    LeaveCriticalSection(&lpIAB->cs);

    return hr;
}

/*
 - GetActionAdrList
 -
 *  Based on the parameters for a particular rt-click action,
 *  scans the entries in the list view and creates an adrlist
 *  for the entries
 *  
 *  If only one entry is selected and it is an LDAP entry, then
 *  also creates an LDAP URL representing that entry .. this way
 *  if we are displaying properties or doing actions on a single
 *  entry, the property sheet extenstions can determine if they 
 *  want to do anything extra for the entry. People most interested
 *  in this are the NTDS
 *  
 *  For now,we only look at the selected items in the list view
 *
    lpAdrBook   - IAB object
    hWndLV      - the list view on which this action was initiated
    *lppAdrList - created AdrList
    *lpURL      - returned URL
    *lpbIsNTDSEntry - flag NTDS entries so they can be special treated

  Note performance suffers for a large number of entries so we want to 
  really only return a list of entryids
 */
HRESULT HrGetActionAdrList(LPADRBOOK lpAdrBook,
                        HWND hWndLV,   
                        LPADRLIST * lppAdrList,
                        LPTSTR * lppURL, BOOL * lpbIsNTDSEntry)
{
    HRESULT hr = S_OK;
    LPADRLIST lpAdrList = NULL;
    int i = 0, iItemIndex  = 0, nIndex= 0;
    int nSel = ListView_GetSelectedCount(hWndLV);
    SCODE sc;
    if(!nSel)
        goto out;

    sc = MAPIAllocateBuffer(sizeof(ADRLIST) + nSel * sizeof(ADRENTRY), &lpAdrList);
    
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    // Get index of selected item
    iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);

    while(iItemIndex != -1)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);

        if(lpItem)
        {
            ULONG ulObjType = 0;
            LPSPropValue lpProps = NULL;
            LPMAILUSER lpEntry = NULL;
            ULONG cValues = 0;

            if(lpItem->cbEntryID && lpItem->lpEntryID)
            {
                if (hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                  lpItem->cbEntryID,
                                                  lpItem->lpEntryID,
                                                  NULL,         // interface
                                                  0,            // flags
                                                  &ulObjType,
                                                  (LPUNKNOWN *)&lpEntry))
                {
                    goto out;
                }
                hr = lpEntry->lpVtbl->GetProps( lpEntry, NULL, MAPI_UNICODE, 
                                                &cValues, &lpProps);
                if(HR_FAILED(hr))
                {
                    UlRelease(lpEntry);
                    goto out;
                }
                lpAdrList->aEntries[nIndex].cValues = cValues;
                lpAdrList->aEntries[nIndex].rgPropVals = lpProps;
                nIndex++;

                UlRelease(lpEntry);

                if(nSel == 1 && lppURL)
                {
                    CreateLDAPURLFromEntryID(lpItem->cbEntryID, lpItem->lpEntryID, 
                                             lppURL, lpbIsNTDSEntry);
                }
            }
        }
        iItemIndex = ListView_GetNextItem(hWndLV,iItemIndex,LVNI_SELECTED);
    }

    lpAdrList->cEntries = nIndex;
    *lppAdrList = lpAdrList;
    lpAdrList = NULL;
    hr = S_OK;
   
out:    
    if (lpAdrList)
        MAPIFreeBuffer(lpAdrList);

    return hr;
}

extern void MAILUSERAssociateContextData(LPMAILUSER lpMailUser, LPWABEXTDISPLAY lpWEC);
/*
-   HrCreateContextDataStruct
-
*   Creates the data necessary to initialize a ContextMenu implementor
*   This structure is passed into the IWABExtInit::Initialize call
*
    hWndLV      - ListView containing the WAB entries
    lppWABExt   - returned data
*/
HRESULT HrCreateContextDataStruct(  LPIAB lpIAB, 
                                    HWND hWndLV, 
                                    LPWABEXTDISPLAY * lppWABExt)
{
    LPADRLIST lpAdrList = NULL;
    LPWABEXTDISPLAY lpWEC = NULL;
    LPMAILUSER lpMailUser = NULL;
    LPTSTR lpURL = NULL;
    BOOL bIsNTDSEntry = FALSE;

    HRESULT hr = E_FAIL;

    // Get an AdrList Corresponding to the LV contents
    hr = HrGetActionAdrList((LPADRBOOK)lpIAB, hWndLV, &lpAdrList, &lpURL, &bIsNTDSEntry);
    if(HR_FAILED(hr) || !lpAdrList || !lpAdrList->cEntries)
        goto out; //dont bother invoking

    // Create a dummy mailuser so callers can call GetIDsFromNames
    // on this dummy mailuser - saves them the trouble of creating entries
    // just to call GetIDsFromNames
    hr = HrCreateNewObject((LPADRBOOK)lpIAB, NULL, MAPI_MAILUSER, CREATE_CHECK_DUP_STRICT, (LPMAPIPROP *) &lpMailUser);
    if(HR_FAILED(hr))
        goto out; //dont bother invoking

    lpWEC = LocalAlloc(LMEM_ZEROINIT, sizeof(WABEXTDISPLAY));
    if(!lpWEC)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpWEC->cbSize       = sizeof(WABEXTDISPLAY);
    lpWEC->ulFlags      = WAB_CONTEXT_ADRLIST; // indicates ADRLIST is valid and in the lpv member
    lpWEC->lpAdrBook    = (LPADRBOOK) lpIAB;
    lpWEC->lpWABObject  = (LPWABOBJECT) lpIAB->lpWABObject;
    lpWEC->lpPropObj    = (LPMAPIPROP) lpMailUser;
    lpWEC->lpv          = (LPVOID) lpAdrList;

    if(lpURL && lstrlen(lpURL))
    {
        lpWEC->lpsz = lpURL;
        lpWEC->ulFlags |= WAB_DISPLAY_LDAPURL;
        lpWEC->ulFlags |= MAPI_UNICODE;
        if(bIsNTDSEntry)
            lpWEC->ulFlags |= WAB_DISPLAY_ISNTDS;
    }

    // We associate this entire WABEXT structure with the mailuser
    // so that when we get the IMailUser release, we can go ahead and clean
    // up all the WABEXT memory .. since there is no other good time that we can
    // free the memory since we won't know who is doing what withthe structure.
    // Freeing it at IMailUser::Release time works out quite well
    MAILUSERAssociateContextData(lpMailUser, lpWEC);

    //
    // Cache this mailUser on the IAB object
    //
    // At any given point of time, we are going to cache one ContextMenu related MailUser
    // This is because we set this up before QueryCommandMenu and then we dont know whether
    // or not the user actually managed to select a menu item, or went off and did something new.
    // We set the data on a MailUser and we don't release the MailUser till the next time we are
    // here. If someone is currently using the MailUser, they will addref it - the memory attached
    // to the MailUser will be freed up with the last caller so we dont leak it ..
    // If we never come back here, the mailuser will be released at shutdown
    //
    UlRelease(lpIAB->lpCntxtMailUser);
    lpIAB->lpCntxtMailUser = lpMailUser;

    *lppWABExt = lpWEC;
    hr = S_OK;
out:

    if(HR_FAILED(hr))
    {
        UlRelease(lpMailUser);
        if(lpAdrList)
            FreePadrlist(lpAdrList);
        if(lpWEC)
            LocalFree(lpWEC);
    }
    return hr;
}

//$$////////////////////////////////////////////////////////////////////////////
//
//  AddExtendedMenuItems -  Creates a list of extension menu items and adds them 
//              to the specified menu
//
//  hMenuAction - menu on which to add this item
//  bUpdateStatus - if TRUE, means only find the existing item in the menu and update
//      its status - if FALSE, means add to the menu
//  bAddSendMailToItems - if TRUE, means attempt to modify the SendMailTo menu item
//
//////////////////////////////////////////////////////////////////////////////
void AddExtendedMenuItems(  LPADRBOOK lpAdrBook, 
                            HWND hWndLV, 
                            HMENU hMenuAction, 
                            BOOL bUpdateStatus, 
                            BOOL bAddSendMailToItems)
{
    HRESULT hr = S_OK;
    LPWABEXTDISPLAY lpWEC = NULL;
    LPIAB lpIAB = (LPIAB) lpAdrBook;

    // Intialize the context menu extensions
    if(!lpIAB->lpActionList)
        HrUpdateActionItemList(lpIAB);

    if(bUpdateStatus)
    {
        // This is only set to true from the call from ui_abook.c which means this
        // is the Tools Menu item we are talking about.
        // To update the status of the Tools menu item, we need to remove all the
        // items we added before and then re-add them
        // For indexing purposes, we will assume that the last pre-configured item in
        // this list is the Internet Call item (since this menu list is quite variable)

        // First get the position of the IDM_TOOLS_INTERNET_CALL item
        int i, nPos = -1, nId = 0;
        int nCmdCount = GetMenuItemCount(hMenuAction); // Append all items at end of this menu
        for(i=0;i<nCmdCount;i++)
        {
            if(GetMenuItemID(hMenuAction, i) == IDM_TOOLS_INTERNET_CALL)
            {
                nPos = i;
                break;
            }
        }
        if(nPos >= 0 && nPos < nCmdCount-1)
        {
            for(i=nPos+1;i<nCmdCount;i++)
            {
                DeleteMenu(hMenuAction, nPos+1, MF_BYPOSITION);
            }
        }
    }

    // Do any special treatment we need to do for SendMailTo
    AddExtendedSendMailToItems(lpAdrBook, hWndLV, hMenuAction, bAddSendMailToItems);


    // Before we can call QueryContextMenu - we must already have a list of all
    // the selected items from the ListView and provide such items to the ContextMenu
    // implementors so that they can decide how to handle the data being provided to them
    // (e.g. they may want to disable their item for multi-selections etc)...
    //
    HrCreateContextDataStruct(lpIAB, hWndLV, &lpWEC);
    
    if(lpIAB->lpActionList && lpWEC && lpWEC->lpv)
    {
        LPWABACTIONITEM lpItem = lpIAB->lpActionList;
        int nCmdIdPos = GetMenuItemCount(hMenuAction); // Append all items at end of this menu
        while(lpItem)
        {
            if(lpItem->lpContextMenu && lpItem->lpWABExtInit)// && !bUpdateStatus)
            {
                int nNumCmd = 0;
                // Get the menu item added to this menu
                hr = lpItem->lpWABExtInit->lpVtbl->Initialize(lpItem->lpWABExtInit, lpWEC);
                if(!HR_FAILED(hr))
                {
                    hr = lpItem->lpContextMenu->lpVtbl->QueryContextMenu(lpItem->lpContextMenu,
                                                                    hMenuAction,
                                                                    nCmdIdPos,
                                                                    lpItem->nCmdIdFirst ? lpItem->nCmdIdFirst : IDM_EXTENDED_START+nCmdIdPos,
                                                                    IDM_EXTENDED_END,
                                                                    CMF_NODEFAULT | CMF_NORMAL);
                    if(!HR_FAILED(hr))
                    {
                        nNumCmd = HRESULT_CODE(hr);
                        if(nNumCmd)
                        {
                            // Record the range of IDs taken up by this menu ext implementor
                            if(!lpItem->nCmdIdFirst)
                                lpItem->nCmdIdFirst = nCmdIdPos+IDM_EXTENDED_START;
                            if(!lpItem->nCmdIdLast)
                                lpItem->nCmdIdLast = lpItem->nCmdIdFirst + nNumCmd - 1;
                        }    
                        // Update the next available starting pos
                        nCmdIdPos = nCmdIdPos+nNumCmd;
                    }
                }
            }
            lpItem = lpItem->lpNext;
        }
    }
}




/*
 - ProcessActionCommands
 -
 *  Process a WM_COMMAND message to see if it matches any of the extended
 *  rt-click action items ...
 *
 *  Also process SendMailTo extended email-address mail processing here since
 *  this is a convenient place to do so ..
 *  
 */
LRESULT ProcessActionCommands(LPIAB lpIAB, HWND  hWndLV, HWND  hWnd,  
                              UINT  uMsg, WPARAM  wParam, LPARAM lParam)
{
    int nCmdID = GET_WM_COMMAND_ID(wParam, lParam);
    int i = 0;

    switch(nCmdID)
    {
    case IDM_DIALDLG_START:
        HrExecDialDlg(hWndLV, (LPADRBOOK)lpIAB);
        return 0;
        break;
    case IDM_LVCONTEXT_INTERNET_CALL:
    case IDM_TOOLS_INTERNET_CALL:
        HrShellExecInternetCall((LPADRBOOK)lpIAB, hWndLV);
        return 0;
        break;

    case IDM_LVCONTEXT_SENDMAIL:
	case IDM_FILE_SENDMAIL:
        HrSendMailToSelectedContacts(hWndLV, (LPADRBOOK)lpIAB, 0);
        break;
    }
        
    if( (nCmdID>=IDM_SENDMAILTO_START) && (nCmdID<=IDM_SENDMAILTO_START+IDM_SENDMAILTO_MAX))
    {
        HrSendMailToSelectedContacts(hWndLV, (LPADRBOOK)lpIAB, nCmdID - IDM_SENDMAILTO_START);
        return 0;
    }

    // Check if this is any of the context menu extensions ..
    if(lpIAB->lpActionList)
    {
        LPWABACTIONITEM lpListItem = lpIAB->lpActionList;
        while(lpListItem)
        {
            if(nCmdID >= lpListItem->nCmdIdFirst && nCmdID <= lpListItem->nCmdIdLast)
            {
                CMINVOKECOMMANDINFO cmici = {0};
                cmici.cbSize        = sizeof(CMINVOKECOMMANDINFO);
                cmici.fMask         = 0;
                cmici.hwnd          = hWnd;
                cmici.lpVerb        = (LPCSTR) IntToPtr(nCmdID - lpListItem->nCmdIdFirst);
                cmici.lpParameters  = NULL;
                cmici.lpDirectory   = NULL;
                cmici.nShow         = SW_SHOWNORMAL; 

                lpListItem->lpContextMenu->lpVtbl->InvokeCommand(lpListItem->lpContextMenu,
                                                                &cmici);
                return 0;
            }
            lpListItem = lpListItem->lpNext;
        }
    }
    return DefWindowProc(hWnd,uMsg,wParam,lParam);
}


/*
 - GetContextMenuExtCommandString
 -
 *  gets the status bar helptext for context menu extensions
 *  
 */
void GetContextMenuExtCommandString(LPIAB lpIAB, int nCmdId, LPTSTR sz, ULONG cbsz)
{
    int nStringID = 0;

    switch(nCmdId)
    {            
        case IDM_DIALDLG_START:
            nStringID = idsMenuDialer;    
            break;       
        case IDM_LVCONTEXT_INTERNET_CALL:
        case IDM_TOOLS_INTERNET_CALL:
            nStringID = idsMenuInternetCall;
            break;
        case IDM_LVCONTEXT_SENDMAIL:
        case IDM_FILE_SENDMAIL:
            nStringID = idsMenuSendMail;
            break;
    }
    if(nStringID)
    {
        LoadString(hinstMapiX, nStringID, sz, cbsz);
        return;
    }

    if(lpIAB->lpActionList)
    {
        LPWABACTIONITEM lpListItem = lpIAB->lpActionList;
        while(lpListItem)
        {
            if(nCmdId >= lpListItem->nCmdIdFirst && nCmdId <= lpListItem->nCmdIdLast)
            {
                char szC[MAX_PATH];
                ULONG cbszC = CharSizeOf(szC);
                lpListItem->lpContextMenu->lpVtbl->GetCommandString(lpListItem->lpContextMenu,
                                                                    nCmdId - lpListItem->nCmdIdFirst,
                                                                    GCS_HELPTEXT,
                                                                    NULL,
                                                                    szC,
                                                                    cbszC);
                {
                    LPTSTR lp = ConvertAtoW(szC);
                    if(lp)
                    {
                        StrCpyN(sz, lp, cbsz);
                        LocalFreeAndNull(&lp);
                    }
                }
                break;
            }
            lpListItem = lpListItem->lpNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\contable.c ===
/*
 *	CONTABLE.C
 *
 *	Contents table implementation.
 *	
 */

#include "_apipch.h"


STDMETHODIMP
CONTVUE_SetColumns(
	LPVUE			lpvue,
	LPSPropTagArray	lpptaCols,
	ULONG			ulFlags );

// CONTVUE (table view class)
// Implementes in-memory IMAPITable class on top of TADs
// This is a copy of vtblVUE with FindRow overridden with the LDAP FindRow.
VUE_Vtbl vtblCONTVUE =
{
  VTABLE_FILL
  (VUE_QueryInterface_METHOD FAR *)    UNKOBJ_QueryInterface,
  (VUE_AddRef_METHOD FAR *)            UNKOBJ_AddRef,
  VUE_Release,
  (VUE_GetLastError_METHOD FAR *)      UNKOBJ_GetLastError,
  VUE_Advise,
  VUE_Unadvise,
  VUE_GetStatus,
  (VUE_SetColumns_METHOD FAR *)        CONTVUE_SetColumns,
  VUE_QueryColumns,
  VUE_GetRowCount,
  VUE_SeekRow,
  VUE_SeekRowApprox,
  VUE_QueryPosition,
  VUE_FindRow,
  VUE_Restrict,
  VUE_CreateBookmark,
  VUE_FreeBookmark,
  VUE_SortTable,
  VUE_QuerySortOrder,
  VUE_QueryRows,
  VUE_Abort,
  VUE_ExpandRow,
  VUE_CollapseRow,
  VUE_WaitForCompletion,
  VUE_GetCollapseState,
  VUE_SetCollapseState
};


//
//  Private functions
//



/***************************************************************************

    Name      : GetEntryProps

    Purpose   : Open the entry, get it's props, release the entry

    Parameters: lpContainer -> AB Container object
                cbEntryID = size of entryid
                lpEntryID -> entry id to open
                lpPropertyStore -> property store structure
                lpSPropTagArray -> prop tags to get
                lpAllocMoreHere = buffer to allocate more onto (or NULL for allocbuffer)
                ulFlags - 0 or MAPI_UNICODE
                lpulcProps -> return count of props here
                lppSPropValue -> return props here

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT GetEntryProps(
  LPABCONT lpContainer,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPSPropTagArray lpSPropTagArray,
  LPVOID lpAllocMoreHere,            // allocate more on here
  ULONG ulFlags,
  LPULONG lpulcProps,                      // return count here
  LPSPropValue * lppSPropValue) {          // return props here

    HRESULT hResult = hrSuccess;
    SCODE sc;
    ULONG ulObjType;
    LPMAPIPROP lpObject = NULL;
    LPSPropValue lpSPropValue = NULL;
    ULONG cb;


    if (HR_FAILED(hResult = lpContainer->lpVtbl->OpenEntry(lpContainer,
      cbEntryID,
      lpEntryID,
      NULL,
      0,        // read only is fine
      &ulObjType,
      (LPUNKNOWN *)&lpObject))) {
        DebugTrace(TEXT("GetEntryProps OpenEntry failed %x\n"), GetScode(hResult));
        return(hResult);
    }

    if (HR_FAILED(hResult = lpObject->lpVtbl->GetProps(lpObject,
      lpSPropTagArray,
      ulFlags,
      lpulcProps,
      &lpSPropValue))) {
        DebugTrace(TEXT("GetEntryProps GetProps failed %x\n"), GetScode(hResult));
        goto exit;
    }


    // Allocate more for our return buffer
    if (FAILED(sc = ScCountProps(*lpulcProps, lpSPropValue, &cb))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    if (FAILED(sc = MAPIAllocateMore(cb, lpAllocMoreHere, lppSPropValue))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    if (FAILED(sc = ScCopyProps(*lpulcProps, lpSPropValue, *lppSPropValue, NULL))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

exit:
    FreeBufferAndNull(&lpSPropValue);

    UlRelease(lpObject);

    return(hResult);
}


/***************************************************************************

    Name      : FillTableDataFromPropertyStore

    Purpose   : Fill in a TableData object from the property store

    Parameters: lpIAB
                lppta -> prop tags to get
                lpTableData

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT FillTableDataFromPropertyStore(LPIAB lpIAB, 
                                       LPSPropTagArray lppta, 
                                       LPTABLEDATA lpTableData) 
{
    HRESULT hResult = S_OK;
    SCODE sc;
    LPSRowSet lpSRowSet = NULL;
    LPSPropValue lpSPropValue = NULL;
    LPTSTR lpTemp = NULL;
    ULONG i, j, k;
    LPCONTENTLIST * lppContentList = NULL;
    LPCONTENTLIST lpContentList = NULL;
    ULONG ulContainers = 1;
    SPropertyRestriction PropRes = {0};
    ULONG nLen = 0;
    ULONG ulInvalidPropCount = 0;
    ULONG ulcPropCount;
    ULONG iToAdd;
    ULONG iPR_ENTRYID = (ULONG)-1;
    ULONG iPR_RECORD_KEY = (ULONG)-1;
    ULONG iPR_INSTANCE_KEY = (ULONG)-1;
    LPSPropTagArray lpptaNew = NULL;
    LPSPropTagArray lpptaRead;
    BOOL bUnicodeData = ((LPTAD)lpTableData)->bMAPIUnicodeTable;

    // Make certain that we have required properties:
    //   PR_ENTRYID
    //   PR_RECORD_KEY
    //   PR_INSTANCE_KEY

    // walk through pta looking for required props
    iToAdd = 3;
    for (i = 0; i < lppta->cValues; i++) {
        switch (lppta->aulPropTag[i]) {
            case PR_ENTRYID:
                iPR_ENTRYID = i;
                iToAdd--;
                break;

            case PR_RECORD_KEY:
                iPR_RECORD_KEY = i;
                iToAdd--;
                break;

            case PR_INSTANCE_KEY:
                iPR_INSTANCE_KEY = i;
                iToAdd--;
                break;
        }
    }

    if (iToAdd) {
        if (lpptaNew = LocalAlloc(LPTR, sizeof(SPropTagArray) + (lppta->cValues + iToAdd) * sizeof(DWORD))) {
            // Copy the caller's pta into our new one
            lpptaNew->cValues = lppta->cValues;
            CopyMemory(lpptaNew->aulPropTag, lppta->aulPropTag, lppta->cValues * sizeof(DWORD));

            // Add them on at the end.
            if (iPR_ENTRYID == (ULONG)-1) {
                iPR_ENTRYID = lpptaNew->cValues++;
                lpptaNew->aulPropTag[iPR_ENTRYID] = PR_NULL;
            }
            if (iPR_RECORD_KEY == (ULONG)-1) {
                iPR_RECORD_KEY = lpptaNew->cValues++;
                lpptaNew->aulPropTag[iPR_RECORD_KEY] = PR_NULL;
            }
            if (iPR_INSTANCE_KEY == (ULONG)-1) {
                iPR_INSTANCE_KEY = lpptaNew->cValues++;
                lpptaNew->aulPropTag[iPR_INSTANCE_KEY] = PR_NULL;
            }
            lpptaRead = lpptaNew;
        } else {
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    } else {
        lpptaRead = lppta;
    }

    Assert(iPR_ENTRYID != (ULONG)-1);
    Assert(iPR_RECORD_KEY!= (ULONG)-1);
    Assert(iPR_INSTANCE_KEY != (ULONG)-1);

    //
    // Set filter criteria if none exists - we'll default to DisplayName
    //
    PropRes.ulPropTag = PR_DISPLAY_NAME;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = NULL;

{
// The way we want GetContentsTable to behave is:
//
//  If no profilesAPI enabled and no override, then GetContentsTable works as before and returns
//      full set of contents for the current WAB [This is for the PAB container only]
// In cases where old clients dont know how to invoke the new API, the UI will have new stuff
// but the API should have the old stuff meaning that a GetContentsTable on the PAB 
// container should return full WAB contents. To make sure that the GetContentsTable on the
// PAB container doesn't contain full contents, caller can force this by passing in 
// WAB_ENABLE_PROFILES into the call to GetContentsTable...
//
//  If profilesAPI are enabled, then GetContentsTable only returns the contents of
//      the specified folder/container
//  unless the folder has a NULL entryid in which case we want to get ALL WAB contents
//      so we can pump them into the "All Contacts" ui item ..
// 
//  If ProfilesAPI and WAB_PROFILE_CONTENTS are specified and it's the PAB container
//      then we need to return all the contents pertaining to the current profile
//  
//
//
        SBinary sbEID = {0};
        LPSBinary lpsbEID = ((LPTAD)lpTableData)->pbinContEID;
        BOOL bProfileContents = FALSE;
        
        // Is this a 'new' WAB showing folders and stuff ?
        if(bIsWABSessionProfileAware(lpIAB))
        {
            // If this WAB is identity aware or we were asked to 
            // restrict the contents to a single container, then try to 
            // get the entryid for that container
            if( bAreWABAPIProfileAware(lpIAB) || 
                ((LPTAD)lpTableData)->bContainerContentsOnly)
            {
                if(!lpsbEID)
                    lpsbEID = &sbEID;
            }

            // if we earlier, during GetContentsTable specified that we
            // want the full contents for the current profile (which means
            // iterating through all the folders in this profile), we should
            // look into this ..
            if(((LPTAD)lpTableData)->bAllProfileContents)
            {
                ulContainers = lpIAB->cwabci;
                bProfileContents = TRUE;
            }
        }

        // Allocate a temporary list in which we will get each containers contents
        // seperately - later we will collate all these seperate content-lists 
        // together
        lppContentList = LocalAlloc(LMEM_ZEROINIT, sizeof(LPCONTENTLIST)*ulContainers);
        if(!lppContentList)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        //
        // Get the content list
        //
        if(!bProfileContents)
        {
            // if we don't care about profile and profile folders, 
            // just get the bunch'o'contents from the store
            if (HR_FAILED(hResult = ReadPropArray(lpIAB->lpPropertyStore->hPropertyStore,
                                            lpsbEID,
                                            &PropRes,
                                            AB_MATCH_PROP_ONLY | (bUnicodeData?AB_UNICODE:0),
                                            lpptaRead->cValues,
                                            (LPULONG)lpptaRead->aulPropTag,
                                            &(lppContentList[0])))) 
            {
                DebugTraceResult( TEXT("NewContentsTable:ReadPropArray"), hResult);
                goto exit;
            }
        }
        else
        {
            // We need to collate together all the contents of all the containers for this profile
            //
            // The first item is the Virtual PAB "Shared Contacts" folder .. we want the contents of this
            // item as part of this ContentsTable by default. This item has a special entryid of 0, NULL so we 
            // can diffrentiate it from the rest of the pack..
            //
            for(i=0;i<ulContainers;i++)
            {
                hResult = ReadPropArray(lpIAB->lpPropertyStore->hPropertyStore,
                                        lpIAB->rgwabci[i].lpEntryID ? lpIAB->rgwabci[i].lpEntryID : &sbEID,
                                        &PropRes,
                                        AB_MATCH_PROP_ONLY | (bUnicodeData?AB_UNICODE:0),
                                        lpptaRead->cValues,
                                        (LPULONG)lpptaRead->aulPropTag,
                                        &(lppContentList[i]));
                // ignore MAPI_E_NOT_FOUND errors here ...
                if(HR_FAILED(hResult))
                {
                    if(hResult == MAPI_E_NOT_FOUND)
                        hResult = S_OK;
                    else
                    {
                        DebugTraceResult( TEXT("NewContentsTable:ReadPropArray"), hResult);
                        goto exit;
                    }
                }
            }
        }
    }

    for(k=0;k<ulContainers;k++)
    {
        lpContentList = lppContentList[k];

        if(lpContentList)
        {
            // Now we need to move the information from the index to
            // the SRowSet.  In the process, we need to create a few computed
            // properties:
            //  PR_DISPLAY_TYPE ?
            //  PR_INSTANCE_KEY
            //  PR_RECORD_KEY
            // Allocate the SRowSet
            if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + lpContentList->cEntries * sizeof(SRow),
                                              &lpSRowSet))) 
            {
                DebugTrace(TEXT("Allocation of SRowSet failed\n"));
                hResult = ResultFromScode(sc);
                goto exit;
            }

            lpSRowSet->cRows = lpContentList->cEntries;

            for (i = 0; i < lpContentList->cEntries; i++) 
            {
                //
                // We look at each of the returned entries - if they dont have a prop
                // we set that prop to " "
                // (Assuming these are all string props)
                //
                lpSPropValue = lpContentList->aEntries[i].rgPropVals;
                ulcPropCount = lpContentList->aEntries[i].cValues;

                // DebugProperties(lpSPropValue, ulcPropCount, "Raw");
                for (j = 0; j < ulcPropCount; j++) 
                {
                    // Get rid of error valued properties
                    if (PROP_ERROR(lpSPropValue[j])) {
                        lpSPropValue[j].ulPropTag = PR_NULL;
                    }
                }

                // Make certain we have proper indicies.
                // For now, we will equate PR_INSTANCE_KEY and PR_RECORD_KEY to PR_ENTRYID.

                if(lpSPropValue[iPR_INSTANCE_KEY].ulPropTag != PR_INSTANCE_KEY)
                {
                    lpSPropValue[iPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
                    SetSBinary( &lpSPropValue[iPR_INSTANCE_KEY].Value.bin,
                                lpSPropValue[iPR_ENTRYID].Value.bin.cb,
                                lpSPropValue[iPR_ENTRYID].Value.bin.lpb);
                }

                if(lpSPropValue[iPR_RECORD_KEY].ulPropTag != PR_RECORD_KEY)
                {
                    lpSPropValue[iPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY;
                    SetSBinary( &lpSPropValue[iPR_RECORD_KEY].Value.bin,
                                lpSPropValue[iPR_ENTRYID].Value.bin.cb,
                                lpSPropValue[iPR_ENTRYID].Value.bin.lpb);
                }

                // Put it in the RowSet
                lpSRowSet->aRow[i].cValues = ulcPropCount;  // number of properties
                lpSRowSet->aRow[i].lpProps = lpSPropValue;  // LPSPropValue

            } //for i

            hResult = lpTableData->lpVtbl->HrModifyRows(lpTableData,0,lpSRowSet);

            FreeBufferAndNull(&lpSRowSet);
        } // for k
    }

exit:
    for(i=0;i<ulContainers;i++)
    {
        lpContentList = lppContentList[i];
        if (lpContentList) {
            FreePcontentlist(lpIAB->lpPropertyStore->hPropertyStore, lpContentList);
        }
    }

    if(lppContentList)
        LocalFree(lppContentList);

    if(lpptaNew)
        LocalFree(lpptaNew);

    return(hResult);
}


/***************************************************************************

    Name      : NewContentsTable

    Purpose   : Creates a new contents table

    Parameters:
                lpABContainer   - container being opened
                lpIAB           - AdrBook object
                ulFlags         - WAB_NO_CONTENTTABLE_DATA
                lpInteface ?
                lppTble         - returned table

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT NewContentsTable(LPABCONT lpABContainer,
  LPIAB lpIAB,
  ULONG ulFlags,
  LPCIID lpInterface,
  LPMAPITABLE * lppTable) {
    LPTABLEDATA lpTableData = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc;


#ifndef DONT_ADDREF_PROPSTORE
        if ((FAILED(sc = OpenAddRefPropertyStore(NULL, lpIAB->lpPropertyStore)))) {
            hResult = ResultFromScode(sc);
            goto exitNotAddRefed;
        }
#endif

    if (FAILED(sc = CreateTableData(
      NULL,                                 // LPCIID
      (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *) MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,                                 // lpvReserved,
      TBLTYPE_DYNAMIC,                      // ulTableType,
      PR_RECORD_KEY,                        // ulPropTagIndexCol,
      (LPSPropTagArray)&ITableColumns,      // LPSPropTagArray lpptaCols,
      lpIAB,                                // lpvDataSource
      0,                                    // cbDataSource
      ((LPCONTAINER)lpABContainer)->pmbinOlk,
      ulFlags,
      &lpTableData))) {                     // LPTABLEATA FAR * lplptad
        DebugTrace(TEXT("CreateTable failed %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }


    if (lpTableData) 
    {
        if(!(ulFlags & WAB_CONTENTTABLE_NODATA))
        {
            // Fill in the data from the property store
            if (hResult = FillTableDataFromPropertyStore(lpIAB,
              (LPSPropTagArray)&ITableColumns, lpTableData)) {
                DebugTraceResult( TEXT("NewContentsTable:FillTableFromPropertyStore"), hResult);
                goto exit;
            }
        }
    }

    if (hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
      NULL,                     // LPSSortOrderSet lpsos,
      ContentsViewGone,         //  CALLERRELEASE FAR *	lpfReleaseCallback,
      0,                        //  ULONG				ulReleaseData,
      lppTable)) {              //  LPMAPITABLE FAR *	lplpmt)
        goto exit;
    }

    // Replace the vtable with our new one that overrides SetColumns
    (*lppTable)->lpVtbl = (IMAPITableVtbl FAR *)&vtblCONTVUE;


exit:
#ifndef DONT_ADDREF_PROPSTORE
    ReleasePropertyStore(lpIAB->lpPropertyStore);
exitNotAddRefed:
#endif

    // Cleanup table if failure
    if (HR_FAILED(hResult)) {
        if (lpTableData) {
            UlRelease(lpTableData);
        }
    }

    return(hResult);
}


/*
 *	This is a callback function, invoked by itable.dll when its
 *	caller does the last release on a view of the contents table. We
 *	use it to know when to release the underlying table data.
 */
void STDAPICALLTYPE
ContentsViewGone(ULONG ulContext, LPTABLEDATA lptad, LPMAPITABLE lpVue)
{

#ifdef OLD_STUFF
   LPISPAM pispam = (LPISPAM)ulContext;

	if (FBadUnknown((LPUNKNOWN) pispam)
		|| IsBadWritePtr(pispam, sizeof(ISPAM))
		|| pispam->cRefTad == 0
		|| FBadUnknown(pispam->ptad))
	{
		DebugTrace(TEXT("ContentsViewGone: contents table was apparently already released\n"));
		return;
	}

	if (pispam->ptad != lptad)
	{
		TrapSz( TEXT("ContentsViewGone: TAD mismatch on VUE release!"));
	}
	else if (--(pispam->cRefTad) == 0)
	{
		pispam->ptad = NULL;
		UlRelease(lptad);
	}
#endif // OLD_STUFF
    UlRelease(lptad);
    return;
    IF_WIN32(UNREFERENCED_PARAMETER(ulContext);)
    IF_WIN32(UNREFERENCED_PARAMETER(lpVue);)
}


/*============================================================================
 -	CONTVUE::SetColumns()
 -
 *		Replaces the current column set with a copy of the specified column set
 *		and frees the old column set.
 */

STDMETHODIMP
CONTVUE_SetColumns(
	LPVUE			lpvue,
	LPSPropTagArray	lpptaCols,
	ULONG			ulFlags )
{
    HRESULT        hResult = hrSuccess;


#if !defined(NO_VALIDATION)
    VALIDATE_OBJ(lpvue,CONTVUE_,SetColumns,lpVtbl);

//    Validate_IMAPITable_SetColumns( lpvue, lpptaCols, ulFlags );     // Commented by YST
#endif

    Assert(lpvue->lptadParent->lpvDataSource);

    // Re-read the table data
    if (lpvue->lptadParent && (hResult = FillTableDataFromPropertyStore(
      (LPIAB)lpvue->lptadParent->lpvDataSource,
      lpptaCols,
      (LPTABLEDATA)lpvue->lptadParent))) {
        DebugTraceResult( TEXT("CONTVUE_SetColumns:FillTableFromPropertyStore"), hResult);
        return(hResult);
    }

    return(VUE_SetColumns(lpvue, lpptaCols, ulFlags));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\common.h ===
#include <WINDOWS.H>
#include <genlib32.h>  // added in LAB02
#include <commctrl.h>
#include "resource.h"  // added in LAB05
#include "base32.h"
#include "fonts.h"
#include "thormsgs.h"
#include "image.h"
#include "btnbar.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\debug.c ===
/*
 -  debug.c
 -
 *      Microsoft Internet Phone
 *		Debug functions
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.16.95	Yoram Yaacovi		Copied from the mstools tapicomm misc.c
 *		11.16.95	Yoram Yaacovi		Modified for iphone
 *		1.10.96		Yoram Yaacovi		Added conditional trace and file debug output
 *
 *	Functions:
 *    DebugPrintFileLine
 *    DebugPrintf
 *    DebugTrap
 *
 */

//#include "mpswab.h"
#include "_apipch.h"

#pragma warning(disable:4212)  // nonstd extension: ellipsis used

#if defined(DEBUG) || defined(TEST)

extern BOOL fTrace;							// Set TRUE if you want debug traces
extern BOOL fDebugTrap;						// Set TRUE to get int3's
extern TCHAR szDebugOutputFile[MAX_PATH];	// the name of the debug output file

/*
 *  FUNCTION: DebugPrintFileLine(..)
 *
 *  PURPOSE: Pretty print a trace or error message to the debugging output.
 *
 *  PARAMETERS:
 *    dwParam - One dword parameter (can be the error code)
 *    pszPrefix   - String to prepend to the printed message.
 *    szFileName  - Filename the error occured in.
 *    nLineNumber - Line number the error occured at.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    If szFileName == NULL, then the File and Line are not printed.
 *
 */

void DebugPrintFileLine(
    DWORD dwParam, LPTSTR szPrefix,
    LPTSTR szFileName, DWORD nLineNumber)
{
    TCHAR szBuffer[256];

    if (szPrefix == NULL)
        szPrefix = szEmpty;

    // Pretty print the error message.
	// <not done yet>

    // If szFileName, then use it; else don't.
    if (szFileName != NULL)
    {
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer),
            TEXT("%s: \"%x\" in File \"%s\", Line %d\r\n"),
            szPrefix, dwParam, szFileName, nLineNumber);
    }
    else
    {
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s: \"%x\"\r\n"), szPrefix, dwParam);
    }

    // Print it!
    OutputDebugString(szBuffer);

    return;
}


/*
 *  FUNCTION: DebugPrintfError(LPTSTR, ...)
 *
 *  PURPOSE: a wrapper around DebugPrintf for error cases
 *
 *	PARAMETERS:
 *		lpszFormat - the same as printf		
 *
 *  RETURN VALUE:
 *    none.
 *
 *  COMMENTS:
 *
 */

void __cdecl DebugPrintfError(LPTSTR lpszFormat, ...)
{
    va_list v1;

    va_start(v1, lpszFormat);

	DebugPrintf(AVERROR, lpszFormat, v1);
}

/*
 *  FUNCTION: DebugPrintfTrace(LPTSTR, ...)
 *
 *  PURPOSE: a wrapper around DebugPrintf for the trace case
 *
 *	PARAMETERS:
 *		lpszFormat - the same as printf		
 *
 *  RETURN VALUE:
 *    none.
 *
 *  COMMENTS:
 *
 */

void __cdecl DebugPrintfTrace(LPTSTR lpszFormat, ...)
{
    va_list v1;

    va_start(v1, lpszFormat);

	DebugPrintf(AVTRACE, lpszFormat, v1);
}

/*
 *  FUNCTION: DebugPrintf(ULONG ulFlags, LPTSTR, va_list)
 *
 *  PURPOSE: wsprintfA to the debugging output.
 *
 *	PARAMETERS:
 *		ulFlags - trace, error, zone information
 *		lpszFormat - the same as printf		
 *
 *  RETURN VALUE:
 *    none.
 *
 *  COMMENTS:
 *
 */

#ifdef WIN16
void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, ...)
#else
void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, va_list v1)
#endif
{
    TCHAR szOutput[512];
	LPTSTR lpszOutput=szOutput;
    DWORD dwSize;
#ifdef WIN16
    va_list  v1;

    va_start(v1, lpszFormat);
#endif

	// if error, start the string with "ERROR:"
	if (ulFlags == AVERROR)
	{
        StrCpyN(lpszOutput, TEXT("ERROR: "), ARRAYSIZE(szOutput));
		lpszOutput = lpszOutput+lstrlen(lpszOutput);
	}

	// if trace, and tracing not enabled, leave
	if ((ulFlags == AVTRACE) && !fTrace)
		goto out;

    dwSize = (ARRAYSIZE(szOutput) - (DWORD)(lpszOutput - szOutput));
    dwSize = wvnsprintf(lpszOutput, dwSize, lpszFormat, v1);

	// Append carriage return, if necessary
    if ((szOutput[lstrlen(szOutput)-1] == '\n') &&
		(szOutput[lstrlen(szOutput)-2] != '\r'))
	{
        szOutput[lstrlen(szOutput)-1] = 0;
        StrCatBuff(szOutput, TEXT("\r\n"), ARRAYSIZE(szOutput));
	}

    if (lstrlen(szDebugOutputFile))
    {
		HANDLE hLogFile=NULL;
		DWORD dwBytesWritten=0;
		BOOL bSuccess=FALSE;

		// open a log file for appending. create if does not exist
		if ((hLogFile = CreateFile(szDebugOutputFile,
			GENERIC_WRITE,
			0,	// not FILE_SHARED_READ or WRITE
			NULL,
			OPEN_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			(HANDLE)NULL)) != INVALID_HANDLE_VALUE)
		{
			// Write log string to file. Nothing I can do if this fails
			SetFilePointer(hLogFile, 0, NULL, FILE_END);   // seek to end
            bSuccess = WriteFile(hLogFile,
								szOutput,
								lstrlen(szOutput),
								&dwBytesWritten,
								NULL);
	        IF_WIN32(CloseHandle(hLogFile);) IF_WIN16(CloseFile(hLogFile);)
		}

    }
    else
    {
        OutputDebugString(szOutput);
    }

out:
	return;
}

#ifdef OLD_STUFF
/***************************************************************************

    Name      : DebugTrap

    Purpose   : depending on a registry setting, does the int3 equivalent

    Parameters: none

    Returns   :

	Notes	  :	

***************************************************************************/
void DebugTrapFn(void)
{
	if (fDebugTrap)
		DebugBreak();
  		// _asm { int 3};
}
#endif

#else	// no DEBUG

// need these to resolve def file exports
void DebugPrintFileLine(
    DWORD dwParam, LPTSTR szPrefix,
    LPTSTR szFileName, DWORD nLineNumber)
{}

void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, ...)
{}

#ifdef OLD_STUFF
void DebugTrapFn(void)
{}
#endif

void __cdecl DebugPrintfError(LPTSTR lpszFormat, ...)
{}

void __cdecl DebugPrintfTrace(LPTSTR lpszFormat, ...)
{}

#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dial.h ===
#ifndef _DIALER_H_
#define _DIALER_H_
#include <tapi.h>

#ifdef _NT50_TAPI30
#include <oleauto.h>
#include <objbase.h>
#endif //#ifdef _NT50_TAPI30


HRESULT HrExecDialDlg(HWND, LPADRBOOK);

#ifdef _NT50_TAPI30

DEFINE_GUID(IID_ITRequest, 0xAC48FFDF, 0xF8C4, 0x11d1, 0xA0, 0x30, 0x0, 0xC0, 0x4F, 0xB6, 0x80, 0x9F);
DEFINE_GUID(CLSID_RequestMakeCall, 0xAC48FFE0, 0xF8C4, 0x11d1, 0xA0, 0x30, 0x0, 0xC0, 0x4F, 0xB6, 0x80, 0x9F);

//from tapi3if.h
#ifndef __ITRequest_FWD_DEFINED__
#define __ITRequest_FWD_DEFINED__
typedef interface ITRequest ITRequest;
#endif 	/* __ITRequest_FWD_DEFINED__ */

#ifndef __ITRequest_INTERFACE_DEFINED__
#define __ITRequest_INTERFACE_DEFINED__

/* interface ITRequest */
/* [object][oleautomation][helpstring][uuid] */ 

EXTERN_C const IID IID_ITRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC48FFDF-F8C4-11d1-A030-00C04FB6809F")
    ITRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MakeCall( 
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pAppName,
            /* [in] */ BSTR pCalledParty,
            /* [in] */ BSTR pComment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MakeCall )( 
            ITRequest __RPC_FAR * This,
            /* [in] */ BSTR pDestAddress,
            /* [in] */ BSTR pAppName,
            /* [in] */ BSTR pCalledParty,
            /* [in] */ BSTR pComment);
        
        END_INTERFACE
    } ITRequestVtbl;

    interface ITRequest
    {
        CONST_VTBL struct ITRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITRequest_MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment)	\
    (This)->lpVtbl -> MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITRequest_MakeCall_Proxy( 
    ITRequest __RPC_FAR * This,
    /* [in] */ BSTR pDestAddress,
    /* [in] */ BSTR pAppName,
    /* [in] */ BSTR pCalledParty,
    /* [in] */ BSTR pComment);


void __RPC_STUB ITRequest_MakeCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ITRequest_INTERFACE_DEFINED__ */


// from tapi3.h
EXTERN_C const CLSID CLSID_RequestMakeCall;

#ifdef __cplusplus

class DECLSPEC_UUID("AC48FFE0-F8C4-11d1-A030-00C04FB6809F")
RequestMakeCall;
#endif

//end from tapi3.h

#endif //#ifdef _NT50_TAPI30


#endif /* _DIALER_H_ defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dial.c ===
/**********************************************************************************
*
*       dial.c - autodialer functionality for the wab
*       created on 7/1/98 by t-jstaj
*
*       Note: The reason for having this dialog in teh WAB was to integrate with
*           the NT TAPI team .. we tried using TAPI3.0 which is debuting in 
*           NT5 but found it too unstable, subject to change, and hard to include
*           in our standard headers .. hence the NT5_TAPI3.0 support is currently
*           #ifdefed out _NT50_TAPI30 .. if you reenable that support you should 
*           test it since we havent been able to test the code much - vikramm
**********************************************************************************/

#include "_apipch.h"
#define MAX_PHONE_NUMS  10
#define MAX_PHONE_LEN   32


static DWORD rgDLDialHelpIDs[] = 
{        
    // these are dummy for now, need to change at some point
    IDC_NEWCALL_STATIC_CONTACT,         IDH_WAB_DIALER_CONTACT,
    IDC_NEWCALL_COMBO_CONTACT,          IDH_WAB_DIALER_CONTACT,
    IDC_NEWCALL_STATIC_PHNUM,           IDH_WAB_DIALER_PHONE,
    IDC_NEWCALL_COMBO_PHNUM,            IDH_WAB_DIALER_PHONE,
    IDC_NEWCALL_BUTTON_CALL,            IDH_WAB_DIALER_CALL,
    IDC_NEWCALL_BUTTON_PROPERTIES,      IDH_WAB_DIALER_PROPERTIES,        
    IDC_NEWCALL_BUTTON_DIALPROP,        IDH_WAB_DIALING_PROPERTIES,
    IDC_NEWCALL_GROUP_DIALNUM,          IDH_WAB_COMM_GROUPBOX,
    IDC_NEWCALL_BUTTON_CLOSE,           IDH_WAB_FIND_CLOSE,
    0,0
};

// prototypes
#ifdef _NT50_TAPI30
HRESULT HrLPSZToBSTR(LPTSTR lpsz, BSTR *pbstr);
#endif //#ifdef _NT50_TAPI30

HRESULT HrConfigDialog( HWND );
UINT GetPhoneNumData( HWND , LPTSTR );
BOOL RetrieveData( HWND, LPTSTR szDestAddr, LPTSTR szAppName, 
                  LPTSTR szCalledParty, LPTSTR szComment);
HRESULT HrSetComboText( HWND );
void SetNumbers( HWND, LPSBinary );
INT_PTR CALLBACK ShowNewCallDlg(HWND, UINT, WPARAM, LPARAM);
LONG HrStartCall(LPTSTR, LPTSTR, LPTSTR, LPTSTR);
void UpdateNewCall(HWND, BOOL);
void DisableCallBtnOnEmptyPhoneField(HWND);
HRESULT HrInitDialog(HWND);
HRESULT HrCallButtonActivate( HWND );
HRESULT HrPropButtonActivate( HWND );
HRESULT HrCloseBtnActivate  ( HWND );
VOID FAR PASCAL lineCallbackFunc(  DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR, DWORD_PTR);
BOOL fContextExtCoinitForDial = FALSE;
typedef struct _IABSB
{
    LPADRBOOK lpIAB;
    LPSBinary lpSB;
    
} IABSB, * LPIABSB;

/**
HrExecDialog: entry point to Dialer Dialog
[IN] hWndLV         - handle to the WAB's ListView
[IN] lpAdrBook      - pointer to the IAdrBook object 
*/
HRESULT HrExecDialDlg(HWND hWndLV, LPADRBOOK lpAdrBook )
{
    HRESULT             hr = E_FAIL;
    LPRECIPIENT_INFO    lpItem = NULL;
    LPSPropValue        lpPropArray  = NULL;
    ULONG               ulcProps = 0;
    UINT                iItemIndex;
    LPSBinary           lpSB = NULL;
    IABSB               ptr_store;
    int                 rVal, nCount = ListView_GetSelectedCount(hWndLV);        
    TCHAR               szBuf[MAX_PATH*2];
    ptr_store.lpIAB = lpAdrBook;
    ptr_store.lpSB = NULL;

    if( !lpAdrBook )
        DebugTrace(TEXT("lpAdrbook is null in ExecDialDlg\n"));

    if(nCount == 1)
    {
        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);   
        lpItem = GetItemFromLV(hWndLV, iItemIndex);
        if(lpItem && lpItem->cbEntryID != 0)
        {
            ListView_GetItemText( hWndLV, iItemIndex, 0, szBuf, CharSizeOf( szBuf ));
            // what does this allocate space for SBinary
            MAPIAllocateBuffer( sizeof(SBinary), (LPVOID *) &lpSB);
            if( lpSB )
            {
                // allocate more space for lpb                        
                MAPIAllocateMore(lpItem->cbEntryID, lpSB, (LPVOID *) &(lpSB->lpb) );
            }
            if( !lpSB->lpb)
            {
                MAPIFreeBuffer(lpSB);
                goto out;
            }
            CopyMemory(lpSB->lpb, lpItem->lpEntryID, lpItem->cbEntryID);
            lpSB->cb = lpItem->cbEntryID;
            ptr_store.lpSB = lpSB;
        }
        else
        {
            DebugTrace(TEXT("Bad WAB info will not display\n"));
            goto out;
        }
    }
    // display the dialog box to prompt user to make call    
    if(!DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(IDD_NEWCALL),
        GetParent(hWndLV), ShowNewCallDlg, (LPARAM)&ptr_store) )
    {
        hr = S_OK;
    }
    else
    {
        DebugTrace(TEXT("Dialer dialog creation failed:%d\n"), GetLastError());
    }
    
out: 
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);
    
    if( lpSB )
        MAPIFreeBuffer(lpSB);
    return hr;    
}   

/**
ShowNewCallDlg: process events
*/

INT_PTR CALLBACK ShowNewCallDlg(HWND     hDlg,
                             UINT     uMsg,
                             WPARAM   wParam,
                             LPARAM   lParam)
{
    switch (uMsg)
    {    
    case WM_INITDIALOG:
        {
            HRESULT hr;
            SetWindowLongPtr( hDlg, DWLP_USER, lParam ); 
            hr = HrInitDialog(hDlg);
            // [PaulHi] 12/3/98  Raid #56045
            // Set up child window fonts with default GUI font
            EnumChildWindows(hDlg, SetChildDefaultGUIFont, (LPARAM) 0);
            return HR_FAILED( hr );
        }
    case WM_COMMAND:
        switch (LOWORD(wParam) )
        {
        case IDC_NEWCALL_COMBO_CONTACT:   
            /** only want to make a change if the user actually chooses a new contact
            */
            if( HIWORD(wParam) == CBN_SELENDOK )   
            {
                HRESULT hr;
                UpdateNewCall(hDlg, TRUE);
                hr = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );                
                if( HR_FAILED( hr ) )
                {
                    DebugTrace(TEXT("unable to set text\n"));
                    SendMessage(hDlg, IDCANCEL, 0, 0);
                }
            }            
            return FALSE;
        case IDC_NEWCALL_COMBO_PHNUM:
            // want to set the text of the selected item when the box closes
            if(  HIWORD(wParam) == CBN_CLOSEUP )
            {   
                HRESULT hr = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );
                if( HR_FAILED( hr ) )
                {
                    DebugTrace(TEXT("unable to set text in PHNUM closeup or selchange\n"));
                    SendMessage(hDlg, IDCANCEL, 0, 0);
                }
                return FALSE;
            }
            // reset all the values of the combobox before display since they
            // were altered from the last time a selection was made.
            else if( HIWORD(wParam) == CBN_DROPDOWN )
            {
                UpdateNewCall(hDlg, FALSE);
            }
            else if (HIWORD(wParam) == CBN_EDITUPDATE )
            {
                DisableCallBtnOnEmptyPhoneField(hDlg);
            }
            else if ( HIWORD(wParam) == CBN_SELCHANGE )
            {
                if( !SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, CB_GETDROPPEDSTATE, (WPARAM)(0), (LPARAM)(0) ) )
                {
                    HRESULT hr = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );
                    if( HR_FAILED( hr ) )
                    {
                        DebugTrace(TEXT("unable to set text in PHNUM closeup or selchange\n"));
                        SendMessage(hDlg, IDCANCEL, 0, 0);
                    }
                    return FALSE;
                }
            }
            return FALSE;
        case IDC_NEWCALL_BUTTON_DIALPROP:
            {
                HRESULT hr = HrConfigDialog( hDlg );
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("config dlg failed"));
                    DebugTrace(TEXT(" error was %x\n"), HRESULT_CODE(hr));
                    SendMessage(hDlg, IDCANCEL, 0, 0);
                }
                return FALSE;
            }
            
        case IDC_NEWCALL_BUTTON_CALL:
            {
                HRESULT hr = HrCallButtonActivate( hDlg );
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("Unable to make call\n"));
                    SendMessage( hDlg, IDCANCEL, (WPARAM)(0), (LPARAM)(0) );
                }
            }
            return FALSE;
        case IDC_NEWCALL_BUTTON_PROPERTIES:
            {
                HRESULT hr = HrPropButtonActivate( hDlg );
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("Unable to show properties\n"));
                    SendMessage( hDlg, IDCANCEL, (WPARAM)(0), (LPARAM)(0) );
                }
                return FALSE;
            }
        case IDCANCEL:
        case IDC_NEWCALL_BUTTON_CLOSE:
            {
               HRESULT hr = HrCloseBtnActivate(hDlg);
               return FALSE;
            }
        default:
            return TRUE;        
        }

        case WM_HELP:
            WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD_PTR)(LPSTR) rgDLDialHelpIDs );
            break;
    }
    return FALSE;
}

/**
HrInitDialog: initializes the dialer dialog
*/
HRESULT HrInitDialog( HWND hDlg )
{
    HRESULT     hr = E_FAIL, hr2;
    HWND        hComboContact = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_CONTACT);
    ULONG       lpcbEID, ulObjType = 0, ulResult;
    LPENTRYID   lpEID       = NULL;
    LPMAPITABLE lpAB        = NULL;
    LPSRowSet   lpRow       = NULL;
    LPSRowSet   lpRowAB     = NULL;
    LPABCONT    lpContainer = NULL;
    UINT        cNumRows    = 0;
    UINT        nRows       = 0;
    UINT        i, cEntries = 0;
    LPSBinary   tVal;
    LPIABSB     lpPtrStore = (LPIABSB)GetWindowLongPtr( hDlg, DWLP_USER );
    LPADRBOOK   lpAdrBook = lpPtrStore->lpIAB;
    AssertSz( (lpAdrBook != NULL),  TEXT("lpAdrBook is NULL in shownewcall!\n"));
    
    hr = (HRESULT) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, EM_SETLIMITTEXT, (WPARAM)(TAPIMAXDESTADDRESSSIZE), (LPARAM)(0) );
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("unable to set text len in PHNUM\n"));
    }
    // get the default Container
    hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &lpcbEID, &lpEID);
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to get PAB\n"));
        goto cleanup;
    }
    // open the entry
    hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
        lpcbEID,					    		
        (LPENTRYID)lpEID,
        NULL,
        0,
        &ulObjType,
        (LPUNKNOWN *)&lpContainer);
    
    MAPIFreeBuffer(lpEID);
    lpEID = NULL;
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to open contents\n"));
        goto cleanup;
    }
    // get the contents
    hr = lpContainer->lpVtbl->GetContentsTable(lpContainer, 
                                                MAPI_UNICODE | WAB_PROFILE_CONTENTS | WAB_CONTENTTABLE_NODATA, 
                                                &lpAB );
    
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to get contents table\n"));
        goto cleanup;
    }
    
    // order the columns in the Table
    // order will be displayname, entryid
    // table MUST set columns in order requested
    hr = lpAB->lpVtbl->SetColumns( lpAB, (LPSPropTagArray)&irnColumns, 0);
    
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to set contents table\n"));
        goto cleanup;
    }
    
    hr = lpAB->lpVtbl->SeekRow(lpAB, BOOKMARK_BEGINNING, 0, NULL);
    
    if( HR_FAILED(hr) )
    {
        DebugTrace(TEXT("Unable to seekRow \n"));
        goto cleanup;
    }
    
    do{
        //loop over all the info in the selected rows
        hr = lpAB->lpVtbl->QueryRows(lpAB, 1, 0, &lpRowAB);
        if( HR_FAILED(hr) )
        {
            DebugTrace(TEXT("Unable to Query Rows\n"));
            goto cleanup;
        }
        cNumRows = lpRowAB->cRows;
        if( lpRowAB && cNumRows > 0)  // temp fix to check for cNumRows
        {   
            UINT recentIndex;
            // store the name
            LPTSTR lpsz = lpRowAB->aRow[0].lpProps[irnPR_DISPLAY_NAME].Value.LPSZ;
            // store the entryID info
            LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.lpb;
            ULONG cbEID = lpRowAB->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.cb;
            LPSBinary lpSB = NULL;
            // we can ignore non mail-users  for our purposes 
            // since they won't have ph numbers
            
            // will add strings to the combo box, and will associate the entryid with
            // each entry with its entryID so that it will be easy to obtain the other entry fields
            
            // what does this allocate space for SBinary
            MAPIAllocateBuffer( sizeof(SBinary), (LPVOID *) &lpSB);
            if( lpSB )
            {
                // allocate more space for lpb
                MAPIAllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb) );
            }
            
            if( !lpSB->lpb)
            {
                // because of memmangement in WAB this will free all 
                // the mem in SBinary( deep free )
                MAPIFreeBuffer(lpSB);
                continue;
            }
            CopyMemory(lpSB->lpb, lpEID, cbEID);
            lpSB->cb = cbEID;
            //  next entry, list is sorted                              
            recentIndex = (UINT) SendMessage( hComboContact, CB_ADDSTRING, (WPARAM)(0),
                (LPARAM)(lpsz) );
            // set the data as the pointer to entryid info for the item at that index
            SendMessage( hComboContact, CB_SETITEMDATA,
                (WPARAM)(recentIndex), (LPARAM)(lpSB));
            cEntries++;
        }                    
        FreeProws(lpRowAB);
    }while( SUCCEEDED(hr) && cNumRows && lpRowAB );
    
    if( (LPVOID)lpPtrStore->lpSB )
    {
        for( i = 0; i < cEntries; i++)
        {
            tVal = (LPSBinary)(PULONG)SendMessage( hComboContact, CB_GETITEMDATA, 
                (WPARAM)(i), (LPARAM)(0) );
                if( tVal && tVal->cb && tVal->cb == lpPtrStore->lpSB->cb )
                {
                   if( memcmp((LPVOID)tVal->lpb, 
                       (LPVOID)lpPtrStore->lpSB->lpb, (size_t)tVal->cb) == 0) 
                    {
                        SendMessage(hComboContact, CB_SETCURSEL, 
                            (WPARAM)(i), (LPARAM)(0) );                
                        break;
                    }
            }
        }
    }
    else
        SendMessage(hComboContact, CB_SETCURSEL, (WPARAM)(0), (LPARAM)(0) );
    
cleanup:           
    if( lpContainer )
        lpContainer->lpVtbl->Release(lpContainer);
    if( lpAB)
        lpAB->lpVtbl->Release(lpAB);
    
    UpdateNewCall(hDlg, TRUE);
    hr2 = HrSetComboText( GetDlgItem(hDlg, IDC_NEWCALL_COMBO_PHNUM) );
    DisableCallBtnOnEmptyPhoneField(hDlg);

    if( HR_SUCCEEDED(hr) && HR_FAILED(hr2))
        return hr2;
    return hr;
}

/**
    HrCallButtonActivate: initiates the dialing procedures for the dialer Dlg
  */
HRESULT HrCallButtonActivate( HWND hDlg )
{
    HRESULT hr = E_FAIL;
    TCHAR szDestAddr[TAPIMAXDESTADDRESSSIZE];
    TCHAR szAppName[TAPIMAXAPPNAMESIZE];
    TCHAR szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    TCHAR szComment[TAPIMAXCOMMENTSIZE]; 
    BOOL fGotNum = RetrieveData( hDlg, szDestAddr, szAppName, szCalledParty, szComment);
    if( !fGotNum )
    {
        ShowMessageBox( hDlg, idsNoDialerDataMsg, MB_OK | MB_ICONEXCLAMATION );
    }
    else
    {
        hr = HrStartCall(szDestAddr, szAppName, szCalledParty, szComment);
        /** make call spawns it's own thread so hr only reflects
        whether or not it was able to find the phone device and 
        initiate the calling sequence, not the status of the call.
        */
    }
    return hr;
}

/**
    HrPropButtonActivate: displays the properties for the selected contact in the dialer Dlg
*/
HRESULT HrPropButtonActivate( HWND hDlg )
{    
    HRESULT		hr = E_FAIL;
    LONG		iCurContactSel;
    LPIABSB     lpPtrStore = (LPIABSB)GetWindowLongPtr( hDlg, DWLP_USER );
    LPADRBOOK   lpAdrBook = lpPtrStore->lpIAB;          
    AssertSz((lpAdrBook != NULL),  TEXT("lpAdrBook is NULL in SetNumbers\n"));
    
    // first get the cached data for the contact currently selected
    iCurContactSel = (LONG) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_CONTACT,
        CB_GETCURSEL,(WPARAM)(0), (LPARAM)(0));
    
    // if something is selected
    if( iCurContactSel >= 0 )
    {
        LRESULT lpdata = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_CONTACT, 
            CB_GETITEMDATA, (WPARAM)(iCurContactSel), (LPARAM)(LPTSTR)(0));                   
        // if we have a specially cached entryid ..
        //
        if( lpdata != CB_ERR && ((LPSBinary)lpdata)->cb && ((LPSBinary)lpdata)->lpb)
        {
            LPSBinary lpSB = (LPSBinary)lpdata;
            hr = lpAdrBook->lpVtbl->Details(lpAdrBook, (PULONG_PTR) &hDlg,
                NULL, NULL,
                lpSB->cb,
                (LPENTRYID) lpSB->lpb,
                NULL, NULL,
                NULL, 0); 
        }
    }
    return hr;
}

/** 
    HrCloseBtnActivate: Handles freeing memory from the combo boxes
*/
HRESULT HrCloseBtnActivate( HWND hDlg )
{
    HRESULT hr = S_OK;  
    UINT i, nComboSize;
    PULONG nData;
    LPTSTR lpData;
    HWND hComboItem = GetDlgItem (hDlg, IDC_NEWCALL_COMBO_CONTACT);
    // loop through all the items in the box and free the address pointed 
    // to by the data item    
    nComboSize = (UINT) SendMessage( hComboItem, CB_GETCOUNT, (WPARAM) (0), (LPARAM) (0) );
    for( i = 0; i < nComboSize; i++)
    {
        nData = (PULONG)SendMessage(hComboItem, CB_GETITEMDATA, (WPARAM)(i), (LPARAM)(0) );
        if ((LRESULT)nData != CB_ERR && nData != NULL)
        {
            if( nData )
                MAPIFreeBuffer( (LPSBinary)nData );
        }
        else 
            hr = E_FAIL;
    }
    SendMessage( hComboItem, CB_RESETCONTENT, (WPARAM)(0), (LPARAM)(0));
    hComboItem = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_PHNUM);
    nComboSize = (UINT) SendMessage( hComboItem, CB_GETCOUNT, (WPARAM)(0), (LPARAM)(0) );
    for(i = 0; i < nComboSize; i++)
    {
        lpData = (LPTSTR)SendMessage(hComboItem, CB_GETITEMDATA, (WPARAM)(i), (LPARAM)(0) );
        if( (LRESULT)lpData != CB_ERR && lpData != NULL )
        {
            if( lpData )
                LocalFree( lpData );
                
        }
        else 
            hr = E_FAIL;
    }
//    SendMessage( hComboItem, CB_RESETCONTENT, (WPARAM)(0), (LPARAM)(0));
    EndDialog(hDlg, HR_SUCCEEDED(hr) );
    return hr;
}

/**
    HrStartCall: handles the TAPI calls required to dial a telephone number
    [IN] szDestAddr     - the destination telephone number to call
    [IN] szAppName      - (not used) the application to use in the dialing procedure
    [IN] szCalledParty  - the name of the person called (will be displayed by the TAPI UI)
    [IN] szComment      - (not used) a comment associated with this number 
*/
HRESULT HrStartCall(LPTSTR szDestAddr, LPTSTR szAppName, LPTSTR szCalledParty, LPTSTR szComment)
{
    typedef LONG (CALLBACK* LPFNTAPISTARTCALL)(LPSTR,LPSTR,LPSTR,LPSTR);
    HINSTANCE           hDLL;
    LPFNTAPISTARTCALL   lpfnTapi;    // Function pointer
    HRESULT             lRetCode;
    HRESULT             hr = E_FAIL;
    
#ifdef _NT50_TAPI30
    ITRequest *         pRequest = NULL;
    // begin NT5 code  
    if( CoInitialize(NULL) == S_FALSE )
        CoUninitialize();
    else    
        fContextExtCoinitForDial = TRUE;
    hr = CoCreateInstance(
        &CLSID_RequestMakeCall,
        NULL,
        CLSCTX_INPROC_SERVER,
        &IID_ITRequest,
        (LPVOID *)&pRequest
        );
    
    if( HR_SUCCEEDED(hr) )
    {
        BSTR pDestAdr, pAppName, pCalledParty, pComment; 
        HrLPSZToBSTR(szDestAddr, &pDestAdr);
        HrLPSZToBSTR(szAppName, &pAppName);
        HrLPSZToBSTR(szCalledParty, &pCalledParty);
        HrLPSZToBSTR(szComment, &pComment);
        
        hr  = pRequest->lpVtbl->MakeCall(pRequest, pDestAdr, pAppName, pCalledParty, pComment );
        DebugTrace(TEXT("COM Environment\n"));
        
        LocalFreeAndNull(&pDestAdr);
        LocalFreeAndNull(&pAppName);
        LocalFreeAndNull(&pCalledParty);
        LocalFreeAndNull(&pComment);
        
        if(fContextExtCoinitForDial)
        {
            CoUninitialize();
            fContextExtCoinitForDial = FALSE;
        }
        return hr;
    }
    else 
    {
        if( hr == REGDB_E_CLASSNOTREG )
        {
            DebugTrace(TEXT("Class not registered\n"));
        }
        else if ( hr == CLASS_E_NOAGGREGATION )
        {
            DebugTrace(TEXT("Not able to create class as part of aggregate"));
        }
        else
        {
            DebugTrace(TEXT("Undetermined error = %d"), hr);
        }
        // end NT 5 code
#endif // _NT50_TAPI30
        
        //start making the call using TAPI            
        hDLL = LoadLibrary( TEXT("tapi32.dll"));
        if (hDLL != NULL)
        {
            lpfnTapi = (LPFNTAPISTARTCALL)GetProcAddress(hDLL,
                "tapiRequestMakeCall");       
            if (!lpfnTapi)   
            {      
                // handle the error      
                FreeLibrary(hDLL);           
                DebugTrace(TEXT("getprocaddr tapirequestmakecall failed\n"));
            }
            else                 
            {
                // call the function
                // [PaulHi] 2/23/99  Raid 295116.  The tapi32.dll, tapiRequestMakeCall()
                // function takes single byte char strings, not double byte.
                LPSTR   pszDestAddr = ConvertWtoA(szDestAddr);
                LPSTR   pszCalledParty = ConvertWtoA(szCalledParty);

                hr = lpfnTapi( pszDestAddr, NULL, 
                    pszCalledParty, NULL);
                if( HR_FAILED(hr) )
                {
                    DebugTrace(TEXT("make call returned error of %x\n"), hr );
                }
                
                LocalFreeAndNull(&pszDestAddr);
                LocalFreeAndNull(&pszCalledParty);

                // free the resource 
                FreeLibrary(hDLL); 
            }
        }
#ifdef _NT50_TAPI30
    }
#endif // _NT50_TAPI30
    return hr;
}
/**
    UpdateNewCall:  Updates the phone combo info (removing the description string)
    [IN] fContactChanged    - indicates whether or not it is necessary to select the first
                              entry in the PHNUM combo. 
*/
void UpdateNewCall(HWND hDlg, BOOL fContactChanged)
{
    HWND hContactCombo = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_CONTACT);
    LONG iCurContactSel, iCurPhSel;
    iCurContactSel = (LONG) SendMessage( hContactCombo, CB_GETCURSEL,(WPARAM)(0), (LPARAM)(0));
    // if something is selected
    if( iCurContactSel >= 0 )
    {
        PULONG lpdata;
        lpdata = (PULONG)SendMessage( hContactCombo, CB_GETITEMDATA, 
            (WPARAM)(iCurContactSel), (LPARAM)(LPTSTR)(0));
        
        iCurPhSel = (LONG) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, 
            CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0) );
        // set the data in the combo boxes
        AssertSz( (LRESULT)lpdata != CB_ERR,  TEXT("No data cached for this entry\n") );
        SetNumbers( hDlg, (LPSBinary)lpdata ); 
        
        if( iCurPhSel < 0 || fContactChanged) iCurPhSel = 0;
        SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, CB_SETCURSEL, (WPARAM)(iCurPhSel), (LPARAM)(0));
    }
    DisableCallBtnOnEmptyPhoneField(hDlg);
}

/**
RetrieveData: retrieves dialing information from the NEWCALL dialog,
memory must have been allocated for the character buffers
[OUT] szDestAddr    - the phone number to call, retrieved from the PHNUM combo
[OUT] szAppName     - (not used) empty string returned
[OUT] szCalledParty - the contact to call, retrieved from the CONTACT combo
[OUT] szComment     - (not used) empty string returned

  returns TRUE if success, FALSE if failure
*/
BOOL RetrieveData( HWND hDlg, LPTSTR szDestAddr, LPTSTR szAppName, 
                  LPTSTR szCalledParty, LPTSTR szComment)
{
    LPARAM cchGetText;

    // get the Contact name data
    cchGetText = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_CONTACT, WM_GETTEXT, 
        (WPARAM)(TAPIMAXCALLEDPARTYSIZE), (LPARAM)(LPTSTR)(szCalledParty));
    
    // store a default string in case there is no Party Name;
    if( cchGetText == 0 )
        lstrcpy(szCalledParty, TEXT("No Contact Name"));
    //get the Phone number data
    cchGetText = GetPhoneNumData( hDlg, szDestAddr );
    lstrcpy(szAppName,szEmpty);
    lstrcpy(szComment,szEmpty);     
    
    // return whether or not there was a phone number to dial
    return ( cchGetText > 0 );
}

/**
HrConfigDialog: initiates the dialog to change phone settings
*/
HRESULT HrConfigDialog( HWND hWnd )
{
    typedef LONG(CALLBACK* LPFNTAPIPHCONFIG)(HLINEAPP, DWORD, DWORD, HWND, LPTSTR);
//    typedef LONG(CALLBACK* LPFNTAPILINEINIT)(LPHLINEAPP, HINSTANCE, LINECALLBACK, 
//        LPTSTR, LPDWORD, LPDWORD, LPLINEINITIALIZEEXPARAMS);
    typedef LONG(CALLBACK* LPFNTAPILINEINIT)(LPHLINEAPP, HINSTANCE, LINECALLBACK, LPTSTR, LPDWORD);
    typedef LONG(CALLBACK* LPFNTAPILINESHUTDOWN)(HLINEAPP);    
    HLINEAPP hLineApp = 0;
    HINSTANCE hDLL;
    LPFNTAPIPHCONFIG lpfnConfig;    // Function pointer
    LPFNTAPILINEINIT lpfnLineInit;
    LPFNTAPILINESHUTDOWN lpfnLineShutdown;
    LONG lRetCode;
    DWORD dwDeviceID = 0X0; 
    DWORD dwAPIVersion = 0X00010004;
    LPTSTR lpszDeviceClass = NULL;
    //start config       
    HRESULT hr = E_FAIL;
    hDLL = LoadLibrary( TEXT("tapi32.dll"));
    if (!hDLL )
    {
        DebugTrace(TEXT("loading tapi32.lib failed\n"));        
        return hr;
    }
    
    lpfnConfig = (LPFNTAPIPHCONFIG)GetProcAddress(hDLL,
        "lineTranslateDialog");
    
    if (!lpfnConfig )   
    {      
        // handle the error
        DebugTrace(TEXT("getprocaddr phoneConfigDialog failed\n"));
        DebugTrace(TEXT("last error was %x\n"), GetLastError() );        
    }
    else
    {
        lRetCode = lpfnConfig( 0, dwDeviceID, dwAPIVersion, 
            hWnd, lpszDeviceClass);
        
        switch( lRetCode )
        {
            hr = HRESULT_FROM_WIN32(lRetCode);
        case 0:
            hr = S_OK;
            break;
#ifdef DEBUG
        case LINEERR_REINIT:
            DebugTrace(TEXT("reeinitialize\n"));
            break;
        case LINEERR_INVALAPPNAME:
            DebugTrace(TEXT("invalid app name\n"));
            break;                    
        case LINEERR_BADDEVICEID: 
            DebugTrace(TEXT("bad device id\n"));
            break;
        case LINEERR_INVALPARAM: 
            DebugTrace(TEXT("invalid param\n"));
            break;
        case LINEERR_INCOMPATIBLEAPIVERSION: 
            DebugTrace(TEXT("incompatible api ver\n"));
            break;
        case LINEERR_INVALPOINTER: 
            DebugTrace(TEXT("invalid ptr\n"));
            break;
        case LINEERR_INIFILECORRUPT: 
            DebugTrace(TEXT("ini file corrupt\n"));
            break;
        case LINEERR_NODRIVER: 
            DebugTrace(TEXT("no driver\n"));
            break;
        case LINEERR_INUSE: 
            DebugTrace(TEXT("in use\n"));
            break;
        case LINEERR_NOMEM:
            DebugTrace(TEXT("no mem\n"));
            break;
        case LINEERR_INVALADDRESS:
            DebugTrace(TEXT("invalid address\n"));
            break;
        case LINEERR_INVALAPPHANDLE:
            DebugTrace(TEXT("invalid phone handle\n"));
            break;
        case LINEERR_OPERATIONFAILED:
            DebugTrace(TEXT("op failed\n"));
            break;
#endif // DEBUG
        default:
            DebugTrace(TEXT("(1)lpfnConfig returned a value of %x\n"), lRetCode);
            // this had better be Win95!!
            lpfnLineInit = (LPFNTAPILINEINIT)GetProcAddress(hDLL,
                "lineInitialize");
            if( !lpfnLineInit )
            {
                // handle the error      
                DebugTrace(TEXT("getprocaddr lineInitialize failed\n"));
                DebugTrace(TEXT("last error was %x\n"), GetLastError() );
            }
            else               
            {      
                DWORD dwNumDevs = 0;
                // call the function
                lRetCode = lpfnLineInit( 
                    &hLineApp, 
                    hinstMapiX, 
                    lineCallbackFunc, 
                    NULL, 
                    &dwNumDevs);
                    
                switch( lRetCode )
                {
                    hr = HRESULT_FROM_WIN32(lRetCode);
                case 0:
                    // shows config
                    lRetCode = lpfnConfig( hLineApp, dwDeviceID, dwAPIVersion, 
                        hWnd, lpszDeviceClass);
                    switch( lRetCode )
                    {
                        hr = HRESULT_FROM_WIN32(lRetCode);
                    case 0:
                        // now shutdown line
                        lpfnLineShutdown = (LPFNTAPILINESHUTDOWN)GetProcAddress(hDLL,                
                            "lineShutdown");

                        if( lpfnLineShutdown)
                        {
                            lpfnLineShutdown(hLineApp);
                        }
                        hr = S_OK;
                        break;                            
                    default:
                        DebugTrace(TEXT("(2)lpfnConfig returned a value of %x\n"), lRetCode);
                        break;
                    }
                    break;
                    // end shows config
#ifdef DEBUG
                case LINEERR_REINIT:
                    DebugTrace(TEXT("reeinitialize\n"));
                    break;
                case LINEERR_INVALAPPNAME:
                    DebugTrace(TEXT("invalid app name\n"));
                    break;
                case LINEERR_BADDEVICEID: 
                    DebugTrace(TEXT("bad device id\n"));
                    break;
                case LINEERR_INVALPARAM: 
                    DebugTrace(TEXT("invalid param\n"));
                    break;
                case LINEERR_INCOMPATIBLEAPIVERSION: 
                    DebugTrace(TEXT("incompatible api ver\n"));
                    break;
                case LINEERR_INVALPOINTER: 
                    DebugTrace(TEXT("invalid ptr\n"));
                    break;
                case LINEERR_INIFILECORRUPT: 
                    DebugTrace(TEXT("ini file corrupt\n"));
                    break;
                case LINEERR_NODRIVER: 
                    DebugTrace(TEXT("no driver\n"));
                    break;
                case LINEERR_INUSE: 
                    DebugTrace(TEXT("in use\n"));
                    break;
                case LINEERR_NOMEM:
                    DebugTrace(TEXT("no mem\n"));
                    break;
                case LINEERR_INVALADDRESS:
                    DebugTrace(TEXT("invalid address\n"));
                    break;
                case LINEERR_INVALAPPHANDLE:
                    DebugTrace(TEXT("invalid phone handle\n"));
                    break;
                case LINEERR_OPERATIONFAILED:
                    DebugTrace(TEXT("op failed\n"));
                    break;
#endif // DEBUG
                default:
                    DebugTrace(TEXT("Initialize returned a value of %x\n"), GetLastError());
                    break;
                }
               }
            }        
        }
        // free the resource 
        FreeLibrary(hDLL); 
        return hr;
        
}
/**
SetNumbers: updates the phone numbers in the PHNUM combo based on the selection
in the CONTACT combo
[IN] lpdata     - LPSBinary that points to the data stored for the currently 
selected contact
*/
void SetNumbers( HWND hWnd, LPSBinary lpdata)
{
    ULONG           ulObjType   = 0;
    UINT            i, nLen;
    LPMAILUSER      lpMailUser  = NULL;
    HRESULT         hr;
    LPTSTR          hData;
    LPIABSB         lpPtrStore  = (LPIABSB)GetWindowLongPtr( hWnd, DWLP_USER );
    LPADRBOOK       lpAdrBook   = lpPtrStore->lpIAB;
    HWND            hCombo      = GetDlgItem(hWnd, IDC_NEWCALL_COMBO_PHNUM);
    
    AssertSz((lpAdrBook != NULL), TEXT("lpAdrBook is NULL in SetNumbers\n"));
    // clear all the data in the phnum combo
    nLen = (UINT) SendMessage( hCombo, CB_GETCOUNT, (WPARAM)(0), (LPARAM)(0));
    for( i = 0; i < nLen; i++)
    {
        hData = (LPTSTR)(PULONG)SendMessage( hCombo, CB_GETITEMDATA, (WPARAM)(i), (LPARAM)(0));
        if( (LRESULT)hData != CB_ERR && hData != NULL)
            LocalFree( hData );
    }
    SendMessage( hCombo, CB_RESETCONTENT, (WPARAM)(0), (LPARAM)(0));
    // get the ph num             
    hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, 
        lpdata->cb, 
        (LPENTRYID) lpdata->lpb, 
        NULL,
        0,
        &ulObjType,
        (LPUNKNOWN *)&lpMailUser);
    if( HR_SUCCEEDED(hr) && lpMailUser )    
    {
        LPSPropValue    lpPropArray;
        ULONG           ulcValues;
        ULONG           i;
        ULONG           ulTempProptag;
        TCHAR           szStr[MAX_PATH];
        LONG            cCopied = 0;
        
        hr = lpMailUser->lpVtbl->GetProps(lpMailUser,NULL, MAPI_UNICODE, &ulcValues, &lpPropArray);        
        if ( HR_SUCCEEDED(hr) )
        {
            
            for(i=0;i<ulcValues;i++)
            {
                cCopied = 0;
                ulTempProptag = lpPropArray[i].ulPropTag;
                switch( lpPropArray[i].ulPropTag )
                {
                case PR_HOME_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelHome, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_OFFICE_TELEPHONE_NUMBER:  
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelBus, 
                        szStr, CharSizeOf(szStr) );                
                    break;
                case PR_BUSINESS2_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelBus2, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_MOBILE_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelMobile, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_RADIO_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelRadio, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_CAR_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelCar, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_OTHER_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelOther, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_PAGER_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelPager, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_ASSISTANT_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelAst, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_HOME2_TELEPHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelHome2, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_COMPANY_MAIN_PHONE_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelCompMain, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_BUSINESS_FAX_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelFaxBus, 
                        szStr, CharSizeOf(szStr) );
                    break;
                case PR_HOME_FAX_NUMBER:
                    cCopied = LoadString( hinstMapiX, idsPhoneLabelFaxHome, 
                        szStr, CharSizeOf(szStr) );
                    break;
                default:
                    if(lpPropArray[i].ulPropTag == PR_WAB_IPPHONE)
                        cCopied = LoadString( hinstMapiX, idsPhoneLabelIPPhone, szStr, CharSizeOf(szStr) );
                    break;
                }
                if( cCopied > 0 )
                {
                    LRESULT iItem;
                    LPTSTR lpCompletePhNum = NULL;
                    LPTSTR lpPhNum;
                    int len = lstrlen( lpPropArray[i].Value.LPSZ ) + 1;
                    lpPhNum = LocalAlloc(LMEM_ZEROINIT, sizeof( TCHAR ) * len );
                    if( !lpPhNum )
                    {
                        DebugTrace(TEXT("cannot allocate memory for lpPhNum\n"));
                        SendMessage(hWnd, IDCANCEL, (WPARAM)(0), (LPARAM)(0) );
                    }
                    lstrcpy(lpPhNum, lpPropArray[i].Value.LPSZ);
                    
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szStr, 0, 0, (LPTSTR)&lpCompletePhNum, 0, (va_list *)&lpPropArray[i].Value.LPSZ);
                    
                    if( lpCompletePhNum )
                    {
                        iItem = SendDlgItemMessage( hWnd, IDC_NEWCALL_COMBO_PHNUM, 
                            CB_ADDSTRING, (WPARAM)(0), (LPARAM)(LPCTSTR)(lpCompletePhNum));
                    }
                    else 
                        iItem = CB_ERR;
                    
                    if( iItem == CB_ERR )
                    {
                        DebugTrace(TEXT("ERROR adding string %s"), lpCompletePhNum);
                    }
                    
                    SendDlgItemMessage( hWnd, IDC_NEWCALL_COMBO_PHNUM, 
                        CB_SETITEMDATA, (WPARAM)(iItem), (LPARAM)(lpPhNum) );                
                    LocalFree(lpCompletePhNum);
                }
            }
            MAPIFreeBuffer(lpPropArray);
        }
        lpMailUser->lpVtbl->Release(lpMailUser);
    }
}

/** 
    GetPhoneNumData: copies the data from the PHNUM combo to the szDestAddr buffer
                     memory must have been allocated for szDestAddr 

  [OUT] szDestAddr    - buffer to be filled with the data from the comboBox
    
    returns the number of characters copied from combo_box to szDestAddr buffer
*/
UINT GetPhoneNumData( HWND hDlg, LPTSTR szDestAddr)
{
    LRESULT iIndex, iData;
    UINT cch = 0;
    TCHAR szBuff[MAX_PATH];
    
    // determine which index was selected
    iIndex = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, 
        CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0));
    
    // if nothing is selected then copy everything in the buffer
//    if( iIndex == CB_ERR)
//    {
        cch = (UINT) SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, WM_GETTEXT,
            (WPARAM)(TAPIMAXDESTADDRESSSIZE), (LPARAM)(LPTSTR)(szDestAddr));        
/**    }
    else
    {
        // otherwise obtain the data for the selected item
        iData = SendDlgItemMessage( hDlg, IDC_NEWCALL_COMBO_PHNUM, 
            CB_GETITEMDATA, (WPARAM)(iIndex), (LPARAM)(0) );
        if( iData == CB_ERR )
        {
            cch = -1;
            DebugTrace(TEXT("Unable to obtain data from ComboBox entry that should have data associated\n"));
        }            
        else
        {
            // copy the item to a temp buffer
            lstrcpy( szDestAddr, (LPCTSTR)iData);
            DebugTrace(TEXT("String is %s\n"), szDestAddr );
            DebugTrace(TEXT("Index was %d\n"), iIndex );
        }
    }
    */
    // a character count of 0 indicates there was no data for a particular item
    return cch;
}

/**
    HrSetComboText: a helper function that will set the text entry of the PHNUM combo
                    with just the telephone number (removing the description)
    [IN] hCombo -   the combo box to update, this must be the PHNUM combo.
*/
HRESULT HrSetComboText(HWND hCombo)
{
    LRESULT iIndex;
    LPTSTR szData;
    HRESULT hr = S_OK;
    TCHAR szBuff[MAX_PATH], szDestAddr[TAPIMAXDESTADDRESSSIZE];
    // determine which index was selected
    iIndex = SendMessage( hCombo, CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0));
    if( iIndex != CB_ERR)
    {
        // obtain the data for the selected item
        szData = (LPTSTR)SendMessage( hCombo, CB_GETITEMDATA, (WPARAM)(iIndex), (LPARAM)(0) );
        if( (LRESULT)szData == CB_ERR )
        {
            DebugTrace(TEXT("Unable to obtain data from ComboBox entry that should have data associated\n"));
            szData = szEmpty;
            hr = E_FAIL;
        }            
        else
        {
            LRESULT lr;
            LPVOID lpData;
            if( !szData )
                szData = szEmpty;
            // only copy the data after the offset stored for the item
            lr = SendMessage( hCombo, CB_INSERTSTRING, (WPARAM)(iIndex), (LPARAM)(LPTSTR)(szData));
            if( lr == CB_ERR || lr == CB_ERRSPACE)
            {
                DebugTrace(TEXT("unable to insert string = %s at index = %d \n"), szData, iIndex);
                hr = E_FAIL;
            }
            lpData = (LPVOID)SendMessage( hCombo, CB_GETITEMDATA, (WPARAM)(iIndex+1), (LPARAM)(0) );
            if( (LRESULT)lpData == CB_ERR )
            {
                DebugTrace(TEXT("unable to get data for %d"), iIndex+1);
                hr = E_FAIL;
            }
            lr = SendMessage( hCombo, CB_SETITEMDATA, (WPARAM)(iIndex), (LPARAM)(lpData) );
            if( lr == CB_ERR )
            {
                DebugTrace(TEXT("unable to set data at %d"), iIndex);
                hr = E_FAIL;
            }
            lr = SendMessage( hCombo, CB_DELETESTRING, (WPARAM)(iIndex+1), (LPARAM)(0) );
            if( lr == CB_ERR )
            {
                DebugTrace(TEXT("unable to delete string at %d"), iIndex+1);
                hr = E_FAIL;
            }
            lr = SendMessage( hCombo, CB_SETCURSEL, (WPARAM)(iIndex), (LPARAM)(0) );
            if( lr == CB_ERR )
            {
                DebugTrace(TEXT("unable to set selection at %d"), iIndex);
                hr = E_FAIL;
            }
        }
    }
    else
        hr = E_FAIL;

    if( HR_FAILED(hr) )
        DebugTrace(TEXT("settext failed\n"));
    return hr;
}

/**
    DisableCallBtnOnEmptyPhoneField:    Will disable the call button if there is no text in
                                        in the PHNUM combo box.  Will enable the button if 
                                        text is present.  Does not check to see if button is
                                        already enabled/disabled, but enabling an enabled btn
                                        should be fine.
*/
void DisableCallBtnOnEmptyPhoneField(HWND hDlg)
{
    HWND hComboItem = GetDlgItem( hDlg, IDC_NEWCALL_COMBO_PHNUM);
    LRESULT iCurSel, iCurContSel;
    iCurSel = SendMessage( hComboItem, CB_GETCURSEL, 0L, 0L );
    iCurContSel = SendDlgItemMessage(hDlg, IDC_NEWCALL_COMBO_CONTACT, CB_GETCURSEL, (WPARAM)(0), (LPARAM)(0) );
    if( iCurContSel < 0 || iCurContSel == CB_ERR)
        SendMessage(hComboItem, CB_RESETCONTENT, 0L, 0L);
    if( iCurSel < 0 || iCurSel == CB_ERR )     
    { 
        LRESULT cch;
        TCHAR szBuf[MAX_PATH];
        cch = SendMessage( hComboItem, WM_GETTEXT, (WPARAM)(CharSizeOf( szBuf) ), 
            (LPARAM)(szBuf) );
        
        
        if( (INT)cch <= 0 || cch == CB_ERR)
        {
            // content will be empty at this point so can safely add
            int cCopied;
            LRESULT iIndex;
            TCHAR szBuf[MAX_PATH];
            cCopied = LoadString( hinstMapiX, idsNoPhoneNumAvailable, 
                szBuf, CharSizeOf(szBuf) );
            iIndex = SendMessage(hComboItem, CB_ADDSTRING, (WPARAM)(0), (LPARAM)(szBuf));
            SendMessage(hComboItem, CB_SETITEMDATA, (WPARAM)(0), (LPARAM)(0));
            EnableWindow( GetDlgItem(hDlg, IDC_NEWCALL_BUTTON_CALL), FALSE);
            return;
        }
    }
    EnableWindow( GetDlgItem(hDlg, IDC_NEWCALL_BUTTON_CALL), TRUE);
}

VOID FAR PASCAL lineCallbackFunc(  DWORD a, DWORD b, DWORD_PTR c, DWORD_PTR d, DWORD_PTR e, DWORD_PTR f)
{}


#ifdef _NT50_TAPI30

/**
    HrLPSZCPToBSTR: (BSTR helper) helper to convert LPTSTR -> BST
*/
HRESULT HrLPSZCPToBSTR(UINT cp, LPTSTR lpsz, BSTR *pbstr)
{
    HRESULT hr = NOERROR;
    BSTR    bstr=0;
    ULONG   cch = 0, ccb,
        cchRet;
    
    if (!IsValidCodePage(cp))
        cp = GetACP();
    
    // get byte count
    ccb = lstrlen(lpsz);
    
    // get character count - DBCS string ccb may not equal to cch
    cch=MultiByteToWideChar(cp, 0, lpsz, ccb, NULL, 0);
    if(cch==0 && ccb!=0)        
    {
        AssertSz(cch,  TEXT("MultiByteToWideChar failed"));
        hr=E_FAIL;
        goto error;
    }
    // allocate a wide-string with enough character to hold string - use character count
    bstr = (BSTR)LocalFree(LMEM_ZEROINIT, sizeof( BSTR ) * cch + 1);
    
    if(!bstr)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }
    
    cchRet=MultiByteToWideChar(cp, 0, lpsz, ccb, (LPWSTR)bstr, cch);
    if(cchRet==0 && ccb!=0)
    {
        hr=E_FAIL;
        goto error;
    }
    
    *pbstr = bstr;
    bstr=0;             // freed by caller
    
error:
    if(bstr)
        LocalFree(bstr);
    
    return hr;
}

/**  
    HrLPSZToBSTR:   Converts a LPTSTR to a BSTR using a helper function
*/
HRESULT HrLPSZToBSTR(LPTSTR lpsz, BSTR *pbstr)
{
    // GetACP so that it works on non-US platform
    return HrLPSZCPToBSTR(GetACP(), lpsz, pbstr);
}

#endif //#ifdef _NT50_TAPI30
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\distlist.c ===
/*
 *	DistList.C - Implement the IDistList object
 *	
 *	
 */

#include "_apipch.h"

STDMETHODIMP DISTLIST_OpenProperty(LPCONTAINER lpCONTAINER,
  ULONG ulPropTag,
  LPCIID lpiid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppUnk);
STDMETHODIMP DISTLIST_GetContentsTable(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable);
STDMETHODIMP DISTLIST_GetHierarchyTable(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable);
STDMETHODIMP DISTLIST_OpenEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk);
STDMETHODIMP DISTLIST_SetSearchCriteria(LPCONTAINER lpCONTAINER,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags);
STDMETHODIMP DISTLIST_GetSearchCriteria(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState);
STDMETHODIMP DISTLIST_CreateEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppMAPIPropEntry);
STDMETHODIMP DISTLIST_CopyEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags);
STDMETHODIMP DISTLIST_DeleteEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulFlags);
STDMETHODIMP DISTLIST_ResolveNames(LPCONTAINER lpCONTAINER,
  LPSPropTagArray lptagaColSet,
  ULONG ulFlags,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList);


HRESULT HrNewDLENTRY(LPCONTAINER lpCONTAINER,
  LPMAPIPROP lpOldEntry,    // Old entry to copy from
  ULONG ulCreateFlags,
  LPVOID *lppDLENTRY);

/*
 *  Root jump table is defined here...
 */

CONTAINER_Vtbl vtblDISTLIST =
{
    VTABLE_FILL
    (CONTAINER_QueryInterface_METHOD *)     IAB_QueryInterface,
    (CONTAINER_AddRef_METHOD *)             WRAP_AddRef,
    (CONTAINER_Release_METHOD *)            CONTAINER_Release,
    (CONTAINER_GetLastError_METHOD *)       IAB_GetLastError,
    (CONTAINER_SaveChanges_METHOD *)        MailUser_SaveChanges,
    (CONTAINER_GetProps_METHOD *)           WRAP_GetProps,
    (CONTAINER_GetPropList_METHOD *)        WRAP_GetPropList,
    (CONTAINER_OpenProperty_METHOD *)       DISTLIST_OpenProperty,
    (CONTAINER_SetProps_METHOD *)           WRAP_SetProps,
    (CONTAINER_DeleteProps_METHOD *)        WRAP_DeleteProps,
    (CONTAINER_CopyTo_METHOD *)             WRAP_CopyTo,
    (CONTAINER_CopyProps_METHOD *)          WRAP_CopyProps,
    (CONTAINER_GetNamesFromIDs_METHOD *)    MailUser_GetNamesFromIDs,
    (CONTAINER_GetIDsFromNames_METHOD *)    MailUser_GetIDsFromNames,
    (CONTAINER_GetContentsTable_METHOD *)   DISTLIST_GetContentsTable,
    (CONTAINER_GetHierarchyTable_METHOD *)  DISTLIST_GetHierarchyTable,
    (CONTAINER_OpenEntry_METHOD *)          DISTLIST_OpenEntry,
    (CONTAINER_SetSearchCriteria_METHOD *)  DISTLIST_SetSearchCriteria,
    (CONTAINER_GetSearchCriteria_METHOD *)  DISTLIST_GetSearchCriteria,
    (CONTAINER_CreateEntry_METHOD *)        DISTLIST_CreateEntry,
    (CONTAINER_CopyEntries_METHOD *)        DISTLIST_CopyEntries,
    (CONTAINER_DeleteEntries_METHOD *)      DISTLIST_DeleteEntries,
    (CONTAINER_ResolveNames_METHOD *)       DISTLIST_ResolveNames
};


enum {
    iwdePR_WAB_DL_ENTRIES, // Very important - keep DL_ENTRIES and DL_ONEOFFS togethor .. we use them as contiguous loop indexes somewhere
    iwdePR_WAB_DL_ONEOFFS,
    iwdePR_ENTRYID,
    iwdeMax
};

SizedSPropTagArray(iwdeMax, tagaWabDLEntries) =
{
    iwdeMax,
    {
        PR_WAB_DL_ENTRIES,
        PR_NULL, // should be PR_WAB_DL_ONEOFFS
        PR_ENTRYID,
    }
};



/***************************************************
 *
 *  The actual ABContainer methods
 */
/* ---------
 * IMAPIProp
 */


STDMETHODIMP
DISTLIST_OpenProperty(LPCONTAINER lpCONTAINER,
  ULONG ulPropTag,
  LPCIID lpiid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppUnk)
{
    LPIAB lpIAB;
    LPSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr;

#ifdef	PARAMETER_VALIDATION
    // Validate parameters

    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if ((ulInterfaceOptions & ~(MAPI_UNICODE)) || (ulFlags & ~(MAPI_DEFERRED_ERRORS))) {
        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (FBadOpenProperty(lpRoot, ulPropTag, lpiid, ulInterfaceOptions, ulFlags, lppUnk)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif	// PARAMETER_VALIDATION


    EnterCriticalSection(&lpCONTAINER->cs);

    lpIAB = lpCONTAINER->lpIAB;

    //
    //  Check to see if I need a display table
    //

    if (ulPropTag == PR_CREATE_TEMPLATES) {
        Assert(FALSE);  // Not implemented
        hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
        goto err;

    } else if (ulPropTag == PR_CONTAINER_CONTENTS) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = DISTLIST_GetContentsTable(lpCONTAINER, ulInterfaceOptions, (LPMAPITABLE *)lppUnk);
        goto err;
    } else if (ulPropTag == PR_CONTAINER_HIERARCHY) {
        //
        //  Check to see if they're expecting a table interface
        //
        if (memcmp(lpiid, &IID_IMAPITable, sizeof(IID))) {
            hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED);
            goto err;
        }

        hr = DISTLIST_GetHierarchyTable(lpCONTAINER, ulInterfaceOptions, (LPMAPITABLE *) lppUnk);
        goto err;
    }

    //
    //  Don't recognize the property they want opened.
    //

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

err:
    LeaveCriticalSection(&lpCONTAINER->cs);

    DebugTraceResult(DISTLIST_OpenProperty, hr);
    return(hr);
}


/*************************************************************************
 *
 *
 -  DISTLIST_GetContentsTable
 -
 *
 *
 *  ulFlags - 0 or MAPI_UNICODE
 *
 */
STDMETHODIMP
DISTLIST_GetContentsTable(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable)
{

   LPTABLEDATA lpTableData = NULL;
   HRESULT hResult = hrSuccess;
   SCODE sc;
   LPSRowSet lpSRowSet = NULL;
   LPSPropValue lpSPropValue = NULL;
   LPTSTR lpTemp = NULL;
   ULONG ulCount = 0;
   ULONG i,j;
   ULONG ulcProps;
   SBinaryArray MVbin;
   LPSPropValue lpspv = NULL;
   ULONG cbEID, cbNewKey;
   LPBYTE lpbNewKey;
   LPSPropTagArray lpTableColumnsTemplate;
	
#ifdef	PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags & ~(MAPI_DEFERRED_ERRORS|MAPI_UNICODE)) {
        DebugTraceArg(DISTLIST_GetContentsTable,  TEXT("Unknown flags"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppTable, sizeof(LPMAPITABLE))) {
        DebugTraceArg(DISTLIST_GetContentsTable,  TEXT("Invalid Table parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif	// PARAMETER_VALIDATION


    // [PaulHi] 2/25/99  Raid 73170  Honor the MAPI_UNICODE bit in 
    // ulFlags.  If this bit isn't set then use the ANSI version of
    // the ITableColumns so ANSI property strings are returned to 
    // the user.
    if (ulFlags & MAPI_UNICODE)
        lpTableColumnsTemplate = (LPSPropTagArray)&ITableColumns;
    else
        lpTableColumnsTemplate = (LPSPropTagArray)&ITableColumns_A;

    sc = CreateTableData(
            NULL,                           // LPIID
            (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
            (ALLOCATEMORE FAR *) MAPIAllocateMore,
            MAPIFreeBuffer,
            NULL,                           // lpvReserved
            TBLTYPE_DYNAMIC,                // ulTableType
            PR_RECORD_KEY,                  // ulPropTagIndexCol
            lpTableColumnsTemplate,         // LPSPropTagArray lpptaCols
            NULL,                           // lpvDataSource
            0,                              // cbDataSource
            NULL,                           // pbinContEID
            ulFlags,                        // ulFlags
            &lpTableData);                  // lplptad

    if ( FAILED(sc) )
    {
        DebugTrace(TEXT("DISTLIST_GetContentsTable:CreateTableData -> %x\n"), sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }

    if (lpTableData) 
    {
        tagaWabDLEntries.aulPropTag[iwdePR_WAB_DL_ONEOFFS] = PR_WAB_DL_ONEOFFS;

        // Get the index to the distribution list from PR_WAB_DL_ENTRIES
        if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->GetProps(lpCONTAINER->lpPropData,
                                                                          (LPSPropTagArray)&tagaWabDLEntries,
                                                                          MAPI_UNICODE, &ulcProps, &lpspv))) 
        {
            DebugTraceResult( TEXT("DISTLIST_GetContentsTable:GetProps"), hResult);
            goto exit;
        }

        if (lpspv[iwdePR_WAB_DL_ENTRIES].ulPropTag == PR_WAB_DL_ENTRIES)
            ulCount += lpspv[iwdePR_WAB_DL_ENTRIES].Value.MVbin.cValues;

        if (lpspv[iwdePR_WAB_DL_ONEOFFS].ulPropTag == PR_WAB_DL_ONEOFFS) 
            ulCount += lpspv[iwdePR_WAB_DL_ONEOFFS].Value.MVbin.cValues;

        if(ulCount)
        {
            // DL has contents.
            // Now we need to move the information from the DL to
            // the SRowSet.  In the process, we need to create a few computed
            // properties:
            //  PR_INSTANCE_KEY
            //  PR_RECORD_KEY
            
            // Allocate the SRowSet
            if (FAILED(sc = MAPIAllocateBuffer(sizeof(SRowSet) + ulCount * sizeof(SRow), &lpSRowSet))) 
            {
                DebugTrace(TEXT("Allocation of SRowSet failed\n"));
                hResult = ResultFromScode(sc);
                goto exit;
            }

            lpSRowSet->cRows = 0;

            // Look at each entry in the PR_WAB_DL_ENTRIES
            for(j=iwdePR_WAB_DL_ENTRIES;j<=iwdePR_WAB_DL_ONEOFFS;j++)
            {
                if( (lpspv[j].ulPropTag != PR_WAB_DL_ENTRIES &&  lpspv[j].ulPropTag != PR_WAB_DL_ONEOFFS) ||
                    lpspv[j].Value.MVbin.cValues == 0)
                    continue;

                MVbin = lpspv[j].Value.MVbin;

                for (i = 0; i < MVbin.cValues; i++) 
                {
                    if (HR_FAILED(hResult = GetEntryProps((LPABCONT)lpCONTAINER,  // container object
                                                          MVbin.lpbin[i].cb,
                                                          (LPENTRYID)MVbin.lpbin[i].lpb,
                                                          lpTableColumnsTemplate,                   // default columns
                                                          lpSRowSet,                                // allocate more on here
                                                          ulFlags,                                  // 0 or MAPI_UNICODE
                                                          &ulcProps,                                // return count here
                                                          &lpSPropValue)))                          // return props here
                    {
                        DebugTraceResult( TEXT("DISTLIST_GetContentsTable:GetEntryProps\n"), hResult);
                        hResult = hrSuccess;
                        continue;
                    }

                    Assert(ulcProps == itcMax);

                    // Make certain we have proper indicies.
                    // PR_INSTANCE_KEY and PR_RECORD_KEY must be unique within the table!
                    // They can be the same, though.
                    // Append the index onto the entryid.
                    cbEID = lpSPropValue[itcPR_ENTRYID].Value.bin.cb;
                    cbNewKey = cbEID + sizeof(i);

                    if (FAILED(sc = MAPIAllocateMore(cbNewKey, lpSRowSet, &lpbNewKey))) {
                        hResult = ResultFromScode(sc);
                        DebugTrace(TEXT("GetContentsTable:MAPIAllocMore -> %x"), sc);
                        goto exit;
                    }
                    memcpy(lpbNewKey, lpSPropValue[itcPR_ENTRYID].Value.bin.lpb, cbEID);
                    memcpy(lpbNewKey + cbEID, &i, sizeof(i));

                    lpSPropValue[itcPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY;
                    lpSPropValue[itcPR_INSTANCE_KEY].Value.bin.cb = cbNewKey;
                    lpSPropValue[itcPR_INSTANCE_KEY].Value.bin.lpb = lpbNewKey;

                    lpSPropValue[itcPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY;
                    lpSPropValue[itcPR_RECORD_KEY].Value.bin.cb = cbNewKey;
                    lpSPropValue[itcPR_RECORD_KEY].Value.bin.lpb = lpbNewKey;


                    // Put it in the RowSet
                    lpSRowSet->aRow[lpSRowSet->cRows].cValues = ulcProps;      // number of properties
                    lpSRowSet->aRow[lpSRowSet->cRows].lpProps = lpSPropValue;  // LPSPropValue
                    lpSRowSet->cRows++;

                } // i
            }// j

            hResult = lpTableData->lpVtbl->HrModifyRows(lpTableData, 0, lpSRowSet);
        }

        hResult = lpTableData->lpVtbl->HrGetView(lpTableData,
                                                  NULL,                     // LPSSortOrderSet lpsos,
                                                  ContentsViewGone,         //  CALLERRELEASE FAR *	lpfReleaseCallback,
                                                  0,                        //  ULONG				ulReleaseData,
                                                  lppTable);                //  LPMAPITABLE FAR *	lplpmt)
    }
exit:
    FreeBufferAndNull(&lpspv);
    FreeBufferAndNull(&lpSRowSet);

    // Cleanup table if failure
    if (HR_FAILED(hResult)) {
        UlRelease(lpTableData);
    }

    return(hResult);
}

/*************************************************************************
 *
 *
 -	DISTLIST_GetHierarchyTable
 -
 *  Returns the merge of all the root hierarchy tables
 *
 *
 *
 */

STDMETHODIMP
DISTLIST_GetHierarchyTable (LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPMAPITABLE * lppTable)
{
    LPTSTR lpszMessage = NULL;
    ULONG ulLowLevelError = 0;
    HRESULT hr = hrSuccess;

#ifdef OLD_STUFF
#ifdef	PARAMETER_VALIDATION
    // Validate parameters
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpCONTAINER, sizeof(LPVOID))) {
        // No jump table found
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }


    // See if I can set the return variable
    if (IsBadWritePtr (lppTable, sizeof (LPMAPITABLE))) {
        hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
        return(hr);
    }

    // Check flags:
    // The only valid flags are CONVENIENT_DEPTH and MAPI_DEFERRED_ERRORS
    if (ulFlags & ~(CONVENIENT_DEPTH | MAPI_DEFERRED_ERRORS | MAPI_UNICODE)) {
        DebugTraceArg(DISTLIST_GetHierarchyTable ,  TEXT("Unknown flags used"));
//        return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
    }

#endif

    EnterCriticalSection(&lpCONTAINER->cs);

    if (lpCONTAINER->ulType != AB_DL) {
        //
        //  Wrong version of this object.  Pretend this object doesn't exist.
        //
        hr = ResultFromScode(MAPI_E_NO_SUPPORT);
        SetMAPIError(lpCONTAINER, hr, IDS_NO_HIERARCHY_TABLE, NULL, 0,
          0, 0, NULL);

        goto out;
    }

    //
    //  Check to see if we already have a table
    //
    EnterCriticalSection(&lpCONTAINER->lpIAB->cs);

    if (! lpCONTAINER->lpIAB->lpTableData) {
        //
        //  Open all the root level containers and merge their
        //  root level hierarchies.
        hr = MergeHierarchy(lpCONTAINER, lpCONTAINER->lpIAB, ulFlags);
        if (hr != hrSuccess) {
            LeaveCriticalSection(&lpCONTAINER->lpIAB->cs);
            goto out;
        }
    }
    LeaveCriticalSection(&lpCONTAINER->lpIAB->cs);

    //
    //  Get a view from the TAD
    //
    if (HR_FAILED(hr = lpCONTAINER->lpIAB->lpTableData->lpVtbl->HrGetView(
      lpCONTAINER->lpIAB->lpTableData,
      (LPSSortOrderSet)&sosPR_ROWID,
      NULL,
      0,
      lppTable))) {
        DebugTrace(TEXT("IAB_GetHierarchyTable Get Tad View failed\n"));
        goto out;
    }

#ifdef DEBUG
    if (hr == hrSuccess) {
        MAPISetBufferName(*lppTable,  TEXT("MergeHier VUE Object"));
    }
#endif

    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.

    if (! (ulFlags & CONVENIENT_DEPTH)) {
        SRestriction restrictDepth;
        SPropValue spvDepth;

        spvDepth.ulPropTag = PR_DEPTH;
        spvDepth.Value.l = 0;

        restrictDepth.rt = RES_PROPERTY;
        restrictDepth.res.resProperty.relop = RELOP_EQ;
        restrictDepth.res.resProperty.ulPropTag = PR_DEPTH;
        restrictDepth.res.resProperty.lpProp = &spvDepth;

        if (HR_FAILED(hr = (*lppTable)->lpVtbl->Restrict(*lppTable, &restrictDepth, 0))) {
            DebugTrace(TEXT("IAB_GetHierarchyTable restriction failed\n"));
            goto out;
        }
    }
out:
    LeaveCriticalSection(&lpCONTAINER->cs);

#endif // OLD_STUFF

    hr = ResultFromScode(MAPI_E_NO_SUPPORT);

    DebugTraceResult(DISTLIST_GetHierarchyTable, hr);
    return(hr);
}


/*************************************************************************
 *
 *
 -  DISTLIST_OpenEntry
 -
 *  Just call ABP_OpenEntry
 *
 *
 *
 */
STDMETHODIMP
DISTLIST_OpenEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk)
{
#ifdef	PARAMETER_VALIDATION
    //  Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, DISTLIST_, OpenEntry, lpVtbl)) {
        // jump table not large enough to support this method
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryids are valid
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab) || IsBadReadPtr((LPVOID)lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  "Undefined bits set in EntryID flags\n");
    }
*/
    // Don't check the interface parameter unless the entry is something
    // MAPI itself handles. The provider should return an error if this
    // parameter is something that it doesn't understand.
    // At this point, we just make sure it's readable.

    if (lpInterface && IsBadReadPtr(lpInterface, sizeof(IID))) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lpInterface fails address check"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }	

    if (ulFlags & ~(MAPI_MODIFY | MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS)) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("Unknown flags used"));
///        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr((LPVOID)lpulObjType, sizeof(ULONG))) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lpulObjType"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (IsBadWritePtr((LPVOID)lppUnk, sizeof(LPUNKNOWN))) {
        DebugTraceArg(DISTLIST_OpenEntry,  TEXT("lppUnk"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif	// PARAMETER_VALIDATION

    // Should just call IAB::OpenEntry()...
    return lpCONTAINER->lpIAB->lpVtbl->OpenEntry(lpCONTAINER->lpIAB,
      cbEntryID,
      lpEntryID,
      lpInterface,
      ulFlags,
      lpulObjType,
      lppUnk);
}


STDMETHODIMP
DISTLIST_SetSearchCriteria(LPCONTAINER lpCONTAINER,
  LPSRestriction lpRestriction,
  LPENTRYLIST lpContainerList,
  ULONG ulSearchFlags)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


STDMETHODIMP
DISTLIST_GetSearchCriteria(LPCONTAINER lpCONTAINER,
  ULONG ulFlags,
  LPSRestriction FAR * lppRestriction,
  LPENTRYLIST FAR * lppContainerList,
  ULONG FAR * lpulSearchState)
{
	return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/***************************************************************************

    Name      : DISTLIST_CreateEntry

    Purpose   : Add an entry in this Distribution List container

    Parameters: cbEntryID = size of lpEntryID
                lpEntryID -> EntryID to add to distribution list.
                ulCreateFlags = {CREATE_CHECK_DUP_STRICT,
                                CREATE_CHECK_DUP_LOOSE,
                                CREATE_REPLACE,
                                CREATE_MERGE}
                lppEntry -> Returned lpMAPIPROP object containing
                  the properties of the added entry.

    Returns   : HRESULT

    Comment   : Caller MUST SaveChanges on the returned IMAPIPROP object before
                this change will be saved.

                Caller has no ability to SetProps the properties in the returned
                object.

                Caller must Release the returned object.

                Unlike the PAB, the WAB stores Distribution Lists by reference.
                The contents of the container are stored in PR_WAB_DL_ENTRIES.

***************************************************************************/
STDMETHODIMP
DISTLIST_CreateEntry(LPCONTAINER lpCONTAINER,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulCreateFlags,
  LPMAPIPROP FAR * lppEntry)
{
    HRESULT hResult;
    LPMAILUSER lpOldEntry = NULL;
    ULONG ulObjectType;

#ifdef PARAMETER_VALIDATION

    // Validate the object.
    if (BAD_STANDARD_OBJ(lpCONTAINER, DISTLIST_, CreateEntry, lpVtbl)) {
        // jump table not large enough to support this method
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Bad object/Vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Check the entryid parameter. It needs to be big enough to hold an entryid.
    // Null entryid are bad
/*
    if (lpEntryID) {
        if (cbEntryID < offsetof(ENTRYID, ab) || IsBadReadPtr((LPVOID)lpEntryID, (UINT)cbEntryID)) {
            DebugTraceArg(DISTLIST_CreateEntry,  TEXT("lpEntryID fails address check"));
            return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
        }

        //NFAssertSz(FValidEntryIDFlags(lpEntryID->abFlags),
        //  "Undefined bits set in EntryID flags\n");
    } else {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("lpEntryID NULL"));
        return(ResultFromScode(MAPI_E_INVALID_ENTRYID));
    }
*/
    if (ulCreateFlags & ~(CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE | CREATE_REPLACE | CREATE_MERGE)) {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }

    if (IsBadWritePtr(lppEntry, sizeof(LPMAPIPROP))) {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Bad MAPI Property write parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
				
#endif	// PARAMETER_VALIDATION
    *lppEntry = NULL;

    if (cbEntryID == 0 || lpEntryID == NULL) {
        DebugTrace(TEXT("DISTLIST_CreateEntry: NULL EntryID passed in\n"));
        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto exit;
    }

    // Open and validate the entry.  Should NOT allow default entryid's,
    // root entryid, etc.  Must be a one-off, mailuser or distlist.
    if (hResult = lpCONTAINER->lpVtbl->OpenEntry(lpCONTAINER,
      cbEntryID,
      lpEntryID,
      NULL,
      0,                // ulFlags: Read only
      &ulObjectType,
      (LPUNKNOWN *)&lpOldEntry)) {
        DebugTrace(TEXT("DISTLIST_CreateEntry: OpenEntry -> %x\n"), GetScode(hResult));
        goto exit;
    }

    if (ulObjectType != MAPI_MAILUSER && ulObjectType != MAPI_DISTLIST) {
        DebugTrace(TEXT("DISTLIST_CreateEntry: bad object type passed in\n"));
        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID);
        goto exit;
    }

    if (hResult = HrNewDLENTRY(lpCONTAINER,
      (LPMAPIPROP)lpOldEntry,           // Old entry to copy from
      ulCreateFlags,
      (LPVOID *)lppEntry)) {
        goto exit;
    }

exit:
    UlRelease(lpOldEntry);

    if (HR_FAILED(hResult) && *lppEntry) {
        UlRelease(*lppEntry);
        *lppEntry = NULL;
    }

    return(hResult);
}


/*
 -	CopyEntries
 -
 *	Copies a list of entries into this container...  Since you can't
 *	do that with this container we just return not supported.
 */

STDMETHODIMP
DISTLIST_CopyEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulUIParam,
  LPMAPIPROGRESS lpProgress,
  ULONG ulFlags)
{
	return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


/*
 -  DeleteEntries
 -
 *
 *  Deletes entries within this container.
 */
STDMETHODIMP
DISTLIST_DeleteEntries(LPCONTAINER lpCONTAINER,
  LPENTRYLIST lpEntries,
  ULONG ulFlags)
{
    ULONG i, iEntries = (ULONG)-1, iOneOffs = (ULONG)-1;
    HRESULT hResult = hrSuccess;
    ULONG cDeleted = 0;
    ULONG cToDelete;
    ULONG cValues;
    LPSPropValue lpspv = NULL;

    SizedSPropTagArray(1, tagaDLOneOffsProp) =
    {
        1, PR_WAB_DL_ONEOFFS,
    };


#ifdef PARAMETER_VALIDATION

    if (BAD_STANDARD_OBJ(lpCONTAINER, DISTLIST_, DeleteEntries, lpVtbl)) {
        //  jump table not large enough to support this method
        DebugTraceArg(DISTLIST_DeleteEntries,  TEXT("Bad object/vtbl"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // ensure we can read the container list
    if (FBadEntryList(lpEntries)) {
        DebugTraceArg(DISTLIST_DeleteEntries,  TEXT("Bad Entrylist parameter"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    if (ulFlags) {
        DebugTraceArg(DISTLIST_CreateEntry,  TEXT("Unknown flags used"));
//        return(ResultFromScode(MAPI_E_UNKNOWN_FLAGS));
    }
	
#endif	// PARAMETER_VALIDATION

    // List of entryids is in lpEntries.  This is a counted array of
    // entryid SBinary structs.

    if (! (cToDelete = lpEntries->cValues)) {
        goto exit;                              // nothing to delete
    }

    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->GetProps(lpCONTAINER->lpPropData,
      NULL,
      MAPI_UNICODE,
      &cValues,
      &lpspv))) {
        DebugTraceResult( TEXT("DISTLIST_DeleteEntries:GetProps"), hResult);
        goto exit;
    }

    // Find the PR_WAB_DL_ENTRIES
    for (i = 0; i < cValues; i++) 
    {
        if (lpspv[i].ulPropTag == PR_WAB_DL_ENTRIES) 
            iEntries = i;
        else if(lpspv[i].ulPropTag == PR_WAB_DL_ONEOFFS) 
            iOneOffs = i;
    }

    // If there is no PR_WAB_DL_ENTRIES, then this DL contains no entries and we can't delete them.
    if (iEntries == (ULONG)-1 && iOneOffs == (ULONG)-1) 
    {
        hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
        goto exit;
    }

    // Delete each entry
    if(iEntries != (ULONG)-1)
    {
        for (i = 0; i < cToDelete; i++) 
        {
            if (! RemovePropFromMVBin(lpspv, cValues, iEntries, lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb)) 
            {
                cDeleted++;
                if (lpspv[iEntries].ulPropTag == PR_NULL) 
                {
                    // remove the property
                    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->DeleteProps(lpCONTAINER->lpPropData, (LPSPropTagArray)&tagaDLEntriesProp, NULL))) 
                    {
                        DebugTraceResult( TEXT("DISTLIST_DeleteEntries: DeleteProps on IProp"), hResult);
                        goto exit;
                    }
                    break;
                }
            }
        }
    }

    if(iOneOffs != (ULONG)-1)
    {
        for (i = 0; i < cToDelete; i++) 
        {
            if (! RemovePropFromMVBin(lpspv, cValues, iOneOffs, lpEntries->lpbin[i].lpb, lpEntries->lpbin[i].cb)) 
            {
                cDeleted++;
                if (lpspv[iOneOffs].ulPropTag == PR_NULL) 
                {
                    // remove the property
                    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->DeleteProps(lpCONTAINER->lpPropData, (LPSPropTagArray)&tagaDLOneOffsProp, NULL))) 
                    {
                        DebugTraceResult( TEXT("DISTLIST_DeleteEntries: DeleteProps on IProp"), hResult);
                        goto exit;
                    }
                    break;
                }
            }
        }
    }


    // Set the properties back
    if (HR_FAILED(hResult = lpCONTAINER->lpPropData->lpVtbl->SetProps(lpCONTAINER->lpPropData, cValues, lpspv, NULL))) 
    {
        DebugTraceResult( TEXT("DISTLIST_DeleteEntries: SetProps on IProp"), hResult);
        goto exit;
    }

    // Save the Distribution list to disk
    if (hResult = lpCONTAINER->lpVtbl->SaveChanges(lpCONTAINER, KEEP_OPEN_READWRITE)) 
    {
        DebugTraceResult( TEXT("DISTLIST_DeleteEntries:SaveChanges"), hResult);
    }

    if (! hResult) 
    {
        if (cDeleted != cToDelete) 
        {
            hResult = ResultFromScode(MAPI_W_PARTIAL_COMPLETION);
            DebugTrace(TEXT("DeleteEntries deleted %u of requested %u\n"), cDeleted, cToDelete);
        }
    }

exit:
    FreeBufferAndNull(&lpspv);
    return(hResult);
}


STDMETHODIMP
DISTLIST_ResolveNames(LPCONTAINER lpCONTAINER,
  LPSPropTagArray lptagaColSet,
  ULONG ulFlags,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}



//
//
//  DLENTRY Object - Distribution List entry.
//
//  Returned by CreateEntry in Distribution List.
//
//  Most of this object is implemented by the MailUser object.
//
//

DLENTRY_Vtbl vtblDLENTRY= {
    VTABLE_FILL
    DLENTRY_QueryInterface,
    (DLENTRY_AddRef_METHOD *)           WRAP_AddRef,
    DLENTRY_Release,
    (DLENTRY_GetLastError_METHOD *)     IAB_GetLastError,
    DLENTRY_SaveChanges,
    (DLENTRY_GetProps_METHOD *)         MailUser_GetProps,
    (DLENTRY_GetPropList_METHOD *)      MailUser_GetPropList,
    (DLENTRY_OpenProperty_METHOD *)     MailUser_OpenProperty,
    DLENTRY_SetProps,
    DLENTRY_DeleteProps,
    (DLENTRY_CopyTo_METHOD *)           MailUser_CopyTo,
    (DLENTRY_CopyProps_METHOD *)        MailUser_CopyProps,
    (DLENTRY_GetNamesFromIDs_METHOD *)  MailUser_GetNamesFromIDs,
    (DLENTRY_GetIDsFromNames_METHOD *)  MailUser_GetIDsFromNames
};


//
//  Interfaces supported by this object
//
#define DLENTRY_cInterfaces 1

LPIID DLENTRY_LPIID[DLENTRY_cInterfaces] =
{
	(LPIID) &IID_IMAPIProp
};


/***************************************************************************

    Name      : HrNewDLENTRY

    Purpose   : Creates a new DLENTRY object

    Parameters: lpCONTAINER -> DL Container
                ulCreateFlags = CreateEntry flags
                lppDLENTRY -> Returned DLENTRY object.

    Returns   : HRESULT

    Comment   :
***************************************************************************/
HRESULT HrNewDLENTRY(LPCONTAINER lpCONTAINER,
  LPMAPIPROP lpOldEntry,    // Old entry to copy from
  ULONG ulCreateFlags,
  LPVOID *lppDLENTRY)
{
    LPDLENTRY   lpDLENTRY       = NULL;
    SCODE       sc;
    HRESULT     hResult         = hrSuccess;
    LPPROPDATA  lpPropData      = NULL;
    ULONG       cValues;
    LPSPropValue lpspv          = NULL;


    //
    //  Allocate space for the DLENTRY structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(DLENTRY), (LPVOID *) &lpDLENTRY))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    ZeroMemory(lpDLENTRY, sizeof(DLENTRY));

    lpDLENTRY->cIID = DLENTRY_cInterfaces;
    lpDLENTRY->rglpIID = DLENTRY_LPIID;
    lpDLENTRY->lpVtbl = &vtblDLENTRY;
    lpDLENTRY->lcInit = 1;     // Caller is a reference
    lpDLENTRY->hLastError = hrSuccess;
    lpDLENTRY->idsLastError = 0;
    lpDLENTRY->lpszComponent = NULL;
    lpDLENTRY->ulContext = 0;
    lpDLENTRY->ulLowLevelError = 0;
    lpDLENTRY->ulErrorFlags = 0;
    lpDLENTRY->ulCreateFlags = ulCreateFlags;
    lpDLENTRY->lpMAPIError = NULL;
    lpDLENTRY->ulObjAccess = IPROP_READWRITE;
    lpDLENTRY->lpEntryID = NULL;
    lpDLENTRY->lpIAB = lpCONTAINER->lpIAB;
    lpDLENTRY->lpCONTAINER = lpCONTAINER;

    //
    //  Create IPropData
    //
    if (FAILED(sc = CreateIProp((LPIID)&IID_IMAPIPropData,
      (ALLOCATEBUFFER FAR *) MAPIAllocateBuffer,
      (ALLOCATEMORE FAR *) MAPIAllocateMore,
      MAPIFreeBuffer,
      NULL,
      &lpPropData))) {
        hResult = ResultFromScode(sc);
        goto exit;
    }

    //
    //  Copy the properties from the entry into the DLENTRY.
    //
    if (hResult = lpOldEntry->lpVtbl->GetProps(lpOldEntry,
      NULL,     // lpPropTagArray
      MAPI_UNICODE,        // ulFlags
      &cValues,
      &lpspv)) {
        DebugTrace(TEXT("HrNewDLENTRY: GetProps on old object -> %x\n"), GetScode(hResult));
        goto exit;
    }

    if (hResult = lpPropData->lpVtbl->SetProps(lpPropData,
      cValues,
      lpspv,
      NULL)) {
        DebugTrace(TEXT("HrNewDLENTRY: SetProps on IProp -> %x\n"), GetScode(hResult));
        goto exit;
    }

    // Done setting props, now make it read only.
    lpPropData->lpVtbl->HrSetObjAccess(lpPropData, IPROP_READONLY);

    lpDLENTRY->lpPropData = lpPropData;

    // Keep this container open since we need it in SaveChanges.  Will Release in DLENTRY_Release.
    UlAddRef(lpCONTAINER);

    // initialize the DLENTRYs critical section
    InitializeCriticalSection(&lpDLENTRY->cs);

    *lppDLENTRY = (LPVOID)lpDLENTRY;
exit:
    FreeBufferAndNull(&lpspv);

    if (HR_FAILED(hResult)) {
        FreeBufferAndNull(&lpDLENTRY);
        UlRelease(lpPropData);
        *lppDLENTRY = (LPVOID)NULL;
    }
    return(hResult);
}


/***************************************************************************

    Name      : CheckForCycle

    Purpose   : Does adding this entry to a DL generate a cycle?

    Parameters: lpAdrBook -> ADRBOOK object
                lpEIDChild -> EntryID of entry to be added to DL
                cbEIDChild = sizeof lpEIDChild
                lpEIDParent -> EntryID of distribution list that is being added to.
                cbEIDParent = sizeof lpEIDParent

    Returns   : TRUE if a cycle is detected.

    Comment   : This is a recursive routine.

***************************************************************************/
BOOL CheckForCycle(LPADRBOOK lpAdrBook,
  LPENTRYID lpEIDChild,
  ULONG cbEIDChild,
  LPENTRYID lpEIDParent,
  ULONG cbEIDParent)
{
    BOOL fCycle = FALSE;
    LPMAPIPROP lpDistList = NULL;
    ULONG ulcPropsDL;
    ULONG ulObjType;
    ULONG i;
    LPSPropValue lpPropArrayDL = NULL;

    if (cbEIDChild == cbEIDParent && ! memcmp(lpEIDChild, lpEIDParent, cbEIDChild))
    {
        return(TRUE);   // This is a cycle
    }

    if (lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
            cbEIDChild,
            lpEIDChild,
            NULL,
            0,
            &ulObjType,
            (LPUNKNOWN *)&lpDistList))
    {
        goto exit;  // Can't open child, it must not be a DL
    }

    if (ulObjType == MAPI_DISTLIST) {
        // Get the DL property
        if ( FAILED(lpDistList->lpVtbl->GetProps(
                        lpDistList,
                        (LPSPropTagArray)&tagaWabDLEntries,
                        MAPI_UNICODE,    // ulFlags,
                        &ulcPropsDL,
                        &lpPropArrayDL)) )
        {
            // No property, no entries in this DL.
            goto exit;
        }

        // Note we don't need to look for PR_WAB_DL_ONEOFFS since they won't be cycling ..
        if (lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].ulPropTag != PR_WAB_DL_ENTRIES)
        {
            goto exit;
        }

        // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
        for (i = 0; i < lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].Value.MVbin.cValues; i++)
        {
            if ( fCycle = CheckForCycle(lpAdrBook,
                    (LPENTRYID)lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].Value.MVbin.lpbin[i].lpb,
                    lpPropArrayDL[iwdePR_WAB_DL_ENTRIES].Value.MVbin.lpbin[i].cb,
                    (LPENTRYID)lpEIDParent,
                    cbEIDParent) )
            {
                DebugTrace(TEXT("CheckForCycle found cycle\n"));
                goto exit;
            }
        }
    }
exit:
    FreeBufferAndNull(&lpPropArrayDL);
    UlRelease(lpDistList);

    return(fCycle);
}


// --------
// IUnknown

STDMETHODIMP
DLENTRY_QueryInterface(LPDLENTRY lpDLENTRY,
  REFIID lpiid,
  LPVOID * lppNewObj)
{
	ULONG iIID;

#ifdef PARAMETER_VALIDATION
	// Check to see if it has a jump table
	if (IsBadReadPtr(lpDLENTRY, sizeof(LPVOID))) {
		// No jump table found
		return(ResultFromScode(E_INVALIDARG));
	}

	// Check to see if the jump table has at least sizeof IUnknown
	if (IsBadReadPtr(lpDLENTRY->lpVtbl, 3 * sizeof(LPVOID))) {
		// Jump table not derived from IUnknown
		return(ResultFromScode(E_INVALIDARG));
	}

	// Check to see that it's DLENTRY_QueryInterface
	if (lpDLENTRY->lpVtbl->QueryInterface != DLENTRY_QueryInterface) {
		// Not my jump table
		return(ResultFromScode(E_INVALIDARG));
	}

	// Is there enough there for an interface ID?

	if (IsBadReadPtr(lpiid, sizeof(IID))) {
		DebugTraceSc(DLENTRY_QueryInterface, E_INVALIDARG);
		return(ResultFromScode(E_INVALIDARG));
	}

	// Is there enough there for a new object?
	if (IsBadWritePtr(lppNewObj, sizeof(LPDLENTRY))) {
		DebugTraceSc(DLENTRY_QueryInterface, E_INVALIDARG);
		return(ResultFromScode(E_INVALIDARG));
	}

#endif // PARAMETER_VALIDATION

	EnterCriticalSection(&lpDLENTRY->cs);

	// See if the requested interface is one of ours

	//  First check with IUnknown, since we all have to support that one...
	if (! memcmp(lpiid, &IID_IUnknown, sizeof(IID))) {
		goto goodiid;        // GROSS!  Jump into a for loop!
   }

	//  Now look through all the iids associated with this object, see if any match
	for(iIID = 0; iIID < lpDLENTRY->cIID; iIID++)
		if (! memcmp(lpDLENTRY->rglpIID[iIID], lpiid, sizeof(IID))) {
goodiid:
			//
			//  It's a match of interfaces, we support this one then...
			//
			++lpDLENTRY->lcInit;
			*lppNewObj = lpDLENTRY;

			LeaveCriticalSection(&lpDLENTRY->cs);

			return(0);
		}

	//
	//  No interface we've heard of...
	//
	LeaveCriticalSection(&lpDLENTRY->cs);

	*lppNewObj = NULL;	// OLE requires NULLing out parm on failure
	DebugTraceSc(DLENTRY_QueryInterface, E_NOINTERFACE);
	return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG)
DLENTRY_Release(LPDLENTRY lpDLENTRY)
{

#if	!defined(NO_VALIDATION)
    //
    // Make sure the object is valid.
    //
    if (BAD_STANDARD_OBJ(lpDLENTRY, DLENTRY_, Release, lpVtbl)) {
        return(1);
    }
#endif

    EnterCriticalSection(&lpDLENTRY->cs);

    --lpDLENTRY->lcInit;

    if (lpDLENTRY->lcInit == 0) {
        UlRelease(lpDLENTRY->lpPropData);

        UlRelease(lpDLENTRY->lpCONTAINER);  // parent DL container

        //
        //  Need to free the object
        //
        LeaveCriticalSection(&lpDLENTRY->cs);
        DeleteCriticalSection(&lpDLENTRY->cs);
        FreeBufferAndNull(&lpDLENTRY);
        return(0);
    }

    LeaveCriticalSection(&lpDLENTRY->cs);
    return(lpDLENTRY->lcInit);
}


//
// IProperty
//


STDMETHODIMP
DLENTRY_SaveChanges(LPDLENTRY lpDLENTRY,
  ULONG ulFlags)
{
    HRESULT         hResult = hrSuccess;
    LPSPropValue    lpPropArrayDL = NULL;
    LPSPropValue    lpPropArrayEntry = NULL;
    ULONG           ulcPropsDL, ulcPropsEntry;
    LPCONTAINER     lpCONTAINER = NULL;
    LPENTRYID lpEIDAdd;
    ULONG cbEIDAdd;
    BOOL            bUseOneOffProp = FALSE;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

#if	!defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpDLENTRY, DLENTRY_, SaveChanges, lpVtbl)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }
#endif
    //
    // check read write access ...
    //
    if (lpDLENTRY->ulObjAccess == IPROP_READONLY) {
        // error - cant save changes
        hResult = MAPI_E_NO_ACCESS;
        goto exit;
    }


    // Get the ENTRYID of this entry
    if (hResult = lpDLENTRY->lpPropData->lpVtbl->GetProps(lpDLENTRY->lpPropData,
                                                          (LPSPropTagArray)&ptaEid,    // also include PR_DISPLAYNAME
                                                          MAPI_UNICODE,    // ulFlags,
                                                          &ulcPropsEntry,
                                                          &lpPropArrayEntry)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: GetProps(DLENTRY) -> %x\n"), GetScode(hResult));
        goto exit;
    }

    Assert(lpPropArrayEntry && lpPropArrayEntry[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID);

    cbEIDAdd = lpPropArrayEntry[ieidPR_ENTRYID].Value.bin.cb;
    lpEIDAdd = (LPENTRYID)lpPropArrayEntry[ieidPR_ENTRYID].Value.bin.lpb;

    lpCONTAINER = lpDLENTRY->lpCONTAINER;

    // Merge it into PR_WAB_DL_ENTRIES of the DL unless it's a ONEOFF in which case merge it into the OneOffs
    tagaWabDLEntries.aulPropTag[iwdePR_WAB_DL_ONEOFFS] = PR_WAB_DL_ONEOFFS;

    if (hResult = lpCONTAINER->lpVtbl->GetProps(lpCONTAINER,
                                                  (LPSPropTagArray)&tagaWabDLEntries,
                                                  MAPI_UNICODE,    // ulFlags,
                                                  &ulcPropsDL,
                                                  &lpPropArrayDL)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: GetProps(DL) -> %x\n"), GetScode(hResult));
        // No property, not fatal.
    } 
    else 
    {
        // Check for duplicates.  In DISTLIST, we only support duplicate ENTRYID checking,
        // so CREATE_CHECK_DUP_STRICT is the same as CREATE_CHECK_DUP_LOOSE.
        if (lpDLENTRY->ulCreateFlags & (CREATE_CHECK_DUP_STRICT | CREATE_CHECK_DUP_LOOSE)) 
        {
            SBinaryArray MVbin;
            ULONG ulCount;
            ULONG i,j;

            for(j=iwdePR_WAB_DL_ENTRIES;j<=iwdePR_WAB_DL_ONEOFFS;j++)
            {

                if(lpPropArrayDL[j].ulPropTag == PR_NULL || !lpPropArrayDL[j].Value.MVbin.cValues)
                    continue;

                // Yes, check for duplicates
                MVbin = lpPropArrayDL[j].Value.MVbin;
                ulCount = MVbin.cValues;

                for (i = 0; i < ulCount; i++) 
                {

                    if ((cbEIDAdd == MVbin.lpbin[i].cb) &&
                        !memcmp(lpEIDAdd, MVbin.lpbin[i].lpb, cbEIDAdd)) 
                    {
                        // This EntryID is already in the list.
                        // Handle duplicate.

                        // Since we are only checking against ENTRYID, we don't have to
                        // actually REPLACE.  We just pretend we did something and don't fail.
                        if (! (lpDLENTRY->ulCreateFlags & CREATE_REPLACE)) 
                        {
                            hResult = ResultFromScode(MAPI_E_COLLISION);
                            goto exit;
                        }
                        goto nosave;
                    }
                } // i
            }// j
        }
    }

    if (CheckForCycle((LPADRBOOK)lpDLENTRY->lpCONTAINER->lpIAB,
                      lpEIDAdd, cbEIDAdd,
                      (LPENTRYID)lpPropArrayDL[iwdePR_ENTRYID].Value.bin.lpb,
                      lpPropArrayDL[iwdePR_ENTRYID].Value.bin.cb)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges found cycle\n"));
        hResult = ResultFromScode(MAPI_E_FOLDER_CYCLE);
        goto exit;
    }

    if(WAB_ONEOFF == IsWABEntryID(cbEIDAdd, lpEIDAdd, NULL, NULL, NULL, NULL, NULL))
        bUseOneOffProp = TRUE;
    if(pt_bIsWABOpenExSession)
        bUseOneOffProp = FALSE;

    if (hResult = AddPropToMVPBin(lpPropArrayDL,
                                (bUseOneOffProp ? iwdePR_WAB_DL_ONEOFFS : iwdePR_WAB_DL_ENTRIES),
                                (LPBYTE)lpEIDAdd,
                                cbEIDAdd,
                                TRUE))         // no duplicates
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: AddPropToMVPBin -> %x\n"), GetScode(hResult));
        goto exit;
    }

    if (hResult = lpCONTAINER->lpVtbl->SetProps(lpCONTAINER, ulcPropsDL, lpPropArrayDL, NULL)) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: SetProps(DL) -> %x\n"), GetScode(hResult));
        goto exit;
    }

    // Save the modified DL, keeping it open/writable.
    if (HR_FAILED(hResult = lpCONTAINER->lpVtbl->SaveChanges(lpCONTAINER, FORCE_SAVE | KEEP_OPEN_READWRITE))) 
    {
        DebugTrace(TEXT("DLENTRY_SaveChanges: container SaveChanges -> %x\n"), GetScode(hResult));
        goto exit;
    }

nosave:
    if (ulFlags & KEEP_OPEN_READWRITE) {
        lpDLENTRY->ulObjAccess = IPROP_READWRITE;
    } else {
        //$REVIEW
        // whether the flag was READONLY or there was no flag,
        // we'll make the future access now READONLY
        //
        lpDLENTRY->ulObjAccess = IPROP_READONLY;
    }

exit:
    FreeBufferAndNull(&lpPropArrayDL);
    FreeBufferAndNull(&lpPropArrayEntry);

    if ((HR_FAILED(hResult)) && (ulFlags & MAPI_DEFERRED_ERRORS)) {
        //$REVIEW : this is a grossly trivial handling of MAPI_DEFERRED_ERRORS ..
        // BUGBUG: In fact, it isn't handling the errors at all!
        //
        hResult = hrSuccess;
    }

    return(hResult);
}


STDMETHODIMP
DLENTRY_SetProps(LPDLENTRY lpDLENTRY,
  ULONG cValues,
  LPSPropValue lpPropArray,
  LPSPropProblemArray * lppProblems)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}


STDMETHODIMP
DLENTRY_DeleteProps(LPDLENTRY lpDLENTRY,
  LPSPropTagArray lpPropTagArray,
  LPSPropProblemArray * lppProblems)
{
    return(ResultFromScode(MAPI_E_NO_SUPPORT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/


#if !defined(__DEMAND_H) || defined(IMPLEMENT_LOADER_FUNCTIONS)

#ifndef __DEMAND_H
#define __DEMAND_H
#endif


#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define USE_CRITSEC

#undef LOADER_FUNCTION
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret LOADER_##name args1                         \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#undef LOADER_FUNCTION_VOID
#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret LOADER_##name args1                         \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

BOOL DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef ULONG_PTR HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    1, Crypt32)
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertOpenSystemStoreA VAR_CertOpenSystemStoreA

LOADER_FUNCTION( HCERTSTORE, CertOpenSystemStoreA,
    (HCRYPTPROV hProv, LPCSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol),
    NULL, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef ULONG_PTR HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextA,
    (HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextA VAR_CryptAcquireContextA

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCTSTR pszContainer, LPCTSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    FALSE, Crypt32)
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded,
     DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara,
     void * pvStructInfo, DWORD * pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
     pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

/////////////////////////////////////
// PSTOREC.DLL

#ifndef __IEnumPStoreProviders_FWD_DEFINED__
    #define __IEnumPStoreProviders_FWD_DEFINED__
    typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif 	/* __IEnumPStoreProviders_FWD_DEFINED__ */
#ifndef __IPStore_FWD_DEFINED__
    #define __IPStore_FWD_DEFINED__
    typedef interface IPStore IPStore;
#endif 	/* __IPStore_FWD_DEFINED__ */
typedef GUID PST_PROVIDERID;

BOOL DemandLoadPStoreC();

LOADER_FUNCTION( HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL, PStoreC)
#define PStoreCreateInstance VAR_PStoreCreateInstance

LOADER_FUNCTION( HRESULT, PStoreEnumProviders,
    (DWORD dwFlags, IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum),
    (dwFlags, ppenum),
    E_FAIL, PStoreC)
#define PStoreEnumProviders VAR_PStoreEnumProviders


/////////////////////////////////////
// CRYPTDLG.DLL

BOOL DemandLoadCryptDlg();

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

/////////////////////////////////////
// WINTRUST.DLL

BOOL DemandLoadWinTrust();

LOADER_FUNCTION( LONG, WinVerifyTrust,
    (HWND hwnd, GUID *ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData),
    0, WinTrust)
#define WinVerifyTrust VAR_WinVerifyTrust

/////////////////////////////////////
// VERSION.DLL

BOOL DemandLoadVersion(void);

LOADER_FUNCTION( DWORD, GetFileVersionInfoSizeA,
    (LPSTR lptstrFileName, LPDWORD lpdwHandle),
    (lptstrFileName, lpdwHandle),
    0, Version)
#define GetFileVersionInfoSizeA VAR_GetFileVersionInfoSizeA

LOADER_FUNCTION( BOOL, GetFileVersionInfoA,
    (LPSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, Version)
#define GetFileVersionInfoA VAR_GetFileVersionInfoA

LOADER_FUNCTION( BOOL, VerQueryValueA,
    (const LPVOID pBlock, LPSTR lpSubBlock, LPVOID * lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, Version)
#define VerQueryValueA VAR_VerQueryValueA

LOADER_FUNCTION( DWORD, GetFileVersionInfoSizeW,
    (LPTSTR lptstrFileName, LPDWORD lpdwHandle),
    (lptstrFileName, lpdwHandle),
    0, Version)
#define GetFileVersionInfoSizeW VAR_GetFileVersionInfoSizeW

LOADER_FUNCTION( BOOL, GetFileVersionInfoW,
    (LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, Version)
#define GetFileVersionInfoW VAR_GetFileVersionInfoW

LOADER_FUNCTION( BOOL, VerQueryValueW,
    (const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID * lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, Version)
#define VerQueryValueW VAR_VerQueryValueW


/////////////////////////////////////
// URLMON.DLL

BOOL DemandLoadURLMON();

LOADER_FUNCTION( HRESULT, ObtainUserAgentString,
    (DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize),
    (dwOption, pszUAOut, cbSize),
    E_FAIL, URLMON)
#define ObtainUserAgentString VAR_ObtainUserAgentString

// IMM32.DLL
BOOL DemandLoadImm32(void);

LOADER_FUNCTION(HIMC, ImmAssociateContext,
                (HWND hWnd,     HIMC hIMC),
                (hWnd, hIMC),
                0, Imm32)
#define ImmAssociateContext VAR_ImmAssociateContext

LOADER_FUNCTION(HIMC, ImmGetContext,
                (HWND hWnd),
                (hWnd),
                0, Imm32)
#define ImmGetContext VAR_ImmGetContext

LOADER_FUNCTION(LONG, ImmGetCompositionStringW,
                (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen),
                (hIMC, dwIndex, lpBuf, dwBufLen),
                0, Imm32)
#define ImmGetCompositionStringW VAR_ImmGetCompositionStringW

LOADER_FUNCTION(BOOL, ImmReleaseContext,
                (HWND hWnd, HIMC hIMC),
                (hWnd, hIMC),
                0, Imm32)
#define ImmReleaseContext VAR_ImmReleaseContext

// Wininet.DLL
BOOL DemandLoadWininet(void);

LOADER_FUNCTION(BOOL, InternetCanonicalizeUrlW,
                (LPCWSTR lpszUrl, LPWSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
                (lpszUrl, lpszBuffer, lpdwBufferLength, dwFlags),
                FALSE, Wininet)
#define InternetCanonicalizeUrlW VAR_InternetCanonicalizeUrlW

LOADER_FUNCTION(BOOL, InternetGetConnectedState,
                (LPDWORD lpdwFlags, DWORD dwReserved),
                (lpdwFlags, dwReserved),
                FALSE, Wininet)
#define InternetGetConnectedState VAR_InternetGetConnectedState


///////////////////////////////////////////////////////////////////////////////
//  SHLWAPI.DLL

HINSTANCE DemandLoadShlwapi();

///////////////////////////////////////////////////////////////////////////////
//  Plus UI wrapper functions for WinHelp and HtmlHelp functions.  If 5.0 (IE5)
//  version of Shlwapi.dll is available then its version of the functions are
//  used.  Default is to system versions.  If runnint WinNT5.0 or greater then
//  cross codepage is used.
//
//  Implementation of these functions are in the entry.c file
///////////////////////////////////////////////////////////////////////////////
BOOL WinHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData);
#define WABWinHelp WinHelpWrap

HWND HtmlHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData);
#define WABHtmlHelp HtmlHelpWrap

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\demand.c ===
/*
**	d e m a n d . c p p
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#include "_apipch.h"

// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

#include <wincrypt.h>
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

////////////////////////////////////////////////////////////////////////////
//
//  Macros

#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
        temp = (TYP_##fn) GetProcAddress(h, #fn);   \
        if (temp)                                   \
            VAR_##fn = temp;                        \
        else                                        \
            {                                       \
            AssertSz(VAR_##fn TEXT(" failed to load"));    \
            goto error;                             \
            }

#define RESET(fn)                                   \
        VAR_##fn = LOADER_##fn;

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        Assert(VAR_##fn != NULL); \
        if(NULL == VAR_##fn ) { \
            VAR_##fn  = LOADER_##fn; \
        }

#define GET_PROC_ADDR3(h, fn, varname) \
        VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
        Assert(VAR_##varname != NULL);

#define GET_PROC_ADDR_FLAG(h, fn, pflag) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        *pflag = (VAR_##fn != NULL);


////////////////////////////////////////////////////////////////////////////
//
//  Variables

static HMODULE          s_hCrypt = 0;
static HMODULE          s_hAdvApi = 0;
static HMODULE          s_hPstoreC = 0;
static HMODULE          s_hCryptDlg = 0;
static HMODULE          s_hWinTrust = 0;
static HMODULE          s_hVersion = 0;
static HMODULE          s_hImm32 = 0;
static HMODULE          s_hWininet = 0;
static HMODULE          s_hUrlmon = 0;
static HMODULE          s_hShlwapi = NULL;

#ifdef USE_CRITSEC
static CRITICAL_SECTION cs = {0};
#endif

#ifdef DEBUG
static BOOL             s_fInit = FALSE;
#endif

////////////////////////////////////////////////////////////////////////////
//
//  Management functions

void InitDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    InitializeCriticalSection(&cs);
#endif
#ifdef DEBUG
    s_fInit = TRUE;
#endif
}

void FreeDemandLoadedLibs()
{
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif
    if (s_hCrypt)
        FreeLibrary(s_hCrypt);
    if (s_hAdvApi)
        FreeLibrary(s_hAdvApi);
    if (s_hPstoreC)
        FreeLibrary(s_hPstoreC);
    if (s_hCryptDlg)
        FreeLibrary(s_hCryptDlg);
    if (s_hWinTrust)
        FreeLibrary(s_hWinTrust);
    if (s_hVersion)
        FreeLibrary(s_hVersion);
    if (s_hImm32)
        FreeLibrary(s_hImm32);
    if (s_hWininet)
        FreeLibrary(s_hWininet);
    if (s_hUrlmon)
        FreeLibrary(s_hUrlmon);
    if (s_hShlwapi)
        FreeLibrary(s_hShlwapi);

#ifdef DEBUG
    s_fInit = FALSE;
#endif
#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
    DeleteCriticalSection(&cs);
#endif
}

////////////////////////////////////////////////////////////////////////////
//
//  Loader functions

/* sample loader with critical proc addrs
** but not thread-safe
BOOL DemandLoadFoo()
{
    FARPROC fp;

    if (0 == g_hFoo)
        {
        g_hFoo = LoadLibrary("FOO.DLL");

        if (0 == g_hFoo)
            return FALSE;

        CRIT_GET_PROC_ADDR(NeededFunction1, fp);
        CRIT_GET_PROC_ADDR(NeededFunction2, fp);
        GET_PROC_ADDR(OptionalFunction);
        }
    return TRUE;

error:
    FreeLibrary(g_hFoo);
    g_hFoo = NULL;
    RESET(NeededFunction1)
    RESET(NeededFunction2)
    RESET(OptionalFunction)
    return FALSE;
}
*/

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadCrypt32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary(TEXT("CRYPT32.DLL"));
        AssertSz((NULL != s_hCrypt), TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity)
            GET_PROC_ADDR(s_hCrypt, CertOpenSystemStoreA)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hAdvApi)
        {
        s_hAdvApi = LoadLibrary(TEXT("ADVAPI32.DLL"));
        AssertSz((NULL != s_hAdvApi), TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextA)
            GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadPStoreC()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hPstoreC)
        {
        s_hPstoreC = LoadLibrary(TEXT("PSTOREC.DLL"));
        AssertSz((NULL != s_hPstoreC), TEXT("LoadLibrary failed on PSTOREC.DLL"));

        if (0 == s_hPstoreC)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hPstoreC, PStoreCreateInstance)
            GET_PROC_ADDR(s_hPstoreC, PStoreEnumProviders)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
static BOOL s_fCertViewPropertiesCryptUIA = FALSE;

BOOL DemandLoadCryptDlg()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hCryptDlg)
        {
        s_hCryptDlg = LoadLibrary(TEXT("CRYPTDLG.DLL"));
        AssertSz((NULL != s_hCryptDlg), TEXT("LoadLibrary failed on CRYPTDLG.DLL"));

        if (0 == s_hCryptDlg)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL CryptUIAvailable(void) {
    DemandLoadCryptDlg();
    return(s_fCertViewPropertiesCryptUIA);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadWinTrust()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hWinTrust)
        {
        s_hWinTrust = LoadLibrary(TEXT("WINTRUST.DLL"));
        AssertSz((NULL != s_hWinTrust), TEXT("LoadLibrary failed on WINTRUST.DLL"));

        if (0 == s_hWinTrust)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinTrust, WinVerifyTrust)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL DemandLoadVersion()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hVersion)
        {
        s_hVersion = LoadLibrary(TEXT("VERSION.DLL"));
        AssertSz((NULL != s_hVersion), TEXT("LoadLibrary failed on VERSION.DLL"));

        if (0 == s_hVersion)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeW)
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoW)
            GET_PROC_ADDR(s_hVersion, VerQueryValueW)
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeA)
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoA)
            GET_PROC_ADDR(s_hVersion, VerQueryValueA)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL DemandLoadImm32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hImm32)
        {
        s_hImm32 = LoadLibrary(TEXT("IMM32.DLL"));
        AssertSz((NULL != s_hImm32), TEXT("LoadLibrary failed on IMM32.DLL"));

        if (0 == s_hImm32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hImm32, ImmAssociateContext)
            GET_PROC_ADDR(s_hImm32, ImmGetContext)
            GET_PROC_ADDR(s_hImm32, ImmGetCompositionStringW)
            GET_PROC_ADDR(s_hImm32, ImmReleaseContext)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}

BOOL DemandLoadWininet()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hWininet)
        {
        s_hWininet = LoadLibrary(TEXT("wininet.dll"));
        AssertSz((NULL != s_hWininet), TEXT("LoadLibrary failed on Wininet.DLL"));

        if (0 == s_hWininet)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWininet, InternetCanonicalizeUrlW)
            GET_PROC_ADDR(s_hWininet, InternetGetConnectedState)
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


BOOL DemandLoadURLMON(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (0 == s_hUrlmon)
        {
        s_hUrlmon = LoadLibrary(TEXT("URLMON.DLL"));
        AssertSz((NULL != s_hUrlmon), TEXT("LoadLibrary failed on Urlmon.DLL"));

        if (0 == s_hUrlmon)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hUrlmon, ObtainUserAgentString);
            }
        }

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif
    return fRet;
}


///////////////////////////////////////////////////////////////////////////////
//  DemandLoadShlwapi()
//
//  Only load version 5.0 or greater
///////////////////////////////////////////////////////////////////////////////
static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");

HINSTANCE DemandLoadShlwapi()
{
    Assert(s_fInit);
#ifdef USE_CRITSEC
    EnterCriticalSection(&cs);
#endif

    if (!s_hShlwapi)
        s_hShlwapi = LoadLibrary(c_szShlwapiDll);

#ifdef USE_CRITSEC
    LeaveCriticalSection(&cs);
#endif

    return s_hShlwapi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dllload.c ===
#include "_apipch.h"
#include <pstore.h>
#define _CRYPTDLG_
#include <cryptdlg.h>

#pragma hdrstop
#pragma warning(disable:4229)  // No warnings when modifiers used on data

// flags to enable selective def-loading of dlls.
#define DEFLOAD_PSTOREC
#define DEFLOAD_CRYPTDLG

#define ENSURE_LOADED(_hinst, _dll)   (_hinst ? TRUE : (BOOL)(_hinst = LoadLibrary(TEXT(#_dll))))
#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)                    \
_ret __stdcall _fn _args                                                                \
{                                                                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return (_ret)_err;                                                              \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn);                         \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return (_ret)_err;                                                          \
    }                                                                                   \
    return _pfn##_fn _nargs;                                                            \
}

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, BOOL, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs)                               \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn);                         \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fn _nargs;                                                                   \
}



// For private entrypoints exported by ordinal.
#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err)          \
_ret __stdcall _fn _args                                                                \
{                                                                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return (_ret)_err;                                                              \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord);                 \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return (_ret)_err;                                                          \
    }                                                                                   \
    return _pfn##_fn _nargs;                                                            \
}

#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_VOID_ORD(_hinst, _dll, _fn, _ord, _args, _nargs)                     \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hinst, _dll))                                                   \
    {                                                                                   \
        if(!_hinst) DebugTrace(TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fn == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, MAKEINTRESOURCE(_ord));        \
        if(!_pfn##_fn) DebugTrace(TEXT("GetProcAddress failed on ") ## TEXT(#_fn));    \
        if (_pfn##_fn == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fn _nargs;                                                                   \
}


#ifdef DEFLOAD_PSTOREC
// -------  pstorec.dll -------
HINSTANCE g_hinstPSTOREC = NULL;

#ifndef WIN16
DELAY_LOAD(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags));

DELAY_LOAD(g_hinstPSTOREC, PSTOREC.DLL, HRESULT, PStoreEnumProviders,
    (DWORD dwFlags, IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum),
    (dwFlags, ppenum));
#endif

#endif

#ifdef DEFLOAD_CRYPTDLG
// -------  cryptdlg.dll -------

HINSTANCE g_hinstCRYPTDLG = NULL;

#ifndef WIN16
DELAY_LOAD(g_hinstCRYPTDLG, CRYPTDLG.DLL, BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo));

DELAY_LOAD(g_hinstCRYPTDLG, CRYPTDLG.DLL, BOOL, CertViewPropertiesCryptUIA,
    (PCERT_VIEWPROPERTIESCRYPTUI_STRUCT_A pCertViewInfo),
    (pCertViewInfo));
#endif

#endif

void DefLoadFreeLibraries()
{
#ifdef DEFLOAD_PSTOREC
    if (g_hinstPSTOREC)
        {
        FreeLibrary(g_hinstPSTOREC);
        g_hinstPSTOREC=0;
        }
    if (g_hinstCRYPTDLG)
        {
        FreeLibrary(g_hinstCRYPTDLG);
        g_hinstCRYPTDLG=0;
        }
#endif
}

// --------------------------------------------
// these macros produce code that looks like
//
#if 0

BOOL GetOpenFileName(LPOPENFILENAME pof)
{
    static BOOL (*pfnGetOpenFileName)(LPOPENFILENAME pof);

    if (ENSURE_LOADED(g_hinstCOMDLG32, "COMDLG32.DLL"))
    {
        if (pfnGetOpenFileName == NULL)
            pfnGetOpenFileName = (BOOL (*)(LPOPENFILENAME))GetProcAddress(g_hinstCOMDLG32, "GetOpenFileNameW");

        if (pfnGetOpenFileName)
            return pfnGetOpenFileName(pof);
    }
    return -1;
}
#endif

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\fonts.h ===
#ifndef _FONTS_H
#define _FONTS_H

#include <richedit.h>

enum {
    fntsSysIcon=0,
    fntsSysIconBold,
    //fntsSysIconItalic,
    //fntsSysIconBoldItalic,
    //fntsSysMenu,
    //fntsFolderNameHorz,
    //fntsFolderNameVert,
    fntsMax
    };

BOOL InitFonts(void);
HFONT GetFont(int ifont);
void DeleteFonts(void);

#endif      //_FONTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dochost.c ===
/*********************************************************************************

    DocHost.c
       - This file contains the code for implementing a DOC Object COntainer
            which we will use to host trident

    Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.

    Revision History:

    When		 Who				 What
    --------	 ------------------  ---------------------------------------
    04/22/97    Vikram Madan        Ported from athenas dochost code

***********************************************************************************/

#include <_apipch.h>

LPTSTR c_szWABDocHostWndClass = TEXT("WAB_DocHost");

LPCREATEURLMONIKER lpfnCreateURLMoniker = NULL;

BOOL fTridentCoinit = FALSE;

//
// Function Prototypes
//
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void WMSize(LPIWABDOCHOST lpIWABDocHost, int x, int y);
HRESULT HrCreateDocObj(LPIWABDOCHOST lpIWABDocHost, LPCLSID pCLSID);
HRESULT HrShow(LPIWABDOCHOST lpIWABDocHost);
HRESULT HrCloseDocObj(LPIWABDOCHOST lpIWABDocHost);
HRESULT HrDocHost_Init(LPIWABDOCHOST lpIWABDocHost, BOOL fInit);
HRESULT HrCreateDocView(LPIWABDOCHOST lpIWABDocHost, LPOLEDOCUMENTVIEW pViewToActivate);
HRESULT HrLoadTheURL(LPIWABDOCHOST lpWABDH, LPTSTR pszURL);
HRESULT HrLoadFromMoniker(LPIWABDOCHOST lpIWABDocHost, LPMONIKER pmk);



//
//  IWABDocHost jump tables is defined here...
//

IWABDOCHOST_Vtbl vtblIWABDOCHOST = {
    VTABLE_FILL
    IWABDOCHOST_QueryInterface,
    IWABDOCHOST_AddRef,
    IWABDOCHOST_Release,
};


IWDH_OLEWINDOW_Vtbl vtblIWDH_OLEWINDOW = {
    VTABLE_FILL
    (IWDH_OLEWINDOW_QueryInterface_METHOD *) IWABDOCHOST_QueryInterface,
    (IWDH_OLEWINDOW_AddRef_METHOD *)         IWABDOCHOST_AddRef,
    (IWDH_OLEWINDOW_Release_METHOD *)        IWABDOCHOST_Release,
    IWDH_OLEWINDOW_GetWindow,
    IWDH_OLEWINDOW_ContextSensitiveHelp,
};


IWDH_OLEINPLACEFRAME_Vtbl vtblIWDH_OLEINPLACEFRAME = {
    VTABLE_FILL
    (IWDH_OLEINPLACEFRAME_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLEINPLACEFRAME_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLEINPLACEFRAME_Release_METHOD *)          IWABDOCHOST_Release,
    (IWDH_OLEINPLACEFRAME_GetWindow_METHOD *)               IWDH_OLEWINDOW_GetWindow,
    (IWDH_OLEINPLACEFRAME_ContextSensitiveHelp_METHOD *)    IWDH_OLEWINDOW_ContextSensitiveHelp,
    IWDH_OLEINPLACEFRAME_GetBorder,
    IWDH_OLEINPLACEFRAME_RequestBorderSpace,
    IWDH_OLEINPLACEFRAME_SetBorderSpace,
    IWDH_OLEINPLACEFRAME_SetActiveObject,
    IWDH_OLEINPLACEFRAME_InsertMenus,
    IWDH_OLEINPLACEFRAME_SetMenu,
    IWDH_OLEINPLACEFRAME_RemoveMenus,
    IWDH_OLEINPLACEFRAME_SetStatusText,
    IWDH_OLEINPLACEFRAME_EnableModeless,
    IWDH_OLEINPLACEFRAME_TranslateAccelerator,
};


IWDH_OLEINPLACESITE_Vtbl vtblIWDH_OLEINPLACESITE = {
    VTABLE_FILL
    (IWDH_OLEINPLACESITE_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLEINPLACESITE_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLEINPLACESITE_Release_METHOD *)          IWABDOCHOST_Release,
    (IWDH_OLEINPLACESITE_GetWindow_METHOD *)               IWDH_OLEWINDOW_GetWindow,
    (IWDH_OLEINPLACESITE_ContextSensitiveHelp_METHOD *)    IWDH_OLEWINDOW_ContextSensitiveHelp,
    IWDH_OLEINPLACESITE_CanInPlaceActivate,
    IWDH_OLEINPLACESITE_OnInPlaceActivate,
    IWDH_OLEINPLACESITE_OnUIActivate,
    IWDH_OLEINPLACESITE_GetWindowContext,
    IWDH_OLEINPLACESITE_Scroll,
    IWDH_OLEINPLACESITE_OnUIDeactivate,
    IWDH_OLEINPLACESITE_OnInPlaceDeactivate,
    IWDH_OLEINPLACESITE_DiscardUndoState,
    IWDH_OLEINPLACESITE_DeactivateAndUndo,
    IWDH_OLEINPLACESITE_OnPosRectChange,
};

IWDH_OLECLIENTSITE_Vtbl vtblIWDH_OLECLIENTSITE = {
    VTABLE_FILL
    (IWDH_OLECLIENTSITE_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLECLIENTSITE_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLECLIENTSITE_Release_METHOD *)          IWABDOCHOST_Release,
    IWDH_OLECLIENTSITE_SaveObject,
    IWDH_OLECLIENTSITE_GetMoniker,
    IWDH_OLECLIENTSITE_GetContainer,
    IWDH_OLECLIENTSITE_ShowObject,
    IWDH_OLECLIENTSITE_OnShowWindow,
    IWDH_OLECLIENTSITE_RequestNewObjectLayout,
};


IWDH_OLEDOCUMENTSITE_Vtbl vtblIWDH_OLEDOCUMENTSITE = {
    VTABLE_FILL
    (IWDH_OLEDOCUMENTSITE_QueryInterface_METHOD *)   IWABDOCHOST_QueryInterface,
    (IWDH_OLEDOCUMENTSITE_AddRef_METHOD *)           IWABDOCHOST_AddRef,
    (IWDH_OLEDOCUMENTSITE_Release_METHOD *)          IWABDOCHOST_Release,
    IWDH_OLEDOCUMENTSITE_ActivateMe,
};



//
//  Interfaces supported by this object
//
#define WABDH_cInterfaces 6
LPIID WABDH_LPIID[WABDH_cInterfaces] = 
{
    (LPIID) &IID_IUnknown,
    (LPIID) &IID_IOleWindow,
    (LPIID) &IID_IOleInPlaceFrame,
    (LPIID) &IID_IOleInPlaceSite,
    (LPIID) &IID_IOleClientSite,
    (LPIID) &IID_IOleDocumentSite,
};

//$$
void UninitTrident()
{
    if(fTridentCoinit)
    {
        CoUninitialize();
        fTridentCoinit = FALSE;
    }
}


//$$//////////////////////////////////////////////////////////////////////////
//
// Release memory related to the IWABDocHost pointer
//
//////////////////////////////////////////////////////////////////////////////
void ReleaseDocHostObject(LPIWABDOCHOST lpIWABDocHost)
{
    HrCloseDocObj(lpIWABDocHost);
    SafeRelease(lpIWABDocHost->m_lpOleObj);
    SafeRelease(lpIWABDocHost->m_pDocView);
    SafeRelease(lpIWABDocHost->m_pInPlaceActiveObj);
    HrDocHost_Init(lpIWABDocHost, FALSE);

    DebugTrace(TEXT("IID_IWABDocHost refCount:      %d\n"),lpIWABDocHost->lcInit);
    DebugTrace(TEXT("IID_IOleWindow refCount:       %d\n"),lpIWABDocHost->lpIWDH_OleWindow->lcInit);
    DebugTrace(TEXT("IID_IOleInPlaceFrame refCount: %d\n"),lpIWABDocHost->lpIWDH_OleInPlaceFrame->lcInit);
    DebugTrace(TEXT("IID_IOleInPlaceSite refCount:  %d\n"),lpIWABDocHost->lpIWDH_OleInPlaceSite->lcInit);
    DebugTrace(TEXT("IID_IOleClientSite refCount:   %d\n"),lpIWABDocHost->lpIWDH_OleClientSite->lcInit);
    DebugTrace(TEXT("IID_IOleDocumentSite refCount: %d\n"),lpIWABDocHost->lpIWDH_OleDocumentSite->lcInit);

    MAPIFreeBuffer(lpIWABDocHost);

   return;
}



//$$//////////////////////////////////////////////////////////////////////////
//
// Creates a New IWABDocHost Object
//
//////////////////////////////////////////////////////////////////////////////
HRESULT HrNewWABDocHostObject(LPVOID * lppIWABDocHost)
{

    LPIWABDOCHOST   lpIWABDocHost = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     		   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(IWABDOCHOST), (LPVOID *) &lpIWABDocHost))) {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpIWABDocHost,  TEXT("WAB Doc Host Object"));

    ZeroMemory(lpIWABDocHost, sizeof(IWABDOCHOST));

    lpIWABDocHost->lpVtbl = &vtblIWABDOCHOST;

    lpIWABDocHost->cIID = WABDH_cInterfaces;
    lpIWABDocHost->rglpIID = WABDH_LPIID;

    InitializeCriticalSection(&lpIWABDocHost->cs);


    lpIWABDocHost->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEWINDOW), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleWindow));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleWindow, sizeof(IWABDOCHOST_OLEWINDOW));
    lpIWABDocHost->lpIWDH_OleWindow->lpVtbl = &vtblIWDH_OLEWINDOW;
    lpIWABDocHost->lpIWDH_OleWindow->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEINPLACEFRAME), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleInPlaceFrame));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleInPlaceFrame, sizeof(IWABDOCHOST_OLEINPLACEFRAME));
    lpIWABDocHost->lpIWDH_OleInPlaceFrame->lpVtbl = &vtblIWDH_OLEINPLACEFRAME;
    lpIWABDocHost->lpIWDH_OleInPlaceFrame->lpIWDH = lpIWABDocHost;

    
    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEINPLACESITE), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleInPlaceSite));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleInPlaceSite, sizeof(IWABDOCHOST_OLEINPLACESITE));
    lpIWABDocHost->lpIWDH_OleInPlaceSite->lpVtbl = &vtblIWDH_OLEINPLACESITE;
    lpIWABDocHost->lpIWDH_OleInPlaceSite->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLECLIENTSITE), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleClientSite));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleClientSite, sizeof(IWABDOCHOST_OLECLIENTSITE));
    lpIWABDocHost->lpIWDH_OleClientSite->lpVtbl = &vtblIWDH_OLECLIENTSITE;
    lpIWABDocHost->lpIWDH_OleClientSite->lpIWDH = lpIWABDocHost;


    sc = MAPIAllocateMore(sizeof(IWABDOCHOST_OLEDOCUMENTSITE), lpIWABDocHost,  &(lpIWABDocHost->lpIWDH_OleDocumentSite));
    if(sc)
        goto err;
    ZeroMemory(lpIWABDocHost->lpIWDH_OleDocumentSite, sizeof(IWABDOCHOST_OLEDOCUMENTSITE));
    lpIWABDocHost->lpIWDH_OleDocumentSite->lpVtbl = &vtblIWDH_OLEDOCUMENTSITE;
    lpIWABDocHost->lpIWDH_OleDocumentSite->lpIWDH = lpIWABDocHost;


    lpIWABDocHost->lpVtbl->AddRef(lpIWABDocHost);

    *lppIWABDocHost = (LPVOID)lpIWABDocHost;


    return(hrSuccess);

err:

    FreeBufferAndNull(&lpIWABDocHost);

    return(hr);
}




/**
*
* The Interface methods
*
*
***/

STDMETHODIMP_(ULONG)
IWABDOCHOST_AddRef(LPIWABDOCHOST lpIWABDocHost)
{
    //DebugTrace(TEXT(">>>>>AddRef: %x\trefCount: %d->%d\n"),lpIWABDocHost,lpIWABDocHost->lcInit,lpIWABDocHost->lcInit+1);
    return(++(lpIWABDocHost->lcInit));
}

STDMETHODIMP_(ULONG)
IWABDOCHOST_Release(LPIWABDOCHOST lpIWABDocHost)
{
    //DebugTrace(TEXT("<<<<<Release: %x\trefCount: %d->%d\n"),lpIWABDocHost,lpIWABDocHost->lcInit,lpIWABDocHost->lcInit-1);
    if(--(lpIWABDocHost->lcInit)==0 &&
       (lpIWABDocHost == lpIWABDocHost->lpIWDH))
    {
       ReleaseDocHostObject(lpIWABDocHost);
       return (0);
    }

    return(lpIWABDocHost->lcInit);
}


STDMETHODIMP
IWABDOCHOST_QueryInterface(LPIWABDOCHOST lpIWABDocHost,
                          REFIID lpiid,
                          LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpIWABDocHost->lpIWDH;

    if(IsEqualIID(lpiid, &IID_IOleWindow))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleWindow\n"));
        lp = (LPVOID) (LPOLEWINDOW) lpIWABDocHost->lpIWDH->lpIWDH_OleWindow;
    }

    if(IsEqualIID(lpiid, &IID_IOleInPlaceUIWindow))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleInPlaceUIWindow\n"));
        lp = (LPVOID) (LPOLEINPLACEUIWINDOW) lpIWABDocHost->lpIWDH->lpIWDH_OleInPlaceFrame;
    }

    if(IsEqualIID(lpiid, &IID_IOleInPlaceFrame))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleInPlaceFrame\n"));
        lp = (LPVOID) (LPOLEINPLACEFRAME) lpIWABDocHost->lpIWDH->lpIWDH_OleInPlaceFrame;
    }

    if(IsEqualIID(lpiid, &IID_IOleInPlaceSite))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleInPlaceSite\n"));
        lp = (LPVOID) (LPOLEINPLACESITE) lpIWABDocHost->lpIWDH->lpIWDH_OleInPlaceSite;
    }

    if(IsEqualIID(lpiid, &IID_IOleClientSite))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleClientSite\n"));
        lp = (LPVOID) (LPOLECLIENTSITE) lpIWABDocHost->lpIWDH->lpIWDH_OleClientSite;
    }

    
    if(IsEqualIID(lpiid, &IID_IOleDocumentSite))
    {
        DebugTrace(TEXT("WABDocHost:QI - IOleDocumentSite\n"));
        lp = (LPVOID) (LPOLEDOCUMENTSITE) lpIWABDocHost->lpIWDH->lpIWDH_OleDocumentSite;
    }

    if(!lp)
    {
        return E_NOINTERFACE;
    }

    ((LPIWABDOCHOST) lp)->lpVtbl->AddRef((LPIWABDOCHOST) lp);

    *lppNewObj = lp;

    return S_OK;

}

/*** 
*
*
*    IOleWindowMethods 
*
*
****/

STDMETHODIMP
IWDH_OLEWINDOW_GetWindow(LPIWABDOCHOST_OLEWINDOW lpIWABDocHost,
                      HWND * phWnd)
{
    DebugTrace(TEXT("IOleWindowMethod: GetWindow\n"));
    if(phWnd)
    {
        *phWnd = lpIWABDocHost->lpIWDH->m_hwnd;
    }
    return S_OK;
}


STDMETHODIMP
IWDH_OLEWINDOW_ContextSensitiveHelp(LPIWABDOCHOST_OLEWINDOW lpWABDH,
                                 BOOL   fEnterMode)
{
    DebugTrace(TEXT("IOleWindowMethod: ContextSensitiveHelp\n"));
    return E_NOTIMPL;
}


/***
*
*
* IOleInPlaceUIWindow methods
*
*
***/

STDMETHODIMP
IWDH_OLEINPLACEFRAME_GetBorder(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                      LPRECT lprc)
{
    DebugTrace(TEXT("IOleInPlaceFrame: GetBorder\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_RequestBorderSpace(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                               LPCBORDERWIDTHS pborderwidths)
{
    DebugTrace(TEXT("IOleInPlaceFrame: RequestBorderSpace\n"));
    return S_OK;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetBorderSpace(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                           LPCBORDERWIDTHS pborderwidths)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetBorderSpace\n"));
    return S_OK;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetActiveObject(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                            IOleInPlaceActiveObject * pActiveObject, 
                            LPCOLESTR lpszObjName)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetActiveObject\n"));
    SafeRelease(lpWABDH->lpIWDH->m_pInPlaceActiveObj);
    lpWABDH->lpIWDH->m_pInPlaceActiveObj = pActiveObject;
    if(lpWABDH->lpIWDH->m_pInPlaceActiveObj)
        lpWABDH->lpIWDH->m_pInPlaceActiveObj->lpVtbl->AddRef(lpWABDH->lpIWDH->m_pInPlaceActiveObj);
    return S_OK;
}


/***
*
*
* IOleInPlaceFrame Methods
*
*
*
***/
STDMETHODIMP
IWDH_OLEINPLACEFRAME_InsertMenus(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                        HMENU  hMenu,
                        LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    DebugTrace(TEXT("IOleInPlaceFrame: InsertMenus\n"));
    return S_OK;
}

STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetMenu(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                    HMENU                   hMenu,                  
                    HOLEMENU                hOleMenu,               
                    HWND                    hWnd)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetMenu\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_RemoveMenus(LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                    HMENU                   hMenu)
{
    DebugTrace(TEXT("IOleInPlaceFrame: RemoveMenus\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_SetStatusText(  LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                            LPCOLESTR pszStatusText)
{
    DebugTrace(TEXT("IOleInPlaceFrame: SetStatusText\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_EnableModeless( LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                            BOOL fEnable)
{
    DebugTrace(TEXT("IOleInPlaceFrame: EnableModeless\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLEINPLACEFRAME_TranslateAccelerator( LPIWABDOCHOST_OLEINPLACEFRAME lpWABDH,
                                  MSG * lpmsg,
                                  WORD wID)
{
    DebugTrace(TEXT("IOleInPlaceFrame: TranslateAccelerator\n"));
    return E_NOTIMPL;
}


/***
*
*
*
* IOleInPlaceSite methods
*
*
***/

STDMETHODIMP
IWDH_OLEINPLACESITE_CanInPlaceActivate( LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{
    DebugTrace(TEXT("IOleInPlaceSite: CanInPlaceActivate\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnInPlaceActivate( LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{
    LPOLEINPLACEOBJECT pInPlaceObj = 0;
    
    DebugTrace(TEXT("IOleInPlaceSite: OnInPlaceActivate\n"));
/**/
    lpWABDH->lpIWDH->m_lpOleObj->lpVtbl->QueryInterface(  lpWABDH->lpIWDH->m_lpOleObj,
                                                        &IID_IOleInPlaceObject,
                                                        (LPVOID *) &pInPlaceObj);
    lpWABDH->lpIWDH->m_pIPObj = pInPlaceObj;

    if(pInPlaceObj)
    {
        pInPlaceObj->lpVtbl->GetWindow(pInPlaceObj,
                                      &(lpWABDH->lpIWDH->m_hwndDocObj));
        Assert(IsWindow(lpWABDH->lpIWDH->m_hwndDocObj));

    }
/**/
    return S_OK;
}



STDMETHODIMP
IWDH_OLEINPLACESITE_OnUIActivate( LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{
    DebugTrace(TEXT("IOleInPlaceSite: OnUIActivate\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_GetWindowContext(   LPIWABDOCHOST_OLEINPLACESITE           lpWABDH,
                                LPOLEINPLACEFRAME *     ppFrame,
                                LPOLEINPLACEUIWINDOW *  ppDoc,               
                                LPRECT                  lprcPosRect,         
                                LPRECT                  lprcClipRect,        
                                LPOLEINPLACEFRAMEINFO   lpFrameInfo)    
{

    DebugTrace(TEXT("IOleInPlaceSite: GetWindowContext\n"));
    
    *ppFrame = (LPOLEINPLACEFRAME)lpWABDH->lpIWDH->lpIWDH_OleInPlaceFrame;
    *ppDoc = NULL; // NULL means doc window is same as frame window
    (*ppFrame)->lpVtbl->AddRef(*ppFrame);   // for the inplace frame

    GetClientRect(lpWABDH->lpIWDH->m_hwnd, lprcClipRect);
    GetClientRect(lpWABDH->lpIWDH->m_hwnd, lprcPosRect);

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame=lpWABDH->lpIWDH->m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;

    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_Scroll( LPIWABDOCHOST_OLEINPLACESITE lpWABDH,
                    SIZE scrollExtent)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: Scroll\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnUIDeactivate(LPIWABDOCHOST_OLEINPLACESITE lpWABDH,
                           BOOL fUndoable)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: OnUIDeactivate\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnInPlaceDeactivate(LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: OnInPlaceDeactivate\n"));
    SafeRelease(lpWABDH->lpIWDH->m_pIPObj);
    return S_OK;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_DiscardUndoState(LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: DiscardUndoState\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_DeactivateAndUndo(LPIWABDOCHOST_OLEINPLACESITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: DeactivateAndUndo\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLEINPLACESITE_OnPosRectChange(LPIWABDOCHOST_OLEINPLACESITE lpWABDH,
                            LPCRECT lprcPosRect)
{                   

    DebugTrace(TEXT("IOleInPlaceSite: OnPosRectChange\n"));
    return E_NOTIMPL;
}

/****
*
* OLECLIENTSITE methods
*
***/
STDMETHODIMP
IWDH_OLECLIENTSITE_SaveObject(LPIWABDOCHOST_OLECLIENTSITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleClientSite: SaveObject\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_GetMoniker( LPIWABDOCHOST_OLECLIENTSITE lpWABDH,
                        DWORD dwAssign,
                        DWORD dwWhichMoniker, 
                        LPMONIKER * ppmnk)          
{                   

    DebugTrace(TEXT("IOleClientSite: GetMoniker\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_GetContainer(LPIWABDOCHOST_OLECLIENTSITE lpWABDH,
                         LPOLECONTAINER * ppCont)          
{                   

    DebugTrace(TEXT("IOleClientSite: GetContainer\n"));
    if(ppCont)
        *ppCont = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP
IWDH_OLECLIENTSITE_ShowObject(LPIWABDOCHOST_OLECLIENTSITE lpWABDH)        
{                   

    DebugTrace(TEXT("IOleClientSite: ShowObject\n"));
    return S_OK;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_OnShowWindow(LPIWABDOCHOST_OLECLIENTSITE lpWABDH,
                         BOOL fShow)        
{                   

    DebugTrace(TEXT("IOleClientSite: OnShowWindow\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IWDH_OLECLIENTSITE_RequestNewObjectLayout(LPIWABDOCHOST_OLECLIENTSITE lpWABDH)
{                   

    DebugTrace(TEXT("IOleClientSite: RequestNewObjectLayout\n"));
    return E_NOTIMPL;
}



/***
*
*
*
* IOleDocumentSite Methods
*
*
***/

STDMETHODIMP
IWDH_OLEDOCUMENTSITE_ActivateMe(LPIWABDOCHOST_OLEDOCUMENTSITE lpWABDH,
                       LPOLEDOCUMENTVIEW       pViewToActivate)
{                   

    DebugTrace(TEXT("IOleDocumentSite: ActivateMe: %x\n"), pViewToActivate);
    return HrCreateDocView(lpWABDH->lpIWDH, pViewToActivate);
}




/******
*
*
*
* Non Interface functions
*
*
*
*
*******/



LRESULT CALLBACK_16 WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPIWABDOCHOST lpWABDH;

    lpWABDH = (LPIWABDOCHOST) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(msg)
    {
        case WM_CREATE:
            {
                LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
                lpWABDH = (LPIWABDOCHOST) lpcs->lpCreateParams;
                if(lpWABDH)
                {
                    lpWABDH->m_hwnd = hwnd;
                    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)lpWABDH);
                    lpWABDH->lpVtbl->AddRef(lpWABDH);
                }
                else
                    return -1;
            }
            break;

        case WM_SETFOCUS:
            if(lpWABDH->m_pDocView)
                lpWABDH->m_pDocView->lpVtbl->UIActivate(  lpWABDH->m_pDocView,
                                                                TRUE);
            break;

        case WM_SIZE:
            WMSize(lpWABDH, LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_CLOSE:
            return 0;   // prevent alt-f4's

        case WM_NCDESTROY:
            {
                if(lpWABDH)
                {
                    SetWindowLongPtr(lpWABDH->m_hwnd, GWLP_USERDATA, (LPARAM) 0);
                    lpWABDH->m_hwnd = NULL;
                    lpWABDH->lpVtbl->Release(lpWABDH);
                }
            }
            break;
        }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}


//$$
void WMSize(LPIWABDOCHOST lpWABDH, int cxBody, int cyBody)
{
    RECT rc={0};

    if(lpWABDH->m_pDocView)
    {
        rc.bottom=cyBody;
        rc.right=cxBody;

        lpWABDH->m_pDocView->lpVtbl->SetRect(lpWABDH->m_pDocView,
                                                    &rc);
    }
} 



//$$
HRESULT HrCreateDocObj(LPIWABDOCHOST lpWABDH, LPCLSID pCLSID)
{

    HRESULT hr = S_OK;

    if(!pCLSID)
        return MAPI_E_INVALID_PARAMETER;

    Assert(!lpWABDH->m_lpOleObj);
    Assert(!lpWABDH->m_pDocView);

    if (CoInitialize(NULL) == S_FALSE) 
    {
        // Already initialized, undo the extra.
        CoUninitialize();
    }
    else
        fTridentCoinit = TRUE;

    hr = CoCreateInstance(  pCLSID, 
                            NULL, 
                            CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                            &IID_IOleObject, 
                            (LPVOID *)&(lpWABDH->m_lpOleObj));

    if (FAILED(hr))
    {
        DebugTrace(TEXT("!!!!ERROR: Unable to CoCreateInstance(Trident)\n"));
        goto error;
    }

    hr = lpWABDH->m_lpOleObj->lpVtbl->SetClientSite(  lpWABDH->m_lpOleObj,
                                                      (LPOLECLIENTSITE)lpWABDH->lpIWDH_OleClientSite);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}



//$$
HRESULT HrShow(LPIWABDOCHOST lpWABDH)
{
    RECT                rc;
    HRESULT             hr;

    GetClientRect(lpWABDH->m_hwnd, &rc);
  
    hr=lpWABDH->m_lpOleObj->lpVtbl->DoVerb( lpWABDH->m_lpOleObj,
                                            OLEIVERB_SHOW, 
                                            NULL, 
                                            (LPOLECLIENTSITE)lpWABDH->lpIWDH_OleClientSite, 
                                            0, 
                                            lpWABDH->m_hwnd, 
                                            &rc);
    if(FAILED(hr))
        goto error;

error:
    return hr;
}


//$$
HRESULT HrCloseDocObj(LPIWABDOCHOST lpWABDH)
{

    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    if(lpWABDH->lpIWDH->m_pIPObj)
        lpWABDH->lpIWDH->m_pIPObj->lpVtbl->InPlaceDeactivate(lpWABDH->lpIWDH->m_pIPObj);


    if(lpWABDH->m_pDocView)
    {
        lpWABDH->m_pDocView->lpVtbl->Show(lpWABDH->m_pDocView, FALSE);

        lpWABDH->m_pDocView->lpVtbl->UIActivate(lpWABDH->m_pDocView, FALSE);

        lpWABDH->m_pDocView->lpVtbl->CloseView( lpWABDH->m_pDocView, 0);

        lpWABDH->m_pDocView->lpVtbl->SetInPlaceSite(lpWABDH->m_pDocView, NULL);

        SafeRelease(lpWABDH->m_pDocView);
        
        lpWABDH->m_pDocView=NULL;
    }

    if (lpWABDH->m_lpOleObj)
    {

        lpWABDH->m_lpOleObj->lpVtbl->SetClientSite( lpWABDH->m_lpOleObj, NULL);

        // close the ole object, but blow off changes as we have either extracted 
        // them ourselves or don't care.
        lpWABDH->m_lpOleObj->lpVtbl->Close(lpWABDH->m_lpOleObj, OLECLOSE_NOSAVE);

        SafeRelease(lpWABDH->m_lpOleObj);
    }

    lpWABDH->m_pIPObj=NULL;
    
    return NOERROR;
}


//$$
HRESULT HrInit(LPIWABDOCHOST lpWABDH,
               HWND hwndParent, 
               int idDlgItem, 
               DWORD dhbBorder)
{
    HRESULT hr;
    HWND    hwnd;

    if(!IsWindow(hwndParent))
        return MAPI_E_INVALID_PARAMETER;

    hr=HrDocHost_Init(lpWABDH, TRUE);
    if(FAILED(hr))
        goto error;

    {
        RECT rc = {0};
        HWND hWndFrame = GetDlgItem(hwndParent, IDC_DETAILS_TRIDENT_STATIC);
        GetChildClientRect(hWndFrame, &rc);
        hwnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY, //| WS_EX_CLIENTEDGE,
                            c_szWABDocHostWndClass, 
                            NULL,
                            WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_CHILD|WS_TABSTOP,
                            rc.left,rc.top,
                            rc.right-rc.left,rc.bottom-rc.top, 
                            hwndParent, 
                            (HMENU)IntToPtr(idDlgItem), 
                            hinstMapiXWAB, 
                            (LPVOID)lpWABDH);
        if(!hwnd)
        {
            hr=MAPI_E_NOT_ENOUGH_MEMORY;
            goto error;
        }
    }


error:
    return hr;
}


//$$
HRESULT HrDocHost_Init(LPIWABDOCHOST lpWABDH, BOOL fInit)
{
    static BOOL fInited=FALSE;

    WNDCLASS    wc={0};

    if(fInit)
    {
        if(fInited)         // already regisered
            return NOERROR;

        wc.lpfnWndProc   = WndProc; //CDocHost::ExtWndProc;
        wc.hInstance     = hinstMapiXWAB;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_szWABDocHostWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.style = CS_DBLCLKS;

        if(!RegisterClass(&wc)) // This will fail if class is already registered in which case continue
        {
            DebugTrace(TEXT("RegisterClass: %s failed\n"), c_szWABDocHostWndClass);
            if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
                return MAPI_E_NOT_ENOUGH_MEMORY;
        }

        fInited=TRUE;
    }
    else
    {
        if (fInited)
        {
            if(!UnregisterClass(c_szWABDocHostWndClass, hinstMapiXWAB))
            {
                DebugTrace(TEXT("Could not Unregister %s. GetLastError(): %d\n"),c_szWABDocHostWndClass, GetLastError());
            }
            fInited=FALSE;
        }
    }

    return S_OK;
}




//$$
HRESULT HrCreateDocView(LPIWABDOCHOST lpWABDH, LPOLEDOCUMENTVIEW pViewToActivate)
{
    HRESULT         hr;
    LPOLEDOCUMENT   pOleDoc=NULL;

    // if we weren't handed a DocumentView pointer, get one
    if(!pViewToActivate)
    {
        hr=OleRun((struct IUnknown *)(lpWABDH->m_lpOleObj));
        if(FAILED(hr))
            goto error;
    
        hr=lpWABDH->m_lpOleObj->lpVtbl->QueryInterface(lpWABDH->m_lpOleObj,
                                                             &IID_IOleDocument, 
                                                             (LPVOID*)&pOleDoc);
        if(FAILED(hr))
            goto error;

        hr=pOleDoc->lpVtbl->CreateView( pOleDoc,
                                        (LPOLEINPLACESITE) lpWABDH->lpIWDH_OleInPlaceSite, 
                                        NULL,
                                        0,
                                        &(lpWABDH->m_pDocView));
        if(FAILED(hr))
            goto error;
    }
    else
        lpWABDH->m_pDocView = pViewToActivate;

    hr=lpWABDH->m_pDocView->lpVtbl->SetInPlaceSite(lpWABDH->m_pDocView,
                                                         (LPOLEINPLACESITE)lpWABDH->lpIWDH_OleInPlaceSite);
    if(FAILED(hr))
        goto error;

    // if we were handed a document view pointer, addref it after calling SetInPlaceSite
    if(pViewToActivate)
        pViewToActivate->lpVtbl->AddRef(pViewToActivate);


    hr=lpWABDH->m_pDocView->lpVtbl->Show( lpWABDH->m_pDocView,
                                                TRUE);
    if(FAILED(hr))
        goto error;

error:
    if(pOleDoc)
        SafeRelease(pOleDoc);
    return hr;
}


//$$ 
HRESULT HrLoadTheURL(LPIWABDOCHOST lpWABDH, LPTSTR pszURL)
{
    WCHAR       wszURL[1024]; //INTERNET_MAX_URL_LENGTH + 1];
    LPMONIKER   pmk=0;
    HINSTANCE hInstURLMON = NULL;
    HRESULT hr = S_OK;
    StrCpyN(wszURL,pszURL, ARRAYSIZE(wszURL));
    hInstURLMON = LoadLibrary( TEXT("urlmon.dll"));
    if(!hInstURLMON)
    {
        hr = MAPI_E_NOT_INITIALIZED;
        goto error;
    }
    lpfnCreateURLMoniker = (LPCREATEURLMONIKER) GetProcAddress( hInstURLMON,  "CreateURLMoniker");
    if(!lpfnCreateURLMoniker)
    {
        FreeLibrary(hInstURLMON);
        goto error;
    }

    hr = lpfnCreateURLMoniker(NULL, wszURL, &pmk);

    if(FAILED(hr))
        goto error;

    hr = HrLoadFromMoniker(lpWABDH, pmk);
    if(FAILED(hr))
        goto error;

error:
    if(pmk)
        SafeRelease(pmk); 

    if(lpfnCreateURLMoniker)
        FreeLibrary(hInstURLMON);

    return hr;

}

//$$
HRESULT HrLoadURL(LPIWABDOCHOST lpWABDH, LPTSTR pszURL)
{

    HRESULT     hr=S_OK;
    HCURSOR     hcur;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
  
    if(!pszURL)
    {
        hr=MAPI_E_INVALID_PARAMETER;
        goto error;
    }

    if (!lpWABDH->m_lpOleObj)
    {
        hr = HrCreateDocObj(lpWABDH,
                            (LPCLSID)&CLSID_HTMLDocument);
        if(FAILED(hr))
            goto error;

        hr = HrLoadTheURL(lpWABDH, pszURL);

        if(FAILED(hr))
            goto error;

        hr = HrShow(lpWABDH);

        if (FAILED(hr))
            goto error;
    }



error:

    if(hcur)
        SetCursor(hcur);

    return hr;

}




//$$
HRESULT HrLoadFromMoniker(LPIWABDOCHOST lpWABDH,
                          LPMONIKER pmk)
{
    HRESULT             hr=E_FAIL;
    LPPERSISTMONIKER    pPMoniker=0;
    LPBC                pbc=0;

    hr=lpWABDH->m_lpOleObj->lpVtbl->QueryInterface(lpWABDH->m_lpOleObj,
                                                        &IID_IPersistMoniker, 
                                                        (LPVOID *)&pPMoniker);
    if(FAILED(hr))
        goto error;

    hr=CreateBindCtx(0, &pbc);
    if(FAILED(hr))
        goto error;

    hr=pPMoniker->lpVtbl->Load( pPMoniker,
                                TRUE, 
                                pmk, 
                                pbc, 
                                STGM_READWRITE);
    if(FAILED(hr))
        goto error;

error:
    if(pbc)
        SafeRelease(pbc); 

    if(pPMoniker)
        SafeRelease(pPMoniker); 

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\glheap.h ===
/*
 * glheap.h
 *
 * Implementation of global and local heaps
 *
 * Copyright (C) 1994 Microsoft Corporation
 */

#ifndef __GLHEAP_H_
#define __GLHEAP_H_

#ifdef __cplusplus
extern "C" {
#endif

/* Windows 95 Implementation -------------------------------------------------- */

#ifdef CHICAGO

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GHDR		GHDR,	* PGHDR,	** PPGHDR;
typedef struct GH		GH,  	* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GHDR {
	PGHDR			pghdrNext;		// Pointer to next heap
	HANDLE			hHeap;			// Handle to the heap
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	ULONG			cRef;			// Number of active clients
};

struct GH {
	HANDLE			hHeap;			// Handle to the heap
	HANDLE			hMutex;			// Handle to mutex for this heap
	PGHDR			pghdr;			// Pointer to the heap header block
	#ifdef DEBUG
	UINT			cMutex;			// Mutex entry count
	#endif
};

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

_HGH	_GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	_GH_Close(_HGH hgh);
#define _GH_GetRoot(hgh)			((hgh)->pghdr->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pghdr->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pghdr->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HeapSize((hgh)->hHeap, 0, (LPVOID)(ghid))
#define _GH_Alloc(hgh, cb)			((GHID)HeapAlloc((hgh)->hHeap, 0, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HeapReAlloc((hgh)->hHeap, 0, (LPVOID)(ghid), cb))
#define _GH_Free(hgh, ghid)			HeapFreeZ((hgh)->hHeap, (LPVOID)(ghid))

#ifdef DEBUG
BOOL	_GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
void	_GH_ReleaseMutex(_HGH hgh);
#else
#define	_GH_WaitForMutex(hgh, ulT)	GH_WaitForSingleObject(hgh->hMutex, ulT)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif
#endif

#define	_LH_Open(dwMaxHeap)			HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(hlh)				HeapDestroy(hlh)
#define _LH_Alloc(hlh, cb)			HeapAlloc(hlh, 0, cb)
#define _LH_Realloc(hlh, pv, cb)	HeapReAlloc(hlh, 0, pv, cb)
#define _LH_GetSize(hlh, pv)		HeapSize(hlh, 0, pv)
#define _LH_Free(hlh, pv)			HeapFreeZ(hlh, pv)

#endif

/* Win16 Implementation ---------------------------------------------------- */

#ifdef WIN16

#define GH_POINTERS_VALID

typedef __segment		HPH,	* PHPH,		** PPHPH;
typedef DWORD			HPID,	* PHPID,	** PPHPID;
typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef HPID			GHID,	* PGHID,	** PPGHID;
typedef HPH				_HGH;
typedef HPH				_HLH;

typedef struct HP {
	HPH				hphRoot;		// Pointer to root heap
	HPH				hphPrev;		// Pointer to the previous heap (fShared)
	HPH				hphNext;		// Pointer to next heap (fShared)
	HPH				hphChild;		// Pointer to extended heaps
	BOOL			fShared;		// TRUE if heap is shared across processes
	GHNAME			ghname;			// Name of the shared heap (fShared)
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	UINT			cRef;			// Number of active clients
	UINT			cbHeap;			// Size of this heap
	UINT			cbFree;			// Maximum contiguous free bytes in heap
} HP, * PHP;

#define HphToPhp(hph)				((PHP)((ULONG)(hph) << 16))
#define HP_CREATE					0x0001
#define HP_SHARED					0x0002

HPH		HP_Open(UINT uiFlags, GHNAME ghname, DWORD dwMaxHeap);
void	HP_Close(HPH hph);
HPID	HP_Alloc(HPH hph, UINT cb);
HPID	HP_Realloc(HPH hph, HPID hpid, UINT cb);
void	HP_Free(HPH hph, HPID hpid);
#define	HP_GetSize(hgh, hpid)		(*((UINT *)(hpid) - 2))

#define _GH_Open(fCreate, ghname, dwMaxHeap) \
			HP_Open(HP_SHARED | !!(fCreate), ghname, dwMaxHeap)
#define	_GH_Close(hgh)				HP_Close(hgh)
#define _GH_GetRoot(hgh)			(HphToPhp(hgh)->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		(HphToPhp(hgh)->ghidRoot = (ghid))
#define _GH_GetName(hgh)			(HphToPhp(hgh)->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HP_GetSize(hgh, ghid)
#define _GH_Alloc(hgh, cb)			((GHID)HP_Alloc(hgh, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HP_Realloc(hgh, ghid, cb))
#define _GH_Free(hgh, ghid)			HP_Free(hgh, ghid)
#define _GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)

#define HeapFreeZ(hHeap, pv)           \
                   if (pv)             \
                        HeapFree(hHeap, 0, pv);

#define	_LH_Open(dwMaxHeap)		HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(_hlh)			HeapDestroy(_hlh)
#define _LH_Alloc(_hlh, cb)		HeapAlloc(_hlh, 0, cb)
#define _LH_Realloc(_hlh, pv, cb)	HeapReAlloc(_hlh, 0, pv, cb)
#define _LH_GetSize(_hlh, pv)		HeapSize(_hlh, 0, pv)
#define _LH_Free(_hlh, pv)		HeapFreeZ(_hlh, pv)

#endif

/* NT Implementation ------------------------------------------------------- */

#if defined(WIN32) && !defined(CHICAGO) && !defined(MAC) 

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GROOT	GROOT,	* PGROOT,	** PPGROOT;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GROOT
{
	DWORD			dwBLK;			// Block header
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	WORD			rgcbFree[1];	// Maximum contiguous free bytes per page
};

struct GH
{
	PGROOT			pgroot;			// Pointer to the first byte of the heap
	HANDLE			hMutex;			// Handle to public mutex for this heap
	HANDLE			hMutexHeap;		// Handle to private mutex for this heap
	HANDLE			hMapping;		// Handle to file mapping object
};

typedef struct GH_SECURITY_ATTRIBUTES {
	SECURITY_ATTRIBUTES		sa;
	BYTE					rgbSd[SECURITY_DESCRIPTOR_MIN_LENGTH];
} GH_SECURITY_ATTRIBUTES, * PGH_SECURITY_ATTRIBUTES;

BOOL	GH_InitializeSecurityAttributes(PGH_SECURITY_ATTRIBUTES pghsa);

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

BOOL	_GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
_HGH	_GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	_GH_Close(_HGH hgh);
GHID	_GH_Alloc(_HGH hgh, UINT cb);
GHID	_GH_Realloc(_HGH hgh, GHID ghid, UINT cb);
void	_GH_Free(_HGH hgh, GHID ghid);

#define _GH_GetPv(hgh, ghid)		((LPVOID)((BYTE *)(hgh)->pgroot + (ghid)))
#define _GH_GetId(hgh, pv)			((BYTE *)(pv) - (BYTE *)(hgh)->pgroot)
#define _GH_GetSize(hgh, ghid)		((UINT)*((WORD *)_GH_GetPv(hgh, ghid) - 2))
#define _GH_GetRoot(hgh)			((hgh)->pgroot->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pgroot->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pgroot->ghname)
#define _GH_WaitForMutex(hgh, ul)	GH_WaitForSingleObject((hgh)->hMutex, ul)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif	/* __cplusplus */

#define	_LH_Open(dwMaxHeap)			HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(_hlh)				HeapDestroy(_hlh)
#define _LH_Alloc(_hlh, cb)			HeapAlloc(_hlh, 0, cb)
#define _LH_Realloc(_hlh, pv, cb)	HeapReAlloc(_hlh, 0, pv, cb)
#define _LH_GetSize(_hlh, pv)		HeapSize(_hlh, 0, pv)
#define _LH_Free(_hlh, pv)			HeapFreeZ(_hlh, pv)

#endif	/* WIN32 */

/* Mac Implementation ------------------------------------------------------ */

#ifdef MAC

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GROOT	GROOT,	* PGROOT,	** PPGROOT;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GROOT
{
	GHID			ghidRoot;		// Root heap block
	GHNAME			ghname;			// Name of the heap
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	PGROOT			next;			// Pointer to next shared heap
};

struct GH
{
	LPMALLOC		lpMalloc;		// OLE shared heap allocator (IMalloc interface)
	PGROOT			pgroot;			// Pointer to the first byte of the heap
};

#define _GH_GetRoot(hgh)			((hgh)->pgroot->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pgroot->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pgroot->ghname)
#define	_GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_Close(hgh)				((void)0)

_HGH	_GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);

__inline GHID _GH_Alloc(_HGH hgh, UINT cb)
{
#ifdef __cplusplus
	return((GHID)hgh->lpMalloc->Alloc(cb));
#else
	return((GHID)hgh->lpMalloc->lpVtbl->Alloc(hgh->lpMalloc, cb));
#endif
}

__inline GHID _GH_Realloc(_HGH hgh, GHID ghid, UINT cb)
{
#ifdef __cplusplus
	return((GHID)hgh->lpMalloc->Realloc((LPVOID)ghid, cb));
#else
	return((GHID)hgh->lpMalloc->lpVtbl->Realloc(hgh->lpMalloc, (LPVOID)ghid, cb));
#endif	
}

__inline UINT _GH_GetSize(_HGH hgh, GHID ghid)
{
#ifdef __cplusplus
	return((UINT)hgh->lpMalloc->GetSize((PVOID)ghid));
#else
	return((UINT)hgh->lpMalloc->lpVtbl->GetSize(hgh->lpMalloc, (PVOID)ghid));
#endif
}

__inline void _GH_Free(_HGH hgh, GHID ghid)
{
#ifdef __cplusplus
	hgh->lpMalloc->Free((LPVOID)ghid);
#else
	hgh->lpMalloc->lpVtbl->Free(hgh->lpMalloc, (LPVOID)ghid);
#endif
}

// -----------

__inline LPVOID _LH_Open(DWORD dwMaxHeap)
{
	LPMALLOC		lpMalloc;
	
	(void) CoGetMalloc(MEMCTX_TASK, &lpMalloc);
	return (void *)lpMalloc;
}

#define _LH_Close(hlh)	((void)0)

__inline LPVOID _LH_Alloc(LPMALLOC hlh, UINT cb)
{
#ifdef __cplusplus
	return((hlh)->Alloc(cb));
#else
	return((hlh)->lpVtbl->Alloc(hlh, cb));
#endif
}

__inline LPVOID _LH_Realloc(LPMALLOC hlh, LPVOID pv, UINT cb)
{
#ifdef __cplusplus
	return(hlh->Realloc(pv, cb));
#else
	return(hlh->lpVtbl->Realloc(hlh, pv, cb));
#endif	
}

__inline UINT _LH_GetSize(LPMALLOC hlh, LPVOID pv)
{
#ifdef __cplusplus
	return((UINT)hlh->GetSize(pv));
#else
	return((UINT)hlh->lpVtbl->GetSize(hlh, pv));
#endif
}

__inline void _LH_Free(LPMALLOC hlh, LPVOID pv)
{
#ifdef __cplusplus
	hlh->Free(pv);
#else
	hlh->lpVtbl->Free(hlh, pv);
#endif
}

#endif /* MAC */

/* DOS Implementation ------------------------------------------------------ */

#ifdef DOS

typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef LPMALLOC		_HLH;

__inline LPVOID _LH_Alloc(_HLH hlh, UINT cb)
{
#ifdef __cplusplus
	return((hlh)->Alloc(cb));
#else
	return((hlh)->lpVtbl->Alloc(hlh, cb));
#endif
}

__inline LPVOID _LH_Realloc(_HLH hlh, LPVOID pv, UINT cb)
{
#ifdef __cplusplus
	return(hlh->Realloc(pv, cb));
#else
	return(hlh->lpVtbl->Realloc(hlh, pv, cb));
#endif	
}

__inline void _LH_Free(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	hlh->Free(pv);
#else
	hlh->lpVtbl->Free(hlh, pv);
#endif
}

__inline UINT _LH_GetSize(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	return((UINT)hlh->GetSize(pv));
#else
	return((UINT)hlh->lpVtbl->GetSize(hlh, pv));
#endif
}

#endif

// LH External API ------------------------------------------------------------

#if defined(DEBUG) && (defined(WIN16) || defined(WIN32))
#define	IFHEAPNAME(x)	x

typedef struct LH *	HLH;

HLH	WINAPI LH_Open(DWORD dwMaxHeap);
void	WINAPI LH_Close(HLH hlh);
LPVOID	WINAPI LH_Alloc(HLH hlh, UINT cb);
LPVOID	WINAPI LH_Realloc(HLH hlh, LPVOID pv, UINT cb);
UINT	WINAPI LH_GetSize(HLH hlh, LPVOID pv);
void	WINAPI LH_Free(HLH hlh, LPVOID pv);
BOOL
#ifdef MAC
WINAPI
#endif
LH_DidAlloc(HLH hlh, LPVOID pv);

void __cdecl LH_SetHeapNameFn(HLH hlh, TCHAR *pszFormat, ...);
void __cdecl LH_SetNameFn(HLH hlh, LPVOID pv, TCHAR *pszFormat, ...);

TCHAR *	LH_GetName(HLH hlh, LPVOID pv);

#else
#define	IFHEAPNAME(x)	0

typedef _HLH	HLH;

#define	LH_Open(dwMaxHeap)						_LH_Open(dwMaxHeap)
#define LH_Close(hlh)							_LH_Close(hlh)
#define LH_Alloc(hlh, cb)						_LH_Alloc(hlh, cb)
#define LH_Realloc(hlh, pv, cb)					_LH_Realloc(hlh, pv, cb)
#define LH_GetSize(hlh, pv)						_LH_GetSize(hlh, pv)
#define LH_Free(hlh, pv)						_LH_Free(hlh, pv)

#endif

#define LH_SetHeapName(hlh,psz)					IFHEAPNAME(LH_SetHeapNameFn(hlh,psz))
#define LH_SetHeapName1(hlh,psz,a1)				IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1))
#define LH_SetHeapName2(hlh,psz,a1,a2)			IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2))
#define LH_SetHeapName3(hlh,psz,a1,a2,a3)		IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3))
#define LH_SetHeapName4(hlh,psz,a1,a2,a3,a4)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4))
#define LH_SetHeapName5(hlh,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4,a5))

#define LH_SetName(hlh,pv,psz)					IFHEAPNAME(LH_SetNameFn(hlh,pv,psz))
#define LH_SetName1(hlh,pv,psz,a1)				IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1))
#define LH_SetName2(hlh,pv,psz,a1,a2)			IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2))
#define LH_SetName3(hlh,pv,psz,a1,a2,a3)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3))
#define LH_SetName4(hlh,pv,psz,a1,a2,a3,a4)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4))
#define LH_SetName5(hlh,pv,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4,a5))


// GH External API ------------------------------------------------------------

#if !defined(DOS)

typedef _HGH	HGH;

#define	GH_Open(fCreate, ghname, dwMaxHeap)		_GH_Open(fCreate, ghname, \
															dwMaxHeap)
#define	GH_Close(hgh)							_GH_Close(hgh)
#define GH_GetRoot(hgh)							_GH_GetRoot(hgh)
#define GH_SetRoot(hgh, ghid)					_GH_SetRoot(hgh, ghid)
#define GH_GetName(hgh)							_GH_GetName(hgh)
#define GH_GetPv(hgh, ghid)						_GH_GetPv(hgh, ghid)
#define GH_GetId(hgh, pv)						_GH_GetId(hgh, pv)
#define GH_GetSize(hgh, ghid)					_GH_GetSize(hgh, ghid)
#define GH_Alloc(hgh, cb)						_GH_Alloc(hgh, cb)
#define GH_Realloc(hgh, ghid, cb)				_GH_Realloc(hgh, ghid, cb)
#define GH_Free(hgh, ghid)						_GH_Free(hgh, ghid)
#define	GH_WaitForMutex(hgh, ulT)				_GH_WaitForMutex(hgh, ulT)
#define GH_ReleaseMutex(hgh)					_GH_ReleaseMutex(hgh)
#define GH_GetObjectName(pszName, ghname, bTag) _GH_GetObjectName(pszName, \
														ghname, bTag);
#define GH_WaitForSingleObject(hMutex, ulTO)	_GH_WaitForSingleObject(hMutex,\
														ulTO)
#endif

#ifdef	WIN32
#define GH_NAME_CCH			17
#define GH_NAME_MUTEX_1		'*'		/* reserved for internal use */
#define GH_NAME_MUTEX_2		'+'		/* reserved for internal use */
#define GH_NAME_MUTEX_3		'^'
#define GH_NAME_FILE_MAPPING	'!'
void	_GH_GetObjectName(CHAR *pszName, GHNAME ghname, BYTE bTag);

BOOL	_GH_WaitForSingleObject(HANDLE hMutex, ULONG ulTimeout);
#endif


// ----------------------------------------------------------------------------

#ifdef __cplusplus
}
#endif

#endif	// __GLHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\gllocal.c ===
/*
 * gllocal.c
 *
 * Implementation of global and local heaps
 *
 * Copyright (C) 1994 Microsoft Corporation
 */
#include "_apipch.h"

#define _GLLOCAL_C

#ifdef MAC
#include "ole2ui.h"
#include <utilmac.h>
#include <mapiprof.h>

#ifdef GetPrivateProfileInt
#undef GetPrivateProfileInt
#undef GetPrivateProfileString
#endif
#define	GetPrivateProfileInt		MAPIGetPrivateProfileInt
#define	GetPrivateProfileString		MAPIGetPrivateProfileString
#endif	// MAC

// #include "glheap.h"

#ifdef MAC
#pragma code_seg("glheap", "fixed, preload")
#else
#ifdef OLD_STUFF
#pragma SEGMENT(glheap)
#endif // OLD_STUFF
#endif

#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif

// Local Heap Debug Implementation --------------------------------------------

#ifdef DEBUG

static TCHAR szDebugIni[]		=  TEXT("WABDBG.INI");
static TCHAR szSectionHeap[]		=  TEXT("Memory Management");
static TCHAR szKeyUseVirtual[]	=  TEXT("VirtualMemory");
static TCHAR szKeyAssertLeaks[]	=  TEXT("AssertLeaks");
static TCHAR szKeyDumpLeaks[]	=  TEXT("DumpLeaks");
static TCHAR szKeyFillMem[]		=  TEXT("FillMemory");
static TCHAR szKeyFillByte[]		=  TEXT("FillByte");

// Artificial Errors for local heaps
BOOL FForceFailure(HLH hlh, UINT cb);

static TCHAR szAESectionHeap[]		=  TEXT("Local Heap Failures");
static TCHAR szAEKeyFailStart[]		=  TEXT("AllocsToFirstFailure");
static TCHAR szAEKeyFailInterval[]	=  TEXT("FailureInterval");
static TCHAR szAEKeyFailBufSize[]	=  TEXT("FailureSize");

#ifdef HEAPMON
static TCHAR szKeyHeapMon[]		=  TEXT("MonitorHeap");
#ifdef MAC
static TCHAR szHeapMonDLL[]		=  TEXT("GLHM");
#else
static TCHAR szHeapMonDLL[]		=  TEXT("GLHMON32.DLL");
#endif
static char szHeapMonEntry[]	=  "HeapMonitor";
static char szGetSymNameEntry[]	=  "GetSymbolName";
#endif

// Virtual Memory Support --------------------------------------------
//
//  The VM Allocators do not currently work on:
//      AMD64
//      MAC
//
#if defined(MAC) || defined(_AMD64_) || defined(_IA64_)
#define VMAlloc(cb)				0
#define VMAllocEx(cb, ul)		0
#define VMRealloc(pv, cb)		0
#define VMReallocEx(pv, cb, ul)	0
#define VMFree(pv)
#define VMFreeEx(pv, ul)
#define VMGetSize(pv)			0
#define VMGetSizeEx(pv, ul)		0
#endif

#if defined(WIN32) && !defined(MAC)
#define LH_EnterCriticalSection(hlh)	EnterCriticalSection(&hlh->cs)
#define LH_LeaveCriticalSection(hlh)	LeaveCriticalSection(&hlh->cs)
#else
#define LH_EnterCriticalSection(hlh)
#define LH_LeaveCriticalSection(hlh)
#endif

#ifdef HEAPMON
/*
 -	FRegisterHeap
 -
 *	Purpose:
 *		If the user wants to monitor the Heap, then load the DLL with
 *		the HeapMonitor UI.
 */

BOOL FRegisterHeap(PLH plh)
{
	HINSTANCE			hInst;
	LPHEAPMONPROC		pfnHeapMon;
	LPGETSYMNAMEPROC	pfnGetSymName;
	
	plh->hInstHeapMon = 0;
	plh->pfnGetSymName = NULL;

	hInst = LoadLibrary(szHeapMonDLL);
	
	if (!hInst)
	{
		DebugTrace(TEXT("FRegisterHeap: Failed to LoadLibrary GLHMON32.DLL.\n"));
		goto ret;
	}

	pfnHeapMon = (LPHEAPMONPROC)GetProcAddress(hInst, szHeapMonEntry);
		
	if (!pfnHeapMon)
	{
		DebugTrace(TEXT("FRegisterHeap: Failed to GetProcAddress of HeapMonitor.\n"));
		FreeLibrary(hInst);
		goto ret;
	}
	
	pfnGetSymName = (LPGETSYMNAMEPROC)GetProcAddress(hInst, szGetSymNameEntry);
		
	if (!pfnGetSymName)
	{
		DebugTrace(TEXT("FRegisterHeap: Failed to GetProcAddress of GetSymName.\n"));
	}
	
 	plh->hInstHeapMon = hInst;
	
	if (!pfnHeapMon(plh, HEAPMON_LOAD))
	{
		DebugTrace(TEXT("FRegisterHeap: Call to HeapMonitor failed.\n"));
		plh->hInstHeapMon = 0;
		goto ret;
	}
	
 	plh->pfnHeapMon		= pfnHeapMon;
	plh->pfnGetSymName  = pfnGetSymName;
	
ret:
	return (plh->hInstHeapMon ? TRUE : FALSE);
}


void UnRegisterHeap(HLH hlh)
{
	if (hlh->pfnHeapMon)
		hlh->pfnHeapMon(hlh, HEAPMON_UNLOAD);
}
#endif	// HEAPMON


/*
 -	LH_ReportLeak
 -
 *	Purpose:
 *		To report individual memory leaks through DebugTrace and the
 *		LH_LeakHook breakpoint function.
 */

void LH_ReportLeak(HLH hlh, PLHBLK plhblk)
{
	DebugTrace(TEXT("Memory leak '%s' in %s @ %08lX, Allocation #%ld, Size: %ld\n"),
		plhblk->szName[0] ? plhblk->szName :  TEXT("NONAME"),
		hlh->szHeapName, PlhblkToPv(plhblk),
		plhblk->ulAllocNum, CbPlhblkClient(plhblk));
	
#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
{
	int	i;
		for (i = 0; i < NCALLERS && plhblk->pfnCallers[i]; i++)
	{
		char			szSymbol[256];
		char			szModule[64];
		DWORD			dwDisp;
		BOOL			fGotSym = FALSE;
			
		szSymbol[0] = 0;
		szModule[0] = 0;

		if (hlh->pfnGetSymName)
			if (hlh->pfnGetSymName((DWORD) plhblk->pfnCallers[i], szModule,
								   szSymbol, &dwDisp))
				fGotSym = TRUE;

		if (fGotSym)
		{	
			DebugTrace(TEXT("[%d] %s %s"), i, szModule, szSymbol);
			if (dwDisp)
				DebugTrace(TEXT("+%ld"), dwDisp);
			DebugTrace(TEXT("\n"));
		}
		else
			DebugTrace(TEXT("[%d] %s %08lX \n"), i, szModule, plhblk->pfnCallers[i]);
		DBGMEM_LeakHook(plhblk->pfnCallers[i]);
	}
}
#endif
}


/*
 -	LH_DumpLeaks
 -
 *	Purpose:
 *		Gets called at LH_Close time to report any memory leaks against
 *		this heap.  There are 3 reporting fascilities used by this routine:
 *
 *			=> Breakpoint hooking (via LH_LeakHook)
 *			=> Asserts (via TrapSz)
 *			=> Debug trace tags (via DebugTrace)
 *
 *		The Debug Trace is the default method if no others are specified
 *		or if the others are in-appropriate for the given platform.
 */

void LH_DumpLeaks(HLH hlh)
{
	PLHBLK	plhblk;
	BOOL	fDump = !!(hlh->ulFlags & HEAP_DUMP_LEAKS);
	BOOL	fAssert = !!(hlh->ulFlags & HEAP_ASSERT_LEAKS);
	int		cLeaks = 0;
	
	for (plhblk = hlh->plhblkHead; plhblk; plhblk = plhblk->plhblkNext)
	{
		if (fDump)
			LH_ReportLeak(hlh, plhblk);
		cLeaks++;
	}

	if (cLeaks)
	{
#if defined(WIN16) || (defined(WIN32) && defined(_X86_))
		if (fAssert)
		{
			TrapSz3( TEXT("GLHEAP detected %d memory leak%s in Heap: %s"),
					cLeaks, (cLeaks == 1 ? szEmpty :  TEXT("s")), hlh->szHeapName);
		}
		else
			DebugTrace(TEXT("GLHEAP detected %d memory leak%s in Heap: %s\n"),
					cLeaks, (cLeaks == 1 ? szEmpty :  TEXT("s")), hlh->szHeapName);
#else
		DebugTrace(TEXT("GLHEAP detected %d memory leak%s in Heap: %s\n"),
				cLeaks, (cLeaks == 1 ? szEmpty :  TEXT("s")), hlh->szHeapName);
#endif		
	}
}


BOOL LH_ValidatePlhblk(HLH hlh, PLHBLK plhblk, char ** pszReason)
{
	if (IsBadWritePtr(plhblk, sizeof(LHBLK)))
	{
		*pszReason = "Block header cannot be written to";
		goto err;
	}

	if (plhblk->hlh != hlh)
	{
		*pszReason = "Block header does not have correct pointer back to heap";
		goto err;
	}

	if (plhblk->plhblkNext)
	{
		if (IsBadWritePtr(plhblk->plhblkNext, sizeof(LHBLK)))
		{
			*pszReason = "Block header has invalid next link pointer";
			goto err;
		}

		if (plhblk->plhblkNext->plhblkPrev != plhblk)
		{
			*pszReason = "Block header points to a next block which doesn't "
				"point back to it";
			goto err;
		}
	}

	if (plhblk->plhblkPrev)
	{
		if (IsBadWritePtr(plhblk->plhblkPrev, sizeof(LHBLK))) {
			*pszReason = "Block header has invalid prev link pointer";
			goto err;
		}

		if (plhblk->plhblkPrev->plhblkNext != plhblk)
		{
			*pszReason = "Block header points to a prev block which doesn't "
				"point back to it";
			goto err;
		}
	}
	else if (hlh->plhblkHead != plhblk)
	{
		*pszReason = "Block header has a zero prev link but the heap doesn't "
			"believe it is the first block";
		goto err;
	}

	if (plhblk->ulAllocNum > hlh->ulAllocNum)
	{
		*pszReason = "Block header has an invalid internal allocation number";
		goto err;
	}

	return TRUE;

err:
	return FALSE;
}


// $MAC - Need WINAPI

BOOL
#ifdef MAC
WINAPI
#endif
LH_DidAlloc(HLH hlh, LPVOID pv)
{
	PLHBLK	plhblk;
	char *	pszReason;
	BOOL	fDidAlloc = FALSE;

	for (plhblk = hlh->plhblkHead; plhblk; plhblk = plhblk->plhblkNext)
	{
		AssertSz2(LH_ValidatePlhblk(hlh, plhblk, &pszReason),
			  TEXT("Block header (plhblk=%08lX) is invalid\n%s"),
			 plhblk, pszReason);

		if (PlhblkToPv(plhblk) == pv)
		{
			fDidAlloc = TRUE;
			break;
		}
	}

	return fDidAlloc;
}


BOOL LH_ValidatePv(HLH hlh, LPVOID pv, char * pszFunc)
{
	PLHBLK	plhblk;
	char *	pszReason;

	plhblk = PvToPlhblk(hlh, pv);
	
	if (!plhblk)
	{
		TrapSz3( TEXT("%s detected a memory block (%08lX) which was either not ")
			 TEXT("allocated in heap '%s' or has already been freed."),
			pszFunc, pv, hlh->szHeapName);
		return(FALSE);
	}

	if (LH_ValidatePlhblk(hlh, plhblk, &pszReason))
		return(TRUE);

	TrapSz4( TEXT("%s detected an invalid memory block (%08lX) in heap '%s'.  %s."),
		pszFunc, pv, hlh->szHeapName, pszReason);

	return FALSE;
}


/*
 -	PlhblkEnqueue
 -
 *	Purpose:
 *		To add a newly allocated block to the allocation list hanging
 *		off the heap.  We do an InsertSorted because the HeapMonitor
 *		will need to reference the allocations ordered by their
 *		location in the heap.  Since the monitor will walk the heap
 *		often, it is more efficient to do the sort up front.
 */

void PlhblkEnqueue(PLHBLK plhblk)
{
	PLHBLK	plhblkCurr = NULL;
	PLHBLK	plhblkNext = plhblk->hlh->plhblkHead;
	
	while (plhblkNext)
	{
		if (plhblkNext > plhblk)
			break;
		
		plhblkCurr = plhblkNext;
		plhblkNext = plhblkCurr->plhblkNext;
	}
	
	if (plhblkNext)
	{
		plhblk->plhblkNext		= plhblkNext;
		plhblk->plhblkPrev		= plhblkCurr;
		plhblkNext->plhblkPrev	= plhblk;
	}
	else
	{
		plhblk->plhblkNext = NULL;
		plhblk->plhblkPrev = plhblkCurr;
	}

	if (plhblkCurr)
		plhblkCurr->plhblkNext = plhblk;
	else
		plhblk->hlh->plhblkHead = plhblk;
}


/*
 -	PlhblkDequeue
 -
 *	Purpose:
 *		To remove a freed block from the list of allocations hanging
 *		off the heap.
 */

void PlhblkDequeue(PLHBLK plhblk)
{
	if (plhblk->plhblkNext)
		plhblk->plhblkNext->plhblkPrev = plhblk->plhblkPrev;
	
	if (plhblk->plhblkPrev)
		plhblk->plhblkPrev->plhblkNext = plhblk->plhblkNext;
	else
		plhblk->hlh->plhblkHead = plhblk->plhblkNext;
}


/*
 -	HexByteToBin
 -
 *	Purpose:
 *		Takes a hex string and converts the 2 msd's to a byte, ignoring
 *		the remaining digits.  This function assumes the string is
 *		formatted as: 0xnn, otherwise it simply returns 0x00.
 */

BYTE HexByteToBin(LPSTR sz)
{
	int i, n[2], nT;

	if (*sz++ != '0')
		return 0x00;

	nT = *sz++;

	if (nT != 'x' && nT != 'X')
		return 0x00;

	for (i = 0; i < 2; i++)
	{
		nT = *sz++;
		
		if (nT >= '0' && nT <= '9')
			n[i] = nT - '0';
		else if (nT >= 'A' && nT <= 'F')
			n[i] = nT - 'A' + 10;
		else if (nT >= 'a' && nT <= 'f')
			n[i] = nT - 'a' + 10;
		else
			return (BYTE)0x00;
	}	

	n[0] <<= 4;
	return (BYTE)((BYTE)n[0] | (BYTE)n[1]);
}


HLH WINAPI LH_Open(DWORD dwMaxHeap)
{
	_HLH	_hlhData = 0;
	_HLH	_hlhBlks = 0;
	PLH		plh = NULL;
	UINT	cch = 0;
	UINT	uiT = 0;
	TCHAR	szFillByte[8];
    LPSTR   lpFillByte = NULL;
	ULONG	cbVirtual = 0;
	
	//	The first thing we must do is create a heap that we will
	//	allocate our Allocation Blocks on.  We also allocate our
	//	debug Heap object on this heap.

	_hlhBlks = _LH_Open(dwMaxHeap);
	
	if (!_hlhBlks)
	{
		DebugTrace(TEXT("LH_Open: Failed to create new heap!\n"));
		goto ret;
	}
	
	//	Allocate the thing we hand back to the caller on this new heap.
	
	plh = _LH_Alloc(_hlhBlks, sizeof(LH));
	
	if (!plh)
	{
		DebugTrace(TEXT("LH_Alloc: Failed to allocate heap handle!\n"));
		_LH_Close(_hlhBlks);
		_hlhBlks = 0;
		goto ret;
	}
	
	//	Initialize all the goodies we store in this thing.
	//	Hook this heap into the global list of heaps we've
	//	created in this context.
	
	memset(plh, 0, sizeof(LH));

	plh->pfnSetName = (LPLHSETNAME)LH_SetNameFn;
	plh->_hlhBlks	= _hlhBlks;
	plh->ulFlags	= HEAP_LOCAL;

#if defined(WIN32) && !defined(MAC)
	InitializeCriticalSection(&plh->cs);
#endif
	
	// VirtualMemory default is FALSE

	cbVirtual = GetPrivateProfileInt(szSectionHeap, szKeyUseVirtual, 0,
		szDebugIni);

	if (cbVirtual)
	{
		plh->ulFlags |= HEAP_USE_VIRTUAL;

		// We always want virtual allocations on MIPS and PPC to be 4-byte
		// aligned, because all our code assumes that the beginning of an
		// allocation is aligned on machine word boundaries.  On other
		// platforms, changing this behavior is non-fatal, but on MIPS and
		// PPC we'll get alignment faults everywhere.
		
#if !defined(_MIPS_) && !defined(_PPC_)
		if (cbVirtual == 4)
#endif
			plh->ulFlags |= HEAP_USE_VIRTUAL_4;
	}
		
	// DumpLeaks default is TRUE

	if (GetPrivateProfileInt(szSectionHeap, szKeyDumpLeaks, 1, szDebugIni))
		plh->ulFlags |= HEAP_DUMP_LEAKS;
	
	// AssertLeaks default is FALSE

	if (GetPrivateProfileInt(szSectionHeap, szKeyAssertLeaks, 0, szDebugIni))
		plh->ulFlags |= HEAP_ASSERT_LEAKS;
	
	// FillMem default is TRUE

	if (GetPrivateProfileInt(szSectionHeap, szKeyFillMem, 1, szDebugIni))
		plh->ulFlags |= HEAP_FILL_MEM;
	
	if (plh->ulFlags & HEAP_FILL_MEM)
	{
		cch	= GetPrivateProfileString(
				szSectionHeap,
				szKeyFillByte,
				szEmpty,
               szFillByte,
				CharSizeOf(szFillByte)-1,
				szDebugIni);
	}

	//	Set the memory fill character.
    lpFillByte = ConvertWtoA(szFillByte);
	plh->chFill = (BYTE)(cch ? HexByteToBin(lpFillByte) : chDefaultFill);
    LocalFreeAndNull(&lpFillByte);

	//
	//  Set up artificial failures.  If anything is set in our ini file, then
	//  HEAP_FAILURES_ENABLED gets set.
	//
	uiT = GetPrivateProfileInt(szAESectionHeap, szAEKeyFailStart, 0, szDebugIni);
	if (uiT)
	{
		plh->ulFlags |= HEAP_FAILURES_ENABLED;
		plh->ulFailStart = (ULONG) uiT;
		
		plh->ulFailInterval =
			(ULONG) GetPrivateProfileInt(szAESectionHeap, szAEKeyFailInterval, 0, szDebugIni);

		plh->uiFailBufSize =
			GetPrivateProfileInt(szAESectionHeap, szAEKeyFailBufSize, 0, szDebugIni);
	}


#ifdef HEAPMON
	//	If the user wants Heap Monitor UI, the spin a thread to manage a
	//	DialogBox that can display the status of the heap at all times.

	if (GetPrivateProfileInt(szSectionHeap, szKeyHeapMon, 0, szDebugIni))
		if (FRegisterHeap(plh))
			plh->ulFlags |= HEAP_HEAP_MONITOR;
#endif

	//	If we are not using virtual memory allocators, then we
	//	create another heap to allocate the users data in.
	
	if (!(plh->ulFlags & HEAP_USE_VIRTUAL))
	{
		_hlhData = _LH_Open(dwMaxHeap);

		if (!_hlhData)
		{
			DebugTrace(TEXT("LH_Alloc: Failed to allocate heap handle!\n"));
			_LH_Close(_hlhBlks);
			plh = NULL;
			goto ret;
		}
		
		plh->_hlhData	= _hlhData;
	}
#ifndef _WIN64
	LH_SetHeapName1(plh,  TEXT("LH %08lX"), plh);
#else
	LH_SetHeapName1(plh,  TEXT("LH %p"), plh);
#endif // _WIN64

ret:
	return (HLH)plh;
}


void WINAPI LH_Close(HLH hlh)
{
	_HLH _hlhData = hlh->_hlhData;
	_HLH _hlhBlks = hlh->_hlhBlks;
	
	//	Dump memory leaks if we're supposed to.
	
	if (hlh->ulFlags & HEAP_DUMP_LEAKS)
		LH_DumpLeaks(hlh);
	
	//	Destroy the HeapMonitor thread and un-load the DLL
	
#ifdef HEAPMON
	UnRegisterHeap(hlh);
	
	if ((hlh->ulFlags & HEAP_HEAP_MONITOR) && hlh->hInstHeapMon)
		FreeLibrary(hlh->hInstHeapMon);
#endif
	
#if defined(WIN32) && !defined(MAC)
	DeleteCriticalSection(&hlh->cs);
#endif
	
	//	Clean-up and leave.  Closing frees leaks, so we're cool!
	
	if (!(hlh->ulFlags & HEAP_USE_VIRTUAL) && _hlhData)
		_LH_Close(_hlhData);
		
	if (_hlhBlks)
	{
		_LH_Free (_hlhBlks, hlh);
		_LH_Close(_hlhBlks);
	}
}


LPVOID WINAPI LH_Alloc(HLH hlh, UINT cb)
{
	PLHBLK	plhblk = NULL;
	LPVOID	pvAlloc = NULL;
	
	// Note:  To be consistent with other (e.g. system) allocators,
	// we have to return a valid allocation if cb == 0.  So, we
	// allow a cb of 0 to actually be allocated.  (See bug 3556 in
	// the sqlguest:exchange database.)

	LH_EnterCriticalSection(hlh);

	if (hlh->ulFlags & HEAP_FAILURES_ENABLED)
	{
		if (FForceFailure(hlh, cb))
		{
			DebugTrace(TEXT("LH_Alloc: Artificial Failure\n"));
			pvAlloc = NULL;
			hlh->ulAllocNum++;
			goto out;
		}
	}

	if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
		pvAlloc = VMAllocEx(cb, 4);
	else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
		pvAlloc = VMAllocEx(cb, 1);
	else if (cb > UINT_MAX)
		plhblk = 0;
	else
#ifndef _WIN64
		pvAlloc = _LH_Alloc(hlh->_hlhData, (UINT)cb);
#else
	{
		Assert(hlh->_hlhData);
		Assert(cb);
		Assert(HeapValidate(hlh->_hlhData, 0, NULL));
		pvAlloc = _LH_Alloc(hlh->_hlhData, (UINT)cb);
	}	
#endif
	
	if (pvAlloc)
	{
		plhblk = (PLHBLK)_LH_Alloc(hlh->_hlhBlks, sizeof(LHBLK));
		
		if (plhblk)
		{
			plhblk->hlh			= hlh;
			plhblk->szName[0]	= 0;
			plhblk->ulSize		= cb;
			plhblk->ulAllocNum	= ++hlh->ulAllocNum;
			plhblk->pv			= pvAlloc;

			PlhblkEnqueue(plhblk);

#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
			GetCallStack((DWORD *)plhblk->pfnCallers, 0, NCALLERS);
#endif

			if (hlh->ulFlags & HEAP_FILL_MEM)
				memset(pvAlloc, hlh->chFill, (size_t)cb);
		}
		else
		{
			if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
				VMFreeEx(pvAlloc, 4);
			else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
				VMFreeEx(pvAlloc, 1);
			else
				_LH_Free(hlh->_hlhData, pvAlloc);
			
			pvAlloc = NULL;	
		}
	}

out:

	LH_LeaveCriticalSection(hlh);
	
	return pvAlloc;
}


LPVOID WINAPI LH_Realloc(HLH hlh, LPVOID pv, UINT cb)
{
	LPVOID	pvNew = NULL;

	LH_EnterCriticalSection(hlh);

	if (pv == 0)
		pvNew = LH_Alloc(hlh, cb);
	else if (cb == 0)
		LH_Free(hlh, pv);
	else if (LH_ValidatePv(hlh, pv, "LH_Realloc"))
	{
		PLHBLK	plhblk	= PvToPlhblk(hlh, pv);
		UINT	cbOld	= (UINT)CbPlhblkClient(plhblk);

		PlhblkDequeue(plhblk);


		if (cb > cbOld &&
			((hlh->ulFlags & HEAP_FAILURES_ENABLED) && FForceFailure(hlh, cb)))
		{
			hlh->ulAllocNum++;
			pvNew = 0;
			DebugTrace(TEXT("LH_Realloc: Artificial Failure\n"));
		} else if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
			pvNew = VMReallocEx(pv, cb, 4);
		else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
			pvNew = VMReallocEx(pv, cb, 1);
		else if (cb > UINT_MAX)
			pvNew = 0;
		else
			pvNew = _LH_Realloc(hlh->_hlhData, pv, (UINT)cb);

		PlhblkEnqueue(plhblk);


		if (pvNew)
		{
			hlh->ulAllocNum++;

			plhblk->pv = pvNew;
			plhblk->ulSize = cb;
			
			if (cb > cbOld)
				memset((LPBYTE)pvNew + cbOld, hlh->chFill, cb - cbOld);
		}
	}

	LH_LeaveCriticalSection(hlh);
	
	return pvNew;
}


void WINAPI LH_Free(HLH hlh, LPVOID pv)
{
	PLHBLK	plhblk;

	LH_EnterCriticalSection(hlh);

	if (pv && LH_ValidatePv(hlh, pv, "LH_Free"))
	{
		plhblk = PvToPlhblk(hlh, pv);
		
		PlhblkDequeue(plhblk);
		
		memset(pv, 0xDC, (size_t)CbPlhblkClient(plhblk));
		
		if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
			VMFreeEx(pv, 4);
		else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
			VMFreeEx(pv, 1);
		else
			_LH_Free(hlh->_hlhData, pv);
		
		_LH_Free(hlh->_hlhBlks, plhblk);	
	}
	
	LH_LeaveCriticalSection(hlh);
}	


UINT WINAPI LH_GetSize(HLH hlh, LPVOID pv)
{
	UINT cb = 0;

	LH_EnterCriticalSection(hlh);

	if (LH_ValidatePv(hlh, pv, "LH_GetSize"))
	{
		if (hlh->ulFlags & HEAP_USE_VIRTUAL_4)
			cb = (UINT)VMGetSizeEx(pv, 4);
		else if (hlh->ulFlags & HEAP_USE_VIRTUAL)
			cb = (UINT)VMGetSizeEx(pv, 1);
		else	
			cb = (UINT) _LH_GetSize(hlh->_hlhData, pv);
	}

	LH_LeaveCriticalSection(hlh);

	return cb;
}


void __cdecl LH_SetHeapNameFn(HLH hlh, TCHAR *pszFormat, ...)
{
	TCHAR   sz[512];
	va_list	vl;

	va_start(vl, pszFormat);
    wvnsprintf(sz, ARRAYSIZE(sz), pszFormat, vl);
	va_end(vl);

    StrCpyN(hlh->szHeapName,
            sz,
            CharSizeOf(hlh->szHeapName));
}

void __cdecl EXPORT_16 LH_SetNameFn(HLH hlh, LPVOID pv, TCHAR *pszFormat, ...)
{
	TCHAR	sz[512];
	PLHBLK	plhblk;
	va_list	vl;

	plhblk = PvToPlhblk(hlh, pv);

	if (plhblk)
	{
		va_start(vl, pszFormat);
        wvnsprintf(sz, ARRAYSIZE(sz), pszFormat, vl);
		va_end(vl);

        StrCpyN(plhblk->szName, sz, CharSizeOf(plhblk->szName));
	}
}

// $MAC - Need WINAPI

TCHAR *
#ifdef MAC
WINAPI
#endif
LH_GetName(HLH hlh, LPVOID pv)
{
	PLHBLK	plhblk;

	plhblk = PvToPlhblk(hlh, pv);

	if (plhblk)
		return(plhblk->szName);

	return(szEmpty);
}


BOOL FForceFailure(HLH hlh, UINT cb)
{
	//
	//  First, see if we're past our start of failures point
	//
	if (hlh->ulFailStart && (hlh->ulFailStart <= hlh->ulAllocNum))
	{
		//
		//  If so, then are we at an interval where we should return errors?
		//
		
		if ((hlh->ulFailInterval)
			&& ((hlh->ulAllocNum - hlh->ulFailStart)%hlh->ulFailInterval) == 0)
		{
			//
			//  return that we should fail here
			//
			return TRUE;
		}

		//
		//  Check to see if the alloc size is greater than allowed
		//
		if (hlh->uiFailBufSize && cb >= hlh->uiFailBufSize)
			return TRUE;

	}


	//
	//  Otherwise, no error is returned for this alloc
	//

	return FALSE;
}



/*
 -	PvToPlhblk
 -
 *	Purpose:
 *		Finds the LHBLK for this allocation in the heap's active list.
 */

PLHBLK PvToPlhblk(HLH hlh, LPVOID pv)
{
	PLHBLK plhblk;

	LH_EnterCriticalSection(hlh);
	
	plhblk = hlh->plhblkHead;
	
	while (plhblk)
	{
		if (plhblk->pv == pv)
			break;
		
		plhblk = plhblk->plhblkNext;	
	}
	
	LH_LeaveCriticalSection(hlh);
	
	return plhblk;
}

#endif	/* DEBUG */


#ifdef MAC		// MAC!!

#if defined(DEBUG)
static TCHAR stMemErr[] =  TEXT("\pHad a memory error. See above for details");
#endif


LPVOID WINAPI _LH_Open(DWORD dwMaxHeap)
{
	Ptr			lp;

	lp = NewPtrClear(sizeof(LHeap));
	if (lp == NULL)
	{
#if defined(DEBUG)	
		DebugTrace(TEXT("_LH_Open had an error. MemError = %d"), MemError());
		DebugStr(stMemErr);
#endif /* DEBUG */
		return NULL;
	}
	return (LPVOID)lp;
}


void WINAPI _LH_Close(LPVOID plh)
{
	LBlkPtr		plb, plbNext;
#if defined(DEBUG)
	short		idx = 0;
#endif

	if (plh == NULL)
		return;

	// Walk the block list throwing out remaining mem as we go along.
	plb = ((LHeapPtr)plh)->plb;
	while (plb)
	{
		plbNext = plb->next;
		DisposePtr((Ptr)plb);
#if defined(DEBUG)
		if (MemError())
		{
			DebugTrace(TEXT("_LH_Close: Had a memory error."));
			DebugTrace(TEXT("Error number = %d"), MemError());
			DebugStr(stMemErr);
		}
		idx ++;
#endif
		plb = plbNext;
	}

	// Throw out the heap header.
	DisposePtr((Ptr)plh);
#if defined(DEBUG)
	if (MemError())
	{
		DebugTrace(TEXT("_LH_Close: Had error throwing out heap head."));
		DebugTrace(TEXT("MemError = %d"), MemError());
		DebugStr(stMemErr);
	}
	if (idx)
		DebugTrace(TEXT("Threw out %d left over local memory blocks\n"), idx);
#endif /* DEBUG */
}


LPVOID WINAPI _LH_Alloc(LPVOID plh, UINT cb)
{
	LBlkPtr		plbNew, plb;
	Ptr			lp;

	if (plh == NULL)
		return NULL;

	// Get memory for the linked list element. Mem requests are stored in a
	// linked list off a 'heap' head because real heap management is such a
	// pain on the Mac.
	plbNew = (LBlkPtr)NewPtr(sizeof(LBlock));
	if (plbNew == NULL)
		goto trouble;

	// Memory for the actual request.
	lp = NewPtrClear(cb);
	if (lp == NULL)
	{
		DisposePtr((Ptr)plbNew);
		goto trouble;
	}
	// All members of LBlock are filled in so there's no need to call
	// NewPtrclear() above.
	plbNew->ptr = lp;
	plbNew->next = NULL;

	// Find the end of the linked list and link this element in.
	if (plb = ((LHeapPtr)plh)->plb)
	{
		while (plb->next)
			plb = plb->next;
		plb->next = plbNew;
	}
	else
		((LHeapPtr)plh)->plb = plbNew;
	// Return the successfully allocated memory.
	return lp;

trouble:
	{
#if defined(DEBUG)	
		DebugTrace(TEXT("_LH_Alloc failed. MemError = %d"), MemError());
		DebugTrace(TEXT("The number of requested bytes = %d"), cb);
		DebugStr(stMemErr);
#endif /* DEBUG */
	}
	return NULL;
}


UINT WINAPI _LH_GetSize(LPVOID plh, LPVOID pv)
{
	long		cb;

	cb = GetPtrSize((Ptr)pv);
	if (MemError())
	{
#if defined(DEBUG)
		DebugTrace(TEXT("_LH_GetSize had an error. MemError = %d"), MemError());
		DebugStr(stMemErr);
#endif /* DEBUG */
		return 0;
	}
	return cb;
}


LPVOID WINAPI _LH_Realloc(LPVOID plh, LPVOID pv, UINT cb)
{
	Ptr		lp;
	UINT	cbOld;

	// Get rid of schizo cases.
	if (pv == NULL)
	{
		lp = _LH_Alloc(plh, cb);
		if (lp == NULL)
			goto err;
		return lp;
	}
	else if (cb == 0)
	{
		_LH_Free(plh, pv);
		return NULL;
	}

	// Get the size of the block the old ptr pointed to.
	cbOld = _LH_GetSize(plh, pv);
	if (cbOld == 0)
		goto err;

	// Get memory for the new pointer.
	lp = _LH_Alloc(plh, cb);
	if (lp == NULL)
		goto err;

	// Copy the old info into the new pointer, throw out the old mem and
	// return the result.
	BlockMove(pv, lp, cbOld <= cb ? cbOld : cb);
	_LH_Free(plh, pv);
	return lp;

err:
#if defined(DEBUG)
	DebugStr("\p_LH_Realloc failed");
#endif /* DEBUG */
	return 0;
}


void WINAPI _LH_Free(LPVOID plh, LPVOID pv)
{
	LBlkPtr		plb, plbPrev = NULL;

	if (pv == NULL)
		return;

	// Remove the memory from the linked list.
	plb = ((LHeapPtr)plh)->plb;
	while (plb)
	{
		if (plb->ptr == pv)
			break;
		plbPrev = plb;
		plb = plb->next;
	}
	if (plb)
	{
		if (plbPrev)
			plbPrev->next = plb->next;
		else
			((LHeapPtr)plh)->plb = plb->next;
	}
	else
	{
#if defined(DEBUG)
		DebugStr("\p_LH_Free: Did not find requested <plb> in linked list");
#endif /* DEBUG */
		return;
	}

	// Throw out the linked list element.
	DisposePtr((Ptr)plb);
#if defined(DEBUG)
		if (MemError())
			goto err;
#endif /* DEBUG */

	// Throw out the memory itself.
	DisposePtr((Ptr)pv);
#if defined(DEBUG)
	if (MemError())
err:
	{
		DebugTrace(TEXT("_LH_Free: Error disposing ptr. MemError = %d"), MemError());
		DebugStr(stMemErr);
	}
#endif /* DEBUG */
}

#endif /* MAC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\entryid.c ===
/***********************************************************************
 *
 * ENTRYID.C
 *
 * Windows AB EntryID functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 05.13.96     Bruce Kelley        Created
 *
 ***********************************************************************/

#include <_apipch.h>

#define _WAB_ENTRYID_C

static UUID WABGUID = { /* d3ad91c0-9d51-11cf-a4a9-00aa0047faa4 */
    0xd3ad91c0,
    0x9d51,
    0x11cf,
    {0xa4, 0xa9, 0x00, 0xaa, 0x00, 0x47, 0xfa, 0xa4}
};

static UUID MAPIGUID = { /* a41f2b81-a3be-1910-9d6e-00dd010f5402 */
    0xa41f2b81,
    0xa3be,
    0x1910,
    {0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02}
};
#ifdef _WIN64
#define	MYALIGN				((POINTER_64_INT) (sizeof(ALIGNTYPE) - 1))
// #define	MYALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
// #define MyPbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))
#define MyPbAlignPb(pb)		((LPBYTE) ((((POINTER_64_INT) (pb)) + MYALIGN) & ~MYALIGN))
#endif 

/***************************************************************************

    Name      : CreateWABEntryID

    Purpose   : Creates a WAB EntryID

    Parameters: bType = one of WAB_PAB, WAB_DEF_DL, WAB_DEF_MAILUSER,
                WAB_ONEOFF, WAB_LDAP_CONTAINER, WAB_LDAP_MAILUSER, WAB_PABSHARED

                lpData1, lpData2, lpData3 = data to be placed in entryid
                lpRoot = AllocMore root structure (NULL if we should
                  use AllocateBuffer instead of AllocateMore)
                lpcbEntryID -> returned size of lpEntryID.
                lpEntryID -> returned buffer containing entryid.  This buffer
                  is AllocMore'd onto the lpAllocMore buffer.  Caller is
                  responsible for MAPIFreeing this buffer.

    Returns   : HRESULT

    Comment   : WAB EID format is MAPI_ENTRYID:
                	BYTE	abFlags[4];
                	MAPIUID	mapiuid;     //  = WABONEOFFEID
                	BYTE	bData[];     // Contains BYTE type followed by type
                                        // specific data:
                                        // WAB_ONEOFF:
                                        //   szDisplayName, szAddrType and szAddress.
                                        //   the delimiter is the null between the strings.
                                        //

            4/21/97
            Outlook doesnt understand WAB One-Off EntryIDs. Outlook wants MAPI 
            One-off EntryIDs. What Outlook wants, Outlook gets. 
            MAPI EntryIDs have a slightly different format than WAB entryids.

***************************************************************************/
HRESULT CreateWABEntryID(
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG ulData1,
    ULONG ulData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID) 
{
    // [PaulHi] 1/21/99  @review
    // I assume that the default WAB_ONEOFF EID we create is UNICODE.  If we want an ANSI
    // WAB_ONEOFF EID then the CreateWABEntryEx() function needs to be called instead of
    // this one, with the first parameter set to FALSE.
    return CreateWABEntryIDEx(TRUE, bType, lpData1, lpData2, lpData3, ulData1, ulData2, lpRoot, lpcbEntryID, lppEntryID);
}


////////////////////////////////////////////////////////////////////////////////
//  CreateWABEntryIDEx
//
//  Same as CreateWABEntryID except that this function also takes a bIsUnicode
//  parameter.  If this boolean is TRUE then a WAB_ONEOFF MAPI EID will have 
//  the MAPI_UNICODE bit set in the ulDataType flag, otherwise it this bit 
//  won't be set.
////////////////////////////////////////////////////////////////////////////////
HRESULT CreateWABEntryIDEx(
    BOOL bIsUnicode,
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG ulData1,
    ULONG ulData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID)
{
    SCODE   sc = SUCCESS_SUCCESS;
    LPMAPI_ENTRYID lpeid;
    ULONG   ulSize = sizeof(MAPI_ENTRYID) + sizeof(bType);
    ULONG   cbData1, cbData2, cbData3;
    UNALIGNED LPBYTE  *llpb;
    LPBYTE  lpb23;
    LPSTR   lpszData1 = NULL;
    LPSTR   lpszData2 = NULL;
    LPSTR   lpszData3 = NULL;

#ifdef _WIN64
    ulSize = LcbAlignLcb(ulSize);
#endif
    switch ((int)bType) {
        case WAB_PAB:
        case WAB_PABSHARED:
        case WAB_DEF_DL:
        case WAB_DEF_MAILUSER:
            break;

        case WAB_ONEOFF:
            if (! lpData1 || ! lpData2 || ! lpData3) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
            
///--- 4/22/97 - MAPI One Off stuff
            // No Type here 
            ulSize -= sizeof(bType);
            // Instead, add space for version and type
            ulSize += sizeof(DWORD);
///---

            // Need more space for data strings
            // [PaulHi] 1/21/99 Raid 64211 External clients may request non-UNICODE
            // MAPI EID strings.
            if (!bIsUnicode)
            {
                // First convert strings to ANSI to get accurate DBCS count
                lpszData1 = ConvertWtoA((LPTSTR)lpData1);
                lpszData2 = ConvertWtoA((LPTSTR)lpData2);
                lpszData3 = ConvertWtoA((LPTSTR)lpData3);

                if (!lpszData1 || !lpszData2 || !lpszData3)
                {
                    sc = E_OUTOFMEMORY;
                    goto exit;
                }

                // Compute size for single byte strings
#ifdef _WIN64
                ulSize += cbData1 = LcbAlignLcb((lstrlenA(lpszData1) + 1));
                ulSize += cbData2 = LcbAlignLcb((lstrlenA(lpszData2) + 1));
                ulSize += cbData3 = LcbAlignLcb((lstrlenA(lpszData3) + 1));
#else
                ulSize += cbData1 = (lstrlenA(lpszData1) + 1);
                ulSize += cbData2 = (lstrlenA(lpszData2) + 1);
                ulSize += cbData3 = (lstrlenA(lpszData3) + 1);
#endif // _WIN64

            }
            else
            {
                // Compute size for double byte strings
#ifdef _WIN64
                ulSize += cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
                ulSize += cbData2 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1)));
                ulSize += cbData3 = LcbAlignLcb(sizeof(TCHAR)*(lstrlen((LPTSTR)lpData3) + 1));
#else
                ulSize += cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
                ulSize += cbData2 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
                ulSize += cbData3 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData3) + 1));
#endif // _WIN64
            }
            break;

        case WAB_ROOT:
            // NULL entryid
            *lppEntryID = NULL;
            *lpcbEntryID = 0;
            goto exit;

        case WAB_CONTAINER:
            if (! lpData1) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
            ulSize += sizeof(ULONG) + ulData1;
            break;

        case WAB_LDAP_CONTAINER:
            if (! lpData1) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
#ifdef _WIN64
            ulSize += cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
#else
            ulSize += cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
#endif // _WIN64
            break;

        case WAB_LDAP_MAILUSER:
            if (! lpData1 || ! lpData2) {
                sc = MAPI_E_INVALID_PARAMETER;
                goto exit;
            }
#ifdef _WIN64
            ulSize += cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
            ulSize += cbData2 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1)));
            ulSize += LcbAlignLcb(sizeof(ULONG)) // this one stores the cached array count
                    + LcbAlignLcb(sizeof(ULONG)) // this one stores the cached array buf size
                    + LcbAlignLcb(ulData2);      // this one stores the cached array
#else
            ulSize += cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
            ulSize += cbData2 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
            ulSize += sizeof(ULONG) // this one stores the cached array count
                    + sizeof(ULONG) // this one stores the cached array buf size
                    + ulData2;      // this one stores the cached array
#endif // _WIN64
            break;

        default:
            Assert(FALSE);
            sc = MAPI_E_INVALID_PARAMETER;
            goto exit;
    }

    *lppEntryID = NULL;

#ifdef _WIN64
    ulSize = LcbAlignLcb(ulSize);
#endif

    if (lpRoot) {
        if (sc = MAPIAllocateMore(ulSize, lpRoot, lppEntryID)) {
            goto exit;
        }
    } else {
        if (sc = MAPIAllocateBuffer(ulSize, lppEntryID)) {
            goto exit;
        }
    }

    lpeid = (LPMAPI_ENTRYID)*lppEntryID;
    *lpcbEntryID = ulSize;

    lpeid->abFlags[0] = 0;
    lpeid->abFlags[1] = 0;
    lpeid->abFlags[2] = 0;
    lpeid->abFlags[3] = 0;

///--- 4/22/97 - MAPI One Off stuff
    lpb23 = lpeid->bData;
    llpb = &lpb23;

    // Mark this EID as WAB
    if(bType == WAB_ONEOFF)
    {
        MemCopy(&lpeid->mapiuid, &MAPIGUID, sizeof(MAPIGUID));
        /*
        // version and flag are 0
        // *((LPDWORD)lpb) = 0;
        // lpb += sizeof(DWORD);
        //
        // Bug 32101 dont set flag to 0 - this means always send rich info
        */
        // [PaulHi] 1/21/99  Raid 64211  Set MAPI_UNICODE flag as appropriate
        *((LPULONG)*llpb) = MAKELONG(0, MAPI_ONE_OFF_NO_RICH_INFO);
        if (bIsUnicode)
	        *((LPULONG)*llpb) += MAPI_UNICODE;
	    (*llpb) += sizeof(ULONG);
    }
    else
    {
        LPBYTE  lpb1 = *llpb;
        MemCopy(&lpeid->mapiuid, &WABGUID, sizeof(WABGUID));
        // Fill in the EntryID Data
        *lpb1 = bType;
        (*llpb)++;
    }
///---

    // Fill in any other data
    switch ((int)bType)
    {
        case WAB_ONEOFF:
            if (!bIsUnicode)
            {
                // single byte characters, converted above
#ifdef _WIN64
                LPBYTE lpb = *llpb;
                Assert(lpszData1 && lpszData2 && lpszData3);

                lpb = MyPbAlignPb(lpb);

                StrCpyNA((LPSTR)lpb, lpszData1, cbData1/sizeof(CHAR));
                lpb += cbData1;

                StrCpyNA((LPSTR)lpb, lpszData2, cbData2/sizeof(CHAR));
                lpb += cbData2;

                StrCpyNA((LPSTR)lpb, lpszData3, cbData3/sizeof(CHAR));
                (*llpb) = lpb;
#else
                Assert(lpszData1 && lpszData2 && lpszData3);

                StrCpyNA((LPSTR)*llpb, lpszData1, cbData1/sizeof(CHAR));
                (*llpb) += cbData1;
                StrCpyNA((LPSTR)*llpb, lpszData2, cbData2/sizeof(CHAR));
                (*llpb) += cbData2;
                StrCpyNA((LPSTR)*llpb, lpszData3, cbData3/sizeof(CHAR));
#endif //_WIN64
            }
            else
            {
                // double byte characters
                StrCpyN((LPTSTR)*llpb, (LPTSTR)lpData1, cbData1/sizeof(TCHAR));
                (*llpb) += cbData1;
                StrCpyN((LPTSTR)*llpb, (LPTSTR)lpData2, cbData2/sizeof(TCHAR));
                (*llpb) += cbData2;
                StrCpyN((LPTSTR)*llpb, (LPTSTR)lpData3, cbData3/sizeof(TCHAR));
            }
            break;

        case WAB_CONTAINER:
            CopyMemory(*llpb, &ulData1, sizeof(ULONG));
            (*llpb) += sizeof(ULONG);
            CopyMemory(*llpb, lpData1, ulData1);
            break;

        case WAB_LDAP_CONTAINER:
            {
                UNALIGNED WCHAR * lp2 = lpData1;
#ifdef _WIN64
                LPBYTE lpb = *llpb;

                lpb = MyPbAlignPb(lpb);
                StrCpyN((LPTSTR) lpb, (LPCTSTR) lp2, cbData1/sizeof(TCHAR));  // LDAP Server name
#else 
                StrCpyN((LPTSTR) *llpb, (LPCTSTR) lp2, cbData1/sizeof(TCHAR));  // LDAP Server name

#endif 
            }
            break;

        case WAB_LDAP_MAILUSER:
            {
            UNALIGNED WCHAR * lp2 = lpData1;
#ifdef _WIN64
            LPBYTE lpb = *llpb;
        
            lpb = MyPbAlignPb(lpb);
            StrCpyN((LPTSTR) lpb, (LPCTSTR) lp2, cbData1/sizeof(TCHAR));  // LDAP Server name
            lpb += cbData1;
#else 
            StrCpyN((LPTSTR)*llpb, (LPTSTR)lpData1, cbData1/sizeof(TCHAR));  // LDAP Server name
            (*llpb) += cbData1;
#endif

#ifdef _WIN64
//            lpb = *llpb;      
//            lpb = MyPbAlignPb(lpb);
            StrCpyN((LPTSTR) lpb, (LPCTSTR) lpData2, cbData2/sizeof(TCHAR));  // LDAP Server name
            (*llpb) = lpb;

            lpb += cbData2;
            CopyMemory(lpb, &ulData1, sizeof(ULONG));
            lpb += sizeof(ULONG);
            lpb = MyPbAlignPb(lpb);

            CopyMemory(lpb, &ulData2, sizeof(ULONG));
            lpb += sizeof(ULONG);
            lpb = MyPbAlignPb(lpb);
            CopyMemory(lpb, lpData3, ulData2);
            (*llpb) = lpb;

#else 
            StrCpyN((LPTSTR)*llpb, (LPTSTR)lpData2, cbData2/sizeof(TCHAR));  // LDAP search name

            (*llpb) += cbData2;
            CopyMemory(*llpb, &ulData1, sizeof(ULONG));
            (*llpb) += sizeof(ULONG);
            CopyMemory(*llpb, &ulData2, sizeof(ULONG));
            (*llpb) += sizeof(ULONG);
            CopyMemory(*llpb, lpData3, ulData2);
#endif
            }
            break;
    } // end switch

exit:
    // Clean up
    LocalFreeAndNull(&lpszData1);
    LocalFreeAndNull(&lpszData2);
    LocalFreeAndNull(&lpszData3);

    return(ResultFromScode(sc));
}


/***************************************************************************

    Name      : IsWABEntryID

    Purpose   : Validates a WAB EntryID

    Parameters: cbEntryID = size of lpEntryID.
                lpEntryID -> entryid to check.
                lppData1, lppData2 lppData3 = data from the entryid
                  These returned pointers are pointers WITHIN the input
                  lpEntryID and are not allocated seperately.  They should
                  not be freed.

                  If lpData1 is NULL, then these values will not be returned.

    Returns   : bType = one of WAB_PAB, WAB_DEF_DL, WAB_DEF_MAILUSER,
                WAB_ONEOFF, WAB_LDAP_CONTAINER, WAB_LDAP_MAILUSER, WAB_PABSHARED or 0 if
                this is not a WAB EntryID.

    Comment   :

***************************************************************************/
BYTE IsWABEntryID(
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPVOID * lppData1,
  LPVOID * lppData2,
  LPVOID * lppData3,
  LPVOID * lppData4,
  LPVOID * lppData5)
{
    BYTE bType;
    LPMAPI_ENTRYID lpeid;
    LPBYTE lpData1, lpData2, lpData3;
    ULONG cbData1, cbData2;
    UNALIGNED BYTE *lpb = NULL ;
    ULONG ulMapiDataType = 0;

    // First check... is it big enough?
    if (cbEntryID < sizeof(MAPI_ENTRYID) + sizeof(bType)) {
        return(0);
    }

    lpeid = (LPMAPI_ENTRYID)lpEntryID;

    // Next check... does it contain our GUID?

///--- 4/22/97 - MAPI One Off stuff
    if (!memcmp(&lpeid->mapiuid, &MAPIGUID, sizeof(MAPIGUID))) 
    {
        // [PaulHi] 1/21/99  The first ULONG in lpeid->bData is the MAPI datatype.  
        // This will indicate whether the EID strings are ANSI or UNICODE.
#ifdef _WIN64
		UNALIGNED ULONG * lpu;
        lpb = lpeid->bData;
		lpu = (UNALIGNED ULONG *)lpb;
        ulMapiDataType = *lpu;
#else
        lpb = lpeid->bData;
        ulMapiDataType = *((ULONG *)lpb);
#endif // _WIN64
        lpb += sizeof(ULONG);
        bType = WAB_ONEOFF;
    }
    else if (!memcmp(&lpeid->mapiuid, &WABGUID, sizeof(WABGUID))) 
    {
        lpb = lpeid->bData;
        bType = *lpb;
        lpb++;
    }
    else
    {
        return(0);  // No match
    }
///---

    switch ((int)bType) {
        case WAB_PABSHARED:
        case WAB_PAB:
        case WAB_DEF_DL:
        case WAB_DEF_MAILUSER:
            // No more data
            break;

        case WAB_CONTAINER:
            CopyMemory(&cbData1, lpb, sizeof(ULONG));
            lpb += sizeof(ULONG);
            lpData1 = lpb;
            if(lppData1)
            {
                *lppData1 = lpData1;
                *lppData2 = (LPVOID) IntToPtr(cbData1);
            }
            break;

        case WAB_ONEOFF:
            // Validate the data strings
            // [PaulHi] 1/20/99  Raid 64211
            // Outlook2K may pass in MAPI ANSI EIDs or EIDs with UNICODE strings.
            // OL2K will set the MAPI_UNICODE flag accordingly.
            if (ulMapiDataType & MAPI_UNICODE)
            {
                // Double byte strings
                lpData1 = lpb;
                if (IsBadStringPtr((LPTSTR)lpData1, 0xFFFFFFFF)) {
                    return(0);
                }
#ifdef _WIN64
                cbData1 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1)));
#else
                cbData1 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
#endif //_WIN64

                lpData2 = lpData1 + cbData1;
                if (IsBadStringPtr((LPTSTR)lpData2, 0xFFFFFFFF)) {
                    return(0);
                }
#ifdef _WIN64
                cbData2 = LcbAlignLcb((sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1)));
#else
                cbData2 = (sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
#endif // _WIN64
                lpData3 = lpData2 + cbData2;
                if (IsBadStringPtr((LPTSTR)lpData3, 0xFFFFFFFF)) {
                    return(0);
                }
            }
            else
            {
                // Single byte strings
#ifdef _WIN64
                lpb = MyPbAlignPb(lpb);
                lpData1 = lpb;
                if (IsBadStringPtrA((LPSTR)lpData1, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData1 = lstrlenA((LPSTR)lpData1) + 1;
                lpData2 = lpData1 + LcbAlignLcb(cbData1);
                if (IsBadStringPtrA((LPSTR)lpData2, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData2 = lstrlenA((LPSTR)lpData2) + 1;
                lpData3 = lpData2 + LcbAlignLcb(cbData2);
                if (IsBadStringPtrA((LPSTR)lpData3, 0xFFFFFFFF)) {
                    return(0);
                }
#else
                lpData1 = lpb;
                if (IsBadStringPtrA((LPSTR)lpData1, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData1 = lstrlenA((LPSTR)lpData1) + 1;
                lpData2 = lpData1 + cbData1;
                if (IsBadStringPtrA((LPSTR)lpData2, 0xFFFFFFFF)) {
                    return(0);
                }
                cbData2 = lstrlenA((LPSTR)lpData2) + 1;
                lpData3 = lpData2 + cbData2;
                if (IsBadStringPtrA((LPSTR)lpData3, 0xFFFFFFFF)) {
                    return(0);
                }
#endif // _WIN64
            }
            if (lppData1)
            {
                Assert(lppData2);
                Assert(lppData3);
                *lppData1 = lpData1;
                *lppData2 = lpData2;
                *lppData3 = lpData3;
                // [PaulHi] Also return the MAPI data type variable, if requested
                if (lppData4)
                    *((ULONG *)lppData4) = ulMapiDataType;
            }
            break;

        case WAB_LDAP_CONTAINER:
            // Validate the data strings
#ifdef _WIN64
            lpData1 = MyPbAlignPb(lpb);
#else
            lpData1 = lpb;
#endif // _WIN64
            if (IsBadStringPtr((LPTSTR)lpData1, 0xFFFFFFFF)) {
                return(0);
            }
            if (lppData1) {
                *lppData1 = lpData1;
            }
            break;

        case WAB_LDAP_MAILUSER:
            // Validate the data strings
            {
#ifdef _WIN64
            UNALIGNED BYTE * lp2 = lpb;
            lp2 = MyPbAlignPb(lp2);
            lpData1 = lp2;
#else
            lpData1 = lpb;
#endif              
            if (IsBadStringPtr((LPTSTR)lpData1, 0xFFFFFFFF)) 
            {
                return(0);
            }
#ifdef _WIN64
            cbData1 = LcbAlignLcb(sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1));
#else
            cbData1 = sizeof(TCHAR)*(lstrlen((LPTSTR)lpData1) + 1);
#endif // _WIN64
            lpData2 = lpData1 + cbData1;

            if (IsBadStringPtr((LPTSTR)lpData2, 0xFFFFFFFF)) 
            {
                return(0);
            }
#ifdef _WIN64
            cbData2 = LcbAlignLcb(sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1));
#else
            cbData2 = sizeof(TCHAR)*(lstrlen((LPTSTR)lpData2) + 1);
#endif // _WIN64

            lpData3 = lpData2 + cbData2;
            if (lppData4)
            {
                CopyMemory(lppData4, lpData3, sizeof(ULONG)); //Copy the # of props in cached buffer
            }
            lpData3 += sizeof(ULONG);
#ifdef _WIN64
            lpData3 = MyPbAlignPb(lpData3);
#endif //_WIN64
            if (lppData5)
            {
                CopyMemory(lppData5, lpData3, sizeof(ULONG)); //Copy the size of cached buffer
            }
            lpData3 += sizeof(ULONG);
#ifdef _WIN64
            lpData3 = MyPbAlignPb(lpData3);
#endif //_WIN64
            if (lppData1) 
                {
                *lppData1 = lpData1;
                if(lppData2)
                    *lppData2 = lpData2;
                if(lppData3)
                    *lppData3 = lpData3;
                }
            }
            break;

        default:
            return(0);  // Not a valid WAB EID
    }

    return(bType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\fonts.c ===
#include "_apipch.h"

/**
LOGFONT g_lfFolderNameHorz=
{
    0, // lfHeight
    0, // lfWidth
    0, // lfEscapement
    0, // lfOrientation
    400, // lfWeight
    0, // lfItalic
    0, // lfUnderline
    0, // lfStrikeout
    DEFAULT_CHARSET, // lfCharSet
    OUT_DEFAULT_PRECIS, // lfOutPrecision
    CLIP_DEFAULT_PRECIS, // lfClipPrecision
    DEFAULT_QUALITY, // lfQuality
    DEFAULT_PITCH | FF_DONTCARE, // lfPitchAndFamily
    "" // lfFaceName
};

LOGFONT g_lfFolderNameVert=
{
    0, // lfHeight
    0, // lfWidth
    2700, // lfEscapement
    0, // lfOrientation
    400, // lfWeight
    0, // lfItalic
    0, // lfUnderline
    0, // lfStrikeout
    DEFAULT_CHARSET, // lfCharSet
    OUT_DEFAULT_PRECIS, // lfOutPrecision
    CLIP_DEFAULT_PRECIS, // lfClipPrecision
    DEFAULT_QUALITY, // lfQuality
    DEFAULT_PITCH | FF_DONTCARE, // lfPitchAndFamily
    "" // lfFaceName
};
**/

LOGFONT g_lfSysIcon,
        g_lfSysIconBold;
//        g_lfSysIconItalic,
//        g_lfSysIconItalicBold,
//        g_lfSysMenu;

LOGFONT *g_rgplf[fntsMax]=
{
    &g_lfSysIcon,
    &g_lfSysIconBold,
//    &g_lfSysIconItalic,
//    &g_lfSysIconItalicBold,
//    &g_lfSysMenu,
//    &g_lfFolderNameHorz,
//    &g_lfFolderNameVert
};

HFONT g_rgFont[fntsMax] = {0};
static int  g_yPerInch=0;

HFONT GetFont(int ifont)
    {
    HFONT hfont;

    if (g_rgFont[ifont]==NULL)
    {
        hfont = CreateFontIndirect(g_rgplf[ifont]);
        g_rgFont[ifont] = hfont;
    }
    else
    {
        hfont = g_rgFont[ifont];
    }

    return(hfont);
    }


#define CCHMAX_STRINGRES 64

BOOL InitFonts(void)
{
    NONCLIENTMETRICS    ncm;
    ncm.cbSize = sizeof(ncm);
    if(SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &g_lfSysIcon, 0))
    {
        CopyMemory((LPBYTE)&g_lfSysIconBold, (LPBYTE)&g_lfSysIcon, sizeof(LOGFONT));
        //CopyMemory((LPBYTE)&g_lfSysIconItalic, (LPBYTE)&g_lfSysIcon, sizeof(LOGFONT));
        //CopyMemory((LPBYTE)&g_lfSysIconItalicBold, (LPBYTE)&g_lfSysIcon, sizeof(LOGFONT));
        g_lfSysIconBold.lfWeight = (g_lfSysIconBold.lfWeight < 700) ? 700 : 1000;
        //g_lfSysIconItalic.lfItalic=TRUE;
        //g_lfSysIconItalicBold.lfItalic=TRUE;
        //g_lfSysIconItalicBold.lfWeight = (g_lfSysIconItalicBold.lfWeight < 700) ? 700 : 1000;
    }

    //if(SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
    //    CopyMemory((LPBYTE)&g_lfSysMenu, (LPBYTE)&ncm.lfMenuFont, sizeof(LOGFONT));

    return(TRUE);
}


void DeleteFonts(void)
{
    int ifont;

    for (ifont = 0; ifont < fntsMax; ifont++)
    {
        if (g_rgFont[ifont] != NULL)
        {
            DeleteObject((HGDIOBJ)g_rgFont[ifont]);
            g_rgFont[ifont] = NULL;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\entry.c ===
/*
 *	ENTRY.C
 *	
 *	DLL entry functions for extended MAPI. Mostly for debugging
 *	purposes.
 */

#include <_apipch.h>
#include <advpub.h>
#include "htmlhelp.h"
#include <shlwapi.h>

#define _ENTRY_C

#ifdef MAC
#include <utilmac.h>

#define	PvGetInstanceGlobals()		PvGetInstanceGlobalsMac(kInstMAPIX)
#endif

#ifndef MB_SETFOREGROUND
#define MB_SETFOREGROUND 0
#endif

#ifdef	DEBUG

void	ExitCheckInstance(LPINST pinst);
void	ExitCheckInstUtil(LPINSTUTIL pinstUtil);

#endif	

HINSTANCE	hinstMapiX = NULL;      // Instance to the WAB resources module (wab32res.dll)
HINSTANCE	hinstMapiXWAB = NULL;   // Instance of the WAB32.dll module (this dll)

#if 0
// @todo [PaulHi] DLL Leak.  Remove this or implement
extern CRITICAL_SECTION csOMIUnload;
#endif

BOOL fGlobalCSValid = FALSE;

// Global handle for CommCtrl DLL
HINSTANCE       ghCommCtrlDLLInst = NULL;
ULONG           gulCommCtrlDLLRefCount = 0;

extern void DeinitCommDlgLib();

// Global fontinit for UI
BOOL bInitFonts = FALSE;

BOOL g_bRunningOnNT = TRUE; // Checks the OS we run on so Unicode calls can be thunked to Win9x

BOOL bDNisByLN = FALSE;  // Language dependent flag that tells us if the default
                         // display name should be by first name or last name.
TCHAR szResourceDNByLN[32]; // cache the formatting strings so we load them only once
TCHAR szResourceDNByFN[32];
TCHAR szResourceDNByCommaLN[32];

BOOL bPrintingOn = TRUE;// Locale dependent flag that tells us to remove printing entirely
                         // from the UI

// When running against Outlook, we need a way for Outlook
// to signal us about store changes so we can refresh the UI. There are 2
// events we are interested in - 1. to update the list of contact folders
// and 2 to update the list of contacts - we will use 2 events for this
//
HANDLE ghEventOlkRefreshContacts = NULL;
HANDLE ghEventOlkRefreshFolders = NULL;
static const char cszEventOlkRefreshContacts[]  = "WAB_Outlook_Event_Refresh_Contacts";
static const char cszEventOlkRefreshFolders[]  = "WAB_Outlook_Event_Refresh_Folders";

typedef HRESULT (CALLBACK* SHDLLGETVERSIONPROC)(DLLVERSIONINFO *);
typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef int (STDAPICALLTYPE *PFNMLWINHELP)(HWND hWndCaller, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (STDAPICALLTYPE *PFNMLHTMLHELP)(HWND hWndCaller, LPCTSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);



///////////////////////////////////////////////////////////////////////////////
//  bCheckifRunningOnWinNT5
///////////////////////////////////////////////////////////////////////////////
BOOL bCheckifRunningOnWinNT5()
{
    OSVERSIONINFO   osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 5);
}

///////////////////////////////////////////////////////////////////////////////
//  Load the WAB resource DLL.  This is done every time the WAB32.DLL is loaded.
//  If we have a version 5 or greater SHLWAPI.DLL then we should use the load
//  library function API there.  If we are running NT5 or greater then we
//  use the special cross codepage support.  
//  Also use the new PlugUI version of WinHelp and HtmlHelp APIs in SHLWAPI.DLL
///////////////////////////////////////////////////////////////////////////////

// Copied from shlwapip.h, yuck.
#define ML_NO_CROSSCODEPAGE     0
#define ML_CROSSCODEPAGE_NT     1

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");


///////////////////////////////////////////////////////////////////////////////
//  LoadWABResourceDLL
//
//  Load the WAB resource DLL using the IE5 or greater Shlwapi.dll LoadLibrary
//  function if available.  Otherwise use the system LoadLibrary function.
//
//  Input Params: hInstWAB32     - handle to WAB DLL
//
//  Returns handle to the loaded resource DLL
///////////////////////////////////////////////////////////////////////////////
HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR       szPath[MAX_PATH];
    HINSTANCE   hInst = NULL;
    HINSTANCE   hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    PFNMLLOADLIBARY pfnLoadLibrary = NULL;
    
    if (hinstShlwapi)
    {
        SHDLLGETVERSIONPROC pfnVersion;
        DLLVERSIONINFO      info = {0};

        pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                    pfnLoadLibrary = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378); // UNICODE ordinal
            }
        }
    }

    // We have special cross codepage support on NT5 and on.
    if (pfnLoadLibrary)
    {
        hInst = pfnLoadLibrary(c_szWABResourceDLL, hInstWAB32, 
                               bCheckifRunningOnWinNT5() ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE);
    }
    if (!hInst)
        hInst = LoadLibrary(c_szWABResourceDLL);

    // Try full path name for resource DLL
    if ( !hInst && (GetModuleFileName(hInstWAB32, szPath, CharSizeOf(szPath))) )
    {
        int iEnd;

        iEnd = lstrlen(szPath) - lstrlen(c_szWABDLL);
        StrCpyN(&szPath[iEnd], c_szWABResourceDLL, ARRAYSIZE(szPath)-iEnd);
        if (pfnLoadLibrary)
        {
            hInst = pfnLoadLibrary(szPath, hInstWAB32, 
                                   bCheckifRunningOnWinNT5() ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE);
        }
        if (!hInst)
            hInst = LoadLibrary(szPath);
    }

    if (hinstShlwapi)
        FreeLibrary(hinstShlwapi);

    AssertSz(hInst, TEXT("Failed to LoadLibrary Lang Dll"));

    return(hInst);
}

// PlugUI version of WinHelp
BOOL WinHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData)
{
    static s_fChecked = FALSE;      // Only look for s_pfnWinHelp once
    static PFNMLWINHELP  s_pfnWinHelp = NULL;

    if (!s_pfnWinHelp && !s_fChecked)
    {
        HINSTANCE   hShlwapi = DemandLoadShlwapi();
        s_fChecked = TRUE;
        if (hShlwapi)
        {
            // Check version of the shlwapi.dll
            SHDLLGETVERSIONPROC pfnVersion;
            DLLVERSIONINFO      info = {0};

            pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hShlwapi, c_szDllGetVersion);
            if (pfnVersion)
            {
                info.cbSize = sizeof(DLLVERSIONINFO);

                if (SUCCEEDED(pfnVersion(&info)))
                {
                    if (info.dwMajorVersion >= 5)
                        s_pfnWinHelp = (PFNMLWINHELP)GetProcAddress(hShlwapi, (LPCSTR)397);   // UNICODE ordinal
                }
            }
        }
    }

    if (s_pfnWinHelp)
        return s_pfnWinHelp(hWndCaller, pwszHelpFile, uCommand, dwData);

    // [PaulHi] Win9X version of WinHelpW doesn't work
    if (g_bRunningOnNT)
        return WinHelp(hWndCaller, pwszHelpFile, uCommand, dwData);
    else
    {
        LPSTR   pszHelpFile = ConvertWtoA(pwszHelpFile);
        BOOL    bRtn = WinHelpA(hWndCaller, (LPCSTR)pszHelpFile, uCommand, dwData);

        LocalFreeAndNull(&pszHelpFile);
        return bRtn;
    }
}

// PlugUI version of HtmlHelp
HWND HtmlHelpWrap(HWND hWndCaller, LPCTSTR pwszHelpFile, UINT uCommand, DWORD_PTR dwData)
{
    static s_fChecked = FALSE;      // Only look for s_pfnHtmlHelp once
    static PFNMLHTMLHELP s_pfnHtmlHelp = NULL;

    if (!s_pfnHtmlHelp && !s_fChecked)
    {
        HINSTANCE   hShlwapi = DemandLoadShlwapi();
        s_fChecked = TRUE;
        if (hShlwapi)
        {
            // Check version of the shlwapi.dll
            SHDLLGETVERSIONPROC pfnVersion;
            DLLVERSIONINFO      info = {0};

            pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hShlwapi, c_szDllGetVersion);
            if (pfnVersion)
            {
                info.cbSize = sizeof(DLLVERSIONINFO);

                if (SUCCEEDED(pfnVersion(&info)))
                {
                    if (info.dwMajorVersion >= 5)
                        s_pfnHtmlHelp = (PFNMLHTMLHELP)GetProcAddress(hShlwapi, (LPCSTR)398); // UNICODE ordinal
                }
            }
        }
    }

    if (s_pfnHtmlHelp)
        return s_pfnHtmlHelp(hWndCaller, pwszHelpFile, uCommand, dwData, 
                             bCheckifRunningOnWinNT5() ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE);

    // [PaulHi] Wide chars work Ok on Win9X
    return HtmlHelp(hWndCaller, pwszHelpFile, uCommand, dwData);
}


/*
-
-   CheckifRunningOnWinNT
*
*   Checks the OS we are running on and returns TRUE for WinNT
*   False for Win9x
*/
BOOL bCheckifRunningOnWinNT()
{
    OSVERSIONINFO osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

#if defined(WIN32) && !defined(MAC)

/*
 *	DLL entry point for Win32
 */

BOOL WINAPI
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpvReserved)
{
    LPPTGDATA lpPTGData=NULL;

	switch ((short)dwReason)
	{

	case DLL_PROCESS_ATTACH:
		// allocate a TLS index

        g_bRunningOnNT = bCheckifRunningOnWinNT();

		if ((dwTlsIndex = TlsAlloc()) == 0xfffffff)
			return FALSE;

		hinstMapiXWAB = hinst;
        hinstMapiX = LoadWABResourceDLL(hinstMapiXWAB);

        Assert(hinstMapiX);

		if(!hinstMapiX)
		{
			DWORD dwCode = GetLastError();
			DebugTrace(TEXT("WAB32 Resource load failed: %d\n"), dwCode);
		}
        g_msgMSWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);

        bInitFonts = InitFonts();

        // The WAB does a lot of DisplayName formatting and DisplayName parsing
        // For western names we can always assume thathe the First Name comes
        // first in the display name. However for FE and some locales like Hungarian,
        // this is not true so the WAB needs to know when it can assume the 
        // First Name comes first and when it can Assume that the first name
        // comes last ... so localizers set a flag  .. if the string
        // idsLangDisplayNameisByLastName is set to "1" then we know that the
        // default names for this language start with the last name
        // The localizers also set the format templates for defining how a name
        // should be created from the First/Middle/Last names .. for example,
        // in Japanese it is "L F" (no comma) while elsewhere it could be "L,F"
        // All these things are set in localization...
        {
            TCHAR szBuf[32];
            const LPTSTR lpszOne = TEXT("1");
            const LPTSTR lpszDefFormatName = TEXT("%1% %2% %3");

            LoadString(hinstMapiX, idsLangDisplayNameIsByLastName, szBuf, CharSizeOf(szBuf));
            // if szBuf == "1" then Yes, its by last name .. else its not
            TrimSpaces(szBuf);
            if (!lstrcmpi(szBuf,lpszOne))
                bDNisByLN = TRUE;
            else
                bDNisByLN = FALSE;
            DebugTrace(TEXT("bDNisByLN: %d\n"),bDNisByLN);

            // The DNbyLN can be formed using a comma for western and without a comma for most FE and hungarian ..
            // So if the localizers set the lang default to be by LN, then we use the version without the comma,
            // else we use the version with the comma ..
            LoadString( hinstMapiX,idsDisplayNameByLastName,szResourceDNByLN,CharSizeOf(szResourceDNByLN));
            if(!lstrlen(szResourceDNByLN)) //for whatever reason .. cant afford to fail here
                StrCpyN(szResourceDNByLN, lpszDefFormatName, ARRAYSIZE(szResourceDNByLN));

            LoadString( hinstMapiX,idsDisplayNameByCommaLastName,szResourceDNByCommaLN,CharSizeOf(szResourceDNByCommaLN));
            if(!lstrlen(szResourceDNByCommaLN)) //for whatever reason .. cant afford to fail here
                StrCpyN(szResourceDNByCommaLN, lpszDefFormatName, ARRAYSIZE(szResourceDNByLN));

            LoadString(hinstMapiX,idsDisplayNameByFirstName,szResourceDNByFN,CharSizeOf(szResourceDNByFN));
            if(!lstrlen(szResourceDNByFN)) //for whatever reason .. cant afford to fail here
                StrCpyN(szResourceDNByFN, lpszDefFormatName, ARRAYSIZE(szResourceDNByLN));

            LoadString(hinstMapiX, idsLangPrintingOn, szBuf, CharSizeOf(szBuf));
            // if szBuf == "1" then Yes, its by last name .. else its not
            TrimSpaces(szBuf);
            if (!lstrcmpi(szBuf,lpszOne))
                bPrintingOn = TRUE;
            else
                bPrintingOn = FALSE;
            DebugTrace(TEXT("bPrintingOn: %d\n"),bPrintingOn);
        }
        {
            // Create the events needed for synchronizing with the outlook store
            ghEventOlkRefreshContacts = CreateEventA(NULL,   // security attributes
                                                    TRUE,   // Manual reset
                                                    FALSE,  // initial state
                                                    cszEventOlkRefreshContacts);

            ghEventOlkRefreshFolders  = CreateEventA(NULL,   // security attributes
                                                    TRUE,   // Manual reset
                                                    FALSE,  // initial state
                                                    cszEventOlkRefreshFolders);

        }

        // Check for commoncontrol presence for UI
        InitCommonControlLib();

        InitializeCriticalSection(&csUnkobjInit);
		InitializeCriticalSection(&csMapiInit);
		InitializeCriticalSection(&csHeap);
#if 0
        // @todo [PaulHi] DLL Leak.  Remove this or implement
        InitializeCriticalSection(&csOMIUnload);
#endif

		//	Critical section to protect the Address Book's SearchPathCache
		//	This hack is used because we can't enter the IAB's critical
		//	section from ABProviders call to our AdviseSink::OnNotify for
		//	the Merged One-off and Hierarchy tables.
       InitializeCriticalSection(&csMapiSearchPath);
       InitDemandLoadedLibs();

		//  All the CSs have been initialized
		fGlobalCSValid = TRUE;

		// We don't need these, so tell the OS to stop 'em
        // [PaulHi] 3/8/99  Raid 73731  We DO need these calls.  This is the
        // only way thread local storage is deallocated.  Allocation are performed
        // on demand through the WAB GetThreadStoragePointer() function.
#if 0
		DisableThreadLibraryCalls(hinst);
#endif

        ScInitMapiUtil(0);


        // No Break here - fall through to DLL_THREAD_ATTACH
        // for thread initialization

	case DLL_THREAD_ATTACH:

        DebugTrace(TEXT("DllEntryPoint: 0x%.8x THREAD_ATTACH\n"), GetCurrentThreadId());

        // [PaulHi] 3/9/99  There is no need to allocate the thread global data here
        // since the WAB will allocate whenever it needs the data through the
        // GetThreadStoragePointer(), i.e., on demand.
        // Memory leak mentioned below should now be fixed.
#if 0
        lpPTGData = GetThreadStoragePointer();
        // Note the above ThreadStoragePointer seems to leak in every process
        // so avoid using it for anything more...
        if(!lpPTGData)
	    {
		    DebugPrintError((TEXT("DoThreadAttach: LocalAlloc() failed for thread 0x%.8x\n"), GetCurrentThreadId()));
			lpPTGData = NULL;
			return FALSE;
	    }
#endif

        break;


	case DLL_PROCESS_DETACH:
        DebugTrace(TEXT("LibMain: 0x%.8x PROCESS_DETACH\n"), GetCurrentThreadId());
        /*
        if (hMuidMutex) {
            CloseHandle(hMuidMutex);
            hMuidMutex = NULL;
        }
        */
        if(ghEventOlkRefreshContacts)
        {
            CloseHandle(ghEventOlkRefreshContacts);
            ghEventOlkRefreshContacts = NULL;
        }
        if(ghEventOlkRefreshFolders)
        {
            CloseHandle(ghEventOlkRefreshFolders);
            ghEventOlkRefreshFolders = NULL;
        }

        if (bInitFonts)
            DeleteFonts();
        
        if(hinstMapiX)
            FreeLibrary(hinstMapiX);

        // Fall into DLL_THREAD_DETACH to detach last thread
	case DLL_THREAD_DETACH:

        DebugTrace(TEXT("LibMain: 0x%.8x THREAD_DETACH\n"), GetCurrentThreadId());
       
        // get the thread data
		lpPTGData = TlsGetValue(dwTlsIndex);
		if (!lpPTGData)
		{
			// the thread that detaches, did not attach to the DLL. This is allowed.
			DebugTrace(TEXT("LibMain: thread %x didn't attach\n"),GetCurrentThreadId());
			// if this is a PROCESS_DETACH, I still want to go through the process
			// detach stuff, but if it a thread detach, I'm done
		    if (dwReason == DLL_PROCESS_DETACH)
			    goto do_process_detach;
            else
    			break;
		}

        if(pt_hDefFont)
            DeleteObject(pt_hDefFont);
        if(pt_hDlgFont)
            DeleteObject(pt_hDlgFont);

        // For some reason code never hits this point a lot of times
        // and the threadlocalstorage data leaks.
        // [PaulHi] This was because the DLL_TRHEAD_DETACH calls were turned off above,
        // through DisableThreadLibraryCalls().  The leak should be fixed now.
#ifdef HM_GROUP_SYNCING
        LocalFreeAndNull(&(lpPTGData->lptszHMAccountId));
#endif
	    LocalFreeAndNull(&lpPTGData);

		// if this is THREAD_DETACH, we're done
		if (dwReason == DLL_THREAD_DETACH)
			break;


        //N clean up jump stuff in detach
do_process_detach:

        // do process detach stuff here ...
        DeinitMapiUtil();

#ifdef	DEBUG
		{
			// Don't allow asserts to spin a thread
			extern BOOL fInhibitTrapThread;
			fInhibitTrapThread = TRUE;

			ExitCheckInstance((LPINST)PvGetInstanceGlobals());
			ExitCheckInstUtil((LPINSTUTIL)PvGetInstanceGlobalsEx(lpInstUtil));
		}
#endif	/* DEBUG */


        // Unload Common control dll
        if (ghCommCtrlDLLInst != NULL)
            DeinitCommCtrlClientLib();
        DeinitCommDlgLib();

		//  Tearing down all the global CSs
		fGlobalCSValid = FALSE;

		DeleteCriticalSection(&csUnkobjInit);
		DeleteCriticalSection(&csMapiInit);
		DeleteCriticalSection(&csHeap);
#if 0
        // @todo [PaulHi] DLL Leak.  Remove this or implement
        DeleteCriticalSection(&csOMIUnload);
#endif
		DeleteCriticalSection(&csMapiSearchPath);

		// release the TLS index
		TlsFree(dwTlsIndex);

        DeinitCryptoLib();
        FreeDemandLoadedLibs();

		break;



    default:
		DebugTrace(TEXT("MAPIX FInitMapiDll: bad dwReason %ld\n"), dwReason);
        break;


	}

	return TRUE;
}

#endif	/* WIN32  && !MAC */


#ifdef	DEBUG

void
ExitCheckInstance(LPINST pinst)
{
	TCHAR   rgch[MAX_PATH];
	TCHAR   rgchTitle[128];
	BOOL		fAssertLeaks;

	if (!pinst)
		return;

	if (pinst->szModName[0])
        wnsprintf(rgchTitle, ARRAYSIZE(rgchTitle), TEXT("MAPIX exit checks for '%s'"), pinst->szModName);
	else
        StrCpyN(rgchTitle,  TEXT("MAPIX exit checks"), ARRAYSIZE(rgchTitle));
	DebugTrace(TEXT("%s\n"), rgchTitle);

	fAssertLeaks = GetPrivateProfileInt( TEXT("General"),  TEXT("AssertLeaks"), 0,  TEXT("wabdbg.ini"));

	//	Check for Init/Deinit imbalance
	if (pinst->cRef)
	{
        wnsprintf(rgch, ARRAYSIZE(rgch), TEXT("MAPIX: leaked %ld references"), pinst->cRef);
		TraceSz1( TEXT("%s\n"), rgch);
		if (fAssertLeaks)
			TrapSz(rgch);
	}


	//	Generate memory leak reports.
#if 0	//	LH_DumpLeaks is not exported
//	if (pinst->hlhClient)
//		LH_DumpLeaks(pinst->hlhClient);
	if (pinst->hlhProvider)
		LH_DumpLeaks(pinst->hlhProvider);
	if (pinst->hlhInternal)
		LH_DumpLeaks(pinst->hlhInternal);
#else
{
	HLH	hlh;

	if (pinst->hlhProvider)
		LH_Close(pinst->hlhProvider);
	hlh = pinst->hlhInternal;
	if (hlh)
	{
		LH_Free(hlh, pinst);
		LH_Close(hlh);
	}
}
#endif
}

void
ExitCheckInstUtil(LPINSTUTIL pinstUtil)
{
	HLH		hlh;

	if (!pinstUtil)
		return;

	hlh = pinstUtil->hlhClient;
	if (hlh)
	{
		LH_Free(hlh, pinstUtil);
		LH_Close(hlh);
	}
}


#endif	/* DEBUG */

#ifndef WIN16
static const char c_szReg[]         = "Reg";
static const char c_szRegHandlers[] = "RegisterHandlers";
static const char c_szUnReg[]       = "UnReg";
static const char c_szAdvPackDll[]  = "ADVPACK.DLL";
static const TCHAR c_szWabPath[]    =  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe");
static const TCHAR c_szRegWABVerInfo[] = TEXT("Software\\Microsoft\\WAB\\Version Info");
static const TCHAR c_szIEInstallMode[] = TEXT("InstallMode");
static char c_szWAB_EXE[]           = "WAB_EXE";

BOOL FRedistMode()
{
    HKEY hkey;
    DWORD cb;
    DWORD dwInstallMode=0;
    BOOL fRedist = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegWABVerInfo, 0, KEY_READ, &hkey))
    {
        cb = sizeof(dwInstallMode);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szIEInstallMode, 0, NULL, (LPBYTE)&dwInstallMode, &cb))
        {
            fRedist = (dwInstallMode > 0);
        }

        RegCloseKey(hkey);
    }
    return fRedist;
}


HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT     hr;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    TCHAR       szExe[MAX_PATH];
    STRENTRY    seReg;
    STRTABLE    stReg;
    DWORD       cb;

    hr = E_FAIL;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL)
        {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL)
            {
            cb = CharSizeOf(szExe);
            if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, c_szWabPath, szExe, &cb))
                {
                seReg.pszName = c_szWAB_EXE;
                seReg.pszValue = ConvertWtoA(szExe);
                stReg.cEntries = 1;
                stReg.pse = &seReg;

                // Call the self-reg routine
                hr = pfnri(hinstMapiXWAB, szSection, &stReg);
                LocalFreeAndNull(&seReg.pszValue);
                }
            }

        FreeLibrary(hAdvPack);
        }

    return(hr);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = E_FAIL;
    TCHAR szWABPath[MAX_PATH];

    // Set the wab32.dll path in the registry under
    // HKLM/Software/Microsoft/WAB/WAB4/DLLPath
    //
    if( hinstMapiXWAB &&
        GetModuleFileName(hinstMapiXWAB, szWABPath, CharSizeOf(szWABPath)))
    {
        HKEY hSubKey = NULL;
        DWORD dwDisp = 0;
        if(ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY,
                                            0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
        {
            RegSetValueEx(hSubKey,szEmpty,0,REG_SZ, (LPBYTE)szWABPath, (lstrlen(szWABPath)+1) * sizeof(TCHAR) );
            RegCloseKey(hSubKey);
            hr = S_OK;
        }
    }

    if(HR_FAILED(hr))
        goto out;

    // OE Bug 67540
    // For some reason, need to do handlers then regular else
    // default contact handler won't be taken

    if (!FRedistMode())
        // Try to register handlers as we are not in redist mode
        CallRegInstall(c_szRegHandlers);
     
    // Register things that are always registered
    hr = CallRegInstall(c_szReg);

out:
    return(hr);
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(c_szUnReg);

    return(hr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\globals.h ===
/*  
*   globals.h

    Various globals used everywhere in the WAB
    
*/


// Note most of the Enums below are closely tied to the static arrasy
// in globals.c
//

enum {
    ircPR_DISPLAY_NAME = 0,
    ircPR_DISPLAY_TYPE,
    ircPR_ENTRYID,
    ircPR_INSTANCE_KEY,
    ircPR_OBJECT_TYPE,
    ircPR_RECORD_KEY,
    ircPR_ROWID,
    ircPR_DEPTH,
    ircPR_CONTAINER_FLAGS,
    ircPR_WAB_LDAP_SERVER,
    ircPR_WAB_RESOLVE_FLAG,
    ircPR_AB_PROVIDER_ID,
    ircMax
};

//
// Default set of properties to return from a ResolveNames.
// May be overridden by passing in lptagaColSet to ResolveNames.
//
enum {
    irdPR_ADDRTYPE = 0,
    irdPR_DISPLAY_NAME,
    irdPR_EMAIL_ADDRESS,
    irdPR_ENTRYID,
    irdPR_OBJECT_TYPE,
    irdPR_SEARCH_KEY,
    irdPR_RECORD_KEY,
    irdPR_SURNAME,
    irdPR_GIVEN_NAME,
    irdPR_INSTANCE_KEY,
    irdPR_SEND_INTERNET_ENCODING,
    irdMax
};


//  PR_WAB_DL_ENTRIES proptag array
//
enum {
    iwdesPR_WAB_DL_ENTRIES,
    iwdesMax
};

//
// LDAP server name properties
//
enum {
    ildapcPR_WAB_LDAP_SERVER,
    ildapcMax
};


//
// Properties to get for each container in a Resolve
//
enum {
    irnPR_OBJECT_TYPE = 0,
    irnPR_WAB_RESOLVE_FLAG,
    irnPR_ENTRYID,
    irnPR_DISPLAY_NAME,
    irnMax
};

//
// container default properties
// Put essential props first
//
enum {
    ivPR_DISPLAY_NAME,
    ivPR_SURNAME,
    ivPR_GIVEN_NAME,
    ivPR_OBJECT_TYPE,
    ivPR_EMAIL_ADDRESS,
    ivPR_ADDRTYPE,
    ivPR_CONTACT_EMAIL_ADDRESSES,
    ivPR_CONTACT_ADDRTYPES,
    ivPR_MIDDLE_NAME,
    ivPR_COMPANY_NAME,
    ivPR_NICKNAME,
    ivMax
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

// enum for getting the entryid of an entry
enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidMax
};


enum {
    itcPR_ADDRTYPE = 0,
    itcPR_DISPLAY_NAME,
    itcPR_DISPLAY_TYPE,
    itcPR_ENTRYID,
    itcPR_INSTANCE_KEY,
    itcPR_OBJECT_TYPE,
    itcPR_EMAIL_ADDRESS,
    itcPR_RECORD_KEY,
    itcPR_NICKNAME,
    //itcPR_WAB_THISISME,
    itcMax
};



#ifndef _GLOBALS_C
#define ExternSizedSPropTagArray(_ctag, _name) \
extern const struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name


ExternSizedSPropTagArray(ircMax, ITableColumnsRoot);
ExternSizedSPropTagArray(irdMax, ptaResolveDefaults);
ExternSizedSPropTagArray(itcMax, ITableColumns);
ExternSizedSPropTagArray(iwdesMax, tagaDLEntriesProp);
ExternSizedSPropTagArray(ildapcMax, ptaLDAPCont);
ExternSizedSPropTagArray(irnMax, irnColumns);
ExternSizedSPropTagArray(ivMax, tagaValidate);
ExternSizedSPropTagArray(icrMax, ptaCreate);
ExternSizedSPropTagArray(ieidMax, ptaEid);

// [PaulHi] 2/25/99  ANSI versions
ExternSizedSPropTagArray(itcMax, ITableColumns_A);

#endif

extern const ULONG rgIndexArray[indexMax];
extern const int lprgAddrBookColHeaderIDs[NUM_COLUMNS];
//extern HANDLE hMuidMutex;

// External memory allocators (passed in on WABOpenEx)
extern int g_nExtMemAllocCount;
extern ALLOCATEBUFFER * lpfnAllocateBufferExternal;
extern ALLOCATEMORE * lpfnAllocateMoreExternal;
extern FREEBUFFER * lpfnFreeBufferExternal;
extern LPUNKNOWN pmsessOutlookWabSPI;
extern LPWABOPENSTORAGEPROVIDER lpfnWABOpenStorageProvider;

// registry key constants
extern LPCTSTR lpNewWABRegKey;
extern LPCTSTR lpRegUseOutlookVal;


/*
- The following IDs and tags are for the conferencing named properties
-
-   The GUID for these props is PS_Conferencing
-   This GUID is actually the same GUID used by outlook internally for 
-   it's named properties.
*/
DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);

enum _ConferencingTags
{
    prWABConfServers = 0,
    prWABConfDefaultIndex,
    prWABConfBackupIndex,
    prWABConfEmailIndex,
    prWABConfMax
};

#define CONF_SERVERS        0x8056
#define CONF_DEFAULT_INDEX  0x8057
#define CONF_SERVER_INDEX   0x8058
#define CONF_EMAIL_INDEX    0x8059

#define OLK_NAMEDPROPS_START CONF_SERVERS

ULONG PR_WAB_CONF_SERVERS;      // Multivalued String property that saves unique server related data
ULONG PR_WAB_CONF_DEFAULT_INDEX;// Points to which entry in the SERVERS prop is the default
ULONG PR_WAB_CONF_BACKUP_INDEX; // Points to which entry is the Backup
ULONG PR_WAB_CONF_EMAIL_INDEX;  // NOT USED anymore

SizedSPropTagArray(prWABConfMax, ptaUIDetlsPropsConferencing);

/*
- The following IDs and tags are for the Yomigana named properties
-
-   The GUID for these props is PS_YomiProps (which is again the same
-   guid as the one used by Outlook)
*/
#define PS_YomiProps    PS_Conferencing

#define dispidYomiFirstName     0x802C
#define dispidYomiLastName      0x802D
#define dispidYomiCompanyName   0x802E

#define OLK_YOMIPROPS_START dispidYomiFirstName

enum _YomiTags
{
    prWABYomiFirst = 0,
    prWABYomiLast,
    prWABYomiCompany,
    prWABYomiMax
};

ULONG PR_WAB_YOMI_FIRSTNAME;    // PT_TSTRING
ULONG PR_WAB_YOMI_LASTNAME;     // PT_TSTRING
ULONG PR_WAB_YOMI_COMPANYNAME;  // PT_TSTRING

/*
- The following IDs and tags are for defining the default Mailing Address
-
-   The GUID for these props is PS_PostalAddressID (which is the same as
-   the Outlook GUID)
*/
#define PS_PostalAddressID    PS_Conferencing

#define dispidPostalAddressId   0x8022

#define OLK_POSTALID_START dispidPostalAddressId

enum _PostalIDTags
{
    prWABPostalID = 0,
    prWABPostalMax
};

ULONG PR_WAB_POSTALID; // PT_LONG

// The values for the default Postal ID can only be one of the following
//
enum _PostalIDVal
{
    ADDRESS_NONE = 0, 
    ADDRESS_HOME, 
    ADDRESS_WORK, 
    ADDRESS_OTHER
};


/*
- The following IDs and tags are for the internally used WAB
-
-   The GUID for these props is MPSWab_GUID_V4
*/
ULONG PR_WAB_USER_PROFILEID;        // PT_TSTRING:  Profile ID of a user
ULONG PR_WAB_USER_SUBFOLDERS;       // PT_MVBINARY: List of subfolders that belong to a particular user
ULONG PR_WAB_HOTMAIL_CONTACTIDS;    // PT_MVTSTRING:IDs of Contacts as represented on the Hotmail Server 
ULONG PR_WAB_HOTMAIL_MODTIMES;      // PT_MV_TSTRING: Last modification time for the entry
ULONG PR_WAB_HOTMAIL_SERVERIDS;     // PT_MV_TSTRING: Identifies the Hotmail server
ULONG PR_WAB_DL_ONEOFFS;            // PT_MV_BINARY:Prop used for storing one-off entries as part of a DL
ULONG PR_WAB_IPPHONE;               // PT_TSTRING: Prop used for holding the IP_PHONE property (used to make TAPI happy)
ULONG PR_WAB_FOLDER_PARENT;         // PT_BINARY: EID of the Folder to which a contact belongs
ULONG PR_WAB_SHAREDFOLDER;          // PT_LONG:   BOOL that determines if a subfolder is shared or not
ULONG PR_WAB_FOLDEROWNER;           // PT_TSTRING: String containing GUID of user who creates a folder ..

#define FOLDER_PRIVATE          0x00000000 // values for PR_WAB_SHAREDFOLDER
#define FOLDER_SHARED           0x00000001

#define USER_PROFILEID          0X8001
#define USER_SUBFOLDERS         0x8002
#define HOTMAIL_CONTACTIDS      0x8003
#define HOTMAIL_MODTIMES        0x8004
#define HOTMAIL_SERVERIDS       0x8005
#define DL_ONEOFFS              0x8006
#define IPPHONE                 0x8007
#define FOLDERPARENT            0x8008
#define SHAREDFOLDER            0x8009
#define FOLDEROWNER             0x800a

#define WAB_NAMEDPROPS_START    USER_PROFILEID

enum _UserTags
{
    prWABUserProfileID = 0,
    prWABUserSubfolders,
    prWABHotmailContactIDs,
    prWABHotmailModTimes,
    prWABHotmailServerIDs,
    prWABDLOneOffs,
    prWABIPPhone,
    prWABFolderParent,
    prWABSharedFolder,
    prWABFolderOwner,
    prWABUserMax
};

/* MouseWheel support for Win95 */
UINT g_msgMSWheel;

/*
- These are used for customizing the WAB columns */
ULONG PR_WAB_CUSTOMPROP1;
ULONG PR_WAB_CUSTOMPROP2;
TCHAR szCustomProp1[MAX_PATH];
TCHAR szCustomProp2[MAX_PATH];
// registry names
extern LPTSTR szPropTag1;
extern LPTSTR szPropTag2;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\globals.c ===
/*
 *      GLOBALS.C
 *
 *      Global constant structures
 *
 */

#define _GLOBALS_C
#include "_apipch.h"

// Columns of the Root Contents Table
//
const SizedSPropTagArray(ircMax, ITableColumnsRoot) = {
    ircMax,                             // count of entries
    {
        PR_DISPLAY_NAME,
        PR_DISPLAY_TYPE,
        PR_ENTRYID,
        PR_INSTANCE_KEY,
        PR_OBJECT_TYPE,
        PR_RECORD_KEY,
        PR_ROWID,
        PR_DEPTH,
        PR_CONTAINER_FLAGS,
        PR_AB_PROVIDER_ID,
        PR_WAB_LDAP_SERVER,
        PR_WAB_RESOLVE_FLAG,
    }


};

//
// Default set of properties to return from a ResolveNames.
// May be overridden by passing in lptagaColSet to ResolveNames.
//
const SizedSPropTagArray(irdMax, ptaResolveDefaults)=
{
    irdMax,
    {
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        PR_RECORD_KEY,
        PR_SEARCH_KEY,
        PR_SURNAME,
        PR_GIVEN_NAME,
        PR_INSTANCE_KEY,
        PR_SEND_INTERNET_ENCODING
    }
};

// default set of regular table columns
//
const SizedSPropTagArray(itcMax, ITableColumns) = {
    itcMax,                             // count of entries
    {
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_DISPLAY_TYPE,
        PR_ENTRYID,
        PR_INSTANCE_KEY,
        PR_OBJECT_TYPE,
        PR_EMAIL_ADDRESS,
        PR_RECORD_KEY,
        PR_NICKNAME,
        //PR_WAB_THISISME
    }
};

// [PaulHi] 2/25/99 ANSI version of ITableColumns
const SizedSPropTagArray(itcMax, ITableColumns_A) =
{
    itcMax,
    {
        PR_ADDRTYPE_A,
        PR_DISPLAY_NAME_A,
        PR_DISPLAY_TYPE,
        PR_ENTRYID,
        PR_INSTANCE_KEY,
        PR_OBJECT_TYPE,
        PR_EMAIL_ADDRESS_A,
        PR_RECORD_KEY,
        PR_NICKNAME_A,
        //PR_WAB_THISISME
    }
};


const SizedSPropTagArray(iwdesMax, tagaDLEntriesProp) =
{
    iwdesMax,
    {
        PR_WAB_DL_ENTRIES,
    }
};


const SizedSPropTagArray(ildapcMax, ptaLDAPCont) =
{
  ildapcMax,
  {
    PR_WAB_LDAP_SERVER
  }
};


//
// Properties to get for each container in a Resolve
//
const SizedSPropTagArray(irnMax, irnColumns) =
{
    irnMax,
    {
        PR_OBJECT_TYPE,
        PR_WAB_RESOLVE_FLAG,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};

//
// container default properties
// Put essential props first
//
const SizedSPropTagArray(ivMax, tagaValidate) = {
	ivMax,
   {
       PR_DISPLAY_NAME,
       PR_SURNAME,
       PR_GIVEN_NAME,
       PR_OBJECT_TYPE,
       PR_EMAIL_ADDRESS,
       PR_ADDRTYPE,
       PR_CONTACT_EMAIL_ADDRESSES,
       PR_CONTACT_ADDRTYPES,
       PR_MIDDLE_NAME,
       PR_COMPANY_NAME,
       PR_NICKNAME
	}
};

// Default creation templates for the WAB
//
const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};

const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
    }
};



//
// IMPORTANT NOTE: If you change this array, you must change
//  _IndexType in mpswab.h to match!
//
// This is the set of Indexes from the WAB Data store and is closely
//  tied to the physical layout of data in the WAB store - therefore 
//  *Do NOT* modify this array 
//
const ULONG rgIndexArray[indexMax] =
    {
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_SURNAME,
        PR_GIVEN_NAME,
        PR_EMAIL_ADDRESS,
        PR_NICKNAME,
    };


//
// IMPORTANT NOTE: If you change this, you must change _AddrBookColumns in uimisc.h!
//
const int lprgAddrBookColHeaderIDs[NUM_COLUMNS] =
{
    idsColDisplayName,
    idsColEmailAddress,
    idsColOfficePhone,
    idsColHomePhone
};


// External memory allocators (passed in on WABOpenEx)
int g_nExtMemAllocCount = 0;
ALLOCATEBUFFER * lpfnAllocateBufferExternal = NULL;
ALLOCATEMORE * lpfnAllocateMoreExternal = NULL;
FREEBUFFER * lpfnFreeBufferExternal = NULL;
LPUNKNOWN pmsessOutlookWabSPI = NULL;

LPWABOPENSTORAGEPROVIDER lpfnWABOpenStorageProvider = NULL;

// for registry property tags
LPTSTR szPropTag1 =  TEXT("PropTag1");
LPTSTR szPropTag2 =  TEXT("PropTag2");

// registry key constants
LPCTSTR lpNewWABRegKey = TEXT("Software\\Microsoft\\WAB\\WAB4");
LPCTSTR lpRegUseOutlookVal = TEXT("UseOutlook");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\hotsync.c ===
//  
//  HotSync.c
//
//  Contains code to synchronize addresses and groups with
//  HotMail servers
//

#define COBJMACROS
#include <_apipch.h>
#include <wab.h>
#define COBJMACROS
#include "HotSync.h"
#include "iso8601.h"
#include "uimisc.h"
#include "ui_cflct.h"
#include "ui_pwd.h"
#include "useragnt.h"

typedef enum {
    CIS_STRING = 0,
    CIS_BOOL,
    CIS_DWORD
}CIS_TYPE;

typedef struct CONTACTINFO_STRUCTURE
{
    CIS_TYPE    tType;
    DWORD       dwOffset;
}CONTACTINFO_STRUCTURE;

enum {
    idcisHref = 0,
    idcisId,
    idcisType,
    idcisModified,
    idcisDisplayName,
    idcisGivenName,
    idcisSurname,
    idcisNickName,
    idcisEmail,
    idcisHomeStreet,
    idcisHomeCity, 
    idcisHomeState, 
    idcisHomePostalCode, 
    idcisHomeCountry, 
    idcisCompany, 
    idcisWorkStreet, 
    idcisWorkCity, 
    idcisWorkState, 
    idcisWorkPostalCode, 
    idcisWorkCountry, 
    idcisHomePhone, 
    idcisHomeFax, 
    idcisWorkPhone, 
    idcisWorkFax, 
    idcisMobilePhone, 
    idcisOtherPhone, 
    idcisBday,
    idcisPager
};

CONTACTINFO_STRUCTURE   g_ContactInfoStructure[] = 
{
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHref)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszId)}, 
    {CIS_DWORD,  offsetof(HTTPCONTACTINFO, tyContact)},
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszModified)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszDisplayName)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszGivenName)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszSurname)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszNickname)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszEmail)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeStreet)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeCity)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeState)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomePostalCode)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeCountry)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszCompany)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkStreet)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkCity)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkState)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkPostalCode)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkCountry)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomePhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszHomeFax)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkPhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszWorkFax)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszMobilePhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszOtherPhone)}, 
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszBday)},
    {CIS_STRING, offsetof(HTTPCONTACTINFO, pszPager)}
};

#define CIS_FIRST_DATA_FIELD    5

#define CIS_GETSTRING(pci, i)  (*((char **)(&((char *)pci)[g_ContactInfoStructure[i].dwOffset])))
#define CIS_GETTYPE(i)         (g_ContactInfoStructure[i].tType)

IHTTPMailCallbackVtbl vtblIHTTPMAILCALLBACK = {
    VTABLE_FILL
    WABSync_QueryInterface,
    WABSync_AddRef,
    WABSync_Release,
    WABSync_OnTimeout,
    WABSync_OnLogonPrompt,
    WABSync_OnPrompt,
    WABSync_OnStatus,
    WABSync_OnError,
    WABSync_OnCommand,
    WABSync_OnResponse,
    WABSync_GetParentWindow
};



enum {
    ieid_PR_DISPLAY_NAME = 0,
    ieid_PR_OBJECT_TYPE,
    ieid_PR_ENTRYID,
	ieid_PR_LAST_MODIFICATION_TIME,
	ieid_PR_WAB_HOTMAIL_CONTACTIDS,
	ieid_PR_WAB_HOTMAIL_SERVERIDS,
	ieid_PR_WAB_HOTMAIL_MODTIMES,
    ieid_Max
};

static SizedSPropTagArray(ieid_Max, ptaEidSync)=
{
    ieid_Max,
    {
        PR_DISPLAY_NAME,
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_LAST_MODIFICATION_TIME,
        PR_ENTRYID,
        PR_ENTRYID,
        PR_ENTRYID
    }
};

enum {
    ieidc_PR_DISPLAY_NAME = 0,
    ieidc_PR_OBJECT_TYPE,
    ieidc_PR_ENTRYID,
	ieidc_PR_LAST_MODIFICATION_TIME,
    ieidc_PR_GIVEN_NAME,
    ieidc_PR_SURNAME,
    ieidc_PR_NICKNAME,
    ieidc_PR_EMAIL_ADDRESS,
    ieidc_PR_HOME_ADDRESS_STREET,
    ieidc_PR_HOME_ADDRESS_CITY,
    ieidc_PR_HOME_ADDRESS_STATE_OR_PROVINCE,
    ieidc_PR_HOME_ADDRESS_POSTAL_CODE,
    ieidc_PR_HOME_ADDRESS_COUNTRY,
    ieidc_PR_COMPANY_NAME,
    ieidc_PR_BUSINESS_ADDRESS_STREET,
    ieidc_PR_BUSINESS_ADDRESS_CITY,
    ieidc_PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
    ieidc_PR_BUSINESS_ADDRESS_POSTAL_CODE,
    ieidc_PR_BUSINESS_ADDRESS_COUNTRY,
    ieidc_PR_HOME_TELEPHONE_NUMBER,
    ieidc_PR_HOME_FAX_NUMBER,
    ieidc_PR_BUSINESS_TELEPHONE_NUMBER,
    ieidc_PR_BUSINESS_FAX_NUMBER,
    ieidc_PR_MOBILE_TELEPHONE_NUMBER,
    ieidc_PR_OTHER_TELEPHONE_NUMBER,
    ieidc_PR_BIRTHDAY,
    ieidc_PR_PAGER,
    ieidc_PR_CONTACT_EMAIL_ADDRESSES,
    ieidc_PR_CONTACT_DEFAULT_ADDRESS_INDEX,
#ifdef HM_GROUP_SYNCING
    ieidc_PR_WAB_DL_ENTRIES,
    ieidc_PR_WAB_DL_ONEOFFS,
#endif
	ieidc_PR_WAB_HOTMAIL_CONTACTIDS,
	ieidc_PR_WAB_HOTMAIL_SERVERIDS,
	ieidc_PR_WAB_HOTMAIL_MODTIMES,
    ieidc_Max
};

static SizedSPropTagArray(ieidc_Max, ptaEidCSync)=
{
    ieidc_Max,
    {
        PR_DISPLAY_NAME,
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_LAST_MODIFICATION_TIME,
        PR_GIVEN_NAME,
        PR_SURNAME,
        PR_NICKNAME,
        PR_EMAIL_ADDRESS,
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_COUNTRY,
        PR_COMPANY_NAME,
        PR_BUSINESS_ADDRESS_STREET,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_MOBILE_TELEPHONE_NUMBER,
        PR_OTHER_TELEPHONE_NUMBER,
        PR_BIRTHDAY,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
#ifdef HM_GROUP_SYNCING
        PR_WAB_DL_ENTRIES,
        PR_ENTRYID,
#endif
        PR_ENTRYID,
        PR_ENTRYID,
        PR_ENTRYID,
    }
};

// HM Nickname invalid characters
const ULONG MAX_INVALID_ARRAY_INDEX = 123;
static BOOL bInvalidCharArray[] = 
{
    TRUE,           // 0
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,           // 9
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,           // 19
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,
    TRUE,           // 29
    TRUE,
    TRUE,
    TRUE,           // 32 (x20) Space
    TRUE,           //          !
    TRUE,           //          "
    TRUE,           //          #
    TRUE,           //          $
    TRUE,           //          %
    TRUE,           //          &
    TRUE,           //          '
    TRUE,           //          (
    TRUE,           //          )
    TRUE,           // 42       *
    TRUE,           //          +
    TRUE,           //          ,
    TRUE,           //          -
    TRUE,           //          .
    TRUE,           //          /
    FALSE,          //          0
    FALSE,          //          1
    FALSE,          //          2
    FALSE,          //          3
    FALSE,          // 52       4
    FALSE,          //          5
    FALSE,          //          6
    FALSE,          //          7
    FALSE,          //          8
    FALSE,          //          9
    TRUE,           //          :
    TRUE,           //          ;
    TRUE,           //          <
    TRUE,           //          =
    TRUE,           // 62       >
    TRUE,           //          ?
    TRUE,           //          @
    FALSE,          //          A
    FALSE,          //          B
    FALSE,          //          C
    FALSE,          //          D
    FALSE,          //          E
    FALSE,          //          F
    FALSE,          //          G
    FALSE,          // 72       H
    FALSE,          //          I
    FALSE,          //          J
    FALSE,          //          K
    FALSE,          //          L
    FALSE,          //          M
    FALSE,          //          N
    FALSE,          //          O
    FALSE,          //          P
    FALSE,          //          Q
    FALSE,          // 82       R
    FALSE,          //          S
    FALSE,          //          T
    FALSE,          //          U
    FALSE,          //          V
    FALSE,          //          W
    FALSE,          //          X
    FALSE,          //          Y
    FALSE,          //          Z
    TRUE,           //          [
    TRUE,           // 92       '\'
    TRUE,           //          ]
    TRUE,           //          ^
    FALSE,          //          _
    TRUE,           //          `
    FALSE,          //          a
    FALSE,          //          b
    FALSE,          //          c
    FALSE,          //          d
    FALSE,          //          e
    FALSE,          // 102      f
    FALSE,          //          g
    FALSE,          //          h
    FALSE,          //          i
    FALSE,          //          j
    FALSE,          //          k
    FALSE,          //          l
    FALSE,          //          m
    FALSE,          //          n
    FALSE,          //          o
    FALSE,          // 112      p
    FALSE,          //          q
    FALSE,          //          r
    FALSE,          //          s
    FALSE,          //          t
    FALSE,          //          u
    FALSE,          //          v
    FALSE,          //          w
    FALSE,          //          x
    FALSE,          //          y
    FALSE,          // 122      z
};

extern HRESULT InitUserIdentityManager(LPIAB lpIAB, IUserIdentityManager ** lppUserIdentityManager);

// Address Book Sync Window Class Name
LPTSTR g_lpszSyncKey = TEXT("Software\\Microsoft\\WAB\\Synchronization\\");

LPTSTR g_szSyncClass =  TEXT("WABSyncView");
extern VOID CenterDialog(HWND hwndDlg);

#define WM_SYNC_NEXTSTATE           (WM_USER + 4)
#define WM_SYNC_NEXTOP              (WM_USER + 5)
#define SafeCoMemFree(_pv) \
    if (_pv) { \
        CoTaskMemFree(_pv); \
        _pv = NULL; \
    } \
    else 


#ifdef HM_GROUP_SYNCING
HRESULT HrSynchronize(HWND hWnd, LPADRBOOK lpIAB, LPCTSTR pszAccountID, BOOL bSyncGroups)
#else
HRESULT HrSynchronize(HWND hWnd, LPADRBOOK lpIAB, LPCTSTR pszAccountID)
#endif
{
    HRESULT hr;
    LPWABSYNC   pWabSync = NULL;

//    if (!bIsThereACurrentUser((LPIAB)lpIAB))
//        return E_FAIL;

    // [PaulHi] Raid 62149  Check to see if user is connected
    {
        DWORD   dwConnectedState;
        TCHAR   tszCaption[256];
        TCHAR   tszMessage[256];

        if ( !InternetGetConnectedState(&dwConnectedState, 0) || (dwConnectedState & INTERNET_CONNECTION_OFFLINE) )
        {
            LoadString(hinstMapiX, idsSyncError, tszCaption, CharSizeOf(tszCaption));
            if (dwConnectedState & INTERNET_CONNECTION_OFFLINE)
                LoadString(hinstMapiX, idsOffline, tszMessage, CharSizeOf(tszMessage));
            else
                LoadString(hinstMapiX, idsNoInternetConnect, tszMessage, CharSizeOf(tszMessage));
            MessageBox(hWnd, tszMessage, tszCaption, MB_ICONEXCLAMATION | MB_OK);

            return E_FAIL;
        }
    }

    // Create the wab sync object
    hr = WABSync_Create(&pWabSync);
    if (FAILED(hr))
        goto exit;
    // initializing it kicks off the whole process
#ifdef HM_GROUP_SYNCING
    // [PaulHi] 2/22/99  Hotmail syncing is now done in two passes.  The first pass is
    // as before and synchronizes the normal email contacts.  The second pass synchronizes
    // the group contacts.  Group contacts contain references to email contacts so email
    // contacts must be completely synchronized before groups can be synchronized.
    hr = WABSync_Initialize(pWabSync, hWnd, lpIAB, pszAccountID, bSyncGroups);
#else
    hr = WABSync_Initialize(pWabSync, hWnd, lpIAB, pszAccountID);
#endif

exit:
    WABSync_Release((IHTTPMailCallback*)pWabSync);

    return hr;
}

static LPSTR _StrDup(LPCSTR pszStr)
{
  	LPMALLOC	lpMalloc;
    LPSTR       pszResult = NULL;
    
    if (!pszStr)
        return NULL;

    CoGetMalloc(MEMCTX_TASK, &lpMalloc);
    if (lpMalloc)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        pszResult = (LPSTR) lpMalloc->lpVtbl->Alloc(lpMalloc, cchSize * sizeof(pszResult[0]));

        if (pszResult)
            StrCpyNA(pszResult, pszStr, cchSize);
        lpMalloc->lpVtbl->Release(lpMalloc);
    }

    return pszResult;
}

void _FixHotmailDate(LPSTR pszDate)
{
    if (!pszDate)
        return;

    while (*pszDate)
    {
        if (*pszDate == 'T')
        {
            *pszDate = 0;
            break;
        }

        if (*pszDate == '.')
            *pszDate = '-';

        pszDate++;
    }
}

BOOL    LogTransactions(LPWABSYNC pWabSync)
{
    BOOL fInit = FALSE, fLogging = FALSE;
    LPTSTR  pszLogKey = TEXT("Software\\Microsoft\\Outlook Express\\5.0\\Mail");
    LPTSTR  pszLogValue = TEXT("Log HTTPMail (0/1)");
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    HRESULT hr;
    HKEY hkeyIdentity = NULL, hkeyLog = NULL;
    DWORD   dwValue, dwType, dwSize;

    if(!bIsWABSessionProfileAware((LPIAB)(pWabSync->m_pAB)))
        goto exit;

    if(HR_FAILED(hr = InitUserIdentityManager((LPIAB)(pWabSync->m_pAB), &lpUserIdentityManager)))
        goto exit;
    
    fInit = TRUE;

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, 
                                                                        (GUID *)&UID_GIBC_CURRENT_USER,
                                                                        &lpUserIdentity)))
        goto exit;

    if (HR_FAILED(hr = lpUserIdentity->lpVtbl->OpenIdentityRegKey(lpUserIdentity, 
                                                                KEY_READ, &hkeyIdentity)))
        goto exit;
    
    if (RegOpenKeyEx(hkeyIdentity, pszLogKey, 0, KEY_READ, &hkeyLog) != ERROR_SUCCESS)
        goto exit;

    dwSize = sizeof(DWORD);

    if (RegQueryValueEx(hkeyLog, pszLogValue, NULL, &dwType, (LPBYTE) &dwValue, &dwSize) != ERROR_SUCCESS)
        goto exit;

    fLogging = (dwValue == 1);
exit:
    if(fInit)
        UninitUserIdentityManager((LPIAB)(pWabSync->m_pAB));

    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    if (hkeyLog)
        RegCloseKey(hkeyLog);

    if (hkeyIdentity)
        RegCloseKey(hkeyIdentity);
    
    return fLogging;
}

DWORD   CountHTTPMailAccounts(LPIAB lpIAB)
{
    IImnAccountManager2 *lpAcctMgr;
    IImnEnumAccounts *pEnumAccts = NULL;
    DWORD dwCount = 0;
    HRESULT hr;

    if (FAILED(hr = InitAccountManager(lpIAB, &lpAcctMgr, NULL)) || NULL == lpAcctMgr)
        goto exit;

    if (FAILED(hr = lpAcctMgr->lpVtbl->Enumerate(lpAcctMgr, SRV_HTTPMAIL,&pEnumAccts)))
        goto exit;

    if (FAILED(hr = pEnumAccts->lpVtbl->GetCount(pEnumAccts, &dwCount)))
        dwCount = 0;

exit:
    if( pEnumAccts)
        pEnumAccts->lpVtbl->Release(pEnumAccts);

    return dwCount;
}

HRESULT _FindHTTPMailAccount(HWND hwnd, IImnAccountManager2 *lpAcctMgr, LPSTR pszAcctName, ULONG ccb)
{
    IImnEnumAccounts *pEnumAccts = NULL;
    DWORD dwCount = 0;
    IImnAccount *pAccount = NULL;
    HRESULT hr;

    Assert(lpAcctMgr);

    if (FAILED(hr = lpAcctMgr->lpVtbl->Enumerate(lpAcctMgr, SRV_HTTPMAIL,&pEnumAccts)))
        goto exit;

    if (FAILED(hr = pEnumAccts->lpVtbl->GetCount(pEnumAccts, &dwCount)) || dwCount == 0)
        goto exit;

    if (dwCount > 1)
    {
        if (!ChooseHotmailServer(hwnd, pEnumAccts, pszAcctName, ccb))
        {
            hr = E_UserCancel;
            goto exit;
        }
    }
    else
    {
        if (FAILED(hr = pEnumAccts->lpVtbl->GetNext(pEnumAccts, &pAccount)))
            goto exit;

        if (FAILED(hr = pAccount->lpVtbl->GetProp(pAccount, AP_ACCOUNT_ID, pszAcctName, &ccb)))
            goto exit;
    }
    
    hr = S_OK;
exit:
    if( pAccount)
        pAccount->lpVtbl->Release(pAccount);

    if( pEnumAccts)
        pEnumAccts->lpVtbl->Release(pEnumAccts);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  HrMakeContactId
//
//  Helper function to convert ANSI strings and create UNICODE contact ID
//  string.
///////////////////////////////////////////////////////////////////////////////
HRESULT hrMakeContactId(
    LPTSTR  lptszContactId,     // [out]
    int     nCharNum,           // [in]
    LPCTSTR lptcszProfileId,    // [in]
    LPCSTR  lpcszAccountId,     // [in]
    LPCSTR  lpcszLoginName)     // [in]
{
    HRESULT hr = S_OK;
    LPWSTR  lpwszAccountId = NULL;
    LPWSTR  lpwszLoginName = NULL; 

    // Validate arguments
    if ( !lptszContactId ||
         !lptcszProfileId ||
         !lpcszAccountId ||
         !lpcszLoginName)
    {
        Assert(0);
        return ERROR_INVALID_PARAMETER;
    }

    // Check buffer size.  Account for the two extra '-' characters.
    if ( nCharNum <= (lstrlen(lptcszProfileId) + lstrlenA(lpcszAccountId) + lstrlenA(lpcszLoginName) + 2) )
    {
        Assert(0);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    lpwszAccountId = ConvertAtoW(lpcszAccountId);
    lpwszLoginName = ConvertAtoW(lpcszLoginName);

    if (!lpwszAccountId || !lpwszLoginName)
    {
        Assert(0);
        hr = E_FAIL;
    }
    else
    {
        wnsprintf(lptszContactId, nCharNum, TEXT("%s-%s-%s"), lptcszProfileId, lpwszAccountId, lpwszLoginName);
    }
    
    LocalFreeAndNull(&lpwszAccountId);
    LocalFreeAndNull(&lpwszLoginName);

    return hr;
}


#ifdef HM_GROUP_SYNCING
///////////////////////////////////////////////////////////////////////////////
//  hrAppendName
//
//  Helper function to take a double byte name string, converts it to single
//  byte and appends it to the given name string, using ',' as the delimiter.
//  The name string pointer will be allocated and reallocated as needed.  The 
//  caller is responible for freeing the name string with CoTaskMemFree().
//
//  Parameters
//  [IN/OUT] lpszNameString - name string pointer
//  [IN]     ulCharCount - current name string size in char
//  [IN]     double byte character string to append
///////////////////////////////////////////////////////////////////////////////
LPCSTR lpszDelimiter = ",";

ULONG ulAppendName(
    LPSTR * lppszNameString,
    ULONG   ulCharCount,
    LPCTSTR lptszName)
{
    ULONG   ulLen = 0;
    ULONG   ulNewLen = 0;
    ULONG   ulNew = ulCharCount;
    LPSTR   lpszTemp = NULL;

    Assert(lppszNameString);
    Assert(lptszName);

    // Check size of new string
    ulNewLen = (ULONG)lstrlen(lptszName) + 2;  // Include delimiter character and termination
    if (*lppszNameString)
        ulLen = ulNewLen + (ULONG)lstrlenA(*lppszNameString);
    else
        ulLen = ulNewLen;
    if (ulLen > ulCharCount)
    {
        ulNew = (ulNewLen > MAX_PATH) ? (ulCharCount+ulNewLen+MAX_PATH) : (ulCharCount+MAX_PATH);
        lpszTemp = CoTaskMemAlloc(ulNew * sizeof(WCHAR));
        if (!lpszTemp)
        {
            Assert(0);
            goto error_out;
        }
        *lpszTemp = '\0';

        if (*lppszNameString)
        {
            StrCpyNA(lpszTemp, *lppszNameString, ulNew);
            CoTaskMemFree(*lppszNameString);
        }
        *lppszNameString = lpszTemp;
        ulCharCount = ulNew;
    }

    // Append new string name
    {
        LPSTR   lptsz = ConvertWtoA(lptszName);
        if (**lppszNameString != '\0')
            StrCatBuffA(*lppszNameString, lpszDelimiter, ulCharCount);
        StrCatBuffA(*lppszNameString, lptsz, ulCharCount);
        LocalFreeAndNull(&lptsz);
    }

    return ulNew;

error_out:
    
    // Error, return NULL string pointer
    if (*lppszNameString)
    {
        CoTaskMemFree(*lppszNameString);
        *lppszNameString = NULL;
    }
            
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
//  hrAppendGroupContact
//
//  Helper function to a group's PR_WAB_DL_ENTRIES and/or PR_WAB_DL_ONEOFFS
//  names and append to the given name string.  This name string is in the same
//  format as what is retrieved from a HotMail server, and is compared directly
//  with the corresponding HotMail group.  
//
//  a)  PR_WAB_DL_ENTRIES are WAB entry ID contacts that map to HM contacts
//      distinquished by nickname.
//  b)  PR_WAB_DL_ONEOFFS are WAB entry ID one-offs with user and email embedded
//      directly in the entry ID structure.
//
//  Parameters
//  [IN] pWabSync
//  [IN] ulPropTag
//  [IN] lpProp - Pointer to property struct
//  [IN/OUT] lppszHMEmailName - HM string with new names appended
//           !!NOTE that this needs to be freed by caller using CoMemTaskFree()!!
///////////////////////////////////////////////////////////////////////////////
HRESULT hrAppendGroupContact(
    LPWABSYNC    pWabSync,              // [IN]
    ULONG        ulPropTag,             // [IN]
    LPSPropValue lpProp,                // [IN]
    LPSTR *      lppszHMEmailName)      // [IN/OUT]
{
    HRESULT      hr = S_OK;
    LPSPropValue lpaProps = NULL;
    ULONG        ulcProps = 0;
    ULONG        ul;
    ULONG        ulCharSize = 0;

    Assert(pWabSync);
    Assert(lppszHMEmailName);
    Assert( (ulPropTag == PR_WAB_DL_ENTRIES) || (ulPropTag == PR_WAB_DL_ONEOFFS) );

    // Check each DL entry and check whether it is another WAB (mail user) contact
    // EID or a WAB One-Off email/name string EID.
    if (ulPropTag == PR_WAB_DL_ONEOFFS)
    {
        // Wab one-off is equivalent to a HM direct email name
        for (ul=0; ul<lpProp->Value.MVbin.cValues; ul++)
        {
            ULONG       cbEntryID = lpProp->Value.MVbin.lpbin[ul].cb;
            LPENTRYID   lpEntryID = (LPENTRYID)lpProp->Value.MVbin.lpbin[ul].lpb;
            BYTE        bType;
            LPTSTR      lptstrDisplayName, lptstrAddrType;
            LPTSTR      lptstrAddress = NULL;

            bType = IsWABEntryID(cbEntryID, lpEntryID, 
                        &lptstrDisplayName, 
                        &lptstrAddrType, 
                        &lptstrAddress, NULL, NULL);
            if (lptstrAddress)
            {
                // Append the one-off email name
                ulCharSize = ulAppendName(lppszHMEmailName, ulCharSize, lptstrAddress);
                if (ulCharSize == 0)
                {
                    hr = E_OUTOFMEMORY;
                    goto out;
                }
            }
            else
            {
                Assert(0);
            }
        }
    }
    else if (ulPropTag == PR_WAB_DL_ENTRIES)
    {
        // WAB mail user contact is equivalent to a HM contact
        for (ul=0; ul<lpProp->Value.MVbin.cValues; ul++)
        {
            HRESULT     hr;
            LPMAILUSER  lpMailUser;
            ULONG       ulObjectType;
            ULONG       cbEntryID = lpProp->Value.MVbin.lpbin[ul].cb;
            LPENTRYID   lpEntryID = (LPENTRYID)lpProp->Value.MVbin.lpbin[ul].lpb;

            hr = pWabSync->m_pAB->lpVtbl->OpenEntry(pWabSync->m_pAB, cbEntryID, lpEntryID, 
                NULL, 0, &ulObjectType, (LPUNKNOWN *)&lpMailUser);

            if (SUCCEEDED(hr))
            {
                LPSPropValue    lpaProps;
                ULONG           ulcProps;

                Assert(ulObjectType == MAPI_MAILUSER);

                // HM contacts are designated by the nickname field, so this is all
                // we need to append to the name string.
                hr = lpMailUser->lpVtbl->GetProps(lpMailUser, NULL, MAPI_UNICODE, &ulcProps, &lpaProps);
                if (SUCCEEDED(hr))
                {
                    ULONG   ulc;
                    LPCTSTR lptszNickname = NULL;
                    for (ulc=0; ulc<ulcProps; ulc++)
                    {
                        if (lpaProps[ulc].ulPropTag == PR_NICKNAME)
                            break;
                    }
                    if (ulc == ulcProps)
                    {
                        // No nickname.  This means that the preceeding contact sync has
                        // failed or not completed in some way.  Skip.
                        Assert(0);
                        continue;
                    }
                    else
                        lptszNickname = (LPCTSTR)lpaProps[ulc].Value.lpszW;

                    ulCharSize = ulAppendName(lppszHMEmailName, ulCharSize, lptszNickname);
                    if (ulCharSize == 0)
                    {
                        hr = E_OUTOFMEMORY;
                        goto out;
                    }
                }
            }
        }
    }
    else
    {
        // Trace("Unknown property tag type");
        Assert(0);
    }

out:

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  hrParseHMGroupEmail
//
//  Helper function to parse a HM group email string into nickname names 
//  (contacts) and email names (one-offs).  The name arrays are simply pointers
//  into the passed in email name string and so are valid as long at that 
//  input string is valid.  Note that this function modifies the input string
//  lptszEmailName.
//
//  Parameters
//  [IN]  lptszEmailName - email string to parse
//  [OUT] patszContacts - array of parsed contact (nickname) names if requested
//  [OUT] pcContacts - number of contact names
//  [OUT] patszOneOffs - array of parsed one-off (email) names if requested
//  [OUT] pcOneOffs - number of one-off names
///////////////////////////////////////////////////////////////////////////////
// It looks like HM allows four possible text delimiters: ' ', ',', ';', '+'
const TCHAR tszSpace[] = TEXT(" ");
const TCHAR tszComma[] = TEXT(",");
const TCHAR tszSemi[] = TEXT(";");
const TCHAR tszPlus[] = TEXT("+");
const TCHAR tszAt[] = TEXT("@");

HRESULT hrParseHMGroupEmail(
    LPTSTR     lptszEmailName,
    LPTSTR **  patszContacts,
    ULONG *    pcContacts,
    LPTSTR **  patszOneOffs,
    ULONG *    pcOneOffs)
{
    HRESULT     hr = S_OK;
    ULONG       cCount = 1;
    ULONG       ul;
    LPTSTR      lptszTemp = lptszEmailName;
    LPTSTR *    atszContacts = NULL;
    LPTSTR *    atszOneOffs = NULL;
    ULONG       cContacts = 0;
    ULONG       cOneOffs = 0;

    Assert( lptszEmailName && (pcContacts || pcOneOffs) );

    // Strip all leading and ending spaces
    TrimSpaces(lptszTemp);

    // Count
    while (*lptszTemp)
    {
        if ( ((*lptszTemp) == (*tszSpace)) ||
             ((*lptszTemp) == (*tszComma)) ||
             ((*lptszTemp) == (*tszSemi)) ||
             ((*lptszTemp) == (*tszPlus)) )
        {
            ++cCount;

            // Increment to next valid name
            ++lptszTemp;
            while ( ((*lptszTemp) == (*tszSpace)) ||
                    ((*lptszTemp) == (*tszComma)) ||
                    ((*lptszTemp) == (*tszSemi)) ||
                    ((*lptszTemp) == (*tszPlus)) )
            {
                ++lptszTemp;
            }
        }
        else
            ++lptszTemp;
    }

    // Create Contacts and One-Offs name pointer arrays
    atszContacts = LocalAlloc(LMEM_ZEROINIT, (cCount * sizeof(LPTSTR)));
    if (!atszContacts)
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }
    atszOneOffs = LocalAlloc(LMEM_ZEROINIT, (cCount * sizeof(LPTSTR)));
    if (!atszOneOffs)
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    // Fill the name pointer arrays and counts
    {
        LPTSTR  lptszName = lptszEmailName;
        BOOL    fIsEmail = FALSE;
        
        lptszTemp = lptszName;
        while(*lptszTemp)
        {
            // Determine whether this name is a nickname or email.  I am assuning
            // that all email names will have the '@' character.
            if ((*lptszTemp) == (*tszAt))
                fIsEmail = TRUE;

            if ( ((*lptszTemp) == (*tszSpace)) ||
                 ((*lptszTemp) == (*tszComma)) ||
                 ((*lptszTemp) == (*tszSemi)) ||
                 ((*lptszTemp) == (*tszPlus)) )
            {
                *lptszTemp = '\0';
                ++lptszTemp;

                if (fIsEmail)
                {
                    atszOneOffs[cOneOffs++] = lptszName;
                    Assert(cOneOffs <= cCount);
                    fIsEmail = FALSE;
                }
                else
                {
                    atszContacts[cContacts++] = lptszName;
                    Assert(cContacts <= cCount);
                }

                // Increment to next valid name
                while ( ((*lptszTemp) == (*tszSpace)) ||
                        ((*lptszTemp) == (*tszComma)) ||
                        ((*lptszTemp) == (*tszSemi)) ||
                        ((*lptszTemp) == (*tszPlus)) )
                {
                    ++lptszTemp;
                }

                lptszName = lptszTemp;
            }
            else
                ++lptszTemp;
        }
        // Pick up last item
        if (*lptszName)
        {
            if (fIsEmail)
            {
                atszOneOffs[cOneOffs++] = lptszName;
                Assert(cOneOffs <= cCount);
            }
            else
            {
                atszContacts[cContacts++] = lptszName;
                Assert(cContacts <= cCount);
            }
        }
    }

    // Pass back contact name array if requested
    if (cContacts && pcContacts)
    {
        *pcContacts = cContacts;
    }
    if (patszContacts)
        (*patszContacts) = atszContacts;

    // Pass back one-off name array if requested
    if (cOneOffs && pcOneOffs )
    {
        *pcOneOffs = cOneOffs;
    }
    if (patszOneOffs)
        (*patszOneOffs) = atszOneOffs;

out:

    if ( FAILED(hr) || !patszContacts )
        LocalFreeAndNull((LPVOID *)&atszContacts);

    if ( FAILED(hr) || !patszOneOffs )
        LocalFreeAndNull((LPVOID *)&atszOneOffs);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//  hrCreateGroupMVBin
//
//  Creates either a PR_WAB_DL_ENTRIES or PR_WAB_DL_ONEOFFS MVBin property and
//  adds it to the passed in property array.  
//
//  If the proptag is PR_WAB_DL_ENTRIES then the atszNames array is assumed to
//  contain valid WAB contact nicknames.  The first contact's (mail user) EID
//  with that nickname is added to the MVBin property.  It is assumed that 
//  nicknames are unique (after contact syncing which is performed first) as is
//  required by Hotmail.
//
//  If the proptag is PR_WAB_DL_ONEOFFS then the atszNames array is assumed to
//  contain valid email names.  WAB one-off EIDs are created from these and 
//  added to the MVBin property.
//
//  Parameters
//  [IN] pWabSync
//  [IN] ulPropTag
//  [IN] atszNames - Array of wide char names
//  [IN] cCount - Number of items in above array
//  [IN/OUT] lpPropArray
//  [IN/OUT] pdwLoc - Current lpPropArray index
///////////////////////////////////////////////////////////////////////////////
HRESULT hrCreateGroupMVBin(
    LPWABSYNC    pWabSync,
    ULONG        ulPropTag,
    LPTSTR *     atszNames,
    ULONG        cCount,
    LPSPropValue lpPropArray,
    DWORD *      pdwLoc)
{
    HRESULT hr = S_OK;
    ULONG   ul;

    Assert(atszNames);
    Assert(lpPropArray);
    Assert(pdwLoc);

    // Set up this property as error.  When the MVbin values are added via
    // AddPropToMVPBin() the tag type will change to valid PT_MV_BINARY type.
    lpPropArray[*pdwLoc].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(ulPropTag));
    lpPropArray[*pdwLoc].dwAlignPad = 0;
    lpPropArray[*pdwLoc].Value.MVbin.cValues = 0;
    lpPropArray[*pdwLoc].Value.MVbin.lpbin = NULL;
    
    if (ulPropTag == PR_WAB_DL_ENTRIES)
    {
        // Search for WAB mail users with these nicknames
        for (ul=0; ul<cCount; ul++)
        {
            SPropertyRestriction PropRes;
            SPropValue Prop = {0};
            LPSBinary rgsbEntryIDs = NULL;
            ULONG ulCount = 1;

            // Set up search restriction
            Prop.ulPropTag = PR_NICKNAME;
            Prop.Value.LPSZ = atszNames[ul];
            PropRes.lpProp = &Prop;
            PropRes.relop = RELOP_EQ;
            PropRes.ulPropTag = PR_NICKNAME;

            if (SUCCEEDED(FindRecords(((LPIAB)pWabSync->m_pAB)->lpPropertyStore->hPropertyStore,
	                                  NULL,			// pmbinFolder
                                      0,            // ulFlags
                                      TRUE,         // Always TRUE
                                      &PropRes,     // Propertyrestriction
                                      &ulCount,     // IN: number of matches to find, OUT: number found
                                      &rgsbEntryIDs)))
            {
                // Add EID property
                if (ulCount > 0)
                {
                    if ( FAILED(AddPropToMVPBin(
                            lpPropArray,
                            *pdwLoc,
                            rgsbEntryIDs[0].lpb,
                            rgsbEntryIDs[0].cb,
                            FALSE)) )                   // Don't add duplicates, not
                    {
                        Assert(0);
                    }
                }

                FreeEntryIDs(((LPIAB)pWabSync->m_pAB)->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
            }
            else
            {
                // All contacts should be in WAB unless the preceeding mail user contact
                // sync failed.
                DebugTrace(TEXT("hrCreateGroupMVBin - Failed to find HM group contact\n"));
            }
        }
    }
    else if (ulPropTag == PR_WAB_DL_ONEOFFS)
    {        
        for (ul=0; ul<cCount; ul++)
        {
            ULONG       cbEID = 0;
            LPENTRYID   lpEID = NULL;
            LPTSTR      lptszName = NULL;
            LPTSTR      lptszSMTP = TEXT("");
            LPTSTR      lptszEmail = atszNames[ul];
            LPTSTR      lptszTemp = NULL;
            int         nLen = lstrlen(atszNames[ul]) + 1;

            // A WAB DL OneOff must have a valid display name.  Take the first
            // part of the email name for this.
            lptszName = LocalAlloc(LMEM_ZEROINIT, (nLen * sizeof(WCHAR)));
            if (!lptszName)
            {
                hr = E_OUTOFMEMORY;
                goto out;
            }
            StrCpyN(lptszName, lptszEmail, nLen);
            lptszTemp = lptszName;
            while ( *lptszTemp &&
                    (*lptszTemp) != (*tszAt) )
            {
                ++lptszTemp;
            }
            (*lptszTemp) = '\0';

            // Creates UNICODE string embedded WAB one-off EID
            if ( SUCCEEDED(CreateWABEntryID(WAB_ONEOFF,
                                            (LPVOID)lptszName,
                                            (LPVOID)lptszSMTP,
                                            (LPVOID)lptszEmail,
                                            0, 0, NULL,
                                            &cbEID,
                                            &lpEID)) )
            {
                if ( FAILED(AddPropToMVPBin(
                        lpPropArray,
                        *pdwLoc,
                        lpEID,
                        cbEID,
                        FALSE)) )                   // Don't add duplicates, not
                {
                    Assert(0);
                }
            }

            LocalFreeAndNull(&lptszName);
        }
    }
    else
    {
        Assert(0);
    }

out:

    ++(*pdwLoc);
    return hr;
}
#endif  // HM_GROUP_SYNCING


///////////////////////////////////////////////////////////////////////////////
//  hrStripInvalidChars
//
//  Helper function to remove disallowed characters.  HM only allows 
//  alphanumeric and '-' and '_' characters in a nickname.  All illegal chars
//  are removed from the string.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT hrStripInvalidChars(LPSTR lpszName)
{
    HRESULT hr = S_OK;
    LPSTR   lpszAddTo = NULL;

    Assert(lpszName);

    lpszAddTo = lpszName;
    while (*lpszName)
    {
        // @review  Currently the look up table only contains 122 characters.  Make
        // it full 256?  How will HM change when it adds intenational suppport?
        if ( ((UCHAR)(*lpszName) < MAX_INVALID_ARRAY_INDEX) && !bInvalidCharArray[*lpszName] )
        {
            *lpszAddTo = *lpszName;
            ++lpszAddTo;
        }
        ++lpszName;
    }
    *lpszAddTo = '\0';

    return hr;
}



// ****************************************************************************************************
//  C   H   O   T   S   Y   N   C          C   L   A   S   S   
//
//  Class to handle the synchronizing of WAB and Hotmail contacts
//

HRESULT     WABSync_Create(LPWABSYNC *ppWabSync)
{
    Assert(ppWabSync);

    *ppWabSync = LocalAlloc(LMEM_ZEROINIT, sizeof(WABSYNC));
   
    // fix up the prop tag array structure to take into account the variable values
    ptaEidSync.aulPropTag[ieid_PR_WAB_HOTMAIL_CONTACTIDS] = PR_WAB_HOTMAIL_CONTACTIDS;
    ptaEidSync.aulPropTag[ieid_PR_WAB_HOTMAIL_SERVERIDS] = PR_WAB_HOTMAIL_SERVERIDS;
    ptaEidSync.aulPropTag[ieid_PR_WAB_HOTMAIL_MODTIMES] = PR_WAB_HOTMAIL_MODTIMES;

    // fix up the other prop tag array structure to take into account the variable values
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_HOTMAIL_CONTACTIDS] = PR_WAB_HOTMAIL_CONTACTIDS;
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_HOTMAIL_SERVERIDS] = PR_WAB_HOTMAIL_SERVERIDS;
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_HOTMAIL_MODTIMES] = PR_WAB_HOTMAIL_MODTIMES;
#ifdef HM_GROUP_SYNCING
    ptaEidCSync.aulPropTag[ieidc_PR_WAB_DL_ONEOFFS] = PR_WAB_DL_ONEOFFS;
#endif

    if (*ppWabSync)
    {
        (*ppWabSync)->vtbl = &vtblIHTTPMAILCALLBACK;
        (*ppWabSync)->m_cRef = 1;
        (*ppWabSync)->m_state = SYNC_STATE_INITIALIZING;
        (*ppWabSync)->m_ixpStatus = IXP_DISCONNECTED;
        ZeroMemory(&(*ppWabSync)->m_rInetServerInfo, sizeof(INETSERVER));
    }
    else
        return E_OUTOFMEMORY;

    return S_OK;
}


void        WABSync_Delete(LPWABSYNC pWabSync)
{
    Assert(pWabSync);

    ZeroMemory(&(pWabSync->m_rInetServerInfo), sizeof(INETSERVER));     // Done for security

    if (pWabSync->m_pOps)
    {
        WABSync_FreeOps(pWabSync);
        Vector_Delete(pWabSync->m_pOps);
        pWabSync->m_pOps = NULL;
    }

    if (pWabSync->m_pWabItems)
    {
        WABSync_FreeItems(pWabSync);
        Vector_Delete(pWabSync->m_pWabItems);
    }

    if (pWabSync->m_pszAccountId)
        CoTaskMemFree(pWabSync->m_pszAccountId);

    if (pWabSync->m_pAB)
        pWabSync->m_pAB->lpVtbl->Release(pWabSync->m_pAB);

    if (pWabSync->m_pTransport)
        IHTTPMailTransport_Release(pWabSync->m_pTransport);

    if (pWabSync->m_pszRootUrl)
        CoTaskMemFree(pWabSync->m_pszRootUrl);

#ifdef HM_GROUP_SYNCING
    // [PaulHi] If we are ending a mail contact sync, kick off a second pass
    // to synchronize the group contacts.
    // @review - We may want to skip group syncing if an error occurs during the
    // first pass contact syncing.
    if (!pWabSync->m_fSyncGroups && pWabSync->m_hParentWnd)
        PostMessage(pWabSync->m_hParentWnd, WM_USER_SYNCGROUPS, 0, 0L);
#endif

    LocalFree(pWabSync);
}


//----------------------------------------------------------------------
// IUnknown Members
//----------------------------------------------------------------------
HRESULT WABSync_QueryInterface (IHTTPMailCallback __RPC_FAR *lpunkobj,
                                REFIID          riid,
                                LPVOID FAR *    lppUnk)
{
    SCODE       sc;
    LPWABSYNC   lpWabSync = (LPWABSYNC)lpunkobj;

    if (IsEqualGUID(riid, &IID_IUnknown) ||
        IsEqualGUID(riid, &IID_IHTTPMailCallback) ||
        IsEqualGUID(riid, &IID_ITransportCallback))
    {
        sc = S_OK;
    }
    else
    {
		*lppUnk = NULL;	// OLE requires zeroing [out] parameters
		sc = E_NOINTERFACE;
		goto error;
    }

	/* We found the requested interface so increment the reference count.
	 */
	lpWabSync ->m_cRef++;

	*lppUnk = lpunkobj;

	return hrSuccess;

error:
	return ResultFromScode(sc);
}


ULONG WABSync_AddRef(IHTTPMailCallback __RPC_FAR *This)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return InterlockedIncrement(&pWabSync->m_cRef);
}

ULONG WABSync_Release(IHTTPMailCallback __RPC_FAR *This)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    LONG cRef = InterlockedDecrement(&pWabSync->m_cRef);
    
    Assert(cRef >= 0);

    if (0 == cRef)
        WABSync_Delete(pWabSync);

    return (ULONG)cRef;
}


//----------------------------------------------------------------------
// IHTTPMailCallback Members
//----------------------------------------------------------------------
STDMETHODIMP WABSync_OnTimeout (IHTTPMailCallback __RPC_FAR *This, DWORD *pdwTimeout, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnLogonPrompt (IHTTPMailCallback __RPC_FAR *This, LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    if (PromptUserForPassword(pInetServer, pWabSync->m_hWnd))
    {
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP_(INT) WABSync_OnPrompt (IHTTPMailCallback __RPC_FAR *This, HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnStatus (IHTTPMailCallback __RPC_FAR *This, IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnError (IHTTPMailCallback __RPC_FAR *This, IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_OnCommand (IHTTPMailCallback __RPC_FAR *This, CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport)
{
//    LPWABSYNC pWabSync = (LPWABSYNC)This;
    return E_NOTIMPL;
}

STDMETHODIMP WABSync_GetParentWindow (IHTTPMailCallback __RPC_FAR *This, HWND *pHwndParent)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    
    *pHwndParent = pWabSync->m_hWnd;
    return S_OK;
}

STDMETHODIMP WABSync_OnResponse (IHTTPMailCallback __RPC_FAR *This, LPHTTPMAILRESPONSE pResponse)
{
    LPWABSYNC pWabSync = (LPWABSYNC)This;
    HRESULT hr = S_OK;
    
    Assert(pWabSync);
    Assert(pResponse);

    if (FAILED(pResponse->rIxpResult.hrResult))
    {
        switch (pResponse->rIxpResult.hrResult)
        {
            case IXP_E_HTTP_INSUFFICIENT_STORAGE:
            case IXP_E_HTTP_ROOT_PROP_NOT_FOUND:
            case IXP_E_HTTP_NOT_IMPLEMENTED:
                WABSync_Abort(pWabSync, pResponse->rIxpResult.hrResult);
                break;
        }
    }

    if (pWabSync->m_fAborted)
        return E_FAIL;

    if (SYNC_STATE_SERVER_CONTACT_DISCOVERY == pWabSync->m_state)
    {
        if (pResponse->command == HTTPMAIL_GETPROP)
            hr = WABSync_HandleContactsRootResponse(pWabSync, pResponse);
        else
            hr = WABSync_HandleIDListResponse(pWabSync, pResponse);
    }    
    else if ((SYNC_STATE_PROCESS_OPS == pWabSync->m_state || SYNC_STATE_PROCESS_MERGED_CONFLICTS == pWabSync->m_state)
                && pWabSync->m_pOps)
    {   
        LPHOTSYNCOP pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);
        Assert(pOp);

        if (pOp)
            hr = Syncop_HandleResponse(pOp, pResponse);
        else
            hr = E_FAIL;

        if (FAILED(hr))
            WABSync_AbortOp(pWabSync, hr);
    }
    else
        hr = E_FAIL;

    return hr;
}

#ifdef HM_GROUP_SYNCING
STDMETHODIMP WABSync_Initialize(LPWABSYNC pWabSync, HWND hWnd, IAddrBook *pAB, LPCTSTR pszAccountID, BOOL bSyncGroups)
#else
STDMETHODIMP WABSync_Initialize(LPWABSYNC pWabSync, HWND hWnd, IAddrBook *pAB, LPCTSTR pszAccountID)
#endif
{
    IImnAccountManager2 *lpAcctMgr = NULL;
    IImnAccount        *pAccount = NULL;
    HRESULT             hr;
    char                szAcctName[CCHMAX_ACCOUNT_NAME+1];
    DWORD               ccb = CCHMAX_ACCOUNT_NAME;
    LPSTR               pszUserAgent = NULL;
#ifdef HM_GROUP_SYNCING
    LPPTGDATA           lpPTGData=GetThreadStoragePointer();
#endif

    Assert(pWabSync);
    Assert(pAB);

    pWabSync->m_hParentWnd = hWnd;
    pWabSync->m_pTransport = NULL;
    pWabSync->m_fSkipped = FALSE;
#ifdef HM_GROUP_SYNCING
    pWabSync->m_fSyncGroups = bSyncGroups;
#endif

    pWabSync->m_hWnd =  CreateDialogParam (hinstMapiX, MAKEINTRESOURCE (iddSyncProgress),
                        pWabSync->m_hParentWnd, SyncProgressDlgProc, (LPARAM)pWabSync);


    if (!pWabSync->m_hWnd)
    {
        hr = E_FAIL;
        goto exit;
    }
    ShowWindow(pWabSync->m_hWnd, SW_SHOW);
    if (pWabSync->m_hParentWnd)
        EnableWindow (pWabSync->m_hParentWnd, FALSE);

    WABSync_BeginSynchronize(pWabSync);
    
    InitWABUserAgent(TRUE);

    if (FAILED(hr = InitAccountManager(NULL, &lpAcctMgr, NULL)))
        goto exit;

    if (pszAccountID == NULL)
    {
        if (FAILED(hr = _FindHTTPMailAccount(pWabSync->m_hWnd, lpAcctMgr, szAcctName, CCHMAX_ACCOUNT_NAME)))
            goto exit;
#ifdef HM_GROUP_SYNCING
        // [PaulHi] We don't want the user to have to choose the HM account twice (once for contact and
        // then for group syncing).  So save the account ID here.
        LocalFreeAndNull(&(lpPTGData->lptszHMAccountId));
        lpPTGData->lptszHMAccountId = ConvertAtoW(szAcctName);
#endif
    }
    else
    {
        LPSTR lpAcctA = ConvertWtoA((LPWSTR)pszAccountID);
        StrCpyNA(szAcctName, lpAcctA, ARRAYSIZE(szAcctName));
        LocalFreeAndNull(&lpAcctA);
    }

    // Get the account
    hr = lpAcctMgr->lpVtbl->FindAccount(lpAcctMgr, AP_ACCOUNT_ID, szAcctName, &pAccount);
    if (FAILED(hr))
    {
        hr = lpAcctMgr->lpVtbl->FindAccount(lpAcctMgr, AP_ACCOUNT_NAME, szAcctName, &pAccount);
        if (FAILED(hr))
            goto exit;
    }

    if (SUCCEEDED(hr = pAccount->lpVtbl->GetProp(pAccount, AP_ACCOUNT_ID, szAcctName, &ccb)))
        pWabSync->m_pszAccountId = _StrDup(szAcctName);

    pWabSync->m_pAB = pAB;
    
    pWabSync->m_pAB->lpVtbl->AddRef(pWabSync->m_pAB);

    // Create the Transport
    hr = CoCreateInstance(  &CLSID_IHTTPMailTransport, 
                            NULL, 
                            CLSCTX_INPROC_SERVER,
                            &IID_IHTTPMailTransport, 
                            (LPVOID *)&(pWabSync->m_pTransport));
    
    if (FAILED(hr) || !pWabSync->m_pTransport)
        goto exit;

    pszUserAgent = GetWABUserAgentString();
    if (!pszUserAgent)
        goto exit;

    // Initialize the transport
    hr = IHTTPMailTransport_InitNew(pWabSync->m_pTransport, pszUserAgent, (LogTransactions(pWabSync) ? "C:\\WabSync.log" : NULL),(IHTTPMailCallback*)pWabSync);
    if (FAILED(hr))
        goto exit;

    // Create the SERVERINFO
    hr = IHTTPMailTransport_InetServerFromAccount(pWabSync->m_pTransport, pAccount, &pWabSync->m_rInetServerInfo);
    if (FAILED(hr))
        goto exit;
    
    StrCpyNA(pWabSync->m_szLoginName, pWabSync->m_rInetServerInfo.szUserName, ARRAYSIZE(pWabSync->m_szLoginName));

    // Check if I can connect
    hr = IHTTPMailTransport_Connect(pWabSync->m_pTransport,&pWabSync->m_rInetServerInfo,TRUE,TRUE);
    if (FAILED(hr))
        goto exit;

    hr = WABSync_LoadLastModInfo(pWabSync);
    if (FAILED(hr))
        goto exit;

    hr = WABSync_BuildWabContactList(pWabSync);
    if (FAILED(hr))
        goto exit;

    WABSync_NextState(pWabSync);

exit:
    if (pszUserAgent)
        LocalFree(pszUserAgent);

    if (FAILED(hr))
    {
        if (pWabSync->m_pTransport)
            IHTTPMailTransport_Release(pWabSync->m_pTransport);
        pWabSync->m_pTransport = NULL;
        WABSync_Abort(pWabSync, hr);

        if (pWabSync->m_pAB)
        {
            pWabSync->m_pAB->lpVtbl->Release(pWabSync->m_pAB);
            pWabSync->m_pAB = NULL;
        }
    }

    // don't release the lpAcctMgr since the WAB maintains a global reference.
        
    if (pAccount)
        pAccount->lpVtbl->Release(pAccount);

    return hr;
}


//
//    CHotSync::Abort
//
//    Blow away all of the pending items in the queue.
//
STDMETHODIMP WABSync_Abort(LPWABSYNC pWabSync, HRESULT hr)
{
    LPHOTSYNCOP         pOp;
    TCHAR   szMsg[512], szCaption[255], szRes[512];
    
    Assert(pWabSync);
    
    pWabSync->m_fAborted = TRUE;

    if (pWabSync->m_pOps)
    {
        DWORD   dwIndex, cOps = Vector_GetLength(pWabSync->m_pOps);

        for (dwIndex = 0; dwIndex < cOps; ++dwIndex)
        {
            pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);

            if (pOp)
            {
                Syncop_Abort(pOp);
                Syncop_Delete(pOp);
            }

            Vector_RemoveItem(pWabSync->m_pOps, 0);
        }
    }

    if (FAILED(hr) && hr != E_UserCancel)
    {
        switch (hr)
        {
            case IXP_E_HTTP_INSUFFICIENT_STORAGE:
                LoadString(hinstMapiX, idsOutOfServerSpace, szMsg, CharSizeOf(szMsg));
                break;

            case IXP_E_HTTP_ROOT_PROP_NOT_FOUND:
            case IXP_E_HTTP_NOT_IMPLEMENTED:
                LoadString(hinstMapiX, idsSyncNotHandled, szMsg, CharSizeOf(szMsg));
                break;
            
            default:
                LoadString(hinstMapiX, idsSyncAborted, szRes, CharSizeOf(szRes));
                wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, hr);
                break;
        }
        LoadString(hinstMapiX, idsSyncError, szCaption, CharSizeOf(szCaption));
        MessageBox(pWabSync->m_hWnd, szMsg, szCaption, MB_ICONEXCLAMATION | MB_OK);
    }

    WABSync_FinishSynchronize(pWabSync, hr);

    return S_OK;
}

//
//    CHotSync::AbortOp
//
//    Abort the current operation (for some reason)
//
STDMETHODIMP WABSync_AbortOp(LPWABSYNC pWabSync, HRESULT hr)
{
    LPHOTSYNCOP         pOp;
    
    Assert(pWabSync);
    
    pWabSync->m_cAborts++;

    // do something with the knowledge of this abort (log to whatever)
    if (!WABSync_NextOp(pWabSync, TRUE))
        WABSync_NextState(pWabSync);

    return S_OK;
}

int __cdecl CompareOpTypes(const void* lpvA, const void* lpvB)
{
    LPHOTSYNCOP pSyncOpA;
    LPHOTSYNCOP pSyncOpB;

    pSyncOpA = *((LPHOTSYNCOP*)lpvA);
    pSyncOpB = *((LPHOTSYNCOP*)lpvB);

    return (pSyncOpA->m_bOpType - pSyncOpB->m_bOpType);
}


STDMETHODIMP WABSync_RequestContactsRootProperty(LPWABSYNC pWabSync)
{
    HRESULT hr;

    Assert(pWabSync);
    Assert(pWabSync->m_pTransport);

    hr = pWabSync->m_pTransport->lpVtbl->GetProperty(pWabSync->m_pTransport, HTTPMAIL_PROP_CONTACTS, &pWabSync->m_pszRootUrl);
    
    if(hr == E_PENDING)
        hr = S_OK;
    else if (SUCCEEDED(hr) && pWabSync->m_pszRootUrl)
        WABSync_RequestServerIDList(pWabSync);
    else
        WABSync_Abort(pWabSync, hr);    //something went terribly wrong

    return S_OK;
}

STDMETHODIMP WABSync_HandleContactsRootResponse(LPWABSYNC pWabSync, LPHTTPMAILRESPONSE pResponse)
{
    Assert(pWabSync);

    pWabSync->m_pszRootUrl = NULL;
    if (SUCCEEDED(pResponse->rIxpResult.hrResult))
    {
        if (pResponse->rGetPropInfo.type == HTTPMAIL_PROP_CONTACTS)
        {
            pWabSync->m_pszRootUrl = pResponse->rGetPropInfo.pszProp;
            pResponse->rGetPropInfo.pszProp = NULL;
        }            
    }

    if (pWabSync->m_pszRootUrl)
        WABSync_RequestServerIDList(pWabSync);
    else
        WABSync_Abort(pWabSync, pResponse->rIxpResult.hrResult);


    return S_OK;
}

STDMETHODIMP WABSync_RequestServerIDList(LPWABSYNC pWabSync)
{
    HRESULT             hr;

    Assert(pWabSync);
    Assert(pWabSync->m_pTransport);
    Assert(pWabSync->m_pszRootUrl && *pWabSync->m_pszRootUrl);

    WABSync_Progress(pWabSync, idsSyncGathering, -1);

    hr = pWabSync->m_pTransport->lpVtbl->ListContactInfos(pWabSync->m_pTransport, pWabSync->m_pszRootUrl, 0);

    if FAILED(hr)
        WABSync_Abort(pWabSync, hr);

    return hr;
}

STDMETHODIMP WABSync_FindContactByServerId(LPWABSYNC pWabSync, LPSTR pszServerId, LPWABCONTACTINFO *ppContact, DWORD *pdwIndex)
{
    DWORD               cItems, dwIndex;
    LPWABCONTACTINFO    pContact;

    Assert(pWabSync);
    Assert(pWabSync->m_pWabItems);

    cItems = Vector_GetLength(pWabSync->m_pWabItems);

    for (dwIndex = 0; dwIndex < cItems; dwIndex++)
    {
        pContact = (LPWABCONTACTINFO)Vector_GetItem(pWabSync->m_pWabItems, dwIndex);

        if (pContact && pContact->pszHotmailId && lstrcmpA(pContact->pszHotmailId, pszServerId) == 0)
        {
            *ppContact = pContact;
            *pdwIndex = dwIndex;
            return S_OK;
        }
    }
    return E_FAIL;
}
 
STDMETHODIMP WABSync_HandleIDListResponse(LPWABSYNC pWabSync, LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr;
    LPHOTSYNCOP      pNewOp;

    if (SUCCEEDED(pResponse->rIxpResult.hrResult))
    {
        ULONG   cItems = pResponse->rContactInfoList.cContactInfo;
        LPHTTPCONTACTINFO prgId = pResponse->rContactInfoList.prgContactInfo;
        DWORD   dwItem;

        for (dwItem = 0; dwItem < cItems; dwItem++)
        {
#ifdef HM_GROUP_SYNCING
            // [PaulHi] We synchronize contacts and groups separately
            if ( (!pWabSync->m_fSyncGroups && (prgId[dwItem].tyContact == HTTPMAIL_CT_CONTACT)) ||
                 (pWabSync->m_fSyncGroups && (prgId[dwItem].tyContact == HTTPMAIL_CT_GROUP)) )
#else
            if (HTTPMAIL_CT_GROUP == prgId[dwItem].tyContact)
            {
                // ignore groups for now
                continue;
            }
            else
#endif
            {
                LPWABCONTACTINFO pContact;
                DWORD            dwIndex;
                FILETIME         ftModTime = {0,0};

                pNewOp = NULL;
                // [PaulHi] 12/17/98  Raid #61548
                // The Exchange server will pass in contacts with no file mod time, 
                // which really hoses the sync process.  We could just skip these 
                // contacts but to keep things simple we abort the sync process here.
                // Note that HotMail servers work correctly.
                //
                // @todo [PaulHi]
                // After IE5 ship of WAB, fix this by creating a conflict op code and
                // let user straighten out any differences.  Also time stamp so future
                // syncs will work.
                hr = iso8601ToFileTime(prgId[dwItem].pszModified, &ftModTime, TRUE, TRUE);
                if (FAILED(hr))
                {
                    WABSync_Abort(pWabSync, hr);
                    return hr;
                }

                if (SUCCEEDED(WABSync_FindContactByServerId(pWabSync, prgId[dwItem].pszId, &pContact, &dwIndex)))
                {
                    if (pContact->fDelete)
                    {
                        // it has been deleted from the wab.  Now delete it from the server.
                        pContact->pszHotmailHref = prgId[dwItem].pszHref;
                        prgId[dwItem].pszHref = NULL;

                        pContact->pszModHotmail = prgId[dwItem].pszModified;
                        prgId[dwItem].pszModified = NULL;

                        pNewOp = Syncop_CreateServerDelete(pContact);
                    }
                    else
                    {
                        LONG lLocalCompare = CompareFileTime(&pWabSync->m_ftLastSync, &pContact->ftModWab);
                        LONG lServerCompare = pContact->pszModHotmail && prgId[dwItem].pszModified ? lstrcmpA(pContact->pszModHotmail, prgId[dwItem].pszModified) : -1;

                        SafeCoMemFree(pContact->pszHotmailHref);
                        pContact->pszHotmailHref = prgId[dwItem].pszHref;
                        prgId[dwItem].pszHref = NULL;

                        SafeCoMemFree(pContact->pszHotmailId);
                        pContact->pszHotmailId = prgId[dwItem].pszId;
                        prgId[dwItem].pszId = NULL;

                        SafeCoMemFree(pContact->pszModHotmail);
                        pContact->pszModHotmail = prgId[dwItem].pszModified;
                        prgId[dwItem].pszModified = NULL;
                    
                        if (lLocalCompare >= 0)
                        {
                            // hasn't changed locally since last sync
                        
                            if (lServerCompare)
                            {
                                // has changed on server, just update here
                                pNewOp = Syncop_CreateClientChange(pContact);
                                Assert(pNewOp);
                                Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                            }
                            else
                            {
                                // hasn't changed anywhere.  do nothing.
                                WABContact_Delete(pContact);
                                pContact = NULL;
                            }
                        }   
                        else 
                        {
                            // has changed locally.

                            if (lServerCompare)
                            {
                                // has changed on server, CONFLICT
                                pNewOp = Syncop_CreateConflict(pContact);
                                Assert(pNewOp);
                                Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                            }
                            else
                            {
                                // Local change only, upload changes
                                pNewOp = Syncop_CreateServerChange(pContact);
                                Assert(pNewOp);
                                Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                            }
                        }
                    }
                    
                    //remove the contact from the list of local contacts
                    Vector_RemoveItem(pWabSync->m_pWabItems, dwIndex);   
                }
                else
                {
                    // its not in the WAB, we need to add it there.
                    pContact = LocalAlloc(LMEM_ZEROINIT, sizeof(WABCONTACTINFO));
                    Assert(pContact);

                    if (pContact)
                    {
                        pContact->pszHotmailHref = prgId[dwItem].pszHref;
                        prgId[dwItem].pszHref = NULL;

                        pContact->pszHotmailId = prgId[dwItem].pszId;
                        prgId[dwItem].pszId = NULL;

                        pContact->pszModHotmail = prgId[dwItem].pszModified;
                        prgId[dwItem].pszModified = NULL;

                        pNewOp = Syncop_CreateClientAdd(pContact);
                        Assert(pNewOp);
                        Syncop_SetServerContactInfo(pNewOp, pContact, &prgId[dwItem]);
                    }
                }

                if (pNewOp)
                {
                    Syncop_Init(pNewOp, (IHTTPMailCallback *)pWabSync, pWabSync->m_pTransport);
                    hr = Vector_AddItem(pWabSync->m_pOps, pNewOp);
                }
                else
                {
                    if (pContact)
                        WABContact_Delete(pContact);
                }
            }
        }


        if (pResponse->fDone)
        {
            //everything left in the contact list needs to either
            //be added to the server or deleted locally.
            LONG                cItems, dwIndex;
            LPWABCONTACTINFO    pContact;

            Assert(pWabSync->m_pWabItems);

            cItems = Vector_GetLength(pWabSync->m_pWabItems);

            if (cItems > 0)
            {
                for (dwIndex = cItems - 1; dwIndex >= 0; dwIndex--)
                {
                    pNewOp = NULL;
                    pContact = (LPWABCONTACTINFO)Vector_GetItem(pWabSync->m_pWabItems, dwIndex);

                    if (pContact && pContact->pszHotmailId)
                    {
                        if (pContact->fDelete)
                        {
                            TCHAR   tszServerId[MAX_PATH];
                            TCHAR   tszKey[MAX_PATH];
                            HKEY    hkey;
                            // now that the delete has completed, delete the tombstone from the registry.
                            hr = hrMakeContactId(
                                tszServerId,
                                MAX_PATH,
                                ((LPIAB)(pWabSync->m_pAB))->szProfileID,
                                pWabSync->m_pszAccountId,
                                pWabSync->m_szLoginName);
                            if (FAILED(hr))
                                return hr;
                            wnsprintf(tszKey, ARRAYSIZE(tszKey), TEXT("%s%s"), g_lpszSyncKey, tszServerId);

                            if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, tszKey, 0, KEY_SET_VALUE, &hkey))
                            {
                                LPTSTR lpKey =
                                    ConvertAtoW(pContact->pszHotmailId);
                                RegDeleteValue(hkey, lpKey);
                                LocalFreeAndNull(&lpKey);
                                RegCloseKey(hkey);
                            }
                        }
                        else
                        {
                            //needs to be deleted locally
                            pNewOp = Syncop_CreateClientDelete(pContact);
                        }
                    }
                    else if (pContact)
                    {
                        //needs to be added remotely
                        pNewOp = Syncop_CreateServerAdd(pContact);
                    }

                    if (pNewOp)
                    {
                        //remove the contact from the list of local contacts
                        Vector_RemoveItem(pWabSync->m_pWabItems, dwIndex);   
                        Syncop_Init(pNewOp, (IHTTPMailCallback *)pWabSync, pWabSync->m_pTransport);
                        hr = Vector_AddItem(pWabSync->m_pOps, pNewOp);
                    }
                }

            }

            WABSync_MergeAddsToConflicts(pWabSync);

            pWabSync->m_cTotalOps = Vector_GetLength(pWabSync->m_pOps);
            
            Vector_Sort(pWabSync->m_pOps, CompareOpTypes); 

            //Now go on to handling the operations
            WABSync_NextState(pWabSync);
        }
    }
    else
        WABSync_Abort(pWabSync, pResponse->rIxpResult.hrResult);

    return S_OK;
}

STDMETHODIMP WABSync_OperationCompleted(LPWABSYNC pWabSync, LPHOTSYNCOP pOp)
{
    Assert(pWabSync->m_pOps);
    Assert(pOp == Vector_GetItem(pWabSync->m_pOps, 0));  //completing op should be first op in the list

    Syncop_Delete(pOp);
    Vector_RemoveItem(pWabSync->m_pOps, 0);

    // get the next operation and start it running.
    // if there are no more operations, go to the next state
    pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);
    if (pOp)
        Syncop_Begin(pOp);
    else
        WABSync_NextState(pWabSync);

    return S_OK;
}


STDMETHODIMP WABSync_BeginSynchronize(LPWABSYNC pWabSync)
{
    //Keep a reference to ourself while the UI is shown
    WABSync_AddRef((IHTTPMailCallback *)pWabSync); 

    // begin ui
    
    return S_OK;
}

STDMETHODIMP WABSync_FinishSynchronize(LPWABSYNC pWabSync, HRESULT hr)
{
    // if there were any failures or the user didn't resolve all of the 
    // conflicts, then don't update the mod info so we have to do it again.
#ifdef HM_GROUP_SYNCING
    // [PaulHi]  Don't store the current mod time until the synchronization
    // process is completely through, meaning that we are ending the second
    // group contact syncing pass
    if (SUCCEEDED(hr) && !pWabSync->m_fSkipped && pWabSync->m_fSyncGroups)
#else
    if (SUCCEEDED(hr) && !pWabSync->m_fSkipped)
#endif
        WABSync_SaveCurrentModInfo(pWabSync);
    else if (!pWabSync->m_fAborted && FAILED(hr))
    {
        TCHAR   szMsg[512], szCaption[255];

        LoadString(hinstMapiX, idsSyncFailed, szMsg, CharSizeOf(szMsg));
        LoadString(hinstMapiX, idsSyncError, szCaption, CharSizeOf(szCaption));
        
        MessageBox(pWabSync->m_hWnd, szMsg, szCaption, MB_ICONEXCLAMATION | MB_OK);
    }

    if (pWabSync->m_pTransport)
    {
        IHTTPMailTransport_Release(pWabSync->m_pTransport);
        pWabSync->m_pTransport = NULL;
    }

    if (pWabSync->m_hWnd)
    {
        if (pWabSync->m_hParentWnd)
            EnableWindow (pWabSync->m_hParentWnd, TRUE);

        DestroyWindow(pWabSync->m_hWnd);
        pWabSync->m_hWnd = NULL;
    }
    InitWABUserAgent(FALSE);

    WABSync_Release((IHTTPMailCallback *)pWabSync);
 
    return S_OK;  
}


void    WABSync_CheckForLocalDeletions(LPWABSYNC pWabSync)
{
    TCHAR   tszKey[MAX_PATH], tszId[MAX_PATH];
    TCHAR   tszServerId[MAX_PATH];
    DWORD   dwType = 0;
    DWORD   dwValue = 0;
    HKEY    hkey = NULL;
    DWORD   dwSize;
    HRESULT hr = E_FAIL;
    DWORD   cRecords, i, cb, lResult;

    Assert(pWabSync);
    Assert(*pWabSync->m_szLoginName);

    // [PaulHi]  Assemble the contact ID string
    if ( FAILED(hrMakeContactId(
        tszServerId,
        MAX_PATH,
        ((LPIAB)(pWabSync->m_pAB))->szProfileID,
        pWabSync->m_pszAccountId,
        pWabSync->m_szLoginName)) )
    {
        return;
    }
    wnsprintf(tszKey, ARRAYSIZE(tszKey), TEXT("%s%s"), g_lpszSyncKey, tszServerId);

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, tszKey, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, NULL, NULL, NULL, &cRecords, NULL, NULL, NULL, NULL) &&
            cRecords > 0)
        {
            // Start Enumerating the keys
            for (i = 0; i < cRecords; i++)
            {
                // Enumerate Friendly Names
                cb = CharSizeOf(tszId);
                lResult = RegEnumValue(hkey, i, tszId, &cb, 0, NULL, NULL, NULL);

                if (ERROR_SUCCESS == lResult && *tszId)
                {
                    WABCONTACTINFO *lpWCI;

                    lpWCI = LocalAlloc(LMEM_ZEROINIT, sizeof(WABCONTACTINFO));

                    if (!lpWCI)
                    {
                        hr = E_OUTOFMEMORY;
                        DebugPrintError(( TEXT("WABCONTACTINFO Alloc Failed\n")));
                        goto out;
                    }
                    
                    lpWCI->fDelete = TRUE;

                    {
                        LPSTR lpID = 
                            ConvertWtoA(tszId);
                        lpWCI->pszHotmailId = _StrDup(lpID);
                        LocalFreeAndNull(&lpID);
                    }
                    if (FAILED(Vector_AddItem(pWabSync->m_pWabItems, lpWCI)))
                        goto out;

                }
            }        

        }
out:
        RegCloseKey(hkey);
    }

        
}

STDMETHODIMP WABSync_BuildWabContactList(LPWABSYNC pWabSync)
{
    HRESULT hr = S_OK;
    ULONG   ulObjType;
    LPENTRYID   pEntryID = NULL;
    ULONG       cbEntryID = 0;
    LPABCONT    lpContainer = NULL;
    ULONG       ulObjectType;
    LPMAPITABLE lpABTable =  NULL;
    LPSRowSet   lpRowAB =   NULL;
	int cNumRows = 0;
    int nRows=0;

    Assert(pWabSync->m_pAB);

    Vector_Create(&pWabSync->m_pOps);
    if (pWabSync->m_pOps == NULL)
    {
        WABSync_Abort(pWabSync, E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    Vector_Create(&pWabSync->m_pWabItems);
    if (pWabSync->m_pWabItems == NULL)
    {
        WABSync_Abort(pWabSync, E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    WABSync_CheckForLocalDeletions(pWabSync);

    if (HR_FAILED(hr = pWabSync->m_pAB->lpVtbl->GetPAB(pWabSync->m_pAB, &cbEntryID, &pEntryID)))
    {
        DebugPrintError(( TEXT("GetPAB Failed\n")));
        goto out;
    }
   
    hr = pWabSync->m_pAB->lpVtbl->OpenEntry(pWabSync->m_pAB, cbEntryID,     // size of EntryID to open
                                                pEntryID,     // EntryID to open
                                                NULL,         // interface
                                                0,            // flags
                                                &ulObjType,
                                                (LPUNKNOWN *)&lpContainer);

	MAPIFreeBuffer(pEntryID);

	pEntryID = NULL;
    
    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed\n")));
        goto out;
    }

    if (HR_FAILED(hr = lpContainer->lpVtbl->GetContentsTable(lpContainer, MAPI_UNICODE | WAB_PROFILE_CONTENTS, &lpABTable)))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed\n")));
        goto out;
    }

	hr = lpABTable->lpVtbl->SetColumns(lpABTable, (LPSPropTagArray)&ptaEidSync, 0 );

    if(HR_FAILED(hr))
        goto out;

    // Reset to the beginning of the table
    //
	hr = lpABTable->lpVtbl->SeekRow(lpABTable, BOOKMARK_BEGINNING, 0, NULL );

    if(HR_FAILED(hr))
        goto out;

    // Read all the rows of the table one by one
    //
	do {

        hr = lpABTable->lpVtbl->QueryRows(lpABTable, 1, 0, &lpRowAB);

        if(HR_FAILED(hr))
            break;

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

            if (cNumRows)
            {
                LPTSTR lpsz = lpRowAB->aRow[0].lpProps[ieid_PR_DISPLAY_NAME].Value.LPSZ;
                LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[ieid_PR_ENTRYID].Value.bin.lpb;
                ULONG cbEID = lpRowAB->aRow[0].lpProps[ieid_PR_ENTRYID].Value.bin.cb;
                
                //
                // There are 2 kinds of objects - the MAPI_MAILUSER contact object
                // and the MAPI_DISTLIST contact object
                //
#ifdef HM_GROUP_SYNCING
                if( (!pWabSync->m_fSyncGroups && (lpRowAB->aRow[0].lpProps[ieid_PR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)) ||
                    (pWabSync->m_fSyncGroups && (lpRowAB->aRow[0].lpProps[ieid_PR_OBJECT_TYPE].Value.l == MAPI_DISTLIST)) )
#else
                // Only consider MAILUSER objects
                if (lpRowAB->aRow[0].lpProps[ieid_PR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
#endif
                {
                    WABCONTACTINFO *lpWCI;
                    HTTPCONTACTINFO hci;

                    lpWCI = LocalAlloc(LMEM_ZEROINIT, sizeof(WABCONTACTINFO));

                    if (!lpWCI)
                    {
                        hr = E_OUTOFMEMORY;
                        DebugPrintError(( TEXT("WABCONTACTINFO Alloc Failed\n")));
                        goto out;
                    }

                    lpWCI->lpEID = LocalAlloc(LMEM_ZEROINIT, cbEID);

                    if (!lpWCI->lpEID)
                    {
                        hr = E_OUTOFMEMORY;
                        DebugPrintError(( TEXT("WABCONTACTINFO.ENTRYID Alloc Failed\n")));
                        goto out;
                    }

                    lpWCI->cbEID = cbEID;
                    CopyMemory(lpWCI->lpEID, lpEID, cbEID);
                    
                    lpWCI->ftModWab = lpRowAB->aRow[0].lpProps[ieid_PR_LAST_MODIFICATION_TIME].Value.ft;
                    
                    lpWCI->pszHotmailId = NULL;
                    lpWCI->pszModHotmail = NULL;
                    
                    if (SUCCEEDED(ContactInfo_LoadFromWAB(pWabSync, &hci, lpWCI, lpEID, cbEID)))
                    {
                        lpWCI->pszHotmailId = _StrDup(hci.pszId);
                        lpWCI->pszModHotmail = _StrDup(hci.pszModified);
                        ContactInfo_Free(&hci);
                    }

                    // search the multi value list of longs for the proper server id.  If found,
                    // then get the appropriate hotmail id and mod id.

                    if (FAILED(Vector_AddItem(pWabSync->m_pWabItems, lpWCI)))
                        goto out;
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

    
out:
    if (HR_FAILED(hr))
    {
        if (pWabSync->m_pWabItems)
            WABSync_FreeItems(pWabSync);
        if (lpContainer)
            lpContainer->lpVtbl->Release(lpContainer);
        if (lpABTable)
            lpABTable->lpVtbl->Release(lpABTable);
    }


    return hr;
}


HRESULT WABSync_LoadLastModInfo(LPWABSYNC pWabSync)
{
    TCHAR szKey[MAX_PATH];
    DWORD dwType = 0;
    DWORD dwValue = 0;
    HKEY hKey = NULL;
    DWORD dwSize;
    HRESULT hr = E_FAIL;
    FILETIME    ftValue;
    
    Assert(pWabSync);
    Assert(*pWabSync->m_szLoginName);

    StrCpyN(szKey, g_lpszSyncKey, ARRAYSIZE(szKey));
#ifndef UNICODE
    StrCatBuff(szKey, pWabSync->m_szLoginName, ARRAYSIZE(szKey));
#else
    {
        LPTSTR lpName = ConvertAtoW(pWabSync->m_szLoginName);
        StrCatBuff(szKey, lpName, ARRAYSIZE(szKey));
        LocalFreeAndNull(&lpName);
    }
#endif

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_READ, &hKey))
    {
        dwSize = sizeof(DWORD);
        hr = RegQueryValueEx( hKey,  TEXT("Server ID"), NULL, &dwType, (LPBYTE) &dwValue, &dwSize);
        if (dwValue && ERROR_SUCCESS == hr)
        {
            pWabSync->m_dwServerID = dwValue;
        }
        else
            goto fail;

        dwSize = sizeof(FILETIME);
        if (ERROR_SUCCESS == (hr = RegQueryValueEx( hKey,  TEXT("Server Last Sync"), NULL, &dwType, (LPBYTE) &ftValue, &dwSize)))
        {
            pWabSync->m_ftLastSync = ftValue;
        }
        else
            goto fail;
    }
    else    
    {
        // the key for this user account isn't there.  
        // create a new one and return default values.

        // a random number would be nice here, instead we will
        // use the low DWORD of a date time....
        GetSystemTimeAsFileTime(&ftValue);
        pWabSync->m_dwServerID = ftValue.dwLowDateTime;

        // NULL filetime since we haven't synced yet, everything is after the last sync
        ZeroMemory(&pWabSync->m_ftLastSync, sizeof(FILETIME));

        hr = WABSync_SaveCurrentModInfo(pWabSync);
    }

fail:
    if (hKey)
        RegCloseKey(hKey);

    return hr;
}


HRESULT      WABSync_SaveCurrentModInfo(LPWABSYNC pWabSync)
{
    TCHAR szKey[MAX_PATH];
    HKEY hKey = NULL;
    HRESULT hr = E_FAIL;
    
    Assert(pWabSync);
    Assert(*pWabSync->m_szLoginName);

    StrCpyN(szKey, g_lpszSyncKey, ARRAYSIZE(szKey));

    {
        LPTSTR lpName = ConvertAtoW(pWabSync->m_szLoginName);
        StrCatBuff(szKey, lpName, ARRAYSIZE(szKey));
        LocalFreeAndNull(&lpName);
    }

    
    if(ERROR_SUCCESS == ( hr = RegCreateKey(HKEY_CURRENT_USER, szKey, &hKey)))
    {
        GetSystemTimeAsFileTime(&pWabSync->m_ftLastSync);

        hr = RegSetValueEx( hKey,  TEXT("Server ID"), 0, REG_DWORD, (BYTE *)&pWabSync->m_dwServerID, sizeof(DWORD));
        hr = RegSetValueEx( hKey,  TEXT("Server Last Sync"), 0, REG_BINARY, (BYTE *)&pWabSync->m_ftLastSync, sizeof(FILETIME));
    
        RegCloseKey(hKey);
    }
    
    return hr;
}

void WABSync_Progress(LPWABSYNC pWabSync, DWORD dwResId, DWORD dwCount)
{
    TCHAR   szRes[MAX_PATH], szMsg[MAX_PATH];
    HWND    hwndText;

    LoadString(hinstMapiX, dwResId, szRes, CharSizeOf(szRes));
    if (dwCount != -1)
        wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, dwCount);
    else
        StrCpyN(szMsg, szRes, ARRAYSIZE(szMsg));

    hwndText = GetDlgItem(pWabSync->m_hWnd, IDC_SYNC_MSG);
    if (hwndText)
    {
        SetWindowText(hwndText, szMsg);
    }

    SendDlgItemMessage(pWabSync->m_hWnd, IDC_SYNC_PROGBAR, PBM_SETRANGE, 0, MAKELPARAM(0, pWabSync->m_cTotalOps));
    SendDlgItemMessage(pWabSync->m_hWnd, IDC_SYNC_PROGBAR, PBM_SETPOS, pWabSync->m_cTotalOps - dwCount, 0);
}

void    WABSync_NextState(LPWABSYNC pWabSync)
{
    PostMessage(pWabSync->m_hWnd, WM_SYNC_NEXTSTATE, 0, (LPARAM)pWabSync);
}

void    _WABSync_NextState(LPWABSYNC pWabSync)
{
    HRESULT hr;

    Assert(pWabSync);

    pWabSync->m_state++;

    switch(pWabSync->m_state)
    {
        case SYNC_STATE_SERVER_CONTACT_DISCOVERY:
            WABSync_Progress(pWabSync, idsSyncConnecting, -1);
            hr = WABSync_RequestContactsRootProperty(pWabSync);
            break;

        case SYNC_STATE_PROCESS_OPS:
            WABSync_Progress(pWabSync, idsSyncSynchronizing, Vector_GetLength(pWabSync->m_pOps));
            if (pWabSync->m_pOps && Vector_GetLength(pWabSync->m_pOps) > 0)
            {
                if (WABSync_NextOp(pWabSync, FALSE))
                    return;
            }
            // fall through if there are no ops
            pWabSync->m_state++;

        case SYNC_STATE_PROCESS_CONFLICTS:
            WABSync_Progress(pWabSync, idsSyncConflicts, Vector_GetLength(pWabSync->m_pOps));
            if (pWabSync->m_pOps && Vector_GetLength(pWabSync->m_pOps) > 0)
            {
                if(SUCCEEDED(WABSync_DoConflicts(pWabSync)))
                    return;
            }
            // fall through if there are no ops
            pWabSync->m_state++;
            if (pWabSync->m_fAborted)
                return;

        case SYNC_STATE_PROCESS_MERGED_CONFLICTS:
            WABSync_Progress(pWabSync, idsSyncFinishing, Vector_GetLength(pWabSync->m_pOps));
            if (pWabSync->m_pOps && Vector_GetLength(pWabSync->m_pOps) > 0)
            {
                if (WABSync_NextOp(pWabSync, FALSE))
                    return;
            }
            // fall through if there are no ops
            pWabSync->m_state++;

        case SYNC_STATE_DONE:
            WABSync_FinishSynchronize(pWabSync, (pWabSync->m_cAborts == 0 ? S_OK : E_FAIL));
            break;
    }
}

BOOL  _WABSync_NextOp(LPWABSYNC pWabSync, BOOL fPopFirst)
{
    HRESULT hr = E_FAIL;
    LPHOTSYNCOP pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);

    Assert(pWabSync->m_state == SYNC_STATE_PROCESS_OPS || pWabSync->m_state == SYNC_STATE_PROCESS_MERGED_CONFLICTS);
    Assert(pOp);

    if (pOp && fPopFirst)
    {
        LPVECTOR  pVector;
        pVector = pWabSync->m_pOps;
        Assert(pVector);
        Vector_Remove(pVector, pOp);
        Syncop_Delete(pOp);
        pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);
    }

    if (pWabSync->m_state == SYNC_STATE_PROCESS_OPS)
        WABSync_Progress(pWabSync, idsSyncSynchronizing, Vector_GetLength(pWabSync->m_pOps));
    else if (pWabSync->m_state == SYNC_STATE_PROCESS_MERGED_CONFLICTS)
        WABSync_Progress(pWabSync, idsSyncFinishing, Vector_GetLength(pWabSync->m_pOps));

    if (pOp)
        hr = Syncop_Begin(pOp);  
    
    return (SUCCEEDED(hr));
}

BOOL WABSync_NextOp(LPWABSYNC pWabSync, BOOL fPopFirst)
{
    HRESULT hr = E_FAIL;
    LPHOTSYNCOP pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, 0);

    if (!pOp)
        return FALSE;
    PostMessage(pWabSync->m_hWnd, WM_SYNC_NEXTOP, fPopFirst, (LPARAM)pWabSync);
    return TRUE;
}

void         WABSync_FreeOps(LPWABSYNC pWabSync)
{
    LPHOTSYNCOP    pOp;

    if (pWabSync->m_pOps)
    {
        LONG   dwIndex, cItems = Vector_GetLength(pWabSync->m_pOps);

        for (dwIndex = cItems - 1; dwIndex >= 0; --dwIndex)
        {
            pOp = (LPHOTSYNCOP)Vector_GetItem(pWabSync->m_pOps, dwIndex);

            if (pOp)
            {
                Vector_RemoveItem(pWabSync->m_pOps, dwIndex);
                Syncop_Abort(pOp);
                Syncop_Delete(pOp);
            }

            if (dwIndex == 0)
                break;
        }
    }
}

void         WABSync_FreeItems(LPWABSYNC pWabSync)
{
    LPWABCONTACTINFO    lprWCI;

    if (pWabSync->m_pWabItems)
    {
        LONG   dwIndex, cItems = Vector_GetLength(pWabSync->m_pWabItems);

        for (dwIndex = cItems - 1; dwIndex >= 0; --dwIndex)
        {
            lprWCI = (LPWABCONTACTINFO)Vector_GetItem(pWabSync->m_pWabItems, dwIndex);

            if (lprWCI)
            {
                if (lprWCI->lpEID)
                    LocalFree(lprWCI->lpEID);
                LocalFree(lprWCI);
            }

            Vector_RemoveItem(pWabSync->m_pWabItems, dwIndex);
            
            if (dwIndex == 0)
                break;
        }
    }

}

HRESULT WABSync_DoConflicts(LPWABSYNC pWabSync)
{
    LONG                dwIndex, cConflicts = 0, cItems = Vector_GetLength(pWabSync->m_pOps);
    LPHOTSYNCOP         pOp;
    LPHTTPCONFLICTINFO  pConflicts = NULL;
    if (cItems == 0)
    {
        WABSync_NextState(pWabSync);
        return S_OK;
    }

    pConflicts = LocalAlloc(LMEM_ZEROINIT, sizeof(HTTPCONFLICTINFO) * cItems);
    if (!pConflicts)
        return E_OUTOFMEMORY;

    for (dwIndex = 0; dwIndex < cItems; dwIndex++)
    {
        pOp = Vector_GetItem(pWabSync->m_pOps, dwIndex);
        Assert(pOp->m_bOpType == SYNCOP_CONFLICT);
        
        if (!pOp || pOp->m_bOpType != SYNCOP_CONFLICT)
           continue;

        Assert(pOp->m_pServerContact);
        Assert(pOp->m_pClientContact);

        pConflicts[dwIndex].pciServer = pOp->m_pServerContact;
        pConflicts[dwIndex].pciClient = pOp->m_pClientContact;
        cConflicts++;
    }

    if (ResolveConflicts(pWabSync->m_hParentWnd, pConflicts, cConflicts))
    {
        HRESULT hr = S_OK;
        for (dwIndex = 0; dwIndex < cConflicts; dwIndex++)
        {
            BOOL    fChanged = FALSE;
            DWORD   dw;

            pOp = Vector_GetItem(pWabSync->m_pOps, dwIndex);
            Assert(pOp->m_bOpType == SYNCOP_CONFLICT);
        
            Assert(pOp->m_pServerContact);
            Assert(pOp->m_pClientContact);
            
            for (dw = 0; dw < CONFLICT_DECISION_COUNT; dw++)
            {
                if (pConflicts[dwIndex].rgcd[dw] != 0)
                {
                    fChanged = TRUE;
                    break;
                }
            }

            if (fChanged)
 