	pointer to bytes
typedef ULONG		*PUL;		//	pointer to unsigned longs
typedef ULONG		 FID;		//  field identifier
typedef FID			*PFID;		//  pointer to a field identifier

//	Definitions that undoubtedly belong somewhere in some internal header
//	file other than this one, but are put here for the sake of simplicity.

typedef char		*SZ;		//	null terminated string

#define		fFalse		0
#define		fTrue		1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_glheap.h ===
/*
 * glheap.h
 *
 * Private definitions for GLHEAP facility
 *
 * Copyright (C) 1994 Microsoft Corporation
 */

#ifndef _GLHEAP_H_
#define _GLHEAP_H_

#ifndef __GLHEAP_H_
#include "_glheap.h"
#endif

#if defined (WIN32) && !defined (MAC) && !defined(_WIN64)
#define HEAPMON
#endif

#define chDefaultFill	((BYTE)0xFE)
#define NCALLERS		20

typedef struct LH		LH,		* PLH,		** PPLH;
typedef struct LHBLK	LHBLK,	* PLHBLK,	** PPLHBLK;

#ifdef HEAPMON
typedef BOOL (APIENTRY HEAPMONPROC)(PLH plh, ULONG ulFlags);
typedef HEAPMONPROC FAR *LPHEAPMONPROC;
typedef BOOL (APIENTRY GETSYMNAMEPROC)(DWORD, LPSTR, LPSTR, DWORD FAR *);
typedef GETSYMNAMEPROC FAR *LPGETSYMNAMEPROC;

#define HEAPMON_LOAD		((ULONG) 0x00000001)
#define HEAPMON_UNLOAD		((ULONG) 0x00000002)
#define HEAPMON_PING		((ULONG) 0x00000003)
#endif

#define HEAP_USE_VIRTUAL		((ULONG) 0x00000001)
#define HEAP_DUMP_LEAKS			((ULONG) 0x00000002)
#define HEAP_ASSERT_LEAKS		((ULONG) 0x00000004)
#define HEAP_FILL_MEM			((ULONG) 0x00000008)
#define HEAP_HEAP_MONITOR		((ULONG) 0x00000010)
#define HEAP_USE_VIRTUAL_4		((ULONG) 0x00000020)
#define HEAP_FAILURES_ENABLED	((ULONG) 0x00000040)
#define HEAP_LOCAL				((ULONG) 0x10000000)
#define HEAP_GLOBAL				((ULONG) 0x20000000)


typedef void (__cdecl *LPLHSETNAME)(LPVOID, char *, ...);

struct LHBLK
{
	HLH			hlh;			// Heap this block was allocated on
	PLHBLK		plhblkPrev;		// Pointer to the previous allocation this heap
	PLHBLK		plhblkNext;		// Pointer to the next allocation this heap
	TCHAR		szName[128];		// We can name blocks allocated on a heap
	ULONG		ulAllocNum;		// Allocation number (Id) for this block
	ULONG		ulSize;			// Number of bytes the client requested
	FARPROC		pfnCallers[NCALLERS]; // Call stack during this allocation
	LPVOID		pv;				// Pointer to the client data
};

struct LH
{
	LPLHSETNAME	pfnSetName;		// Pointer to LH_SetNameFn function
	_HLH		_hlhData;		// The underlying heap that we alloc data from
	_HLH		_hlhBlks;		// The underlying heap that we alloc lhblks from
	PLH			pNext;			// Pointer to the next heap in a list of heaps
	TCHAR		szHeapName[32];	// We can name our heaps for display purposes
	ULONG		ulAllocNum;		// Allocation number this heap since Open
	PLHBLK		plhblkHead;		// Link-list of allocations on this heap
	ULONG		ulFlags;		// Combination of the HEAP_ flags above
	BYTE		chFill;			// Character to fill memory with
#ifdef HEAPMON
	HINSTANCE	hInstHeapMon;	// DLL instance of the HeapMonitor DLL
	LPHEAPMONPROC pfnHeapMon;	// Entry point into HeapMonitor DLL
#endif
#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION cs;		// Critcal section to protect access to heap
#endif
	UINT		uiFailBufSize;	// If HEAP_FAILURES_ENABLED, this is the minimum size in
								// which failures occur.  1 means alloc's of any size fail.
								// 0 means never fail.
	ULONG		ulFailInterval;	// If HEAP_FAILURES_ENABLED, this is the period on which the
								// failures occur.  1 means every alloc will fail. 0 means never
								// fail.
	ULONG		ulFailStart;	// If HEAP_FAILURES_ENABLED, this is the allocation number that
								// the first failure will occur on.  1 means the first alloc.  0
								// means never start failing.	
	// Put at end to avoid re-compile of World!
#ifdef HEAPMON
	LPGETSYMNAMEPROC pfnGetSymName;	// Resolve address to Symbol
#endif
};

PLHBLK	PvToPlhblk(HLH hlh, LPVOID pv);
#define PlhblkToPv(pblk)		((LPVOID)((PLHBLK)(pblk)->pv))
#define CbPlhblkClient(pblk)	(((PLHBLK)(pblk))->ulSize)
#define CbPvClient(hlh, pv)		(CbPlhblkClient(PvToPlhblk(hlh, pv)))
#define CbPvAlloc(hlh, pv)		(CbPlhblkAlloc(PvToPlhblk(hlh, pv)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_errctx.h ===
/***********************************************************************
 *
 * _ERRCTX.H
 *
 * Error contexts defines for MAPI Components.
 *
 * Copyright 1992-95 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*********
VIKRAMM 10/10/98
I don't have a clue what this file is about - in 3 years this is the first
time I've looked in it .. 
But don't delete it since we don't know what it does
*********/


/*
 * Names for defines are of the following form:
 *
 * CONT_ ==> abbreviation for Error Context
 * <object type>_ ==> will be either SESS, SUPP, ADDR, OOP, PRP, BASE
 * <abbreviated method name>_ ==> an abbreviated form of the method
 * <index> ==> starts at 1, and grows to as many contexts as are needed
 *
 *	Example: CONT_SESS_GETMSTABLE_1 is the first error context define for
 *		IMAPISession::GetMessageStoresTable.
 */

/* Base number that all contexts are offset from. */
#define MAPIX_CONTEXT_BASE			(0x0200)

/* Multiplier to separate each section. Note that this means that this */
/* mechanism only allows 0x20 (32) contexts per section. */
#define MAPIX_CONTEXT_MULT			(0x20)

#define OFFSET_CONTEXT(a,b)			\
		(((a)*MAPIX_CONTEXT_MULT) + ((b) + MAPIX_CONTEXT_BASE))


//	The following context groups belong to IMAPISession methods.

#define CONT_SESS_GETMSTABLE_1		OFFSET_CONTEXT(0, 0)
#define CONT_SESS_GETMSTABLE_2		OFFSET_CONTEXT(0, 1)
#define CONT_SESS_GETMSTABLE_3		OFFSET_CONTEXT(0, 2)
#define CONT_SESS_GETMSTABLE_4		OFFSET_CONTEXT(0, 3)

#define CONT_SESS_OPENAB_1			OFFSET_CONTEXT(1, 0)
#define CONT_SESS_OPENAB_2			OFFSET_CONTEXT(1, 1)
#define CONT_SESS_OPENAB_3			OFFSET_CONTEXT(1, 2)

#define CONT_SESS_ADVISE_1			OFFSET_CONTEXT(2, 0)
#define CONT_SESS_ADVISE_2			OFFSET_CONTEXT(2, 1)
#define CONT_SESS_ADVISE_3			OFFSET_CONTEXT(2, 2)
#define CONT_SESS_ADVISE_4			OFFSET_CONTEXT(2, 3)
#define CONT_SESS_ADVISE_5			OFFSET_CONTEXT(2, 4)
#define CONT_SESS_ADVISE_6			OFFSET_CONTEXT(2, 5)

#define CONT_SESS_UNADVISE_1		OFFSET_CONTEXT(3, 0)

#define CONT_SESS_OPENMS_1			OFFSET_CONTEXT(4, 0)
#define CONT_SESS_OPENMS_2			OFFSET_CONTEXT(4, 1)
#define CONT_SESS_OPENMS_3			OFFSET_CONTEXT(4, 2)
#define CONT_SESS_OPENMS_4			OFFSET_CONTEXT(4, 3)
#define CONT_SESS_OPENMS_5			OFFSET_CONTEXT(4, 4)
#define CONT_SESS_OPENMS_6			OFFSET_CONTEXT(4, 5)
#define CONT_SESS_OPENMS_7			OFFSET_CONTEXT(4, 6)
#define CONT_SESS_OPENMS_8			OFFSET_CONTEXT(4, 7)
#define CONT_SESS_OPENMS_9			OFFSET_CONTEXT(4, 8)
#define CONT_SESS_OPENMS_10			OFFSET_CONTEXT(4, 9)
#define CONT_SESS_OPENMS_11			OFFSET_CONTEXT(4, 10)
#define CONT_SESS_OPENMS_12			OFFSET_CONTEXT(4, 11)
#define CONT_SESS_OPENMS_13			OFFSET_CONTEXT(4, 12)

#define CONT_SESS_SETDEFMS_1		OFFSET_CONTEXT(5, 0)
#define CONT_SESS_SETDEFMS_2		OFFSET_CONTEXT(5, 1)
#define CONT_SESS_SETDEFMS_3		OFFSET_CONTEXT(5, 2)
#define CONT_SESS_SETDEFMS_4		OFFSET_CONTEXT(5, 3)
#define CONT_SESS_SETDEFMS_5		OFFSET_CONTEXT(5, 4)

#define CONT_SESS_GETSTATTBL_1		OFFSET_CONTEXT(6, 0)
#define CONT_SESS_GETSTATTBL_2		OFFSET_CONTEXT(6, 1)

#define CONT_SESS_MSGOPT_1			OFFSET_CONTEXT(7, 0)
#define CONT_SESS_MSGOPT_2			OFFSET_CONTEXT(7, 1)
#define CONT_SESS_MSGOPT_3			OFFSET_CONTEXT(7, 2)
#define CONT_SESS_MSGOPT_4			OFFSET_CONTEXT(7, 3)
#define CONT_SESS_MSGOPT_5			OFFSET_CONTEXT(7, 4)
#define CONT_SESS_MSGOPT_6			OFFSET_CONTEXT(7, 5)
#define CONT_SESS_MSGOPT_7			OFFSET_CONTEXT(7, 6)
#define CONT_SESS_MSGOPT_8			OFFSET_CONTEXT(7, 7)

#define CONT_SESS_OPENPROF_1		OFFSET_CONTEXT(8, 0)
#define CONT_SESS_OPENPROF_2		OFFSET_CONTEXT(8, 1)

#define CONT_SESS_COMPEID_1			OFFSET_CONTEXT(9, 0)
#define CONT_SESS_COMPEID_2			OFFSET_CONTEXT(9, 1)

#define CONT_SESS_OPENENTRY_1		OFFSET_CONTEXT(10, 0)
#define CONT_SESS_OPENENTRY_2		OFFSET_CONTEXT(10, 1)
#define CONT_SESS_OPENENTRY_3		OFFSET_CONTEXT(10, 2)
#define CONT_SESS_OPENENTRY_4		OFFSET_CONTEXT(10, 3)
#define CONT_SESS_OPENENTRY_5		OFFSET_CONTEXT(10, 4)
#define CONT_SESS_OPENENTRY_6		OFFSET_CONTEXT(10, 5)
#define CONT_SESS_OPENENTRY_7		OFFSET_CONTEXT(10, 6)
#define CONT_SESS_OPENENTRY_8		OFFSET_CONTEXT(10, 7)
#define CONT_SESS_OPENENTRY_9		OFFSET_CONTEXT(10, 8)
#define CONT_SESS_OPENENTRY_10		OFFSET_CONTEXT(10, 9)
#define CONT_SESS_OPENENTRY_11		OFFSET_CONTEXT(10, 10)

#define CONT_SESS_QDEFMSGOPTS_1		OFFSET_CONTEXT(11, 0)
#define CONT_SESS_QDEFMSGOPTS_2		OFFSET_CONTEXT(11, 1)

#define CONT_SESS_ENUMATYPES_1		OFFSET_CONTEXT(12, 0)
#define CONT_SESS_ENUMATYPES_2		OFFSET_CONTEXT(12, 1)

#define CONT_SESS_QID_1				OFFSET_CONTEXT(13, 0)
#define CONT_SESS_QID_2				OFFSET_CONTEXT(13, 1)
#define CONT_SESS_QID_3				OFFSET_CONTEXT(13, 2)
#define CONT_SESS_QID_4				OFFSET_CONTEXT(13, 3)
#define CONT_SESS_QID_5				OFFSET_CONTEXT(13, 4)

#define CONT_SESS_ADMINSVCS_1		OFFSET_CONTEXT(14, 0)

#define CONT_SESS_SENDNOTE_1		OFFSET_CONTEXT(15, 0)
#define CONT_SESS_SENDNOTE_2		OFFSET_CONTEXT(15, 1)

// The INITPROV context group is used by MDBInitProvider in mdbsup.c. Both
// IMAPISession::OpenMsgStore and IMAPISession::SetDefaultStore call this.

#define CONT_SESS_INITPROV_1		OFFSET_CONTEXT(16, 0)
#define CONT_SESS_INITPROV_2		OFFSET_CONTEXT(16, 1)
#define CONT_SESS_INITPROV_3		OFFSET_CONTEXT(16, 2)
#define CONT_SESS_INITPROV_4		OFFSET_CONTEXT(16, 3)
#define CONT_SESS_INITPROV_5		OFFSET_CONTEXT(16, 4)
#define CONT_SESS_INITPROV_6		OFFSET_CONTEXT(16, 5)
#define CONT_SESS_INITPROV_7		OFFSET_CONTEXT(16, 6)

// The following context groups are used in the default profile provider
// which is built into MAPI.

#define CONT_PRP_OPENPROFILE_1		OFFSET_CONTEXT(17, 1)
#define CONT_PRP_OPENPROFILE_2		OFFSET_CONTEXT(17, 2)
#define CONT_PRP_OPENPROFILE_3		OFFSET_CONTEXT(17, 3)
#define CONT_PRP_OPENPROFILE_4		OFFSET_CONTEXT(17, 3)
#define CONT_PRP_CREATEPROFILE_1	OFFSET_CONTEXT(17, 5)
#define CONT_PRP_CREATEPROFILE_2	OFFSET_CONTEXT(17, 6)
#define CONT_PRP_CREATEPROFILE_3	OFFSET_CONTEXT(17, 7)
#define CONT_PRP_DELETEPROFILE_1	OFFSET_CONTEXT(17, 8)
#define CONT_PRP_DELETEPROFILE_2	OFFSET_CONTEXT(17, 9)
#define CONT_PRP_DELETEPROFILE_3	OFFSET_CONTEXT(17, 10)
#define CONT_PRP_DELETEPROFILE_4	OFFSET_CONTEXT(17, 11)
#define CONT_PRP_DELETEPROFILE_5	OFFSET_CONTEXT(17, 12)
#define CONT_PRP_DELETEPROFILE_6	OFFSET_CONTEXT(17, 13)
#define CONT_PRP_CHANGEPW_1			OFFSET_CONTEXT(17, 14)
#define CONT_PRP_CHANGEPW_2			OFFSET_CONTEXT(17, 15)
#define CONT_PRP_CHANGEPW_3			OFFSET_CONTEXT(17, 16)
#define CONT_PRP_CHANGEPW_4			OFFSET_CONTEXT(17, 17)
#define CONT_PRP_CHANGEPW_5			OFFSET_CONTEXT(17, 18)
#define CONT_PRP_CHANGEPW_6			OFFSET_CONTEXT(17, 19)
#define CONT_PRP_GETTABLE_1			OFFSET_CONTEXT(17, 20)
#define CONT_PRP_GETTABLE_2			OFFSET_CONTEXT(17, 21)
#define CONT_PRP_COPYPROFILE_1		OFFSET_CONTEXT(17, 22)
#define CONT_PRP_COPYPROFILE_2		OFFSET_CONTEXT(17, 23)
#define CONT_PRP_COPYPROFILE_3		OFFSET_CONTEXT(17, 24)
#define CONT_PRP_COPYPROFILE_4		OFFSET_CONTEXT(17, 25)
#define CONT_PRP_COPYPROFILE_5		OFFSET_CONTEXT(17, 26)
#define CONT_PRP_COPYPROFILE_6		OFFSET_CONTEXT(17, 27)
#define CONT_PRP_COPYPROFILE_7		OFFSET_CONTEXT(17, 28)
#define CONT_PRP_COPYPROFILE_8		OFFSET_CONTEXT(17, 29)

#define CONT_PRP_RENAMEPROFILE_1	OFFSET_CONTEXT(18, 1)
#define CONT_PRP_RENAMEPROFILE_2	OFFSET_CONTEXT(18, 2)
#define CONT_PRP_RENAMEPROFILE_3	OFFSET_CONTEXT(18, 3)
#define CONT_PRP_RENAMEPROFILE_4	OFFSET_CONTEXT(18, 4)
#define CONT_PRP_SETDEFAULT_1		OFFSET_CONTEXT(18, 5)
#define CONT_PRP_SETDEFAULT_2		OFFSET_CONTEXT(18, 6)

#define CONT_PSESS_OPENSECTION_1	OFFSET_CONTEXT(18, 7)

#define CONT_PROF_GETPROPS_1		OFFSET_CONTEXT(19, 1)
#define CONT_PROF_GETPROPS_2		OFFSET_CONTEXT(19, 2)
#define CONT_PROF_GETPROPS_3		OFFSET_CONTEXT(19, 3)
#define CONT_PROF_GETPROPLIST_1		OFFSET_CONTEXT(19, 4)
#define CONT_PROF_GETPROPLIST_2		OFFSET_CONTEXT(19, 5)
#define CONT_PROF_GETPROPLIST_3		OFFSET_CONTEXT(19, 6)
#define CONT_PROF_GETPROPLIST_4		OFFSET_CONTEXT(19, 7)
#define CONT_PROF_OPENPROPERTY_1	OFFSET_CONTEXT(19, 8)
#define CONT_PROF_SETPROPS_1		OFFSET_CONTEXT(19, 9)
#define CONT_PROF_SETPROPS_2		OFFSET_CONTEXT(19, 10)
#define CONT_PROF_SETPROPS_3		OFFSET_CONTEXT(19, 11)
#define CONT_PROF_DELETEPROPS_1		OFFSET_CONTEXT(19, 12)
#define CONT_PROF_DELETEPROPS_2		OFFSET_CONTEXT(19, 13)
#define CONT_PROF_COPYTO_1			OFFSET_CONTEXT(19, 14)
#define CONT_PROF_COPYTO_2			OFFSET_CONTEXT(19, 15)
#define CONT_PROF_COPYPROPS_1		OFFSET_CONTEXT(19, 16)
#define CONT_PROF_COPYPROPS_2		OFFSET_CONTEXT(19, 17)
#define CONT_PROF_GETNAMEID_1		OFFSET_CONTEXT(19, 18)
#define CONT_PROF_GETIDNAME_1		OFFSET_CONTEXT(19, 19)

//	The following context groups belong to the IProfAdmin interface.

#define CONT_IPA_RENAME_1			OFFSET_CONTEXT(20, 1)


//	The following context groups belong to the IMsgServiceAdmin interface.

#define CONT_ISA_CREATE_1			OFFSET_CONTEXT(21, 1)
#define CONT_ISA_CREATE_2			OFFSET_CONTEXT(21, 2)
#define CONT_ISA_COPY_1				OFFSET_CONTEXT(21, 3)


//	The following context groups belong to base MAPI functions.

#define CONT_BASE_LOGON_1			OFFSET_CONTEXT(22, 1)
#define CONT_BASE_LOGON_2			OFFSET_CONTEXT(22, 2)
#define CONT_BASE_LOGON_3			OFFSET_CONTEXT(22, 3)
#define CONT_BASE_LOGON_4			OFFSET_CONTEXT(22, 4)
#define CONT_BASE_LOGON_5			OFFSET_CONTEXT(22, 5)
#define CONT_BASE_LOGON_6			OFFSET_CONTEXT(22, 6)
#define CONT_BASE_LOGON_7			OFFSET_CONTEXT(22, 7)
#define CONT_BASE_LOGON_8			OFFSET_CONTEXT(22, 8)
#define CONT_BASE_LOGON_9			OFFSET_CONTEXT(22, 9)
#define CONT_BASE_LOGON_10			OFFSET_CONTEXT(22, 10)

//	The following context groups belong to MAPI Support functions.

#define CONT_SUPP_EXPANDRECIPS_1	OFFSET_CONTEXT(23, 1)
#define CONT_SUPP_EXPANDRECIPS_2	OFFSET_CONTEXT(23, 2)
#define CONT_SUPP_EXPANDRECIPS_3	OFFSET_CONTEXT(23, 3)
#define CONT_SUPP_EXPANDRECIPS_4	OFFSET_CONTEXT(23, 4)
#define CONT_SUPP_EXPANDRECIPS_5	OFFSET_CONTEXT(23, 5)
#define CONT_SUPP_EXPANDRECIPS_6	OFFSET_CONTEXT(23, 6)

#define CONT_SUPP_READRECEIPT_1		OFFSET_CONTEXT(24, 1)
#define CONT_SUPP_READRECEIPT_2		OFFSET_CONTEXT(24, 2)
#define CONT_SUPP_READRECEIPT_3		OFFSET_CONTEXT(24, 3)
#define CONT_SUPP_READRECEIPT_4		OFFSET_CONTEXT(24, 4)
#define CONT_SUPP_READRECEIPT_5		OFFSET_CONTEXT(24, 5)
#define CONT_SUPP_READRECEIPT_6		OFFSET_CONTEXT(24, 6)
#define CONT_SUPP_READRECEIPT_7		OFFSET_CONTEXT(24, 7)

#define CONT_SUPP_PREPARESUBMIT_1	OFFSET_CONTEXT(25, 1)

#define CONT_SUPP_SPOOLERNOTIFY_1	OFFSET_CONTEXT(26, 1)

#define CONT_SUPP_MODIFYPROFILE_1	OFFSET_CONTEXT(27, 1)
#define CONT_SUPP_MODIFYPROFILE_2	OFFSET_CONTEXT(27, 2)
#define CONT_SUPP_MODIFYPROFILE_3	OFFSET_CONTEXT(27, 3)
#define CONT_SUPP_MODIFYPROFILE_4	OFFSET_CONTEXT(27, 4)
#define CONT_SUPP_MODIFYPROFILE_5	OFFSET_CONTEXT(27, 5)
#define CONT_SUPP_MODIFYPROFILE_6	OFFSET_CONTEXT(27, 6)

#define CONT_SUPP_STORELOGOFFTRANSPORTS_1	OFFSET_CONTEXT(28, 1)
#define CONT_SUPP_STORELOGOFFTRANSPORTS_2	OFFSET_CONTEXT(28, 2)
#define CONT_SUPP_STORELOGOFFTRANSPORTS_3	OFFSET_CONTEXT(28, 3)

#define CONT_SUPP_OPENPROFILESECTION_1	OFFSET_CONTEXT(29, 1)
#define CONT_SUPP_OPENPROFILESECTION_2	OFFSET_CONTEXT(29, 2)

#define CONT_SUPP_MODIFYSTATUSROW_1		OFFSET_CONTEXT(30, 1)

#define CONT_SUPP_NEWUID_1				OFFSET_CONTEXT(31, 1)

#define CONT_SUPP_CREATEONEOFF_1		OFFSET_CONTEXT(32, 1)

#define CONT_SUPP_SETPROVIDERUID_1		OFFSET_CONTEXT(33, 1)

#define CONT_SUPP_GETSVCCONFIGSPTOBJ_1	OFFSET_CONTEXT(34, 1)

#define CONT_SUPP_SUBSCRIBE_1			OFFSET_CONTEXT(35, 1)

#define CONT_SUPP_UNSUBSCRIBE_1			OFFSET_CONTEXT(36, 1)

#define CONT_SUPP_NOTIFY_1				OFFSET_CONTEXT(37, 1)

// PAB contexts

#define CONT_PAB_RECIP_1				OFFSET_CONTEXT(38, 1)
#define CONT_PAB_RECIP_2				OFFSET_CONTEXT(38, 2)
#define CONT_PAB_RECIP_3				OFFSET_CONTEXT(38, 3)
#define CONT_PAB_RECIP_4				OFFSET_CONTEXT(38, 4)

#define CONT_PAB_DIR_1					OFFSET_CONTEXT(38, 5)
#define CONT_PAB_DIR_2					OFFSET_CONTEXT(38, 6)
#define CONT_PAB_DIR_3					OFFSET_CONTEXT(38, 7)
#define CONT_PAB_DIR_4					OFFSET_CONTEXT(38, 10)
#define CONT_PAB_DIR_5					OFFSET_CONTEXT(38, 11)

#define CONT_PAB_DL_1					OFFSET_CONTEXT(38, 8)

#define CONT_PAB_DB_1					OFFSET_CONTEXT(38, 9)

#define CONT_PAB_TOO_BIG_FOR_WIN16		OFFSET_CONTEXT(38, 12)

#define CONT_PAB_CORRUPT_RPC_ROW_MISSING_DISPLAY_NAME	OFFSET_CONTEXT(38, 20)


// The following contexts are meant to be only error contexts.  They
// should not be converted or used as Help file contexts

// NDB.2 Error contexts (ulContext) -------------------------------------------------

#if defined ( _NDB_H_ )

#define EC_NDB_MIN											0x10000000

#define EC_NDB_AMAP_AMAPALLOC								0x10010101
#define EC_NDB_AMAP_AMAPFREE								0x10010201
#define EC_NDB_AMAP_AMAPWRITE_1								0x10010301
#define EC_NDB_AMAP_AMAPWRITE_2								0x10010302
#define EC_NDB_AMAP_PMAPALLOC								0x10010401
#define EC_NDB_AMAP_PMAPWRITE								0x10010501
#define EC_NDB_AMAP_AMAPREBUILDBEGIN						0x10010601
#define EC_NDB_AMAP_AMAPREBUILDFINISH						0x10010701

#define EC_NDB_BBTREE_BBTADDREF								0x10020101
#define EC_NDB_BBTREE_BBTRELEASEFOREACH						0x10020201
#define EC_NDB_BBTREE_BBTFREEANDREMOVE						0x10020301

#define EC_NDB_BCACHE_BCREADFILE_1							0x10030101
#define EC_NDB_BCACHE_BCREADFILE_2							0x10030102
#define EC_NDB_BCACHE_BCWRITE								0x10030201
#define EC_NDB_BCACHE_BCWRITEFILE							0x10030301
#define EC_NDB_BCACHE_BCREALLOC								0x10030401
#define EC_NDB_BCACHE_BCGROW_1								0x10030501
#define EC_NDB_BCACHE_BCGROW_2								0x10030502
#define EC_NDB_BCACHE_BCRELEASEFOREACH						0x10030601
#define EC_NDB_BCACHE_BCRELEASESETRELEASED					0x10030701
#define EC_NDB_BCACHE_BCSETRELEASED							0x10030801
#define EC_NDB_BCACHE_BCSAVEFOREACH							0x10030901
#define EC_NDB_BCACHE_BCFLUSH								0x10030C01
#define EC_NDB_BCACHE_BCVALIDATE_1							0x10030D01
#define EC_NDB_BCACHE_BCVALIDATE_2							0x10030D02
#define EC_NDB_BCACHE_BCVALIDATE_3							0x10030D03
#define EC_NDB_BCACHE_BCVALIDATE_4							0x10030D04
#define EC_NDB_BCACHE_BCVALIDATE_5							0x10030D05
#define EC_NDB_BCACHE_BCVALIDATE_6							0x10030D06
#define EC_NDB_BCACHE_BCVALIDATE_7							0x10030D07
#define EC_NDB_BCACHE_BCVALIDATE_8							0x10030D08
#define EC_NDB_BCACHE_BCVALIDATE_9							0x10030D09
#define EC_NDB_BCACHE_BCVALIDATE_10							0x10030D0A
#define EC_NDB_BCACHE_BCVALIDATE_11							0x10030D0B
#define EC_NDB_BCACHE_BCVALIDATE_12							0x10030D0C
#define EC_NDB_BCACHE_BCVALIDATE_13							0x10030D0D
#define EC_NDB_BCACHE_BCVALIDATE_14							0x10030D0E
#define EC_NDB_BCACHE_BCVALIDATE_15							0x10030D0F
#define EC_NDB_BCACHE_BCSETHOLD								0x10030E01
#define EC_NDB_BCACHE_HVGROW								0x10030F01

#define EC_NDB_BTREE_BTLOOKUP								0x10040101
#define EC_NDB_BTREE_BTREMOVE								0x10040201
#define EC_NDB_BTREE_BTLOOKUPPATH							0x10040301

#define EC_NDB_DATABASE_NDB_OPENDATABASE_1					0x10050101
#define EC_NDB_DATABASE_NDB_OPENDATABASE_2					0x10050102
#define EC_NDB_DATABASE_NDB_OPENDATABASE_3					0x10050103
#define EC_NDB_DATABASE_OPENDATABASE_1						0x10050201
#define EC_NDB_DATABASE_OPENDATABASE_2						0x10050202
#define EC_NDB_DATABASE_OPENDATABASE_3						0x10050203
#define EC_NDB_DATABASE_OPENDATABASE_4						0x10050204
#define EC_NDB_DATABASE_NDB_OPENNODE						0x10050301
#define EC_NDB_DATABASE_DELETENODETRANSACT_1				0x10050401
#define EC_NDB_DATABASE_DELETENODETRANSACT_2				0x10050402
#define EC_NDB_DATABASE_QUERYNODE							0x10050501
#define EC_NDB_DATABASE_NDB_COMMITTRANSACTION_1				0x10050601
#define EC_NDB_DATABASE_NDB_COMMITTRANSACTION_2				0x10050602
#define EC_NDB_DATABASE_NDB_COMMITTRANSACTION_3				0x10050603
#define EC_NDB_DATABASE_SETPARENTNIDTRANSACT_1				0x10050701
#define EC_NDB_DATABASE_GETCACHESIZES						0x10050801
#define EC_NDB_DATABASE_WAITFORMUTEX_1						0x10050901
#define EC_NDB_DATABASE_WAITFORMUTEX_2						0x10050902
#define EC_NDB_DATABASE_WAITFORMUTEX_3						0x10050903
#define EC_NDB_DATABASE_WAITFORMUTEX_4						0x10050904
#define EC_NDB_DATABASE_WAITFORMUTEX_5						0x10050805
#define EC_NDB_DATABASE_WAITFORMUTEX_6						0x10050806
#define EC_NDB_DATABASE_WAITFORMUTEX_7						0x10050807

#define EC_NDB_FILE_32_FILEOPEN								0x10060101
#define EC_NDB_FILE_32_FILEREAD_1							0x10060201
#define EC_NDB_FILE_32_FILEREAD_2							0x10060202
#define EC_NDB_FILE_32_FILEREAD_3							0x10060203
#define EC_NDB_FILE_32_FILEWRITE_1							0x10060301
#define EC_NDB_FILE_32_FILEWRITE_2							0x10060302
#define EC_NDB_FILE_32_FILEWRITE_3							0x10060303
#define EC_NDB_FILE_32_FILEGETEOF							0x10060401
#define EC_NDB_FILE_32_FILESETEOF_1							0x10060501
#define EC_NDB_FILE_32_FILESETEOF_2							0x10060502
#define EC_NDB_FILE_32_FILEFLUSH							0x10060601
#define EC_NDB_FILE_32_FILEDELETE							0x10060701
#define EC_NDB_FILE_32_FILELOCK								0x10060801
#define EC_NDB_FILE_16_FILEOPEN_1							0x10061101
#define EC_NDB_FILE_16_FILEOPEN_2							0x10061102
#define EC_NDB_FILE_16_FILEREAD_1							0x10061201
#define EC_NDB_FILE_16_FILEREAD_2							0x10061202
#define EC_NDB_FILE_16_FILEREAD_3							0x10061203
#define EC_NDB_FILE_16_FILEWRITE_1							0x10061301
#define EC_NDB_FILE_16_FILEWRITE_2							0x10061302
#define EC_NDB_FILE_16_FILEWRITE_3							0x10061303
#define EC_NDB_FILE_16_FILEGETEOF							0x10061401
#define EC_NDB_FILE_16_FILESETEOF_1							0x10061501
#define EC_NDB_FILE_16_FILESETEOF_2							0x10061502
#define EC_NDB_FILE_16_FILESETEOF_3							0x10061503
#define EC_NDB_FILE_16_FILESETEOF_4							0x10061504
#define EC_NDB_FILE_16_FILESETEOF_5							0x10061505
#define EC_NDB_FILE_16_FILESETEOF_6							0x10061506
#define EC_NDB_FILE_16_FILEFLUSH							0x10061601
#define EC_NDB_FILE_16_FILEDELETE							0x10061701
#define EC_NDB_FILE_16_FILELOCK								0x10061801

#define EC_NDB_IDLETASK_INITIDLETASK_1						0x10070101
#define EC_NDB_IDLETASK_INITIDLETASK_2						0x10070102

#define EC_NDB_LNTABLE_LNLOOKUP								0x10080101
#define EC_NDB_LNTABLE_LNGROW_1								0x10080201
#define EC_NDB_LNTABLE_LNGROW_2								0x10080202
#define EC_NDB_LNTABLE_LNREMOVE								0x10080301

#define EC_NDB_NBTREE_NBTLOOKUP								0x10090101
#define EC_NDB_NBTREE_NBTREMOVE								0x10090201

#define EC_NDB_NODE_CANSAVECHANGES_1						0x100A0101
#define EC_NDB_NODE_CANSAVECHANGES_2						0x100A0102
#define EC_NDB_NODE_CANSAVECHANGES_3						0x100A0103

#define EC_NDB_PCACHE_VALIDATE_1							0x100B0101
#define EC_NDB_PCACHE_VALIDATE_2							0x100B0102
#define EC_NDB_PCACHE_VALIDATE_3							0x100B0103
#define EC_NDB_PCACHE_VALIDATE_4							0x100B0104
#define EC_NDB_PCACHE_VALIDATE_5							0x100B0105
#define EC_NDB_PCACHE_VALIDATE_6							0x100B0106
#define EC_NDB_PCACHE_VALIDATE_7							0x100B0107
#define EC_NDB_PCACHE_LOOKUP_1								0x100B0201
#define EC_NDB_PCACHE_LOOKUP_2								0x100B0202
#define EC_NDB_PCACHE_LOOKUP_3								0x100B0203
#define EC_NDB_PCACHE_LOOKUP_4								0x100B0204
#define EC_NDB_PCACHE_READ									0x100B0301
#define EC_NDB_PCACHE_PCACQUIREPAGE							0x100B0401
#define EC_NDB_PCACHE_PCPURGEPAGE							0x100B0501
#define EC_NDB_PCACHE_PCGETPAGE								0x100B0601

#define EC_NDB_SBLOCK_SBLOOKUP								0x100C0101
#define EC_NDB_SBLOCK_SBINSERT								0x100C0201
#define EC_NDB_SBLOCK_SBUPDATE								0x100C0301
#define EC_NDB_SBLOCK_SBREMOVE_1							0x100C0401
#define EC_NDB_SBLOCK_SBREMOVE_2							0x100C0402
#define EC_NDB_SBLOCK_SBINSERTPATH							0x100C0501
#define EC_NDB_SBLOCK_SBFOREACH_1							0x100C0601
#define EC_NDB_SBLOCK_SBFOREACH_2							0x100C0602

#define EC_NDB_SHARED_INITSHAREDDATABASE_1					0x100D0101
#define EC_NDB_SHARED_INITSHAREDDATABASE_2					0x100D0102
#define EC_NDB_SHARED_INITSHAREDDATABASE_3					0x100D0103
#define EC_NDB_SHARED_INITSHAREDDATABASE_4					0x100D0104
#define EC_NDB_SHARED_INITSHAREDDATABASE_5					0x100D0105
#define EC_NDB_SHARED_INITSHAREDDATABASE_6					0x100D0106
#define EC_NDB_SHARED_INITSHAREDDATABASE_7					0x100D0107
#define EC_NDB_SHARED_OPENSHAREDDATABASE_1					0x100D0201
#define EC_NDB_SHARED_OPENSHAREDDATABASE_2					0x100D0202
#define EC_NDB_SHARED_OPENSHAREDDATABASE_3					0x100D0203
#define EC_NDB_SHARED_GRABFIRSTLOCK							0x100D0301
#define EC_NDB_SHARED_GRABFILELOCK							0x100D0401
#define EC_NDB_SHARED_GROWSHAREDDATABASE					0x100D0501
#define EC_NDB_SHARED_RECONNECTDATABASE_1					0x100D0601
#define EC_NDB_SHARED_RECONNECTDATABASE_2					0x100D0602
#define EC_NDB_SHARED_RECONNECTDATABASE_3					0x100D0603
#define EC_NDB_SHARED_RECONNECTDATABASE_4					0x100D0604

#define EC_NDB_UPDATE_READHEADER_1							0x100E0101
#define EC_NDB_UPDATE_READHEADER_2							0x100E0102
#define EC_NDB_UPDATE_READHEADER_3							0x100E0103
#define EC_NDB_UPDATE_COMMITHEADER_1						0x100E0201
#define EC_NDB_UPDATE_COMMITHEADER_2						0x100E0202

#define EC_NDB_XBLOCK_XBACCESS_1							0x100F0101
#define EC_NDB_XBLOCK_XBACCESS_2							0x100F0102
#define EC_NDB_XBLOCK_XBACCESS_3							0x100F0103
#define EC_NDB_XBLOCK_XBACCESS_4							0x100F0104
#define EC_NDB_XBLOCK_XBACCESS_5							0x100F0105
#define EC_NDB_XBLOCK_XBACCESS_6							0x100F0106
#define EC_NDB_XBLOCK_XBACCESS_7							0x100F0107
#define EC_NDB_XBLOCK_XBACCESS_8							0x100F0108
#define EC_NDB_XBLOCK_XBACCESS_9							0x100F0109
#define EC_NDB_XBLOCK_XBACCESS_10							0x100F010A
#define EC_NDB_XBLOCK_XBACCESS_11							0x100F010B
#define EC_NDB_XBLOCK_XBFOREACH_1							0x100F0201
#define EC_NDB_XBLOCK_XBFOREACH_2							0x100F0202
#define EC_NDB_XBLOCK_XBFOREACH_3							0x100F0203
#define EC_NDB_XBLOCK_XBFOREACH_4							0x100F0204
#define EC_NDB_XBLOCK_XBFOREACH_5							0x100F0205

#endif	// _NDB_H_

// LTP Error contexts (ulContext) -------------------------------------------------

#if defined ( _LTP_H_ )

#define EC_LTP_MIN											0x20000000

#define EC_LTP_BTH_A_SETROOTHID								0x20010101
#define EC_LTP_BTH_A_GETINDEXENTRY							0x20010201
#define EC_LTP_BTH_A_SETINDEXENTRY							0x20010301
#define EC_LTP_BTH_A_REMOVEROOT								0x20010401
#define EC_LTP_BTH_A_LOOKUPROOT								0x20010501
#define EC_LTP_BTH_A_LOOKUPLEAF								0x20010601
#define EC_LTP_BTH_BTHADVANCEPATH							0x20010701
#define EC_LTP_BTH_A_REKEY									0x20010801
#define EC_LTP_BTH_A_FOREACHROOT							0x20010901
#define EC_LTP_BTH_A_FOREACHLEAF							0x20010A01
#define EC_LTP_BTH_OPEN_1									0x20010B01
#define EC_LTP_BTH_OPEN_2									0x20010B02
#define EC_LTP_BTH_OPEN_3									0x20010B03
#define EC_LTP_BTH_LOOKUP									0x20010C01
#define EC_LTP_BTH_INSERT_1									0x20010D01
#define EC_LTP_BTH_INSERT_2									0x20010D02
#define EC_LTP_BTH_UPDATE									0x20010E01
#define EC_LTP_BTH_REMOVE									0x20010F01
#define EC_LTP_BTH_A_REMOVELEAF								0x20011001

#define EC_LTP_ES_SAVECHANGES								0x20020101
#define EC_LTP_ES_SETSIZE									0x20020201
#define EC_LTP_ES_READ										0x20020301
#define EC_LTP_ES_WRITE										0x20020401
#define EC_LTP_ES_MOVEDATA_1								0x20020501
#define EC_LTP_ES_MOVEDATA_2								0x20020502
#define EC_LTP_ES_COPYTO									0x20020601
#define EC_LTP_ES_ACCESS_1									0x20020701
#define EC_LTP_ES_ACCESS_2									0x20020702
#define EC_LTP_ES_RELOAD									0x20020801

#define EC_LTP_HEAP_ALLOCATE								0x20030101
#define EC_LTP_HEAP_A_ALLOCATE								0x20030201
#define EC_LTP_HEAP_REALLOCATE_1							0x20030301
#define EC_LTP_HEAP_REALLOCATE_2							0x20030302
#define EC_LTP_HEAP_A_REALLOCATE_1							0x20030401
#define EC_LTP_HEAP_A_REALLOCATE_2							0x20030402
#define EC_LTP_HEAP_FREE									0x20030501
#define EC_LTP_HEAP_A_FREE_1								0x20030601
#define EC_LTP_HEAP_A_FREE_2								0x20030602
#define EC_LTP_HEAP_ACCESS									0x20030701
#define EC_LTP_HEAP_A_ACCESS_1								0x20030801
#define EC_LTP_HEAP_A_ACCESS_2								0x20030802
#define EC_LTP_HEAP_OPEN_1									0x20030901
#define EC_LTP_HEAP_OPEN_2									0x20030902
#define EC_LTP_HEAP_SCVALIDATEPAGEHEADERFN_1				0x20030A01
#define EC_LTP_HEAP_SCVALIDATEPAGEHEADERFN_2				0x20030A02
#define EC_LTP_HEAP_SCVALIDATEPAGEHEADERFN_3				0x20030A03
#define EC_LTP_HEAP_SCRESIZEALLOCATION_1					0x20030B01
#define EC_LTP_HEAP_SCRESIZEALLOCATION_2					0x20030B02
#define EC_LTP_HEAP_SCRESIZEALLOCATION_3					0x20030B03
#define EC_LTP_HEAP_SCACCESSPAGE							0x20030C01
#define EC_LTP_HEAP_SCSHRINKPAGEIFLAST						0x20030D01
#define EC_LTP_HEAP_A_RELOADLASTPAGECACHE					0x20030E01
#define EC_LTP_HEAP_SCMAKEACCESSCALLBACK					0x20030F01
#define EC_LTP_HEAP_ACCESSPAGE								0x20031001
#define EC_LTP_HEAP_ACCESSALLOCATION_1						0x20031101
#define EC_LTP_HEAP_ACCESSALLOCATION_2						0x20031102

#define EC_LTP_NAMEID_INTERNGUID_1							0x20040101
#define EC_LTP_NAMEID_INTERNGUID_2							0x20040102
#define EC_LTP_NAMEID_READFIXED								0x20040201
#define EC_LTP_NAMEID_APPENDENTRY_1							0x20040301
#define EC_LTP_NAMEID_APPENDENTRY_2							0x20040302
#define EC_LTP_NAMEID_COMPARESTRING_1						0x20040401
#define EC_LTP_NAMEID_COMPARESTRING_2						0x20040402
#define EC_LTP_NAMEID_COMPARESTRING_3						0x20040403
#define EC_LTP_NAMEID_READSTRING_1							0x20040501
#define EC_LTP_NAMEID_READSTRING_2							0x20040502
#define EC_LTP_NAMEID_INTERNNAME_1							0x20040601
#define EC_LTP_NAMEID_INTERNNAME_2							0x20040602
#define EC_LTP_NAMEID_INTERNNAME_3							0x20040603
#define EC_LTP_NAMEID_OPENCONTEXT							0x20040701
#define EC_LTP_NAMEID_GETNAMESFROMGUID						0x20040801
#define EC_LTP_NAMEID_GETIDSFROMNAMES						0x20040901

#define EC_LTP_PC_SCWRITEPROPENTRY							0x20050101
#define EC_LTP_PC_SCSAVECHANGESESPC							0x20050201
#define EC_LTP_PC_GETPROPINFO								0x20050301
#define EC_LTP_PC_OPENSTREAM_1								0x20050401
#define EC_LTP_PC_OPENSTREAM_2								0x20050402
#define EC_LTP_PC_OPENSTREAM_3								0x20050403
#define EC_LTP_PC_OPENSTREAM_4								0x20050404
#define EC_LTP_PC_OPENSTREAM_5								0x20050405

#define EC_LTP_PROP_A_ENCODEOBJECT							0x20060101
#define EC_LTP_PROP_SCCOPYOBJECT							0x20060201
#define EC_LTP_PROP_SCDECODESTRING							0x20060301
#define EC_LTP_PROP_SCDECODEMVCONSTANT						0x20060401
#define EC_LTP_PROP_SCDECODEMVGUID							0x20060501
#define EC_LTP_PROP_SCDECODEMVCONSTANTINST					0x20060601
#define EC_LTP_PROP_SCDECODEMVSTRINGINST_1					0x20060701
#define EC_LTP_PROP_SCDECODEMVSTRINGINST_2					0x20060702
#define EC_LTP_PROP_SCGETINFOVARIABLESIZE_1					0x20060801
#define EC_LTP_PROP_SCGETINFOVARIABLESIZE_2					0x20060802
#define EC_LTP_PROP_SCGETINFOVARIABLESIZE_3					0x20060803

#define EC_LTP_TC_SCREADPTCI_1								0x20070101
#define EC_LTP_TC_SCREADPTCI_2								0x20070102
#define EC_LTP_TC_SCINSERTCOLUMN_1							0x20070201
#define EC_LTP_TC_SCINSERTCOLUMN_2							0x20070202
#define EC_LTP_TC_OPEN										0x20070301
#define EC_LTP_TC_ADDROW									0x20070401
#define EC_LTP_TC_DELROWS									0x20070501
#define EC_LTP_TC_GETROWINFO								0x20070601
#define EC_LTP_TC_GETCELLINFO_1								0x20070701
#define EC_LTP_TC_GETCELLINFO_2								0x20070702
#define EC_LTP_TC_GETCELLINFO_3								0x20070703
#define EC_LTP_TC_GETROWPROPS								0x20070801
#define EC_LTP_TC_GETONEROWPROP_1							0x20070901
#define EC_LTP_TC_GETONEROWPROP_2							0x20070902
#define EC_LTP_TC_GETONEROWPROP_3							0x20070903
#define EC_LTP_TC_GETCOLUMNPROPS_1							0x20070A01
#define EC_LTP_TC_GETCOLUMNPROPS_2							0x20070A02
#define EC_LTP_TC_SETROWPROPS								0x20070B01
#define EC_LTP_TC_SETROWPROPSFROMPC							0x20070C01
#define EC_LTP_TC_DELROWPROPS								0x20070D01
#define EC_LTP_TC_SETROW_1									0x20070E01
#define EC_LTP_TC_COPYROW_1									0x20070F01

#define EC_LTP_TCV_RESTRICTROW								0x20080101
#define EC_LTP_TCV_SCRESTRICT								0x20080201
#define EC_LTP_TCV_RESTRICTGETVALREF2						0x20080301
#define EC_LTP_TCV_SCRESTRICTCONTENTSTREAM_1				0x20080401
#define EC_LTP_TCV_SCRESTRICTCONTENTSTREAM_2				0x20080402
#define EC_LTP_TCV_SCRESTRICTPROPERTYSTREAM					0x20080501
#define EC_LTP_TCV_SCRESTRICTCOMPARESTREAM_1				0x20080601
#define EC_LTP_TCV_SCRESTRICTCOMPARESTREAM_2				0x20080602
#define EC_LTP_TCV_RESTRICT									0x20080701
#define EC_LTP_TCV_SCPREPAREADDCOLUMN						0x20080801

#define EC_LTP_GMP_INDEXFROMGUID_1							0x20090101
#define EC_LTP_GMP_INDEXFROMGUID_2							0x20090102
#define EC_LTP_GMP_INDEXFROMGUID_3							0x20090103
#define EC_LTP_GMP_GUIDFROMINDEX_1							0x20090201
#define EC_LTP_GMP_GUIDFROMINDEX_2							0x20090202

#define EC_LTP_SMP_LOOKUP									0x200A0101
#define EC_LTP_SMP_UPDATE									0x200A0201
#define EC_LTP_SMP_REMOVE									0x200A0301

#endif	// _LTP_H_

// PST Error contexts (ulContext) -------------------------------------------------

#if defined ( _PST_H_ )

#define EC_PST_MIN											0x30000000

#define EC_PST_ATCH_SAVECHANGES_1							0x30010101
#define EC_PST_ATCH_SAVECHANGES_2							0x30010102
#define EC_PST_ATCH_SAVECHANGES_3							0x30010103

#define EC_PST_FLD_SCCREATEFOLDER							0x30020101
#define EC_PST_FLD_SCOPENFOLDERTABLE_1						0x30020201
#define EC_PST_FLD_SCOPENFOLDERTABLE_2						0x30020202
#define EC_PST_FLD_CREATEFOLDER_1							0x30020301
#define EC_PST_FLD_CREATEFOLDER_2							0x30020302
#define EC_PST_FLD_CREATEMESSAGE_1							0x30020401
#define EC_PST_FLD_CREATEMESSAGE_2							0x30020402
#define EC_PST_FLD_CREATEMESSAGE_3							0x30020403
#define EC_PST_FLD_COPYFOLDER_1								0x30020501
#define EC_PST_FLD_COPYFOLDER_2								0x30020502
#define EC_PST_FLD_COPYFOLDER_3								0x30020503
#define EC_PST_FLD_COPYFOLDER_4								0x30020504
#define EC_PST_FLD_COPYFOLDER_5								0x30020505
#define EC_PST_FLD_COPYFOLDER_6								0x30020506
#define EC_PST_FLD_COPYMESSAGES_1							0x30020601
#define EC_PST_FLD_COPYMESSAGES_2							0x30020602
#define EC_PST_FLD_COPYMESSAGES_3							0x30020603
#define EC_PST_FLD_COPYMESSAGES_4							0x30020604
#define EC_PST_FLD_DELETEMESSAGES_1							0x30020701
#define EC_PST_FLD_DELETEMESSAGES_2							0x30020702
#define EC_PST_FLD_DELETEMESSAGES_3							0x30020703
#define EC_PST_FLD_DELETEFOLDER_1							0x30020801
#define EC_PST_FLD_DELETEFOLDER_2							0x30020802
#define EC_PST_FLD_DELETEFOLDER_3							0x30020803
#define EC_PST_FLD_DELETEFOLDER_4							0x30020804
#define EC_PST_FLD_EMPTYFOLDER_1							0x30020901
#define EC_PST_FLD_EMPTYFOLDER_2							0x30020902
#define EC_PST_FLD_EMPTYFOLDER_3							0x30020903
#define EC_PST_FLD_SETREADFLAGS_1							0x30020A01
#define EC_PST_FLD_SETREADFLAGS_2							0x30020A02
#define EC_PST_FLD_SETMESSAGESTATUS_1						0x30020B01
#define EC_PST_FLD_SETMESSAGESTATUS_2						0x30020B02
#define EC_PST_FLD_SETMESSAGESTATUS_3						0x30020B03
#define EC_PST_FLD_SETSEARCHCRITERIA_1						0x30020C01
#define EC_PST_FLD_SETSEARCHCRITERIA_2						0x30020C02
#define EC_PST_FLD_GETSEARCHCRITERIA						0x30020D01
#define EC_PST_FLD_SCSETDELETEFOLDERPROPS_1					0x30020E01
#define EC_PST_FLD_SCSETDELETEFOLDERPROPS_2					0x30020E02
#define EC_PST_FLD_SCSETDELETEFOLDERPROPS_3					0x30020E03
#define EC_PST_FLD_SCOPENFOLDERPCTC							0x30020F01

#define EC_PST_FLDCOPY_SCCHECKFOLDERANCESTRY				0x30030101
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_1				0x30030201
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_2				0x30030202
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_3				0x30030203
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_4				0x30030204
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_5				0x30030205
#define EC_PST_FLDCOPY_SCDOFOLDERCOPYPROPS_6				0x30030206
#define EC_PST_FLDCOPY_SCMOVECOPYFOLDERPROPS_1				0x30030301
#define EC_PST_FLDCOPY_SCMOVECOPYFOLDERPROPS_2				0x30030302
#define EC_PST_FLDCOPY_SCMOVECOPYONEFOLDER_1				0x30030401
#define EC_PST_FLDCOPY_SCMOVECOPYONEFOLDER_2				0x30030402
#define EC_PST_FLDCOPY_SCDELETESUBFOLDERS					0x30030501
#define EC_PST_FLDCOPY_SCEMPTYFOLDER_1						0x30030601
#define EC_PST_FLDCOPY_SCEMPTYFOLDER_2						0x30030602
#define EC_PST_FLDCOPY_SCDELETEONEMESSAGE_1					0x30030701
#define EC_PST_FLDCOPY_SCDELETEONEMESSAGE_2					0x30030702
#define EC_PST_FLDCOPY_SCMOVECOPYALLFOLDERS_1				0x30030801
#define EC_PST_FLDCOPY_SCMOVECOPYALLFOLDERS_2				0x30030802
#define EC_PST_FLDCOPY_MOVECOPYONEMESSAGE_1					0x30030901
#define EC_PST_FLDCOPY_MOVECOPYONEMESSAGE_2					0x30030902
#define EC_PST_FLDCOPY_SCCHANGEREADFLAG						0x30030A01
#define EC_PST_FLDCOPY_SCDELETEFOLDEROBJECTS_1				0x30030B01
#define EC_PST_FLDCOPY_SCDELETEFOLDEROBJECTS_2				0x30030B02
#define EC_PST_FLDCOPY_SCPROCESSSOME_1						0x30030C01

#define EC_PST_MS_SCINITMS_1								0x30040101
#define EC_PST_MS_SCINITMS_2								0x30040102
#define EC_PST_MS_OPENENTRY_1								0x30040201
#define EC_PST_MS_OPENENTRY_2								0x30040202
#define EC_PST_MS_OPENENTRY_3								0x30040203
#define EC_PST_MS_OPENENTRY_4								0x30040204
#define EC_PST_MS_OPENENTRY_5								0x30040205
#define EC_PST_MS_OPENENTRY_6								0x30040206
#define EC_PST_MS_OPENENTRY_7								0x30040207
#define EC_PST_MS_COMPAREENTRYIDS							0x30040301
#define EC_PST_MS_ADVISE									0x30040401
#define EC_PST_MS_SETRECEIVEFOLDER_1						0x30040501
#define EC_PST_MS_SETRECEIVEFOLDER_2						0x30040502
#define EC_PST_MS_SETRECEIVEFOLDER_3						0x30040503
#define EC_PST_MS_SETRECEIVEFOLDER_4						0x30040504
#define EC_PST_MS_GETOUTGOINGQUEUE							0x30040601
#define EC_PST_MS_SETLOCKSTATE_1							0x30040701
#define EC_PST_MS_SETLOCKSTATE_2							0x30040702
#define EC_PST_MS_SETLOCKSTATE_3							0x30040703
#define EC_PST_MS_SETLOCKSTATE_4							0x30040704
#define EC_PST_MS_FINISHEDMSG_1								0x30040801
#define EC_PST_MS_FINISHEDMSG_2								0x30040802
#define EC_PST_MS_FINISHEDMSG_3								0x30040803
#define EC_PST_MS_ABORTSUBMIT_1								0x30040901
#define EC_PST_MS_ABORTSUBMIT_2								0x30040902
#define EC_PST_MS_ABORTSUBMIT_3								0x30040903
#define EC_PST_MS_NOTIFYNEWMAIL								0x30040A01

#define EC_PST_MSG_SCSAVETOPLEVELMSG_1						0x30050101
#define EC_PST_MSG_SCSAVETOPLEVELMSG_2						0x30050102
#define EC_PST_MSG_SCSAVETOPLEVELMSG_3						0x30050103
#define EC_PST_MSG_SCSAVETOPLEVELMSG_4						0x30050104
#define EC_PST_MSG_SCSAVETOPLEVELMSG_5						0x30050105
#define EC_PST_MSG_SAVECHANGES_1							0x30050201
#define EC_PST_MSG_SAVECHANGES_2							0x30050202
#define EC_PST_MSG_SAVECHANGES_3							0x30050203
#define EC_PST_MSG_OPENATTACH								0x30050301
#define EC_PST_MSG_CREATEATTACH_1							0x30050401
#define EC_PST_MSG_CREATEATTACH_2							0x30050402
#define EC_PST_MSG_DELETEATTACH								0x30050501
#define EC_PST_MSG_SCSUBMITMESSAGE_1						0x30050601
#define EC_PST_MSG_SCSUBMITMESSAGE_2						0x30050602
#define EC_PST_MSG_SCSUBMITMESSAGE_3						0x30050603
#define EC_PST_MSG_SCSUBMITMESSAGE_4						0x30050604
#define EC_PST_MSG_SUBMITMESSAGE_1							0x30050701
#define EC_PST_MSG_SUBMITMESSAGE_2							0x30050702
#define EC_PST_MSG_SUBMITMESSAGE_3							0x30050703
#define EC_PST_MSG_SETREADFLAG_1							0x30050801
#define EC_PST_MSG_SETREADFLAG_2							0x30050802
#define EC_PST_MSG_SCINITMSGOBJ								0x30050901
#define EC_PST_MSG_MODIFYRECIPIENTS							0x30050A01
#define EC_PST_MSG_SCSAVEMESSAGE_1							0x30050B01
#define EC_PST_MSG_SCSAVEMESSAGE_2							0x30050B02
#define EC_PST_MSG_SCSAVEMESSAGE_3							0x30050B03
#define EC_PST_MSG_SCSAVEMESSAGE_4							0x30050B04
#define EC_PST_MSG_SCSAVEMESSAGE_5							0x30050B05
#define EC_PST_MSG_SCSAVEMESSAGE_6							0x30050B06
#define EC_PST_MSG_SCSAVEMESSAGE_7							0x30050B07
#define EC_PST_MSG_SCSAVEMESSAGE_8							0x30050B08
#define EC_PST_MSG_SCCALLRTFSYNC							0x30050C01

#define EC_PST_MSL_LOGON_1									0x30060101
#define EC_PST_MSL_LOGON_2									0x30060102
#define EC_PST_MSL_SPOOLERLOGON_1							0x30060201
#define EC_PST_MSL_SPOOLERLOGON_2							0x30060202
#define EC_PST_MSL_SCLOGONHELPER							0x30060301
#define EC_PST_MSL_SCOPENSTORE_1							0x30060401
#define EC_PST_MSL_SCOPENSTORE_2							0x30060402
#define EC_PST_MSL_SCOPENSTORE_3							0x30060403
#define EC_PST_MSL_SCOPENSTORE_4							0x30060404
#define EC_PST_MSL_SCOPENSTORE_5							0x30060405
#define EC_PST_MSL_SCBROWSEFORFILE_1						0x30060501
#define EC_PST_MSL_SCCREATEORCONFIGURE_1					0x30060601
#define EC_PST_MSL_SCCREATEORCONFIGURE_2					0x30060602
#define EC_PST_MSL_SCSERVICECONFIGURE_1						0x30060701

#define EC_PST_PROPOBJ_GETPROPS_1							0x30070101
#define EC_PST_PROPOBJ_GETPROPS_2							0x30070102
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_1					0x30070201
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_2					0x30070202
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_3					0x30070203
#define EC_PST_PROPOBJ_SCSETSPECIALPROP_4					0x30070204
#define EC_PST_PROPOBJ_SETPROPS								0x30070301
#define EC_PST_PROPOBJ_DELETEPROPSINTERNAL_1				0x30070401
#define EC_PST_PROPOBJ_DELETEPROPSINTERNAL_2				0x30070402
#define EC_PST_PROPOBJ_DELETEPROPS							0x30070501
#define EC_PST_PROPOBJ_COPYPROPS_1							0x30070601
#define EC_PST_PROPOBJ_COPYPROPS_2							0x30070602
#define EC_PST_PROPOBJ_COPYPROPS_3							0x30070603
#define EC_PST_PROPOBJ_GETIDSFROMNAMES_1					0x30070701
#define EC_PST_PROPOBJ_GETIDSFROMNAMES_2					0x30070702
#define EC_PST_PROPOBJ_OPENPROPERTY_1						0x30070801
#define EC_PST_PROPOBJ_OPENPROPERTY_2						0x30070802
#define EC_PST_PROPOBJ_OPENPROPERTY_3						0x30070803
#define EC_PST_PROPOBJ_OPENPROPERTY_4						0x30070804
#define EC_PST_PROPOBJ_OPENPROPERTY_5						0x30070805
#define EC_PST_PROPOBJ_OPENPROPERTY_6						0x30070806
#define EC_PST_PROPOBJ_OPENPROPERTY_7						0x30070807
#define EC_PST_PROPOBJ_SCDELSPECIALPROP						0x30070901
#define EC_PST_PROPOBJ_GETNAMESFROMIDS						0x30070A01

#define EC_PST_PSTDLG_SCGETPSTFILENAME_1					0x30080101
#define EC_PST_PSTDLG_SCGETPSTFILENAME_2					0x30080102
#define EC_PST_PSTDLG_SCGETPSTFILENAME_3					0x30080103
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_1				0x30080201
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_2				0x30080202
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_3				0x30080203
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_4				0x30080204
#define EC_PST_PSTDLG_SCGETCREATEINFORMATION_5				0x30080205
#define EC_PST_PSTDLG_FCHANGEPASSWORDDLG					0x30080301
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_1					0x30080401
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_2					0x30080402
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_3					0x30080403
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_4					0x30080404
#define EC_PST_PSTDLG_SCCHANGEPASSWORDDLG_5					0x30080405
#define EC_PST_PSTDLG_SCGETPASSWORD_1						0x30080501
#define EC_PST_PSTDLG_SCGETPASSWORD_2						0x30080502
#define EC_PST_PSTDLG_SCGETPASSWORD_3						0x30080503
#define EC_PST_PSTDLG_SCGETPASSWORD_4						0x30080504
#define EC_PST_PSTDLG_SCGETPASSWORD_5						0x30080505
#define EC_PST_PSTDLG_SCGETPASSWORD_6						0x30080506
#define EC_PST_PSTDLG_SCSHAREPASSWORDDLG_1					0x30080601
#define EC_PST_PSTDLG_SCSHAREPASSWORDDLG_2					0x30080602
#define EC_PST_PSTDLG_SCSHAREPASSWORDDLG_3					0x30080603
#define EC_PST_PSTDLG_SCGETCREATEINFORMATIONEX				0x30081101
#define EC_PST_PSTDLG_SCGETPASSWORDEX						0x30081201
#define EC_PST_PSTDLG_SCGETOSTFILENAME_1					0x30081301

#define EC_PST_PSTUTIL_SCGETPARENTNIDIMMEDIATE				0x30090101
#define EC_PST_PSTUTIL_SCGETPARENTNID						0x30090201
#define EC_PST_PSTUTIL_SCSETPARENTNID						0x30090301
#define EC_PST_PSTUTIL_SCEXPECTONEPROP						0x30090401
#define EC_PST_PSTUTIL_MS_UPDATECOUNTERPROPS				0x30090501
#define EC_PST_PSTUTIL_CHANGEPSTPASSWORD					0x30090601
#define EC_PST_PSTUTIL_SCDECODEENTRYID_1					0x30090701
#define EC_PST_PSTUTIL_SCDECODEENTRYID_2					0x30090702

#define EC_PST_QUEUE_SCOPENQUEUENODE						0x300A0101
#define EC_PST_QUEUE_SUDQ_SCPEEK							0x300A0201

#define EC_PST_RFS_SCOPENRFS								0x300B0101
#define EC_PST_RFS_SCFINDROWOFMSGCLASS						0x300B0201

#define EC_PST_SCO_SCSETSEARCHCRITERIA_1					0x300C0101
#define EC_PST_SCO_SCSETSEARCHCRITERIA_2					0x300C0102
#define EC_PST_SCO_SCADDTODOMAIN							0x300C0201
#define EC_PST_SCO_SCDELETEFROMDOMAIN						0x300C0301
#define EC_PST_SCO_SCENUMDOMAIN_1							0x300C0401
#define EC_PST_SCO_SCENUMDOMAIN_2							0x300C0402
#define EC_PST_SCO_SCGETFLAGS								0x300C0501
#define EC_PST_SCO_SCGETREST_1								0x300C0601
#define EC_PST_SCO_SCGETREST_2								0x300C0602
#define EC_PST_SCO_SCGETREST_3								0x300C0603
#define EC_PST_SCO_SCGETDOMAIN_1							0x300C0701
#define EC_PST_SCO_SCGETDOMAIN_2							0x300C0702
#define EC_PST_SCO_SCGETDOMAIN_3							0x300C0703
#define EC_PST_SCO_SCRECALCDOMAIN							0x300C0801
#define EC_PST_SCO_SCWRITESUBFOLDERS						0x300C0901

#define EC_PST_SETTINGS_SCOPENSETTINGSPROP					0x300D0101
#define EC_PST_SETTINGS_DELETEPROPS							0x300D0201
#define EC_PST_SETTINGS_OPENPROPERTY_1						0x300D0301
#define EC_PST_SETTINGS_OPENPROPERTY_2						0x300D0302

#define EC_PST_SMO_SCOPENSMO_1								0x300E0101
#define EC_PST_SMO_SCOPENSMO_2								0x300E0102
#define EC_PST_SMO_SCOPENSAL								0x300E0201
#define EC_PST_SMO_SAL_SCDELETESTD							0x300E0301
#define EC_PST_SMO_SDO_SCREMOVE								0x300E0401
#define EC_PST_SMO_SDO_SCOPENNODE							0x300E0501

#define EC_PST_SPECPROP_SCGETSPECIALPROPVALUE_1				0x300F0101
#define EC_PST_SPECPROP_SCGETSPECIALPROPVALUE_2				0x300F0102
#define EC_PST_SPECPROP_SCGETSPECIALPROPVALUE_3				0x300F0103
#define EC_PST_SPECPROP_GETSPECIALPROPVALUEPC_1				0x300F0201
#define EC_PST_SPECPROP_GETSPECIALPROPVALUEPC_2				0x300F0202
#define EC_PST_SPECPROP_GETSPECIALPROPVALUEPC_3				0x300F0203

#define EC_PST_STAT_SCOPENSTATUSENTRY						0x30100101
#define EC_PST_STAT_SCCHANGEPW								0x30100201

#define EC_PST_TBL_FINDROW_1								0x30110101
#define EC_PST_TBL_FINDROW_2								0x30110102
#define EC_PST_TBL_SEEKROW									0x30110201
#define EC_PST_TBL_SETCOLLAPSESTATE							0x30110301
#define EC_PST_TBL_SCFINDROWBYIKEY							0x30110401
#define EC_PST_TBL_EXPANDROW								0x30110501
#define EC_PST_TBL_COLLAPSEROW								0x30110601
#define EC_PST_TBL_FREEBOOKMARK_1							0x30110701
#define EC_PST_TBL_FREEBOOKMARK_2							0x30110702

#define EC_PST_TBLTSO_TRO_RESTRICT							0x30120101
#define EC_PST_TBLTSO_GETIUROWINDEXFROMPIKEY_1				0x30120201
#define EC_PST_TBLTSO_GETIUROWINDEXFROMPIKEY_2				0x30120202
#define EC_PST_TBLTSO_EXPANDTOIUROWINDEX_1					0x30120301
#define EC_PST_TBLTSO_EXPANDTOIUROWINDEX_2					0x30120302
#define EC_PST_TBLTSO_SCCOMPAREROW							0x30120401
#define EC_PST_TBLTSO_SCPREPARENEWTSO_1						0x30120501
#define EC_PST_TBLTSO_SCPREPARENEWTSO_2						0x30120502
#define EC_PST_TBLTSO_SCPREPARENEWTSO_3						0x30120503
#define EC_PST_TBLTSO_CATEGORIZE							0x30120601
#define EC_PST_TBLTSO_SCREBUILDCACHE						0x30120701

#define EC_PST_TRANSACT_SCOPENSUBLTP						0x30130101
#define EC_PST_TRANSACT_MS_BEGINUPDATE_1					0x30130201
#define EC_PST_TRANSACT_MS_BEGINUPDATE_2					0x30130202
#define EC_PST_TRANSACT_MS_BEGINUPDATE_3					0x30130203
#define EC_PST_TRANSACT_MS_BEGINUPDATE_4					0x30130204

#define EC_PST_OST_SCLRFLDCANCREATE							0x30140101
#define EC_PST_OST_SCLRFLDCANMOVECOPY						0x30140201
#define EC_PST_OST_SCLRFLDCANDELETE							0x30140301
#define EC_PST_OST_SCLRFLDFINDROW_1							0x30140401
#define EC_PST_OST_SCLRFLDFINDROW_2							0x30140402
#define EC_PST_OST_SCLRFLDCANMODIFY							0x30140501
#define EC_PST_OST_SCLRBEGUPHIERARCHY						0x30140601
#define EC_PST_OST_SCLRBEGUPFOLDER_1						0x30140701
#define EC_PST_OST_SCLRBEGUPFOLDER_2						0x30140702
#define EC_PST_OST_SCLRBEGUPFOLDER_3						0x30140703
#define EC_PST_OST_SCLRBEGUPCONTENTS_1						0x30140801
#define EC_PST_OST_SCLRBEGUPCONTENTS_2						0x30140802
#define EC_PST_OST_SCLRBEGUPTABLE_1							0x30140901
#define EC_PST_OST_SCLRBEGUPTABLE_2							0x30140902
#define EC_PST_OST_SCLRENDUPTABLE							0x30140A01
#define EC_PST_OST_SCLRBEGUPMESSAGE_1						0x30140B01
#define EC_PST_OST_SCLRBEGUPMESSAGE_2						0x30140B02
#define EC_PST_OST_SCLRBEGUPMESSAGEREAD_1					0x30140C01
#define EC_PST_OST_SCLRBEGUPMESSAGEREAD_2					0x30140C02
#define EC_PST_OST_SCLRBEGUPMESSAGEDEL_1					0x30140D01
#define EC_PST_OST_SCLRBEGUPMESSAGEDEL_2					0x30140D02
#define EC_PST_OST_SCLRENDUPMESSAGEDEL_1					0x30140E01
#define EC_PST_OST_SCLRENDUPMESSAGEDEL_2					0x30140E02
#define EC_PST_OST_SYNCBEG									0x30140F01
#define EC_PST_OST_SYNCEND									0x30141001
#define EC_PST_OST_SCLRSETMODIFIED_1						0x30141101
#define EC_PST_OST_SCLRSETMODIFIED_2						0x30141102
#define EC_PST_OST_SCLROPENSTREAM							0x30141201
#define EC_PST_OST_SRLRUPDFOLDERCKEY						0x30141301
#define EC_PST_OST_SCLRBEGDNTABLE							0x30141401
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_1					0x30141501
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_2					0x30141502
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_3					0x30141503
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_4					0x30141504
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_5					0x30141505
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_6					0x30141506
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_7					0x30141507
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_8					0x30141508
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_9					0x30141509
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_10					0x3014150A
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_11					0x3014150B
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_12					0x3014150C
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_13					0x3014150D
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_14					0x3014150E
#define EC_PST_OST_IHCIMPORTFOLDERCHANGE_15					0x3014150F
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_1					0x30141601
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_2					0x30141602
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_3					0x30141603
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_4					0x30141604
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_5					0x30141605
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_6					0x30141606
#define EC_PST_OST_ICCIMPORTMESSAGECHANGE_7					0x30141607
#define EC_PST_OST_SCLRPATCHHIERROW							0x30141701
#define EC_PST_OST_MSXSETFOLDERINFO_1						0x30141801
#define EC_PST_OST_MSXSETFOLDERINFO_2						0x30141802
#define EC_PST_OST_MSXSETFOLDERINFO_3						0x30141803
#define EC_PST_OST_MSXSETFOLDERINFO_4						0x30141804
#define EC_PST_OST_MSXSETFOLDERINFO_5						0x30141805
#define EC_PST_OST_MSXGETFOLDERINFO							0x30141901
#define EC_PST_OST_SCLRFLDUPDATE							0x30141A01
#define EC_PST_OST_SCLRFAVCREATE_1							0x30141B01
#define EC_PST_OST_SCLRFAVCREATE_2							0x30141B02
#define EC_PST_OST_SCLRFAVCREATE_3							0x30141B03
#define EC_PST_OST_SCLRFAVDELETE_1							0x30141C01
#define EC_PST_OST_SCLRFAVDELETE_2							0x30141C02
#define EC_PST_OST_SCLRFAVDELETE_3							0x30141C03
#define EC_PST_OST_SCLRFAVDELETE_4							0x30141C04
#define EC_PST_OST_SCLRBEGDNFORM_1							0x30141D01
#define EC_PST_OST_SCLRCONFLICTCHECK						0x30141E01
#define EC_PST_OST_SCLRFIXUPWINNER1							0x30141F01
#define EC_PST_OST_SCLRFIXUPWINNER2_1						0x30142001
#define EC_PST_OST_SCLRFIXUPWINNER2_2						0x30142002
#define EC_PST_OST_SCLRGETCHGINFO_1							0x30142101
#define EC_PST_OST_SCLRGETCHGINFO_2							0x30142102
#define EC_PST_OST_MSXGETFOLDERCKEY							0x30142201
#define EC_PST_OST_SCLROPMODREAD							0x30142301
#define EC_PST_OST_SCLROPPROCESS							0x30142401
#define EC_PST_OST_SCLRFLDCHECKREP_1						0x30142501
#define EC_PST_OST_SCLRFLDCHECKREP_2						0x30142502
#define EC_PST_OST_SCLRFLDCHECKREP_3						0x30142503

#define EC_PST_GENERIC										0x30FFFFFF

#endif // _PST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_iab.h ===
/***********************************************************************
 *
 *  _IAB.H
 *
 *  Header file for code in IADRBOOK.C: Address Book object
 *
 *  Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

//
//	structure used to contain information about the open hierarchy tables
//
typedef struct {
    ULONG ulConnection;
    LPMAPITABLE lpTable;
    LPMAPITABLE lpmtRestricted;
    LPIAB lpIAB;
    LPMAPIADVISESINK lpABAdviseSink;
    LPMAPICONTAINER lpContainer;
} TABLEINFO, *LPTABLEINFO;


#define SafeRelease(x)                                      \
    if (x)                                                  \
    {                                                       \
        ULONG uRef = (x)->lpVtbl->Release((x));             \
        DebugTrace(TEXT("**** SafeRelease: %s: Release refCount: %d\n"), TEXT(#x), uRef); \
        if(uRef==0) (x) = NULL;                             \
    }

// This following struct contains info about extensible actions in the UI
// Declared here because these actions are read from the registry and cached 
// on the IAddrBook object once per session
//
typedef struct _WABACTIONITEM
{
    GUID            guidContextMenu;    // GUID identifying the menu extension
    LPCONTEXTMENU   lpContextMenu;      // ICOntextMenu object provided by the extension
    LPWABEXTINIT    lpWABExtInit;       // IWABExtInit object provided by the extension
    int             nCmdIdFirst;        // First Menu Command ID for this extension
    int             nCmdIdLast;         // Last Menu Command ID for this extension
    struct _WABACTIONITEM * lpNext;
} WABACTIONITEM, FAR * LPWABACTIONITEM;


// Folders within the WAB are just special mailuser entries
// We cache information about all the WAB fodlers on the IAB Object
// so that we have handy access to the folders from the lpAdrBook object
//
// There are 2 types of folders:
//  User Folders
//  Regular folders
//
//  User folders correspond to the various identities... Each identity gets
//  one user folder which is non-shareable and appears at the top level of the
//  treeview in the WAB Main view. This folder is distinguished in that it has a
//  corresponding GUID identifying the identity it corresponds to.
//  User folders are not shareable.
//  Regular folders don't correspond to a particular Identity and are shareable.
//
// Folowing structure holds information about a particular folder
//
typedef struct _WABFOLDER
{
    LPTSTR  lpFolderName;   // String containing folder name
    LPTSTR  lpProfileID;    // <GUID> profile ID for the Identity that created the folder (if it's a User folder)
    BOOL    bShared;        // Whether the folder is shared or not
    BOOL    bOwned;         // Set to true if this folder "belongs" to an existing user folder
    SBinary sbEID;          // Entryif of this item
    LPTSTR  lpFolderOwner;  // String identifying the "owner" of this folder - used for reverting a folder to it's original creator if it is shared or unshared
    int     nMenuCmdID;     // when we load a list of folders, we will assign a menu id to them to make it easier to manipulate them in the Share Folders menu
    struct _WABFOLDERLIST * lpFolderList;
    struct _WABFOLDER * lpNext;
} WABFOLDER, FAR * LPWABFOLDER;

typedef struct _WABFOLDERLIST
{
    LPWABFOLDER lpFolder;
    struct _WABFOLDERLIST * lpNext;
} WABFOLDERLIST, FAR * LPWABFOLDERLIST;

#define WABUSERFOLDER   WABFOLDER
#define LPWABUSERFOLDER LPWABFOLDER

// This structure is used for doing prop sheet extensions
//  Information about property sheet extensions is loaded up the first time
//  user wants to see properties on a WAB contact. The info is then cached on the
//  IAB object
//
typedef struct _ExtDisplayDLLInfo
{
    GUID guidPropExt;       // GUID identifying the Property Sheet extension
    BOOL bMailUser;         // Whether this is property sheet extension for a MailUser or a DistList
    LPSHELLPROPSHEETEXT lpPropSheetExt; // IShellPropSheetExt object returned by extension
    LPWABEXTINIT lpWABExtInit;  // IWABExtInit object returned by extension
    struct _ExtDisplayDLLInfo * lpNext;
} EXTDLLINFO, * LPEXTDLLINFO;

/* IDentityChangeNotification
-  Identity Change Notification object for the Identity manager
-   This is cached on the IAB Object so that the IAB always has the 
-   knowledge of the latest current identity*/
typedef struct _WAB_IDENTITYCHANGENOTIFY * LPWABIDENTITYCHANGENOTIFY;

//
// IAB Object
//
typedef struct _IAB {
    MAPIX_BASE_MEMBERS(IAB)

    LPPROPDATA lpPropData;

    LONG lRowID;				 //  Status Row #

    LPIWOINT lpWABObject;       // Our parent WABObject

    //
    // Stores a handle to the open property store
    //
    LPPROPERTY_STORE lpPropertyStore;

    //  Default directory info
    LPENTRYID lpEntryIDDD;
    ULONG cbEntryIDDD;

    //  PAB directory info
    LPENTRYID lpEntryIDPAB;
    ULONG cbEntryIDPAB;

    BOOL fReloadSearchPath;

    // Cached Search Path containers
    LPSPropValue lpspvSearchPathCache;

    //  Merged hierarchy table
    LPTABLEDATA lpTableData;
    LPMAPITABLE lpmtHierarchy;

    //  Merged One Off Table
    LPTABLEDATA lpOOData;
    LPMAPITABLE lpmtOOT;

    // List of open hierarchy tables
    ULONG ulcTableInfo;
    LPTABLEINFO pargTableInfo;

    // List of open oneoff tables
    ULONG ulcOOTableInfo;
    LPTABLEINFO pargOOTableInfo;

    // List of IAB handled Advise "ulConnections"
    LPADVISELIST padviselistIAB;

    // WAB Version of notifications for this pointer
    LPADVISE_LIST pWABAdviseList;

    // Set TRUE if creation of IAB loaded LDAP client
    BOOL fLoadedLDAP;

    HWND        hWndNotify;     // hidden window that runs a notification spooler
    UINT_PTR    ulNotifyTimer;  // notification spooler timer
    LPWSTR      lpwszWABFilePath;// FCN file path
    HANDLE      hThreadNotify;
    HANDLE      hEventKillNotifyThread;

    FILETIME ftLast;

    // Stuff used with Context Extensions
    // This is a list of extensions cached on the IAB object
    LPWABACTIONITEM lpActionList;   // All the registered rt-click actions for this wab
    LPMAILUSER lpCntxtMailUser;

    // Browse window .. assuming there's only one per IAddrBook object ..
    HWND hWndBrowse;

    // Identity manager information cached on the IAB object
    LPWABIDENTITYCHANGENOTIFY lpWABIDCN;
    DWORD dwWABIDCN;
    IUserIdentityManager * lpUserIdentityManager;
    BOOL fCoInitUserIdentityManager;
    ULONG cIdentInit;

    // Information about the current identity
    TCHAR           szProfileName[CCH_IDENTITY_NAME_MAX_LENGTH];// Current identities name
    TCHAR           szProfileID[CCH_IDENTITY_NAME_MAX_LENGTH];  // Current identities GUID in string form
    LPWABUSERFOLDER lpWABUserFolders;       // Linked list of all user folders
    LPWABUSERFOLDER lpWABCurrentUserFolder; // The current Identities user folder
    LPWABFOLDER     lpWABFolders;           // Linked list of ALL WAB folders
    GUID            guidCurrentUser;        // GUID for the current Identity
    HKEY            hKeyCurrentUser;        // Special HKEY for the identity

    // Stuff for caching prop sheet extensions
    LPEXTDLLINFO lpPropExtDllList;
    int nPropExtDLLs;   //# of extension DLLs

    // Caling processes can pass in a GUID through WABOpen WAB_PARAM structure
    // that identifies the calling process. This GUID can later be used for
    // several app-specific things - e.g.
    // We use this guid to identify which property sheet and context menu
    // extensions belong to the calling app and then decide to only show those
    // extensions in that case. Could also use this guid to load the apps
    // specific printer extension.
    GUID guidPSExt; 
    
    // Outlook folder information
    struct _OlkContInfo *rgwabci;
    ULONG cwabci;

    // Flags that tell us the state of the WAB
    BOOL bProfilesEnabled;  // means the caller didn't pass in WAB_ENABLE_PROFILES 
                            // in WABOpen so we should treat the API as olde flavor
                            // but the UI should show folders etc

    BOOL bProfilesIdent;    // means the caller passed in WAB_ENABLE_PROFILES
                            // both UI and API should be identity aware, 
                            // but probably Identities are disabled

    BOOL bProfilesAPIEnabled; // means the caller passed in WAB_ENABLE_PROFILES
                            // so both UI and API should be identity aware
    
    BOOL bUseOEForSendMail; // set to true when client passes WAB_USE_OE_SENDMAIL 
                            // into WABOpen - when this flag is passed in we try to
                            // exclusively use OE for send-mail

    BOOL bSetOLKAllocators; // Boolean set if this object created inside and Outlook session, i.e.,
                            // the WAB is set to use the Outlook MAPI allocators.
	
	HANDLE	hMutexOlk; // used for keeping track of outlook notifications
	DWORD	dwOlkRefreshCount;
	DWORD	dwOlkFolderRefreshCount;

} IAB, *LPIAB;	


//
//  Private Prototypes
//

//
//  Entry point to create a new IAB object
//
HRESULT HrNewIAB(LPPROPERTY_STORE lpPropertyStore,
  LPWABOBJECT lpWABObject,
  LPVOID * lppIAB);

HRESULT MergeOOTables(LPIAB lpIAB,
  ULONG ulFlags);

HRESULT HrMergeTableRows(LPTABLEDATA lptadDst,
  LPMAPITABLE lpmtSrc,
  ULONG ulProviderNum);


#define MIN_CCH_LAST_ERROR	256
#define MAX_CCH_LAST_ERROR	2048

//	The Number of MAPI internal ONE-OFF entries in the AB OOTable.
#define IAB_INTERNAL_OOCNT	1

//	Max Hierarchy Entries per Provider
#define IAB_PROVIDER_HIERARCHY_MAX	0x0000ffff

// used with ptagaABSearchPath declared in abint.c


enum {
    iPATH = 0,
    iUPDATE
};

enum ivtANRCols {
    ivtACPR_ENTRYID = 0,
    ivtACPR_DISPLAY_NAME_A,
    ivtACPR_ADDRTYPE_A,
    ivtACPR_OBJECT_TYPE,
    ivtACPR_DISPLAY_TYPE,
    ivtACPR_EMAIL_ADDRESS_A,
    ivtACPR_SEARCH_KEY,
    ivtACPR_SEND_RICH_INFO,
    ivtACPR_TRANSMITABLE_DISPLAY_NAME_A,
    ivtACPR_7BIT_DISPLAY_NAME,
    cvtACMax
};

// Loads the WABs internally used name properties
HRESULT HrLoadPrivateWABProps(LPIAB lpIAB);

// Reads the custom column props from the registry
void ReadWABCustomColumnProps(LPIAB lpIAB);


// Functions defined in Notify.c
HRESULT HrAdvise(LPIAB lpIAB,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulEventMask,
  LPMAPIADVISESINK lpAdvise,
  ULONG FAR * lpulConnection);

HRESULT HrUnadvise(LPIAB lpIAB, ULONG ulConnection);
// fires the nontifications
HRESULT HrWABNotify(LPIAB lpIAB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_imemx.h ===
/*
 *	_IMEMX.H
 *	
 *	Routines and macros to manage per-instance global variables
 *	for DLLs under both Win16 and Win32.  Allows the per-instance globals
 *	for different functional areas of a DLL to reside in seperate memory blocks
 *  Functions are provided to install and retrieve the
 *	correct block of memory for the current instance/functional_area.
 *	
 *	There are only two functions:
 *	
 *		PvGetInstanceGlobalsEx	Call this to get the address of the
 *								per-instance globals structure.
 *		ScSetinstanceGlobalsEx	Call this to install the
 *								per-instance globals structure. It
 *								may fail if the number of instances
 *								exceeds a certain limit.
 *	
 *	The caller is free to choose the name, size, and allocation
 *	method of the per-instance global variables structure.
 */

#ifndef _IMEMX_H
#define _IMEMX_H

#if defined (WIN32) && !defined (MAC)

/*
 *	The WIN32 implementation uses a pointer in the DLL's data
 *	segment. This assumes that the DLL gets a separate instance
 *	of the default data segment per calling process.
 */

#define DefineInstList(Name) VOID FAR *pinst_##Name = NULL
#define DeclareInstList(Name) extern VOID FAR *pinst_##Name;

#define PvGetInstanceGlobalsEx(Name)		pinst_##Name
#define ScSetInstanceGlobalsEx(_pv, Name)	(pinst_##Name = _pv, 0)

#elif defined (WIN16)

/*	InstList
 *
 *	Since more than one independently developed functional areas can be
 *	combined into a single DLL, the routines for finding instance data in
 *	WIN16 will take an LPInstList as a parameter.  A seperate InstList
 *	structure is kept for each functional area.
 *
 *	Each InstList has a fixed array of pointers (lprgLpvInstList) and a
 *	matching fixed array of keys (lprgInstKeyList) unique to the calling
 *	process.  The key for a given process (StackSegment) and the index of this
 *	key in lprgInstKeyList can be quickly obtained.  A pointer to the instance
 *	data is at the corresponding index of lprgLpvInstList.  Though the
 *  instance key (StackSegment) can be obtained quickly and is guaranteed (in
 *	WIN16) to be unique at any given moment, it is not guaranteed to be unique
 *	throughout the life of the DLL.  For this reason a "more" unique key may
 *	be useful at Instance Contruct/Destruct time.  lprgdwPidList is a list of
 *	keys corresponding to lprgInstKeyList which are guaranteed unique through
 *	the life of the DLL, but which are more time consuming to obtain.
 */
typedef struct _InstList
{
	WORD			cInstEntries;
	WORD			wCachedKey;
	LPVOID			lpvCachedInst;
	DWORD			dwInstFlags;
	WORD FAR *		lprgwInstKey;
	LPVOID FAR *	lprglpvInst;
	DWORD FAR *		lprgdwPID;
	HTASK FAR *		lprghTask;		// raid 31090: used to recycle instance slots
} InstList, FAR * LPInstList;

#define INST_ALLOCATED	1

/*
 *	
 */

#define cInstChunk	50

#define		DefineInstList(Name) \
InstList instList_##Name = { 0, 0, NULL, INST_ALLOCATED, NULL, NULL, NULL}

#define		DeclareInstList(Name) extern InstList instList_##Name

#define		PvGetInstanceGlobalsEx(Name) \
				PvGetInstanceGlobalsInt(&instList_##Name)

#define		ScSetInstanceGlobalsEx(pv, Name) \
				ScSetInstanceGlobalsInt(pv, &instList_##Name)

extern LPVOID		PvGetInstanceGlobalsInt(LPInstList lpInstListX);
extern SCODE		ScSetInstanceGlobalsInt(LPVOID pv, LPInstList lpInstListX);

#elif defined (MAC)

/*
 *	The MAC implementation uses a linked list containing unique keys
 *	to the calling process and pointers to instance data. This linked
 *	list is n-dimensional because the Mac version often groups several
 *	dlls into one exe.
 */

#define				DeclareInstList(Name)
LPVOID FAR PASCAL	PvGetInstanceGlobalsMac(WORD dwDataSet);
SCODE FAR PASCAL	ScSetInstanceGlobalsMac(LPVOID pv, WORD dwDataSet);

#else

//$ REVIEW: DOS based pst will not compile without these
//	definitions
//
#define DeclareInstList(Name) extern VOID FAR *pinst_##Name;
#define PvGetInstanceGlobalsEx(Name)		pinst_##Name

#endif	/* WIN32, WIN16, Mac */

#endif	/* _IMEMX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_entryid.h ===
/***********************************************************************
 *
 * _ENTRYID.H
 *
 * Internal headers for the WABAPI: entryid.c
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 05.13.96     Bruce Kelley        Created
 *
 ***********************************************************************/


// Types of WAB EntryIDs.  This byte sized value indicates what type of
// entryid this is.
enum _WAB_ENTRYID_TYPE {
    // Must not use 0, this value is invalid.
    WAB_PAB = 1,        // "PAB" entryif
    WAB_DEF_DL,         // Default DistList - used for the DistList Template EIDs (used in CreateEntry/NewEntry)
    WAB_DEF_MAILUSER,   // Default Mailuser - used for the MailUser Template EIDs (used in CreateEntry/NewEntry)
    WAB_ONEOFF,         // One Off entryid
    WAB_ROOT,           // Root object
    WAB_DISTLIST,       // Distribution list
    WAB_CONTAINER,      // Container object
    WAB_LDAP_CONTAINER, // LDAP containers - these are special because the container really doesn't exist
    WAB_LDAP_MAILUSER,  // LDAP mailuser entryid
    WAB_PABSHARED,      // "Shared Contacts" folder which is virtual so needs special treatment
};

// Creates WAB entryids
HRESULT CreateWABEntryID(
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG cbData1,
    ULONG cbData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID);

HRESULT CreateWABEntryIDEx(
    BOOL bIsUnicode,
    BYTE bType,
    LPVOID lpData1,
    LPVOID lpData2,
    LPVOID lpData3,
    ULONG cbData1,
    ULONG cbData2,
    LPVOID lpRoot,
    LPULONG lpcbEntryID,
    LPENTRYID * lppEntryID);

// Checks if it's a valid WAB entryID
BYTE IsWABEntryID(
    ULONG cbEntryID,
    LPENTRYID lpEntryID,
    LPVOID * lppData1,
    LPVOID * lppData2,
    LPVOID * lppData3,
    LPVOID * lppData4,
    LPVOID * lppData5);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_layguid.h ===
/*
 *	_LAYGUID.H
 *
 *	Lays down actual, 16-byte GUIDs for use in an EXE or DLL.
 *	Should be included in only one module (a .C file) of said EXE or DLL.
 *	Before including, define the tags for all the GUIDs you
 *	plan to use, e.g.
 *
 *		#define USES_IID_IUnknown
 *		#define USES_IID_IStream
 *		#define USES_IID_IMAPIProp
 *		#include <_layguid.h>
 */



#ifdef USES_GUID_NULL
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#endif

#ifdef USES_IID_IUnknown
DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
#endif

#ifdef USES_IID_IClassFactory
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
#endif

#ifdef USES_IID_IMalloc
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
#endif

#ifdef USES_IID_IMarshal
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);
#endif


/* RPC related interfaces */
#ifdef USES_IID_IRpcChannel
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
#endif

#ifdef USES_IID_IRpcStub
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
#endif

#ifdef USES_IID_IStubManager
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxy
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
#endif

#ifdef USES_IID_IProxyManager
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
#endif

#ifdef USES_IID_IPSFactory
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxyBuffer
DEFINE_GUID(IID_IRpcProxyBuffer, 0xD5F56A34, 0x593B, 0x101A, 0xB5, 0x69, 0x08, 0x00, 0x2B, 0x2D, 0xBF, 0x7A);
#endif

#ifdef USES_IID_IPSFactoryBuffer
DEFINE_GUID(IID_IPSFactoryBuffer,0xD5F569D0,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcChannelBuffer
DEFINE_GUID(IID_IRpcChannelBuffer,0xD5F56B60,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcStubBuffer
DEFINE_GUID(IID_IRpcStubBuffer,0xD5F56AFC,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

/* storage related interfaces */
#ifdef USES_IID_ILockBytes
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
#endif

#ifdef USES_IID_IStorage
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
#endif

#ifdef USES_IID_IStream
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATSTG
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);
#endif


/* moniker related interfaces */
#ifdef USES_IID_IBindCtx
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
#endif

#ifdef USES_IID_IMoniker
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
#endif

#ifdef USES_IID_IRunningObjectTable
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
#endif

#ifdef USES_IID_IInternalMoniker
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);
#endif


/* storage related interfaces */
#ifdef USES_IID_IRootStorage
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved1
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved2
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved3
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);
#endif


/* concurrency releated interfaces */
#ifdef USES_IID_IMessageFilter
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);
#endif


/* CLSID of standard marshaler */
#ifdef USES_CLSID_StdMarshal
DEFINE_OLEGUID(CLSID_StdMarshal,		0x00000017L, 0, 0);
#endif


/* interface on server for getting info for std marshaler */
#ifdef USES_IID_IStdMarshalInfo
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);
#endif


/* NOTE: LSB 0x19 through 0xff are reserved for future use */

//	End of COGUID.H clone

//	Copied from OLEGUID.H

/* this file is the master definition of all public GUIDs specific to OLE
   and is included in ole2.h.

   NOTE: The second least significant byte of all of these GUIDs is 1.
*/


#ifdef USES_IID_IEnumUnknown
DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
#endif

#ifdef USES_IID_IEnumString
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
#endif

#ifdef USES_IID_IEnumMoniker
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
#endif

#ifdef USES_IID_IEnumFORMATETC
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
#endif

#ifdef USES_IID_IEnumOLEVERB
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATDATA
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);
#endif


#ifdef USES_IID_IEnumGeneric
DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
#endif

#ifdef USES_IID_IEnumHolder
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
#endif

#ifdef USES_IID_IEnumCallback
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);
#endif


#ifdef USES_IID_IPersistStream
DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
#endif

#ifdef USES_IID_IPersistStorage
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
#endif

#ifdef USES_IID_IPersistFile
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
#endif

#ifdef USES_IID_IPersist
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);
#endif


#ifdef USES_IID_IViewObject
DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
#endif

#ifdef USES_IID_IDataObject
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
#endif

#ifdef USES_IID_IAdviseSink
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
#endif

#ifdef USES_IID_IDataAdviseHolder
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
#endif

#ifdef USES_IID_IOleAdviseHolder
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);
#endif


#ifdef USES_IID_IOleObject
DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceObject
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
#endif

#ifdef USES_IID_IOleWindow
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceUIWindow
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceFrame
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceActiveObject
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);
#endif


#ifdef USES_IID_IOleClientSite
DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceSite
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);
#endif


#ifdef USES_IID_IParseDisplayName
DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
#endif

#ifdef USES_IID_IOleContainer
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
#endif

#ifdef USES_IID_IOleItemContainer
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);
#endif


#ifdef USES_IID_IOleLink
DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
#endif

#ifdef USES_IID_IOleCache
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
#endif

#ifdef USES_IID_IOleManager
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0);
#endif

#ifdef USES_IID_IOlePresObj
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);
#endif


#ifdef USES_IID_IDropSource
DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
#endif

#ifdef USES_IID_IDropTarget
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);
#endif


#ifdef USES_IID_IDebug
DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
#endif

#ifdef USES_IID_IDebugStream
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);
#endif



/* NOTE: LSB values 0x25 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
#ifdef USES_CLSID_StdOleLink
DEFINE_OLEGUID(CLSID_StdOleLink,			0x00000300, 0, 0);
#endif

#ifdef USES_CLSID_StaticMetafile
DEFINE_OLEGUID(CLSID_StaticMetafile,        0x00000315, 0, 0);
#endif

#ifdef USES_CLSID_StaticDib
DEFINE_OLEGUID(CLSID_StaticDib,             0x00000316, 0, 0);
#endif

//	End of OLEGUID.H clone
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_idrgdrp.h ===
/****
*
*
*
* idrgdrp.h - drag 'n' drop for vcard files and other formats
*
*
*    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
****/

#ifndef _IDRGDRP_H
#define _IDRGDRP_H


struct _IWAB_DRAGDROP;
typedef struct _IWAB_DRAGDROP * LPIWABDRAGDROP;


/* IWAB_DROPTARGET ------------------------------------------------------ */
#define CBIWAB_DROPTARGET sizeof(IWAB_DROPTARGET)


#define IWAB_DROPTARGET_METHODS(IPURE)	                    \
	MAPIMETHOD(DragEnter)									\
		(THIS_	IDataObject * pDataObject,					\
				DWORD grfKeyState,							\
				POINTL pt,									\
				DWORD * pdwEffect)				IPURE;		\
	MAPIMETHOD(DragOver)									\
		(THIS_	DWORD grfKeyState,							\
				POINTL pt,									\
				DWORD * pdwEffect)				IPURE;		\
	MAPIMETHOD(DragLeave)									\
		(THIS)									IPURE;		\
	MAPIMETHOD(Drop)										\
		(THIS_	IDataObject * pDataObject,					\
				DWORD grfKeyState,							\
				POINTL pt,									\
				DWORD * pdwEffect)				IPURE;

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_DropTarget
DECLARE_MAPI_INTERFACE_(IWAB_DropTarget, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_DROPTARGET_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DROPTARGET

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DROPTARGET_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DROPTARGET_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPTARGET_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DROPTARGET_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPTARGET_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DROPTARGET_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_DROPTARGET_METHODS(IMPL)
};


typedef struct _IWAB_DROPTARGET
{
    MAPIX_BASE_MEMBERS(IWAB_DROPTARGET)

	LPIWABDRAGDROP lpIWDD;

} IWABDROPTARGET, * LPIWABDROPTARGET;

/* ----------------------------------------------------------------------------------------------*/




/* IWAB_DROPSOURCE ------------------------------------------------------ */
#define CBIWAB_DROPSOURCE sizeof(IWAB_DROPSOURCE)


#define IWAB_DROPSOURCE_METHODS(IPURE)	                    \
	MAPIMETHOD(QueryContinueDrag)							\
		(THIS_	BOOL fEscapePressed,						\
                DWORD grfKeyState)				IPURE;		\
	MAPIMETHOD(GiveFeedback)								\
		(THIS_	DWORD dwEffect)					IPURE;	

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_DropSource
DECLARE_MAPI_INTERFACE_(IWAB_DropSource, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_DROPSOURCE_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DROPSOURCE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DROPSOURCE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DROPSOURCE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPSOURCE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DROPSOURCE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DROPSOURCE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DROPSOURCE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_DROPSOURCE_METHODS(IMPL)
};


typedef struct _IWAB_DROPSOURCE
{
    MAPIX_BASE_MEMBERS(IWAB_DROPSOURCE)

	LPIWABDRAGDROP lpIWDD;

} IWABDROPSOURCE, * LPIWABDROPSOURCE;

/* ----------------------------------------------------------------------------------------------*/


/* IWAB_DRAGDROP ------------------------------------------------------ */
#define CBIWAB_DRAGDROP sizeof(IWAB_DRAGDROP)


#undef           INTERFACE
#define          INTERFACE      IWAB_DragDrop
DECLARE_MAPI_INTERFACE_(IWAB_DragDrop, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DRAGDROP

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DRAGDROP_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DRAGDROP_)
        MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DRAGDROP_)
        MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DRAGDROP_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
};


typedef struct _IWAB_DRAGDROP
{
    MAPIX_BASE_MEMBERS(IWAB_DRAGDROP)

	LPIWABDRAGDROP lpIWDD;

	LPIWABDROPTARGET lpIWABDropTarget;

	LPIWABDROPSOURCE lpIWABDropSource;

	LPDATAOBJECT m_pIDataObject;
	DWORD		m_dwEffect;
	CLIPFORMAT  m_cfAccept;
	BOOL		m_bIsCopyOperation; // if CTRL key is pressed
    DWORD       m_grfInitialKeyState;
    BOOL        m_bSource;
    BOOL        m_bOverTV;

    LPVOID      m_lpv; // data of parent window
} IWABDRAGDROP, * LPIWABDRAGDROP;

/* ----------------------------------------------------------------------------------------------*/


// Create the IDragDrop Data Object
HRESULT HrCreateIWABDragDrop(LPIWABDRAGDROP * lppIWABDragDrop);


/* ----------------------------------------------------------------------------------------------*/


/* IWAB_DATAOBJECT ------------------------------------------------------ */
#define CBIWAB_DATAOBJECT sizeof(IWAB_DATAOBJECT)

    
#define IWAB_DATAOBJECT_METHODS(IPURE)	                    \
	MAPIMETHOD(GetData)                                     \
		(THIS_	FORMATETC * pFormatetc,	                    \
                STGMEDIUM * pmedium)            IPURE;      \
	MAPIMETHOD(GetDataHere)                                 \
        (THIS_  FORMATETC * pFormatetc,	                    \
                STGMEDIUM * pmedium)            IPURE;      \
    MAPIMETHOD(QueryGetData)                                \
        (THIS_  FORMATETC * pFormatetc)         IPURE;      \
    MAPIMETHOD(GetCanonicalFormatEtc)                       \
        (THIS_  FORMATETC * pFormatetcIn,	                \
                FORMATETC * pFormatetcOut)      IPURE;      \
    MAPIMETHOD(SetData)                                     \
        (THIS_  FORMATETC * pFormatetc,                     \
                STGMEDIUM * pmedium,                        \
                BOOL fRelease)                  IPURE;      \
    MAPIMETHOD(EnumFormatEtc)                               \
        (THIS_  DWORD dwDirection,	                        \
                IEnumFORMATETC ** ppenumFormatetc)  IPURE;  \
    MAPIMETHOD(DAdvise)                                     \
        (THIS_  FORMATETC * pFormatetc,	                    \
                DWORD advf,	                                \
                IAdviseSink * pAdvSink,	                    \
                DWORD * pdwConnection)          IPURE;      \
    MAPIMETHOD(DUnadvise)                                   \
        (THIS_  DWORD dwConnection)             IPURE;      \
    MAPIMETHOD(EnumDAdvise)                                 \
        (THIS_  IEnumSTATDATA ** ppenumAdvise)  IPURE;      \

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_DataObject
DECLARE_MAPI_INTERFACE_(IWAB_DataObject, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_DATAOBJECT_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_DATAOBJECT

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_DATAOBJECT_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_DATAOBJECT_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DATAOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_DATAOBJECT_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_DATAOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_DATAOBJECT_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_DATAOBJECT_METHODS(IMPL)
};


typedef struct _IWAB_DATAOBJECT
{
    MAPIX_BASE_MEMBERS(IWAB_DATAOBJECT)

    LPADRBOOK m_lpAdrBook; 
    HWND m_hWndLV;

    BOOL m_bObjectIsGroup;   // TRUE when dragging a single object which is a group

    ULONG cbDatahDrop;
    const void *pDatahDrop;
    
    ULONG cbDataTextA;
    const void *pDataTextA;

    ULONG cbDataTextW;
    const void *pDataTextW;

    ULONG cbDataBuffer;
    const void *pDataBuffer;

    ULONG cbDataEID;
    const void *pDataEID;
    
    LPVOID m_lpv;
} IWABDATAOBJECT, * LPIWABDATAOBJECT;

/* ----------------------------------------------------------------------------------------------*/

// Creates the IDataObject that holds info about the dragged and dropped object
HRESULT HrCreateIWABDataObject(LPVOID lpv, LPADRBOOK lpAdrBook, HWND hWndLV, LPIWABDATAOBJECT * lppIWABDataObject, BOOL bGetDataNow, BOOL bIsGroup);




/* ----------------------------------------------------------------------------------------------*/


/* IWAB_ENUMFORMATETC ------------------------------------------------------ */
#define CBIWAB_ENUMFORMATETC sizeof(IWAB_ENUMFORMATETC)

    
#define IWAB_ENUMFORMATETC_METHODS(IPURE)	                \
	MAPIMETHOD(Next)                                        \
        (THIS_  ULONG celt,                                 \
                FORMATETC *rgelt,                           \
                ULONG *pceltFethed)         IPURE;          \
	MAPIMETHOD(Skip)                                        \
        (THIS_  ULONG celt)                 IPURE;          \
	MAPIMETHOD(Reset)                                       \
        (THIS)                              IPURE;          \
	MAPIMETHOD(Clone)                                       \
        (THIS_  IEnumFORMATETC ** ppenum)   IPURE;          \

/****/

#undef           INTERFACE
#define          INTERFACE      IWAB_EnumFORMATETC
DECLARE_MAPI_INTERFACE_(IWAB_EnumFORMATETC, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWAB_ENUMFORMATETC_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWAB_ENUMFORMATETC

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWAB_ENUMFORMATETC_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWAB_ENUMFORMATETC_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_ENUMFORMATETC_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWAB_ENUMFORMATETC_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWAB_ENUMFORMATETC_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWAB_ENUMFORMATETC_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWAB_ENUMFORMATETC_METHODS(IMPL)
};


typedef struct _IWAB_ENUMFORMATETC
{
    MAPIX_BASE_MEMBERS(IWAB_ENUMFORMATETC)

    UINT	     ifmt;
    UINT	     cfmt;
    FORMATETC	 afmt[1];
    
} IWABENUMFORMATETC, * LPIWABENUMFORMATETC;

/* ----------------------------------------------------------------------------------------------*/

HRESULT HrCreateIWABEnumFORMATETC(UINT cfmt, 
                                const FORMATETC afmt[], 
                                LPIWABENUMFORMATETC *ppenumFormatEtc);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_imem.h ===
/*
 *	_IMEM.H
 *	
 *	Routines and macros to manage per-instance global variables
 *	for DLLs under both Win16 and Win32. Assumes that all of the
 *	DLL's per-instance global variables live in a single block of
 *	memory; functions are provided to install and retrieve the
 *	correct block of memory for the current instance.
 *	
 *	There are only two functions:
 *	
 *		PvGetInstanceGlobals	Call this to get the address of the
 *								per-instance globals structure.
 *		ScSetinstanceGlobals	Call this to install the
 *								per-instance globals structure. It
 *								may fail if the number of instances
 *								exceeds a certain limit.
 *	
 *	The caller is free to choose the name, size, and allocation
 *	method of the per-instance global variables structure.
 */

#ifndef _IMEM_H
#define _IMEM_H

#if defined (WIN32) && !defined (MAC)

/*
 *	The WIN32 implementation uses a pointer in the DLL's data
 *	segment. This assumes that the DLL gets a separate instance
 *	of the default data segment per calling process.
 */


extern LPVOID pinstX;

#define PvGetInstanceGlobals()		pinstX
#define ScSetInstanceGlobals(_pv)	(pinstX = _pv, 0)


// hack to get around broken windows headers.
// winnt.h defines RtlMoveMemory as memmove which is in the C-runtime... which we are not linking to.
// We want the Kernel32 version.
#undef RtlMoveMemory

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );


#elif defined (WIN16)

/*
 *	The WIN16 implementation uses a fixed array of pointers and a
 *	matching fixed array of keys unique to the calling process.
 */


#define cInstMax	50

LPVOID		PvGetInstanceGlobals(void);
SCODE		ScSetInstanceGlobals(LPVOID pv);

#elif defined (MAC)

/*
 *	The MAC implementation uses a linked list containing unique keys
 *	to the calling process and pointers to instance data. This linked
 *	list is n-dimensional because the Mac version often groups several
 *	dlls into one exe.
 */

LPVOID		PvGetInstanceGlobals(WORD dwDataSet);
SCODE		ScSetInstanceGlobals(LPVOID pv, WORD dwDataSet);

#else

#error I only do Windows and Mac!

#endif	/* WIN32, WIN16, Mac */

#ifdef _WIN64
void WabValidateClientheap();

#endif

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
#ifndef WIN16
MAPIFREEBUFFER MAPIFreeBuffer;
#endif

#endif	/* _IMEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_ldapcnt.h ===
/***********************************************************************
 *
 *  _LDAPCNT.H
 *
 *  Header file for code in LDAPCONT.C
 *
 *  Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  ABContainer for LDAP object.  (i.e. IAB::OpenEntry() with an
 *  lpEntryID of NULL).
 */

#undef	INTERFACE
#define INTERFACE	struct _LDAPCONT

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, LDAPCONT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, LDAPCONT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(LDAPCONT_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
};

typedef struct _LDAPCONT {
    MAILUSER_BASE_MEMBERS(LDAPCONT)
    ULONG ulType;
} LDAPCONT, *LPLDAPCONT;

#define CBLDAP	sizeof(LDAPCONT)

#define LDAPCONT_cInterfaces 3

/*============================================================================
 *	LDAPVUE (table view class) functions
 *
 *  Function prototypes for functions to override in the LDAPVUE vtable.
 */

STDMETHODIMP
LDAPVUE_FindRow(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	BOOKMARK		bkOrigin,
	ULONG			ulFlags );

STDMETHODIMP
LDAPVUE_Restrict(
	LPVUE			lpvue,
	LPSRestriction	lpres,
	ULONG			ulFlags );


// Definitions
#define LDAP_AUTH_METHOD_ANONYMOUS  LDAP_AUTH_ANONYMOUS     // Anonymous binding
#define LDAP_AUTH_METHOD_SIMPLE     LDAP_AUTH_PASSWORD      // LDAP_AUTH_SIMPLE binding
#define LDAP_AUTH_METHOD_SICILY     LDAP_AUTH_MEMBER_SYSTEM // Use Sicily (challenge-response) authentication

#define LDAP_USERNAME_LEN           256 // Maximum length for username/DN
#define LDAP_PASSWORD_LEN           256 // Maximum length for password
#define LDAP_ERROR                  0xffffffff  // Generic LDAP error code.
#define COUNTRY_STR_LEN             2   // Size of country string for ldap_search base
#define LDAP_SEARCH_SIZE_LIMIT      100 // Maximum number of entries to return from a search
#define LDAP_SEARCH_TIME_LIMIT      60  // Maximum number of seconds for server to spend on a search
#define LDAP_SEARCH_TIMER_ID        1   // ID of timer used for asynch LDAP searches
#define LDAP_BIND_TIMER_ID          2   // ID of timer used for asynch LDAP bind
#define LDAP_SEARCH_TIMER_DELAY     100 // Number of milliseconds to wait between polls for asynch LDAP searches
#define SEARCH_CANCEL_DIALOG_DELAY  2000// Number of milliseconds to wait before displaying cancel dialog
#define MAX_ULONG                   0xffffffff

#define LDAP_DEFAULT_PORT           389

// structure for getting proc addresses of api functions
typedef struct _APIFCN
{
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;

// structure to hold MAPI property to LDAP attibute mapping
typedef struct _ATTRMAP
{
  ULONG   ulPropTag;  // MAPI property tag
  const TCHAR * pszAttr;    // LDAP attribute name
} ATTRMAP;

// structure to hold LDAP server parameters
// as read in from the registry through the account manager
//
typedef struct _LDAPSERVERPARAMS
{
  DWORD   dwSearchSizeLimit;
  DWORD   dwSearchTimeLimit;
  DWORD   dwAuthMethod;
  LPTSTR  lpszUserName;
  LPTSTR  lpszPassword;
  LPTSTR  lpszURL;          // URL for server information
  LPTSTR  lpszLogoPath;     // path to the logo bitmap for this server
  BOOL    fResolve;         // Resolve against this server if TRUE
  LPTSTR  lpszBase;         // Search Base
  LPTSTR  lpszName;         // Actual server name or IP address
  DWORD   dwID;             // Unique server ID (order specifier)
  DWORD   dwPort;           // Port to connect to - 389 is default but this could be different
  DWORD   dwUseBindDN;
  DWORD   dwUseSSL;
  DWORD   dwPagedResult;
  LPTSTR  lpszAdvancedSearchAttr;     // List of searchable attributes for advanced searching
  DWORD   dwIsNTDS;                   // used to determine if this is an NTDS or not ..  
  IF_WIN32(BOOL    fSimpleSearch;)    // If specified, we use a very very simple filter ...
  IF_WIN16(DWORD   fSimpleSearch;)    // BOOL is defined as DWORD
                                      // in WIN32 while it is UINT in WIN16.
} LDAPSERVERPARAMS, FAR* LPLDAPSERVERPARAMS;

  BOOL              fUseSynchronousSearch;

#define LSP_ShowAnim                0x00000001
#define LSP_ResolveMultiple         0x00000002
#define LSP_UseSynchronousBind      0x00000004
#define LSP_InitDll                 0x00000008
#define LSP_AbandonSearch           0x00000010
#define LSP_SimpleSearch            0x00000020
#define LSP_UseSynchronousSearch    0x00000040
#define LSP_PagedResults            0x00000080
#define LSP_NoPagedResults          0x00000100
#define LSP_IsNTDS                  0x00000200
#define LSP_IsNotNTDS               0x00000400

// structure to pass data back from IDD_DIALOG_LDAPCANCEL handler
typedef struct _LDAPSEARCHPARAMS
{
  ULONG             ulTimeout;
  ULONG             ulTimeElapsed;
  ULONG             ulMsgID;
  ULONG             ulResult;
  ULONG             ulError;
  LDAP**            ppLDAP;
  LPTSTR             szBase;
  ULONG             ulScope;
  LPTSTR             szFilter;
  LPTSTR             szNTFilter;
  LPTSTR*            ppszAttrs;
  ULONG             ulAttrsonly;
  LDAPMessage**     lplpResult;
  LPTSTR            lpszServer;
  ULONG             ulEntryIndex;
  UINT              unTimerID;
  LPADRLIST         lpAdrList;
  LPFlagList        lpFlagList;
  HWND              hDlgCancel;
  ULONG             ulFlags;
  ULONG             ulLDAPValue;
  LPTSTR            lpszBindDN;
  DWORD             dwAuthType;
  struct berval *   pCookie;
  BOOL              bUnicode;
} LDAPSEARCHPARAMS, * PLDAPSEARCHPARAMS;


typedef struct _SERVER_NAME {
    LPTSTR lpszName;
    DWORD dwOrder;
    /*UNALIGNED */struct _SERVER_NAME * lpNext;
} SERVER_NAME, *LPSERVER_NAME;


// Creates an LDAP URL by deconstructing the LDAP entryid and using information from
// it to fill in gaps in the URL
void CreateLDAPURLFromEntryID(ULONG cbEntryID, LPENTRYID lpEntryID, LPTSTR * lppBuf, BOOL * lpbIsNTDSEntry);


// LDAP function typedefs

// ldap_open
typedef LDAP* (__cdecl LDAPOPEN)( LPTSTR HostName, ULONG PortNumber );
typedef LDAPOPEN FAR *LPLDAPOPEN;

//ldap_connect
typedef ULONG (__cdecl LDAPCONNECT)( LDAP *ld, LDAP_TIMEVAL *timeout);
typedef LDAPCONNECT FAR *LPLDAPCONNECT;

//ldap_init
typedef LDAP* (__cdecl LDAPINIT)( LPTSTR HostName, ULONG PortNumber );
typedef LDAPINIT FAR *LPLDAPINIT;

// ldap_sslinit
typedef LDAP* (__cdecl LDAPSSLINIT)( LPTSTR HostName, ULONG PortNumber , int Secure);
typedef LDAPSSLINIT FAR *LPLDAPSSLINIT;

// ldap_set_option
typedef ULONG (__cdecl LDAPSETOPTION)( LDAP *ld, int option, void *invalue );
typedef LDAPSETOPTION FAR *LPLDAPSETOPTION;

// ldap_bind_s
typedef ULONG (__cdecl LDAPBINDS)(LDAP *ld, LPTSTR dn, LPTSTR cred, ULONG method);
typedef LDAPBINDS FAR *LPLDAPBINDS;

// ldap_bind
typedef ULONG (__cdecl LDAPBIND)( LDAP *ld, LPTSTR dn, LPTSTR cred, ULONG method );
typedef LDAPBIND FAR *LPLDAPBIND;

//ldap_unbind
typedef ULONG (__cdecl LDAPUNBIND)(LDAP* ld);
typedef LDAPUNBIND FAR *LPLDAPUNBIND;

// ldap_search
typedef ULONG (__cdecl LDAPSEARCH)(
        LDAP    *ld,
        LPTSTR   base,
        ULONG   scope,
        LPTSTR   filter,
        LPTSTR   attrs[],
        ULONG   attrsonly
    );
typedef LDAPSEARCH FAR *LPLDAPSEARCH;

// ldap_search_s
typedef ULONG (__cdecl LDAPSEARCHS)(
        LDAP            *ld,
        LPTSTR           base,
        ULONG           scope,
        LPTSTR           filter,
        LPTSTR           attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res
    );
typedef LDAPSEARCHS FAR *LPLDAPSEARCHS;

// ldap_search_st
typedef ULONG (__cdecl LDAPSEARCHST)(
        LDAP            *ld,
        LPTSTR           base,
        ULONG           scope,
        LPTSTR           filter,
        LPTSTR           attrs[],
        ULONG           attrsonly,
        struct l_timeval  *timeout,
        LDAPMessage     **res
    );
typedef LDAPSEARCHST FAR *LPLDAPSEARCHST;

// ldap_abandon
typedef ULONG (__cdecl LDAPABANDON)( LDAP *ld, ULONG msgid );
typedef LDAPABANDON FAR *LPLDAPABANDON;

// ldap_result
typedef ULONG (__cdecl LDAPRESULT)(
        LDAP            *ld,
        ULONG           msgid,
        ULONG           all,
        struct l_timeval  *timeout,
        LDAPMessage     **res
    );
typedef LDAPRESULT FAR *LPLDAPRESULT;

// ldap_result2error
typedef ULONG (__cdecl LDAPRESULT2ERROR)(
        LDAP            *ld,
        LDAPMessage     *res,
        ULONG           freeit      // boolean.. free the message?
    );
typedef LDAPRESULT2ERROR FAR *LPLDAPRESULT2ERROR;

// ldap_msgfree
typedef ULONG (__cdecl LDAPMSGFREE)(LDAPMessage *res);
typedef LDAPMSGFREE FAR *LPLDAPMSGFREE;

// ldap_first_entry
typedef LDAPMessage* (__cdecl LDAPFIRSTENTRY)(LDAP *ld, LDAPMessage *res);
typedef LDAPFIRSTENTRY FAR *LPLDAPFIRSTENTRY;

// ldap_next_entry
typedef LDAPMessage* (__cdecl LDAPNEXTENTRY)(LDAP *ld, LDAPMessage *entry);
typedef LDAPNEXTENTRY FAR *LPLDAPNEXTENTRY;

// ldap_count_entries
typedef ULONG (__cdecl LDAPCOUNTENTRIES)(LDAP *ld, LDAPMessage *res);
typedef LDAPCOUNTENTRIES FAR *LPLDAPCOUNTENTRIES;

// ldap_first_attribute
typedef LPTSTR (__cdecl LDAPFIRSTATTR)(
        LDAP            *ld,
        LDAPMessage     *entry,
        BerElement      **ptr
    );
typedef LDAPFIRSTATTR FAR *LPLDAPFIRSTATTR;

// ldap_next_attribute
typedef LPTSTR (__cdecl LDAPNEXTATTR)(
        LDAP            *ld,
        LDAPMessage     *entry,
        BerElement      *ptr
    );
typedef LDAPNEXTATTR FAR *LPLDAPNEXTATTR;

// ldap_get_values
typedef LPTSTR* (__cdecl LDAPGETVALUES)(
        LDAP            *ld,
        LDAPMessage     *entry,
        LPTSTR           attr
    );
typedef LDAPGETVALUES FAR *LPLDAPGETVALUES;

// ldap_get_values_len
typedef struct berval** (__cdecl LDAPGETVALUESLEN)(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    LPTSTR           attr
    );
typedef LDAPGETVALUESLEN FAR *LPLDAPGETVALUESLEN;

// ldap_count_values
typedef ULONG (__cdecl LDAPCOUNTVALUES)(LPTSTR *vals);
typedef LDAPCOUNTVALUES FAR *LPLDAPCOUNTVALUES;

// ldap_count_values_len
typedef ULONG (__cdecl LDAPCOUNTVALUESLEN)(struct berval **vals);
typedef LDAPCOUNTVALUESLEN FAR *LPLDAPCOUNTVALUESLEN;

// ldap_value_free
typedef ULONG (__cdecl LDAPVALUEFREE)(LPTSTR *vals);
typedef LDAPVALUEFREE FAR *LPLDAPVALUEFREE;

// ldap_value_free_len
typedef ULONG (__cdecl LDAPVALUEFREELEN)(struct berval **vals);
typedef LDAPVALUEFREELEN FAR *LPLDAPVALUEFREELEN;

// ldap_get_dn
typedef LPTSTR (__cdecl LDAPGETDN)(LDAP *ld, LDAPMessage *entry);
typedef LDAPGETDN FAR *LPLDAPGETDN;

// ldap_memfree
typedef VOID (__cdecl LDAPMEMFREE)(LPTSTR  Block);
typedef LDAPMEMFREE FAR *LPLDAPMEMFREE;

// ldap_err2string
typedef LPTSTR (__cdecl LDAPERR2STRING)(ULONG err);
typedef LDAPERR2STRING FAR *LPLDAPERR2STRING;

//ldap_create_page_control
typedef ULONG (__cdecl LDAPCREATEPAGECONTROL)(
                LDAP * pExternalHandle, 
                ULONG PageSize, 
                struct berval *Cookie, 
                UCHAR IsCritical, 
                PLDAPControlA *Control);
typedef LDAPCREATEPAGECONTROL FAR *LPLDAPCREATEPAGECONTROL;

//ldap_search_ext_s
typedef ULONG (__cdecl LDAPSEARCHEXT_S)(
                LDAP *ld,
                LPTSTR base,
                ULONG scope,
                LPTSTR filter,
                LPTSTR attrs[],
                ULONG attrsonly,
                PLDAPControlA *ServerControls,
                PLDAPControlA *ClientControls,
                struct l_timeval *timeout,
                ULONG SizeLimit,
                LDAPMessage **res);
typedef LDAPSEARCHEXT_S FAR * LPLDAPSEARCHEXT_S;

typedef ULONG (__cdecl LDAPSEARCHEXT)(
                LDAP *ld,
                LPTSTR base,
                ULONG scope,
                LPTSTR filter,
                LPTSTR attrs[],
                ULONG attrsonly,
                PLDAPControlA *ServerControls,
                PLDAPControlA *ClientControls,
                ULONG TimeLimit,
                ULONG SizeLimit,
                ULONG *MessageNumber);
typedef LDAPSEARCHEXT FAR * LPLDAPSEARCHEXT;

//ldap_parse_result
typedef ULONG (__cdecl LDAPPARSERESULT)(
                LDAP *Connection,
                LDAPMessage *ResultMessage,
                ULONG *ReturnCode OPTIONAL, 
                PWCHAR *MatchedDNs OPTIONAL, 
                PWCHAR *ErrorMessage OPTIONAL, 
                PWCHAR **Referrals OPTIONAL, 
                PLDAPControl **ServerControls OPTIONAL,
                BOOLEAN Freeit);
typedef LDAPPARSERESULT FAR *LPLDAPPARSERESULT;

//ldap_parse_page_control
typedef ULONG (__cdecl LDAPPARSEPAGECONTROL)(
                PLDAP ExternalHandle,
                PLDAPControlA *ServerControls,
                ULONG *TotalCount,
                struct berval **Cookie     // Use ber_bvfree to free
                );
typedef LDAPPARSEPAGECONTROL FAR * LPLDAPPARSEPAGECONTROL;

typedef ULONG (__cdecl LDAPCONTROLFREE)(
                LDAPControl *Control);
typedef LDAPCONTROLFREE FAR * LPLDAPCONTROLFREE;

typedef ULONG (__cdecl LDAPCONTROLSFREE)(
                LDAPControl **Control);
typedef LDAPCONTROLSFREE FAR * LPLDAPCONTROLSFREE;

 



// Public functions in ldapcont.c
BOOL InitLDAPClientLib(void);
ULONG DeinitLDAPClientLib(void);

HRESULT LDAPResolveName(LPADRBOOK lpAddrBook,
  LPADRLIST lpAdrList,
  LPFlagList lpFlagList,
  LPAMBIGUOUS_TABLES lpAmbiguousTables,
  ULONG ulFlags);

HRESULT LDAP_OpenMAILUSER(LPIAB lpIAB,
                          ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPCIID lpInterface,
  ULONG ulFlags,
  ULONG * lpulObjType,
  LPUNKNOWN * lppUnk);
BOOL    GetLDAPServerParams(LPTSTR lpszServer, LPLDAPSERVERPARAMS lspParams);
HRESULT SetLDAPServerParams(LPTSTR lpszServer, LPLDAPSERVERPARAMS lspParams);
void    FreeLDAPServerParams(LDAPSERVERPARAMS Params);
DWORD   GetLDAPNextServerID(DWORD dwSet);
BOOL    GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,UINT nApiProcs);
void UninitAccountManager(void);
HRESULT InitAccountManager(LPIAB lpIAB, IImnAccountManager2 ** lppAccountManager, GUID * pguidUser);
HRESULT AddToServerList(UNALIGNED LPSERVER_NAME * lppServerNames, LPTSTR szBuf, DWORD dwOrder);
HRESULT EnumerateLDAPtoServerList(IImnAccountManager2 * lpAccountManager,
  LPSERVER_NAME * lppServerNames, LPULONG lpcServers);

extern const LPTSTR szAllLDAPServersValueName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_iprop.h ===
//
//  Function prototypes
//

#undef	INTERFACE
#define INTERFACE	struct _IPDAT

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	IPDAT_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IPDAT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IPROPDATA_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IPDAT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
		MAPI_IPROPDATA_METHODS(IMPL)			
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IPDAT_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
	MAPI_IPROPDATA_METHODS(IMPL)
};

/* Generic part of property linked lists.
 */
typedef struct _lstlnk {
	struct _lstlnk FAR *	lpNext;
	ULONG					ulKey;
} LSTLNK, FAR * LPLSTLNK;

typedef LPLSTLNK FAR * LPPLSTLNK;


/* Linked list of property values.
 */
typedef struct _lstspv {
	LSTLNK			lstlnk;
	LPSPropValue	lpPropVal;
	ULONG			ulAccess;
} LSTSPV, FAR * LPLSTSPV;
#define CBLSTSPV sizeof(LSTSPV)

/* Linked list of property ID to NAME mappings.
 */
typedef struct _lstspn {
	LSTLNK			lstlnk;
	LPMAPINAMEID	lpPropName;
} LSTSPN, FAR * LPLSTSPN;

typedef struct _IPDAT {
	IPDAT_Vtbl FAR *	lpVtbl;

	// Generic IMAPIUnknown portion
	UNKOBJ_MEMBERS;
	UNKINST		inst;

	//
	//  Says whether or not this object (as a whole) is modifiable
	//
	ULONG		ulObjAccess;

	// List of properties in this object
	LPLSTSPV	lpLstSPV;

	// Count of properties in this object
	ULONG 		ulCount;

	// List of property ID to NAME maps for this object
	LPLSTSPN	lpLstSPN;

	// Next ID to use when creating a new NAME to ID map
	ULONG		ulNextMapID;

} IPDAT, *LPIPDAT;	

#define CBIPDAT sizeof(IPDAT)




/* dimensionof determines the number of elements in "array".
 */

#ifdef WIN16
#ifndef dimensionof
#define	dimensionof(rg)			(sizeof(rg)/sizeof(*(rg)))
#endif // !dimensionof
#else  // WIN16
#define	dimensionof(rg)			(sizeof(rg)/sizeof(*(rg)))
#endif // WIN16

#define SET_PROP_TYPE(ultag, ultype)	(ultag) = ((ultag) & 0xffff0000) \
												  | (ultype)
#define MIN_NAMED_PROP_ID	0x8000
#define MAX_NAMED_PROP_ID	0xfffe



SCODE ScWCToAnsiMore(   LPALLOCATEMORE lpMapiAllocMore, LPVOID lpBase,
                        LPWSTR lpszWC, LPSTR * lppszAnsi );
SCODE ScAnsiToWCMore(   LPALLOCATEMORE lpMapiAllocMore, LPVOID lpBase,
                        LPSTR lpszAnsi, LPWSTR * lppszWC );

LPSTR ConvertWtoA(LPCWSTR lpszW);
LPWSTR ConvertAtoW(LPCSTR lpszA);

SCODE ScConvertAPropsToW(LPALLOCATEMORE lpMapiAllocMore, LPSPropValue lpPropArray, ULONG ulcProps, ULONG ulStart);
SCODE ScConvertWPropsToA(LPALLOCATEMORE lpMapiAllocMore, LPSPropValue lpPropArray, ULONG ulcProps, ULONG ulStart);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_itable.h ===
/*============================================================================
 *
 *	_ITABLE.H
 *
 *	Internal header file for MAPI 1.0 In-memory MAPI Table DLL
 *
 *	Copyright (C) 1993 and 1994 Microsoft Corporation
 *
 *
 *	Hungarian shorthand:
 *		To avoid excessively long identifier names, the following
 *		shorthand expressions are used:
 *
 *			LPSPropTagArray		lppta
 *			LPSRestriction		lpres
 *			LPSPropValue		lpprop
 *			LPSRow				lprow
 *			LPSRowSet			lprows
 *			LPSSortOrder		lpso
 *			LPSSortOrderSet		lpsos
 */

// $MAC - Fix up some naming conflicts

#ifdef MAC
#define FFindColumn				ITABLE_FFindColumn
#endif

typedef	struct _TAD FAR *		LPTAD;
typedef struct _VUE FAR *		LPVUE;

//	Global Constants
#define ROW_CHUNK_SIZE			50
#define COLUMN_CHUNK_SIZE		15

//	Max number of notifications to send in a batch
//
//	Raid: Horsefly/Exchange/36281
//	This was changed from 8 to 1 because code in itable.c which fills in
//	the batch cannot guarantee the correct order of the notifications in
//	it.  If this is ever changed, that bug will have to be revisited.
//
#define MAX_BATCHED_NOTIFS		1

//	For use in aligning data in buffers
#if defined (_AMD64_) || defined (_IA64_)
#define ALIGNTYPE			LARGE_INTEGER
#else
#define ALIGNTYPE			DWORD
#endif
#define	ALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)	(((lcb) + ALIGN) & ~ALIGN)
#define PbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))

//	This structure is used to keep track of a private memory buffer which is
//	used with the private AllocateMore function ScBufAllocateMore().  This
//	allows for one MAPI memory allocation when the size of a property is known
//	and the author wishes to use PropCopyMore.  See ITABLE.C ScCopyTadRow()
//	for an example.
typedef struct _CMB
{
	ULONG	ulcb;
	LPVOID	lpv;
} 	CMB, * LPCMB;


#if	!defined(NO_VALIDATION)

#define VALIDATE_OBJ(lpobj,objtype,fn,lpVtbl)										\
	if ( BAD_STANDARD_OBJ(lpobj,objtype,fn,lpVtbl))										\
	{																		\
		DebugTrace(  TEXT("%s::%s() - Invalid parameter passed as %s object\n"),	\
					#objtype,												\
					#fn,													\
					#objtype );												\
		return ResultFromScode( MAPI_E_INVALID_PARAMETER );					\
	}

#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

// $MAC - Supprt for WLM 4.0
#ifndef VTABLE_FILL
#define VTABLE_FILL
#endif



#define	HrSetLastErrorIds(lpobj,sc,ids)				\
			UNKOBJ_HrSetLastError((LPUNKOBJ)(lpobj),	\
								 (sc),				\
								 (ids))



#ifdef	WIN32
#define	LockObj(lpobj)		UNKOBJ_Lock((LPUNKOBJ)(lpobj))
__inline VOID
UNKOBJ_Lock( LPUNKOBJ lpunkobj )
{
	EnterCriticalSection(&lpunkobj->csid);
}

#define UnlockObj(lpobj)	UNKOBJ_Unlock((LPUNKOBJ)(lpobj))
__inline VOID
UNKOBJ_Unlock( LPUNKOBJ lpunkobj )
{
	LeaveCriticalSection(&lpunkobj->csid);
}
#else
#define	LockObj(lpobj)
#define	UnlockObj(lpobj)
#endif


// Memory Management Macros for code readability

#define	ScAllocateBuffer(lpobj,ulcb,lppv)				\
			UNKOBJ_ScAllocate((LPUNKOBJ)(lpobj),	\
							  (ulcb),				\
							  (LPVOID FAR *)(lppv))


#define	ScAllocateMore(lpobj,ulcb,lpv,lppv)			\
			UNKOBJ_ScAllocateMore((LPUNKOBJ)(lpobj),	\
								  (ulcb),				\
								  (lpv),				\
								  (LPVOID FAR *)(lppv))

#define ScFreeBuffer(lpobj,lpv)					\
			UNKOBJ_Free((LPUNKOBJ)(lpobj), (lpv))

#define	ScCOAllocate(lpunkobj,ulcb,lplpv)		\
			UNKOBJ_ScCOAllocate((LPUNKOBJ)(lpunkobj),(ulcb),(lplpv))


#define	ScCOReallocate(lpunkobj,ulcb,lplpv)		\
			UNKOBJ_ScCOReallocate((LPUNKOBJ)(lpunkobj),(ulcb),(lplpv))


#define	COFree(lpunkobj,lpv)		\
			UNKOBJ_COFree((LPUNKOBJ)(lpunkobj),(lpv))


#define	MAPIFreeRows(lpobj,lprows)				\
			UNKOBJ_FreeRows((LPUNKOBJ)(lpobj),(lprows))




/*============================================================================
 *	TAD (table data class)
 *
 *		Implementes in-memory table data object.
 */

#undef	INTERFACE
#define	INTERFACE	struct _TAD
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,TAD_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_ITABLEDATA_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_TYPEDEF(type,method,TAD_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_ITABLEDATA_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(TAD_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_ITABLEDATA_METHODS(IMPL)
};

typedef struct _TAD
{
	TAD_Vtbl FAR *		lpVtbl;
	UNKOBJ_MEMBERS;

	UNKINST				inst;

	LPVUE				lpvueList;

	ULONG				ulTableType;
	ULONG				ulPropTagIndexCol;

	ULONG				ulcColsMac;
	LPSPropTagArray		lpptaCols;			// Initial view col set (CO)

	ULONG				ulcRowsAdd;
	ULONG				ulcRowMacAdd;
	LPSRow *			parglprowAdd;		// Unsorted Row Set (CO)

	ULONG				ulcRowsIndex;
	ULONG				ulcRowMacIndex;
	LPSRow * 			parglprowIndex;		// Row Set Sorted by Index (CO)

   LPVOID              lpvDataSource;   // used to store container specific data
   ULONG               cbDataSource;    // bytes in lpvDataSource to copy to new allocation.
                                        // If non-zero, CreateView should LocalAlloc this size
                                        // and copy data from lpvDataSource into it.  Release
                                        // should LocalFree.

   // With multiple containers, it becomes necessary to figure
   // out which container the table represents. We cache the containers
   // EID in the table for easy access. This is a pointer .. no need to free
   LPSBinary            pbinContEID;

   // When calling get ContentsTable, we may sometimes want a list of
   // contents from ALL the folders/containers for a particular profile and
   // return those contents as a single contentstable. Following flag caches
   // this setting so we collate contents of all folders. Works only if the
   // container being opened was the PAB container and if bProfilesAPIEnabled
   // (ie profiles were invoked explicitly)
   BOOL                 bAllProfileContents;

   // For PAB containers where profilesAPIEnabled=FALSE, GetContentsTable
   // typically means return contents of ALL the WAB since user hasn;t asked for
   // profiles. In this case we may want to have the option of opening only
   // a particular folder and getting only the conetnts of that folder .. so we
   // need a flag to cache this inverse option.
    BOOL                 bContainerContentsOnly;

    // When calling GetContentsTable, the caller can specify MAPI_UNICODE
    // for unicode tables.. we cache that flag in case we need to refill the table
    // at some later point ..
    BOOL                bMAPIUnicodeTable;
} TAD;

SCODE
ScCopyTadRowSet(
	LPTAD			lptad,
	LPSRowSet		lprowsetIn,
	ULONG *			pcNewTags,
	ULONG *			pcRows,
    LPSRow * *		pparglprowUnsortedCopy,
	LPSRow * *		pparglprowSortedCopy );

SCODE
ScCopyTadRow( LPTAD			lptad,
			  LPSRow		lprow,
			  ULONG *		pTagsAdded,
			  LPSRow FAR *	lplprowCopy );

VOID
UpdateViews( LPTAD		lptad,
			 ULONG		cRowsToRemove,
			 LPSRow *	parglprowToRemove,
			 ULONG		cRowsToAdd,
			 LPSRow *	parglprowToAddUnsorted,
			 LPSRow *	parglprowToAddSorted );

VOID
FixupView(
	LPVUE		lpvue,
	ULONG		cRowsToRemove,
	LPSRow *	parglprowToRemove,
	ULONG		cRowsToAdd,
	LPSRow *	parglprowToAddUnsorted,
	LPSRow *	parglprowToAddSorted );

SCODE
ScReplaceRows(
	LPTAD		lptad,
	ULONG		cRowsNew,
	LPSRow *	parglprowNew,
	ULONG *		pcRowsOld,
	LPSRow * *	pparglprowOld );

SCODE
ScFindRow( LPTAD		lptad,
		   LPSPropValue	lpprop,
		   LPSRow * *	pplprow );
SCODE
ScAddRow( LPUNKOBJ			lpunkobj,
		  LPSSortOrderSet	lpsos,
		  LPSRow			lprow,
		  ULONG				uliRow,
		  ULONG *			pulcRows,
		  ULONG *			pulcRowsMac,
		  LPSRow **			pparglprows,
		  LPSRow **			pplprow );





/*============================================================================
 *	VUE (table view class)
 */

#undef	INTERFACE
#define	INTERFACE	struct _VUE
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,VUE_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_TYPEDEF(type,method,VUE_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPITABLE_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(VUE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPITABLE_METHODS(IMPL)
};

/*	BOOKMARK status
 *
 *	dwfBKSFree		is used for a bookmark that is NOT valid and
 *					is available for use
 *	dwfBKSValid		is set for any used bookmark.
 *	dwfChanged		is used with dwfBKSValid to indicate that the marked row
 *					has moved since the last query which in involved this
 *					bookmark
 *	dwfBKSMoving	is used with dwfBKSValid to indicate that the marked row is
 *					in the process of being moved relative to other rows.
 *	dwfBKSStale		is used with dwfBKSValid to indicate the given bookmark
 *					no longer marks a row but has not been Freed
 *	dwfBKSMask		is the set of all valid bookmark status
 *	
 */	
#define dwfBKSFree		((DWORD) 0x00000000)
#define	dwfBKSValid		((DWORD) 0x00000001)
#define dwfBKSChanged	((DWORD) 0x00000002)
#define dwfBKSMoving	((DWORD) 0x00000004)
#define	dwfBKSStale		((DWORD) 0x00000008)
#define	dwfBKSMask		(~(dwfBKSValid|dwfBKSChanged|dwfBKSMoving|dwfBKSStale))

#define	FBadBookmark(lpvue,bk)							\
		((bk) >= cBookmarksMax ||						\
		 ((lpvue)->rgbk[(bk)].dwfBKS == dwfBKSFree) ||	\
		 ((lpvue)->rgbk[(bk)].dwfBKS & dwfBKSMask))		\

typedef struct
{
	DWORD	dwfBKS;			// Bookmark status
	union
	{
		ULONG	uliRow;		// dwfBKSValid || dwfBKSChanged
		LPSRow	lprow;		// dwfBKSMoving
	};
} BK, * PBK;


// There is a maximum of 42 client defined bookmarks for each VUE.  This
// seems adequate for an in-memory table.
// Bookmarks are kept as an array of 45 where the first three are
// the MAPI predefined bookmarks.

#define cBookmarksMax		45	// Max. # of bookmarks including reserved ones
#define	cBookmarksReserved	3	// # of reserved bookmarks (begin, cur, end)

#define	BOOKMARK_MEMBERS				\
	struct								\
	{									\
		union							\
		{								\
			struct						\
			{							\
				BK	bkBeginning;		\
				BK	bkCurrent;			\
				BK	bkEnd;				\
			};							\
			BK	rgbk[cBookmarksMax];	\
		};								\
	}									\

typedef BOOKMARK_MEMBERS UBK, * PUBK;

typedef struct _VUE
{
	VUE_Vtbl FAR *		lpVtbl;
	UNKOBJ_MEMBERS;

	LPVUE				lpvueNext;
	LPTAD				lptadParent;

	LPSPropTagArray		lpptaCols;		// Column set (MAPI)
	LPSRestriction		lpres;			// Restriction (MAPI)
	LPSSortOrderSet		lpsos;			// Sort order set (MAPI)

	CALLERRELEASE FAR *	lpfReleaseCallback;
	ULONG				ulReleaseData;

	ULONG				ulcRowMac;	// Space available for rows
	LPSRow *			parglprows;	// Sorted Row Set

	BOOKMARK_MEMBERS;

	LPADVISELIST		lpAdviseList;
	ULONG				ulcAdvise;
	MAPIUID				mapiuidNotif;

   LPVOID              lpvDataSource;   // used to store container specific data
   ULONG               cbDataSource;    // bytes in lpvDataSource to copy to new allocation.
                                        // If non-zero, CreateView should LocalAlloc this size
                                        // and copy data from lpvDataSource into it.  Release
                                        // should LocalFree.

   BOOL                 bMAPIUnicodeTable; //tracks whether parent table needs UNICODE data or not

} VUE;

typedef struct _VUENOTIFKEY
{
	ULONG		ulcb;
	MAPIUID		mapiuid;

} VUENOTIFKEY;

BOOL
FBookMarkStale( LPVUE lpvue,
				BOOKMARK bk);

SCODE
ScLoadRows( ULONG			ulcRowsSrc,
			LPSRow *		rglprowsSrc,
			LPVUE			lpvue,
			LPSRestriction	lpres,
			LPSSortOrderSet	lpsos );

SCODE
ScDeleteAllRows( LPTAD		lptad);

SCODE
ScMaybeAddRow( LPVUE			lpvue,
			   LPSRestriction	lpres,
			   LPSSortOrderSet	lpsos,
			   LPSRow			lprow,
			   ULONG			uliRow,
			   ULONG *			pulcRows,
			   ULONG *			pulcRowMac,
			   LPSRow **		pparglprows,
			   LPSRow **		pplprow );

SCODE
ScCopyVueRow( LPVUE				lpvue,
			  LPSPropTagArray	lpptaCols,
			  LPSRow			lprowSrc,
			  LPSRow			lprowDst );




/*============================================================================
 *	Utilities
 */

SCODE
ScDupRestriction( LPUNKOBJ				lpunkobj,
				  LPSRestriction		lpres,
				  LPSRestriction FAR *	lplpresCopy );

SCODE
ScDupRestrictionMore( LPUNKOBJ			lpunkobj,
					  LPSRestriction	lpresSrc,
					  LPVOID			lpvLink,
					  LPSRestriction	lpresDst );

SCODE
ScSatisfiesRestriction( LPSRow			lprow,
						LPSRestriction	lpres,
						ULONG *			pfSatisfies );
SCODE
ScDupRgbEx( LPUNKOBJ		lpunkobj,
			ULONG			ulcb,
			LPBYTE			lpb,
			ULONG			ulcbExtra,
			LPBYTE FAR *	lplpbCopy );

LPSRow *
PlprowCollateRow( ULONG				ulcRows,
				  LPSRow *			rglprows,
				  LPSSortOrderSet	lpsos,
				  BOOL				fAfterExisting,
				  LPSRow			lprow );

LPSRow *
PlprowByLprow( ULONG	ulcRows,
			   LPSRow *	rglprows,
			   LPSRow	lprow );

LPSPropValue __fastcall
LpSPropValueFindColumn( LPSRow	lprow,
						ULONG	ulPropTagColumn );

STDMETHODIMP_(SCODE)
ScBufAllocateMore( ULONG		ulcb,
				   LPCMB		lpcmb,
				   LPVOID FAR *	lplpv );

ULONG
UlcbPropToCopy( LPSPropValue lpprop );



#ifndef WIN16 // WIN16 C (not C++) doesn't support INLINE functions.
              // Functions are defined in ITABLE.C.
/*============================================================================
 -	FFindColumn()
 -
 *		Checks a prop tag array to see if a given prop tag exists.
 *
 *		NOTE!  The prop tag must match completely (even type).
 *
 *
 *	Parameters:
 *		lpptaCols	in		Prop tag array to check
 *		ulPropTag	in		Prop tag to check for.
 *
 *	Returns:
 *		TRUE if ulPropTag is in lpptaCols
 *		FALSE if ulPropTag is not in lpptaCols
 */

__inline BOOL
FFindColumn(	LPSPropTagArray	lpptaCols,
		 		ULONG			ulPropTag )
{
	UNALIGNED ULONG *	pulPropTag;


	pulPropTag = lpptaCols->aulPropTag + lpptaCols->cValues;
	while ( --pulPropTag >= lpptaCols->aulPropTag )
		if ( *pulPropTag == ulPropTag )
			return TRUE;

	return FALSE;
}



/*============================================================================
 -	ScFindRow()
 -
 *		Finds the first row in the table data whose index column property
 *		value is equal to that of the specified property and returns the
 *		location of that row in the table data, or, if no such row exists,
 *		the end of the table data.
 *
 *	Parameters:
 *		lptad		in		TAD in which to find row
 *		lpprop		in		Index property to match
 *		puliRow		out		Pointer to location of found row
 *
 *	Error returns:
 *		MAPI_E_INVALID_PARAMETER	If proptag of property isn't the TAD's
 *										index column's proptag.
 *		MAPI_E_NOT_FOUND			If no matching row is found (*pplprow
 *										is set to lptad->parglprows +
 *										lptad->cRows in this case).
 */

__inline SCODE
ScFindRow(
	LPTAD			lptad,
	LPSPropValue	lpprop,
	LPSRow * *		pplprow)
{
	SCODE			sc = S_OK;
	SRow			row = {0, 1, lpprop};
	SizedSSortOrderSet(1, sosIndex) = { 1, 0, 0 };

	if (lpprop->ulPropTag != lptad->ulPropTagIndexCol)
	{
		sc = MAPI_E_INVALID_PARAMETER;
		goto ret;
	}

	Assert(!IsBadWritePtr(pplprow, sizeof(*pplprow)));

	//	Build a sort order set for the Index Column
	sosIndex.aSort[0].ulPropTag = lptad->ulPropTagIndexCol;
	sosIndex.aSort[0].ulOrder = TABLE_SORT_ASCEND;

	*pplprow = PlprowCollateRow(lptad->ulcRowsIndex,
							  lptad->parglprowIndex,
							  (LPSSortOrderSet) &sosIndex,
							  FALSE,
							  &row);

	//	Find the row in the Index Sorted Row Set
	if (   !lptad->ulcRowsIndex
		|| (*pplprow >= (lptad->parglprowIndex + lptad->ulcRowsIndex))
		|| LPropCompareProp( lpprop, (**pplprow)->lpProps))
	{
		sc = MAPI_E_NOT_FOUND;
	}

ret:
	return sc;
}
#else  // !WIN16
BOOL FFindColumn( LPSPropTagArray lpptaCols, ULONG ulPropTag );
SCODE ScFindRow( LPTAD lptad, LPSPropValue lpprop, LPSRow * * pplprow);
#endif // !WIN16


//	This macro is used on a ULONG or INT that is to be used as denominator
//	If ul is non-zero it is returned unchanged.  If ul is zero then a 1 is
//	returned.
#define	UlDenominator(ul)	((ul) | !(ul))

BOOL
FRowContainsProp(LPSRow			lprow,
				 ULONG			cValues,
				 LPSPropValue	lpsv);

STDAPI_(SCODE)
CreateTableData(LPCIID lpiid,
  ALLOCATEBUFFER FAR *  lpfAllocateBuffer,
  ALLOCATEMORE FAR *    lpfAllocateMore,
  FREEBUFFER FAR *      lpfFreeBuffer,
  LPVOID                lpvReserved,
  ULONG                 ulTableType,
  ULONG                 ulPropTagIndexCol,
  LPSPropTagArray       lpptaCols,
  LPVOID                lpvDataSource,
  ULONG                 cbDataSource,
  LPSBinary             pbinContEID,
  ULONG                 ulFlags,
  LPTABLEDATA FAR *     lplptad);

HRESULT HrVUERestrict(  LPVUE   lpvue,
                        LPSRestriction lpres,
                        ULONG   ulFlags );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_mailusr.h ===
#ifndef _MAILUSER_H_
#define _MAILUSER_H_


#undef	INTERFACE
#define INTERFACE	struct _MailUser

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, MailUser_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, MailUser_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(MailUser_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};


//	Keep the base members common across all the MAILUSER, CONTAINER, DISTLIST objects
// such that code reuse is leveraged.
//
#define MAILUSER_BASE_MEMBERS(_type)											 \
    MAPIX_BASE_MEMBERS(_type)                                                   \
                                                                                \
    LPPROPDATA          lpPropData;                                             \
    LPENTRYID           lpEntryID;                                              \
    LPIAB               lpIAB;                                                  \
    ULONG               ulObjAccess;                                            \
    ULONG               ulCreateFlags;                                          \
    LPSBinary           pmbinOlk;                                               \
    LPVOID              lpv;

typedef struct _MailUser {
    MAILUSER_BASE_MEMBERS(MailUser)
} MailUser, FAR * LPMailUser;	


HRESULT HrSetMAILUSERAccess(LPMAILUSER lpMAILUSER, ULONG ulFlags);
HRESULT HrNewMAILUSER(LPIAB lpIAB, LPSBinary pmbinOlk, ULONG ulType, ULONG ulFlags, LPVOID * lppMAILUSER);
BOOL FixDisplayName(    LPTSTR lpFirstName,
                        LPTSTR lpMiddleName,
                        LPTSTR lpLastName,
                        LPTSTR lpCompanyName,
                        LPTSTR lpNickName,
                        LPTSTR * lppDisplayName,
                        LPVOID lpvRoot);
// Parses a display name into first and last ...
BOOL ParseDisplayName(  LPTSTR lpDisplayName,
                        LPTSTR * lppFirstName,
                        LPTSTR * lppLastName,
                        LPVOID lpvRoot,
                        LPVOID * lppLocalFree);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_memcpy.h ===
/*
 *	MemCopy()
 *
 *	A much safer version of memcpy that checks the value of the byte
 *	count before calling the memcpy() function.  This macro is only built
 *	into the 16 bit non-debug builds.
 */

#ifndef __MEMCPY_H_
#define __MEMCPY_H_

#if defined(WIN16) && !defined(DEBUG)
#define MemCopy(_dst,_src,_cb)		do									\
									{									\
										size_t __cb = (size_t)(_cb);	\
										if (__cb)						\
											memcpy(_dst,_src,__cb);		\
									} while (FALSE)
#else
#define MemCopy(_dst,_src,_cb)	memcpy(_dst,_src,(size_t)(_cb))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_mapiprv.h ===
/*
 *	_MAPIPRV.H
 *
 *	MAPIX subsystem-wide definitions
 */

#ifdef __cplusplus
extern "C" {
#endif


#ifdef OLD_STUFF
#if defined(WIN32) && !defined(MAC) && !defined (COINITEX_DEFINED) && !defined(NT_BUILD)

// COM initialization flags; passed to CoInitializeEx.
// Doc'ed by OLE but not in their header. Not on Windows 95 yet.

typedef enum tagCOINIT
{
  COINIT_MULTITHREADED = 0,      // OLE calls objects on any thread.
  COINIT_SINGLETHREADED = 1,        // OLE calls objects on single thread.
  COINIT_APARTMENTTHREADED = 2        //$ MAIL: OLE apartment model.
} COINIT;

STDAPI  CoInitializeEx(LPMALLOC pMalloc, ULONG);

#endif	/**/
#endif



#ifndef MAC
typedef struct ProcessSerialNumber	{
	unsigned long			highLongOfPSN;
	unsigned long			lowLongOfPSN;
} ProcessSerialNumber;
#endif

#define	PSN							ProcessSerialNumber

/*
 *	IsEqualIID
 *
 *	This redefinition removes a dependency on compobj.dll.
 *	//$ It uses a byte-order-insensitive comparison on data that is
 *	//$ inherently byte-order-sensitive. If we ever wind up
 *	//$ remoting MAPI interfaces directly, it will break.
 */

#undef  IsEqualIID
#define IsEqualIID(i1,i2) IsEqualMAPIUID((i1), (i2))


#ifndef CharSizeOf
#define CharSizeOf(x)	(sizeof(x) / sizeof(TCHAR))
#endif

// explicit implementation of CharSizeOf
#define CharSizeOf_A(x)	(sizeof(x) / sizeof(CHAR))
#define CharSizeOf_W(x)	(sizeof(x) / sizeof(WCHAR))



/*
 *	Shared memory header structure. This is the only thing that must
 *	appear at a fixed offset in the shared memory block; anything else
 *	can move.
 *
 *	//$ the shared profile name is for a temporary implementation of
 *	//$ piggyback logon
 */


#define ghnameMAPIX		((GHNAME)0x4d417049)	// Name of Global Heap
#define cbGHInitial		((DWORD) 0x00002000)	// Initial size of Global Heap
#define cKeyIncr   		0x10					// # of notif key slots to allocate

typedef struct
{
	ULONG	cRef;
	GHID	ghidSharedProfile;		// for fake piggyback logon
	UINT	cRefHack;

									// Spooler stuff
#if defined(WIN32) && !defined(MAC)
	DWORD	dwSpoolerPid;			// spooler's process handle
#elif defined(MAC)
	PSN		psnSpooler;				// spooler's process serial number
#else
	HTASK	htaskSpooler;			// spooler's task handle
#endif
	HWND	hwndSpooler;			// spooler's window handle
	UINT	cRefSpooler;			// maintained but not used
	UINT	uSpooler;				// spooler status
	DWORD	dwSecurePid;			// security pid
	LONG	lSecureId;				// security id

									// Subsystem stuff
	GHID	ghidTaskList;			// linked list of active MAPI callers
	GHID	ghidProfList;			// linked list of profile info

									// Notification stuff
	USHORT	cKeyMac;				// count of registered keys
	USHORT	cKeyMax;				// size of key offset array
	GHID	ghidKeyList;			// list of registered keys
									// (array of offsets)
	ULONG	ulConnectStub;			// stub spooler registration

	GHID	ghidOptionList;			// Transport registration stuff
									// Linked-list of per message & per
									// recipient options registered by XPs

	GHID	ghidUIMutexList;		// Linked list of UI mutexes

	GHID	ghididmp;				// Offset of session/identity mapping
	ULONG	cidmp;					// Count of mappings
	ULONG	cidmpMax;				// Available mappings

	GHID	ghidMsgCacheCtl; 		// Simple MAPI MsgID cache control struct
	
} SHDR, FAR *LPSHDR;


/*
 *	STAG
 *	
 *	Sesstion tag -- tags a session with the processes that have logged
 *	into the profile represented by the session
 */

typedef struct _STAG
{
	union
	{
		DWORD	pid;
		HTASK	htask;
		PSN		psn;
	};
	
} STAG, FAR * LPSTAG;

/*
 *	SPROF
 *
 *	Shared profile session information.
 */

typedef struct
{
	ULONG	cRef;					// Number of sessions active
	GHID	ghidProfNext;			// Next item in chain

									// Profile / session flags
	USHORT	fSpoolerInitDone : 1;	// TRUE <=> all XPs are loaded
	USHORT	fSharedSession	 : 1;	// TRUE <=> shared session is on this profile
	USHORT	fDeletePending	 : 1;	// TRUE <=> delete profile when zero refcount
	USHORT	fCleanedProfile	 : 1;	// TRUE <=> already removed temp sections
	USHORT	wPad;

	GHID	ghidPBdata;				// secret stuff for piggyback logon

	ULONG	cRowMax;				// count of status rows
	GHID	ghidRowList;			// array of offsets to shared row data

	CHAR	rgchName[cchProfileNameMax+1];

	USHORT	cstagMac;				// count of stags
	USHORT	cstagMax;				// space available for stags
	GHID	ghidstag;				// array of stags held by the session

} SPROF, FAR *LPSPROF;


#ifdef MAC
typedef LRESULT (STDAPICALLTYPE NOTIFYPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct _tagNOTIFY {
	NOTIFYPROC	*wndProc;
	PSN			psn;
} NOTIFY, *LPNOTIFY;
#endif

/*
 *	STASK
 *
 *	Keeps track of outstanding notifications for a particular
 *	process. The notification parameters live in shared memory, and
 *	are hung on a chain from this structure.
 *
 *	The flag 'fSignalled' is set when a message is posted to the
 *	target task's notification window, and cleared when its
 *	notification queue is emptied. So at most one message at a
 *	time is outstanding to a given task.
 *
 *	There is also some auxiliary info like the task's module name,
 *	for use in debugging.
 */

#define	MAPI_TASK_SERVICE	0x0001	// task was started as a service
#define	MAPI_TASK_SPOOLER	0x0002	// MAPI spooler
#define	MAPI_TASK_PENDING	0x0004	// spooler not up yet
//#define MAPI_TASK_SIGNALLED	0x0008

typedef struct
{
	GHID		ghidTaskNext;		//	link to next STASK in chain

									//	Task ID info
#ifndef MAC
	HWND		hwndNotify;			//	notification window handle
#else
	LPNOTIFY	hwndNotify;			// Not an hwnd at all!
#endif
	CHAR		szModName[16];		//	module name of running process (ansi only)
#ifdef NT
	DWORD		dwPID;				//	If process was started as a service this will contain PID		
#endif
	UINT		uFlags;				//  Information about task, ie, it's a service
	BOOL		fSignalled;			//	TRUE <=> message in queue
	UINT		cparmsMac;			//	# of notifications (SPARMS)
	UINT		cparmsMax;			//	# of notification slots allocated
	GHID		ghidparms;			//	offset to list of SPARMS

	
} STASK, FAR *LPSTASK;




/*
 *	LIBINFO
 *
 *	Used to keep track of DLLs loaded. Stores the name of the Dll and
 *	associated handle.
 */

typedef struct
{
	LPSTR		szDllName;			//	Name of provider Dll (ANSI only)
	HINSTANCE	hInstDll;			//	Handle to the loaded Dll
} LIBINFO, FAR *LPLIBINFO;


/*
 *
 *	Access to proxy and stub internals is restricted to the remoting code only.
 *	The rest should only access the IUnknown.
 *
 */
typedef LPUNKNOWN LPPROXY;
typedef LPUNKNOWN LPSTUB;

/*
 *	Instance global data for mapix.dll -- that is, information
 *	associated with a particular process.
 */

typedef struct
{
	BOOL			fTriedDlg;		// TRUE <=> tried to load dialog DLL
	HINSTANCE		hinstDlg;		// dialogs DLL instance handle
#ifdef OLD_STUFF
	MAPIDLG_ScInitMapidlg *pfnInitDlg;	// dialog fn proc address
	JT_MAPIDLG		jtDlg;			// dialog functions jump table

	LPSESSOBJ		psessobj;		// chain of session objects
	LPIPA			pipa;			// chain of ProfAdmin objects
	HINSTANCE		hinstProfile;	// profile DLL instance handle
	LPPRPROVIDER	lpPRProvider;	// -> profile provider object
#endif

#if 0	//$	Not needed with the new deferred provider unloading at deinit time
		
	HINSTANCE		hLibrary;		// latest library to be released

#else	//$	Deferred provider unloading support

	UINT			cLibraries;		// number of providers loaded
	LPLIBINFO 		lpLibInfo;		// array of info on loaded providers

#endif

//$New SMem stuff
	HGH				hghShared;		// handle to the global heap
	GHID			ghidshdr;		// offset of shared header struct (the Root)
//$New SMem stuff

//$Old SMem stuff
//	PSMEM			psmem;			// shared memory block
//	LPSMALLOC		psmalloc;		// shared heap manager
//	UINT			ibshdr;			// offset of shared header struct
//$Old SMem stuff

	ULONG			ulXPStatus;		// catches transport status row notifs
#ifndef MAC
	HWND			hwndNotify;		// multi-process notification info
#else
	LPNOTIFY		hwndNotify;		// Not an hwnd at all!
#endif
#ifdef OLD_STUFF
	LPADVISELIST	padviselist;	// open notifs on session
#endif

#if defined(WIN32) && !defined(MAC)
	HANDLE			htNotify;		// thread handle of notification thread
	DWORD			tidNotify;		// thread ID of notification thread
	HANDLE			heventNotify;	// event handle for thread sync
 	SCODE			scInitNotify;	// for use during startup only
#endif

#ifdef OLD_STUFF
    HMODULE			hmodWmsfr;		// form registry lib handle
    LPFNMAPIREGCREATE pfnCreateObject; // form registry init function
	LPMESSAGEFILTER	pMsgFilter;		// IMessage Filter interface
	LPUNKNOWN		pUnkPSFactory;	// Proxy Stub Factory's IUnknown
	LPPROXY			pProxyListHead;	// First of a chain of active proxy objects
	LPSTUB			pStubListHead;	// First of a chain of active stub objects
#endif

#if defined(WOW)
	LPVOID			pvConnection1632; // The 16 to 32 bit connection
#endif

#if defined(WIN16) && !defined(WOW)
	HWND			hwndMarshal;	// Window to defer release on an unmarshalled
									// interface to workaround 16bit CoMarshalInterface
									// bug - see SqlGuest:Exchange #14416.
#endif

	LPVOID			psvctbl;		// Spooler's service scheduler

	LPVOID			pvSentinel;		// Variables ABOVE this point are zeroed
									// at the last MAPIUninitialize; those
									// BELOW this point are not.

	int				cRef;			// reference count for this instance

	LPMALLOC		pmallocOrig;	// allocator from OLE - CoGetMalloc()
	HLH				hlhProvider;	// heap for Provider MAPIAllocateBuffer/More
	HLH				hlhInternal;	// heap for internal allocations
	ULONG			ulInitFlags;	// MAPIInitialize Flags for notification
									// support

	HMODULE			hmod;			// module handle of running process
	CHAR			szModName[16];	// module name of running process (ansi only)
#ifdef	WIN16
	HINSTANCE		hinstApp;		// calling app's instance handle
#endif	

#ifdef	WIN32
	HANDLE			heSecure;		// spooler blocking mutex
#endif
	
	CRITICAL_SECTION cs;			// critical section data
} INST, FAR *LPINST;



//
//  Generic internal entry ID structure
//
#pragma warning (disable: 4200)

typedef struct _MAPIEID {
	BYTE	abFlags[4];
	MAPIUID	mapiuid;
	UNALIGNED BYTE	bData[];
} MAPI_ENTRYID;

typedef UNALIGNED MAPI_ENTRYID *LPMAPI_ENTRYID;


extern HINSTANCE hinstMapiX;
extern HINSTANCE hinstMapiXWAB;

extern BOOL fGlobalCSValid;

extern BOOL bDNisByLN;
extern TCHAR szResourceDNByLN[32];
extern TCHAR szResourceDNByCommaLN[32];
extern TCHAR szResourceDNByFN[32];
extern BOOL bPrintingOn;
extern HANDLE ghEventOlkRefreshContacts;
extern HANDLE ghEventOlkRefreshFolders;

#ifdef OLD_STUFF
#pragma warning (default: 4200)

//	Hack structure for shared session
typedef struct
{
	UINT	cb;			//	all-inclusive
	UINT	cbsd;
	BYTE	ab[1];
} SESSHACK, FAR *LPSESSHACK;

//	Globally defined notification keys

extern struct _NOTIFKEY_notifkeyXPStatus notifkeyXPStatus;
extern struct _NOTIFKEY_notifkeyOlaf notifkeyOlaf;

//	Globally defined UIDs

extern MAPIUID muidProviderSection;
extern MAPIUID muidStoreWrap;
extern MAPIUID muidStatusWrap;
extern MAPIUID muidOOP;

#if defined(WIN32) && !defined(MAC)
#ifndef DATA1_BEGIN
#include "mapiperf.h"
#endif
#pragma DATA1_BEGIN
extern CRITICAL_SECTION csMapiInit;
extern CRITICAL_SECTION csHeap;
extern CRITICAL_SECTION csMapiSearchPath;
extern BOOL fGlobalCSValid;
#pragma DATA_END
#endif

//	Notification engine

SCODE			ScInitNotify( LPINST pinst );

void			DeinitNotify(void);
STDMETHODIMP	HrSubscribe(LPADVISELIST FAR *lppAdviseList,
						LPNOTIFKEY lpKey,
						ULONG ulEventMask,
						LPMAPIADVISESINK lpAdvise,
						ULONG ulFlags,
						ULONG FAR *lpulConnection);
STDMETHODIMP	HrUnsubscribe(LPADVISELIST FAR *lppAdviseList,
						ULONG ulConnection);
STDMETHODIMP	HrNotify(LPNOTIFKEY lpKey,
						ULONG cNotification,
						LPNOTIFICATION lpNotifications,
						ULONG * lpulFlags);

//	Instantiate an IMsgServiceAdmin interface

SCODE			ScNewServiceAdmin(LPMAPIPROF pprofile,
						LPVOID lpParentObj,
						LPSESSOBJ psessobj,
						LPTSTR lpszProfileName,
						ULONG ulFlags,
						LPSERVICEADMIN FAR *lppServiceAdmin);

// Instantiate an IProviderAdmin interface

SCODE			ScNewProviderAdmin(LPMAPIPROF pprofile,
						LPVOID lpParentObj,
						LPTSTR lpszProfileName,
						ULONG ulFlags,
						LPMAPIUID lpUID,
						BOOL fService,
						LPPROVIDERADMIN FAR *lppProviderAdmin);

//	Find (and optionally make) an SPROF list entry for a profile

LPSPROF PsprofFindCreate(HGH hgh, GHID ghidshdr, LPSTR szProfile,
		BOOL fCreate);

//	Decrement the global refcounts for a session
SCODE	ScDerefSessionGlobals(LPTSTR lpszProfileName);
SCODE	ScDerefProcessSessionGlobals(LPTSTR lpszProfileName
#if defined(WIN32) && !defined(MAC)
	, DWORD pid
#elif defined(MAC)
	, PSN *ppsn
#elif defined(WIN16)
	, HTASK htask
#endif
	, ULONG ulFlags
	);

//	Validate the spooler globals
//		S_OK				The spooler is up and running
//		S_FALSE				No spooler is running
//		MAPI_E_CALL_FAILED	The spooler has died

SCODE			ScSpoolerStatus(LPINST pinst, LPSHDR pshdr);
void			StopSpooler(LPSHDR pshdr);		//	NOT USED by design

//	Overall subsystem startup-shutdown routines

SCODE			ScInitMapiX(ULONG ulFlags, LPBYTE lpbSecurity);
void			DeinitMapiX(void);
SCODE			ScInitCompobj(LPINST FAR *ppinst, DWORD dwPid);
void			DeinitCompobj(LPINST pinst);
void			DestroyMapidlg(LPINST pinst);
void			CloseMapidlg(void);
SCODE			ScGetDlgFunction(UINT ibFunction, FARPROC FAR *lppfn,
						BOOL *pfDidInit);
#ifdef	WIN16
HINSTANCE		HinstApplication(void);
#endif	
LPMALLOC		PMallocOrig(void);
HLH				HlhInternal(void);
void			CleanupSession(LPSESSOBJ psessobj, BOOL fToldSpooler);
void			LogoffSpooler(LPSESSOBJ psessobj, ULONG ulReserved);

//	Get information about an entry ID

HRESULT			HrGetEIDType(LPSESSOBJ psessobj,
						ULONG cbeid,
						LPENTRYID peid,
						ULONG FAR *pulType,
						LPUNKNOWN FAR *ppunk);

//	Get information about a pair of entry IDs

HRESULT			HrGetEIDPairType(LPSESSOBJ psessobj,
						ULONG cbeid1,
						LPENTRYID peid1,
   						ULONG cbeid2,
   						LPENTRYID peid2,
						ULONG FAR *pulType,
						LPUNKNOWN FAR *ppunk);

//	Critical section for instance globals

STDAPI_(SCODE)	ScGetInst(LPINST FAR *ppinst);
STDAPI_(void)	ReleaseInst(LPINST FAR *ppinst);

//	Profile section access checks

typedef enum
{
	profaccClient = 0,
	profaccProvider,
	profaccService
} PROFACC;

HRESULT			HrCheckProfileAccess(PROFACC profacc,
						LPMAPIUID lpuid,
						LPMAPIUID lpuidParent,
						LPMAPIPROF pprofile);

#endif      // OLD_STUFF
#ifdef	__cplusplus
}		//	extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_notify.h ===
/*
 *      _NOTIFY.H
 *
 *      WAB Notification Engine Headers
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 */

#define MAX_NOTIFICATION_SPACE 0x10000  // maximum size of shared memory
#define WAB_W_NO_ADVISE (MAKE_MAPI_S(0x1002))

// Notification node structure for Global Notification List
typedef struct _NOTIFICATION_NODE {
   ULONG ulIdentifier;                  // unique identifier for this notification
   ULONG ulCount;                       // number of advise processes that have seen it
   NOTIFICATION Notification;           // notification structure
   struct _NOTIFICATION_NODE * lpNext;  // Pointer to next node
   ULONG cbData;                        // size of data in bytes
   BYTE Data[];                         // additional data for this node
} NOTIFICATION_NODE, * LPNOTIFICATION_NODE;

// Notification list structure for Global Notification List
typedef struct _NOTICATION_LIST {
    ULONG cAdvises;                     // Number of advise processes
    ULONG cEntries;                     // Number of entries in the list
    ULONG ulNextIdentifier;             // next notification identifer
    LPNOTIFICATION_NODE lpNode;         // First node in list or NULL if empty
} NOTIFICATION_LIST, *LPNOTIFICATION_LIST;

// Advise node structure for Local Advise List
typedef struct _ADVISE_NODE {
    ULONG ulConnection;                 // connection identifier
    ULONG ulEventMask;                  // mask of event types
    LPMAPIADVISESINK lpAdviseSink;      // AdviseSink object to be called on notification
    struct _ADVISE_NODE * lpNext;       // next node in AdviseList
    struct _ADVISE_NODE * lpPrev;       // next node in AdviseList
    ULONG cbEntryID;                    // size of lpEntryID
    BYTE EntryID[];                     // EntryID of object to advise on
} ADVISE_NODE, *LPADVISE_NODE;

// Advise list structure for Local Advise List
typedef struct _ADVISE_LIST {
    ULONG cAdvises;                     // Number of nodes in the list
    LPADVISE_NODE lpNode;
} ADVISE_LIST, *LPADVISE_LIST;

HRESULT HrFireNotification(LPNOTIFICATION lpNotification);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_printex.h ===
/*-------------------------------------------------------------------

  _printEx.h

  
    HACK!


    We need to add support for NT5 PrintDlgEx function but turns out
    that the corresponding headers are included for WinVER = 0x0500 ..
    but since WAB is being built with 0x0400, we can't include the
    headers directly - so we have included a copy of the PrintDlgEx

    At some point of time we should remove this copy and just use
    commdlg.h
    
      Created: 9/25/98 - Vikramm
--------------------------------------------------------------------*/

#ifdef STDMETHOD

#if(WINVER < 0x0500)
/*

//-------------------------------------------------------------------------
//
//  IPrintDialogCallback Interface
//
//  IPrintDialogCallback::InitDone()
//    This function is called by PrintDlgEx when the system has finished
//    initializing the main page of the print dialog.  This function
//    should return S_OK if it has processed the action or S_FALSE to let
//    PrintDlgEx perform the default action.
//
//  IPrintDialogCallback::SelectionChange()
//    This function is called by PrintDlgEx when a selection change occurs
//    in the list view that displays the currently installed printers.
//    This function should return S_OK if it has processed the action or
//    S_FALSE to let PrintDlgEx perform the default action.
//
//  IPrintDialogCallback::HandleMessage(hDlg, uMsg, wParam, lParam, pResult)
//    This function is called by PrintDlgEx when a message is sent to the
//    child window of the main page of the print dialog.  This function
//    should return S_OK if it has processed the action or S_FALSE to let
//    PrintDlgEx perform the default action.
//
//  IObjectWithSite::SetSite(punkSite)
//    IPrintDialogCallback usually paired with IObjectWithSite.
//    Provides the IUnknown pointer of the site to QI for the
//    IPrintDialogServices interface.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   IPrintDialogCallback

DECLARE_INTERFACE_(IPrintDialogCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IPrintDialogCallback methods ***
    STDMETHOD(InitDone) (THIS) PURE;
    STDMETHOD(SelectionChange) (THIS) PURE;
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pResult) PURE;
};


*/

//
//  Page Range structure for PrintDlgEx.
//
typedef struct tagPRINTPAGERANGE {
   DWORD  nFromPage;
   DWORD  nToPage;
} PRINTPAGERANGE, *LPPRINTPAGERANGE;

#define START_PAGE_GENERAL             0xffffffff

//
//  PrintDlgEx structure.
//
typedef struct tagPDEXA {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCSTR                lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXA, *LPPRINTDLGEXA;
//
//  PrintDlgEx structure.
//
typedef struct tagPDEXW {
   DWORD                 lStructSize;          // size of structure in bytes
   HWND                  hwndOwner;            // caller's window handle
   HGLOBAL               hDevMode;             // handle to DevMode
   HGLOBAL               hDevNames;            // handle to DevNames
   HDC                   hDC;                  // printer DC/IC or NULL
   DWORD                 Flags;                // PD_ flags
   DWORD                 Flags2;               // reserved
   DWORD                 ExclusionFlags;       // items to exclude from driver pages
   DWORD                 nPageRanges;          // number of page ranges
   DWORD                 nMaxPageRanges;       // max number of page ranges
   LPPRINTPAGERANGE      lpPageRanges;         // array of page ranges
   DWORD                 nMinPage;             // min page number
   DWORD                 nMaxPage;             // max page number
   DWORD                 nCopies;              // number of copies
   HINSTANCE             hInstance;            // instance handle
   LPCWSTR               lpPrintTemplateName;  // template name for app specific area
   LPUNKNOWN             lpCallback;           // app callback interface
   DWORD                 nPropertyPages;       // number of app property pages in lphPropertyPages
   HPROPSHEETPAGE       *lphPropertyPages;     // array of app property page handles
   DWORD                 nStartPage;           // start page id
   DWORD                 dwResultAction;       // result action if S_OK is returned
} PRINTDLGEXW, *LPPRINTDLGEXW;
#ifdef UNICODE
typedef PRINTDLGEXW PRINTDLGEX;
typedef LPPRINTDLGEXW LPPRINTDLGEX;
#else
typedef PRINTDLGEXA PRINTDLGEX;
typedef LPPRINTDLGEXA LPPRINTDLGEX;
#endif // UNICODE

HRESULT  APIENTRY  PrintDlgExA(LPPRINTDLGEXA);
HRESULT  APIENTRY  PrintDlgExW(LPPRINTDLGEXW);
#ifdef UNICODE
#define PrintDlgEx  PrintDlgExW
#else
#define PrintDlgEx  PrintDlgExA
#endif // !UNICODE

/*--------------------------------------------------------------------------*/

DEFINE_GUID(IID_IPrintDialogCallback, 0x5852a2c3, 0x6530, 0x11d1, 0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9);

/*--------------------------------------------------------------------------*/
#endif	// (WINVER < 0x0500)


#define WAB_PRINTDIALOGCALLBACK_METHODS(IPURE)                          \
    MAPIMETHOD_(HRESULT, InitDone)                                      \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, SelectionChange)                               \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, HandleMessage)                                 \
                (THIS_  HWND hDlg, UINT uMsg, WPARAM wParam,            \
                        LPARAM lParam, LRESULT *pResult)        IPURE;
#undef  INTERFACE
#define INTERFACE       struct _WAB_PRINTDIALOGCALLBACK

#undef  METHOD_PREFIX
#define METHOD_PREFIX   WAB_PRINTDIALOGCALLBACK_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, WAB_PRINTDIALOGCALLBACK_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_PRINTDIALOGCALLBACK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, WAB_PRINTDIALOGCALLBACK_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_PRINTDIALOGCALLBACK_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WAB_PRINTDIALOGCALLBACK_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_PRINTDIALOGCALLBACK_METHODS(IMPL)
};

typedef struct _WAB_PRINTDIALOGCALLBACK
{
    MAPIX_BASE_MEMBERS(WAB_PRINTDIALOGCALLBACK)

    LPIAB lpIAB;

    DWORD dwSelectedStyle; 

} WABPRINTDIALOGCALLBACK, * LPWABPRINTDIALOGCALLBACK;

HRESULT HrCreatePrintCallbackObject(LPIAB lpIAB, LPWABPRINTDIALOGCALLBACK * lppWABPCO, DWORD dwSelectedStyle);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_runt.h ===
/*
 *	_RUNT.H
 *	
 *	DLL central for the MAPI utilities.
 */

#ifndef _RUNT_H_
#define _RUNT_H_

#ifdef	__cplusplus
extern "C" {
#endif

// Per-process instance data for utilities functions

DeclareInstList(lpInstUtil);

#define INSTUTIL_SIG_BEG		0x54534E49	// 'INST'
#define INSTUTIL_SIG_END		0x4C495455	// 'UTIL'

typedef struct
{
#ifdef WIN16
	DWORD		dwBeg;			// INSTUTIL_SIG_BEG
	WORD		wSS;			// Stack segment of current task
	HTASK		hTask;			// HTASK of current task
#endif

	UINT		cRef;

								// General stuff
	HLH			hlhClient;		// Heap for allocations

								// Idle engine stuff
	ULONG		cRefIdle;	  	/* reference count */
	LPMALLOC	lpMalloc;	  	/* memory allocator */
	HINSTANCE	hInst;			/* */
	HWND		hwnd;		  	/* handle of hidden window */
	int			iftgMax;	  	/* size of idle routine registry */
	int			iftgMac;	  	/* number of registered idle routines */
#if !(defined(WIN32) && !defined(MAC))
	UINT		uiWakeupTimer; 	/* Timer to wake up & run idle routines */
#endif

#ifdef OLD_STUFF
	PFTG		pftgIdleTable;	/* ptr to table of registered routines */
#endif
	int			iftgCur;	  	/* Index in pftgIdleTable of currently */
								/* running ftgCur routine or recently run */
	USHORT		schCurrent;		/* current idle routine state from last */
								/* FDoNextIdleTask() call */
	BOOL		fIdleExit;		/* flag set TRUE if idle routines are */
								/* being called from IdleExit */

#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION	cs;		/* gate to keep multiple threads from */
								/* accessing global data at the same time */
	BOOL		fSignalled;		/* Only do this when we need to */
	HANDLE		hTimerReset;	/* Used to signal timer reset */
	HANDLE		hTimerThread;	/* Timer thread handle */
	DWORD		dwTimerThread;	/* Timer thread ID */
	DWORD		dwTimerTimeout;	/* Current timeout value */
	BOOL		fExit;			/* if TRUE, timer thread should exit */
#endif

#ifdef WIN16
	LPVOID		pvBeg;			// Pointer back to beginning of pinst
	DWORD		dwEnd;			// INSTUTIL_SIG_END
#endif

} INSTUTIL, FAR *LPINSTUTIL;




#define MAPIMDB_VERSION	((BYTE) 0x00)
#define MAPIMDB_NORMAL	((BYTE) 0x00)	// Normal wrapped store EntryID
#define MAPIMDB_SECTION	((BYTE) 0x01)	// Known section, but no EntryID

#define MUIDSTOREWRAP {		\
	0x38, 0xa1, 0xbb, 0x10,	\
	0x05, 0xe5, 0x10, 0x1a,	\
	0xa1, 0xbb, 0x08, 0x00,	\
	0x2b, 0x2a, 0x56, 0xc2 }

typedef struct _MAPIMDBEID {
	BYTE	abFlags[4];
	MAPIUID	mapiuid;
	BYTE	bVersion;
	BYTE	bFlagInt;
	BYTE	bData[MAPI_DIM];
} MAPIMDB_ENTRYID, *LPMAPIMDB_ENTRYID;

#define CbNewMAPIMDB_ENTRYID(_cb)	\
	(offsetof(MAPIMDB_ENTRYID,bData) + (_cb))
#define CbMAPIMDB_ENTRYID(_cb)		\
	(offsetof(MAPIMDB_ENTRYID,bData) + (_cb))
#define SizedMAPIMDB_ENTRYID(_cb, _name) \
	struct _MAPIMDB_ENTRYID_ ## _name \
{ \
	BYTE	abFlags[4]; \
	MAPIUID	mapiuid;	\
	BYTE	bVersion;	\
	BYTE	bFlagInt;	\
	BYTE	bData[_cb];	\
} _name

// This macro computes the length of the MAPI header on a store entryid.
// The provider-specific data starts on a 4-byte boundary following the
// DLL Name. The cb parameter is the length of the DLL name in bytes (counting
// the NULL terminator).
#define CB_MDB_EID_HEADER(cb)	((CbNewMAPIMDB_ENTRYID(cb) + 3) & ~3)

// Internal function that gets a new UID
STDAPI_(SCODE)			ScGenerateMuid(LPMAPIUID lpMuid);



// Internal function that gets the utilities heap
HLH						HlhUtilities(VOID);

// Critical section for serializing heap access
#if defined(WIN32) && !defined(MAC)
extern CRITICAL_SECTION	csHeap;
#endif
#if defined(WIN32) && !defined(MAC)
extern CRITICAL_SECTION	csMapiInit;
#endif
#if defined(WIN32) && !defined(MAC)
extern CRITICAL_SECTION	csMapiSearchPath;
#endif


// Access the DLL instance handle

LRESULT STDAPICALLTYPE
DrainFilteredNotifQueue(BOOL fSync, ULONG ibParms, LPNOTIFKEY pskeyFilter);


//$ used by ITable
LPADVISELIST lpAdviseList;
LPNOTIFKEY lpNotifKey;
LPMAPIADVISESINK lpMAPIAdviseSink;
LPNOTIFICATION lpNotification;


STDMETHODIMP			HrSubscribe(LPADVISELIST FAR *lppAdviseList, LPNOTIFKEY lpKey,
						ULONG ulEventMask, LPMAPIADVISESINK lpAdvise, ULONG ulFlags,
						ULONG FAR *lpulConnection);
STDMETHODIMP			HrUnsubscribe(LPADVISELIST FAR *lppAdviseList, ULONG ulConnection);
STDMETHODIMP			HrNotify(LPNOTIFKEY lpKey, ULONG cNotification,
						LPNOTIFICATION lpNotifications, ULONG * lpulFlags);

#ifndef PSTRCVR
#endif //PSTRCVR



//$	END

#ifdef	__cplusplus
}
#endif

#endif	//	_RUNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_mapiu.h ===
/*
 *	_ M A P I U . H
 *	
 *	Non-public MACROs and FUNCTIONs which may be used by MAPI
 *
 *	Used in conjunction with routines found in MAPIU.DLL.
 *	
 *	Copyright 1992-93 Microsoft Corporation.  All Rights Reserved.
 */
#ifndef	_MAPIU_H
#define	_MAPIU_H

#ifdef __cplusplus
extern "C" {
#endif

extern CRITICAL_SECTION csUnkobjInit;


/* Macros provided by MAPIU
 */
#ifndef CharSizeOf
#define CharSizeOf(x)	(sizeof(x) / sizeof(x[0]))
#endif

//	Alignment

#define AlignN(n, x)		(((x)+(1<<(n))-1) & ~((1<<(n))-1))
#define Align2(x)			AlignN(1,(x))
#define Align4(x)			AlignN(2,(x))
#define Align8(x)			AlignN(3,(x))

#if defined (_AMD64_) || defined (_IA64_)
#define	AlignNatural(cb)			Align8(cb)
#elif defined (WIN32)
#define	AlignNatural(cb)			Align4(cb)
#else // defined (WIN16)
#define	AlignNatural(cb)			Align2(cb)
#endif

#define FIsAligned(p)				(AlignNatural((ULONG_PTR)((LPVOID)p)) == (ULONG_PTR)((LPVOID)p))
#define FIsAlignedCb(cb)			(AlignNatural((ULONG_PTR)(cb)) == (ULONG_PTR)(cb))

/* Prototypes for private math functions
 */
STDAPI_(DWORD)
DwDivFtDw( FILETIME ftDividend, DWORD dwDivisor);

VOID
VSzFromIDS(ULONG ulIDS, UINT uncchBuffer, LPWSTR lpszBuffer, ULONG ulFlags);

/* Prototype for LoadString wrapper
 * Utility to allocate memory and loadstring and string IDS, ANSI/UNICODE.
 */

#define MAX_CCH_IDS		256
SCODE ScStringFromIDS( LPALLOCATEBUFFER lpMapiAllocBuffer, ULONG ulFlags, UINT ids,
		LPTSTR * lppszIDS );

/* Prototypes for Message and Dialog Box utilities.
 */
SCODE
ScMessageBoxIDS( ULONG	ulUIParam,
				 UINT	idsCaption,
				 UINT	idsMessage,
				 UINT	uMBType);

/* Prototypes for MAPI status utilities.
 */
BOOL
FProfileLoggedOn( LPSTR	szProfileName);

/* Prototypes for functions used to validate complex parameters.
 */

#ifndef __cplusplus
#define	FBadIfacePtr(param, iface)					\
		(	IsBadReadPtr((param), sizeof(iface)) 	\
		 ||	IsBadReadPtr((param)->lpVtbl, sizeof(iface##Vtbl)))
#else
#define FBadIfacePtr(param, iface)	(FALSE)
#endif

/*
 *	FBadDelPTA
 *
 *	Returns TRUE if the given Prop Tag Array is readable and contains only
 *	prop tags which are valid for a DeleteProps (or related) call.
 */
STDAPI_(BOOL)
FBadDelPTA(LPSPropTagArray lpPropTagArray);


#ifndef WIN16 // WIN16 C compiler doesn't support INLINE functions.
/*
 *	IListedPropID
 *
 *  Purpose
 *		If a tag with ID == PROP_ID(ulPropTag) is listed in lptaga then
 *		the index of tag is returned.  If the tag is not in lptaga then
 *		-1 is returned.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
_inline LONG_PTR
IListedPropID( ULONG			ulPropTag,
			   LPSPropTagArray	lptaga)
{
	UNALIGNED ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return -1;
	}

	/* Mutate ulPropTag to just a PROP_ID.
	 */
    ulPropTag = PROP_ID(ulPropTag);

	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return (lpulPTag - lptaga->aulPropTag);
		}
	}

	return -1;
}

/*
 *	FListedPropID
 *
 *  Purpose
 *		Determine if a tag with ID == PROP_ID(ulPropTag) is listed in lptaga.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
_inline BOOL
FListedPropID( ULONG			ulPropTag,
			   LPSPropTagArray	lptaga)
{
	UNALIGNED ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return FALSE;
	}

	/* Mutate ulPropTag to just a PROP_ID.
	 */
    ulPropTag = PROP_ID(ulPropTag);

	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return TRUE;
		}
	}

	return FALSE;
}

/*
 *	FListedPropTAG
 *
 *  Purpose
 *		Determine if a the given ulPropTag is listed in lptaga.
 *
 *	Arguments
 *		ulPropTag	Property tag to locate.
 *		lptaga		Property tag array to search.
 *
 *	Returns		TRUE or FALSE
 */
_inline BOOL
FListedPropTAG( ULONG			ulPropTag,
				LPSPropTagArray	lptaga)
{
	UNALIGNED ULONG FAR	*lpulPTag;

	/* No tag is contained in a NULL list of tags.
	 */
    if (!lptaga)
	{
		return FALSE;
	}

	/* Compare the entire prop tag to be sure both ID and TYPE match
	 */
	for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
		; --lpulPTag >= lptaga->aulPropTag
		; )
	{
		/* Compare PROP_ID's.
		 */
		if (PROP_ID(*lpulPTag) == ulPropTag)
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	AddProblem
 *
 *  Purpose
 *		Adds a problem to the next available entry of a pre-allocated problem
 *		array.
 *		The pre-allocated problem array must be big enough to have another
 *		problem added.  The caller is responsible for making sure this is
 *		true.
 *
 *	Arguments
 *		lpProblems	Pointer to pre-allocated probelem array.
 *		ulIndex		Index into prop tag/value array of the problem property.
 *		ulPropTag	Prop tag of property which had the problem.
 *		scode		Error code to list for the property.
 *
 *	Returns		TRUE or FALSE
 */
_inline VOID
AddProblem( LPSPropProblemArray	lpProblems,
			ULONG				ulIndex,
			ULONG				ulPropTag,
			SCODE				scode)
{
	if (lpProblems)
	{
		Assert( !IsBadWritePtr( lpProblems->aProblem + lpProblems->cProblem
			  , sizeof(SPropProblem)));
		lpProblems->aProblem[lpProblems->cProblem].ulIndex = ulIndex;
		lpProblems->aProblem[lpProblems->cProblem].ulPropTag = ulPropTag;
		lpProblems->aProblem[lpProblems->cProblem].scode = scode;
		lpProblems->cProblem++;
	}
}

__inline BOOL
FIsExcludedIID( LPCIID lpiidToCheck, LPCIID rgiidExclude, ULONG ciidExclude)
{
	/* Check the obvious (no exclusions).
	 */
	if (!ciidExclude || !rgiidExclude)
	{
		return FALSE;
	}

	/* Check each iid in the list of exclusions.
	 */
	for (; ciidExclude; rgiidExclude++, ciidExclude--)
	{
//		if (IsEqualGUID( lpiidToCheck, rgiidExclude))
		if (!memcmp( lpiidToCheck, rgiidExclude, sizeof(MAPIUID)))
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	Error/Warning Alert Message Boxes
 */
int			AlertIdsCtx( HWND hwnd,
						 HINSTANCE hinst,
						 UINT idsMsg,
						 LPSTR szComponent,
						 ULONG ulContext,
						 ULONG ulLow,
						 UINT fuStyle);

__inline int
AlertIds(HWND hwnd, HINSTANCE hinst, UINT idsMsg, UINT fuStyle)
{
	return AlertIdsCtx(hwnd, hinst, idsMsg, NULL, 0, 0, fuStyle);
}

int			AlertSzCtx( HWND hwnd,
						LPSTR szMsg,
						LPSTR szComponent,
						ULONG ulContext,
						ULONG ulLow,
						UINT fuStyle);

__inline int
AlertSz(HWND hwnd, LPSTR szMsg, UINT fuStyle)
{
	return AlertSzCtx(hwnd, szMsg, NULL, 0, 0, fuStyle);
}
#else  // !WIN16
LONG IListedPropID( ULONG ulPropTag, LPSPropTagArray lptaga);
BOOL FListedPropID( ULONG ulPropTag, LPSPropTagArray lptaga);
BOOL FListedPropTAG( ULONG ulPropTag, LPSPropTagArray lptaga);
VOID AddProblem( LPSPropProblemArray lpProblems, ULONG ulIndex, ULONG ulPropTag, SCODE scode);
BOOL FIsExcludedIID( LPCIID lpiidToCheck, LPCIID rgiidExclude, ULONG ciidExclude);
int AlertIds(HWND hwnd, HINSTANCE hinst, UINT idsMsg, UINT fuStyle);
int AlertSzCtx( HWND hwnd, LPSTR szMsg, LPSTR szComponent, ULONG ulContext, ULONG ulLow, UINT fuStyle);
int AlertSz(HWND hwnd, LPSTR szMsg, UINT fuStyle);
#endif // !WIN16




/*  Encoding and decoding strings */
STDAPI_(void)			EncodeID(LPBYTE lpb, ULONG cb, LPTSTR lpsz);
STDAPI_(BOOL)			FDecodeID(LPTSTR lpsz, LPBYTE lpb, ULONG FAR *lpcb);
STDAPI_(ULONG)			CchOfEncoding(ULONG cb);
STDAPI_(ULONG)			CbOfEncoded(LPTSTR lpsz);
STDAPI_(int)			CchEncodedLine(int cb);


/*  Idle engine routines */

#ifdef	DEBUG

/*
 *	DumpIdleTable
 *
 *		Used for debugging only.  Writes information in the PGD(hftgIdle)
 *		table to COM1.
 */

STDAPI_(void)
DumpIdleTable (void);

#endif
/*
 *	FDoNextIdleTask
 *
 *		Dispatches the first eligible idle function, according to
 *		its simple scheduling algorithm.
 */

STDAPI_(BOOL) FDoNextIdleTask (void);

/* C runtime substitutes */

typedef int (__cdecl FNSGNCMP)(const void FAR *lpv1, const void FAR *lpv2);
typedef FNSGNCMP FAR *PFNSGNCMP;

FNSGNCMP				SgnCmpPadrentryByType;

BOOL FRKFindSubpb(LPBYTE pbTarget, ULONG cbTarget, LPBYTE pbPattern, ULONG cbPattern);
BOOL FRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);
LPSTR LpszRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);

STDAPI_(void)			ShellSort(LPVOID lpv, UINT cv,			/* qsort */
						LPVOID lpvT, UINT cb, PFNSGNCMP fpCmp);


/*  Advise list maintainence utilities  */
/*
 *	Structure and functions for maintaining a list of advise sinks,
 *	together with the keys used to release them.
 */

typedef struct
{
	LPMAPIADVISESINK	lpAdvise;
	ULONG				ulConnection;
	ULONG				ulType;
	LPUNKNOWN			lpParent;
} ADVISEITEM, FAR *LPADVISEITEM;

typedef struct
{
	ULONG				cItemsMac;
	ULONG				cItemsMax;
	#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION FAR * lpcs;
	#endif
	ADVISEITEM			rgItems[1];
} ADVISELIST, FAR *LPADVISELIST;

#define CbNewADVISELIST(_citems) \
	(offsetof(ADVISELIST, rgItems) + (_citems) * sizeof(ADVISEITEM))
#define CbADVISELIST(_plist) \
	(offsetof(ADVISELIST, rgItems) + (_plist)->cItemsMax * sizeof(ADVISEITEM))

STDAPI_(SCODE)
ScAddAdviseList(	LPVOID lpvReserved,
					LPADVISELIST FAR *lppList,
					LPMAPIADVISESINK lpAdvise,
					ULONG ulConnection,
					ULONG ulType,
					LPUNKNOWN lpParent);

STDAPI_(SCODE)
ScDelAdviseList(	LPADVISELIST lpList,
					ULONG ulConnection);
STDAPI_(SCODE)
ScFindAdviseList(	LPADVISELIST lpList,
					ULONG ulConnection,
					LPADVISEITEM FAR *lppItem);
STDAPI_(void)
DestroyAdviseList(	LPADVISELIST FAR *lppList);

// prototype for routine that detects whether calling apps is
// an interactive EXE or a service.

#if defined( _WINNT )
BOOL WINAPI IsServiceAnExe( VOID );
#endif

// prototype for internal routine that computes the size required
// to hold a given propval array based on specified alignment

SCODE ScCountPropsEx( int cprop,
                      LPSPropValue rgprop,
                      ULONG ulAlign,
                      ULONG FAR *pcb );

/*  Option data handling routines */
#ifdef MAPISPI_H

STDAPI_(SCODE)
ScCountOptionData(LPOPTIONDATA lpOption, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyOptionData(LPOPTIONDATA lpOption, LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocOptionData(LPOPTIONDATA lpOption,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

#endif	/* MAPISPI_H */


#ifdef __cplusplus
}
#endif


#endif	// _MAPIU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_vcard.h ===
/*
 *	_VCard.H - VCard definitions
 *
 *
 *	
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *	
 */
#define VCARD   TRUE        // comment out to disable vCard support

#ifdef VCARD
typedef ULONG (VCARD_READ)(HANDLE hVCard, LPVOID lpBuffer, ULONG uBytes, LPULONG ulBytesRead);
typedef VCARD_READ FAR *LPVCARD_READ;

typedef ULONG (VCARD_WRITE)(HANDLE hVCard, LPVOID lpBuffer, ULONG uBytes, LPULONG ulBytesWritten);
typedef VCARD_WRITE FAR *LPVCARD_WRITE;

HRESULT FileReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead);
HRESULT BufferReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead);
HRESULT FileWriteFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbWritten);
HRESULT ReadVCard(HANDLE hVCard, VCARD_READ ReadFn, LPMAILUSER lpMailUser);
HRESULT WriteVCard(HANDLE hVCard, VCARD_WRITE WriteFn, LPMAILUSER lpMailUser);

BOOL VCardGetBuffer(LPTSTR lpszFileName, LPSTR lpszBuf, LPSTR * lppBuf);
BOOL VCardGetNextBuffer(LPSTR lpBuf, LPSTR * lppVCard, LPSTR * lppNext);

#define WAB_W_END_OF_DATA           (MAKE_MAPI_S(0x1001))
#define WAB_E_VCARD_NOT_ASCII       (MAKE_MAPI_E(0x1002))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_profile.h ===
/*
 * _Profile.h - Stuff dealing with WAB Profile Handling
 *
 */


HRESULT HrGetWABProfiles(LPIAB lpIAB); 
void FreeWABFoldersList(LPIAB lpIAB);
BOOL bIsProfileMember(LPIAB lpIAB, LPSBinary lpsb, LPWABFOLDER lpWABFolder, LPWABUSERFOLDER lpUserFolder);
LPWABFOLDER FindWABFolder(LPIAB lpIAB, LPSBinary lpsb, LPTSTR lpName, LPTSTR lpProfileID);
void FreeProfileContainerInfo(LPIAB lpIAB);

#define FOLDER_UPDATE_NAME  0x00000001
#define FOLDER_UPDATE_SHARE 0x00000002
HRESULT HrUpdateFolderInfo(LPIAB lpIAB, LPSBinary lpsbEID, ULONG ulFlags, BOOL bShared, LPTSTR lpsz);

HRESULT HrAddRemoveFolderFromUserFolder(LPIAB lpIAB, LPWABFOLDER lpUserFolder, LPSBinary lpsbEID, LPTSTR lpName, BOOL bRefreshProfiles);
HRESULT HrCreateNewFolder(LPIAB lpIAB, LPTSTR lpName, LPTSTR lpProfileID, BOOL bUserFolder, LPWABFOLDER lpParentFolder, BOOL bShared, LPSBinary lpsbNew);


BOOL bDoesThisWABHaveAnyUsers(LPIAB lpIAB);
BOOL bIsThereACurrentUser(LPIAB lpIAB);
BOOL bAreWABAPIProfileAware(LPIAB lpIAB);
BOOL bIsWABSessionProfileAware(LPIAB lpIAB);


HRESULT HrGetUserProfileID(LPGUID lpUserGuid, LPTSTR szProfileID, ULONG cbProfileID);
HRESULT HrGetIdentityName(LPIAB lpIAB, LPTSTR lpID, LPTSTR szUserName, ULONG cchUserName);
HRESULT HrLogonAndGetCurrentUserProfile(HWND hWndParent, LPIAB lpIAB, BOOL bForceUI, BOOL bSwitchUser);
void UninitUserIdentityManager(LPIAB lpIAB);

#define DEFAULT_ID_HKEY         0x00000001
#define DEFAULT_ID_PROFILEID    0x00000002
#define DEFAULT_ID_NAME         0x00000004
HRESULT HrGetDefaultIdentityInfo(LPIAB lpIAB, ULONG ulFlags, HKEY * lphKey, LPTSTR lpProfileID, ULONG cchProfileID, LPTSTR lpName, ULONG cchName);






/*--------------------------------------------------------------------------*/
/* Interface used for registering and issuing notification callbacks for identities */
#define WAB_IDENTITYCHANGENOTIFY_METHODS(IPURE)                         \
    MAPIMETHOD_(HRESULT, QuerySwitchIdentities)                         \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, SwitchIdentities)                              \
                (THIS)                                          IPURE;  \
    MAPIMETHOD_(HRESULT, IdentityInformationChanged)                    \
                (THIS_  DWORD dwType)                           IPURE;  
/*
#undef       INTERFACE
#define      INTERFACE  WAB_IdentityChangeNotify
DECLARE_MAPI_INTERFACE_(WAB_IdentityChangeNotify, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    WAB_IDENTITYCHANGENOTIFY_METHODS(PURE)
};

*/
#undef  INTERFACE
#define INTERFACE       struct _WAB_IDENTITYCHANGENOTIFY

#undef  METHOD_PREFIX
#define METHOD_PREFIX   WAB_IDENTITYCHANGENOTIFY_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, WAB_IDENTITYCHANGENOTIFY_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_IDENTITYCHANGENOTIFY_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, WAB_IDENTITYCHANGENOTIFY_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        WAB_IDENTITYCHANGENOTIFY_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WAB_IDENTITYCHANGENOTIFY_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_IDENTITYCHANGENOTIFY_METHODS(IMPL)
};

typedef struct _WAB_IDENTITYCHANGENOTIFY
{
    MAPIX_BASE_MEMBERS(WAB_IDENTITYCHANGENOTIFY)

    LPIAB lpIAB;
} WABIDENTITYCHANGENOTIFY, * LPWABIDENTITYCHANGENOTIFY;

HRESULT HrCreateIdentityChangeNotifyObject(LPIAB lpIAB, LPWABIDENTITYCHANGENOTIFY * lppWABIDCN);


HRESULT HrRegisterUnregisterForIDNotifications( LPIAB lpIAB, BOOL bRegister);

/*--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_wabapi.h ===
/***********************************************************************
 *
 * _WABAPI.H
 *
 * Internal headers for the WABAPI
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 04.16.96     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifndef ___WABAPI_H
#define ___WABAPI_H

typedef struct _PROPERTY_STORE {
    HANDLE hPropertyStore;
    ULONG ulRefCount;
    BOOL bProfileAPIs;
    BOOL bIsWABOpenExSession; // Bug - Outlook passes IADRBook.c to multiple threads without all the threads calling
                              // WABOpenEx - as a result secondary threads dont know its an outlook session and
                              // try to access the .WAB which crashes badly. This flag is a hack way to pass the
                              // info between the two threads
	struct _OlkContInfo *rgolkci; // Outlook container info
	ULONG colkci;
    // information for WAB containers...
} PROPERTY_STORE, *LPPROPERTY_STORE;

typedef struct _OUTLOOK_STORE {
    HMODULE hOutlookStore;
    ULONG ulRefCount;
} OUTLOOK_STORE, *LPOUTLOOK_STORE;

ULONG ReleasePropertyStore(LPPROPERTY_STORE lpPropertyStore);
SCODE OpenAddRefPropertyStore(LPWAB_PARAM lpWP, LPPROPERTY_STORE lpPropertyStore);

ULONG ReleaseOutlookStore(HANDLE hPropertyStore, LPOUTLOOK_STORE lpOutlookStore);
SCODE OpenAddRefOutlookStore(LPOUTLOOK_STORE lpOutlookStore);

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_wabobj.h ===
//
// _WABOBJ.H
//
// Internal interface for IWABOBJECT
//
//

#include <mpswab.h>

//
//  Function prototypes
//

#undef	INTERFACE
#define INTERFACE	struct _IWOINT

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	IWOINT_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IWOINT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IWOINT_)
		MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWOINT_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_IWABOBJECT_METHODS(IMPL)
};


#ifdef OLD_STUFF
/* Generic part of property linked lists.
 */
typedef struct _lstlnk {
	struct _lstlnk FAR *	lpNext;
	ULONG					ulKey;
} LSTLNK, FAR * LPLSTLNK;

typedef LPLSTLNK FAR * LPPLSTLNK;


/* Linked list of property values.
 */
typedef struct _lstspv {
	LSTLNK			lstlnk;
	LPSPropValue	lpPropVal;
	ULONG			ulAccess;
} LSTSPV, FAR * LPLSTSPV;
#define CBLSTSPV sizeof(LSTSPV)

/* Linked list of property ID to NAME mappings.
 */
typedef struct _lstspn {
	LSTLNK			lstlnk;
	LPMAPINAMEID	lpPropName;
} LSTSPN, FAR * LPLSTSPN;
#endif


typedef struct _IWOINT {
	IWOINT_Vtbl FAR *	lpVtbl;

	// Generic IMAPIUnknown portion
	UNKOBJ_MEMBERS;
	UNKINST		inst;

	//
	//  Says whether or not this object (as a whole) is modifiable
	//
	ULONG		ulObjAccess;

    //
    // Structure which stores a handle and a refcount of the open property store
    //
    LPPROPERTY_STORE lpPropertyStore;

    // Stores a handle to the outlook-wab library module
    LPOUTLOOK_STORE lpOutlookStore;

    // Boolean set if this object created inside and Outlook session, i.e., the
    // WAB is set to use the Outlook MAPI allocators.
    BOOL bSetOLKAllocators;

} IWOINT, *LPIWOINT;	

#define CBIWOINT sizeof(IWOINT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_wrap.h ===
//	Keep the base members common across all the MAPIX objects such that
//	code reuse is leveraged.  AddRef(), Release() and GetLastError() assume
//	that the BASE members are the first set of members in the object
//
#define MAPIX_BASE_MEMBERS(_type)												\
	_type##_Vtbl *		lpVtbl;				/* object method table	*/			\
																				\
	ULONG				cIID;				/* count of interfaces supported */	\
	LPIID *				rglpIID;			/* array of &interfaces supported */\
	ULONG				lcInit;				/* refcount */						\
	CRITICAL_SECTION	cs;					/* critical section memory */		\
																				\
	HRESULT				hLastError;			/* for MAPI_GetLastError */			\
	UINT				idsLastError;		/* for MAPI_GetLastError */			\
	LPTSTR				lpszComponent;		/* for MAPI_GetLastError */			\
	ULONG				ulContext;			/* for MAPI_GetLastError */			\
	ULONG				ulLowLevelError;	/* for MAPI_GetLastError */			\
	ULONG				ulErrorFlags;		/* for MAPI_GetLastError */			\
	LPMAPIERROR			lpMAPIError;		/* for MAPI_GetLastError */			\


//
//  Function prototypes
//
//  Those not mentioned use IAB_methods


#undef	INTERFACE
#define INTERFACE	struct _WRAP

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, WRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, WRAP_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(WRAP_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _WRAP {

	MAPIX_BASE_MEMBERS(WRAP)
	LPPROPDATA lpPropData;

} WRAP, *LPWRAP;
#define CBWRAP sizeof(WRAP)





//
//  One-Off from object from an entryid
//
typedef struct _OOP {

	MAPIX_BASE_MEMBERS(WRAP)
	LPPROPDATA lpPropData;
	ULONG fUnicodeEID;
	
} OOP, *LPOOP;
#define CBOOP sizeof(OOP)

//
//  Entry point to create a new OOP MAPIProp object from a OO entryid
//

HRESULT NewOOP ( LPENTRYID lpEntryID,
				 ULONG cbEntryID,
				 LPCIID lpInterface,
				 ULONG ulOpenFlags,
				 LPVOID lpIAB,
				 ULONG *lpulObjType,
				 LPVOID *lppOOP,
				 UINT *lpidsError );


HRESULT NewOOPUI ( LPENTRYID lpEntryID,
				 ULONG cbEntryID,
				 LPCIID lpInterface,
				 ULONG ulOpenFlags,
				 LPIAB lpIAB,
				 ULONG *lpulObjType,
				 LPVOID *lppOOP,
				 UINT *lpidsError );


//
//  Entry point to programmatically create a new OO entry from a
//  foreign template...
//
//  The end result is a OO entryid (no attatched details, yet...)
//
typedef struct _OOE {

	MAPIX_BASE_MEMBERS(WRAP)
	LPPROPDATA lpPropData;
	ULONG fUnicodeEID;

	//
	//  New stuff
	//
	LPMAPIPROP lpPropTID;
	
} OOE, *LPOOE;
#define CBOOE sizeof(OOE)

HRESULT HrCreateNewOOEntry(	LPVOID lpROOT,
							ULONG cbEntryID,
							LPENTRYID lpEntryID,
							ULONG ulCreateFlags,
							LPMAPIPROP FAR * lppMAPIPropEntry );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_wabtags.h ===
/*
 *  _WABTAGS.H
 *
 *  Internal Property tag definitions
 *
 *  The following ranges should be used for all internal property IDs.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  6600    67FF    Provider-defined internal non-transmittable property
 *
 *  Copyright 1996 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(_WABTAGS_H)
#define _WABTAGS_H


#define WAB_INTERNAL_BASE   0x6600

// Internal representation of a Distribution List.  Multi-valued binary contains
// ENTRYID's of each entry in the distribution list.
#define PR_WAB_DL_ENTRIES                   PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 0)
#define PR_WAB_PROFILE_ENTRIES              PR_WAB_DL_ENTRIES // Use same prop for Profile Entries
#define PR_WAB_FOLDER_ENTRIES               PR_WAB_DL_ENTRIES // Use same prop for Folder Entries

#define PR_WAB_LDAP_SERVER                  PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 1)
#define PR_WAB_RESOLVE_FLAG                 PROP_TAG(PT_BOOLEAN,    WAB_INTERNAL_BASE + 2)
// internal only 2nd email address.  Used for parsing LDAP -> WAB mailuser
#define PR_WAB_2ND_EMAIL_ADDR               PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 3)
#define PR_WAB_SECONDARY_EMAIL_ADDRESSES    PROP_TAG(PT_MV_TSTRING, WAB_INTERNAL_BASE + 4)
#define PR_WAB_TEMP_CERT_HASH               PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 5)
// internal properties for temporarily storing the labeledURI value of a returned LDAP contact
#define PR_WAB_LDAP_LABELEDURI              PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 6)

// Internal entry that will tag a given contact as the ME object. There can only be
// one ME per WAB .. we only need to check the existence of the property, the value doesnt
// matter
#define PR_WAB_THISISME                     PROP_TAG(PT_LONG,       WAB_INTERNAL_BASE + 7)

/******* Above properties can be persisted in the data store ****?
/******* The properties below should not end up in the data store since
        older and newer version of Outlook cannot handle them.
        The properties below are used for in-memory manipulation only
        and are NULLed out prior to saving ****/

// Internal binary prop that temporarily stores any certificate returned from LDAP ...
// We cache the raw LDAP cert until such time as the user does an OpenEntry on the LDAP entry
// If the user never calls OpenEntry, then we dont need to convert the raw cert to a MAPI cert
// PR_WAB_LDAP_RAWCERT handles userCertificate;binary
// PR_WAB_LDAP_RAWCERTSMIME handles userSMIMECertificate;binary
//
#define PR_WAB_LDAP_RAWCERT                 PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 8)
#define PR_WAB_LDAP_RAWCERTSMIME            PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 9)

// For storing and displaying the Manager and Direct Reports details for LDAP searches on exchange servers
// These entries will store the details in the form of LDAP URLS ...
#define PR_WAB_MANAGER                      PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 10)
#define PR_WAB_REPORTS                      PROP_TAG(PT_MV_TSTRING, WAB_INTERNAL_BASE + 11)

// The PR_WAB_FOLDER_PARENT prop is used to store the entryid of the parent of an object .. 
// This property was originally predefined here but this may have been a bad idea since Outlook can't
// store this property .. hence the PR_WAB_FOLDER_PARENT property is turned into a named property
// so there aren't any problems with outlook. Meanwhile don't use this value WAB_INTERNAL_BASE+12
// since there may be .wabs around which have this value in them ..
#define PR_WAB_FOLDER_PARENT_OLDPROP        PROP_TAG(PT_MV_BINARY,  WAB_INTERNAL_BASE + 12)

// Note Outlook store can't save anything beyond WAB_INTERNAL_BASE + 7 
//(it's hardcoded to understand the first 8 but can't save beyong that)
// Therefore any other internal WAB props must be only in the .wab file 
//or not saved at all.
// Outlook used named properties for ALL the contact data it stores.
//
// If you need to extend the WAB property set for internal only properties,
// use named properties and add them in globals.h

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dead\image.c ===
//
// image.cpp
//
// utilities for images and imagelists
//


//#include "pch.hxx"
//#include "resource.h"
//#include "globals.h"
//#include "util.h"
#include "_apipch.h"

//extern HINSTANCE hinstMapiX;

//
// TileImage
//
// This function tiles a bitmap in lprcDest, using lpptOrigin as the origin
//
#define ILT_PARTIALBLT_LEFT     0
#define ILT_PARTIALBLT_TOP      1
#define ILT_PARTIALBLT_RIGHT    2
#define ILT_PARTIALBLT_BOTTOM   3

void TileImage(HBITMAP hbmp, HDC hdc, LPPOINT lpptOrigin, LPRECT lprcDest)
    {
    BOOL    fFirstRow, fFirstCol;
    int     nRows, nCols, nSaveCols, offset;
    int     rgOffsetPartialBlt[4];
    POINT   ptTileOrigin, ptDraw, ptDest, ptSrc;
    SIZE    sizeImage, sizeRect, sizeBlt;
    HDC     hdcBmp=0;
    HBITMAP hbmpOrig=0;
    BITMAP  bm;

    if(!hdc)
        return;

    if(!(hdcBmp = CreateCompatibleDC(hdc)))
        goto fail;

    if(!(hbmpOrig = SelectObject(hdcBmp, hbmp)))
        goto fail;
    
    GetObject(hbmp, sizeof(BITMAP), &bm);
    sizeImage.cx = bm.bmWidth;
    sizeImage.cy = bm.bmHeight;

    // Generate the true origin with the tile
    lpptOrigin->x %= sizeImage.cx;
    lpptOrigin->y %= sizeImage.cy;

    // We will start the tile so that the origin lines up
    ptTileOrigin.x = lprcDest->left - lpptOrigin->x;
    ptTileOrigin.y = lprcDest->top - lpptOrigin->y;

    // Figure out how many rows and columns wo need
    sizeRect.cx = lprcDest->right - ptTileOrigin.x;
    sizeRect.cy = lprcDest->bottom - ptTileOrigin.y;

    nRows = sizeRect.cy / sizeImage.cy;
    nRows += (sizeRect.cy % sizeImage.cy) ? 1 : 0;
    nSaveCols = sizeRect.cx / sizeImage.cx;
    nSaveCols += (sizeRect.cx % sizeImage.cx) ? 1 : 0;

    // Generate the partial blt offsets
    rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] = lprcDest->top - ptTileOrigin.y;
     rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] = lprcDest->left - ptTileOrigin.x;
    if (sizeImage.cy >= sizeRect.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy - sizeRect.cy;
    else if(sizeRect.cy % sizeImage.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy -
                (sizeRect.cy % sizeImage.cy);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = 0;
    if (sizeImage.cx >= sizeRect.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx - sizeRect.cx;
    else if(sizeRect.cx % sizeImage.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx -
                (sizeRect.cx % sizeImage.cx);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = 0;

    // Draw the tiles
    ptDraw.y = ptTileOrigin.y;
    fFirstRow = TRUE;
    while (nRows--)
        {
        ptDraw.x = ptTileOrigin.x;
        nCols = nSaveCols;
        fFirstCol = TRUE;
        while (nCols--)
            {
            ptDest = ptDraw;
            sizeBlt = sizeImage;
            ptSrc.x = ptSrc.y = 0; 
            // Handle partial boundary Blts
            if (fFirstRow && rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_TOP];
                ptDest.y += offset;
                sizeBlt.cy -= offset;
                ptSrc.y += offset;
                }
            if (nRows == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] != 0)
                sizeBlt.cy -= rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM];
            if (fFirstCol && rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT];
                ptDest.x += offset;
                sizeBlt.cx -= offset;
                ptSrc.x += offset;
                }
            if (nCols == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] != 0)
                sizeBlt.cx -= rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT];
            // Just do it
            BitBlt(hdc, ptDest.x, ptDest.y,    sizeBlt.cx, sizeBlt.cy,
                    hdcBmp, ptSrc.x, ptSrc.y, SRCCOPY);
            ptDraw.x += sizeImage.cx;
            fFirstCol = FALSE;
            }
        ptDraw.y += sizeImage.cy;
        fFirstRow = FALSE;
        }

fail:
    if(hdcBmp) 
        {
        if(hbmpOrig)
            SelectObject(hdcBmp, hbmpOrig);
        DeleteDC(hdcBmp);
        }
    }

//
// shared image list..
//

static HIMAGELIST g_himlAthSm = NULL;
static HIMAGELIST g_himlAthLg = NULL;
static HIMAGELIST g_himlAthSt = NULL;

HIMAGELIST InitImageList(int cx, int cy, LPSTR szbm, int cicon)
{
    HBITMAP hbm;
    HIMAGELIST himl;

    himl = ImageList_Create(cx, cy, ILC_MASK, cicon, 0);

    if (himl != NULL)
        {
        hbm = LoadBitmap(hinstMapiX, szbm);

        ImageList_AddMasked(himl, hbm, RGB_TRANSPARENT);

        DeleteObject((HGDIOBJ)hbm);
        }

    return(himl);
}


void FreeImageLists(void)
{
    if (g_himlAthSm != NULL)
        {
        ImageList_Destroy(g_himlAthSm);
        g_himlAthSm = NULL;
        }

    if (g_himlAthLg != NULL)
        {
        ImageList_Destroy(g_himlAthLg);
        g_himlAthLg = NULL;
        }

    if (g_himlAthSt != NULL)
        {
        ImageList_Destroy(g_himlAthSt);
        g_himlAthSt = NULL;
        }
}

BOOL LoadBitmapAndPalette(int idbmp, HBITMAP *phbmp, HPALETTE *phpal)
    {
    int i, n;
    HBITMAP hbmp;
    HPALETTE hpal;
    HDC hdcBitmap;
    DWORD adw[257];
    BOOL fret = FALSE;

    hdcBitmap = NULL;
    *phbmp = NULL;
    *phpal = NULL;

    hbmp = (HBITMAP)LoadImage(hinstMapiX, MAKEINTRESOURCE(idbmp),
                    IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if (hbmp == NULL)
        goto DoneLoadBitmap;

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap == NULL)
        goto DoneLoadBitmap;
    SelectObject(hdcBitmap, (HGDIOBJ)hbmp);
    n = GetDIBColorTable(hdcBitmap, 0, 256, (LPRGBQUAD)&adw[1]);
    for (i = 1; i <= n; i++)
        adw[i] = RGB(GetBValue(adw[i]), GetGValue(adw[i]), GetRValue(adw[i]));
    adw[0] = MAKELONG(0x300, n);
    hpal = CreatePalette((LPLOGPALETTE)&adw[0]);
    if (hpal == NULL)
        goto DoneLoadBitmap;

    *phbmp = hbmp;
    *phpal = hpal;

    fret = TRUE;

DoneLoadBitmap:
    if (hdcBitmap != NULL)
        DeleteDC(hdcBitmap);

    return(fret);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dead\coguid.c ===
/*
coguid.cpp - self contained GUID allocator module

	Bob Atkinson (BobAtk@microsoft.com) June 1993
	Modified for temporary use by billm April 1994

This file contains all that is necessary to generate GUIDs with high
frequency and robustness without a network card on WIN32.
We allocate a pseudo-random node id based
on machine state.

There is only one public API in this file: HrCreateGuidNoNet().

The following are relevant reference documents:

   		Project 802: Local and Metropolitan Area Network Standard
   		Draft Standard P802.1A/D10 1 April 1990
   		Prepared by the IEEE 802.1
		(Describes IEEE address allocation)

		DEC / HP
		Network Computing Architecture
		Remote Procedure Call RunTime Extensions Specification
		Version OSF TX1.0.11   Steven Miller  July 23, 1992
		(Chapter 10 describes UUID allocation)

A word about "GUID" vs "UUID" vs ... In fact, they're all the SAME THING.
Meaning that, once allocated, they're all interoperable / comparable / etc.
The standard describes a memory layout for a 16-byte structure (long, word,
word, array of bytes) which gets around byte order issues. It then goes on
to describe three different "variants" of allocation algorithm for these 16
byte structures; each variant is encoded by certain high order bits in the
"clockSeqHiAndReserved" byte.
	Variant 0 is (I believe) the historical Apollo allocation algorithm.
	Variant 1 is what is implemented here.
	Variant 2 is created according to the "Microsoft GUID specification."
Careful: Despite the name here being HrCreateGuidNoNet() we are NOT allocating
according to Variant 2; we are using Variant 1. Variant 2 works by having
a range of the bits be a (MS allocated, for now) authority identifier, and
the remaining bits be whatever that authority wants. Variant 1, by
contrast, has a precise standard for how all the bits are allocated. But
as the resulting 16 bytes are in fact all mutually compatible, this
confusion in terminology is of no actual consequence.

Variant 1 is allocated as follows. First, Variant 1 allocates four bits
as a "version" field. Here we implement according to version 1; version 2
is defined for "UUIDs genereated for OSF DCE Security purposes, conformant
to this specification, but substuting a Unix id value for the timeLow
value." I know of no other legal versions that have been allocated.

The other fields of Variant 1 are as follows. The high 6 bytes are the
IEEE allocated node id on which the allocator is running. The low eight
bytes are the current "time": we are to take the current time as
avialable to the precision of milliseconds and multiply by 10,000, thus
giving a logical precision of 100 ns. Within these lower bits, we are to
sequentially increment a count as we allocate guids. Thus, the maximum rate
at which we can allocate is indeed 1 GUID / 100 ns. The remaining two bytes
are used for a "clock sequence". The intent of the clock sequence is to
provide some protection against the real clock going backwards in time.
We initially randomly allocate the clock sequence, and then increment it
each time we detect the clock going backwards (the last time used and the
current clock sequence are stored in the registry).

Presently (93.06.11) this implementation contains byte-order sensitivities,
particularly in the 64-bit arithmetic helper routines below. This
implementation is also not suitable for use on a premptive system.

This function is only called when UuidCreate() fails.
*/

#include "_apipch.h"


#ifndef STATIC
#ifdef DEBUG
#define STATIC
#else
#define STATIC static
#endif
#endif

#ifdef WIN32

#define INTERNAL                  STATIC HRESULT __stdcall
#define INTERNAL_(type)           STATIC type __stdcall

//==============================================================
// Start of 64 bit arithmetic utility class
//==============================================================

INTERNAL_(BOOL)
FLessThanOrEqualFTs(FILETIME ft1, FILETIME ft2)
{
	if (ft1.dwHighDateTime < ft2.dwHighDateTime)
		return TRUE;
	else if (ft1.dwHighDateTime == ft2.dwHighDateTime)
		return ft1.dwLowDateTime <= ft2.dwLowDateTime;
	else
		return FALSE;
}	
	
INTERNAL_(FILETIME)
FtAddUShort(FILETIME ft1, USHORT ush)
{
	FILETIME	ft;

	ft.dwLowDateTime = ft1.dwLowDateTime + ush;
	ft.dwHighDateTime = ft1.dwHighDateTime +
		((ft.dwLowDateTime < ft1.dwLowDateTime ||
			ft.dwLowDateTime < ush) ?
				1L : 0L);

	return ft;
}

//==============================================================
// End of 64 bit arithmetic utility
//==============================================================

#pragma pack(1)
struct _NODEID // machine identifier
	{
	union {
		BYTE	rgb[6];
		WORD	rgw[3];
		};
	};
#pragma pack()
	
typedef struct _NODEID	NODEID;
typedef USHORT			CLKSEQ;
typedef CLKSEQ FAR *	PCLKSEQ;
#define	clkseqNil		((CLKSEQ)-1)

struct _UDBK		// data from which a block of UUIDs can be generated
	{
	DWORD 				timeLowNext;	// lower bound of block of time values
    DWORD				timeLowLast;	// upper bound of block of time values
    DWORD				timeHigh;		// high dword of timeLowXXXX
	CLKSEQ				clkseq;			// the clock sequence
	NODEID				nodeid;			
    };

typedef struct _UDBK	UDBK;


INTERNAL_(BOOL)		FLessThanOrEqualFTs(FILETIME ft1, FILETIME ft2);
INTERNAL_(FILETIME) FtAddUShort(FILETIME ft1, USHORT ush);
INTERNAL			GetPseudoRandomNodeId(NODEID*);
INTERNAL_(void)		GetCurrentTimeULong64(FILETIME *);
INTERNAL			GetNextBlockOTime(PCLKSEQ pClockSeq, FILETIME *pftCur);
INTERNAL			ReadRegistry (PCLKSEQ pClockSeqPrev, FILETIME *pftPrev);
INTERNAL			InitRegistry (PCLKSEQ pClockSeqPrev, FILETIME *pftPrev);
INTERNAL			WriteRegistry(CLKSEQ, CLKSEQ, const FILETIME);
INTERNAL_(LONG)		CountFilesInDirectory(LPCSTR szDirPath);
INTERNAL_(void) 	FromHexString(LPCSTR sz, LPVOID rgb, USHORT cb);
INTERNAL_(void)		ToHexString(LPVOID rgb, USHORT cb, LPSTR sz);
INTERNAL_(WORD)		Cyc(WORD w);
INTERNAL_(void)		ShiftNodeid(NODEID FAR* pnodeid);
#ifdef MAC
OSErr	__pascal  GetDirName(short vRefNum, long ulDirID, StringPtr name);
int		MacCountFiles(StringPtr pathName, short vRefNum, long parID);
#endif

// We amortize the overhead cost of allocating UUIDs by returning them in
// time-grouped blocks to the actual CoCreateGUID routine. This two-level
// grouping is largely historical, having been derived from the original
// NT UuidCreate() routine, but has been retained here with the thought that
// the efficiencies gained will be needed in future premptive system (Windows 95).

static const ULONG	cuuidBuffer    = 1000;	// how many uuids to get per registry hit.
static const ULONG	cuuidReturnMax = 100;	// how many max to return on each GetUDBK.

static const DWORD	dwMax = 0xFFFFFFFF;		// largest legal DWORD

//================================================================================
// Start of meat of implementation
//================================================================================

INTERNAL GetUDBK(UDBK *pudbk)
// Init the given UDBK so that a bunch of UUIDs can be generated therefrom. This
// routine hits the system registry and the disk, and so is somewhat slow. But we
// amortize the cost over the block of UUIDs that are returned.
{
	HRESULT		hr;
	ULONG		cuuidReturn;
	ULONG		cuuidLeftInBuffer;
	FILETIME	ftCur;
	
	// These next block of variables in effect comprise the internal state of
	// the UUID generator. Notice that this works only in a shared-data space
	// DLL world, such as Win3.1. In non-shared environments, this will
	// need to be done differently, perhaps by putting this all in a server process.
	// In a premptively scheduled system, this function is all a critical section.
	static DWORD  timeLowFirst	= 0;
	static DWORD  timeLowLast	= 0;
	static CLKSEQ clkseq;
	static DWORD  timeHigh;
	static NODEID nodeid        = { 0, 0, 0, 0, 0, 0 };
	
	cuuidLeftInBuffer = timeLowLast - timeLowFirst;
	if (cuuidLeftInBuffer == 0) {
		// Our buffer of uuid space is empty, or this is the first time in to this routine.
		// Get another block of time from which we can generate UUIDs.
		hr = GetNextBlockOTime(&clkseq, &ftCur);
		if (hr != NOERROR) return hr;
		
		if (nodeid.rgw[0] == 0 && nodeid.rgw[1] == 0 && nodeid.rgw[2] == 0) {
			hr = GetPseudoRandomNodeId(&nodeid);
			if (hr != NOERROR) return hr;
		}	
		
		timeHigh = ftCur.dwHighDateTime;
		// Set the buffer bottom. Return few enough so that we don't wrap the low dw.
		timeLowFirst = ftCur.dwLowDateTime;
		timeLowLast  = (timeLowFirst > (dwMax - cuuidBuffer)) ? dwMax : timeLowFirst + cuuidBuffer;
		cuuidLeftInBuffer = timeLowLast - timeLowFirst;
	}
	cuuidReturn = (cuuidLeftInBuffer < cuuidReturnMax) ? cuuidLeftInBuffer : cuuidReturnMax;
	
	// Set the output values and bump the usage count
	pudbk->timeLowNext = timeLowFirst;
	timeLowFirst 	  += cuuidReturn;
	pudbk->timeLowLast = timeLowFirst;
	pudbk->timeHigh    = timeHigh;
	pudbk->clkseq	   = clkseq;
	pudbk->nodeid	   = nodeid;
	return NOERROR;
}

INTERNAL_(void) GetCurrentTimeUlong64(FILETIME *pft)
// Return the current time (# of 100 nanoseconds intervals since 1/1/1601).
// Make sure that we never return the same time twice by high-frequency calls
// to this function.
//
{
	static FILETIME	 ftPrev = {0};
	SYSTEMTIME syst;

	GetSystemTime(&syst);
	if (!SystemTimeToFileTime(&syst, pft))
	{
		TrapSz1("Error %08lX calling SystemTimeToFileTime", GetLastError());
		pft->dwLowDateTime = 0;
		pft->dwHighDateTime =0;
	}

	if (memcmp(pft, &ftPrev, sizeof(FILETIME)) == 0)
		*pft = FtAddUShort(*pft, 1);

	memcpy(&ftPrev, pft, sizeof(FILETIME));
}	

INTERNAL GetNextBlockOTime(PCLKSEQ pclkseq, FILETIME *pft)
// Updates, and potentially create, the registry entries that maintain
// the block of time values for UUIDs that we've created. The algorithm
// is basically:
// If the registry entries don't exist, then create them. Use
//		a random number for the clock sequence.
// If the entries do exist, the dig out of them the previous
//		clock sequence and previous time allocated. If the previous time
//		is greater than the current time then bump (and store) the
//		clock sequence.
{
	FILETIME	ftRegistry;
	HRESULT	hr;
	CLKSEQ	clkseqPrev;

	GetCurrentTimeUlong64(pft);
	hr = ReadRegistry(pclkseq, &ftRegistry);
	if (hr != NOERROR)
		return InitRegistry(pclkseq, pft);

	// If the clock's gone backwards, bump the clock seq. The clock
	// seq is only 14 bits significant; don't use more.
	clkseqPrev = *pclkseq;
	if (FLessThanOrEqualFTs(*pft, ftRegistry)) {
		clkseqPrev = clkseqNil;
		*pclkseq += 1;
		if (*pclkseq == 16384)	// 2^14
			*pclkseq = 0;
	}
	return WriteRegistry(*pclkseq, clkseqPrev, *pft);
}

// Use a private ini file for now. This will go away when CoCreateGuid
// is available on NT and Windows 95.
static const char szDataKey[]	= "CoCreateGuid";
static const char szClkSeq[]    = "PreviousClockSequence";	// same as UUIDGEN.EXE
static const char szTime[]		= "PreviousTimeAllocated";	// same as UUIDGEN.EXE
static const char szNodeId[]	= "NodeId";

static const char szBlank[]		   = "";	// used for default GetPrivateProfileString values
static const char szProfileFile[]  = "mapiuid.ini";

#define CCHHEXBUFFERMAX	32

INTERNAL ReadRegistry(PCLKSEQ pclkseq, FILETIME *pft)
// Read the previous values of the clock sequence and the time from
// the registry, if they are there. If they are not, then return
// an error.
{
	SCODE sc = S_OK;
	LONG cch = 0;
	char szHexBuffer[CCHHEXBUFFERMAX];

    // use our private ini file
	cch = CCHHEXBUFFERMAX;
	cch = GetPrivateProfileString(szDataKey, szClkSeq, szBlank,
					szHexBuffer, (int)cch, szProfileFile);
	if (cch == 0 || cch >= CCHHEXBUFFERMAX) {
		sc = MAPI_E_DISK_ERROR;
		goto ErrRet;
	}		
	FromHexString(szHexBuffer, pclkseq, sizeof(CLKSEQ));

	cch = CCHHEXBUFFERMAX;
	cch = GetPrivateProfileString(szDataKey, szTime, szBlank,
					szHexBuffer, (int)cch, szProfileFile);
	if (cch == 0 || cch >= CCHHEXBUFFERMAX) {
		sc = MAPI_E_DISK_ERROR;
		goto ErrRet;
	}
	FromHexString(szHexBuffer, pft, sizeof(FILETIME));
	// Fall through to ErrRet	
ErrRet:
	return ResultFromScode(sc);
}

INTERNAL InitRegistry(PCLKSEQ pclkseq, FILETIME *pft)
// Invent a new clock sequence using a pseudo random number. Then
// write the clock sequence and the current time to the registry.
{
	LONG cfile;
#ifdef MAC
	short	vRefNum;
	long	ulDirID;
	Str32	stDirName;

	FindFolder((short)kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder,
		&vRefNum, &ulDirID);
	GetDirName(vRefNum, ulDirID, stDirName);
	cfile = MacCountFiles(stDirName, vRefNum, ulDirID);
#else
	const int cchWindowsDir = 145;	// 144 is recommended size according to SDK
	LPSTR szWindowsDir = NULL;

	if (	FAILED(MAPIAllocateBuffer(cchWindowsDir, (LPVOID *) &szWindowsDir))
		||	GetWindowsDirectory(szWindowsDir, cchWindowsDir) == 0)
		goto ErrRet;
	// For the clock sequence, we use the number of files in the current
	// windows directory, on the theory that that this is highly sensitive
	// to the exact set of applications that have been installed on this
	// particular machine.
	cfile = CountFilesInDirectory(szWindowsDir);
	if (cfile == -1)
		goto ErrRet;
	MAPIFreeBuffer(szWindowsDir);
	szWindowsDir = NULL;
	goto NormRet;

ErrRet:
	MAPIFreeBuffer(szWindowsDir);
	return ResultFromScode(MAPI_E_CALL_FAILED);

NormRet:
#endif	// MAC
	*pclkseq  = (CLKSEQ)Cyc((WORD)cfile);
	// Also use ms since boot so as to get a more time-varying value
	*pclkseq ^= (CLKSEQ)Cyc((WORD)GetTickCount());
	*pclkseq &= 16384-1; // only allow 14 bits of significance in clock seq
	GetCurrentTimeUlong64(pft);
	return WriteRegistry(*pclkseq, clkseqNil, *pft);
}

INTERNAL WriteRegistry(CLKSEQ clkseq, CLKSEQ clkseqPrev, const FILETIME ft)
// Write the clock sequence and time into the registry so that we can
// retrieve it later on a subsequent reboot. clkseqPrev is passed so that
// we can avoid writing the clock sequence if in fact we know it to be
// currently valid. This was measured as important for performance.
{
	SCODE sc = S_OK;
	char szHexBuffer[CCHHEXBUFFERMAX];
	
	if (clkseq != clkseqPrev) { // don't write if clock sequence same (often is)

		ToHexString((LPVOID)&clkseq, sizeof(CLKSEQ), szHexBuffer);

		if (!WritePrivateProfileString(szDataKey, szClkSeq, szHexBuffer, szProfileFile)) {
			sc = MAPI_E_DISK_ERROR;
			goto ErrRet;
		}
	}			

	ToHexString((LPVOID)&ft, sizeof(FILETIME), szHexBuffer);		
	if (!WritePrivateProfileString(szDataKey, szTime, szHexBuffer, szProfileFile)) {
		sc = MAPI_E_DISK_ERROR;
		goto ErrRet;
	}

ErrRet:
	WritePrivateProfileString(NULL,NULL,NULL,szProfileFile); // flush the ini cache
	return ResultFromScode(sc);
}

#ifdef MAC
#define	GET_DIR_INFO				-1

int	MacCountFiles(StringPtr pathName, short vRefNum, long parID)
// Return the number of files in the specified Mac directory.
{
	CInfoPBRec paramBlk;

	paramBlk.hFileInfo.ioNamePtr = pathName;	// Pascal string
	paramBlk.hFileInfo.ioVRefNum = vRefNum;
	// not necessary for full pathname
	paramBlk.hFileInfo.ioDirID = paramBlk.dirInfo.ioDrParID = parID;
	paramBlk.hFileInfo.ioFDirIndex = GET_DIR_INFO;
	PBGetCatInfoSync(&paramBlk);
	return(((DirInfo *) &paramBlk)->ioDrNmFls);
}
#endif

INTERNAL_(LONG) CountFilesInDirectory(LPCSTR szDirPath)
// Return the number of files in this directory. The path may or may not
// currently end with a slash.
{
	int cfile = 0;
#ifndef MAC
	LPCSTR szStar = "*.*";
	char  chLast = szDirPath[lstrlen(szDirPath)-1];
	LPSTR szPath;
	WIN32_FIND_DATA ffd;
	HANDLE hFile;

	if (FAILED(MAPIAllocateBuffer(lstrlen(szDirPath) +1 +lstrlen(szStar) +1,
			(LPVOID *) &szPath)))
		return -1;

	lstrcpy(szPath, szDirPath);

/***
#ifdef DBCS
	chLast = *(SzGPrev(szDirPath, szDirPath+lstrlen(szDirPath)));
#endif
***/
    // Get the last character in above szDirPath
    {
        LPCSTR lp = szDirPath;
        while(*lp)
        {
            chLast = *lp;
            lp = CharNext(lp);
        }
    }

    if (!(chLast == '\\' || chLast == '/'))
		lstrcat(szPath, "\\");
	lstrcat(szPath, szStar);
	
	ffd.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

	hFile = FindFirstFile(szPath, &ffd);
	if (hFile != INVALID_HANDLE_VALUE)
		{
		cfile++;
		while (FindNextFile(hFile, &ffd))
			cfile++;
		FindClose(hFile);
		}

    MAPIFreeBuffer(szPath);
#else
	FSSpec pfss;

	if (UnwrapFile(szDirPath, &pfss))
		cfile = MacCountFiles(pfss.name, pfss.vRefNum, pfss.parID);
	else
		cfile = Random();
#endif
	return cfile;
}

#pragma warning (disable:4616) // warning number out of range
#pragma warning	(disable:4704) // in-line assembler precludes global optimizations

INTERNAL_(void) ShiftNodeid(NODEID FAR* pnodeid)
// Shift the nodeid so as to get a randomizing effect
{
	// Rotate the whole NODEID left one bit. NODEIDs are 6 bytes long.
#if !defined(M_I8086) && !defined(M_I286) && !defined(M_I386) && !defined(_M_IX86)
	BYTE bTmp;
	BYTE bOld=0;

/* Compilers complain about conversions here. Pragma the warning off. */
#pragma warning(disable:4244)	// possible data loss in conversion

	bTmp = pnodeid->rgb[5];
	pnodeid->rgb[5] = (pnodeid->rgb[5] << 1) + bOld;
	bOld = (bTmp & 0x80);	

	bTmp = pnodeid->rgb[4];
	pnodeid->rgb[4] = (pnodeid->rgb[4] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[3];
	pnodeid->rgb[3] = (pnodeid->rgb[3] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[2];
	pnodeid->rgb[2] = (pnodeid->rgb[2] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[1];
	pnodeid->rgb[1] = (pnodeid->rgb[1] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	bTmp = pnodeid->rgb[0];
	pnodeid->rgb[0] = (pnodeid->rgb[0] << 1) + bOld;
	bOld = (bTmp & 0x80);	
	
	pnodeid->rgb[5] = pnodeid->rgb[5] + bOld;
#pragma warning(default:4244)

#else
	_asm {
		mov	ebx, pnodeid
		sal	WORD PTR [ebx], 1	// low order bit now zero
		rcl	WORD PTR [ebx+2], 1		
		rcl	WORD PTR [ebx+4], 1
		// Now put bit that fell off end into low order bit
		adc	WORD PTR [ebx],0	// add carry bit back in
	}
#endif
}
	
INTERNAL_(WORD) Cyc(WORD w)
// Randomizing function used to distribute random state values uniformly
// in 0..65535 before use.
{
	// // // Use one iteration of the library random number generator.
	// // srand(w);
	// // return rand();
	//
	// The following is what this would actually do, taken from the library
	// source. It really isn't very good.
	// return (WORD)(  ((((long)w) * 214013L + 2531011L) >> 16) & 0x7fff );
	
	// Really what we do: use the random number generator presented in
	// CACM Oct 1988 Vol 31 Number 10 p 1195, slightly optimized since
	// we are only interested in 16bit input/seed values.
	
	const LONG a = 16807L;
	const LONG m = 2147483647L;	// 2^31 -1. Is prime.
	const LONG q = 127773L;		// m div a
	const LONG r = 2386L;		// m mod a
		
	LONG seed = (LONG)w + 1L;	// +1 so as to avoid problems with zero
	// LONG hi   = seed / q;	// seed div q. Here always zero, since seed < q.
	// LONG lo	 = seed % q;	// seed mod q. Here always seed.
	LONG test = a*seed;			// a * lo - r * hi
	if (test > 0)
		seed = test;
	else
		seed = test + m;
		
	// In a true random number generator, what we do now is scale the bits
	// to return a floating point number in the range 0..1. However, we have
	// no need here for that degree of quality of number sequence, and we
	// wish to avoid the floating point calculations. Therefore we simply xor
	// the words together.
	
	// // p1193, top right column: seed is in the range 1..m-1, inclusive
	// return (double)seed / m;			// what the text recommends
	// return (double)(seed-1) / (m-1);	// variation: allows zero as legal value
	return (WORD) (LOWORD(seed) ^ HIWORD(seed)); // use all the bits
}	

INTERNAL GenerateNewNodeId(NODEID* pnodeid)
// Can't get from net. Generate one. We do this by using
// various statistics files in certain key directories on
// the machine.
{	
	// REVIEW: Consider not bothering to init the NODEID, thus getting
	// random state from RAM?
#ifndef MAC
	// Not including this should help make up for some of the (here)
	// randomizing funcitons the MAC doesn't support.
	memset(pnodeid, 0, sizeof(*pnodeid));
	
	{ // BLOCK
		// First, merge in random state generated from the file system
		DWORD dwSectPerClust;
		DWORD dwBytesPerSect;
		DWORD dwFreeClust;
		DWORD dwClusters;

		(void) GetDiskFreeSpace(NULL, &dwSectPerClust, &dwBytesPerSect,
            &dwFreeClust, &dwClusters);

		pnodeid->rgw[0] ^= Cyc(LOWORD(dwBytesPerSect));
		pnodeid->rgw[1] ^= Cyc(HIWORD(dwBytesPerSect));
		pnodeid->rgw[2] ^= Cyc(HIWORD(dwClusters));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(LOWORD(dwFreeClust));
		pnodeid->rgw[1] ^= Cyc(HIWORD(dwFreeClust));
		pnodeid->rgw[2] ^= Cyc(LOWORD(dwClusters));
	} // BLOCK
#else
	{ // BLOCK
		ParamBlockRec paramBlk = {0};

		paramBlk.volumeParam.ioVolIndex = 1;
		PBGetVInfoSync(&paramBlk);
		pnodeid->rgw[0] ^= Cyc(LOWORD(paramBlk.volumeParam.ioVAlBlkSiz));
		pnodeid->rgw[1] ^= Cyc(HIWORD(paramBlk.volumeParam.ioVAlBlkSiz));
		pnodeid->rgw[2] ^= Cyc(HIWORD(paramBlk.volumeParam.ioVNmAlBlks));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(LOWORD(paramBlk.volumeParam.ioVFrBlk));
		pnodeid->rgw[1] ^= Cyc(HIWORD(paramBlk.volumeParam.ioVFrBlk));
		pnodeid->rgw[2] ^= Cyc(LOWORD(paramBlk.volumeParam.ioVNmAlBlks));
	} // BLOCK
#endif
	{ // BLOCK
		// Next, mix in other stuff.
		// As we generate and *store* the nodeid, using the time should not
		// cause corellation problems with the fact that the time is also
		// used as part of the fundamental uuid generation algorithm.
		MEMORYSTATUS ms;
		FILETIME ft;
		DWORD dw;
		POINT pt;
#ifndef MAC
		LPVOID lpv;
#else
		PSN	psn;
		DWORD dwFeature;
		
		Gestalt(gestaltOSAttr, &dwFeature);
		if (BitTst(&dwFeature, 31 - gestaltTempMemSupport))
		{
		// If temporary memory is available.
			ms.dwAvailPhys = (DWORD) TempFreeMem();
			ms.dwAvailVirtual = (DWORD) TempMaxMem(&ms.dwAvailVirtual);
			ms.dwAvailPageFile = (DWORD) TempTopMem();
		}
		else
		{
		// If temporary memory is not available.
			ms.dwAvailPhys = (DWORD) TickCount();
			GetDateTime(&ms.dwAvailVirtual);
		}
#endif
#ifndef MAC
		ms.dwLength = sizeof(MEMORYSTATUS);
		GlobalMemoryStatus(&ms);
#endif

		ShiftNodeid(pnodeid);
		GetCurrentTimeUlong64(&ft);
		pnodeid->rgw[0] ^= Cyc(HIWORD(ft.dwHighDateTime)); // Use hi-order six bytes as time is *10000
		pnodeid->rgw[1] ^= Cyc(LOWORD(ft.dwHighDateTime));
		pnodeid->rgw[2] ^= Cyc(HIWORD(ft.dwLowDateTime));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(LOWORD(ms.dwAvailPhys));
		pnodeid->rgw[1] ^= Cyc(LOWORD(ms.dwAvailVirtual));
		pnodeid->rgw[2] ^= Cyc(LOWORD(ms.dwAvailPageFile));

		ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc(HIWORD(ms.dwAvailPhys));
		pnodeid->rgw[1] ^= Cyc(HIWORD(ms.dwAvailVirtual));
		pnodeid->rgw[2] ^= Cyc(HIWORD(ms.dwAvailPageFile));
		
        ShiftNodeid(pnodeid);
		dw = GetTickCount();		
		pnodeid->rgw[0] ^= Cyc(HIWORD(dw));         	// Time (ms) since boot
		pnodeid->rgw[1] ^= Cyc(LOWORD(dw));
#ifndef MAC
		pnodeid->rgw[2] ^= Cyc(LOWORD(CountClipboardFormats()));// Number of items on the clipboard
#endif
		
		GetCursorPos(&pt);								// Cursor Position
        ShiftNodeid(pnodeid);
		pnodeid->rgw[0] ^= Cyc((WORD)(pt.x));
		pnodeid->rgw[1] ^= Cyc((WORD)(pt.y));
#ifdef MAC
		MacGetCurrentProcess(&psn);
		pnodeid->rgw[2] ^= Cyc(LOWORD(psn.lowLongOfPSN));
#else
		pnodeid->rgw[2] ^= Cyc(LOWORD((DWORD)GetCurrentThread())); // Current thread we're running in
#endif
		ShiftNodeid(pnodeid);
#ifdef MAC
		pnodeid->rgw[0] ^= Cyc(HIWORD(psn.lowLongOfPSN));
		pnodeid->rgw[1] ^= Cyc(LOWORD(psn.highLongOfPSN));
#else
		pnodeid->rgw[0] ^= Cyc(HIWORD(GetCurrentThread()));
		pnodeid->rgw[1] ^= Cyc((WORD)GetOEMCP());	// sensitive to different countries		
#endif
		pnodeid->rgw[2] ^= Cyc((WORD)GetSystemMetrics(SM_SWAPBUTTON)); // different for lefties vs righties
		
		ShiftNodeid(pnodeid);
#ifndef MAC		
		lpv = GetEnvironmentStrings();
		pnodeid->rgw[0] ^= Cyc(HIWORD((DWORD)lpv));
		pnodeid->rgw[1] ^= Cyc(LOWORD((DWORD)lpv));
#endif
		pnodeid->rgw[2] ^= Cyc(HIWORD(GetCursor()));
		
		ShiftNodeid(pnodeid);
#ifdef MAC
		GetCursorPos(&pt);
#else	
		GetCaretPos(&pt);
#endif	
		pnodeid->rgw[0] ^= Cyc((WORD)(pt.x));
		pnodeid->rgw[1] ^= Cyc((WORD)(pt.y));
		pnodeid->rgw[2] ^= Cyc(LOWORD((DWORD)GetCursor()));

		ShiftNodeid(pnodeid);		
		pnodeid->rgw[0] ^= Cyc((WORD)(DWORD)GetDesktopWindow());
		pnodeid->rgw[1] ^= Cyc((WORD)(DWORD)GetActiveWindow());
#ifndef MAC
		pnodeid->rgw[2] ^= Cyc((WORD)(DWORD)GetModuleHandle("OLE32"));
#endif
		
    } // BLOCK

    /* The following exerpts are taken from

    		Project 802: Local and Metropolitan Area Network Standard
    		Draft Standard P802.1A/D10 1 April 1990
    		Prepared by the IEEE 802.1
    		
       and is available in MS technical library. The key point about this is the
       second LSB in the first byte of a real IEEE address is always zero.

       Page 18:
       "5. Universal Addresses and Protocol Identifiers

       The IEEE makes it possible for organizations to employ unique individual
       LAN MAC addresses, group addresses, and protocol identifiers. It does so by
       assigning organizationally unique identifiers, which are 24 bits in length.
       [...] Though the organizationally unique identifiers are 24 bits in length,
       their true address space is 22 bits. The first bit can be set to 1 or 0
       depending on the application. The second bit for all assignments is zero.
       The remaining 22 bits [...] result in 2**22 (approximately
       4 million identifiers.

       [...] The multicast bit is the least significant bit of the first octet, A.


       [...] 5.1 Organizationally Unique Identifier

       [...] The organizationally unique identifier is 24 bits in length and its
       bit pattern is shown below. Organizationally unique identifiers are
       assigned as 24 bit values with both values (0,1) being assigned to the
       first bit and the second bit being set to 0 indicates that the assignment
       is universal. Organizationally unique identifiers with the second bit set
       to 1 are locally assigned and have no relationship to the IEEE-assigned
       values (as described herein).

       The organizationally unique identifier is defined to be:

       	1st bit                24th bit
       	  |                       |
       	  a  b  c  d  e  .......  x  y
          |  |
          |  Always set to zero
          Bit can be set to 0 or 1 depending on application [application here is
          noting at all to do with what we, MS, call an application]

       [...] 5.2 48-Bit Universal LAN Mac Addresses
       [...] A 48 bit universal address consists of two parts. The first 24 bits
       correspond to the organizationally unique identifier as assigned by the
       IEEE except that the assignee may set the first bit to 1 for group
       addresses or set it to 0 for individual addresses. The second part,
       comprising the remaining 24 bits, is administered locally by the assignee.
       [...]
	
         octet:
             0          1          2          3          4          5
         0011 0101  0111 1011  0001 0010  0000 0000  0000 0000  0000 0001
         |
         First bit transmitted on the LAN medium. (Also the Individual/Group
         Address Bit.) The hexadecimal representation is: AC-DE-48-00-00-80
		 						
       The Individual/Group (I/G) Address Bit (1st bit of octet 0) is used to
       identify the destination address either as an individual or as a group
       address. If the Individual/Group Address Bit is 0, it indicates that
       the address field contains an individual address. If this bit is 1, the
       address field contains a group address that identifies one or more (or
       all) stations connected to the LAN. The all-stations broadcast address
       is a special, pre-defined group address of all 1's.

       The Universally or Locally Administered Address Bit (2nd bit of octet 0)
       is the bit directly following the I/G bit. This bit indicates whether
       the address has been assigned by a local or universal administrator.
       Universally administered addresses have this bit set to 0. If this bit
       is set to 1, the entire address (i.e.: 48 bits) has been locally administered."

	*/
	pnodeid->rgb[0] |= 2;	// Ensure that this is a locally administered address
	pnodeid->rgb[0] &= ~1;	// For future expandability: ensure one bit is
							// always zero.

	return NOERROR;	
}	

INTERNAL GetPseudoRandomNodeId(NODEID* pnodeid)
// Use the same nodeid we did last time if it's there; otherwise,
// make a new one.
{
	HRESULT hr = NOERROR;
	char szHexBuffer[CCHHEXBUFFERMAX];
	LONG cch = CCHHEXBUFFERMAX;
	
	// See if we already have a nodeid registered
	cch = GetPrivateProfileString(szDataKey, szNodeId, szBlank,
									szHexBuffer, (int)cch, szProfileFile);
	if (cch != 0 && cch < CCHHEXBUFFERMAX) {
		FromHexString(szHexBuffer, pnodeid, sizeof(*pnodeid));
		
	} else {
	// If we don't presently have a nodeid registered, make one, then register it
		hr = GenerateNewNodeId(pnodeid);
		if (hr != NOERROR) goto Exit;
		
		ToHexString(pnodeid, sizeof(*pnodeid), szHexBuffer);
		
		if (WritePrivateProfileString(szDataKey, szNodeId, szHexBuffer,szProfileFile)) {
			WritePrivateProfileString(NULL,NULL,NULL,szProfileFile); // flush ini cache		
		} else {
			hr = ResultFromScode(REGDB_E_WRITEREGDB);
			goto Exit;
			}
	}
				
Exit:
	return hr;
}

//========================================================================	
INTERNAL_(unsigned char) ToUpper(unsigned char ch)
{
	if (ch >= 'a' && ch <= 'z')
		return (unsigned char)(ch - 'a' + 'A');
	else
		return ch;
}

INTERNAL_(BYTE) FromHex(unsigned char ch)
{
	BYTE b = (BYTE) (ToUpper(ch) - '0');
	if (b > 9)
		b -= 'A' -'9' -1;
	return b;
}

INTERNAL_(void) FromHexString(LPCSTR sz, LPVOID pv, USHORT cb)
// Set the value of this array of bytes from the given hex string
{
	BYTE FAR *rgb = (BYTE FAR*)pv;
	const char FAR *pch = sz;

	memset(rgb, 0, cb);

	if ((lstrlen(pch) & 1) != 0)
	    rgb[0] = FromHex(*pch++);			// Odd length; do the leading nibble separately
	while (*pch != '\0') {
		BYTE b = FromHex(*pch++);			// get next nibble
		b = (BYTE)((b<<4) | FromHex(*pch++)); 		// and the next
		MoveMemory(&rgb[1], &rgb[0], cb-1);	// shift us over one byte		
		rgb[0] = b;
	}
}
	
INTERNAL_(unsigned char) ToHex(BYTE b)
{
	b &= 0x0f;
	if (b > 9)
		return (BYTE)(b -10 + 'A');
	else
		return (BYTE)(b -0  + '0');
}	
	
INTERNAL_(void) ToHexString(LPVOID pv, USHORT cb, LPSTR sz)
// sz must be at least 2*cb +1 characters long
{
	const BYTE FAR *rgb = (const BYTE FAR *)pv;
	const int ibLast = cb-1;
	int ib;

	for (ib = ibLast; ib >= 0; ib--) {
		sz[(ibLast-ib)*2] 	 = ToHex((BYTE)(rgb[ib]>>4));
		sz[(ibLast-ib)*2+1]  = ToHex(rgb[ib]);
	}
	sz[(ibLast+1)*2] = '\0';
}
                                       	

//========================================================================

// NOTE: As much as it might appear, this structure definition is NOT byte
// order sensitive. That is, the structure definition and the field
// manipulations that we use are in fact correct on both little and big	
// endian machines.

#pragma pack(1)	
struct _INTERNALUUID
	{
	ULONG		timeLow;
	USHORT		timeMid;
	USHORT		timeHighAndVersion;
	BYTE		clkseqHighAndReserved;
	BYTE		clkseqLow;
	BYTE		nodeid[6];
	};
#pragma pack()

typedef struct _INTERNALUUID	INTERNALUUID;
	
enum {
// Constants used below for manipulating fields in the UUID
	uuidReserved 		= 0x80,		// we are a variant 1 UUID
	uuidVersion			= 0x1000,   // version 1 (high nibble significant)
	};	

//=================================================================

STDAPI HrCreateGuidNoNet(GUID FAR *pguid)
// This is the only public function in this file.
// Return a newly allocated GUID.
	{
	static UDBK udbk;	// We rely on static initialization to zero
	HRESULT hr;
	INTERNALUUID FAR* puuid = (INTERNALUUID FAR *)pguid;
	if (udbk.timeLowNext == udbk.timeLowLast)
		{
		if ((hr = GetUDBK(&udbk)) != NOERROR)
			return hr;
		}
 		
	puuid->timeLow =  udbk.timeLowNext++;
	puuid->timeMid = (USHORT)(udbk.timeHigh & 0xffff);
	puuid->timeHighAndVersion =
		(USHORT) (((USHORT)((udbk.timeHigh >> 16) & 0x0fff))
					| ((USHORT) uuidVersion));
	puuid->clkseqHighAndReserved =
		(BYTE)((BYTE) ((udbk.clkseq >> 8) & 0x3f)
			| (BYTE) uuidReserved);
	puuid->clkseqLow = (BYTE)(udbk.clkseq & 0xff);
	memcpy(&puuid->nodeid[0], &udbk.nodeid.rgb[0], sizeof(NODEID));
	
	return hrSuccess;
	}

#endif /* WIN32 only */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dead\btnbar.c ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     BtnBar.cpp
//
//  PURPOSE:    Implements a generic button bar.
//

#include "_apipch.h"

#define idtTrack 101
#define idcFolderList 102
#define HOTTRACK_TIMER 100
#define ID_HWNDBAR 2020

extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;

//#define DEAD

void CBB_ConfigureRects(HWND hwnd);
void CBB_DoHotTracking(HWND hwnd);
void CBB_EndHotTracking(HWND hwnd);
int CBB_HitTest(int x, int y);
void CBB_SetSelBtn(int iSel,HWND hwnd);


//
//  FUNCTION:   CButtonBar::~CButtonBar()
//
//  PURPOSE:    Cleans up the resources we allocated during the life of the
//              object.
//
void CBB_Cleanup(void)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // Free the GDI resources.
    ImageList_Destroy(m_himlButtons);
    DeleteObject(m_hpalBkgnd);
    DeleteObject(m_hfButton);
    DeleteObject(m_hbmpBkgnd);

    // Free the button array.
    LocalFreeAndNull((LPVOID *)&m_rgButtons);

    // NOTE - this is a comment from the original athena source code
    //$REVIEW - we can't do this here, because it screws up
    //          when we have multiple instances of the CButtonBar
    //          with overlapping creates and destroys.  we should
    //          probably unregister somewhere, but it isn't strictly
    //          necessary. (EricAn)
    // Unregister our window class.
    // UnregisterClass(c_szButtonBar, m_hInstance);

    return;
}


//
//  FUNCTION:   CButtonBar::Create()
//
//  PURPOSE:    Initializes the button bar and creates the button bar window.
//
//  PARAMETERS:
//      hwndParent - Handle of the window that will be the button bar parent.
//      idHwnd     - Child window ID for the button bar.
//      idButtons  - ID of the button icons bitmap.
//      idHorzBackground - ID of the horizontal background bitmap.
//      idVertBackground - ID of the vertical background bitmap.
//      pBtnCreateParams - Pointer to the array of BTNCREATEPARAMS used to create the buttons.
//      cParams    - Number of buttons in pBtnCreateParams.
//      uSide      - Side of the parent window the bar should initially attach to.
//
//  RETURN VALUE:
//      Returns TRUE if successful, or FALSE otherwise.
//
HWND CBB_Create(HWND hwndParent, UINT idButtons,
                        UINT idHorzBackground,
                        PBTNCREATEPARAMS pBtnCreateParams, UINT cParams)
    {

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    int i;
    WNDCLASS wc;
    BITMAP bm;
    RECT rc;
    POINT ptL, ptR;
    ICONMETRICS im;
    HWND hwnd = NULL;


    wc.style         = CS_DBLCLKS;              // Bug #15450
    wc.lpfnWndProc   = CBB_ButtonBarProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.hInstance     = hinstMapiX;
    wc.hIcon         = 0;
    wc.hCursor       = 0;
    wc.hbrBackground = 0;
    wc.lpszMenuName  = 0;
    wc.lpszClassName = c_szButtonBar;

    RegisterClass(&wc);

    m_rgButtons = NULL;
    m_himlButtons = 0;
    m_hbmpBkgnd = 0;
    m_hpalBkgnd = 0;
    m_hfButton = 0;
    m_cButtons = 0;
    m_iSelect = -1;
    m_iOldSelect = -1;

    // This is the information we'll need later to to draw the button bar etc.
    // Stash it away for now.
    m_cButtons = cParams;

    m_rgButtons = LocalAlloc(LMEM_ZEROINIT, sizeof(BUTTON) * m_cButtons);
    if (!m_rgButtons) return FALSE;

    for (i = 0; i < m_cButtons; i++)
        {
        m_rgButtons[i].id = pBtnCreateParams[i].id;
        m_rgButtons[i].iIcon = pBtnCreateParams[i].iIcon;

        LoadString(hinstMapiX, pBtnCreateParams[i].idsLabel,
                   m_rgButtons[i].szTitle, sizeof(m_rgButtons[i].szTitle));
        }

    // Load the bitmaps we'll need for drawing.
    m_himlButtons = gpfnImageList_LoadImage(hinstMapiX, MAKEINTRESOURCE(idButtons),
                                        c_cxButtons, 0, c_crMask, IMAGE_BITMAP,
                                        0); //LR_LOADMAP3DCOLORS);
    if (!m_himlButtons)
        return (FALSE);

    // Get the width of the bitmap we're going to use as the background so we
    // know how wide to make the window.
    if (!LoadBitmapAndPalette(idHorzBackground, &m_hbmpBkgnd, &m_hpalBkgnd))
        return (FALSE);

    if (!GetObject(m_hbmpBkgnd, sizeof(BITMAP), (LPVOID) &bm))
        return (FALSE);

    GetClientRect(hwndParent, &rc);

    // Get the font we're going to use for the buttons
    im.cbSize = sizeof(ICONMETRICS);
    SystemParametersInfo(SPI_GETICONMETRICS, 0, (LPVOID) &im, 0);
    m_hfButton = CreateFontIndirect(&(im.lfFont));
    if (!m_hfButton)
        return (FALSE);

    ptL.x = ptL.y=0;
    ptR.x = rc.right;
    ptR.y = bm.bmHeight;

    hwnd = CreateWindowEx(WS_EX_CLIENTEDGE,
                        c_szButtonBar,
                        c_szButtonBar,
                        WS_CLIPSIBLINGS |
                        WS_VISIBLE |
                        WS_CHILD,
                        ptL.x,
                        ptL.y,
                        ptR.x,
                        ptR.y,
                        hwndParent,
                        (HMENU) ID_HWNDBAR,
                        hinstMapiX,
                        NULL);

    CBB_ConfigureRects(hwnd);

    return (hwnd);
    }


//
//  FUNCTION:   CButtonBar::ButtonBarProc()
//
//  PURPOSE:    Message handler for the button bar window.
//
LRESULT CALLBACK CBB_ButtonBarProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                           LPARAM lParam)
    {

    switch (uMsg)
        {
        case WM_NCCREATE:
            SetWindowLong(hwnd, 0, (LONG) ((LPCREATESTRUCT) lParam)->lpCreateParams);
            return (TRUE);
/***
        case WM_CREATE:
            return 0;
            break;

        case WM_SIZE:
            return 0;
            break;

        case WM_LBUTTONDOWN:
            return 0;
            break;

        case WM_COMMAND:
            return 0;
            break;

/***/
        case WM_PAINT:
            CBB_OnPaint(hwnd);
            return 0;
            break;

        case WM_MOUSEMOVE:
            CBB_OnMouseMove(hwnd, LOWORD(lParam), HIWORD(lParam), wParam);
            return 0;
            break;

        case WM_LBUTTONUP:
            CBB_OnLButtonUp(hwnd, LOWORD(lParam), HIWORD(lParam), wParam);
            return 0;
            break;

        case WM_TIMER:
            CBB_OnTimer(hwnd, wParam);
            return 0;
            break;

        case WM_MOUSEACTIVATE:
            CBB_OnMouseActivate(hwnd, (HWND) wParam, (INT) LOWORD(lParam), (UINT) HIWORD(lParam));
            return 0;
            break;

        case WM_PALETTECHANGED:
            if ((HWND) wParam != hwnd)
                {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                HDC hdc = GetDC(hwnd);
                HPALETTE hPalOld = SelectPalette(hdc, m_hpalBkgnd, TRUE);
                RealizePalette(hdc);
                InvalidateRect(hwnd, NULL, TRUE);
                SelectPalette(hdc, hPalOld, TRUE);
                ReleaseDC(hwnd, hdc);
                }
            return 0;
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }


void CBB_OnPaint(HWND hwnd)
    {
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    HDC hdc;
    PAINTSTRUCT ps;
    BITMAP bm;
    HDC hdcMem;
    HBITMAP hbmMemOld, hbmMem;
    HPALETTE hpalOld;
    RECT rc;
    HFONT hf;
    COLORREF clrText, clrBk;

    int cxIndent = 3;
    int cyIndent = 3;
    int nTop = 0;
    int nLeft = 0;
    int nButton = 0;
    int i=0;

    if(!hwnd) goto out;

    // Get the size of the background bitmap
    GetObject(m_hbmpBkgnd, sizeof(BITMAP), (LPVOID) &bm);
    GetClientRect(hwnd, &rc);

    hdc = BeginPaint(hwnd, &ps);
    hdcMem = CreateCompatibleDC(hdc);

    // If we are displaying the buttons ...
        {
        // Draw the background bitmaps first.
        hpalOld = SelectPalette(hdc, m_hpalBkgnd, TRUE);
        RealizePalette(hdc);

        hbmMemOld = (HBITMAP) SelectObject(hdcMem, (HGDIOBJ) m_hbmpBkgnd);

        // If the window is taller or wider than a single bitmap, we may have
        // to loop and put a couple out there.
            while (nLeft < rc.right)
                {
                BitBlt(hdc, nLeft, nTop, bm.bmWidth, bm.bmHeight, hdcMem, 0,
                       0, SRCCOPY);
                nLeft += bm.bmWidth;
                }

        // Now draw the buttons
        nTop = 0;

        hf = (HFONT) SelectObject(hdc, m_hfButton);
        SetBkMode(hdc, TRANSPARENT);

        while (nButton < m_cButtons)
            {
            if (RectVisible(hdc, &(m_rgButtons[nButton].rcBound)))
                {
                ImageList_Draw(m_himlButtons, m_rgButtons[nButton].iIcon, hdc,
                               m_rgButtons[nButton].rcIcon.left, m_rgButtons[nButton].rcIcon.top,
                               ILD_TRANSPARENT);

                // Draw the title of the button that the mouse is over with a
                // different color.
                if (nButton == m_iSelect)
                {
                    clrBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    clrText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                }
                else
                {
                    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
                    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
                }

                SetTextAlign(hdc, TA_TOP /* | TA_CENTER */);


                if (nButton == m_iSelect)
                {
                    clrText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    ExtTextOut( hdc,
                                (m_rgButtons[nButton].rcTitle.right - m_rgButtons[nButton].rcTitle.left) / 2 + m_rgButtons[nButton].rcTitle.left,
                                m_rgButtons[nButton].rcTitle.top,
                                ETO_OPAQUE | ETO_CLIPPED,
                                &(m_rgButtons[nButton].rcTitle),
                                m_rgButtons[nButton].szTitle,
                                lstrlen(m_rgButtons[nButton].szTitle),
                                NULL);
                    clrText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    DrawText(hdc, m_rgButtons[nButton].szTitle, lstrlen(m_rgButtons[nButton].szTitle),
                             &m_rgButtons[nButton].rcTitle, DT_CENTER | DT_WORDBREAK);
                }
                else
                {
                    DrawText(hdc, m_rgButtons[nButton].szTitle, lstrlen(m_rgButtons[nButton].szTitle),
                             &m_rgButtons[nButton].rcTitle, DT_CENTER | DT_WORDBREAK);
                }

                if (nButton == m_iSelect)
                    {
                    SetBkColor(hdc,clrBk);
                    SetTextColor(hdc, clrText);
                    }
                }
            nButton++;
            }

        SelectObject(hdc, m_hfButton);

        if (hpalOld != NULL)
            SelectPalette(hdc, hpalOld, TRUE);

        SelectObject(hdcMem, hbmMemOld);
        }

    DeleteObject(hbmMem);
    DeleteDC(hdcMem);
    EndPaint(hwnd, &ps);

out:
    return;
    }



//
//  FUNCTION:   CButtonBar::OnLButtonUp()
//
//  PURPOSE:    If we are dragging the button bar around, then the user has
//              released the bar and we can clean up.  If the user wasn't
//              dragging, then they have clicked on a button and we send the
//              appropriate command message to the parent window.
//
void CBB_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    int iSel = 0;

    if (-1 != (iSel = CBB_HitTest(x, y)))
    {
        // Move command handling from LButtonUp to LButtonDown to avoid
        // duplicate messages being sent from double clicks - Nash Bug #15450
        if (0 <= iSel)
        {
            SendMessage(GetParent(hwnd), WM_COMMAND, m_rgButtons[iSel].id, (LPARAM) hwnd);
            CBB_SetSelBtn(-1,hwnd);
        }
    }

    return;
}


//
//  FUNCTION:   CButtonBar::OnMouseMove()
//
//  PURPOSE:    If the user is dragging the bar around, we need to determine
//              which side of the parent window the mouse is closest to and
//              move the button bar to that edge.
//
//              If the user is not dragging, then we need to decide if the
//              mouse is over a button and if so highlight the text.
//
void CBB_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
    POINT pt = {x, y};
    int iSel;
    POINT ptScreen = {x, y};


    // If we're not dragging the bar around, the just update the button
    // selection.
    iSel = CBB_HitTest(x, y);
    CBB_SetSelBtn(iSel,hwnd);
    if (iSel != -1)
        SetCursor(LoadCursor(hinstMapiX, MAKEINTRESOURCE(idcurPointedHand)));
    else
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    CBB_DoHotTracking(hwnd);
    return;
   }




int CBB_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg)
    {
        return (MA_ACTIVATE);
    }



//
//  FUNCTION:   CButtonBar::ConfigureRects()
//
//  PURPOSE:    Calculates the rectangles that are necessary for displaying
//              the button bar based on the side of the parent window the
//              bar is currently attached to.
//
void CBB_ConfigureRects(HWND hwnd)
    {
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // Need to gather some font information first.  We need the height of the
    // folder title font all the time and we need the width of the longest
    // button title if we're displayed horizontally.

    HDC        hdc;
    int        i;
    int        cxMaxTitle;
    SIZE       sizeString;
    SIZE       sizeRect;
    int cyIconTitle;
    int cxCenter;
    int cyCenter;
    TEXTMETRIC tmTitle;

    hdc = GetDC(hwnd);

    SelectObject(hdc, m_hfButton);
    GetTextMetrics(hdc, &tmTitle);

    // Button text width
        cxMaxTitle = 0;
        for (i = 0; i < m_cButtons; i++)
            {
            GetTextExtentPoint32(hdc, m_rgButtons[i].szTitle,
                                 lstrlen(m_rgButtons[i].szTitle),
                                 &sizeString);
            if (sizeString.cx > cxMaxTitle)
                cxMaxTitle = sizeString.cx;
            }

        // Add a little buffer here just to make it look nice.
        cxMaxTitle += 10;

    ReleaseDC(hwnd, hdc);

    // Now calculate the button rectangles.  Each button will have three rects
    // associated with it.  The first rectangle is the overall bounding rect
    // which contains the image and title.  The next rectangle is the rect for
    // the image which is centered horizontally within the bounding rect and
    // vertically when combined with the title.  The final rect is the title.

    // Calculate the initial bounding rectangle based on whether or not we're
    // horizontal or vertical.  sizeRect is the dimensions of each button's
    // bounding rectangle.

        {
        RECT rcBound,rcWnd;
        int cyButton=0,cxButton=0;

        ImageList_GetIconSize(m_himlButtons, &cxButton, &cyButton);

        GetClientRect(hwnd,&rcWnd);
        sizeRect.cx = cxMaxTitle;
        sizeRect.cy = rcWnd.bottom - rcWnd.top;
        SetRect(&rcBound, 0, 0, sizeRect.cx, sizeRect.cy);

        // Also calculate the offsets needed to center the image and text within
        // the bound.
        cyIconTitle = tmTitle.tmHeight + cyButton;
        cxCenter = ((rcBound.right - rcBound.left) - cxButton) / 2;
        cyCenter = ((rcBound.bottom - rcBound.top) - cyIconTitle) / 2;

        // Now loop through all the buttons
        for (i = 0; i < m_cButtons; i++)
            {
            m_rgButtons[i].rcBound = rcBound;

            // Center the image horizontally within the bounding rect.
            m_rgButtons[i].rcIcon.left = m_rgButtons[i].rcBound.left + cxCenter;
            m_rgButtons[i].rcIcon.top = m_rgButtons[i].rcBound.top + cyCenter;
            m_rgButtons[i].rcIcon.right = m_rgButtons[i].rcIcon.left + cxButton;
            m_rgButtons[i].rcIcon.bottom = m_rgButtons[i].rcIcon.top + cyButton;

            // And the button title below the image
            m_rgButtons[i].rcTitle.left = m_rgButtons[i].rcBound.left + 1;
            m_rgButtons[i].rcTitle.top = m_rgButtons[i].rcIcon.bottom;
            m_rgButtons[i].rcTitle.right = m_rgButtons[i].rcBound.right - 1;
            m_rgButtons[i].rcTitle.bottom = m_rgButtons[i].rcTitle.top + (tmTitle.tmHeight);// * 2);

            // Offset the rcBound to the next button.
                OffsetRect(&rcBound, sizeRect.cx, 0);
            }
        }
    }




//
//  FUNCTION:   CButtonBar::OnTimer()
//
//  PURPOSE:    When the timer fires we check to see if the mouse is still
//              over the button bar window.  If not we remove the selection
//              from the active button.
//
void CBB_OnTimer(HWND hwnd, UINT id)
    {
    POINT pt;
    GetCursorPos(&pt);
    if (hwnd != WindowFromPoint(pt))
    {
        CBB_SetSelBtn(-1,hwnd);
    }

    CBB_EndHotTracking(hwnd);
    }


//
//  FUNCTION:   CButtonBar::DoHotTracking()
//
//  PURPOSE:    Starts a timer that allows the button bar to track the mouse
//              in case it leaves the button bar window.
//
void CBB_DoHotTracking(HWND hwnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    CBB_EndHotTracking(hwnd);
    m_fHotTrackTimer = SetTimer(hwnd, idtTrack, HOTTRACK_TIMER, NULL);
}


//
//  FUNCTION:   CButtonBar::EndHotTracking()
//
//  PURPOSE:    If the timer was set to track the mouse, we kill it and reset
//              our state.
//
void CBB_EndHotTracking(HWND hwnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    if (m_fHotTrackTimer)
    {
        KillTimer(hwnd, idtTrack);
        m_fHotTrackTimer = FALSE;
    }
}


//
//  FUNCTION:   CButtonBar::HitTest()
//
//  PURPOSE:    Returns the button number that the passed in position is
//              over.  If the mouse is over the menu button, it returns
//              -2.  Otherwise, if the mouse is not over a button the function
//              returns -1.
//
//  PARAMETERS:
//      x, y - Position in client coordinates to check.
//
int CBB_HitTest(int x, int y)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    POINT pt = {x, y};
    int i;

    // Walk through the different buttons and determine if the point is
    // within either their image or title.
    for (i = 0; i < m_cButtons; i++)
        {
        if (PtInRect(&m_rgButtons[i].rcBound, pt))
/*            PtInRect(&m_rgButtons[i].rcIcon, pt) ||
            PtInRect(&m_rgButtons[i].rcTitle, pt)) */
            {
            return (i);
            }
        }

   // If we're not over a button then return a default value.
    return (-1);
}




//
//  FUNCTION:   CButtonBar::CBB_SetSelBtn()
//
//  PURPOSE:    Changes the button selection to the specified button.
//
void CBB_SetSelBtn(int iSel,HWND hwnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if (m_iSelect != iSel)
    {
        HDC hdc = GetDC(hwnd);

        // Remove the old selection
        if (m_iSelect >= 0)
            InvalidateRect(hwnd, &m_rgButtons[m_iSelect].rcTitle, FALSE);

        // Add the new selection
        if (iSel >= 0)
            InvalidateRect(hwnd, &m_rgButtons[iSel].rcTitle, FALSE);

        m_iOldSelect = m_iSelect;

//        if (m_iOldSelect >= 0)
//            DrawFocusRect(hdc, &m_rgButtons[m_iOldSelect].rcBound);

        m_iSelect = iSel;

//        if (m_iSelect >= 0)
//            DrawFocusRect(hdc, &m_rgButtons[m_iSelect].rcBound);

        ReleaseDC(hwnd, hdc);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dead\oldstuff.c ===
// This file contains dead code we dont use in the WAB but which we dont want
// to lose as it may be useful someday ...
//

#ifdef IMPORT_WAB
/***************************************************************************

    Name      : HrImportWABFile

    Purpose   : Merges an external WAB file with the current on

    Parameters: hwnd = hwnd
                lpIAB -> IAddrBook object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrImportWABFile(HWND hWnd, LPADRBOOK lpIAB)
{
    HRESULT hResult = hrSuccess;
    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(idsWABImportString, TEXT("*.WAB"));
    TCHAR szFileName[MAX_PATH + 1] = "";

    HANDLE hPropertyStore = NULL;

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = TEXT("Select WAB File to Import");
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = "wab";
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;


    if (GetOpenFileName(&ofn))
    {
        ULONG ulEIDCount = 0;
        LPDWORD lpdwEntryIDs = NULL;
        ULONG i;
        SPropertyRestriction PropRes = {0};
        HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        TCHAR szBuf[MAX_UI_STR];


        hResult = OpenPropertyStore(
                            szFileName,
                            AB_OPEN_EXISTING,
                            hWnd,
                            &hPropertyStore);

        if(HR_FAILED(hResult) || (!hPropertyStore))
        {
            ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFileName);
            goto out;
        }

        PropRes.ulPropTag = PR_DISPLAY_NAME;
        PropRes.relop = RELOP_EQ;
        PropRes.lpProp = NULL;

        hResult = FindRecords(
                            hPropertyStore,
                            AB_MATCH_PROP_ONLY,
                            TRUE,
                            &PropRes,
                            &ulEIDCount,
                            &lpdwEntryIDs);


        if(HR_FAILED(hResult))
        {
            LocalFreeAndNull(&lpdwEntryIDs);
            goto out;
        }

        if (ulEIDCount > 0)
        {

            for(i=0;i<ulEIDCount;i++)
            {
                SBinary sb = {0};
                LPSPropValue lpPropArray = NULL;
                ULONG ulcValues = 0;
                ULONG cbEntryID = 0;
                LPENTRYID lpEntryID = NULL;
                ULONG j;
                LPTSTR lpszName;

                sb.cb = SIZEOF_WAB_ENTRYID;
                sb.lpb = (LPBYTE) &(lpdwEntryIDs[i]);

                hResult = ReadRecord(
                        hPropertyStore,
                        &sb,
                        0,
                        &ulcValues,
                        &lpPropArray);

                if(HR_FAILED(hResult))
                {
                    if(lpPropArray)
                        LocalFreePropArray(ulcValues,&lpPropArray);
                    continue;
                }

                // can't import dist lists yet - they will be imported in a second pass
                for(j=0;j<ulcValues;j++)
                {
                    if(lpPropArray[j].ulPropTag == PR_OBJECT_TYPE)
                    {
                        if(lpPropArray[j].Value.l != MAPI_MAILUSER)
                            goto endloop;
                    }
                    if(lpPropArray[j].ulPropTag == PR_DISPLAY_NAME)
                    {
                        lpszName = lpPropArray[j].Value.LPSZ;
                    }
                }

                // reset entryid
                for(j=0;j<ulcValues;j++)
                {
                    if(lpPropArray[j].ulPropTag == PR_ENTRYID)
                    {
                        lpPropArray[j].Value.bin.cb = 0;
                        LocalFreeAndNull(&lpPropArray[j].Value.bin.lpb);
                        break;
                    }
                }

                //Status bar messages out here
                // This is temp - TBD
                // Modify to use resource and Format Message
                wsprintf(szBuf,"Importing %s. Entry: '%s'.",szFileName,lpszName);
                StatusBarMessage(szBuf);

                hResult = HrCreateNewEntry(
                            lpIAB,
                            hWnd,
                            MAPI_MAILUSER,
                            CREATE_CHECK_DUP_STRICT,
                            FALSE,
                            ulcValues,
                            lpPropArray,
                            &cbEntryID,
                            &lpEntryID );


endloop:
                if(lpPropArray)
                    LocalFreePropArray(ulcValues,&lpPropArray);

                if(lpEntryID)
                    MAPIFreeBuffer(lpEntryID);

            } //for loop


        } // if

out:
        if(hPropertyStore)
            ClosePropertyStore(hPropertyStore,AB_DONT_BACKUP);

        LocalFreeAndNull(&lpdwEntryIDs);

        SetCursor(hOldCur);
    }

    LocalFreeAndNull(&lpFilter);
    LocalFreeAndNull((LPVOID *)&(ofn.lpstrTitle));

    StatusBarMessage(szEmpty);

    return(hResult);

}
#endif

#ifdef OLD_STUFF
//$$//////////////////////////////////////////////////////////////////////
//	HrSendMailToContact
//
//	Retrieves the contacts email address and shell executes a "mailto:"
//
//  hWndLV - handle of List view. We look up the selected item in this list
//              view, get its lParam structure, then get its EntryID and
//              call details
//  lpIAB - handle to current AdrBook object - used for calling details
//
//  Returns:S_OK
//          E_FAIL
//
//////////////////////////////////////////////////////////////////////////
static const SizedSPropTagArray(1, ptaEmailAddress)=
{
    1,
    {
        PR_EMAIL_ADDRESS,
    }
};
HRESULT HrSendMailToContact(HWND hWndLV, LPADRBOOK lpIAB)
{
	HRESULT hr = E_FAIL;
	int iItemIndex = ListView_GetSelectedCount(hWndLV);
	HWND hWndParent = GetParent(hWndLV);
    TCHAR szBuf[MAX_UI_STR];
    LPSPropValue lpspv = NULL;
    IF_WIN16(static const char cszMailClient[]  = "MSIMN.EXE";)

	// Open props if only 1 item is selected
	if (iItemIndex == 1)
	{
		// Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
		if (iItemIndex != -1)
		{
			LPRECIPIENT_INFO lpItem;
			LV_ITEM LVItem;

			LVItem.mask = LVIF_PARAM;
            LVItem.iItem = iItemIndex;
            LVItem.iSubItem = 0;
            LVItem.lParam = 0;

			// Get item lParam LPRECIPIENT_INFO structure
            if (ListView_GetItem(hWndLV,&LVItem))
			{
				lpItem = ((LPRECIPIENT_INFO) LVItem.lParam);
                if(lpItem->szEmailAddress && lstrlen(lpItem->szEmailAddress))
                {
                    LPTSTR lpszMailTo = NULL;
                    LPTSTR lpszEmail = NULL;
                    ULONG cValues;
                    LoadString(hinstMapiX, idsSendMailTo, szBuf, sizeof(szBuf));

                    // Open the entry and read the email address.
                    // NOTE: We can't just take the address out of the listbox
                    // because it may be truncated!
                    if (HR_FAILED(hr = HrGetPropArray(lpIAB,
                      (LPSPropTagArray)&ptaEmailAddress,
                      lpItem->cbEntryID,
                      lpItem->lpEntryID,
                      &cValues,
                      &lpspv))) {
                        goto out;
                    }

                    lpszEmail = lpspv[0].Value.LPSZ;

                    if (FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        szBuf,
                                        0,                    // stringid
                                        0,                    // dwLanguageId
                                        (LPTSTR)&lpszMailTo,     // output buffer
                                        0,                    //MAX_UI_STR
                                        (va_list *)&lpszEmail))
                    {
#ifndef WIN16
                        ShellExecute(hWndParent, "open", lpszMailTo, NULL, NULL, SW_SHOWNORMAL);
                        LocalFreeAndNull(&lpszMailTo);
#else
                        ShellExecute(hWndParent, NULL, cszMailClient, lpszMailTo, NULL, SW_SHOWNORMAL);
                        FormatMessageFreeMem(lpszMailTo);
#endif
                        hr = S_OK;
                        goto out;
                    }

				}
                else
                {
                    // the item has no email
                    ShowMessageBox(GetParent(hWndLV), idsSendMailToNoEmail, MB_ICONEXCLAMATION | MB_OK);
                }
			}

		}
	}
	else
    {
        if (iItemIndex <= 0)
		{
			// nothing selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
		}
		else
		{
			//multiple selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_ACTION, MB_ICONEXCLAMATION);
		}
    }


out:
    FreeBufferAndNull(&lpspv);

	return hr;

}
#endif

#ifdef CERT_PROPS
IDD_DIALOG_CERT_GENERAL DIALOG DISCARDABLE  0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg"
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    ICON            IDI_ICON_CERT,IDC_CERT_GENERAL_ICON,7,7,20,20
    LTEXT           "John Smith <jsmith@generic.com>",
                    IDC_CERT_GENERAL_LABEL_CERTFORDATA,56,12,149,8
    LTEXT           "Serial Number:",IDC_CERT_GENERAL_LABEL_SERIALNUM,7,45,
                    47,8
    LTEXT           "12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  12 34 56 78 90  ",
                    IDC_CERT_GENERAL_LABEL_SERIALNUMDATA,56,45,149,26
    LTEXT           "Valid From:",IDC_CERT_GENERAL_LABEL_VALIDFROM,7,30,36,8
    LTEXT           "September 19, 1996 to September 18, 1997",
                    IDC_CERT_GENERAL_LABEL_VALIDFROMDATA,56,30,139,8
    GROUPBOX        "Issued By:",IDC_CERT_GENERAL_FRAME_ISSUED,7,71,198,32
    LTEXT           "Verisign, Inc.",IDC_CERT_GENERAL_LABEL_ISSUER,38,86,158,
                    8
    GROUPBOX        "Status:",IDC_CERT_GENERAL_FRAME_STATUS,7,107,198,74
    ICON            IDI_ICON_CHECK,IDC_CERT_GENERAL_ICON_CHECK,13,116,20,20
    ICON            IDI_ICON_UNCHECK,IDC_CERT_GENERAL_ICON_UNCHECK,13,116,20,
                    20
    LTEXT           "This ID is valid.",IDC_CERT_GENERAL_STATIC_STATUS,38,
                    120,150,10
    LTEXT           "Revoked:",IDC_CERT_GENERAL_LABEL_REVOKED,40,135,32,8
    LTEXT           "No.",IDC_CERT_GENERAL_LABEL_REVOKEDDATA,81,135,12,8
    LTEXT           "Expired:",IDC_CERT_GENERAL_LABEL_EXPIRED,40,149,26,8
    LTEXT           "No.",IDC_CERT_GENERAL_LABEL_EXPIREDDATA,81,149,12,8
    LTEXT           "&Trusted:",IDC_CERT_GENERAL_LABEL_TRUST,39,163,27,8
    COMBOBOX        IDC_CERT_GENERAL_COMBO_TRUST,109,161,89,43,
                    CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Yes.",IDC_CERT_GENERAL_LABEL_TRUSTEDDATA,81,163,18,8
END

IDD_DIALOG_CERT_TRUST DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "View the Chain of Trust for this digital ID here. ",
                    IDC_CERT_TRUST_LABEL_EXPLAIN,36,12,169,8
    GROUPBOX        "&Chain of Trust:",IDC_CERT_TRUST_FRAME_CHAIN,7,30,198,
                    151
#ifndef WIN16
    CONTROL         "Tree1",IDC_CERT_TRUST_TREE_CHAIN,"SysTreeView32",
                    TVS_HASLINES | TVS_DISABLEDRAGDROP | WS_TABSTOP,14,46,
                    184,127,WS_EX_CLIENTEDGE
#else
    CONTROL         "Tree1",IDC_CERT_TRUST_TREE_CHAIN,"IE_SysTreeView",
                    TVS_HASLINES | TVS_DISABLEDRAGDROP | WS_TABSTOP,14,46,
                    184,127
#endif // !WIN16
    ICON            IDI_ICON_CERT,IDC_CERT_GENERAL_ICON,7,7,18,20
END

IDD_DIALOG_CERT_ADVANCED DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "View additional properties for this digital ID here.",
                    IDC_CERT_ADVANCED_LABEL_EXPLAIN,36,12,169,11
    LTEXT           "&Field:",IDC_CERT_ADVANCED_LABEL_FIELD,7,39,28,8
#ifndef WIN16
    CONTROL         "List1",IDC_CERT_ADVANCED_LIST_FIELD,"SysListView32",
                    LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_AUTOARRANGE | LVS_NOCOLUMNHEADER | LVS_NOSORTHEADER |
                    WS_BORDER | WS_TABSTOP,7,49,69,121,WS_EX_CLIENTEDGE
#else
    CONTROL         "List1",IDC_CERT_ADVANCED_LIST_FIELD,"IE_SysListView",
                    LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_AUTOARRANGE | LVS_NOCOLUMNHEADER | LVS_NOSORTHEADER |
                    WS_BORDER | WS_TABSTOP,7,49,69,121
#endif // !WIN16
    LTEXT           "Details:",IDC_CERT_ADVANCED_LABEL_DETAILS,77,39,28,8
#ifndef WIN16
    EDITTEXT        IDC_CERT_ADVANCED_EDIT_DETAILS,78,49,127,121,
                    ES_MULTILINE | ES_READONLY | WS_VSCROLL,WS_EX_CLIENTEDGE
#else
    EDITTEXT        IDC_CERT_ADVANCED_EDIT_DETAILS,78,49,127,121,
                    ES_MULTILINE | ES_READONLY | WS_VSCROLL
#endif // !WIN16
    ICON            IDI_ICON_CERT,IDC_CERT_GENERAL_ICON,7,7,20,20
END
#endif //OLD_STUFF


//#define IDC_CERT_GENERAL_LABEL_TRUSTEDDATA 2225
/*
#define IDC_CERT_GENERAL_FRAME_STATUS       2208
#define IDC_CERT_GENERAL_ICON               2209
#define IDC_CERT_GENERAL_FRAME_ISSUED       2210
#define IDC_CERT_GENERAL_LABEL_CERTFOR      2211
#define IDC_CERT_GENERAL_LABEL_SERIALNUM    2212
#define IDC_CERT_GENERAL_LABEL_VALIDFROM    2213
#define IDC_CERT_GENERAL_LABEL_CERTFORDATA  2214
#define IDC_CERT_GENERAL_LABEL_SERIALNUMDATA 2215
#define IDC_CERT_GENERAL_LABEL_VALIDFROMDATA 2216
#define IDC_CERT_GENERAL_BUTTON_OPEN        2217
#define IDC_CERT_GENERAL_LABEL_ISSUER       2218
#define IDC_CERT_GENERAL_STATIC_STATUS      2219
#define IDC_CERT_GENERAL_LABEL_EXPIRED      2220
#define IDC_CERT_GENERAL_LABEL_REVOKED      2221
#define IDC_CERT_GENERAL_LABEL_EXPIREDDATA  2222
#define IDC_CERT_GENERAL_ICON_CHECK         2223
#define IDC_CERT_GENERAL_LABEL_REVOKEDDATA  2227
#define IDC_CERT_GENERAL_LABEL_TRUST        2228
#define IDC_CERT_GENERAL_COMBO_TRUST        2229
#define IDC_CERT_GENERAL_ICON_UNCHECK       2230

#define IDC_CERT_TRUST_FRAME_CHAIN      2231
#define IDC_CERT_TRUST_TREE_CHAIN       2232
#define IDC_CERT_TRUST_LABEL_EXPLAIN    2233

#define IDC_CERT_ADVANCED_LABEL_EXPLAIN 2234
#define IDC_CERT_ADVANCED_LIST_FIELD    2235
#define IDC_CERT_ADVANCED_EDIT_DETAILS  2236
#define IDC_CERT_ADVANCED_LABEL_FIELD   2237
#define IDC_CERT_ADVANCED_LABEL_DETAILS 2238
*/
//#define IDD_DIALOG_CERT_GENERAL         120
//#define IDD_DIALOG_CERT_TRUST           121
//#define IDD_DIALOG_CERT_ADVANCED        122


#endif // CERT_PROPS

// LDAP_PROPS
#ifdef OLD_STUFF
IDD_DIALOG_LDAP_ADD DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "Add, remove, and modify Internet directory services here. You will be able to search these directory services and check names against them.",
                    IDC_LDAP_ADD_STATIC_CAPTION,7,7,198,24
#ifndef WIN16
    CONTROL         "",IDC_LDAP_ADD_STATIC_ETCHED2,"Static",SS_ETCHEDHORZ,7,
                    36,198,1
#endif // !WIN16
    GROUPBOX        "Directory services:",IDC_LDAP_ADD_STATIC_LABELLIST1,7,
                    43,198,138
    PUSHBUTTON      "&Add",IDC_LDAP_ADD_BUTTON_ADD,16,61,48,14
    PUSHBUTTON      "Remo&ve",IDC_LDAP_ADD_BUTTON_DELETE,16,80,48,14
    PUSHBUTTON      "P&roperties",IDC_LDAP_ADD_BUTTON_PROPERTIES,16,99,48,14
#ifndef WIN16
    CONTROL         "List1",IDC_LDAP_ADD_LIST_ALL,"SysListView32",LVS_LIST |
                    LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,72,60,125,108,
                    WS_EX_CLIENTEDGE
#else
    CONTROL         "List1",IDC_LDAP_ADD_LIST_ALL,"IE_SysListView",LVS_LIST |
                    LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,72,60,125,108
#endif // !WIN16
END


IDD_DIALOG_LDAP_PROPERTIES DIALOG DISCARDABLE  0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg"
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "&Friendly Name:",IDC_LDAP_PROPS_STATIC_NAME_FRIENDLY,7,
                    29,60,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY,80,27,125,14,
                    ES_AUTOHSCROLL
    LTEXT           "&Directory Server:",IDC_LDAP_PROPS_STATIC_NAME,7,46,65,
                    8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_NAME,80,43,125,14,ES_AUTOHSCROLL
    GROUPBOX        "&Authentication Type:",IDC_LDAP_PROPS_FRAME,7,64,198,
                    100,WS_GROUP
    CONTROL         "A&nonymous",IDC_LDAP_PROPS_RADIO_ANON,"Button",
                    BS_AUTORADIOBUTTON | WS_TABSTOP,17,77,125,10
    CONTROL         "&Secure Password (requires server support)",
                    IDC_LDAP_PROPS_RADIO_SICILY,"Button",BS_AUTORADIOBUTTON,
                    17,88,181,10
    CONTROL         "Pass&word",IDC_LDAP_PROPS_RADIO_USERPASS,"Button",
                    BS_AUTORADIOBUTTON,17,99,125,10
    LTEXT           "&User Name:",IDC_LDAP_PROPS_STATIC_USERNAME,17,116,40,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_USERNAME,80,112,118,14,
                    ES_AUTOHSCROLL
    LTEXT           "&Password:",IDC_LDAP_PROPS_STATIC_PASSWORD,17,131,40,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_PASSWORD,80,128,118,14,ES_PASSWORD |
                    ES_AUTOHSCROLL
    LTEXT           "&Confirm Password:",IDC_LDAP_PROPS_STATIC_PASSWORD2,17,
                    146,62,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD,80,144,118,14,
                    ES_PASSWORD | ES_AUTOHSCROLL
    CONTROL         "Chec&k names against this server when sending mail.",
                    IDC_LDAP_PROPS_CHECK_NAMES,"Button",BS_AUTOCHECKBOX |
                    WS_TABSTOP,7,171,181,10
    LTEXT           "Add or modify information about an LDAP directory service.",
                    IDC_LDAP_PROPS_STATIC_CAPTION,7,7,198,10
#ifndef WIN16
    CONTROL         "",IDC_LDAP_PROPS_STATIC_ETCHED2,"Static",SS_ETCHEDHORZ,
                    8,21,197,1
#endif // !WIN16
END

IDD_DIALOG_LDAP_PROPERTIES_ADVANCED DIALOG DISCARDABLE  0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg"
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    GROUPBOX        "Search Parameters:",IDC_LDAP_PROPS_FRAME2,7,7,198,71
    LTEXT           "&Search time-out (in seconds):",
                    IDC_LDAP_PROPS_STATIC_SEARCH,16,28,132,8
    EDITTEXT        IDC_LDAP_PROPS_EDIT_SEARCH,162,26,35,14,ES_AUTOHSCROLL |
                    ES_NUMBER
    LTEXT           "&Maximum number of entries to return:",
                    IDC_LDAP_PROPS_STATIC_NUMRESULTS,15,53,137,9
    EDITTEXT        IDC_LDAP_PROPS_EDIT_NUMRESULTS,162,50,35,14,
                    ES_AUTOHSCROLL | ES_NUMBER
    GROUPBOX        "Search &Base for this directory service",
                    IDC_LDAP_PROPS_FRAME_ROOT,7,88,198,43
    EDITTEXT        IDC_LDAP_PROPS_EDIT_ROOT,15,106,182,14,ES_AUTOHSCROLL
END

#define IDC_LDAP_SEARCH_BUTTON_REMOVE   6470
#define IDC_LDAP_SEARCH_LIST_SELECTED   6471
#define IDC_LDAP_SEARCH_BUTTON_UP       6472
#define IDC_LDAP_SEARCH_BUTTON_DOWN     6473
#define IDC_LDAP_SEARCH_STATIC_COUNTRY  6474
#define IDC_LDAP_SEARCH_COMBO_COUNTRY   6475
#define IDC_LDAP_SEARCH_STATIC_ETCHED2  6476
#define IDC_LDAP_SEARCH_STATIC_LABELLIST2 6477
#define IDC_LDAP_SEARCH_FRAME           6478
#define IDC_LDAP_SEARCH_STATIC_CAPTION  6479
#define IDC_LDAP_SEARCH_STATIC_LABELLIST1 6480
#define IDC_LDAP_SEARCH_LIST_DS         6481
#define IDC_LDAP_SEARCH_BUTTON_SELECT   6482

#define IDC_LDAP_ADD_BUTTON_ADD         5579
#define IDC_LDAP_ADD_BUTTON_DELETE      5580
#define IDC_LDAP_ADD_STATIC_CAPTION     5581
#define IDC_LDAP_ADD_BUTTON_PROPERTIES  5582
#define IDC_LDAP_ADD_STATIC_LABELLIST1  5583
#define IDC_LDAP_ADD_STATIC_ETCHED2     5584
#define IDC_LDAP_ADD_LIST_ALL           5585

#define IDC_LDAP_PROPS_STATIC_PASSWORD  5586
#define IDC_LDAP_PROPS_EDIT_CONNECTION  5587
#define IDC_LDAP_PROPS_EDIT_SEARCH      5588
#define IDC_LDAP_PROPS_EDIT_NAME        5589
#define IDC_LDAP_PROPS_EDIT_NUMRESULTS  5590
#define IDC_LDAP_PROPS_FRAME            5591
#define IDC_LDAP_PROPS_FRAME2           5592
#define IDC_LDAP_PROPS_STATIC_CONNECTION 5593
#define IDC_LDAP_PROPS_STATIC_SEARCH    5594
#define IDC_LDAP_PROPS_STATIC_NUMRESULTS 5595
#define IDC_LDAP_PROPS_EDIT_USERNAME    5596
#define IDC_LDAP_PROPS_EDIT_PASSWORD    5597
#define IDC_LDAP_PROPS_STATIC_NAME      5598
#define IDC_LDAP_PROPS_RADIO_ANON       5599
#define IDC_LDAP_PROPS_RADIO_SICILY     5600
#define IDC_LDAP_PROPS_RADIO_USERPASS   5601
#define IDC_LDAP_PROPS_STATIC_USERNAME  5602
#define IDC_LDAP_PROPS_FRAME_NUMRESULTS 5603
#define IDC_LDAP_PROPS_STATIC_PASSWORD2 5604
#define IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD 5605
#define IDC_LDAP_PROPS_CHECK_NAMES      5606
#define IDC_LDAP_PROPS_EDIT_ROOT        5608
#define IDD_DIALOG_LDAP_PROPERTIES_ADVANCED 5609
#define IDC_LDAP_PROPS_STATIC_NAME_FRIENDLY 5610
#define IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY 5611
#define IDC_LDAP_PROPS_FRAME_ROOT       5612
#define IDC_LDAP_PROPS_RADIO_DEFAULTBASE 5613
#define IDC_LDAP_PROPS_RADIO_OTHERBASE  5614

#define IDD_DIALOG_LDAP_PROPERTIES      5540
#define IDD_DIALOG_LDAP_SEARCH          5541
#define IDD_DIALOG_LDAP_ADD             5542

#define IDC_LDAP_PROPS_STATIC_CAPTION   65
#define IDC_LDAP_PROPS_STATIC_ETCHED2   66

IDD_DIALOG_LDAP_SEARCH DIALOGEX 0, 0, 212, 188
STYLE DS_MODALFRAME | WS_POPUP
#ifndef WIN16
FONT 8, "MS Shell Dlg", 0, 0, 0x1
#else
FONT 8, "MS Sans Serif"
#endif // !WIN16
BEGIN
    LTEXT           "If you have chosen to check names against one or more directory services, the directory services will be accessed in the order shown in the list below. Use the up and down buttons to change this order.",
                    IDC_LDAP_SEARCH_STATIC_CAPTION,16,21,181,35
    GROUPBOX        "&Change check names order:",IDC_LDAP_SEARCH_FRAME,7,6,
                    198,162
#ifndef WIN16
    CONTROL         "List1",IDC_LDAP_SEARCH_LIST_SELECTED,"SysListView32",
                    LVS_REPORT | LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,16,69,124,77,
                    WS_EX_CLIENTEDGE
#else
    CONTROL         "List1",IDC_LDAP_SEARCH_LIST_SELECTED,"IE_SysListView",
                    LVS_REPORT | LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER |
                    LVS_NOSORTHEADER | WS_TABSTOP,16,69,124,77
#endif // !WIN16
    PUSHBUTTON      "&Up",IDC_LDAP_SEARCH_BUTTON_UP,148,115,49,14
    PUSHBUTTON      "&Down",IDC_LDAP_SEARCH_BUTTON_DOWN,148,132,49,14
END

#endif // OLD_STUFF


// LDAP_PROPERTIES
#ifdef OLD_LDAP_UI

extern HINSTANCE ghCommCtrlDLLInst;
extern LPPROPERTYSHEET        gpfnPropertySheet;


enum _Propsheets
{
    propMain=0,
    propOptions,
    propMAX
};

enum _ReturnValues
{
    DS_CANCEL=0,
    DS_OK,
    DS_ERROR
};


// Whenever we add a new server, we put it in a linked list so we'll be able to
// regress if the user hits cancel after adding a couple of entries
typedef struct _NewServer
{
    TCHAR szName[MAX_UI_STR];
    struct _NewServer * lpNext;
} NEW_SERVER, *LPNEW_SERVER;



// Params passed to the property sheets
typedef struct _DSUILV
{
    HWND hWndMainLV;
    HWND hWndResolveOrderLV;
    int nRetVal;
    LPNEW_SERVER lpNewServerList; // if servers added and we hit cancel, we use this list to remove newly added servers
    LPNEW_SERVER lpOldServerList; // if servers modified and we hit ok, we use this list to remove old servers
} DSUILV, * LPDSUILV;


#define hlvM (lpdsuiLV->hWndMainLV)
#define hlvR (lpdsuiLV->hWndResolveOrderLV)



/*
* Prototypes
*/
HRESULT HrInitLDAPListView(HWND hWndLV);

void LDAPListAddItem(HWND hWndLV, LPTSTR lpszItemText);

BOOL ReadLDAPServers(HWND hWndLV, LPTSTR szValueName);

void DeleteLDAPServers(HWND hDlg);

void ProcessOKMessage(HWND hDlg, LPDSUILV lpdsuiLV, int nPropSheet);

void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp);

BOOL SetDSUI(HWND hDlg,int nPropSheet, LPDSUILV lpdsuiLV);

BOOL FillDSUI(HWND hDlg,int nPropSheet, LPDSUILV lpdsuiLV);

int CreateDSPropSheets(HWND hwndOwner, LPDSUILV lpdsuiLV);

BOOL APIENTRY_16 fnDSMainProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);

BOOL APIENTRY_16 fnDSOptionsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);

void SetUpDownButtons(HWND hDlg, HWND hWndLV);

BOOL SynchronizeLVContentsForward(HWND hDlg, LPDSUILV lpdsuiLV);

BOOL SynchronizeLVContentsBackward(HWND hDlg, LPDSUILV lpdsuiLV);

void ShowDSProps(HWND hDlg, BOOL bAddNew, LPDSUILV lpdsuiLV);

BOOL ReadLDAPServerKey(HWND hWndLV, LPTSTR szValueName);

void WriteLDAPServerKey(HWND hWndLV, LPTSTR szValueName);


// Help IDs
static DWORD rgDsMainHelpIDs[] =
{
    IDC_LDAP_ADD_STATIC_LABELLIST1, IDH_WABLDAP_DIR_SER_LIST,
    IDC_LDAP_ADD_LIST_ALL,          IDH_WABLDAP_DIR_SER_LIST,
    IDC_LDAP_ADD_BUTTON_ADD,        IDH_WABLDAP_GEN_ADD,
    IDC_LDAP_ADD_BUTTON_DELETE,     IDH_WABLDAP_GEN_REMOVE,
    IDC_LDAP_ADD_BUTTON_PROPERTIES, IDH_WABLDAP_GEN_PROPERTIES,
    0,0
};

static DWORD rgDsOptHelpIDs[] =
{
    IDC_LDAP_SEARCH_STATIC_LABELLIST2,  IDH_WABLDAP_OPT_DIRSERV_CHECK_AGAINST,
    IDC_LDAP_SEARCH_LIST_SELECTED,      IDH_WABLDAP_OPT_DIRSERV_CHECK_AGAINST,
    IDC_LDAP_SEARCH_BUTTON_UP,          IDH_WABLDAP_OPT_UP,
    IDC_LDAP_SEARCH_BUTTON_DOWN,        IDH_WABLDAP_OPT_DOWN,
    0,0
};

//$$///////////////////////////////////////////////////////////////////////////////
//
// HrShowDirectoryServiceModificationDlg - Shows the main dialog with the list
// of directory services and with a prop sheet for changing check order
//
//  hWndParent - Parent for this dialog
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent)
{
    ACCTLISTINFO ali;
    HRESULT hr = hrSuccess;
#ifdef OLD_LDAP_UI
    DSUILV dsuiLV = {0};
#endif // OLD_LDAP_UI
    IImnAccountManager * lpAccountManager;

#ifdef OLD_LDAP_UI
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }
#endif // OLD_LDAP_UI

    // Make sure there is an account manager
    if (hr = InitAccountManager(&lpAccountManager)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = (ACCTTYPE)-1;
    ali.dwAcctFlags = ACCT_FLAG_DIR_SERV;
    ali.dwFlags = 0;
    hr = lpAccountManager->lpVtbl->AccountListDialog(lpAccountManager,
      hWndParent,
      &ali);

#ifdef OLD_LDAP_UI
    dsuiLV.nRetVal = DS_ERROR;
    dsuiLV.lpNewServerList = NULL;
    dsuiLV.lpOldServerList = NULL;

    // show dialog
    if(-1 == CreateDSPropSheets(hWndParent,&dsuiLV))
    {
        DebugPrintError(("Directory Service dialog failed\n"));
        hr = E_FAIL;
        goto out;
    }

    // Free any allocated memory
    while(dsuiLV.lpNewServerList)
    {
        LPNEW_SERVER lpTemp = dsuiLV.lpNewServerList;
        dsuiLV.lpNewServerList = lpTemp->lpNext;
        if(dsuiLV.nRetVal == DS_CANCEL)
            SetLDAPServerParams(lpTemp->szName, NULL);
        LocalFree(lpTemp);
    }

    // Free any allocated memory
    while(dsuiLV.lpOldServerList)
    {
        LPNEW_SERVER lpTemp = dsuiLV.lpOldServerList;
        dsuiLV.lpOldServerList = lpTemp->lpNext;
        if(dsuiLV.nRetVal == DS_OK)
            SetLDAPServerParams(lpTemp->szName, NULL);
        LocalFree(lpTemp);
    }


    switch(dsuiLV.nRetVal)
    {
    case DS_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case DS_OK:
        hr = S_OK;
        break;
    case DS_ERROR:
        hr = E_FAIL;
        break;
    }
#endif // OLD_LDAP_UI

out:
    return hr;
}

#ifdef OLD_LDAP_UI

#define m_lpDSUILV              ((LPDSUILV) pps->lParam)
#define m_hWndMainLV            (m_lpDSUILV->hWndMainLV)
#define m_hWndResolveOrderLV    (m_lpDSUILV->hWndResolveOrderLV)
#define m_nRetVal               (m_lpDSUILV->nRetVal)

/*//$$***********************************************************************
*    FUNCTION: fnDSMainProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSMainProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        // Save the lparam for later use
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        // Setup the UI
        SetDSUI(hDlg,propMain,m_lpDSUILV);

        // Fill in the UI
        FillDSUI(hDlg,propMain,m_lpDSUILV);
        return TRUE;

    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsMainHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsMainHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_LDAP_ADD_BUTTON_DELETE:
            DeleteLDAPServers(hDlg);
            break;

        case IDC_LDAP_ADD_BUTTON_ADD:
            ShowDSProps(hDlg, TRUE, m_lpDSUILV);
            break;

        case IDC_LDAP_ADD_BUTTON_PROPERTIES:
            ShowDSProps(hDlg, FALSE, m_lpDSUILV);
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            SynchronizeLVContentsBackward(hDlg, m_lpDSUILV);
            break;

        case PSN_APPLY:         //ok
            ProcessOKMessage(hDlg,m_lpDSUILV,propMain);
            m_nRetVal = DS_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            m_nRetVal = DS_CANCEL;
            break;
        }

		switch((int) wParam)
		{
		case IDC_LDAP_ADD_LIST_ALL:
            switch(((NM_LISTVIEW *)lParam)->hdr.code)
	        {
	        case LVN_KEYDOWN:
                switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                {
                case VK_DELETE:
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_LDAP_ADD_BUTTON_DELETE, 0);
                    return 0;
                    break;
                }
                break;

            case NM_DBLCLK:
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_LDAP_ADD_BUTTON_PROPERTIES, 0);
                return 0;
                break;
            }
			break;
		}

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnDSOptionsProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSOptionsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    int CtlID = 0; //used to determine which required field in the UI has not been set

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        SetDSUI(hDlg,propOptions,m_lpDSUILV);
        FillDSUI(hDlg,propOptions,m_lpDSUILV);
        return TRUE;

    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsOptHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsOptHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_LDAP_SEARCH_BUTTON_UP:
            MoveLDAPItemUpDown(hDlg, TRUE);
            break;

        case IDC_LDAP_SEARCH_BUTTON_DOWN:
            MoveLDAPItemUpDown(hDlg, FALSE);
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            SynchronizeLVContentsForward(hDlg, m_lpDSUILV);
            break;

        case PSN_APPLY:         //ok
            ProcessOKMessage(hDlg,m_lpDSUILV,propOptions);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
//            lpLSP->nRetVal = DL_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}



/*//$$***************************************************************************
*    FUNCTION: CreateDSPropSheets(HWND)
*
*    PURPOSE:  Creates the DL property sheet
*
****************************************************************************/
int CreateDSPropSheets( HWND hwndOwner, LPDSUILV lpdsuiLV )
{
    PROPSHEETPAGE psp[propMAX];
    PROPSHEETHEADER psh;
    TCHAR szBuf[propMAX][MAX_UI_STR];
    TCHAR szBuf2[MAX_UI_STR];

    psp[propMain].dwSize = sizeof(PROPSHEETPAGE);
    psp[propMain].dwFlags = PSP_USETITLE;
    psp[propMain].hInstance = hinstMapiX;
    psp[propMain].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_ADD);
    psp[propMain].pszIcon = NULL;
    psp[propMain].pfnDlgProc = (DLGPROC) fnDSMainProc;
    LoadString(hinstMapiX, idsGeneral, szBuf[propMain], sizeof(szBuf[propMain]));
    psp[propMain].pszTitle = szBuf[propMain];
    psp[propMain].lParam = (LPARAM) lpdsuiLV;

    psp[propOptions].dwSize = sizeof(PROPSHEETPAGE);
    psp[propOptions].dwFlags = PSP_USETITLE;
    psp[propOptions].hInstance = hinstMapiX;
    psp[propOptions].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_SEARCH);
    psp[propOptions].pszIcon = NULL;
    psp[propOptions].pfnDlgProc = (DLGPROC) fnDSOptionsProc;
    LoadString(hinstMapiX, idsOptions, szBuf[propOptions], sizeof(szBuf[propMain]));
    psp[propOptions].pszTitle = szBuf[propOptions];
    psp[propOptions].lParam = (LPARAM) lpdsuiLV;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, idsDirectoryServices, szBuf2, sizeof(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = propMain;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (gpfnPropertySheet(&psh));
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// SetDSUI - Sets the prop sheet UI
//
//  hDlg        - Parent HWND
//  nPropSheet  - Identifies the prop sheet being set
//  lpdsuiLV    - Dialog param info
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetDSUI(HWND hDlg,int nPropSheet,LPDSUILV lpdsuiLV)
{
    ULONG i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    switch(nPropSheet)
    {
    case propMain:
        lpdsuiLV->hWndMainLV = GetDlgItem(hDlg, IDC_LDAP_ADD_LIST_ALL);
        // Initialize the list view that displays the list of LDAP servers
        HrInitLDAPListView(lpdsuiLV->hWndMainLV);
        break;
    case propOptions:
        lpdsuiLV->hWndResolveOrderLV = GetDlgItem(hDlg, IDC_LDAP_SEARCH_LIST_SELECTED);
        // Initialize the list view that displays the list of LDAP servers
        HrInitLDAPListView(lpdsuiLV->hWndResolveOrderLV);
        break;
    }

    return TRUE;
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// FillDSUI - Fills in the UI fields with the given data
//
//  hDlg        - HWND of parent
//  nPropSheet  - identifies prop sheet being modified
//  lpdsuiLV    - lParam from dialog
//
/////////////////////////////////////////////////////////////////////////////////
BOOL FillDSUI(HWND hDlg,int nPropSheet,LPDSUILV lpdsuiLV)
{
    HWND hWndLV = NULL;

    switch(nPropSheet)
    {
    case propMain:
        hWndLV = GetDlgItem(hDlg, IDC_LDAP_ADD_LIST_ALL);

        // Read all the registered LDAP servers from the registry into
        // this list view
        ReadLDAPServerKey(hWndLV, szAllLDAPServersValueName);

        if(ListView_GetItemCount(hWndLV) <= 0)
        {
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),FALSE);
            EnableWindow(hWndLV,FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),TRUE);
            EnableWindow(hWndLV,TRUE);
        }

        SetFocus(GetNextDlgTabItem(hDlg, GetDlgItem(hDlg, IDC_LDAP_ADD_STATIC_CAPTION), FALSE));

        break;


    case propOptions:
        break;
    }

    return TRUE;
}
#endif

#ifdef OLD_LDAP_UI
//$$///////////////////////////////////////////////////////////////////////////////
//
// DeleteLDAPServers - Deletes LDAP server entries form the Directory Services list
//
//  hDlg - HWND of dialog
//
/////////////////////////////////////////////////////////////////////////////////
void DeleteLDAPServers(HWND hDlg)
{
    HWND hWndLV = GetDlgItem(hDlg,IDC_LDAP_ADD_LIST_ALL);
    TCHAR szBuf[MAX_UI_STR];

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    if(ListView_GetSelectedCount(hWndLV) > 0)
    {
        int iItemIndex = 0;

        if(IDYES == ShowMessageBox(hDlg, idsQuestionServerDeletion, MB_ICONEXCLAMATION  | MB_YESNO))
        {
            while(ListView_GetSelectedCount(hWndLV) > 0)
            {
                iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                szBuf[0]='\0';
                ListView_GetItemText(hWndLV,iItemIndex,0,szBuf,sizeof(szBuf));

                // Delete the registry key corerspnding to this entry
                if(lstrlen(szBuf))
                    SetLDAPServerParams(szBuf,NULL);

                // Delete the item from the list view
                ListView_DeleteItem(hWndLV, iItemIndex);
            }
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
        }

        if(ListView_GetItemCount(hWndLV) <= 0)
        {
            // no entries left
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),FALSE);
            EnableWindow(hWndLV,FALSE);
            SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
            SetFocus(GetDlgItem(GetParent(hDlg),IDOK));
        }
        else
        {
            // some entries left - select the one closest to the last deleted ...
            if(ListView_GetSelectedCount(hWndLV) <= 0)
            {
                if(iItemIndex >= ListView_GetItemCount(hWndLV))
                    iItemIndex--;
                LVSelectItem(hWndLV, iItemIndex);
            }
        }
    }
    else
        ShowMessageBox(hDlg, idsSelectServersToDelete, MB_ICONEXCLAMATION | MB_OK);

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return;
}








//$$///////////////////////////////////////////////////////////////////////////////
//
// ProcessOKMessage - Processes the OK button being clicked
//
/////////////////////////////////////////////////////////////////////////////////
void ProcessOKMessage(HWND hDlg, LPDSUILV lpdsuiLV, int nPropSheet)
{

    TCHAR szBuf[MAX_UI_STR];

    switch(nPropSheet)
    {
    case propMain:
        SynchronizeLVContentsBackward(hDlg, lpdsuiLV);
        WriteLDAPServerKey(hlvM, szAllLDAPServersValueName);
        break;

    case propOptions:
        break;
    }


    return;
}



//$$////////////////////////////////////////////////////////////////////
//
// MoveLDAPitemUpDown - moves a selected item up or down in the list
//
////////////////////////////////////////////////////////////////////////
void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_LDAP_SEARCH_LIST_SELECTED);
    int iItemIndex = ListView_GetSelectedCount(hWndLV);
    int iListCount = ListView_GetItemCount(hWndLV);

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    if( iItemIndex != 1)
    {
        ShowMessageBox(hDlg,idsSelectOneMoveUpDown,MB_ICONEXCLAMATION | MB_OK);
    }
    else
    {
        TCHAR szBufItem[MAX_UI_STR];
        TCHAR szBufOtherItem[MAX_UI_STR];
        int iMoveToIndex = 0;

        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

        // Can't move beyond the first or last item
        if( ((iItemIndex == 0) && bMoveUp) ||
            ((iItemIndex == (iListCount-1)) && !bMoveUp) )
            goto out;

        iMoveToIndex = (bMoveUp) ? (iItemIndex - 1):(iItemIndex+1);

        // Basically since these list view items have no parameters of interest
        // other than the text, we can swap the text (looks cleaner)

        // Get the selected item text
        ListView_GetItemText(hWndLV, iItemIndex, 0, szBufItem, sizeof(szBufItem));
        ListView_GetItemText(hWndLV, iMoveToIndex, 0, szBufOtherItem, sizeof(szBufOtherItem));

        ListView_SetItemText(hWndLV, iMoveToIndex, 0, szBufItem);
        ListView_SetItemText(hWndLV, iItemIndex, 0, szBufOtherItem);
        LVSelectItem(hWndLV, iMoveToIndex);

        SetUpDownButtons(hDlg, hWndLV);

    }

out:
    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// SetUpDownButtons - Enables/Disables up and down buttons
//
////////////////////////////////////////////////////////////////////////////////////////
void SetUpDownButtons(HWND hDlg, HWND hWndLV)
{

    int iItemCount = ListView_GetItemCount(hWndLV);
    int iSelectedItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
    HWND hWndUp = GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_UP);
    HWND hWndDown = GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_DOWN);

    DebugPrintTrace(("--SetUpDownButtons--\n"));


    if(iItemCount <= 0)
    {
        EnableWindow(hWndUp, FALSE);
        EnableWindow(hWndDown, FALSE);
        SetFocus(GetDlgItem(GetParent(hDlg),IDOK));
    }
    else
    {
        EnableWindow(hWndUp, TRUE);
        EnableWindow(hWndDown, TRUE);
    }

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// SynchronizeLVContentsForward - this funciton attempts to synhronize the
//          List view contents between the various ListViews when going from main pane
//          to Options pane
//
////////////////////////////////////////////////////////////////////////////////////
BOOL SynchronizeLVContentsForward(HWND hDlg, LPDSUILV lpdsuiLV)
{
    BOOL bRet = FALSE;

    int iItemIndex=0;


    // Basically we just want to enter all the entries with check names against them in
    // this list view

    SendMessage(hlvR, WM_SETREDRAW, (WPARAM) FALSE, 0);

    ListView_DeleteAllItems(hlvR);

    //
    // if there are no items in the original, wipe out and leave
    //
    if(ListView_GetItemCount(hlvM) <= 0)
    {
        EnableWindow(hlvR, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_UP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LDAP_SEARCH_BUTTON_DOWN), FALSE);
        bRet = TRUE;
        goto out;
    }
    else
    {
        // Look at all the items in the original one by one and if they have
        // the check names flag, enter them into hlvR
        int i,nIndex,nTotal;
        TCHAR szBuf[MAX_PATH];

        EnableWindow(hlvR, TRUE);
        for(i = 0; i < ListView_GetItemCount(hlvM); i++)
        {
            ListView_GetItemText(hlvM, i, 0, szBuf, sizeof(szBuf));
            if(lstrlen(szBuf))
            {
                LDAPSERVERPARAMS ldsp = {0};
                GetLDAPServerParams(szBuf, &(ldsp));

                if(ldsp.fResolve)
                {
                    // This is selected for resolving so we should add it to
                    // the selected items list
                    LDAPListAddItem(hlvR, szBuf);
                }

                FreeLDAPServerParams(ldsp);
            }
        }

    }


    LVSelectItem(hlvR, 0);

    SetUpDownButtons(hDlg, hlvR);

    bRet = TRUE;

out:

    SendMessage(hlvR, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return bRet;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  ShowDSProps(HWND hDlg, BOOL bAddNew);
//
//  Displays properties of a Directory Service or creates and adds a new one
//
////////////////////////////////////////////////////////////////////////////////////
void ShowDSProps(HWND hDlg, BOOL bAddNew, LPDSUILV lpdsuiLV)
{
    TCHAR szBuf[MAX_UI_STR];
    TCHAR szOldName[MAX_UI_STR];
    int iItemIndex;

    HWND hWndLV = GetDlgItem(hDlg,IDC_LDAP_ADD_LIST_ALL);

    if(bAddNew)
    {
        szBuf[0]='\0';
    }
    else
    {
        int iItemCount = ListView_GetSelectedCount(hWndLV);

        if (iItemCount > 1)
        {
            ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_ACTION, MB_ICONINFORMATION | MB_OK);
            goto out;
        }
        else if(iItemCount == 0)
        {
            ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONINFORMATION | MB_OK);
            goto out;
        }

        // by now we should only have 1 selection

        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        if(iItemIndex == -1)
            goto out;

        ListView_GetItemText(hWndLV, iItemIndex, 0, szBuf, sizeof(szBuf));

        if(!lstrlen(szBuf))
            goto out;

    }

    // Save the old name just in case we need it ... (eg. user modifies the name in the props)
    lstrcpy(szOldName,szBuf);

    if(!HR_FAILED(HrShowDSProps(hDlg,szBuf,bAddNew)))
    {
        if(bAddNew)
        {
            // Add this new string to the main list box
            if(lstrlen(szBuf))
                LDAPListAddItem(hWndLV, szBuf);

            // At this point of time, the new entry has been saved in the
            // registry. If the user now hits cancel, we want to remove
            // the newly entered entry from the registry so that it doesnt
            // show up later. To do this, we store a list of all newly added
            // names.
            {
                LPNEW_SERVER lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(NEW_SERVER));
                if(lpTemp)
                {
                    lpTemp->lpNext = lpdsuiLV->lpNewServerList;
                    lstrcpy(lpTemp->szName, szBuf);
                    lpdsuiLV->lpNewServerList = lpTemp;
                }
            }
        }
        else
        {
            if(lstrcmpi(szOldName, szBuf))
            {
                // update the old name in the list ...
                ListView_SetItemText(hWndLV, iItemIndex, 0, szBuf);

                // At this point of time, the old entry name has been modified and we
                // have two keys in the registry - the old one and the new one
                // If the user hits cancel we want to remove the new entries
                // If the user hits ok, we want to remove the old entries
                {
                    LPNEW_SERVER lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(NEW_SERVER));
                    if(lpTemp)
                    {
                        lpTemp->lpNext = lpdsuiLV->lpOldServerList;
                        lstrcpy(lpTemp->szName, szOldName);
                        lpdsuiLV->lpOldServerList = lpTemp;
                    }
                }
                //
                // Again, we also want the new name of the entry so that if the user
                // hits cancel, we can revert back to the old name.
                //
                {
                    LPNEW_SERVER lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(NEW_SERVER));
                    if(lpTemp)
                    {
                        lpTemp->lpNext = lpdsuiLV->lpNewServerList;
                        lstrcpy(lpTemp->szName, szBuf);
                        lpdsuiLV->lpNewServerList = lpTemp;
                    }
                }
            }
        }
    }

    if(ListView_GetItemCount(hWndLV) > 0)
    {
        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_DELETE),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_ADD_BUTTON_PROPERTIES),TRUE);
        EnableWindow(hWndLV,TRUE);
        SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
    }

out:
    return;

}
#endif
#ifdef OLD_LDAP_UI
//$$////////////////////////////////////////////////////////////////////////////////
//
// SynchronizeLVContentsBackward(LPDSUILV lpdsuiLV) - this funciton attempts to synhronize the
//          List view contents between the various ListViews when going from Options pane
//          to main pane - basically what we want to do is to preserve the order of the
//          resolveNames list views ... when modifications have been made in the resolvenames
//          list view, we change the order of the main list view to reflect that change
//
////////////////////////////////////////////////////////////////////////////////////
BOOL SynchronizeLVContentsBackward(HWND hDlg, LPDSUILV lpdsuiLV)
{
    BOOL bRet = FALSE;
    int i=0,iItemIndex=0;
    TCHAR szBuf[MAX_PATH];


    if(!hlvR)
    {
        // Didnt go to the options pane
        // Leave things as they are
        bRet = TRUE;
        goto out;
    }

    //
    // Easy way to do this ...
    // Delete all the entries in hlvM that occur in hlvR and then add hlvR items one by one
    //

    SendMessage(hlvM, WM_SETREDRAW, (WPARAM) FALSE, 0);

    for(i = 0; i < ListView_GetItemCount(hlvR); i++)
    {
        ListView_GetItemText(hlvR, i, 0, szBuf, sizeof(szBuf));
        if(lstrlen(szBuf))
        {
            LV_FINDINFO lvfi = {0};
            int iItemIndex;
            lvfi.flags = LVFI_STRING;
            lvfi.psz = szBuf;

            iItemIndex = ListView_FindItem(hlvM, -1, &lvfi);
            if(iItemIndex != -1)
            {
                ListView_DeleteItem(hlvM, iItemIndex);
            }
        }
    }

    for(i = 0; i < ListView_GetItemCount(hlvR); i++)
    {
        ListView_GetItemText(hlvR, i, 0, szBuf, sizeof(szBuf));
        if(lstrlen(szBuf))
        {
            LDAPListAddItem(hlvM, szBuf);
        }
    }

    LVSelectItem(hlvM, 0);

    bRet = TRUE;

out:

    SendMessage(hlvM, WM_SETREDRAW, (WPARAM) TRUE, 0);

    return(bRet);

}
#endif // OLD_LDAP_UI


//$$///////////////////////////////////////////////////////////////////////////////
//
// LDAPListAddItem - adds an item to the LDAP list view controls
//
//  hWndLV  - HWND of List View
//  lpszItemText - Name of item to add to list view
//
/////////////////////////////////////////////////////////////////////////////////
void LDAPListAddItem(HWND hWndLV, LPTSTR lpszItemText)
{
    LV_ITEM lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_IMAGE;
    lvi.pszText = lpszItemText;
    lvi.iImage = imageDirectoryServer;
        lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;

    ListView_InsertItem(hWndLV, &lvi);

    LVSelectItem(hWndLV, lvi.iItem);

    return;

}


/*************************************************************************
//$$
//  HrInitLDAPListView - Initializes the two list views on this dialog
//          so they look nice
//
//  hWndLV - handle of list view
//
**************************************************************************/
HRESULT HrInitLDAPListView(HWND hWndLV)
{
	HRESULT hr = hrSuccess;
    LV_COLUMN lvC;               // list view column structure
	HIMAGELIST hSmall=NULL;

	DWORD dwLVStyle;
	ULONG nCols=0;
	ULONG index=0;

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(dwLVStyle & LVS_EDITLABELS)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_EDITLABELS));

    hSmall = gpfnImageList_LoadImage(   hinstMapiX, 	
                                    MAKEINTRESOURCE(IDB_BITMAP_SMALL),
                                    S_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);

	ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column

	lvC.cx = 250; //<TBD> - change this hardcoding
	lvC.pszText = NULL;

    lvC.iSubItem = 0;

    if (ListView_InsertColumn (hWndLV, 0, &lvC) == -1)
	{
		DebugPrintError(("ListView_InsertColumn Failed\n"));
		hr = E_FAIL;
		goto out;
	}


out:	

	return hr;
}


#endif // OLD_LDAP_UI



#ifdef URL_CHAR_ESCAPING
// URLs are filled with escape characters, we need to replace these
// with regular characters ...
//
static const TCHAR szEsc1[]="%20";
static const TCHAR szEsc2[]="%3C";
static const TCHAR szEsc3[]="%3E";
static const TCHAR szEsc4[]="%23";
static const TCHAR szEsc5[]="%25";
static const TCHAR szEsc6[]="%7B";
static const TCHAR szEsc7[]="%7D";
static const TCHAR szEsc8[]="%7C";
static const TCHAR szEsc9[]="%74";
static const TCHAR szEsc10[]="%5E";
static const TCHAR szEsc11[]="%7E";
static const TCHAR szEsc12[]="%5B";
static const TCHAR szEsc13[]="%5D";
static const TCHAR szEsc14[]="%60";

#define MAX_ESC_CHAR 14

const TCHAR * szEsc[] =
{   szEsc1,     szEsc2,     szEsc3,
    szEsc4,     szEsc5,     szEsc6,
    szEsc7,     szEsc8,     szEsc9,
    szEsc10,    szEsc11,    szEsc12,
    szEsc13,    szEsc14  
};


const char cEscChar[] =
{
    ' ',        '<',        '>',
    '#',        '%',        '{',
    '}',        '|',        '\\',
    '^',        '~',        '[',
    ']',        '`'  
};


/*
-
-  ReplaceURLIllegalChars
-
*  Replaces illegal chars in a URL with escaped strings as per some RFC
*  Makes a copy of the input string and then copies it back onto the input string
*  Assumes that input string was big enough to handle all replacements
*/
void ReplaceURLIllegalChars(LPTSTR lpURL)
{
    LPTSTR lpTemp = NULL,lp=NULL, lp1=NULL;
    int i = 0;
    if(!lpURL)
        return;
    if(!(lpTemp = LocalAlloc(LMEM_ZEROINIT, 2*lstrlen(lpURL)+1)))
        return;
    lstrcpy(lpTemp, lpURL);
    lp = lpURL;
    lp1 = lpTemp;
    while(lp && *lp)
    {
        for(i=0;i<MAX_ESC_CHAR;i++)
        {
            if(*lp == cEscChar[i])
            {
                lstrcpy(lp1, szEsc[i]);
                lp1 += lstrlen(szEsc[i])-1;
                lstrcat(lp1, CharNext(lp));
                break;
            }
        }
        lp=CharNext(lp);
        lp1=CharNext(lp1);
    }
    lstrcpy(lpURL, lpTemp);
    LocalFreeAndNull(&lpTemp);
}


/***************************************************************************

    Name      : StrICmpN

    Purpose   : Compare strings, ignore case, stop at N characters

    Parameters: szString1 = first string
                szString2 = second string
                N = number of characters to compare
                bCmpI - compare insensitive if TRUE, sensitive if false

    Returns   : 0 if first N characters of strings are equivalent.

    Comment   :

***************************************************************************/
int StrICmpN(LPTSTR szString1, LPTSTR szString2, ULONG N, BOOL bCmpI) {
    int Result = 0;

    if (szString1 && szString2) {

        if(bCmpI)
        {
            szString1 = CharUpper(szString1);
            szString2 = CharUpper(szString2);
        }

        while (*szString1 && *szString2 && N)
        {
            N--;

            if (*szString1 != *szString2)
            {
                Result = 1;
                break;
            }

            szString1=CharNext(szString1);
            szString2=CharNext(szString2);
        }
    } else {
        Result = -1;    // arbitrarily non-equal result
    }

    return(Result);
}

/************
//Fragment---

    // Make a copy of our URL
    lpsz = LocalAlloc(LMEM_ZEROINIT, lstrlen(szLDAPUrl)+1);
    if(!lpsz)
        goto exit;

    lstrcpy(lpsz, szLDAPUrl);

    // Since this is most likely a URL on an HTML page, we need to translate its escape
    // characters to proper characters .. e.g. %20 becomes ' ' ..
    {
        lpszTmp = lpsz;
        while(*lpszTmp)
        {
            if(*lpszTmp == '%')
            {
                int i;
                for(i=0;i<MAX_ESC_CHAR;i++)
                {
                    if(!StrICmpN(lpszTmp, (LPTSTR) szEsc[i], lstrlen(szEsc[i]), FALSE))
                    {
                        *lpszTmp = cEscChar[i];
                        lstrcpy(lpszTmp+1, lpszTmp+3);
                        break;
                    }
                }
            }
            lpszTmp = CharNext(lpszTmp);
        }
    }

/*************/
#endif

#ifdef MIGRATELDAPACCTS
static const LPTSTR lpRegNewServer = TEXT("Software\\Microsoft\\WAB\\Server Properties");
static const LPTSTR lpNewServer = TEXT("NewServers");

//*******************************************************************
//
//  FUNCTION:   bNewServersAvailable
//
//  PURPOSE:    Checks if there are new servers to migrate
//
//  RETURNS:    BOOL
//
//  COMMENTS:   If new servers exist, resets the reg setting
//
//*******************************************************************
BOOL bNewServersAvailable()
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpRegNewServer, 0, KEY_ALL_ACCESS, &hKey))
    {
        TCHAR szVal[16];
        ULONG cbVal = 16;
        DWORD dwType = 0;
        if(ERROR_SUCCESS == RegQueryValueEx( hKey, lpNewServer, NULL, &dwType, (LPBYTE) szVal, &cbVal))
        {
            if(!lstrcmpi(szVal, "1"))
            {
                bRet = TRUE;
                // Reset the FLAG
                RegDeleteValue(hKey, lpNewServer);
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    return bRet;
}


        if(bNewServersAvailable())
        {
            // Migrate the settings from the old WAB installation
            MigrateOldLDAPAccounts(g_lpAccountManager, TRUE);
            // Migrate the settings from the new Setup
            // MigrateOldLDAPAccounts(g_lpAccountManager, FALSE);
        }




//*******************************************************************
//
//  FUNCTION:   MigrateOldLDAPServer
//
//  PURPOSE:    Read in old WAB 3.0 LDAP account information, write
//              it to the account manager and delete the old one.
//
//  PARAMETERS: lpAccountManager -> initialized account manager object.
//              hKeyServers = handle of old WAB/servers key
//              lpszServer = name of server to migrate
//
//  RETURNS:    none
//
//*******************************************************************
void MigrateOldLDAPServer(IImnAccountManager * lpAccountManager,
  HKEY hKeyServers, LPTSTR lpszServer) {
    LDAPSERVERPARAMS spParams = {0};
    DWORD dwErr, dwType, dwValue, dwSize;
    HKEY hKey = NULL;
    TCHAR szTemp[1];
    LPBYTE lpbPassword = NULL;


    // Set defaults for each value
    spParams.dwSearchSizeLimit = LDAP_SEARCH_SIZE_LIMIT;
    spParams.dwSearchTimeLimit = LDAP_SEARCH_TIME_LIMIT;
    spParams.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
    spParams.lpszUserName = NULL;
    spParams.lpszPassword = NULL;
    spParams.lpszURL = NULL;
    spParams.lpszBase = NULL;
    spParams.lpszName = NULL;
    spParams.lpszLogoPath = NULL;
    spParams.fResolve = FALSE;
    spParams.dwID = 0xFFFFFFFF;     // default to end
    spParams.dwPort = LDAP_DEFAULT_PORT;
    spParams.dwUseBindDN = 0;
    spParams.fSimpleSearch = FALSE;

    // Open the key for this LDAP server
    if (dwErr = RegOpenKeyEx(hKeyServers,
      lpszServer,
      0,
      KEY_READ,
      &hKey)) {
        DebugTrace("Migrate couldn't open server key %s -> %u\n", lpszServer, dwErr);
        return;
    }

    // Read server ID
    dwErr = RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPServerID,
      &dwValue);
    if ((! dwErr) && dwValue) {
        spParams.dwID = dwValue;
    } else {
        spParams.dwID = GetLDAPNextServerID(0);
    }

    // Read server search size limit
    dwErr = RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPSearchSizeLimit,
      &dwValue);
    if ((! dwErr) && dwValue) {
        spParams.dwSearchSizeLimit = dwValue;
    }

    // Read server search time limit
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPSearchTimeLimit,
      &dwValue)) {
        spParams.dwSearchTimeLimit = dwValue;
    }

    // Read the authentication type
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPAuthMethod,
      &dwValue)) {
        spParams.dwAuthMethod = dwValue;
    }

    // Read username and password if auth type is LDAP_AUTH_METHOD_SIMPLE
    if (LDAP_AUTH_METHOD_SIMPLE == spParams.dwAuthMethod) {
        // Read the user name
// BUGBUG: Should make a function out of this section for improved code size and readability!

        dwSize = 1;         // Expect ERROR_MORE_DATA
        if (RegQueryValueEx(hKey,
          (LPTSTR)szLDAPAuthUserName,
          NULL,
          &dwType,
          szTemp,
          &dwSize) == ERROR_MORE_DATA) {
            // Allocate space for the string
            if (spParams.lpszUserName = (LPTSTR)LocalAlloc(LPTR, dwSize + 1)) {
                // Try again with sufficient buffer
                RegQueryValueEx(hKey,
                  (LPTSTR)szLDAPAuthUserName,
                  NULL,
                  &dwType,
                  spParams.lpszUserName,
                  &dwSize);
            }
        }
// BUGBUG: END

        // Read the password
        dwSize = 1;         // Expect ERROR_MORE_DATA
        if (RegQueryValueEx(hKey,
          (LPTSTR)szLDAPAuthPassword,
          NULL,
          &dwType,
          szTemp,
          &dwSize) == ERROR_MORE_DATA) {
            // Allocate space for the string
            if (lpbPassword = (LPBYTE)LocalAlloc(LPTR, dwSize + 1)) {
                // Try again with sufficient buffer
                if (! (dwErr = RegQueryValueEx(hKey,
                  (LPTSTR)szLDAPAuthPassword,
                  NULL,
                  &dwType,
                  lpbPassword,
                  &dwSize))) {
                    // Decrypt the password
                    EncryptDecryptText(lpbPassword, dwSize);
                    lpbPassword[dwSize] = '\0';
                    spParams.lpszPassword = (LPTSTR)lpbPassword;
                }
            }
        }

        // If user name is missing, use anonymous authentication.
        if (NULL == spParams.lpszUserName) {
            spParams.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
        }
    }

    // Read Resolve flag
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPResolveFlag,
      &dwValue)) {
        spParams.fResolve = (BOOL)dwValue;
    }

    // Read the Search Base
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPSearchBase,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszBase = (LPTSTR)LocalAlloc(LPTR, dwSize + 1)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPSearchBase,
              NULL,
              &dwType,
              spParams.lpszBase,
              &dwSize);
        }
    }

    // Read the Server Name
    dwSize = 1;           // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPServerName,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszName = (LPTSTR)LocalAlloc(LPTR, dwSize + 1)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPServerName,
              NULL,
              &dwType,
              spParams.lpszName,
              &dwSize);
        }
    } else {
        // use the given friendly name as the server name (this is for compatibility with when
        // we didnt have friendly names ...
        if (spParams.lpszName = (LPTSTR)LocalAlloc(LPTR, lstrlen(lpszServer) + 1)) {
            lstrcpy(spParams.lpszName, lpszServer);
        }
    }


    // Read the Server Info URL
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPServerInfoURL,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszURL = (LPTSTR)LocalAlloc(LPTR, dwSize)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPServerInfoURL,
              NULL,
              &dwType,
              spParams.lpszURL,
              &dwSize);
        }
    }


     
    // Read the Advanced Search Attributes
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPAdvancedSearchAttr,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszAdvancedSearchAttr = (LPTSTR)LocalAlloc(LPTR, dwSize)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPAdvancedSearchAttr,
              NULL,
              &dwType,
              spParams.lpszAdvancedSearchAttr,
              &dwSize);
        }
    }

    

// Read the Server logo path
    dwSize = 1;         // Expect ERROR_MORE_DATA
    if (RegQueryValueEx(hKey,
      (LPTSTR)szLDAPServerLogoPath,
      NULL,
      &dwType,
      szTemp,
      &dwSize) == ERROR_MORE_DATA) {
        // Allocate space for the string
        if (spParams.lpszLogoPath = (LPTSTR)LocalAlloc(LPTR, dwSize)) {
            // Try again with sufficient buffer
            RegQueryValueEx(hKey,
              (LPTSTR)szLDAPServerLogoPath,
              NULL,
              &dwType,
              spParams.lpszLogoPath,
              &dwSize);
        }
    }

    // Read the LDAP port
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPPort,
      &dwValue)) {
        spParams.dwPort = dwValue;
    }


    // Read the use Bind DN setting
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPUseBindDN,
      &dwValue)) {
        spParams.dwUseBindDN = dwValue;
    }


    // Read the Simple Search setting
    if (! RegQueryValueExDWORD(hKey,
      (LPTSTR)szLDAPSimpleSearch,
      &dwValue)) {
        spParams.fSimpleSearch = (dwValue ? TRUE : FALSE);
    }


    RegCloseKey(hKey);


    // Write it to the account manager
    SetLDAPServerParams(
      lpszServer,
      &spParams);


    // Delete the key
    // BUGBUG: Won't work if key has sub-keys! (It shouldn't)

    // IE4 - dont delete this setting as it is in HKLM
    // RegDeleteKey(hKeyServers, lpszServer);
}


//*******************************************************************
//
//  FUNCTION:   MigrateOldLDAPAccounts
//
//  PURPOSE:    Read in old WAB 3.0 LDAP account information, write
//              it to the account manager and delete it from the
//              registry.
//
//  PARAMETERS: lpAccountManager -> initialized account manager object.
//              bMigrateOldWAB   -> if TRUE migrates old wab settings from
//                              a v1 installation. if FALSE, migrates new
//                              accounts from HKLM setup during setup
//  RETURNS:    none
//
//*******************************************************************
void MigrateOldLDAPAccounts(IImnAccountManager * lpAccountManager,
                            BOOL bMigrateOldWAB)
{
    BOOL      bRet = FALSE;
    HKEY      hKeyWAB = NULL;
    HKEY      hKeyServers = NULL;
    DWORD     dwErr;
    DWORD     dwType;
    DWORD     dwSize;
    TCHAR     szBuffer[512];
    ULONG     cbBuffer;
    DWORD     dwValue = 0;
    ULONG     ulSize;
    TCHAR     szTemp[1];
    LPBYTE    lpbPassword;
    DWORD     cMigrated = 0;
    LPTSTR    szLDAPServers = NULL;
    HRESULT   hResult = hrSuccess;
    DWORD     dwIndex = 0;

    // How many rows to migrate?
    if (! (dwErr = RegOpenKeyEx((bMigrateOldWAB ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE),
      szWABKey,
      0,
      KEY_ALL_ACCESS,
      &hKeyWAB))) {

        if (! RegOpenKeyEx(hKeyWAB,
          szLDAPServerPropsKey,
          0,
          KEY_ALL_ACCESS,
          &hKeyServers)) {
            // There is a Servers key

            // First, read in any servers which are "ordered"
            ulSize = 1;         // Expect ERROR_MORE_DATA
            if (dwErr = RegQueryValueEx(hKeyWAB,
              (LPTSTR)szAllLDAPServersValueName,
              NULL,
              &dwType,
              szTemp,
              &ulSize)) {
                if (dwErr == ERROR_MORE_DATA) {
                    if (szLDAPServers = LocalAlloc(LPTR, ulSize)) {
                        szLDAPServers[0] = '\0';    // init to empty string

                        // Try again with sufficient buffer
                        if (! RegQueryValueEx(hKeyWAB,
                          szAllLDAPServersValueName,
                          NULL,
                          &dwType,
                          szLDAPServers,
                          &ulSize)) {
                            DebugTrace("Found LDAP server registry key\n");

#ifdef OLD_STUFF
                                switch (dwType) {
                                case REG_BINARY:
                                // Some thing (probably setup) has given us binary data.
                                case REG_MULTI_SZ:
                                    break;

                                default:
                                    // Ignore it
                                    DebugTrace("Bad value of %s in registry\n", szAllLDAPServersValueName);
                                    Assert(FALSE);
                                    break;
                            }
#endif // OLD_STUFF
                        }

                        while (szLDAPServers && *szLDAPServers) {
                            MigrateOldLDAPServer(lpAccountManager, hKeyServers, szLDAPServers);
                            cMigrated++;

                            // move to next server in double null terminated string.
                            szLDAPServers += (lstrlen(szLDAPServers) + 1);
                        }

                        LocalFreeAndNull(&szLDAPServers);

                        // Get rid of the ordered servers key
                        // BUG - Dont delete v1 info
                        // RegDeleteValue(hKeyWAB, szAllLDAPServersValueName);
                    }
                }
                dwErr = 0;
            }

            dwIndex = 0;

            // Then read in any extra servers
            while (dwErr == 0) {
                cbBuffer = sizeof(szBuffer);
                if (dwErr = RegEnumKeyEx(hKeyServers,
                  dwIndex,
                  szBuffer,     // put server name here
                  &cbBuffer,
                  NULL,
                  NULL,
                  0,
                  NULL)) {
                    break;      // done
                }

                // Got a name, migrate it
                MigrateOldLDAPServer(lpAccountManager, hKeyServers, szBuffer);

                cMigrated++;
                dwIndex++;
            }

            if (cMigrated) {
                DebugTrace("Migrated %u LDAP server names from registry\n", cMigrated);
            }
            RegCloseKey(hKeyServers);
        }

        RegCloseKey(hKeyWAB);
    }
}


const LPTSTR szLDAPServersValueName     = "LDAP Servers";
const LPTSTR szLDAPServerName           = "Server Name";
const LPTSTR szLDAPServerInfoURL        = "Server Information URL";
const LPTSTR szLDAPSearchBase           = "Search Base";
const LPTSTR szLDAPServerPropsKey       = "Server Properties";
const LPTSTR szLDAPSearchSizeLimit      = "Search Size Limit";
const LPTSTR szLDAPSearchTimeLimit      = "Search Time Limit";
const LPTSTR szLDAPServerLogoPath       = "Logo";
const LPTSTR szLDAPClientSearchTimeout  = "Client Search Timeout";
const LPTSTR szLDAPDefaultAuthMethod    = "Default Authentication Method";
const LPTSTR szLDAPAuthMethod           = "Authentication Method";
const LPTSTR szLDAPAuthUserName         = "User Name";
const LPTSTR szLDAPAuthPassword         = "Password";
const LPTSTR szLDAPResolveFlag          = "Resolve";
const LPTSTR szLDAPServerID             = "ServerID";
const LPTSTR szLDAPNextAvailableServerID = "Server ID";
const LPTSTR szLDAPPort                 = "Port";
const LPTSTR szLDAPUseBindDN            = "Bind DN";
const LPTSTR szLDAPSimpleSearch         = "Simple Search";
const LPTSTR szLDAPAdvancedSearchAttr   = "Advanced Search Attributes";

extern const LPTSTR szLDAPServersValueName;
extern const LPTSTR szLDAPServerPropsKey;
extern const LPTSTR szLDAPSearchSizeLimit;
extern const LPTSTR szLDAPSearchTimeLimit;
extern const LPTSTR szLDAPClientSearchTimeout;
extern const LPTSTR szLDAPDefaultAuthMethod;
extern const LPTSTR szLDAPAuthMethod;
extern const LPTSTR szLDAPAuthUserName;
extern const LPTSTR szLDAPAuthPassword;
extern const LPTSTR szLDAPResolveFlag;
extern const LPTSTR szLDAPServerName;
extern const LPTSTR szLDAPServerInfoURL;
extern const LPTSTR szLDAPServerLogoPath;
extern const LPTSTR szLDAPSearchBase;
extern const LPTSTR szLDAPNextAvailableServerID;
extern const LPTSTR szLDAPServerID;
extern const LPTSTR szLDAPPort;
extern const LPTSTR szLDAPUseBindDN;
extern const LPTSTR szLDAPSimpleSearch;
extern const LPTSTR szLDAPAdvancedSearchAttr;


#endif

#ifdef mutil_c
#ifdef OLD_STUFF
/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> %s\n", *lppunk, SzDecodeScode(GetScode(hResult)));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : MergeProblemArrays

    Purpose   : Merge a problem array into another

    Parameters: lpPaDest -> destination problem array
                lpPaSource -> source problem array
                cDestMax = total number of problem slots in lpPaDest.  This
                  includes those in use (lpPaDest->cProblem) and those not
                  yet in use.

    Returns   : none

    Comment   :

***************************************************************************/
void MergeProblemArrays(LPSPropProblemArray lpPaDest,
  LPSPropProblemArray lpPaSource, ULONG cDestMax) {
    ULONG i, j;
    ULONG cDest;
    ULONG cDestRemaining;

    cDest = lpPaDest->cProblem;
    cDestRemaining = cDestMax - cDest;

    // Loop through the source problems, copying the non-duplicates into dest
    for (i = 0; i < lpPaSource->cProblem; i++) {
        // Search the Dest problem array for the same property
        for (j = 0; j < cDest; j++) {
            // should just compare PROP_IDs here, since we may be overwriting
            // some of the proptypes with PT_NULL elsewhere.
            if (PROP_ID(lpPaSource->aProblem[i].ulPropTag) == PROP_ID(lpPaDest->aProblem[j].ulPropTag)) {
                break;  // Found a match, don't copy this one.  Move along.
            }
        }

        if (j == lpPaDest->cProblem) {
            Assert(cDestRemaining);
            if (cDestRemaining) {
                // No matches, copy this problem from Source to Dest
                lpPaDest->aProblem[lpPaDest->cProblem++] = lpPaSource->aProblem[i];
                cDestRemaining--;
            } else {
                DebugTrace("MergeProblemArrays ran out of problem slots!\n");
            }
        }
    }
}


/***************************************************************************

    Name      : MapObjectNamedProps

    Purpose   : Map the named properties WAB cares about into the object.

    Parameters: lpmp -> IMAPIProp object
                lppPropTags -> returned array of property tags.  Note: Must
                be MAPIFreeBuffer'd by caller.

    Returns   : none

    Comment   : What a pain in the butt!
                We could conceivably improve performance here by caching the
                returned table and comparing the object's PR_MAPPING_SIGNATURE
                against the cache.

***************************************************************************/
HRESULT MapObjectNamedProps(LPMAPIPROP lpmp, LPSPropTagArray * lppPropTags) {
    static GUID guidWABProps = { /* efa29030-364e-11cf-a49b-00aa0047faa4 */
        0xefa29030,
        0x364e,
        0x11cf,
        {0xa4, 0x9b, 0x00, 0xaa, 0x00, 0x47, 0xfa, 0xa4}
    };

    ULONG i;
    LPMAPINAMEID lppmnid[eMaxNameIDs] = {NULL};
    MAPINAMEID rgmnid[eMaxNameIDs] = {0};
    HRESULT hResult = hrSuccess;


    // Loop through each property, setting up the NAME ID structures
    for (i = 0; i < eMaxNameIDs; i++) {

        rgmnid[i].lpguid = &guidWABProps;
        rgmnid[i].ulKind = MNID_STRING;             // Unicode String
        rgmnid[i].Kind.lpwstrName = rgPropNames[i];

        lppmnid[i] = &rgmnid[i];
    }

    if (hResult = lpmp->lpVtbl->GetIDsFromNames(lpmp,
      eMaxNameIDs,      // how many?
      lppmnid,
      MAPI_CREATE,      // create them if they don't already exist
      lppPropTags)) {
        if (HR_FAILED(hResult)) {
            DebugTrace("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult)));
            goto exit;
        } else {
            DebugTrace("GetIDsFromNames -> %s\n", SzDecodeScode(GetScode(hResult)));
        }
    }

    Assert((*lppPropTags)->cValues == eMaxNameIDs);

    DebugTrace("PropTag\t\tType\tProp Name\n");
    // Loop through the property tags, filling in their property types.
    for (i = 0; i < eMaxNameIDs; i++) {
        (*lppPropTags)->aulPropTag[i] = CHANGE_PROP_TYPE((*lppPropTags)->aulPropTag[i],
          PROP_TYPE(rgulNamedPropTags[i]));
#ifdef DEBUG
        {
            TCHAR szBuffer[257];

            WideCharToMultiByte(CP_ACP, 0, rgPropNames[i], -1, szBuffer, 257, NULL, NULL);

            DebugTrace("%08x\t%s\t%s\n", (*lppPropTags)->aulPropTag[i],
              PropTypeString(PROP_TYPE((*lppPropTags)->aulPropTag[i])), szBuffer);
        }
#endif

    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : PreparePropTagArray

    Purpose   : Prepare a prop tag array by replacing placeholder props tags
                with their named property tags.

    Parameters: ptaStatic = static property tag array (input)
                pptaReturn -> returned prop tag array (output)
                pptaNamedProps -> returned array of named property tags
                    Three possibilities here:
                       + NULL pointer: no input PTA or output named
                           props PTA is returned.  This is less efficient since
                           it must call MAPI to get the named props array.
                       + good pointer to NULL pointer:  no input PTA, but
                           will return a good PTA of named props which can
                           be used in later calls on this object for faster
                           operation.
                       + good pointer to good pointer.  Use the input PTA instead
                           of calling MAPI to map props.  Returned contents must
                           be freed with MAPIFreeBuffer.
                lpObject = object that the properties apply to.  Required if
                    no input *pptaNamedProps is supplied, otherwise, NULL.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT PreparePropTagArray(LPSPropTagArray ptaStatic, LPSPropTagArray * pptaReturn,
  LPSPropTagArray * pptaNamedProps, LPMAPIPROP lpObject) {
    HRESULT hResult = hrSuccess;
    ULONG cbpta;
    LPSPropTagArray ptaTemp = NULL;
    LPSPropTagArray ptaNamedProps;
    ULONG i;

    if (pptaNamedProps) {
        // input Named Props PTA
        ptaNamedProps = *pptaNamedProps;
    } else {
        ptaNamedProps = NULL;
    }

    if (! ptaNamedProps) {
        if (! lpObject) {
            DebugTrace("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n");
            hResult = ResultFromScode(E_INVALIDARG);
            goto exit;
        }

        // Map the property names into the object
        if (hResult = MapObjectNamedProps(lpObject, &ptaTemp)) {
            DebugTrace("PreoparePropTagArray both lpObject and ptaNamedProps are NULL\n");
            goto exit;
        }
    }

    if (pptaReturn) {
        // Allocate a return pta
        cbpta = sizeof(SPropTagArray) + ptaStatic->cValues * sizeof(ULONG);
        if ((*pptaReturn = WABAlloc(cbpta)) == NULL) {
            DebugTrace("PreparePropTagArray WABAlloc(%u) failed\n", cbpta);
            hResult = ResultFromScode(E_OUTOFMEMORY);
            goto exit;
        }

        (*pptaReturn)->cValues = ptaStatic->cValues;

        // Walk through the ptaStatic looking for named property placeholders.
        for (i = 0; i < ptaStatic->cValues; i++) {
            if (IS_PLACEHOLDER(ptaStatic->aulPropTag[i])) {
                // Found a placeholder.  Turn it into a true property tag
                Assert(PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i]) < ptaNamedProps->cValues);
                (*pptaReturn)->aulPropTag[i] =
                   ptaNamedProps->aulPropTag[PLACEHOLDER_INDEX(ptaStatic->aulPropTag[i])];
            } else {
                (*pptaReturn)->aulPropTag[i] = ptaStatic->aulPropTag[i];
            }
        }
    }

exit:
    if (hResult || ! pptaNamedProps) {
        FreeBufferAndNull(&ptaTemp);
    } else {
        // Client is responsible for freeing this.
        *pptaNamedProps = ptaNamedProps;
    }

    return(hResult);
}


/***************************************************************************

    Name      : OpenCreateProperty

    Purpose   : Open an interface on a property or create if non-existent.

    Parameters: lpmp -> IMAPIProp object to open prop on
                ulPropTag = property tag to open
                lpciid -> interface identifier
                ulInterfaceOptions = interface specific flags
                ulFlags = MAPI_MODIFY?
                lppunk -> return the object here

    Returns   : HRESULT

    Comment   : Caller is responsible for Release'ing the returned object.

***************************************************************************/
HRESULT OpenCreateProperty(LPMAPIPROP lpmp,
  ULONG ulPropTag,
  LPCIID lpciid,
  ULONG ulInterfaceOptions,
  ULONG ulFlags,
  LPUNKNOWN * lppunk) {

    HRESULT hResult;

    if (hResult = lpmp->lpVtbl->OpenProperty(
      lpmp,
      ulPropTag,
      lpciid,
      ulInterfaceOptions,
      ulFlags,
      (LPUNKNOWN *)lppunk)) {
        DebugTrace("OpenCreateProperty:OpenProperty(%s)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult)));
        // property doesn't exist... try to create it
        if (hResult = lpmp->lpVtbl->OpenProperty(
          lpmp,
          ulPropTag,
          lpciid,
          ulInterfaceOptions,
          MAPI_CREATE | ulFlags,
          (LPUNKNOWN *)lppunk)) {
            DebugTrace("OpenCreateProperty:OpenProperty(%s, MAPI_CREATE)-> %s\n", PropTagName(ulPropTag), SzDecodeScode(GetScode(hResult)));
        }
    }

    return(hResult);
}
#endif // OLD_STUFF
#endif // mutil_c

#ifdef rk_c



#ifdef OLD_STUFF
//#ifdef OLDSTUFF_DBCS
#define chVoiced		0xde	//Japanese specific
#define	chVoiceless		0xdf	//Japanese specific
#define chDbcsVoiced	0x814a	//Japanese specific
#define	chDbcsVoiceless	0x814b	//Japanese specific
#define LangJPN			0x0411
/* =========================================================
*  ulcbStrCount()
*
*  Count the byte from szSource and ulChrLen
*
*    usChrLen : Char Count not bytes count
*/
ULONG
ulcbStrCount (LPTSTR szSource , ULONG ulChrLen, LANGID langID)
{
	ULONG	ulb = 0;
	ULONG	ulch = ulChrLen;
	LPTSTR	sz = szSource;

	while(ulch && *sz)
	{
		if (IsDBCSLeadByte(*sz))
		{
			if (langID != LangJPN ||
				((*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiced) && (*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiceless)))
				ulch--;
			sz += 2;
			ulb += 2;
		}
		else
		{
			if (langID != LangJPN ||
				((*sz != chVoiced) && (*sz != chVoiceless)))
				ulch--;
			sz++;
			ulb++;
		}
		
	}
	return ulb;
}

/* ========================================================
	ulchStrCount

	Count the Charctor from szSource and ulBLen

	ulBLen is bytes counts
*/
ULONG
ulchStrCount (LPTSTR szSource, ULONG ulBLen, LANGID langID)
{
	ULONG 	ulb = ulBLen;
	ULONG	ulch = 0;
	LPTSTR	sz = szSource;

	while(ulb && *sz)
	{
		if (IsDBCSLeadByte(*sz))
		{
			if (langID != LangJPN ||
				((*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiced) && (*(UNALIGNED WORD*)sz != (WORD)chDbcsVoiceless)))
				ulch++;
			sz += 2;
			ulb -= 2;
		}
		else
		{
			if (langID != LangJPN ||
				((*sz != chVoiced) && (*sz != chVoiceless)))
				ulch++;
			sz++;
			ulb--;
		}
	}
	return ulch;
}


/* =========================================================
*  ulcbEndCount()
*
*  Count the byte from szSource and ulChrLen
*
*    usChrLen : Char Count not bytes count
*/
ULONG
ulcbEndCount(LPSTR szTarget, ULONG cbTarget, ULONG cchPattern, LANGID langID)
{
	LPBYTE	szStart;
	ULONG	cbEndTarget = 0;

	if (cbTarget < cchPattern)
		return 0;

	// This is to get the reasonable starting pointer of the string,
	// so we can imporve the performance in the SzGPrev().
	while(cbTarget > (cchPattern * 2))
	{
		if (IsDBCSLeadByte(*szTarget))
		{
			cbTarget -= 2;
			szTarget += 2;
		}
		else
		{
			cbTarget --;
			szTarget ++;
		}
	}
	
	szStart	= szTarget;
	szTarget= szTarget + cbTarget;

	while (cchPattern > 0)
	{
		const LPBYTE	szTargetOrg =  szTarget;
		szTarget = SzGPrev(szStart, szTarget);

		if(szTarget + 2 == szTargetOrg)	// same as if (IsDBCSLeadByte(szTarget))
		{
			if (langID != LangJPN ||
				((*(UNALIGNED WORD*)szTarget != (WORD)chDbcsVoiced) && (*(UNALIGNED WORD*)szTarget != (WORD)chDbcsVoiceless)))
				cchPattern --;
			cbEndTarget++;
		}
		else if (*szTarget != chVoiced && *szTarget != chVoiceless)
		{
			cchPattern --;
		}
		cbEndTarget++;
	}
	return cbEndTarget;
}
//#endif	// DBCS
#endif //OLD_STUFF

#ifdef OLD_STUFF
#if		defined(WIN16)
#pragma	warning(disable:4505)	/* unreferenced local fuction removed */
#elif	defined(WIN32)
#pragma warning(disable:4514)	/* unreferenced inline function removed */
#endif // OLD_STUFF
#endif

#endif //rk_c

#ifdef _runt_h

#ifdef OLD_STUFF
// CRC-32 implementation (yet another)
ULONG		UlCrc(UINT cb, LPBYTE pb);
#endif

#endif

#ifdef _runt_c
#ifdef OLD_STUFF
STDAPI_(LPTSTR)
SzFindCh(LPCTSTR sz, USHORT ch)
{
	AssertSz(!IsBadStringPtr(sz, INFINITE), "SzFindCh: sz fails address check");

#ifdef OLDSTUFF_DBCS
	return SzGFindCh(sz, ch);
#else
	for (;;)
	{
		if (FIsNextCh(sz, ch))
			return (LPTSTR) sz;
		else if (!*sz)
			return NULL;
		else
			sz = TCharNext(sz);
	}
#endif
}
#endif // OLD_STUFF

#ifdef OLD_STUFF
STDAPI_(LPTSTR)
SzFindLastCh(LPCTSTR sz, USHORT ch)
{
	LPTSTR	szLast = NULL;
	LPTSTR	szNext = (LPTSTR) sz;

	AssertSz(!IsBadStringPtr(sz, INFINITE), "SzFindLastCh: sz fails address check");

#ifdef OLDSTUFF_DBCS
	szNext = sz + CbGSzLen(sz) - 2;
	return SzGFindBackCh(sz, szNext, ch);
#else
	do {
		if (szNext = SzFindCh(szNext, ch)) {
			szLast = szNext;
			szNext = TCharNext(szNext);
		}
	} while (szNext);

	return szLast;
#endif
}
#endif //OLD_STUFF

#ifdef OLD_STUFF
STDAPI_(LPTSTR)
SzFindSz(LPCTSTR sz, LPCTSTR szKey)
{
	AssertSz(!IsBadStringPtr(sz, 0xFFFF), "SzFindSz: sz fails address check");
	AssertSz(!IsBadStringPtr(szKey, 0xFFFF),  "SzFindSz: szKey fails address check");

#ifdef OLDSTUFF_DBCS
	return (LPTSTR)LpszRKFindSubpsz ((LPSTR)sz,
								CchGSzLen(sz),
								(LPSTR)szKey,
								CchGSzLen(szKey),
								0);
#else
	return (LPTSTR)LpszRKFindSubpsz ((LPSTR)sz,
								lstrlen(sz),
								(LPSTR)szKey,
								lstrlen(szKey),
								0);
#endif
}
#endif // OLD_STUFF

#endif _runt_c

#ifdef structs_h
#ifdef OLD_STUFF
/************************ IABProvider ***********************************/

typedef struct _tagIABProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IABProvider_Shutdown_Params, FAR * LPIABProvider_Shutdown_Params;

typedef struct _tagIABProvider_Logon_Params
{
        		LPVOID						This;
        		LPMAPISUP                   lpMAPISup;
                ULONG                       ulUIParam;
                LPTSTR                      lpszProfileName;
                ULONG                       ulFlags;
				ULONG FAR *					lpulpcbSecurity;
				LPBYTE FAR *				lppbSecurity;
                LPMAPIERROR FAR *			lppMapiError;
                LPABLOGON FAR *             lppABLogon;
} IABProvider_Logon_Params, FAR * LPIABProvider_Logon_Params;


/************************* IABLogon *************************************/

typedef struct _tagIABLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IABLogon_GetLastError_Params, FAR * LPIABLogon_GetLastError_Params;

typedef struct _tagIABLogon_Logoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IABLogon_Logoff_Params, FAR * LPIABLogon_Logoff_Params;

typedef struct _tagIABLogon_OpenEntry_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IABLogon_OpenEntry_Params, FAR * LPIABLogon_OpenEntry_Params;

typedef struct _tagIABLogon_CompareEntryIDs_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID1;
                LPENTRYID                   lpEntryID1;
                ULONG                       cbEntryID2;
                LPENTRYID                   lpEntryID2;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulResult;
} IABLogon_CompareEntryIDs_Params, FAR * LPIABLogon_CompareEntryIDs_Params;

typedef struct _tagIABLogon_Advise_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                ULONG                       ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IABLogon_Advise_Params, FAR * LPIABLogon_Advise_Params;

typedef struct _tagIABLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IABLogon_Unadvise_Params, FAR * LPIABLogon_Unadvise_Params;


typedef struct _tagIABLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IABLogon_OpenStatusEntry_Params, FAR * LPIABLogon_OpenStatusEntry_Params;

typedef struct _tagIABLogon_OpenTemplateID_Params
{
        		LPVOID						This;
        		ULONG                       cbTemplateID;
                LPENTRYID                   lpTemplateID;
                ULONG                       ulTemplateFlags;
                LPMAPIPROP                  lpMAPIPropData;
                LPIID                       lpInterface;
                LPMAPIPROP FAR *            lppMAPIPropNew;
                LPMAPIPROP                  lpMAPIPropSibling;
} IABLogon_OpenTemplateID_Params, FAR * LPIABLogon_OpenTemplateID_Params;

typedef struct _tagIABLogon_GetOneOffTable_Params
{
        		LPVOID						This;
				ULONG						ulFlags;
        		LPMAPITABLE FAR *           lppTable;
} IABLogon_GetOneOffTable_Params, FAR * LPIABLogon_GetOneOffTable_Params;

typedef struct _tagIABLogon_PrepareRecips_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPSPropTagArray				lpPropTagArray;
				LPADRLIST					lpRecipList;
} IABLogon_PrepareRecips_Params, FAR * LPIABLogon_PrepareRecips_Params;


/*********************** IXPProvider ************************************/

typedef struct _tagIXPProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IXPProvider_Shutdown_Params, FAR * LPIXPProvider_Shutdown_Params;

typedef struct _tagIXPProvider_TransportLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG FAR *					lpulFlags;
                LPMAPIERROR FAR *			lppMapiError;
				LPXPLOGON FAR *				lppXPLogon;
} IXPProvider_TransportLogon_Params, FAR * LPIXPProvider_TransportLogon_Params;


/************************ IXPLogon **************************************/

typedef struct _tagIXPLogon_AddressTypes_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcAdrType;
				LPTSTR FAR * FAR *			lpppAdrTypeArray;
				ULONG FAR *					lpcMAPIUID;
				LPMAPIUID FAR * FAR *		lpppUIDArray;
} IXPLogon_AddressTypes_Params, FAR * LPIXPLogon_AddressTypes_Params;

typedef struct _tagIXPLogon_RegisterOptions_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcOptions;
				LPOPTIONDATA FAR *			lppOptions;
} IXPLogon_RegisterOptions_Params, FAR * LPIXPLogon_RegisterOptions_Params;

typedef struct _tagIXPLogon_TransportNotify_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				LPVOID FAR *				lppvData;
} IXPLogon_TransportNotify_Params, FAR * LPIXPLogon_TransportNotify_Params;

typedef struct _tagIXPLogon_Idle_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_Idle_Params, FAR * LPIXPLogon_Idle_Params;

typedef struct _tagIXPLogon_TransportLogoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_TransportLogoff_Params, FAR * LPIXPLogon_TransportLogoff_Params;

typedef struct _tagIXPLogon_SubmitMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
				ULONG FAR *					lpulReturnParm;
} IXPLogon_SubmitMessage_Params, FAR * LPIXPLogon_SubmitMessage_Params;

typedef struct _tagIXPLogon_EndMessage_Params
{
				LPVOID						This;
				ULONG						ulMsgRef;
				ULONG FAR *					lpulFlags;
} IXPLogon_EndMessage_Params, FAR * LPIXPLogon_EndMessage_Params;

typedef struct _tagIXPLogon_Poll_Params
{
				LPVOID						This;
				ULONG FAR *					lpulIncoming;
} IXPLogon_Poll_Params, FAR * LPIXPLogon_Poll_Params;

typedef struct _tagIXPLogon_StartMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
} IXPLogon_StartMessage_Params, FAR * LPIXPLogon_StartMessage_Params;

typedef struct _tagIXPLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IXPLogon_OpenStatusEntry_Params, FAR * LPIXPLogon_OpenStatusEntry_Params;

typedef struct _tagIXPLogon_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IXPLogon_ValidateState_Params, FAR * LPIXPLogon_ValidateState_Params;

typedef struct _tagIXPLogon_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IXPLogon_FlushQueues_Params, FAR * LPIXPLogon_FlushQueues_Params;


/*********************** IMSProvider ************************************/

typedef struct _tagIMSProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSProvider_Shutdown_Params, FAR * LPIMSProvider_Shutdown_Params;
		
typedef struct _tagIMSProvider_Logon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG FAR *					lpcbSpoolSecurity;
				LPBYTE FAR *				lppbSpoolSecurity;
                LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_Logon_Params, FAR * LPIMSProvider_Logon_Params;
				
typedef struct _tagIMSProvider_SpoolerLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG						cbSpoolSecurity;
				LPBYTE						lpbSpoolSecurity;
				LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_SpoolerLogon_Params, FAR * LPIMSProvider_SpoolerLogon_Params;
				
typedef struct _tagIMSProvider_CompareStoreIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSProvider_CompareStoreIDs_Params, FAR * LPIMSProvider_CompareStoreIDs_Params;


/*************************** IMSLogon **********************************/

typedef struct _tagIMSLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMSLogon_GetLastError_Params, FAR * LPIMSLogon_GetLastError_Params;

typedef struct _tagIMSLogon_Logoff_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSLogon_Logoff_Params, FAR * LPIMSLogon_Logoff_Params;

typedef struct _tagIMSLogon_OpenEntry_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMSLogon_OpenEntry_Params, FAR * LPIMSLogon_OpenEntry_Params;

typedef struct _tagIMSLogon_CompareEntryIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSLogon_CompareEntryIDs_Params, FAR * LPIMSLogon_CompareEntryIDs_Params;

typedef struct _tagIMSLogon_Advise_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMSLogon_Advise_Params, FAR * LPIMSLogon_Advise_Params;

typedef struct _tagIMSLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IMSLogon_Unadvise_Params, FAR * LPIMSLogon_Unadvise_Params;

typedef struct _tagIMSLogon_OpenStatusEntry_Params
{
				LPVOID						This;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPVOID FAR *				lppEntry;
} IMSLogon_OpenStatusEntry_Params, FAR * LPIMSLogon_OpenStatusEntry_Params;


/*************************** IMAPIControl ******************************/

typedef struct _tagIMAPIControl_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIControl_GetLastError_Params, FAR * LPIMAPIControl_GetLastError_Params;
				
				
typedef struct _tagIMAPIControl_Activate_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG						ulUIParam;
} IMAPIControl_Activate_Params, FAR * LPIMAPIControl_Activate_Params;
				
				
typedef struct _tagIMAPIControl_GetState_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG FAR *					lpulState;
} IMAPIControl_GetState_Params, FAR * LPIMAPIControl_GetState_Params;

#endif
#endif //structs_h


#ifdef wabval_h
#ifdef OLD_STUFF

/* IMsgStore */

#define Validate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define UlValidate_IMsgStore_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define CheckParameters_IMsgStore_Unadvise( a1, a2 ) \
			 CheckParameters2( IMsgStore_Unadvise, a1, a2 )

#define Validate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define UlValidate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define CheckParameters_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )

#define Validate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define UlValidate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )

#define Validate_IMsgStore_StoreLogoff( a1, a2 ) \
			 ValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define UlValidate_IMsgStore_StoreLogoff( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define CheckParameters_IMsgStore_StoreLogoff( a1, a2 ) \
			 CheckParameters2( IMsgStore_StoreLogoff, a1, a2 )

#define Validate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )

#define Validate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define UlValidate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )

#define Validate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define UlValidate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define CheckParameters_IMsgStore_SetLockState( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_SetLockState, a1, a2, a3 )

#define Validate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )

#define Validate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 ValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define UlValidate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define CheckParameters_IMsgStore_NotifyNewMail( a1, a2 ) \
			 CheckParameters2( IMsgStore_NotifyNewMail, a1, a2 )


/* IMessage */

#define Validate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define UlValidate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )

#define Validate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define UlValidate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetRecipientTable, a1, a2, a3 )

#define Validate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define UlValidate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define CheckParameters_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 CheckParameters3( IMessage_ModifyRecipients, a1, a2, a3 )

#define Validate_IMessage_SubmitMessage( a1, a2 ) \
			 ValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define UlValidate_IMessage_SubmitMessage( a1, a2 ) \
			 UlValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define CheckParameters_IMessage_SubmitMessage( a1, a2 ) \
			 CheckParameters2( IMessage_SubmitMessage, a1, a2 )

#define Validate_IMessage_SetReadFlag( a1, a2 ) \
			 ValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define UlValidate_IMessage_SetReadFlag( a1, a2 ) \
			 UlValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define CheckParameters_IMessage_SetReadFlag( a1, a2 ) \
			 CheckParameters2( IMessage_SetReadFlag, a1, a2 )


/* IABProvider */

#define Validate_IABProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define UlValidate_IABProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define CheckParameters_IABProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IABProvider_Shutdown, a1, a2 )

#define Validate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )


/* IABLogon */

#define Validate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IABLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IABLogon_Logoff, a1, a2 )
#define UlValidate_IABLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Logoff, a1, a2 )
#define CheckParameters_IABLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IABLogon_Logoff, a1, a2 )

#define Validate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IABLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define UlValidate_IABLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define CheckParameters_IABLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IABLogon_Unadvise, a1, a2 )

#define Validate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 ValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define UlValidate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 UlValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define CheckParameters_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 CheckParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )

#define Validate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define UlValidate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )


/* IXPProvider */

#define Validate_IXPProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define UlValidate_IXPProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define CheckParameters_IXPProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IXPProvider_Shutdown, a1, a2 )

#define Validate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )


/* IXPLogon */

#define Validate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )

#define Validate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )

#define Validate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define UlValidate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define CheckParameters_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_TransportNotify, a1, a2, a3 )

#define Validate_IXPLogon_Idle( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Idle, a1, a2 )
#define UlValidate_IXPLogon_Idle( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Idle, a1, a2 )
#define CheckParameters_IXPLogon_Idle( a1, a2 ) \
			 CheckParameters2( IXPLogon_Idle, a1, a2 )

#define Validate_IXPLogon_TransportLogoff( a1, a2 ) \
			 ValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define UlValidate_IXPLogon_TransportLogoff( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define CheckParameters_IXPLogon_TransportLogoff( a1, a2 ) \
			 CheckParameters2( IXPLogon_TransportLogoff, a1, a2 )

#define Validate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define UlValidate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define CheckParameters_IXPLogon_EndMessage( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_EndMessage, a1, a2, a3 )

#define Validate_IXPLogon_Poll( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Poll, a1, a2 )
#define UlValidate_IXPLogon_Poll( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Poll, a1, a2 )
#define CheckParameters_IXPLogon_Poll( a1, a2 ) \
			 CheckParameters2( IXPLogon_Poll, a1, a2 )

#define Validate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )

#define Validate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define UlValidate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define CheckParameters_IXPLogon_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_ValidateState, a1, a2, a3 )

#define Validate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )


/* IMSProvider */

#define Validate_IMSProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define UlValidate_IMSProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define CheckParameters_IMSProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IMSProvider_Shutdown, a1, a2 )

#define Validate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )


/* IMSLogon */

#define Validate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IMSLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define UlValidate_IMSLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define CheckParameters_IMSLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IMSLogon_Logoff, a1, a2 )

#define Validate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMSLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define UlValidate_IMSLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define CheckParameters_IMSLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IMSLogon_Unadvise, a1, a2 )

#define Validate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )


/* IMAPIControl */

#define Validate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIControl_Activate( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define UlValidate_IMAPIControl_Activate( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define CheckParameters_IMAPIControl_Activate( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_Activate, a1, a2, a3 )

#define Validate_IMAPIControl_GetState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define UlValidate_IMAPIControl_GetState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define CheckParameters_IMAPIControl_GetState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_GetState, a1, a2, a3 )


/* IMAPIStatus */

#define Validate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define UlValidate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )

#define Validate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define UlValidate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )

#define Validate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define UlValidate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define CheckParameters_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )

#define Validate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )

#endif

#endif //wabval



#ifdef WAB_PROFILES
#ifdef OLD_STUFF
/*
-   HrCreateNewProfileItem
-
*   Creates a new Profile Item and adds the default shared profile to this item
*
*/
HRESULT HrCreateNewProfileItem(LPWABPROFILEITEM * lppItem, LPTSTR lpszProfileID)
{
    HRESULT hr = E_FAIL;
    SCODE sc;
    LPWABPROFILEITEM lpProfile = LocalAlloc(LMEM_ZEROINIT, sizeof(WABPROFILEITEM));

    if(!lppItem)
        goto out;

    if(!lpProfile)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpProfile->lpszProfileID = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpszProfileID)+1);
    if(!lpProfile->lpszProfileID)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lstrcpy(lpProfile->lpszProfileID, lpszProfileID);
    //lpProfile->dwProfileID = dwEntryID;
    sc = MAPIAllocateBuffer(sizeof(SPropValue), &(lpProfile->lpspvFolders));
    if(sc)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpProfile->lpspvFolders[0].ulPropTag = PR_WAB_FOLDER_ENTRIES;
    lpProfile->lpspvFolders[0].Value.MVbin.cValues = 0;
    lpProfile->lpspvFolders[0].Value.MVbin.lpbin = NULL;

    // The folder item corresponding to the Shared folder is a 
    // virtual item with NULL entryid .. so add this virtual item to
    // the primary profile
    //
    AddPropToMVPBin(lpProfile->lpspvFolders, 0,
                     (LPVOID) NULL, 0, TRUE);

    *lppItem = lpProfile;

    hr = S_OK;
out:
    if(HR_FAILED(hr) && lpProfile)
        LocalFree(lpProfile);

    return hr;
 }

/*
-   HrLoadPrimaryWABProfile
-
-
*   Creates a primary profile which points to all existing folders in the
*   store - this profile is used when no profile ID is supplied so that the
*   UI can see everything
*   
*/
HRESULT HrLoadPrimaryWABProfile(LPIAB lpIAB)
{
    SCODE sc;
    HRESULT hr = E_FAIL;
    SPropertyRestriction PropRes = {0};
	SPropValue sp = {0};
    ULONG ulCount = 0;
    LPSBinary rgsbEntryIDs = NULL;
    ULONG i = 0;
    LPWABPROFILEITEM lpProfile = NULL;

    // Now we will search the WAB for all objects of PR_OBJECT_TYPE = MAPI_ABCONT
    //

	sp.ulPropTag = PR_OBJECT_TYPE;
	sp.Value.l = MAPI_ABCONT;

    PropRes.ulPropTag = PR_OBJECT_TYPE;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = &sp;

    hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
						NULL, 0,
                        TRUE,
                        &PropRes, &ulCount, &rgsbEntryIDs);

    if (HR_FAILED(hr))
        goto out;

    // we'll always create a default item, whether it has anything in it or not ..
    hr = HrCreateNewProfileItem(&lpProfile, szEmpty);
    if(HR_FAILED(hr) || !lpProfile)
        goto out;

    //if(ulCount && rgsbEntryIDs)
    {
        for(i=0;i<ulCount;i++)
        {
            ULONG cb = 0;
            LPENTRYID lpb = NULL;

            if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                            rgsbEntryIDs[i].lpb, NULL, NULL,
                                            rgsbEntryIDs[i].cb, 0,
                                            NULL, &cb, &lpb)))
            {
                // Add the entryids to this prop - ignore errors
                AddPropToMVPBin(lpProfile->lpspvFolders, 0, (LPVOID) lpb, cb, TRUE);
#ifdef DEBUG 
//////////////
                {
                    LPTSTR lp = NULL;
                    SBinary sb;
                    sb.cb = cb;sb.lpb = (LPBYTE)lpb;
                    HrGetProfileFolderName(lpIAB, &sb, &lp);
                    if(lp)
                    {
                        DebugTrace("Found Folder: %s\n",lp);
                        LocalFree(lp);
                    }
                }
//////////////
#endif 
                MAPIFreeBuffer(lpb);
            }
        }

        lpProfile->lpNext = lpIAB->lpProfilesList;
        lpIAB->lpProfilesList = lpProfile;
    }

    hr = S_OK;
out:
    if(ulCount && rgsbEntryIDs)
    {
        FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore,
                    ulCount,
                    rgsbEntryIDs);
    }
    return hr;
}



static const char szProfileKey[] = "Software\\Microsoft\\WAB\\WAB4\\Profiles";

/*
-   HrLoadSecondaryWABProfiles
-
-
*   Creates secondary profiles which are based on profiles actually saved in the registry
*   
*/
HRESULT HrLoadSecondaryWABProfiles(LPIAB lpIAB)
{
    SCODE sc;
    HRESULT hr = E_FAIL;
    ULONG ulCount = 0, i = 0;
    LPWABPROFILEITEM lpProfile = NULL;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, szProfileKey, 0, KEY_READ, &hKey))
    {
        hr = S_OK; // ignore this error
        goto out;
    }

    {
        TCHAR szValName[MAX_PATH];
        DWORD dwValIndex = 0, dwValSize = sizeof(szValName), dwType = 0;

        *szValName = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwValIndex, 
                                            szValName, &dwValSize, 
                                            0, &dwType, 
                                            NULL, NULL))
        {
            // The value names under this entry are the profiles IDs and the
            // Value data is the raw folder data we care about
            //
            if(dwType == REG_BINARY && lstrlen(szValName))
            {
                //Read in the Value
                if(ERROR_SUCCESS == RegQueryValueEx(hKey, szValName, 0, &dwType, 
                                                    NULL, &dwValSize))
                {
                    LPTSTR lpsz = LocalAlloc(LMEM_ZEROINIT, dwValSize);
                    if(lpsz)
                    {
                        if(ERROR_SUCCESS == RegQueryValueEx(hKey, szValName, 0, &dwType, 
                                                            (LPBYTE) lpsz, &dwValSize))
                        {
                            LPSPropValue lpProp = NULL;
                            ULONG ulCount = 0;

                            hr = HrGetPropArrayFromBuffer(lpsz, dwValSize, 1, 0, &lpProp); 
                            if(!HR_FAILED(hr) && lpProp && lpProp->ulPropTag == PR_WAB_FOLDER_ENTRIES)
                            {
                                hr = HrCreateNewProfileItem(&lpProfile, szValName);
                                if(HR_FAILED(hr) || !lpProfile)
                                    goto out;

                                for(i=0;i<lpProp->Value.MVbin.cValues;i++)
                                {
                                    if(lpProp->Value.MVbin.lpbin[i].lpb && lpProp->Value.MVbin.lpbin[i].cb)
                                    {
                                        LPSPropValue lpPropArray = NULL;
                                        ULONG ulcValues = 0;
                                        // Verify that this folder actually physically exists - it might have been deleted
                                        if(!HR_FAILED(ReadRecord(   lpIAB->lpPropertyStore->hPropertyStore, 
                                                                    &(lpProp->Value.MVbin.lpbin[i]),
                                                                    0, &ulcValues, &lpPropArray)))
                                        {
                                            // Add the entryids to this prop - ignore errors
                                            // Dont add the default shared folder as thats alreadybeen added
                                            ULONG cb = lpProp->Value.MVbin.lpbin[i].cb;
                                            LPENTRYID lpb = (LPENTRYID) lpProp->Value.MVbin.lpbin[i].lpb;

                                            if(WAB_CONTAINER != IsWABEntryID(cb,lpb,NULL,NULL,NULL,NULL,NULL))
                                            {
                                                CreateWABEntryID( WAB_CONTAINER,lpProp->Value.MVbin.lpbin[i].lpb, NULL, NULL,
                                                                                lpProp->Value.MVbin.lpbin[i].cb, 0,
                                                                                NULL, &cb, &lpb);
                                            }
                                            // Add the entryids to this prop - ignore errors
                                            AddPropToMVPBin(lpProfile->lpspvFolders, 0, (LPVOID) lpb, cb, TRUE);
                                            if(lpProp->Value.MVbin.lpbin[i].lpb != (LPBYTE)lpb )
                                                MAPIFreeBuffer(lpb);
                                        }
                                        LocalFreePropArray(NULL, ulcValues, &lpPropArray);
                                    }
                                }
                                lpProfile->lpNext = lpIAB->lpProfilesList;
                                lpIAB->lpProfilesList = lpProfile;
                            }
                            LocalFreePropArray(NULL, 1, &lpProp);
                        }
                        LocalFree(lpsz);
                    }
                }
            }

            dwValIndex++;
            *szValName = '\0';
            dwValSize = sizeof(szValName);
        }
    }

    hr = S_OK;
out:

    if(hKey)
        RegCloseKey(hKey);

    return hr;
}


/*
- SetCurrentProfile - scans list and updates pointer
-
*
*/
void SetCurrentProfile(LPIAB lpIAB, LPTSTR lpszProfileID)
{
    LPWABPROFILEITEM lpTemp = lpIAB->lpProfilesList;
    while(lpTemp)
    {
        if(!lstrcmpi(lpTemp->lpszProfileID, lpszProfileID))
        {
            lpIAB->lpCurrentProfile = lpTemp;
            lpIAB->lpszProfileID = lpTemp->lpszProfileID;
            break;
        }
        lpTemp = lpTemp->lpNext;
    }
}

/*
-   HrSaveProfileItem
-
-
*   Persists a profile item to the registry
*   Format for the data is:
*   under HKCU\Software\Microsoft\WAB\Profiles create a new binary value
*   corresponding to the profile ID and set the binary value data to
*   a flat buffer corresponding to the PR_WAB_FOLDER_ENTRIES property
*/
HRESULT HrSaveProfileItem(LPWABPROFILEITEM lpNew)
{
    ULONG cbBuf = 0;
    LPTSTR lpBuf = NULL;
    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;

    if(lpNew->lpszProfileID && !(lpNew->lpszProfileID))    // This item is never cached - only created dynamically
        return S_OK;

    hr = HrGetBufferFromPropArray(  1, lpNew->lpspvFolders,
                                    &cbBuf, &lpBuf);
    if(HR_FAILED(hr))
        goto out;

    if(cbBuf && lpBuf)
    {
        TCHAR szValName[MAX_PATH];
        lstrcpy(szValName, lpNew->lpszProfileID);
        //wsprintf(szValName, "%d", lpNew->dwProfileID);

        if(ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, szProfileKey,
                                            0, NULL, REG_OPTION_NON_VOLATILE, 
                                            KEY_ALL_ACCESS, NULL, 
                                            &hKey, NULL))
        {
            RegSetValueEx(  hKey, szValName,
                            0, REG_BINARY,
                            (LPBYTE) lpBuf, cbBuf );
        }
        LocalFree(lpBuf);
    }

out:
    if(hKey)
        RegCloseKey(hKey);
    return hr;
}


/*
-   HrCreateNewWABProfile
-
-
*   Creates a new profile based on the supplied profile ID
*   The profile has the default folder-id for the shared folder
*   set on it.
*   Also tags the new profile to the current folder list
*/
HRESULT HrCreateNewWABProfile(LPIAB lpIAB, LPTSTR lpszProfileID )
{
    HRESULT hr = E_FAIL;
    LPWABPROFILEITEM lpNew = NULL;

    hr = HrCreateNewProfileItem(&lpNew, lpszProfileID);
    if(HR_FAILED(hr) || !lpNew)
        goto out;

    // Persist this new item to the registry
    HrSaveProfileItem(lpNew);

    // Add it to the main list
    lpNew->lpNext = lpIAB->lpProfilesList;
    lpIAB->lpProfilesList = lpNew;

    hr = S_OK;
out:

    if(HR_FAILED(hr) && lpNew)
    {
        MAPIFreeBuffer(lpNew->lpspvFolders);
        LocalFree(lpNew);
    }

    return hr;

}



/*
-   FreeWABProfilesList
-
-
*   Clears up existing Profile info from the IAB object
*/
void FreeWABProfilesList(LPIAB lpIAB)
{
    LPWABPROFILEITEM lpTemp = lpIAB->lpProfilesList;
    while(lpTemp)
    {
        lpIAB->lpProfilesList  = lpTemp->lpNext;
        MAPIFreeBuffer(lpTemp->lpspvFolders);
        if(lpTemp->lpszProfileID)
            LocalFree(lpTemp->lpszProfileID);
        LocalFree(lpTemp);
        lpTemp = lpIAB->lpProfilesList;
    }
    lpIAB->lpProfilesList = NULL;
    lpIAB->lpCurrentProfile = NULL;
    lpIAB->lpszProfileID = NULL;
}



#endif //OLD_STUFF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dead\uidsprop.c ===
/**********************************************************************************
*
*
*   UI_DPROP.C - contains functions for the Directory Service Property dialog
*
*
*
**********************************************************************************/

#include "_apipch.h"


#ifdef OLD_LDAP_UI
extern HINSTANCE ghCommCtrlDLLInst;
extern LPPROPERTYSHEET        gpfnPropertySheet;


// Params passed to dialog box
typedef struct _tagLSP
{
    LPTSTR lpszName;
    LDAPSERVERPARAMS ldapsp;
    int nRetVal;
    BOOL bAddNew;
} LSP, * LPLSP;


// Return codes from Dialog Box
enum _DSPROPS
{
    DSPROP_ERROR=0,
    DSPROP_OK,
    DSPROP_CANCEL
};

/*
* Prototypes
*/
int CreateDSPropertySheet( HWND hwndOwner, LPLSP lpLsp);
BOOL APIENTRY_16 fnDSPropsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);
BOOL APIENTRY_16 fnDSAdvancedPropsProc(HWND hDlg,UINT message,UINT  wParam,LPARAM lParam);

BOOL FillDSPropsUI( HWND hDlg,
                    int nPropSheet,
                    LPLSP lpLsp);

BOOL GetDSPropsFromUI(  HWND hDlg,
                        int nPropSheet,
                        LPLSP lpLsp);

BOOL SetDSPropsUI(HWND hDlg,
                  int nPropSheet);


// List of property sheets in this UI
enum _DSProps
{
    propDSProp=0,
    propDSPropAdvanced,
    propDSMax
};


#define EDIT_LEN   MAX_UI_STR-16

/*
* Help IDs
*/
static DWORD rgDsPropsHelpIDs[] =
{
    IDC_LDAP_PROPS_FRAME,               IDH_WAB_COMM_GROUPBOX,
    IDC_LDAP_PROPS_FRAME2,              IDH_WAB_COMM_GROUPBOX,
    //IDC_LDAP_PROPS_STATIC_CAPTION,
    IDC_LDAP_PROPS_STATIC_NAME_FRIENDLY,IDH_WABLDAP_DIRSSERV_FRIENDLY_NAME,
    IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY,  IDH_WABLDAP_DIRSSERV_FRIENDLY_NAME,
    IDC_LDAP_PROPS_RADIO_SICILY,        IDH_WABLDAP_DIRSSERV_AUTH_SICILY,
    IDC_LDAP_PROPS_CHECK_NAMES,         IDH_WABLDAP_DIRSSERV_CHECK_AGAINST,
    IDC_LDAP_PROPS_STATIC_NAME,         IDH_WABLDAP_DIRSSERV_NAME,
    IDC_LDAP_PROPS_EDIT_NAME,           IDH_WABLDAP_DIRSSERV_NAME,
    IDC_LDAP_PROPS_RADIO_ANON,          IDH_WABLDAP_DIRSSERV_AUTH_ANON,
    IDC_LDAP_PROPS_RADIO_USERPASS,      IDH_WABLDAP_DIRSSERV_AUTH_PASS,
    IDC_LDAP_PROPS_STATIC_USERNAME,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_EDIT_USERNAME,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_STATIC_PASSWORD,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_EDIT_PASSWORD,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_STATIC_PASSWORD2,    IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD,IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    IDC_LDAP_PROPS_FRAME_ROOT,          IDH_LDAP_SEARCH_BASE,
    IDC_LDAP_PROPS_EDIT_ROOT,           IDH_LDAP_SEARCH_BASE,
    IDC_LDAP_PROPS_STATIC_SEARCH,       IDH_WABLDAP_SEARCH_TIMEOUT,
    IDC_LDAP_PROPS_EDIT_SEARCH,         IDH_WABLDAP_SEARCH_TIMEOUT,
    IDC_LDAP_PROPS_STATIC_NUMRESULTS,   IDH_WABLDAP_SEARCH_LIMIT,
    IDC_LDAP_PROPS_EDIT_NUMRESULTS,     IDH_WABLDAP_SEARCH_LIMIT,
    0,0
};


#endif // OLD_LDAP_UI


///////////////////////////////////////////////////////////////////
//
//  HrShowDSProps - shows Directory Service properties UI
//
//  hWndParent - hWnd of Parent
//  lpszName - pointer to a buffer ... also contains name of LDAP
//      server to view prperties on - this name can be modified so
//      lpszName should point to a big enough buffer
//  bAddNew - TRUE if this is a new entry, false if this is props
///////////////////////////////////////////////////////////////////
HRESULT HrShowDSProps(HWND      hWndParent,
                      LPTSTR    lpszName,
                      BOOL      bAddNew)
{

    HRESULT hr = hrSuccess;
    IImnAccountManager * lpAccountManager = NULL;
    IImnAccount * lpAccount = NULL;

    // init account manager
    // Make sure there is an account manager
    if (hr = InitAccountManager(&lpAccountManager)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    // find this account
    if (hr = lpAccountManager->lpVtbl->FindAccount(lpAccountManager,
      AP_ACCOUNT_NAME,
      lpszName,
      &lpAccount)) {
        DebugTrace("FindAccount(%s) -> %x\n", lpszName, GetScode(hr));
        goto out;
    }

    // show properties
    if (hr = lpAccount->lpVtbl->ShowProperties(lpAccount,
      hWndParent,
      0)) {
        DebugTrace("ShowProperties(%s) -> %x\n", lpszName, GetScode(hr));
        goto out;
    }

    {
        TCHAR szBuf[MAX_UI_STR];
        // Get the friendly name (== account name if this changed)
        if (! (HR_FAILED(hr = lpAccount->lpVtbl->GetPropSz(lpAccount,
                                                                AP_ACCOUNT_NAME,
                                                                szBuf,
                                                                sizeof(szBuf))))) 
        {
            lstrcpy(lpszName, szBuf);
        }
    }

#ifdef OLD_LDAP_UI
    SCODE sc = SUCCESS_SUCCESS;
    TCHAR szOldName[MAX_UI_STR];

    ULONG i = 0, j = 0;

    LSP lsp = {0};

    DebugPrintTrace(("----------\nHrShowDSProps Entry\n"));

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    lsp.lpszName = lpszName;
    lsp.nRetVal = DSPROP_ERROR;
    lsp.bAddNew = bAddNew;


    // Store the old name in case it changes later on ...
    szOldName[0]='\0';
    if (! bAddNew) {
        lstrcpy(szOldName, lpszName);
    }

    // Get the details of this DS from the registry
    if (lpszName && *lpszName) {
        if (hr = GetLDAPServerParams(lpszName, &(lsp.ldapsp))) {
            DebugTrace("No Account Manager\n");
            ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
            goto out;
        }
    } else {
        // Fill in the default values for the props here:
        lsp.ldapsp.dwSearchSizeLimit = LDAP_SEARCH_SIZE_LIMIT;
        lsp.ldapsp.dwSearchTimeLimit = LDAP_SEARCH_TIME_LIMIT;
        lsp.ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
        lsp.ldapsp.lpszUserName = NULL;
        lsp.ldapsp.lpszPassword = NULL;
        lsp.ldapsp.lpszURL = NULL;
        lsp.ldapsp.fResolve = FALSE;
        lsp.ldapsp.lpszBase = NULL;
        lsp.ldapsp.lpszName = NULL;
    }

retry:
    // PropSheets
    if (CreateDSPropertySheet(hWndParent,&lsp) == -1)
    {
        // Something failed ...
        hr = E_FAIL;
        goto out;
    }


    switch(lsp.nRetVal)
    {
    case DSPROP_OK:
        if(lstrlen(lsp.lpszName))
        {
            // If this was an old entry that changed, remove the old entry from the
            // registry and rewrite this again ...
            // if(!bAddNew &&
            //   (lstrcmpi(szOldName, lsp.lpszName)))
            //    SetLDAPServerParams(szOldName, NULL);
            //
            // On second thoughts, we will let the calling function handle the old new thing
            // because the calling function should be able to recover from a User Cancel ...

            if (GetScode(SetLDAPServerParams(lpszName, &(lsp.ldapsp))) == MAPI_E_COLLISION) {
                // Name collision with existing account.
                DebugTrace("Collision in LDAP server names\n");
                ShowMessageBoxParam(hWndParent, IDE_SERVER_NAME_COLLISION, MB_ICONERROR, lsp.lpszName);
                goto retry;
            }
        }
        hr = S_OK;
        break;
    case DSPROP_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case DSPROP_ERROR:
        hr = E_FAIL;
        break;
    }

out:

    FreeLDAPServerParams(lsp.ldapsp);
#endif // OLD_LDAP_UI

out:

    if (lpAccount) {
        lpAccount->lpVtbl->Release(lpAccount);
    }


//  Don't release the account manager.  It will be done when the IAdrBook is released.
//    if (lpAccountManager) {
//        lpAccountManager->lpVtbl->Release(lpAccountManager);
//    }

    return hr;
}


#ifdef OLD_LDAP_UI
/****************************************************************************
*    FUNCTION: CreateDSPropertySheet(HWND)
*
*    PURPOSE:  Creates the DL property sheet
*
****************************************************************************/
int CreateDSPropertySheet( HWND hwndOwner,
                           LPLSP lpLsp)
{
    PROPSHEETPAGE psp[propDSMax];
    PROPSHEETHEADER psh;
    TCHAR szBuf[propDSMax][MAX_UI_STR];
    TCHAR szBuf2[MAX_UI_STR];

    psp[propDSProp].dwSize = sizeof(PROPSHEETPAGE);
    psp[propDSProp].dwFlags = PSP_USETITLE;
    psp[propDSProp].hInstance = hinstMapiX;
    psp[propDSProp].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_PROPERTIES);
    psp[propDSProp].pszIcon = NULL;
    psp[propDSProp].pfnDlgProc = (DLGPROC) fnDSPropsProc;
    LoadString(hinstMapiX, idsCertGeneralTitle, szBuf[propDSProp], sizeof(szBuf[propDSProp]));
    psp[propDSProp].pszTitle = szBuf[propDSProp];
    psp[propDSProp].lParam = (LPARAM) lpLsp;

    psp[propDSPropAdvanced].dwSize = sizeof(PROPSHEETPAGE);
    psp[propDSPropAdvanced].dwFlags = PSP_USETITLE;
    psp[propDSPropAdvanced].hInstance = hinstMapiX;
    psp[propDSPropAdvanced].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_LDAP_PROPERTIES_ADVANCED);
    psp[propDSPropAdvanced].pszIcon = NULL;
    psp[propDSPropAdvanced].pfnDlgProc = (DLGPROC) fnDSAdvancedPropsProc;
    LoadString(hinstMapiX, idsCertAdvancedTitle, szBuf[propDSPropAdvanced], sizeof(szBuf[propDSPropAdvanced]));
    psp[propDSPropAdvanced].pszTitle = szBuf[propDSPropAdvanced];
    psp[propDSPropAdvanced].lParam = (LPARAM) lpLsp;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, IDS_DETAILS_CAPTION, szBuf2, sizeof(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = propDSProp;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (gpfnPropertySheet(&psh));
}


/****************************************************************************
*    FUNCTION: SetDSPropsUI(HWND)
*
*    PURPOSE:  Sets up the UI for this PropSheet
*
*   hDlg - Dialog
*   nPropSheet - property sheet
*
****************************************************************************/
BOOL SetDSPropsUI(HWND hDlg, int nPropSheet)
{
    ULONG i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    switch(nPropSheet)
    {
    case propDSProp:
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_NAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        break;
    case propDSPropAdvanced:
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_SEARCH),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_NUMRESULTS),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        SendMessage(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_ROOT),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
        break;
    }

    return TRUE;
}


/****************************************************************************
*    FUNCTION: FillDSPropsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillDSPropsUI(HWND hDlg, int nPropSheet, LPLSP lpLsp)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    int id;

    switch(nPropSheet)
    {
    case propDSProp:
        {
            // Set the authentication method UI
            switch(lpLsp->ldapsp.dwAuthMethod)
            {
            case LDAP_AUTH_METHOD_ANONYMOUS:
                id = IDC_LDAP_PROPS_RADIO_ANON;
                break;
            case LDAP_AUTH_METHOD_SIMPLE:
                id = IDC_LDAP_PROPS_RADIO_USERPASS;
                break;
            case LDAP_AUTH_METHOD_SICILY:
                id = IDC_LDAP_PROPS_RADIO_SICILY;
                break;
            }

            if( (id == IDC_LDAP_PROPS_RADIO_ANON) ||
                (id == IDC_LDAP_PROPS_RADIO_SICILY) )
            {
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_USERNAME),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD),FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD2),FALSE);
            }
            //
            // Club the radio buttons togethor ...
            CheckRadioButton(   hDlg,
                                IDC_LDAP_PROPS_RADIO_ANON,
                                IDC_LDAP_PROPS_RADIO_USERPASS,
                                id);

            // Fill in other details
            if(lstrlen(lpLsp->lpszName))
            {
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY, lpLsp->lpszName);
                SetWindowPropertiesTitle(GetParent(hDlg), lpLsp->lpszName);
            }

            if(lpLsp->ldapsp.lpszName)
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME, lpLsp->ldapsp.lpszName);

            if(lpLsp->ldapsp.lpszUserName)
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_USERNAME, lpLsp->ldapsp.lpszUserName);

            if(lpLsp->ldapsp.lpszPassword)
            {
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_PASSWORD, lpLsp->ldapsp.lpszPassword);
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD, lpLsp->ldapsp.lpszPassword);
            }

            id = (lpLsp->ldapsp.fResolve) ? BST_CHECKED : BST_UNCHECKED;
            CheckDlgButton(hDlg, IDC_LDAP_PROPS_CHECK_NAMES, id);

        }
        break;


    case propDSPropAdvanced:
        {
            SetDlgItemInt(  hDlg,
                            IDC_LDAP_PROPS_EDIT_SEARCH,
                            lpLsp->ldapsp.dwSearchTimeLimit,
                            FALSE);
            SetDlgItemInt(  hDlg,
                            IDC_LDAP_PROPS_EDIT_NUMRESULTS,
                            lpLsp->ldapsp.dwSearchSizeLimit,
                            FALSE);

            EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_ROOT),TRUE);

            if(lpLsp->ldapsp.lpszBase)
            {
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_ROOT, lpLsp->ldapsp.lpszBase);
            }
            else
            {
                LPTSTR lpszBase = TEXT("c=%s"); //Hopefully this string doesnt need localization
                TCHAR szBuf[32], szCode[4];
                ReadRegistryLDAPDefaultCountry(NULL, szCode);
                wsprintf(szBuf, lpszBase, szCode);
                SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_ROOT, szBuf);
            }
        }
        break;
    }



    bRet = TRUE;

    return bRet;
}




////////////////////////////////////////////////////////////////////////////////
//
//  GetDSPropsFromUI - reads the UI for its parameters and verifies that
//  all required fields are set. Params are stored back in the lpLsp struct
//
////////////////////////////////////////////////////////////////////////////////
BOOL GetDSPropsFromUI(HWND hDlg, int nPropSheet, LPLSP lpLsp)
{
    BOOL bRet = FALSE;
    LDAPSERVERPARAMS  Params={0};

    TCHAR szBuf[2 * EDIT_LEN];

    switch(nPropSheet)
    {
    case propDSProp:
        {
            //
            // First check the required property (which is the Name and Friendly Name)
            //
            BOOL bName = FALSE, bFName = FALSE;
            DWORD dwID = 0;
            BOOL bExists = FALSE;

            szBuf[0]='\0'; //reset
            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            if(lstrlen(szBuf))
                bFName = TRUE;

            // We want the friendly names to be unique .. hence check if this friendly name
            // already exists or not ...
            bExists = GetLDAPServerParams(szBuf, &Params);

            if((bExists && lpLsp->bAddNew) ||
                (bExists && !lpLsp->bAddNew && (Params.dwID != lpLsp->ldapsp.dwID)))
            {
                // We are adding a new entry, but we found that another entry exists with the
                // same name or we are editing an existing entry and then found that another
                // entry exists whose ID does not match this entries ID.

                // Warn them that they must add a unique friendly name
                ShowMessageBoxParam(hDlg, idsEnterUniqueLDAPName, MB_ICONEXCLAMATION | MB_OK, szBuf);
                goto out;
            }

            szBuf[0]='\0'; //
            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            if(lstrlen(szBuf))
                bName = TRUE;

            if(!bName || !bFName)
            {
                ShowMessageBox(hDlg, idsEnterLDAPServerName, MB_ICONEXCLAMATION | MB_OK);
                goto out;
            }

            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            LocalFreeAndNull(&lpLsp->ldapsp.lpszName);
            lpLsp->ldapsp.lpszName = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
            if(lpLsp->ldapsp.lpszName)
                lstrcpy(lpLsp->ldapsp.lpszName, szBuf);

            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            lstrcpy(lpLsp->lpszName, szBuf);

            //
            // check the selected authentication type
            //
            if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_RADIO_ANON) == 1)
                lpLsp->ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_ANONYMOUS;
            else if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_RADIO_USERPASS) == 1)
                lpLsp->ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_SIMPLE;
            else if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_RADIO_SICILY) == 1)
                lpLsp->ldapsp.dwAuthMethod = LDAP_AUTH_METHOD_SICILY;


            LocalFreeAndNull(&lpLsp->ldapsp.lpszUserName);
            LocalFreeAndNull(&lpLsp->ldapsp.lpszPassword);

            //
            // Get the user name password, if applicable
            //
            if(lpLsp->ldapsp.dwAuthMethod == LDAP_AUTH_METHOD_SIMPLE)
            {
                TCHAR szBuf2[MAX_UI_STR*2];

                //
                // Verify that the entered password matches the confirmed password
                //
                szBuf[0]='\0'; //reset
                GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_PASSWORD, szBuf, sizeof(szBuf));
                szBuf2[0]='\0'; //reset
                GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD, szBuf2, sizeof(szBuf2));
                TrimSpaces(szBuf);
                TrimSpaces(szBuf2);

                if(lstrcmp(szBuf,szBuf2))
                {
                    ShowMessageBox(hDlg, idsConfirmPassword, MB_ICONEXCLAMATION | MB_OK);
                    SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_PASSWORD, szEmpty);
                    SetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD, szEmpty);
                    goto out;
                }

                // otherwise keep this password ...
                lpLsp->ldapsp.lpszPassword = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
                if(!(lpLsp->ldapsp.lpszPassword))
                {
                    DebugPrintError(("LocalAlloc failed to allocate memory\n"));
                    goto out;
                }
                lstrcpy(lpLsp->ldapsp.lpszPassword,szBuf);

                szBuf[0]='\0'; //reset
                GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_USERNAME, szBuf, sizeof(szBuf));
                TrimSpaces(szBuf);
                if(lstrlen(szBuf))
                {
                    lpLsp->ldapsp.lpszUserName = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
                    if(!(lpLsp->ldapsp.lpszUserName))
                    {
                        DebugPrintError(("LocalAlloc failed to allocate memory\n"));
                        goto out;
                    }
                    lstrcpy(lpLsp->ldapsp.lpszUserName,szBuf);
                }
            }

            if(IsDlgButtonChecked(hDlg, IDC_LDAP_PROPS_CHECK_NAMES) == BST_CHECKED)
                lpLsp->ldapsp.fResolve = TRUE;
            else
                lpLsp->ldapsp.fResolve = FALSE;

            if(lpLsp->bAddNew)
                lpLsp->ldapsp.dwID = GetLDAPNextServerID(0);

        }
        break;
    case propDSPropAdvanced:
        {
            lpLsp->ldapsp.dwSearchTimeLimit = GetDlgItemInt(
                                                hDlg,
                                                IDC_LDAP_PROPS_EDIT_SEARCH,
                                                NULL,
                                                FALSE);

            lpLsp->ldapsp.dwSearchSizeLimit = GetDlgItemInt(
                                                hDlg,
                                                IDC_LDAP_PROPS_EDIT_NUMRESULTS,
                                                NULL,
                                                FALSE);

            GetDlgItemText(hDlg, IDC_LDAP_PROPS_EDIT_ROOT, szBuf, sizeof(szBuf));
            TrimSpaces(szBuf);
            if(lstrlen(szBuf))
            {
                LocalFreeAndNull(&lpLsp->ldapsp.lpszBase);
                lpLsp->ldapsp.lpszBase = LocalAlloc(LMEM_ZEROINIT, lstrlen(szBuf)+1);
                if(lpLsp->ldapsp.lpszBase)
                    lstrcpy(lpLsp->ldapsp.lpszBase, szBuf);
            }
        }
        break;
    }

    bRet = TRUE;

out:
    FreeLDAPServerParams(Params);
    return bRet;
}



#define lpLSP ((LPLSP) pps->lParam)



/*//$$***********************************************************************
*    FUNCTION: fnDSPropsProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSPropsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        SetDSPropsUI(hDlg, propDSProp);
        FillDSPropsUI(hDlg, propDSProp, lpLSP);
        return TRUE;


    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE:
            switch(LOWORD(wParam))
            {
            case IDC_LDAP_PROPS_EDIT_NAME_FRIENDLY:
                {
                    // Update the dialog title with the friendly name
                    TCHAR szBuf[MAX_UI_STR];
                    GetWindowText((HWND) lParam,szBuf,sizeof(szBuf));
                    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                }
                break;
            }
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        case IDC_LDAP_PROPS_RADIO_ANON:
        case IDC_LDAP_PROPS_RADIO_USERPASS:
        case IDC_LDAP_PROPS_RADIO_SICILY:
                CheckRadioButton(   hDlg,
                        IDC_LDAP_PROPS_RADIO_ANON,
                        IDC_LDAP_PROPS_RADIO_USERPASS,
                        LOWORD(wParam));
                {
                    int id = LOWORD(wParam);
                    if( (id == IDC_LDAP_PROPS_RADIO_ANON) ||
                        (id == IDC_LDAP_PROPS_RADIO_SICILY) )
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_USERNAME),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD2),FALSE);
                    }
                    else if (id = IDC_LDAP_PROPS_RADIO_USERPASS)
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_USERNAME),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_PASSWORD),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_USERNAME),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_LDAP_PROPS_STATIC_PASSWORD2),TRUE);
                    }
                }
                break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            if (!GetDSPropsFromUI(hDlg, propDSProp, lpLSP))
            {
                //something failed ... abort this OK ... ie dont let them close
                SetWindowLong(hDlg,DWL_MSGRESULT, TRUE);
                return TRUE;
            }
            lpLSP->nRetVal = DSPROP_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            lpLSP->nRetVal = DSPROP_CANCEL;
            break;




        }

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnDSAdvancedPropsProc
*
*    PURPOSE:  Window proc for advanced property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnDSAdvancedPropsProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLong(hDlg,DWL_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        SetDSPropsUI(hDlg, propDSPropAdvanced);
        FillDSPropsUI(hDlg, propDSPropAdvanced, lpLSP);
        return TRUE;


    case WM_HELP:
#ifndef WIN16
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
#else
        WinHelp(    hDlg,
                    g_szWABHelpFileName,
                    HELP_CONTENTS,
                    0L );
#endif // !WIN16
        break;


#ifndef WIN16
	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
#endif // !WIN16


    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            if (!GetDSPropsFromUI(hDlg, propDSPropAdvanced, lpLSP))
            {
                //something failed ... abort this OK ... ie dont let them close
                SetWindowLong(hDlg,DWL_MSGRESULT, TRUE);
                return TRUE;
            }
            lpLSP->nRetVal = DSPROP_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            lpLSP->nRetVal = DSPROP_CANCEL;
            break;




        }

        return TRUE;
    }

    return bRet;

}

#endif // OLD_LDAP_UI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabexe\certprop.c ===
/*-----------------------------------------
//
// CertProp.C -- Displays Certificate File
//               Properties and Allows
///              Add Cert to WAB
//
//-----------------------------------------*/

#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "..\wab32res\resrc2.h"
#include <wincrypt.h>
#include <cryptdlg.h>
#include <cryptui.h>
#include "wabexe.h"

const UCHAR cszOID_PKIX_KP_EMAIL_PROTECTION[] = szOID_PKIX_KP_EMAIL_PROTECTION;
const UCHAR szRoot[] = "ROOT";
const UCHAR szCA[] = "CA";
const UCHAR szAB[] = "AddressBook";

#define iAddToWAB   0

// Test for PT_ERROR property tag
// #define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))
#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)

#define GET_PROC_ADDR(h, fn) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        Assert(VAR_##fn != NULL); \
        if(NULL == VAR_##fn ) { \
            VAR_##fn  = LOADER_##fn; \
        }

#define GET_PROC_ADDR_FLAG(h, fn, pflag) \
        VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
        *pflag = (VAR_##fn != NULL);

#undef LOADER_FUNCTION
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret LOADER_##name args1                         \
        {                                               \
           if (!DemandLoad##dll()) return err;          \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#ifdef DEBUG
void DebugTraceCertContextName(PCCERT_CONTEXT pcCertContext, LPTSTR lpDescription);
#endif

// *****************************************************************************************
// CRYPTDLG.DLL
// *****************************************************************************************
BOOL DemandLoadCryptDlg(void);
static HMODULE s_hCryptDlg = 0;

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

// *****************************************************************************************
// CRYPT32.DLL
// *****************************************************************************************
BOOL DemandLoadCrypt32(void);
static HMODULE s_hCrypt32 = 0;

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    FALSE, Crypt32)
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( HCERTSTORE, CertOpenSystemStoreA,
    (HCRYPTPROV hProv, LPCSTR szSubsystemProtocol),
    (hProv, szSubsystemProtocol),
    NULL, Crypt32)
#define CertOpenSystemStoreA VAR_CertOpenSystemStoreA

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    FALSE, Crypt32)
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPTSTR pszValueString, DWORD cszValueString),
    (dwValueType, pValue, pszValueString, cszValueString),
    0, Crypt32)
#define CertRDNValueToStrA VAR_CertRDNValueToStrA

LOADER_FUNCTION( PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwEncodingType, LPCSTR lpszStructType, const BYTE * pbEncoded, DWORD cbEncoded, DWORD dwFlags,
      void * pvStructInfo, DWORD * pcbStructInfo),
    (dwEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags,
      pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT * ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore


LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

// *****************************************************************************************
// ADVAPI.DLL
// *****************************************************************************************
BOOL DemandLoadAdvApi32(void);
static HMODULE s_hAdvApi = 0;


LOADER_FUNCTION(BOOL, CryptAcquireContextA,
    (HCRYPTPROV * phProv, LPCTSTR pszContainer, LPCTSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextA VAR_CryptAcquireContextA

LOADER_FUNCTION( BOOL, CryptReleaseContext,
    (HCRYPTPROV hProv, DWORD dwFlags),
    (hProv, dwFlags),
    FALSE, AdvApi32)
#define CryptReleaseContext VAR_CryptReleaseContext


// *****************************************************************************************
// Various Structures and typdefs
// *****************************************************************************************
typedef BLOB THUMBBLOB;

// This struct and tags will be published by the exchange group -- this is temporary.
#define NUM_CERT_TAGS       2
#define CERT_TAG_DEFAULT    0x20
#define CERT_TAG_THUMBPRINT 0x22
// SIZE_CERTTAGS is the size of the structure excluding the byte array.
#define SIZE_CERTTAGS       (2 * sizeof(WORD))

//N warnings, should probably just remove the []
#pragma warning (disable:4200)
typedef struct _CertTag
{
  WORD  tag;
  WORD  cbData;
  BYTE  rgbData[];
} CERTTAGS, FAR * LPCERTTAGS;
#pragma warning (default:4200)


#define LPARAM_SENTRY  0x424A4800
typedef struct _AB_DIALOG_PANE_PARAMS {
    DWORD dwSentry;                 // Must be set to value of LPARAM_SENTRY
    LPWABOBJECT lpWABObject;
    LPADRBOOK lpAdrBook;
    PCERT_CONTEXT * rgCertContext;  // array of cert context pointers
    ULONG cCertContexts;            // how many cert in rgCertContext
    ULONG iLeafCert;                // index in array of the leaf cert
    LPTSTR lpDisplayName;
    LPTSTR lpEmailAddress;
    HCRYPTPROV hCryptProv;
} AB_DIALOG_PANE_PARAMS, *LPAB_DIALOG_PANE_PARAMS;


static BOOL s_fCertViewPropertiesCryptUIA = FALSE;
BOOL DemandLoadCryptDlg(void) {
    BOOL fRet = TRUE;

    if (0 == s_hCryptDlg) {
        s_hCryptDlg = LoadLibrary("CRYPTDLG.DLL");

        if (0 == s_hCryptDlg) {
            DebugTrace("LoadLibrary of CRYPTDLG.DLL failed\n");
            fRet = FALSE;
        } else {
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
        }
    }
    return(fRet);
}


BOOL CryptUIAvailable(void) {
    DemandLoadCryptDlg();
    return(s_fCertViewPropertiesCryptUIA);
}


BOOL DemandLoadCrypt32(void) {
    BOOL fRet = TRUE;

    if (0 == s_hCrypt32) {
        s_hCrypt32 = LoadLibrary("CRYPT32.DLL");

        if (0 == s_hCrypt32) {
            DebugTrace("LoadLibrary of CRYPT32.DLL failed\n");
            fRet = FALSE;
        } else {
            GET_PROC_ADDR(s_hCrypt32, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt32, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt32, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt32, CertOpenSystemStoreA)
            GET_PROC_ADDR(s_hCrypt32, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt32, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt32, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt32, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt32, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt32, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt32, CertRDNValueToStrA)
            GET_PROC_ADDR(s_hCrypt32, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt32, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt32, CertAddCertificateContextToStore)
            GET_PROC_ADDR(s_hCrypt32, CertAddEncodedCertificateToStore)
        }
    }
    return(fRet);
}

BOOL DemandLoadAdvApi32(void) {
    BOOL fRet = TRUE;

    if (0 == s_hAdvApi) {
        s_hAdvApi = LoadLibrary("ADVAPI32.DLL");

        if (0 == s_hAdvApi) {
            DebugTrace("LoadLibrary of ADVAPI32.DLL failed\n");
            fRet = FALSE;
        } else {
            GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextA)
            GET_PROC_ADDR(s_hAdvApi, CryptReleaseContext)
        }
    }
    return(fRet);
}


/***************************************************************************

    Name      : IsThumbprintInMVPBin

    Purpose   : Check the PR_USER_X509_CERTIFICATE prop for this vsthumbprint

    Parameters: spv = prop value structure of PR_USER_X509_CERTIFICATE
                lpThumbprint -> THUMBBLOB structure to find

    Returns   : TRUE if found

    Comment   :

***************************************************************************/
BOOL IsThumbprintInMVPBin(SPropValue spv, THUMBBLOB * lpThumbprint) {
    ULONG cValues, i;
    LPSBinary lpsb = NULL;
    LPCERTTAGS lpCurrentTag;
    LPBYTE lpbTagEnd;


    if (! PROP_ERROR((spv))) {
        lpsb = spv.Value.MVbin.lpbin;
        cValues = spv.Value.MVbin.cValues;

        // Check for duplicates
        for (i = 0; i < cValues; i++) {
            lpCurrentTag = (LPCERTTAGS)lpsb[i].lpb;
            lpbTagEnd = (LPBYTE)lpCurrentTag + lpsb[i].cb;

            while ((LPBYTE)lpCurrentTag < lpbTagEnd) {
                // Check if this is the tag that contains the thumbprint
                if (CERT_TAG_THUMBPRINT == lpCurrentTag->tag) {
                    if ((lpThumbprint->cbSize == lpCurrentTag->cbData - SIZE_CERTTAGS) &&
                      ! memcmp(lpThumbprint->pBlobData, &lpCurrentTag->rgbData,
                      lpThumbprint->cbSize)) {
                        return(TRUE);
                    }
                }

                lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
            }
        }
    }
    return(FALSE);
}


/***************************************************************************

    Name      : HrBuildCertSBinaryData

    Purpose   : Takes as input all the data needed for a cert entry
                in PR_USER_X509_CERTIFICATE and returns a pointer to
                memory that contains all the input data in the correct
                format to be plugged in to the lpb member of an SBinary
                structure.  This memory should be Freed by the caller.


    Parameters: bIsDefault - TRUE if this is the default cert
                pblobCertThumbPrint - The actual certificate thumbprint
                lplpbData - receives the buffer with the data
                lpcbData - receives size of the data

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  THUMBBLOB*            pPrint,
  LPBYTE FAR*           lplpbData,
  ULONG FAR*            lpcbData)
{
    WORD        cbDefault, cbPrint;
    HRESULT     hr = S_OK;
    LPCERTTAGS  lpCurrentTag;
    ULONG       cbSize, cProps;
    LPBYTE      lpb = NULL;


    cbDefault   = sizeof(bIsDefault);
    cbPrint     = (WORD) pPrint->cbSize;
    cProps      = 2;
    cbSize      = cbDefault + cbPrint;
    cbSize += (cProps * SIZE_CERTTAGS);

    if (! (lpb = LocalAlloc(LPTR, cbSize))) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Set the default property
    lpCurrentTag = (LPCERTTAGS)lpb;
    lpCurrentTag->tag       = CERT_TAG_DEFAULT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbDefault;
    memcpy(&lpCurrentTag->rgbData, &bIsDefault, cbDefault);

    // Set the thumbprint property
    lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
    lpCurrentTag->tag       = CERT_TAG_THUMBPRINT;
    lpCurrentTag->cbData    = SIZE_CERTTAGS + cbPrint;
    memcpy(&lpCurrentTag->rgbData, pPrint->pBlobData, cbPrint);

    *lpcbData = cbSize;
    *lplpbData = lpb;
exit:
    return(hr);
}


/*  PVGetCertificateParam:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to get a parameter
**      from a certificate.  Give it a thing to get and it will alloc the mem.
**  Takes:
**      IN pCert            - CAPI certificate to query
**      IN dwParam          - parameter to find, ex: CERT_SHA1_HASH_PROP_ID
**      OUT OPTIONAL cbOut  - (def value of NULL) size of the returned PVOID
**  Returns:
**      data that was obtained, NULL if failed
*/
LPVOID PVGetCertificateParam(
    PCCERT_CONTEXT  pCert,
    DWORD           dwParam,
    DWORD          *cbOut)
{
    DWORD cbData;
    void *pvData = NULL;

    if (!pCert) {
        SetLastError((DWORD)E_INVALIDARG);
        goto ErrorReturn;
    }

    cbData = 0;
    CertGetCertificateContextProperty(pCert, dwParam, NULL, &cbData);
    if (! cbData || (! (pvData = LocalAlloc(LPTR, cbData)))) {
        DebugTrace("CertGetCertificateContextProperty -> %x\n", GetLastError());
        goto ErrorReturn;
    }

    if (! CertGetCertificateContextProperty(pCert, dwParam, pvData, &cbData)) {
        DebugTrace("CertGetCertificateContextProperty -> %x\n", GetLastError());
        goto ErrorReturn;
    }

exit:
    if (cbOut) {
        *cbOut = cbData;
    }
    return(pvData);

ErrorReturn:
    if (pvData) {
        LocalFree(pvData);
        pvData = NULL;
    }
    cbData = 0;
    goto exit;
}


/*
**
**  FUNCTION:   GetAttributeString
**
**  PURPOSE:    Get the string associated with the given attribute
**
**  PARAMETERS: lplpszAttributeString - pointer that will be LocalAlloc'ed
**                to hold the string.  Caller must LocalFree this!
**              pbEncoded - the encoded blob
**              cbEncoded - size of the encoded blob
**              lpszObjID - object ID of attribute to retrieve
**
**  RETURNS:    HRESULT.
**
**  HISTORY:
**  96/10/03  markdu  Created for WAB
**
*/
HRESULT GetAttributeString(LPTSTR FAR * lplpszAttributeString,
  BYTE *pbEncoded,
  DWORD cbEncoded,
  LPCSTR lpszObjID)
{
    HRESULT             hr = hrSuccess;
    BOOL                fRet;
    PCERT_RDN_ATTR      pRdnAttr;
    PCERT_NAME_INFO     pNameInfo = NULL;
    DWORD               cbInfo;
    DWORD               cbData;  //N need both?

    // Initialize so we know if any data was copied in.
    *lplpszAttributeString = NULL;

    // Get the size of the subject name data
    cbInfo = 0;
    CryptDecodeObject(
      X509_ASN_ENCODING,    // indicates X509 encoding
      (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
      pbEncoded,            // pointer to a buffer holding the encoded name
      cbEncoded,            // length in bytes of the encoded name
                            //N maybe can use nocopy flag
      0,                    // flags
      NULL,                 // NULL used when just geting length
      &cbInfo);             // length in bytes of the decoded name
    if (0 == cbInfo) {
        hr = GetLastError();
        goto exit;
    }

    // Allocate space for the decoded name
    if (! (pNameInfo = LocalAlloc(LPTR, cbInfo))) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Get the subject name
    if (! CryptDecodeObject(
      X509_ASN_ENCODING,    // indicates X509 encoding
      (LPCSTR)X509_NAME,    // flag indicating a name blob is to be decoded
      pbEncoded,            // pointer to a buffer holding the encoded name
      cbEncoded,            // length in bytes of the encoded name
      0,                    // flags
      pNameInfo,            // the buffer where the decoded name is written to
      &cbInfo)) {             // length in bytes of the decoded name
        hr = GetLastError();
        goto exit;
    }

    // Now we have a decoded name RDN array, so find the oid we want
    if (! (pRdnAttr = CertFindRDNAttr(lpszObjID, pNameInfo))) {
        hr = MAPI_E_NOT_FOUND;
        goto exit;
    }

    // We only handle certain types
    //N look to see if we should have a stack var for the ->
    if ((CERT_RDN_NUMERIC_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_PRINTABLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_IA5_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_VISIBLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_ISO646_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNIVERSAL_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_TELETEX_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNICODE_STRING != pRdnAttr->dwValueType)) {
        hr = MAPI_E_INVALID_PARAMETER;
        goto exit;
    }

    // Find out how much space to allocate.
    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            cbData = WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              NULL,
              0,
              NULL,
              NULL);
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            cbData = CertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              NULL,
              0);
            break;

        default:
            cbData = pRdnAttr->Value.cbData + 1;
            break;
    }

    // Allocate the space for the string.
    if (! (*lplpszAttributeString = LocalAlloc(LPTR, cbData))) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Copy the string
    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            if (FALSE == WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              *lplpszAttributeString,
              cbData,
              NULL,
              NULL))
            {
              DWORD dwErr = GetLastError();
              switch(dwErr)
              {
                case ERROR_INSUFFICIENT_BUFFER:
                  hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                  break;
                case ERROR_INVALID_PARAMETER:
                  hr = ResultFromScode(MAPI_E_INVALID_PARAMETER);
                  break;
                default:
                  hr = ResultFromScode(MAPI_E_CALL_FAILED);
                  break;
               }
               goto exit;
            }
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            CertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              *lplpszAttributeString,
              cbData);
            break;

        default:
            lstrcpyn(*lplpszAttributeString, (LPCSTR)pRdnAttr->Value.pbData, cbData);
            (*lplpszAttributeString)[cbData - 1] = '\0';
            break;
    }

exit:
    if (hr && *lplpszAttributeString) {
        LocalFree(*lplpszAttributeString);
        *lplpszAttributeString = NULL;
    }

    if (NULL != pNameInfo) {
        LocalFree(pNameInfo);
    }
    return(hr);
}


/***************************************************************************

    Name      : AddPropToMVPBin

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpWABObject -> WAB Object
                lpaProps -> array of properties
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpNew -> new data
                cbNew = size of lpbNew
                fNoDuplicates = TRUE if we should not add duplicates

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array lpbin the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPBin(LPWABOBJECT lpWABObject,
  LPSPropValue lpaProps,
  DWORD index,
  LPVOID lpNew,
  ULONG cbNew,
  BOOL fNoDuplicates)
{
    UNALIGNED SBinaryArray * lprgsbOld = NULL;
    SBinaryArray * lprgsbNew = NULL;
    LPSBinary lpsbOld = NULL;
    LPSBinary lpsbNew = NULL;
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;


    // Find the size of any existing MVP entries
    if (PT_ERROR == PROP_TYPE(lpaProps[index].ulPropTag)) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_BINARY, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgsbOld = &(lpaProps[index].Value.MVbin);
        lpsbOld = lprgsbOld->lpbin;

        cExisting = lprgsbOld->cValues;

        // Check for duplicates
        if (fNoDuplicates) {
            for (i = 0; i < cExisting; i++) {
                if (cbNew == lpsbOld[i].cb &&
                  ! memcmp(lpNew, lpsbOld[i].lpb, cbNew)) {
                    DebugTrace("AddPropToMVPBin found duplicate.\n");
                    return(hrSuccess);
                }
            }
        }

        cbMVP = cExisting * sizeof(SBinary);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(SBinary);   // room in the MVP for another Sbin

    // Allocate room for new MVP
    if (sc = lpWABObject->lpVtbl->AllocateMore(lpWABObject, cbMVP, lpaProps, (LPVOID*)&lpsbNew)) {
        DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lpsbNew[i].cb = lpsbOld[i].cb;
        lpsbNew[i].lpb = lpsbOld[i].lpb;
    }

    // Add the new property value
    // Allocate room for it
    if (sc = lpWABObject->lpVtbl->AllocateMore(lpWABObject, cbNew, lpaProps, (LPVOID*)&(lpsbNew[i].lpb))) {
        DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    lpsbNew[i].cb = cbNew;
    CopyMemory(lpsbNew[i].lpb, lpNew, cbNew);

    lpaProps[index].Value.MVbin.lpbin = lpsbNew;
    lpaProps[index].Value.MVbin.cValues = cExisting + 1;

    return(hResult);
}





// enum for ADRENTRY props
enum {
    irnPR_ENTRYID = 0,
    irnPR_DISPLAY_NAME,
    irnPR_EMAIL_ADDRESS,
    irnPR_OBJECT_TYPE,
    irnMax
};

// enum for getting the entryid of an entry
enum {
    itbdPR_USER_X509_CERTIFICATE,
    itbMax
};
static const SizedSPropTagArray(itbMax, ptaCert) =
{
    itbMax,
    {
        PR_USER_X509_CERTIFICATE,
    }
};


enum {
   iconPR_DEF_CREATE_MAILUSER = 0,
   iconMax
};
static const SizedSPropTagArray(iconMax, ptaCon)=
{
   iconMax,
   {
       PR_DEF_CREATE_MAILUSER,
   }
};

// enum for setting the created properties
enum {
    imuPR_DISPLAY_NAME = 0,     // must be first so DL's can use same enum
    imuPR_EMAIL_ADDRESS,
    imuPR_ADDRTYPE,
    imuMax
};
static const SizedSPropTagArray(imuMax, ptag)=
{
    imuMax,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
    }
};

// enum for getting the entryid of an entry
enum {
    ieidPR_ENTRYID,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEID)=
{
    ieidMax,
    {
        PR_ENTRYID,
    }
};




HRESULT HrAddCertsToWAB(HWND hwnd, LPWABOBJECT lpWABObject, LPADRBOOK lpAdrBook, HCRYPTPROV hCryptProv,
  PCERT_CONTEXT * rgCertContext, ULONG cCertContexts, ULONG iLeaf, LPTSTR lpDisplayName, LPTSTR lpEmailAddress)
{
    HRESULT         hr;
    SCODE           sc;
    BOOL            fFound;
    ULONG           cCerts;
    LPSPropValue    ppv = NULL;
    LPSPropValue    ppvEID = NULL;
    BOOL            fAlreadyHasCert;
    ULONG           ul;
    LPADRLIST       lpAdrList = NULL;
    LPMAILUSER      lpMailUser = NULL;
    ULONG           ulObjectType;
    LPBYTE          lpCertProp;
    ULONG           cbCertProp;
    LPSPropValue    ppvUndo = NULL;
    HCERTSTORE      hcAB = 0, hcCA = 0;
    PCCERT_CONTEXT  pccLeaf = NULL;
    THUMBBLOB       Thumbprint = {0};
    ULONG           i, iEntry;
    BOOL            fShowUI = TRUE;
    HCRYPTPROV      hProv = 0;
    SPropValue      spv[imuMax];
    ULONG           cbEIDWAB;
    LPENTRYID       lpEIDWAB = NULL;
    ULONG           cProps;
    LPSPropValue    lpCreateEIDs = NULL;
    LPABCONT        lpContainer = NULL;
    BOOL            fCreateNew = FALSE;


    if (! rgCertContext || ! lpAdrBook || ! lpWABObject) {
        return(ResultFromScode(E_FAIL));
    }

    DebugTrace("Certificate for '%s'. Email: '%s'\n", lpDisplayName, lpEmailAddress ? lpEmailAddress : szEmpty);


    if (! (hcCA = CertOpenSystemStoreA(hCryptProv, szCA))) {
        hr = GetLastError();
        goto exit;
    }

    if (! (hcAB = CertOpenSystemStore(hCryptProv, szAB))) {
        hr = GetLastError();
        goto exit;
    }

    // Add all the certs to the cert stores
    // Leaf goes in WAB store, others go in CA
    for (i = 0; i < cCertContexts; i++) {
        if (i == iLeaf) {
            if (CertAddCertificateContextToStore(hcAB,
              rgCertContext[i],
              CERT_STORE_ADD_REPLACE_EXISTING,
              &pccLeaf)) {
                // Get it's thumbprint
                if (! (Thumbprint.pBlobData = (BYTE *)PVGetCertificateParam(
                  pccLeaf,
                  CERT_HASH_PROP_ID,
                  &Thumbprint.cbSize))) {
                    goto exit;
                }
            } else {
                hr = GetLastError();
                DebugTrace("CertAddCertificateContextToStore -> %x\n", hr);
                goto exit;
            }
        } else {

            if (! CertAddCertificateContextToStore(hcCA,
              rgCertContext[i],
              CERT_STORE_ADD_REPLACE_EXISTING,
              NULL)) {
                DebugTrace("CertAddCertificateContextToStore -> %x\n", GetLastError());
                // Don't fail, just go on
            }
        }
    }

    if (sc = lpWABObject->lpVtbl->AllocateBuffer(lpWABObject,
      sizeof(ADRLIST) + 1 * sizeof(ADRENTRY), (LPVOID*)&lpAdrList)) {
        hr = ResultFromScode(sc);
        goto exit;
    }

    lpAdrList->cEntries = 1;
    lpAdrList->aEntries[0].ulReserved1 = 0;
    lpAdrList->aEntries[0].cValues = irnMax;

    // Allocate the prop array for the ADRENTRY
    if (sc = lpWABObject->lpVtbl->AllocateBuffer(lpWABObject,
      lpAdrList->aEntries[0].cValues * sizeof(SPropValue),
      (LPVOID*)&lpAdrList->aEntries[0].rgPropVals)) {
        hr = ResultFromScode(sc);
        goto exit;
    }

    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag = PR_ENTRYID;
    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb = 0;
    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb = NULL;

    lpAdrList->aEntries[0].rgPropVals[irnPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
    lpAdrList->aEntries[0].rgPropVals[irnPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER;


    if (lpDisplayName) {
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].Value.LPSZ = lpDisplayName;
    } else {
        lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_NULL;
    }
    if (lpEmailAddress) {
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS;
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].Value.LPSZ = lpEmailAddress;
    }  else {
        lpAdrList->aEntries[0].rgPropVals[irnPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
    }

    hr = lpAdrBook->lpVtbl->ResolveName(lpAdrBook,
      (ULONG_PTR)hwnd,
      MAPI_DIALOG | WAB_RESOLVE_LOCAL_ONLY | WAB_RESOLVE_ALL_EMAILS |
        WAB_RESOLVE_NO_ONE_OFFS | WAB_RESOLVE_NO_NOT_FOUND_UI,
      NULL,     // BUGBUG: name for NewEntry dialog?
      lpAdrList);

    switch (GetScode(hr)) {
        case SUCCESS_SUCCESS:   // Should be a resolved entry now
            // Should have PR_ENTRYID in rgPropVals[irnPR_ENTRYID]
            if (lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag == PR_ENTRYID) {
                if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                  lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb,
                  (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb,
                  NULL,
                  MAPI_MODIFY,  // ulFlags
                  &ulObjectType,
                  (LPUNKNOWN *)&lpMailUser))) {
                    DebugTrace("OpenEntry -> %x\n", GetScode(hr));
                    goto exit;
                }
            }
            break;

        case MAPI_E_NOT_FOUND:
            // no match, create one
            // Get the PAB object
            if (HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbEIDWAB, &lpEIDWAB))) {
                goto exit;  // Bad stuff here!
            }

            if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbEIDWAB,     // size of EntryID to open
              lpEIDWAB,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjectType,
              (LPUNKNOWN *)&lpContainer))) {
                goto exit;
            }

            // Get us the creation entryids
            if (hr = lpContainer->lpVtbl->GetProps(lpContainer, (LPSPropTagArray)&ptaCon, 0, &cProps, &lpCreateEIDs)) {
                goto exit;  // Bad stuff here!
            }

            if (HR_FAILED(hr = lpContainer->lpVtbl->CreateEntry(lpContainer,
              lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
              (LPENTRYID)lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
              0,        //CREATE_CHECK_DUP_STRICT
              (LPMAPIPROP *)&lpMailUser))) {
                goto exit;
            }

            // Successful creation of new entry.  Fill in email and displayname
            spv[imuPR_EMAIL_ADDRESS].ulPropTag      = PR_EMAIL_ADDRESS;
            spv[imuPR_EMAIL_ADDRESS].Value.lpszA    = lpEmailAddress;

            spv[imuPR_ADDRTYPE].ulPropTag           = PR_ADDRTYPE;
            spv[imuPR_ADDRTYPE].Value.lpszA         = "SMTP";
            spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
            spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpDisplayName;

            if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
              imuMax,                   // cValues
              spv,                      // property array
              NULL))) {                 // problems array
                DebugTrace("SetProps -> %x\n", GetScode(hr));
            }
            // Need to save so we can get an entryid later
            if (HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READWRITE))) {
                goto exit;
            }

            if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
              (LPSPropTagArray)&ptaEID, 0, &ul, &ppvEID))) {
                goto exit;
            }

            lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag = PR_ENTRYID;
            lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb =
              ppvEID[ieidPR_ENTRYID].Value.bin.cb;
            lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb =
              ppvEID[ieidPR_ENTRYID].Value.bin.lpb;

            fCreateNew = TRUE;
            break;

        case MAPI_E_USER_CANCEL:
            // cancel, don't update
        default:
            break;
    }

    if (lpMailUser) {
        // Got the entry, Set the cert property
        if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser, (LPSPropTagArray)&ptaCert, 0, &ul, &ppv))) {
            // Shouldn't happen, but if it does, we don't have a lpPropArray
            goto exit;
        }

        if (! IsThumbprintInMVPBin(ppv[0], &Thumbprint)) {
            if (HR_FAILED(hr = HrBuildCertSBinaryData(PROP_ERROR(ppv[0]),  // Default if there is no current value
              &Thumbprint,
              &lpCertProp,
              &cbCertProp))) {
                goto exit;
            }

            // Add the new thumbprint to PR_USER_X509_CERTIFICATE
            if (HR_FAILED(hr = AddPropToMVPBin(lpWABObject,
              ppv,          // prop array
              0,            // index of PR_USER_X509_CERTIFICATE in ppv
              lpCertProp,
              cbCertProp,
              TRUE))) {     // fNoDuplicates
                goto exit;
            }

            if (fShowUI) {
                // Save undo information
                if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser, (LPSPropTagArray)&ptaCert, 0,
                  &ul, &ppvUndo))) {
                    ppvUndo = NULL;
                }
            }

            if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser, 1, ppv, NULL))) {
                goto exit;
            }
            if (HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READWRITE))) {
                goto exit;
            }
        }

        if (fShowUI) {
            hr = lpAdrBook->lpVtbl->Details(lpAdrBook,
              (PULONG_PTR)&hwnd,
              NULL,
              NULL,
              lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb,
              (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb,
              NULL,
              NULL,
              NULL,
              0);
            if (ResultFromScode(hr) == MAPI_E_USER_CANCEL && (ppvUndo || fCreateNew)) {
                // Undo
                if (fCreateNew && lpContainer) {
                    ENTRYLIST EntryList;


                    EntryList.cValues = 1;
                    EntryList.lpbin = &lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin;

                    // Now, delete the entry found.
                    if (hr = lpContainer->lpVtbl->DeleteEntries(lpContainer, &EntryList, 0)) {
                        goto exit;
                    }
                } else {
                    // Not a new entry, restore the original cert props
                    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser, 1, ppvUndo, NULL))) {
                        goto exit;
                    }
                    if (HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, 0))) {
                        goto exit;
                    }
                }
            }
        }
    }

exit:
    if (lpAdrList) {
        for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry)
        {
            if(lpAdrList->aEntries[iEntry].rgPropVals)
                lpWABObject->lpVtbl->FreeBuffer(lpWABObject,
                  lpAdrList->aEntries[iEntry].rgPropVals);
        }
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, lpAdrList);
        lpAdrList = NULL;
    }

    if (lpCreateEIDs) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, lpCreateEIDs);
    }

    if (ppvEID) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, ppvEID);
    }

    if (lpEIDWAB) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, lpEIDWAB);
    }

    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
    }

    if (lpMailUser) {
        lpMailUser->lpVtbl->Release(lpMailUser);
    }

    if (ppv) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, ppv);
    }

    if (ppvUndo) {
        lpWABObject->lpVtbl->FreeBuffer(lpWABObject, ppvUndo);
    }

    if (Thumbprint.pBlobData) {
        LocalFree(Thumbprint.pBlobData);
    }

    if (pccLeaf) {
        CertFreeCertificateContext(pccLeaf);
    }

    if (hcAB) {
        CertCloseStore(hcAB, 0);
    }

    if (hcCA) {
        CertCloseStore(hcCA, 0);
    }

    return(hr);
}


//*******************************************************************
//
//  FUNCTION:   ReadDataFromFile
//
//  PURPOSE:    Read data from a file.
//
//  PARAMETERS: lpszFileName - name of file containing the data to be read
//              ppbData - receives the data that is read
//              pcbData - receives the size of the data that is read
//
//  RETURNS:    HRESULT
//
//  HISTORY:
//  96/12/16  markdu  Created.
//
//*******************************************************************
HRESULT ReadDataFromFile(
  LPCSTR      lpszFileName,
  PBYTE*      ppbData,
  PDWORD      pcbData)
{
    HRESULT             hr = hrSuccess;
    BOOL                fRet;
    HANDLE              hFile = 0;
    DWORD               cbFile;
    DWORD               cbData;
    PBYTE               pbData = 0;

    if ((NULL == ppbData) || (NULL == pcbData)) {
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    // Open the file and find out how big it is
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
      lpszFileName,
      GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      0,
      NULL))) {
        hr = ResultFromScode(MAPI_E_DISK_ERROR);
        goto error;
    }

    cbData = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbData) {
        hr = ResultFromScode(MAPI_E_DISK_ERROR);
        goto error;
    }

    if (NULL == (pbData = (BYTE *)LocalAlloc(LMEM_ZEROINIT, cbData))) {
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto error;
    }

    if (! ReadFile(
      hFile,                      // handle of file to read
      pbData,                     // address of buffer that receives data
      cbData,                     // number of bytes to read
      &cbFile,                    // address of number of bytes read
      NULL)) {                    // address of structure for data
        hr = ResultFromScode(MAPI_E_DISK_ERROR);
        goto error;
    }

    if (cbData != cbFile) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
        goto error;
    }

    *ppbData = pbData;
    *pcbData = cbData;

out:
    if (hFile) {
        CloseHandle(hFile);
    }

    return(hr);

error:
    // BUGBUG some of the GetLastError calls above may not have worked.
    if (hrSuccess == hr) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
    }

    goto out;
}



LPAB_DIALOG_PANE_PARAMS GetLParamFromPropSheetPage(PROPSHEETPAGE *ps) {
    LONG lparam;
    LPAB_DIALOG_PANE_PARAMS lpABDialogPaneParams;
    ULONG i;

    lpABDialogPaneParams = (LPAB_DIALOG_PANE_PARAMS)(ps->lParam);
    if (lpABDialogPaneParams->dwSentry != LPARAM_SENTRY) {
        // Assume that CryptUI has passed us a wrapped lparam/cert pair
        // typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
        //    LPARAM          lParam;
        //    PCCERT_CONTEXT  pCertContext;
        // } CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;

        PCRYPTUI_INITDIALOG_STRUCT pCryptUIInitDialog = (PCRYPTUI_INITDIALOG_STRUCT)lpABDialogPaneParams;
        lpABDialogPaneParams = (LPAB_DIALOG_PANE_PARAMS )pCryptUIInitDialog->lParam;
        if (lpABDialogPaneParams->dwSentry != LPARAM_SENTRY) {
            // Bad lparam
            return(NULL);
        }
    }
    return(lpABDialogPaneParams);
}



INT_PTR CALLBACK ViewPageAddressBook(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL                fTrust;
    HANDLE              hGraphic;
    DWORD               i;
    PCCERT_CONTEXT      pccert;
    PROPSHEETPAGE *     ps;
    WCHAR               rgwch[200];
    UINT                rguiStrings[7];
    LPAB_DIALOG_PANE_PARAMS lpABDialogPaneParams;
    PROPSHEETPAGE *     lpps;

    switch ( msg ) {
        case WM_INITDIALOG:
            // Get access to the parameters
        lpps = (PROPSHEETPAGE *)lParam;
        lpABDialogPaneParams = GetLParamFromPropSheetPage(lpps);
        if (! lpABDialogPaneParams) {
            return(FALSE);
        }
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)lpABDialogPaneParams);

        return TRUE;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) {
                case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_RESET:
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;
            }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDC_ADD_TO_ADDRESS_BOOK) {
                HRESULT hr = ResultFromScode(MAPI_E_CALL_FAILED);
                lpABDialogPaneParams = (LPAB_DIALOG_PANE_PARAMS)GetWindowLongPtr(hwndDlg, DWLP_USER);

                if (lpABDialogPaneParams) {
                    hr = HrAddCertsToWAB(hwndDlg, lpABDialogPaneParams->lpWABObject,
                      lpABDialogPaneParams->lpAdrBook,
                      lpABDialogPaneParams->hCryptProv,
                      lpABDialogPaneParams->rgCertContext,
                      lpABDialogPaneParams->cCertContexts,
                      lpABDialogPaneParams->iLeafCert,
                      lpABDialogPaneParams->lpDisplayName,
                      lpABDialogPaneParams->lpEmailAddress);
                }

                return TRUE;
            }
            else if (LOWORD(wParam) == IDHELP) {
                    return TRUE;
            }
            break;
    }
    return FALSE;
}


//*******************************************************************
//
//  FUNCTION:   CertFileDisplay
//
//  PURPOSE:    Display the certificate properties of a pkcs7 file
//
//  PARAMETERS: hwnd = parent window handle
//              lpWABObject -> wab object
//              lpAdrBook -> Adrbook object
//              lpFileName -> Cert filename
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT CertFileDisplay(HWND hwnd,
  LPWABOBJECT lpWABObject,
  LPADRBOOK lpAdrBook,
  LPTSTR lpFileName) {
    HCRYPTPROV hCryptProvider = 0;
    HRESULT hr;
    CERT_CONTEXT CertContext;
    LPBYTE lpBuf = NULL;
    ULONG cbData = 0, cCert;
    HCRYPTMSG hMsg = NULL;
    PCERT_CONTEXT * rgCertContext = NULL;
    DWORD dwIssuerFlags = 0;
    ULONG i, j;
    PCCERT_CONTEXT pcCertContextTarget = NULL, pcCertContextIssuer;
    PCERT_INFO pCertInfoTarget = NULL;
    HCERTSTORE hCertStoreMsg = NULL;
    BOOL fFound = FALSE, fIssuer;
    PROPSHEETPAGE PSPage;
    TCHAR szTitle[MAX_RESOURCE_STRING + 1];
    TCHAR szABPaneTitle[MAX_RESOURCE_STRING + 1];
    AB_DIALOG_PANE_PARAMS ABDialogPaneParams;
    PCERT_INFO pCertInfo;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    LPTSTR rgPurposes[1] = {(LPTSTR)&cszOID_PKIX_KP_EMAIL_PROTECTION};


    // Get the crypt provider context
    if (! CryptAcquireContext(
      &hCryptProvider,
      NULL,
      NULL,
      PROV_RSA_FULL,
      CRYPT_VERIFYCONTEXT)) {
        hr = GetLastError();
        goto exit;
    }


    // Read the data from the file.
    if (hr = ReadDataFromFile(lpFileName, &lpBuf, &cbData)) {
        goto exit;
    }

    if (! (hMsg = CryptMsgOpenToDecode(
      PKCS_7_ASN_ENCODING,
      0,                          // dwFlags
      0,                          // dwMsgType
      hCryptProvider,
      NULL,                       // pRecipientInfo (not supported)
      NULL))) {                      // pStreamInfo (not supported)
        hr = GetLastError();
        DebugTrace("CryptMsgOpenToDecode(PKCS_7_ASN_ENCODING) -> 0x%08x\n", GetScode(hr));
        goto exit;
    }

    if (! CryptMsgUpdate(hMsg, lpBuf, cbData, TRUE)) {
        hr = GetLastError();
        DebugTrace("CryptMsgUpdate -> 0x%08x\n", GetScode(hr));
        goto exit;
    }

    cbData = sizeof(cCert);
    if (! CryptMsgGetParam(
      hMsg,
      CMSG_CERT_COUNT_PARAM,        // dwParamType
      0,                            // dwIndex
      (void *)&cCert,
      &cbData)) {                     // pcbData
        hr = GetLastError();
        DebugTrace("CryptMsgGetParam(CMSG_CERT_COUNT_PARAM) -> 0x%08x\n", GetScode(hr));
        goto exit;
    }
    if (cbData != sizeof(cCert)) {
        hr = ResultFromScode(MAPI_E_CALL_FAILED);
        goto exit;
    }


    // Look for cert that's a "Leaf" node.
    // Unfortunately, there is no easy way to tell, so we'll have
    // to loop through each cert, checking to see if it is an issuer of any other cert
    // in the message.  If it is not an issuer of any other cert, it must be the leaf cert.
    //
    if (! (hCertStoreMsg = CertOpenStore(
      CERT_STORE_PROV_MSG,
      X509_ASN_ENCODING,
      hCryptProvider,
      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
      hMsg))) {
        hr = GetLastError();
        DebugTrace("CertOpenStore(msg) -> %x\n", hr);
        goto exit;
    } else {
        if (! (rgCertContext = LocalAlloc(LPTR, cCert * sizeof(PCERT_CONTEXT)))) {
            DebugTrace("LocalAlloc of cert table -> %u\n", GetLastError());
            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }

        // Enumerate all certs on this message
        i = 0;
        while (pcCertContextTarget = CertEnumCertificatesInStore(hCertStoreMsg,
          pcCertContextTarget)) {

            rgCertContext[i] = (PCERT_CONTEXT)CertDuplicateCertificateContext(
              pcCertContextTarget);

#ifdef DEBUG
            DebugTraceCertContextName(rgCertContext[i], "Found Cert:");
#endif
            i++;
        };

        // Now we've got a table full of certs
        for (i = 0; i < cCert; i++) {
            pCertInfoTarget = rgCertContext[i]->pCertInfo;
            fIssuer = FALSE;

            for (j = 0; j < cCert; j++) {
                if (i != j) {
                    dwIssuerFlags = 0;

                    if (pcCertContextIssuer = CertGetIssuerCertificateFromStore(hCertStoreMsg,
                      rgCertContext[j],
                      NULL,
                      &dwIssuerFlags)) {

                        // Found an issuer
                        // Is it the same as the target?
                        fIssuer = CertCompareCertificate(X509_ASN_ENCODING,
                          pCertInfoTarget,   // target
                          pcCertContextIssuer->pCertInfo);     // test issuer

                        CertFreeCertificateContext(pcCertContextIssuer);

                        if (fIssuer) {
                            // This test cert is issued by the target, so
                            // we know that Target is NOT a leaf cert
                            break;
                        } // else, loop back to the enumerate where the test cert context will be freed.
                    }
                }
            }

            if (! fIssuer) {
                DebugTrace("Found a Cert which is not an issuer.\n");
#ifdef DEBUG
                DebugTraceCertContextName(rgCertContext[i], "Non-issuer cert:");
#endif
                // What is the email and display name of the leaf cert?

                pCertInfo = rgCertContext[i]->pCertInfo;

                GetAttributeString(&ABDialogPaneParams.lpDisplayName,
                  pCertInfo->Subject.pbData,
                  pCertInfo->Subject.cbData,
                  szOID_COMMON_NAME);

                GetAttributeString(&ABDialogPaneParams.lpEmailAddress,
                  pCertInfo->Subject.pbData,
                  pCertInfo->Subject.cbData,
                  szOID_RSA_emailAddr);

                ABDialogPaneParams.lpWABObject = lpWABObject;
                ABDialogPaneParams.lpAdrBook = lpAdrBook;
                ABDialogPaneParams.hCryptProv = hCryptProvider;
                ABDialogPaneParams.rgCertContext = rgCertContext;
                ABDialogPaneParams.cCertContexts = cCert;
                ABDialogPaneParams.iLeafCert = i;
                ABDialogPaneParams.dwSentry = LPARAM_SENTRY;

                memset(&PSPage, 0, sizeof(PROPSHEETPAGE));

                PSPage.dwSize = sizeof(PSPage);
                PSPage.dwFlags = 0;     // PSP_HASHELP;
                PSPage.hInstance = hInst;
                PSPage.pszTemplate = MAKEINTRESOURCE(IDD_CERTPROP_ADDRESS_BOOK);
                PSPage.hIcon = 0;
                LoadString(hInst, idsAddToABPaneTitle, szABPaneTitle, sizeof(szABPaneTitle));
                PSPage.pszTitle = szABPaneTitle;
                PSPage.pfnDlgProc = ViewPageAddressBook;
                PSPage.lParam = (LPARAM)&ABDialogPaneParams;       // (DWORD) &viewhelp;
                PSPage.pfnCallback = 0;
                PSPage.pcRefParent = NULL;

                {
                    CERT_VIEWPROPERTIES_STRUCT_A cvps = {0};

                    // Fill in the cert view struct
                    cvps.dwSize = sizeof(CERT_VIEWPROPERTIES_STRUCT);
                    cvps.hwndParent = hwnd;
                    cvps.hInstance = hInst;
                    cvps.dwFlags = CM_ADD_CERT_STORES;      // Look in rghstoreCAs
                    LoadString(hInst, idsCertificateViewTitle, szTitle, sizeof(szTitle));
                    cvps.szTitle = szTitle;
                    cvps.pCertContext = rgCertContext[i];
                    cvps.nStartPage = iAddToWAB;    // show add to WAB page first
                    cvps.arrayPurposes = rgPurposes;
                    cvps.cArrayPurposes = 1;
                    cvps.cStores = 1;                       // Count of other stores to search
                    cvps.rghstoreCAs = &hCertStoreMsg;      // Array of other stores to search
                    cvps.hprov = hCryptProvider;          // Provider to use for verification

                    cvps.cArrayPropSheetPages = 1;
                    cvps.arrayPropSheetPages = &PSPage;

                    if (! CertViewPropertiesA(&cvps)) {
                        hr = GetLastError();
                    }
                }


                fFound = TRUE;
                break;  // done with loop
            }
        }

        // Free the table of certs
        for (i = 0; i < cCert; i++) {
            if (rgCertContext[i]) {
                CertFreeCertificateContext(rgCertContext[i]);
            }
        }
        LocalFree((LPVOID)rgCertContext);

        if (! fFound) {
            // Didn't find a cert that isn't an issuer.  Fail.
            hr = ResultFromScode(MAPI_E_NOT_FOUND);
            goto exit;
        }
    }


exit:
    if (hCryptProvider) {
        CryptReleaseContext(hCryptProvider, 0);
    }

    return(hr);
}



/* DebugTrapFn -------------------------------------------------------------- */
#ifdef DEBUG
#if defined(WIN32) && !defined(_MAC)

typedef struct {
	char *		sz1;
	char *		sz2;
	UINT		rgf;
	int			iResult;
} MBContext;

DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
   pmbc->iResult = MessageBoxA(NULL, pmbc->sz1, pmbc->sz2,
       pmbc->rgf | MB_SETFOREGROUND);

	return(0);
}

int MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
	HANDLE		hThread;
	DWORD		dwThreadId;
	MBContext	mbc;

	mbc.sz1		= sz1;
	mbc.sz2		= sz2;
	mbc.rgf		= rgf;
	mbc.iResult = IDRETRY;

   MessageBoxFnThreadMain(&mbc);
	return(mbc.iResult);
}
#else
#define MessageBoxFn(sz1, sz2, rgf)		MessageBoxA(NULL, sz1, sz2, rgf)
#endif

void FAR CDECL DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) {
	char	sz[512];
	va_list	vl;

	#if defined(WIN16) || defined(WIN32)
	int		id;
	#endif

	lstrcpyA(sz, "++++ WAB Debug Trap (");
//	_strdate(sz + lstrlenA(sz));
//	lstrcatA(sz, " ");
//	_strtime(sz + lstrlenA(sz));
	lstrcatA(sz, ")\n");
	DebugTrace(sz);

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

	DebugTrace(sz);

	#if defined(DOS)
	_asm { int 3 }
	#endif

#if defined(WIN16) || defined(WIN32)
	/* Hold down control key to prevent MessageBox */
	if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
	{
		UINT uiFlags = MB_ABORTRETRYIGNORE;

		if (fFatal)
			uiFlags |= MB_DEFBUTTON1;
		else
			uiFlags |= MB_DEFBUTTON3;

		#ifdef WIN16
		uiFlags |= MB_ICONEXCLAMATION | MB_SYSTEMMODAL;
		#else
		uiFlags |= MB_ICONSTOP | MB_TASKMODAL;
		#endif

#ifndef MAC
		id = MessageBoxFn(sz, "WAB Debug Trap", uiFlags);

		if (id == IDABORT)
			*((LPBYTE)NULL) = 0;
		else if (id == IDRETRY)
			DebugBreak();
#endif // MAC			
	}
#endif
}
#endif

/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
#ifdef DEBUG
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];


    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
    OutputDebugString(String);
}
#endif

#ifdef DEBUG
//*******************************************************************
void DebugTraceCertContextName(PCCERT_CONTEXT pcCertContext, LPTSTR lpDescription) {
    LPTSTR lpName = NULL;
    PCERT_INFO pCertInfo = pcCertContext->pCertInfo;
#ifdef OLD_STUFF
    GetAttributeString(
      &lpName,
      pCertInfo->Subject.pbData,
      pCertInfo->Subject.cbData,
      szOID_COMMON_NAME);
    if (! lpName) {
        GetAttributeString(
          &lpName,
          pCertInfo->Subject.pbData,
          pCertInfo->Subject.cbData,
          szOID_ORGANIZATION_NAME);
    }

    DebugTrace("%s %s\n", lpDescription, lpName ? lpName : "<unknown>");
    if (lpName) {
        LocalFree(lpName);
    }
#endif // OLD_STUFF
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dead\ui_modfy.c ===
/*--------------------------------------------------------------
*
*
*   ui_modfy.c - contains stuff for showing the LDAP Directory
*                   modification dialog ..
*
*
*
*
*
*
--------------------------------------------------------------*/
#include "_apipch.h"


extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;


//$$///////////////////////////////////////////////////////////////////////////////
//
// HrShowDirectoryServiceModificationDlg - Shows the main dialog with the list
// of directory services and with a prop sheet for changing check order
//
//  hWndParent - Parent for this dialog
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent)
{
    ACCTLISTINFO ali;
    HRESULT hr = hrSuccess;
    IImnAccountManager * lpAccountManager;

    // Make sure there is an account manager
    if (hr = InitAccountManager(&lpAccountManager)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = (ACCTTYPE)-1;
    ali.dwAcctFlags = ACCT_FLAG_DIR_SERV;
    ali.dwFlags = 0;
    hr = lpAccountManager->lpVtbl->AccountListDialog(lpAccountManager,
      hWndParent,
      &ali);

out:
    return hr;
}



/**

//$$///////////////////////////////////////////////////////////////////////////////
//
// ReadLDAPServerKey - Reads any Server names stored in the given registry key..
//
//  The server names are stored in the registry as multiple strings seperated with
//      a '\0' with 2 '\0' at the end
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ReadLDAPServerKey(HWND hWndLV, LPTSTR szValueName)
{
    BOOL bRet = FALSE;
    IImnAccountManager * lpAccountManager = NULL;
    LPSERVER_NAME lpServerNames = NULL, lpNextServer;


    // Enumerate the LDAP accounts
    if (InitAccountManager(&lpAccountManager)) {
        goto exit;
    }

    if (EnumerateLDAPtoServerList(lpAccountManager, &lpServerNames, NULL)) {
        goto exit;
    }


    // Add the accounts to the list box in order.
    lpNextServer = lpServerNames;
    while (lpNextServer) {
        LPSERVER_NAME lpPreviousServer = lpNextServer;

        LDAPListAddItem(hWndLV, lpNextServer->lpszName);
        lpNextServer = lpNextServer->lpNext;

        LocalFreeAndNull(&lpPreviousServer->lpszName);
        LocalFreeAndNull(&lpPreviousServer);
    }

    bRet = TRUE;

exit:
    return(bRet);
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// WriteLDAPServerKey - Saves Edited names to the Registry key
//
/////////////////////////////////////////////////////////////////////////////////
void WriteLDAPServerKey(HWND hWndLV, LPTSTR szValueName)
{
    ULONG cbLDAPServers = 0;
    ULONG cbExists = 0;
    ULONG i=0;
    TCHAR szBuf[MAX_UI_STR + 1];
    HRESULT   hResult = hrSuccess;
    IImnAccountManager * lpAccountManager = NULL;


    // Enumerate the LDAP accounts
    if (hResult = InitAccountManager(&lpAccountManager)) {
        goto exit;
    }

    cbLDAPServers = ListView_GetItemCount(hWndLV);

    cbExists = 0;

    for (i = 0; i < cbLDAPServers; i++) {
        szBuf[0]='\0';
        ListView_GetItemText(hWndLV, i, 0, szBuf, sizeof(szBuf));

        SetLDAPServerOrder(lpAccountManager, szBuf, i + 1);
    }

    // We've set them all, reset the next ServerID:
    GetLDAPNextServerID(i);
exit:

    return;
}


**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\dead\ui_cert.c ===
/**********************************************************************************
*
*
*   UI_CERT.C - contains functions for displaying certificates
*
*   **************THIS IS DEAD CODE***************************
*
**********************************************************************************/

#include "_apipch.h"

#ifdef OLD_STUFF

extern HINSTANCE ghCommCtrlDLLInst;
extern LPPROPERTYSHEET        gpfnPropertySheet;
extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;

enum _CERTS
{
    CERT_ERROR=0,
    CERT_OK,
    CERT_CANCEL
};

enum _CertPropSheets
{
    propCertGeneral=0,
    propCertTrust,
    propCertAdvanced,
    propCertMAX
};

typedef struct _CertParam
{
    LPCERT_DISPLAY_PROPS lpCDP;
    int nRetVal;
} CERT_PARAM, * LPCERT_PARAM;


int CreateCertPropertySheet( HWND hwndOwner, LPCERT_PARAM lpcp);

BOOL APIENTRY_16 fnCertGeneralProc(HWND hDlg,UINT message,UINT wParam,LPARAM lParam);
BOOL APIENTRY_16 fnCertTrustProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam);
BOOL APIENTRY_16 fnCertAdvancedProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam);

BOOL FillCertPropsUI( HWND hDlg,
                    int nPropSheet,
                    LPCERT_PARAM lpcp);

BOOL GetCertPropsFromUI(HWND hDlg, LPCERT_PARAM lpcp);

BOOL SetCertPropsUI(HWND hDlg, int nPropSheet);


#define EDIT_LEN   MAX_UI_STR

/***
static DWORD rgCertPropsHelpIDs[] =
{
    IDC_LDAP_PROPS_STATIC_NAME,         IDH_WABLDAP_DIRSSERV_NAME,
    IDC_LDAP_PROPS_EDIT_NAME,           IDH_WABLDAP_DIRSSERV_NAME,
    //IDC_LDAP_PROPS_FRAME,
    IDC_LDAP_PROPS_RADIO_ANON,          IDH_WABLDAP_DIRSSERV_AUTH_ANON,
    IDC_LDAP_PROPS_RADIO_USERPASS,      IDH_WABLDAP_DIRSSERV_AUTH_PASS,
    IDC_LDAP_PROPS_STATIC_USERNAME,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_EDIT_USERNAME,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME,
    IDC_LDAP_PROPS_STATIC_PASSWORD,     IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_EDIT_PASSWORD,       IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS,
    IDC_LDAP_PROPS_STATIC_PASSWORD2,    IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    IDC_LDAP_PROPS_EDIT_CONFIRMPASSWORD,IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF,
    //IDC_LDAP_PROPS_FRAME2,
    IDC_LDAP_PROPS_STATIC_CONNECTION,   IDH_WABLDAP_CONNECT_TIMEOUT,
    IDC_LDAP_PROPS_EDIT_CONNECTION,     IDH_WABLDAP_CONNECT_TIMEOUT,
    IDC_LDAP_PROPS_STATIC_SEARCH,       IDH_WABLDAP_SEARCH_TIMEOUT,
    IDC_LDAP_PROPS_EDIT_SEARCH,         IDH_WABLDAP_SEARCH_TIMEOUT,
    //IDC_LDAP_PROPS_FRAME_NUMRESULTS,    IDH_WABLDAP_SEARCH_LIMIT,
    IDC_LDAP_PROPS_STATIC_NUMRESULTS,   IDH_WABLDAP_SEARCH_LIMIT,
    IDC_LDAP_PROPS_EDIT_NUMRESULTS,     IDH_WABLDAP_SEARCH_LIMIT,
    0,0
};
/***/


///////////////////////////////////////////////////////////////////
//
//  HrShowCertProps - shows properties on a certificate
//
//  hWndParent - hWnd of Parent
//  lpCDP - pointer to a certificate info
//
///////////////////////////////////////////////////////////////////
HRESULT HrShowCertProps(HWND   hWndParent,
                        LPCERT_DISPLAY_PROPS lpCDP)
{

    HRESULT hr = E_FAIL;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i = 0, j = 0;
    CERT_PARAM cp;

    DebugPrintTrace(("----------\nHrShowCertProps Entry\n"));

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    // <TBD> - error check lpCDP
    cp.lpCDP = lpCDP;
    cp.nRetVal = CERT_ERROR;

    if (CreateCertPropertySheet(hWndParent, &cp) == -1)
    {
        // Something failed ...
        hr = E_FAIL;
        goto out;
    }

    switch(cp.nRetVal)
    {
    case CERT_OK:
        hr = S_OK;
        break;
    case CERT_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case CERT_ERROR:
        hr = E_FAIL;
        break;
    }

out:

    return hr;
}


/****************************************************************************
*    FUNCTION: CreateCertPropertySheet(HWND)
*
*    PURPOSE:  Creates the Cert property sheet
*
****************************************************************************/
int CreateCertPropertySheet(HWND hwndOwner, LPCERT_PARAM lpcp)
{
    PROPSHEETPAGE psp[propCertMAX];
    PROPSHEETHEADER psh;
    TCHAR szTitle[propCertMAX][MAX_UI_STR];
    TCHAR szCaption[MAX_UI_STR];

    // General
    psp[propCertGeneral].dwSize = sizeof(PROPSHEETPAGE);
    psp[propCertGeneral].dwFlags = PSP_USETITLE;
    psp[propCertGeneral].hInstance = hinstMapiX;
    psp[propCertGeneral].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_CERT_GENERAL);
    psp[propCertGeneral].pszIcon = NULL;
    psp[propCertGeneral].pfnDlgProc = (DLGPROC) fnCertGeneralProc;
    LoadString(hinstMapiX, idsCertGeneralTitle, szTitle[propCertGeneral], sizeof(szTitle[propCertGeneral]));
    psp[propCertGeneral].pszTitle = szTitle[propCertGeneral];
    psp[propCertGeneral].lParam = (LPARAM) lpcp;

    // Trust
    psp[propCertTrust].dwSize = sizeof(PROPSHEETPAGE);
    psp[propCertTrust].dwFlags = PSP_USETITLE;
    psp[propCertTrust].hInstance = hinstMapiX;
    psp[propCertTrust].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_CERT_TRUST);
    psp[propCertTrust].pszIcon = NULL;
    psp[propCertTrust].pfnDlgProc = (DLGPROC) fnCertTrustProc;
    LoadString(hinstMapiX, idsCertTrustTitle, szTitle[propCertTrust], sizeof(szTitle[propCertTrust]));
    psp[propCertTrust].pszTitle = szTitle[propCertTrust];
    psp[propCertTrust].lParam = (LPARAM) lpcp;

    // Advanced
    psp[propCertAdvanced].dwSize = sizeof(PROPSHEETPAGE);
    psp[propCertAdvanced].dwFlags = PSP_USETITLE;
    psp[propCertAdvanced].hInstance = hinstMapiX;
    psp[propCertAdvanced].pszTemplate = MAKEINTRESOURCE(IDD_DIALOG_CERT_ADVANCED);
    psp[propCertAdvanced].pszIcon = NULL;
    psp[propCertAdvanced].pfnDlgProc = (DLGPROC) fnCertAdvancedProc;
    LoadString(hinstMapiX, idsCertAdvancedTitle, szTitle[propCertAdvanced], sizeof(szTitle[propCertAdvanced]));
    psp[propCertAdvanced].pszTitle = szTitle[propCertAdvanced];
    psp[propCertAdvanced].lParam = (LPARAM) lpcp;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, idsCertPropertyTitleCaption, szCaption, sizeof(szCaption));
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.nStartPage = propCertGeneral;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (gpfnPropertySheet(&psh));
}


/****************************************************************************
*    FUNCTION: SetCertPropsUI(HWND)
*
*    PURPOSE:  Sets up the UI for this PropSheet
*
****************************************************************************/
BOOL SetCertPropsUI(HWND hDlg, int nPropSheet)
{
    ULONG i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    switch(nPropSheet)
    {
    case propCertGeneral:
        break;


    case propCertTrust:
        {
            HWND hWndTree = GetDlgItem(hDlg, IDC_CERT_TRUST_TREE_CHAIN);
            HIMAGELIST hImg = gpfnImageList_LoadImage(
                                            hinstMapiX, 	
                                            MAKEINTRESOURCE(IDB_CERT),
                                            32,
                                            0,
                                            RGB_TRANSPARENT,
                                            IMAGE_BITMAP, 	
                                            0);

	        // Associate the image lists with the list view control.
	        TreeView_SetImageList (hWndTree, hImg, TVSIL_NORMAL);

        }
        break;


    case propCertAdvanced:
        {
            LV_COLUMN lvC;               // list view column structure
	        RECT rc;
            HWND hWndLV = GetDlgItem(hDlg, IDC_CERT_ADVANCED_LIST_FIELD);

            ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT);
	        GetWindowRect(hWndLV,&rc);
	        lvC.mask = LVCF_FMT | LVCF_WIDTH;
            lvC.fmt = LVCFMT_LEFT;   // left-align column
	        lvC.cx = rc.right - rc.left - 20; //TBD
	        lvC.pszText = NULL;
            lvC.iSubItem = 0;
            ListView_InsertColumn (hWndLV, 0, &lvC);
        }
        break;
    }

    return TRUE;
}


enum _TrustString
{
    indexTrusted=0,
    indexNotTrusted,
    //N TODO: CHAINS
    //indexChainTrusted
};




/****************************************************************************
*    FUNCTION: UpdateValidInvalidStatus(HWND, lpCDP)
*
*    PURPOSE:  Fills in the trust/valididyt related items on the property sheet
*
****************************************************************************/
void UpdateValidInvalidStatus(HWND hDlg, LPCERT_PARAM lpcp)
{
    TCHAR szBuf[MAX_UI_STR];

    // Set the status info
    if(lpcp->lpCDP->bIsExpired || lpcp->lpCDP->bIsRevoked || !lpcp->lpCDP->bIsTrusted)
    {
        LoadString(hinstMapiX, idsCertInvalid, szBuf, sizeof(szBuf));
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_UNCHECK), SW_SHOWNORMAL);
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_CHECK), SW_HIDE);
    }
    else
    {
        LoadString(hinstMapiX, idsCertValid, szBuf, sizeof(szBuf));
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_CHECK), SW_SHOWNORMAL);
        ShowWindow(GetDlgItem(hDlg,IDC_CERT_GENERAL_ICON_UNCHECK), SW_HIDE);
    }
    SetDlgItemText(hDlg, IDC_CERT_GENERAL_STATIC_STATUS, szBuf);


    LoadString(hinstMapiX, idsNo, szBuf, sizeof(szBuf));
    if(!lpcp->lpCDP->bIsExpired)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_EXPIREDDATA, szBuf);
    if(!lpcp->lpCDP->bIsRevoked)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_REVOKEDDATA, szBuf);
    if(!lpcp->lpCDP->bIsTrusted)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_TRUSTEDDATA, szBuf);


    LoadString(hinstMapiX, idsYes, szBuf, sizeof(szBuf));
    if(lpcp->lpCDP->bIsExpired)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_EXPIREDDATA, szBuf);
    if(lpcp->lpCDP->bIsRevoked)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_REVOKEDDATA, szBuf);
    if(lpcp->lpCDP->bIsTrusted)
        SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_TRUSTEDDATA, szBuf);

    return;
}



/****************************************************************************
*    FUNCTION: FillCertPropsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillCertPropsUI(HWND hDlg,int nPropSheet, LPCERT_PARAM lpcp)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_UI_STR];

    switch(nPropSheet)
    {
    case propCertGeneral:
        {
            // Fill the combo with the trust strings
            HWND hWndCombo = GetDlgItem(hDlg, IDC_CERT_GENERAL_COMBO_TRUST);
            DWORD dwTrust = lpcp->lpCDP->dwTrust;
            //N TODO: CHAINS
            for(i=idsCertTrustedByMe;i<=idsCertNotTrustedByMe;i++)
            {
                LoadString(hinstMapiX, i, szBuf, sizeof(szBuf));
                SendMessage(hWndCombo,CB_ADDSTRING, (WPARAM) i-idsCertTrustedByMe, (LPARAM) szBuf);
            }

            if(dwTrust & WAB_TRUSTED)
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexTrusted, 0);
            else if(dwTrust & WAB_NOTTRUSTED)
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexNotTrusted, 0);
            if(dwTrust & WAB_CHAINTRUSTED)
                //N TODO: CHAINS
                //SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexChainTrusted, 0);
                SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) indexNotTrusted, 0);

            // Fill in the misc strings
            SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_CERTFORDATA, lpcp->lpCDP->lpszSubjectName);
            SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_SERIALNUMDATA, lpcp->lpCDP->lpszSerialNumber);
            SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_VALIDFROMDATA, lpcp->lpCDP->lpszValidFromTo);

            // if an issuer exists, use it
            if(lpcp->lpCDP->lpszIssuerName)
                SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_ISSUER, lpcp->lpCDP->lpszIssuerName);
            else
            {
                // unknown or self issued
                LoadString(hinstMapiX, idsUnknown, szBuf, sizeof(szBuf));
                SetDlgItemText(hDlg, IDC_CERT_GENERAL_LABEL_ISSUER, szBuf);
            }

            //V Remove for now
            //
            // Disable the button if we dont have an issuer
            // if(!lpcp->lpCDP->lpIssuer)
            //    EnableWindow(GetDlgItem(hDlg, IDC_CERT_GENERAL_BUTTON_OPEN), FALSE);


            UpdateValidInvalidStatus(hDlg, lpcp);

        }
        break;

    case propCertTrust:
        {
            HWND hWndTree = GetDlgItem(hDlg, IDC_CERT_TRUST_TREE_CHAIN);
            HTREEITEM hItem = NULL;
            LPCERT_DISPLAY_PROPS  lpTemp = NULL, lpFirst = NULL, lpLast = NULL;
            LPCERT_DISPLAY_PROPS  lpList[2];
            int i;
            // Bug 18602
            // Add only the first and last items

            // Walk to the end of the linked list
            lpFirst = lpTemp = lpcp->lpCDP;

            while (lpTemp->lpIssuer)
            {
                lpTemp = lpTemp->lpIssuer;
                lpLast = lpTemp;
            }


            // Hack!
            lpList[0] = lpLast;
            lpList[1] = lpFirst;
            
            for(i=0;i<2;i++)
            {
                lpTemp = lpList[i];
                if(lpTemp)
                {
/*
#ifndef OLD_STUFF
    // Now walk back up the list, adding the nodes to the tree.
    while (lpTemp)
    {
#endif        
*/
                    HTREEITEM hItemTemp;
                    TV_ITEM tvI;
                    TV_INSERTSTRUCT tvIns;

                    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                    tvI.pszText = lpTemp->lpszSubjectName;
                    tvI.cchTextMax = lstrlen(tvI.pszText);
                    tvI.iImage = tvI.iSelectedImage = 0;

                    tvIns.item = tvI;
                    tvIns.hInsertAfter = (HTREEITEM) TVI_FIRST;
                    tvIns.hParent = hItem;

                    hItemTemp = TreeView_InsertItem(hWndTree, &tvIns);

                    if(hItem)
                        TreeView_Expand(hWndTree, hItem, TVE_EXPAND);

                    hItem = hItemTemp;

                } //if lpList[i] ..

            } //end for  

/*                
#ifndef OLD_STUFF
                    // We don't want to walk back up past the node for the current cert
                    if (lpTemp == lpcp->lpCDP)
                    {
                      lpTemp = NULL;
                    }
                    else
                    {
                      lpTemp = lpTemp->lpPrev;
                    }
                }
#endif
*/
        } // end case
        break;


    case propCertAdvanced:
        if(lpcp->lpCDP->nFieldCount)
        {
            int i;
            HWND hWndLV = GetDlgItem(hDlg, IDC_CERT_ADVANCED_LIST_FIELD);

            for(i=0;i<lpcp->lpCDP->nFieldCount;i++)
            {
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                    lvi.pszText = lpcp->lpCDP->lppszFieldCount[i];
                    lvi.iItem = ListView_GetItemCount(hWndLV);
                    lvi.iSubItem = 0;
                    lvi.lParam = (LPARAM) lpcp->lpCDP->lppszDetails[i];

                    ListView_InsertItem(hWndLV, &lvi);
            }

            SetDlgItemText( hDlg,
                            IDC_CERT_ADVANCED_EDIT_DETAILS,
                            lpcp->lpCDP->lppszDetails[0]);

            ListView_SetItemState(  hWndLV,
                                    0,
                                    LVIS_FOCUSED | LVIS_SELECTED,
                                    LVIS_FOCUSED | LVIS_SELECTED);
        }
        break;
    }

    bRet = TRUE;

    return bRet;
}




////////////////////////////////////////////////////////////////////////////////
//
//  GetDL from UI - reads the UI for its parameters and verifies that
//  all required fields are set.
//
////////////////////////////////////////////////////////////////////////////////
BOOL GetCertPropsFromUI(HWND hDlg, LPCERT_PARAM lpcp)
{
    BOOL bRet = FALSE;

    // The cert UI is readonly except for trust information ..
    // So just get the trust information
    HWND hWndCombo = GetDlgItem(hDlg, IDC_CERT_GENERAL_COMBO_TRUST);
    int nRet = SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

    switch(nRet)
    {
    case indexTrusted:
        lpcp->lpCDP->dwTrust = WAB_TRUSTED;
        break;
    case indexNotTrusted:
        lpcp->lpCDP->dwTrust = WAB_NOTTRUSTED;
        break;
    //N TODO: CHAINS
    //case indexChainTrusted:
    //    lpcp->lpCDP->dwTrust = WAB_CHAINTRUSTED;
    //    break;
    }

    bRet = TRUE;

//out:
    return bRet;
}



#define _lpCP    ((LPCERT_PARAM) pps->lParam)

/*//$$***********************************************************************
*    FUNCTION: fnCertGeneralProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnCertGeneralProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        if(lParam)
        {
            SetWindowLong(hDlg,DWL_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
        }
        SetCertPropsUI(hDlg,propCertGeneral);
        FillCertPropsUI(hDlg,propCertGeneral,_lpCP);
        return TRUE;

/***
    case WM_HELP:
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
        break;


	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        //V Remove for now
        //
        //case IDC_CERT_GENERAL_BUTTON_OPEN:
        //    {
        //        HrShowCertProps(hDlg, _lpCP->lpCDP->lpIssuer);
        //    }
        //    break;
        }
        switch(GET_WM_COMMAND_CMD(wParam, lParam)) //check the notification code
        {
            case CBN_SELENDOK:
                switch(LOWORD(wParam))
                {
                    case IDC_CERT_GENERAL_COMBO_TRUST:
                        {
                            // The selection could have changed ... so figure out if it has or not
                            // If it has changed, update the UI accordingly ...
                            HWND hWndCombo = GetDlgItem(hDlg, IDC_CERT_GENERAL_COMBO_TRUST);
                            DWORD dwTrust = 0;
                            int nRet = SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

                            switch(nRet)
                            {
                            case indexTrusted:
                                dwTrust = WAB_TRUSTED;
                                break;
                            case indexNotTrusted:
                            default:
                                dwTrust = WAB_NOTTRUSTED;
                                break;
                            //N TODO: CHAINS
                            //case indexChainTrusted:
                            //    dwTrust = WAB_CHAINTRUSTED;
                            //    break;
                            }

                            if (_lpCP->lpCDP->dwTrust != dwTrust)
                            {
                                _lpCP->lpCDP->dwTrust = dwTrust;

                                if (dwTrust & WAB_TRUSTED) 
                                    _lpCP->lpCDP->bIsTrusted = TRUE;
                                else if (dwTrust & WAB_NOTTRUSTED)
                                    _lpCP->lpCDP->bIsTrusted = FALSE;
                                //N TODO: CHAINS
                                //else if (dwTrust & WAB_CHAINTRUSTED)
                                //    _lpCP->lpCDP->bIsTrusted = FALSE; //VerifyTrustBasedOnChainOfTrust(NULL, _lpCP->lpCDP);

                                UpdateValidInvalidStatus(hDlg, _lpCP);
                            }
                        }
                        break;
                }
                break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            if (!GetCertPropsFromUI(hDlg, _lpCP))
            {
                //something failed ... abort this OK ... ie dont let them close
                SetWindowLong(hDlg,DWL_MSGRESULT, TRUE);
                return TRUE;
            }
            _lpCP->nRetVal = CERT_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            _lpCP->nRetVal = CERT_CANCEL;
            break;




        }

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnCertTrustProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnCertTrustProc(HWND hDlg,UINT message,UINT  wParam, LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        if(lParam)
        {
            SetWindowLong(hDlg,DWL_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
        }
        SetCertPropsUI(hDlg,propCertTrust);
        FillCertPropsUI(hDlg,propCertTrust,_lpCP);
        return TRUE;

/***
    case WM_HELP:
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
        break;


	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            // read-only prop sheet - no info to retrieve ...
            _lpCP->nRetVal = CERT_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            _lpCP->nRetVal = CERT_CANCEL;
            break;

        }
        return TRUE;
        break;

    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnCertAdvancedProc
*
*    PURPOSE:  Window proc for property sheet ...
*
****************************************************************************/
BOOL APIENTRY_16 fnCertAdvancedProc(HWND hDlg,UINT message,UINT wParam, LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;

    pps = (PROPSHEETPAGE *) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        if(lParam)
        {
            SetWindowLong(hDlg,DWL_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
        }
        SetCertPropsUI(hDlg,propCertAdvanced);
        FillCertPropsUI(hDlg,propCertAdvanced,_lpCP);
        return TRUE;

/***
    case WM_HELP:
        WinHelp(    ((LPHELPINFO)lParam)->hItemHandle,
                    g_szWABHelpFileName,
                    HELP_WM_HELP,
                    (DWORD)(LPSTR) rgDsPropsHelpIDs );
        break;


	case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD)(LPVOID) rgDsPropsHelpIDs );
		break;
****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            _lpCP->nRetVal = CERT_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            _lpCP->nRetVal = CERT_CANCEL;
            break;

        case LVN_ITEMCHANGED:
        case NM_SETFOCUS:
        case NM_CLICK:
        case NM_RCLICK:
            switch(wParam)
            {
            case IDC_CERT_ADVANCED_LIST_FIELD:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    HWND hWndLV = pNm->hdr.hwndFrom;
                    LV_ITEM lvi = {0};
                    LPTSTR lpsz;

                    lvi.mask = LVIF_PARAM;
                    lvi.iSubItem = 0;
                    lvi.iItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

                    if(ListView_GetItem(hWndLV, &lvi))
                    {
                        lpsz = (LPTSTR) lvi.lParam;
                        SetDlgItemText(hDlg, IDC_CERT_ADVANCED_EDIT_DETAILS, lpsz);
                    }
                }
                break;
            }
            break;
        }
        return TRUE;
        break;

    }

    return bRet;

}


#endif //OLD_STUFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabexe\wabexe.h ===
/*-----------------------------------------
//
//   WABExe.h -- externs
//
//
//-----------------------------------------*/
extern HINSTANCE hInst;         // this module's resources instance handle
extern HINSTANCE hInstApp;         // this module's instance handle

HRESULT CertFileDisplay(HWND hwnd,
  LPWABOBJECT lpWABObject,
  LPADRBOOK lpAdrBook,
  LPTSTR lpFileName);

extern const UCHAR szEmpty[];


#ifdef DEBUG
#define DebugTrace          DebugTraceFn
#define IFTRAP(x)           x
#define Assert(t) IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#else
#define DebugTrace          1?0:DebugTraceFn
#define IFTRAP(x)           0
#define Assert(t)
#endif

/* Debugging Functions ---------------------------------------------------- */
VOID FAR CDECL DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
VOID FAR CDECL DebugTraceFn(char *pszFormat, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabexe\resource.h ===
#define IDI_ICON1                       101
#define IDI_ICON_VCARD                  102

#define idsWABTitle         2001
#define idsWABFileNotFound  2002
#define idsWABOpenError     2003
#define idsWABOpenFileTitle 2004
#define idsWABOpenFileFilter 2005
#define idsWABNewFileTitle  2006
#define idsWABUsage         2007
#define idsWABPathNotFound  2008
#define idsWABInvalidCmdLine 2009
#define idsWABTitleWithFileName 2010
#define idsWABAddressError  2011
#define idsWABOpenErrorMemory   2012
#define idsWABOpenErrorLocked   2013
#define idsWABOpenErrorCorrupt  2014
#define idsWABOpenErrorDisk     2015
#define idsWABAddressErrorMissing  2016
#define idsWABOpenErrorNotWAB      2017
#define idsWABOpenErrorNotWABName  2018
#define idsWABOpenVCardError        2019
#define idsWABOpenLDAPUrlError      2020
#ifdef WIN16
#define idsWABUsage1        2100
#endif

#define idsAddToABPaneTitle         2030
#define idsCertificateViewTitle     2031

#define IDD_DIALOG_DEFAULT_VCARD_VIEWER 3000
#define IDC_CHECK_ALWAYS                3001
#define IDC_STATIC_ASK                  3002
#define IDC_STATIC_ICON                 3003

#define IDC_ADD_TO_ADDRESS_BOOK     4000
#define IDD_CERTPROP_ADDRESS_BOOK   4001
#define IDC_ADD_TO_ADDRESS_BOOK_FRAME   4002
#define IDC_ADD_TO_ADDRESS_BOOK_TEXT    4003

#define MAX_RESOURCE_STRING         260
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabexe\makefile.inc ===
$O\wabexe.res : selfreg.inf

selfreg.inf : selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabexe\wabexe.c ===
/*-----------------------------------------
//
//   WABExe.C -- Enables viewing the WAB modeless UI
//
//
-------------------------------------------*/

#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "..\wab32res\resrc2.h"
#include <advpub.h>
#include <shlwapi.h>
#include "wabexe.h"


#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))
#define WinMainT WinMain
LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
LRESULT CALLBACK WndProcW (HWND, UINT, WPARAM, LPARAM) ;

#define MAX_INPUT_STRING    200

// #define LDAP_AUTH_SICILY    (0x86L | 0x0200)

char szAppName [] = "Address Book Viewer" ;
const LPTSTR szWABFilter = TEXT("*.wab");
const UCHAR szEmpty[] = "";

// Command Line Parameters
static const TCHAR szParamOpen[]  =           "/Open";
static const TCHAR szParamNew[]   =           "/New";
static const TCHAR szParamShowExisting[] =    "/ShowExisting";
static const TCHAR szParamFind[]  =           "/Find";
static const TCHAR szParamVCard[] =           "/VCard";
static const TCHAR szParamLDAPUrl[] =         "/LDAP:";
static const TCHAR szParamCert[] =            "/Certificate";
static const TCHAR szParamFirstRun[] =        "/FirstRun";
static const TCHAR szAllProfiles[] =          "/All";

static const TCHAR szWabKey[]="Software\\Microsoft\\Wab";
static const TCHAR szVCardNoCheckKey[]="NoVCardCheck";

static const TCHAR lpszSharedKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SharedDlls");

HINSTANCE hInstWABDll = NULL;
HINSTANCE hInst = NULL;         // this module's resource instance handle
HINSTANCE hInstApp = NULL;         // this module's instance handle

HINSTANCE LoadLibrary_WABDll();

LPWABOPEN lpfnWABOpen = NULL;
const static TCHAR szWABOpen[] = TEXT("WABOpen");

static const GUID MPSWab_GUID = // keep this in sync with the one in wabapi\mpswab.h
{ 0xc1843281, 0x585, 0x11d0, { 0xb2, 0x90, 0x0, 0xaa, 0x0, 0x3c, 0xf6, 0x76 } };

BOOL bGetFileNameFromDlg(HWND hwnd,
                  HINSTANCE hInstance,
                  LPTSTR lpszDirectory,
                  int szTitleID,
                  DWORD dwFlags,
                  LPTSTR szFileName,
                  DWORD cchFileName);

#define WAB_VCARDFILE   0x00000001
#define WAB_FINDSESSION 0x00000010
#define WAB_LDAPURL     0x00000100
#define WAB_CERTFILE    0x00001000
#define WAB_ALLPROFILES 0x00010000

BOOL bGetFileNameFromCmdLine(HWND hwnd,
                             HINSTANCE hInstance,
                             LPTSTR lpszCmdLine,
                             LPTSTR szWABTitle,
                             ULONG * ulFlag,
                             LPTSTR szFileName,
                             DWORD cchFileName);

static const char c_szReg[] = "Reg";
static const char c_szUnReg[] = "UnReg";
static const char c_szAdvPackDll[] = "ADVPACK.DLL";


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID, HINSTANCE hInstance) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[261];    // Big enough?  Strings better be smaller than 260!

    ulSize = LoadString(hInstance, StringID, szBuffer, sizeof(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, (ulSize + 1)*sizeof(TCHAR)))) {
        StrCpyN(lpBuffer, szBuffer, ulSize+1);
    }

    return(lpBuffer);
}

//$$//////////////////////////////////////////////////////////////////////
//
//  FormatAllocFilter - Loads a file filter name string resource and
//                      formats it with the file extension filter
//
//  StringID - String identifier to load
//  szFilter - file name filter, ie, "*.vcf"
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR FormatAllocFilter(int StringID, const LPTSTR lpFilter, HINSTANCE hInstance) {
    LPTSTR lpFileType;
    LPTSTR lpTemp;
    LPTSTR lpBuffer = NULL;
    ULONG cbFileType, cbFilter;

    cbFilter = lstrlen(lpFilter);
    if (lpFileType = LoadAllocString(StringID,hInstance)) {
    	cbFileType = lstrlen(lpFileType);
        if (lpBuffer = LocalAlloc(LPTR, (cbFileType+1+lstrlen(lpFilter)+ 2)*sizeof(TCHAR))) {
            lpTemp = lpBuffer;
            StrCpyN(lpTemp, lpFileType, cbFileType+1);
            lpTemp += cbFileType;
            lpTemp++;   // leave null there
            StrCpyN(lpTemp, lpFilter, cbFilter+1);
            lpTemp += cbFilter;
            lpTemp++;   // leave null there
            *lpTemp = '\0';
        }

        LocalFree(lpFileType);
    }

    return(lpBuffer);
}


//$$//////////////////////////////////////////////////////////////////////
//
// GetWABExePath - queries the reg for the full path of the wab exe
//
// sz is a preallocated buffer
//
//////////////////////////////////////////////////////////////////////////
TCHAR lpszWABExeRegPath[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Wab.exe");

void GetWABExePath(LPTSTR sz, ULONG cbsz)
{
    DWORD dwType = 0;
    DWORD dwSize = cbsz;
    *sz = '\0';
    RegQueryValue(  HKEY_LOCAL_MACHINE,
                    lpszWABExeRegPath,
                    sz, &dwSize);

    if(!lstrlen(sz))
        StrCpyN(sz, TEXT("WAB.Exe"), cbsz);
}

static const TCHAR szWabAutoFileKey[]=".wab";
static const TCHAR szWabAutoFile[]="wab_auto_file";

static const TCHAR szWabAutoFileNameKey[]="wab_auto_file";
static const TCHAR szWabAutoFileName[]="WAB File";

static const TCHAR szWabCommandOpenKey[]="wab_auto_file\\shell\\open\\command";
static const TCHAR szWabCommandOpen[]="\"%s\" %%1";

//$$//////////////////////////////////////////////////////////////////////
//
// CheckWABDefaultHandler
//
// Checks if WAB.exe is the default handler for the WAB in the registry.
// If not, sets wab.exe as the default handler
//
//////////////////////////////////////////////////////////////////////////
void CheckWABDefaultHandler()
{
    HKEY hKey = NULL;

    TCHAR sz[MAX_PATH];
    TCHAR szWABExe[MAX_PATH];


    DWORD dwDisposition = 0;

    // Check to see if something is registered or not ...

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                        szWabAutoFileKey,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if (dwDisposition == REG_CREATED_NEW_KEY)
    {
        // New key ... need to give it a value .. this will be the
        // default value
        //
        DWORD dwLenName = lstrlen(szWabAutoFile);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szWabAutoFile,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        // Create the other keys also

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szWabAutoFileNameKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        dwLenName = lstrlen(szWabAutoFileName);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szWabAutoFileName,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szWabCommandOpenKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        GetWABExePath(szWABExe, sizeof(szWABExe));
        wnsprintf(sz, ARRAYSIZE(sz), szWabCommandOpen, szWABExe);


        dwLenName = lstrlen(sz);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) sz,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

    }

out:

    if(hKey)
        RegCloseKey(hKey);

    return;
}


enum _RetVal
{
    MAKE_DEFAULT=0,
    DONT_MAKE_DEFAULT
};

enum _DoVCardCheck
{
    NO_VCARD_CHECK=1,
    DO_VCARD_CHECK
};


//$$//////////////////////////////////////////////////////////////////////
//
// fnAskVCardProc
//
//
//////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK fnAskVCardProc(HWND    hDlg, UINT    message, WPARAM    wParam, LPARAM    lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        break;

   case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CHECK_ALWAYS:
			{
				// Set a registry setting depending on the check mark value
				
				UINT nIsChecked = IsDlgButtonChecked(hDlg, IDC_CHECK_ALWAYS);
				DWORD dwCheck = (nIsChecked == BST_CHECKED) ? NO_VCARD_CHECK : DO_VCARD_CHECK;

				{
					// Set this value in the registry
					
					HKEY hKey = NULL;
					DWORD dwDisposition;

					// Open the WAB Key
					if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
														szWabKey,
														0,      //reserved
														NULL,
														REG_OPTION_NON_VOLATILE,
														KEY_ALL_ACCESS,
														NULL,
														&hKey,
														&dwDisposition))
					{
						//if this key exists, get the WAB DoVCardCheck value
						DWORD dwLenName = sizeof(dwCheck);
						DWORD dwType = REG_DWORD;
						RegSetValueEx(	hKey,
										szVCardNoCheckKey,
										0,
										dwType,      //reserved
										(LPBYTE) &dwCheck,
										dwLenName);
					}

					if(hKey)
						RegCloseKey(hKey);

				}
			}
			break;

        case IDOK:
            EndDialog(hDlg, MAKE_DEFAULT);
            break;

        case IDCANCEL:
            EndDialog(hDlg, DONT_MAKE_DEFAULT);
            break;

        }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;

}

static const TCHAR szVCardAutoFileKey[]=".vcf";
static const TCHAR szVCardAutoFile[]="vcard_wab_auto_file";

static const TCHAR szVCardContentTypeValue[]="Content Type";
static const TCHAR szVCardContentType[]="text/x-vcard";

static const TCHAR szVCardMimeDatabase[]="MIME\\Database\\Content Type\\text/x-vcard";
static const TCHAR szVCardExtension[]="Extension";

static const TCHAR szVCardAutoFileNameKey[]="vcard_wab_auto_file";
static const TCHAR szVCardAutoFileName[]="vCard File";

static const TCHAR szVCardCommandOpenKey[]="vcard_wab_auto_file\\shell\\open\\command";
static const TCHAR szVCardCommandOpen[]="\"%s\" /vcard %%1";

static const TCHAR szVCardDefaultIconKey[]="vcard_wab_auto_file\\DefaultIcon";
static const TCHAR szVCardDefaultIcon[]="\"%s\",1";

//$$//////////////////////////////////////////////////////////////////////
//
// CheckVCardDefaultHandler
//
// Checks if WAB.exe is the default handler for the VCard in the registry.
// If not, sets wab.exe as the default handler
//
//////////////////////////////////////////////////////////////////////////
void CheckVCardDefaultHandler(HWND hWnd,
                              HINSTANCE hInstance)
{

    TCHAR sz[MAX_PATH];
    TCHAR szWABExe[MAX_PATH];

    HKEY hKey = NULL;
    HKEY hVCardKey = NULL;

    DWORD dwDisposition = 0;
    DWORD dwType = 0;
    DWORD dwLenName = 0;


    //First check if they want us to check at all ..
    // Open key
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                        szWabKey,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        // Found the key
        if (dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            //if this key exists, get the WAB DoVCardCheck value
            DWORD dwCheck = 0;
            dwLenName = sizeof(dwCheck);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                szVCardNoCheckKey,
                                                NULL,
                                                &dwType,      //reserved
                                                (LPBYTE) &dwCheck,
                                                &dwLenName))
            {
                // success .. what did we get back
                if (dwCheck == NO_VCARD_CHECK) // Dont Check
                    goto out;
            }
            // else no success - so should do the check
        }
        // else no success, do the check
    }
    // else no success, do the check


    if(hKey)
        RegCloseKey(hKey);


    // Check to see if something is registered as a vCard handler or not ...

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                        szVCardAutoFileKey,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if (dwDisposition == REG_OPENED_EXISTING_KEY)
    {
        // This key exists .. check who is registered to handle vCards ..
        TCHAR szHandlerNameKey[MAX_PATH];
        StrCpyN(szHandlerNameKey, szEmpty, ARRAYSIZE(szHandlerNameKey));
        dwLenName = sizeof(szHandlerNameKey);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                            NULL,
                                            NULL,
                                            &dwType,      //reserved
                                            szHandlerNameKey,
                                            &dwLenName))
        {
            // We got the value for this .. is it us ?

            if(!lstrcmpi(szVCardAutoFile, szHandlerNameKey))
            {
                //its us, dont do anything
                goto out;
            }
            else if (szHandlerNameKey && lstrlen(szHandlerNameKey) != 0)
            {
                // Its not us, pop up a dialog asking if they want us
                int nRetVal = (int) DialogBox(
                                hInstance,
                                MAKEINTRESOURCE(IDD_DIALOG_DEFAULT_VCARD_VIEWER),
                                hWnd,
                                fnAskVCardProc);

                if (nRetVal == DONT_MAKE_DEFAULT)
                    goto out;

            } // else couldnt open.. go ahead and make us default
        }  // else couldnt open.. go ahead and make us default
    }


    // If we are here then either dwDisposition == REG_CREATED_NEW_KEY or
    // there is some problem that couldnt let us read the above so set us as
    // the default ...

    {
        // New key ... need to give it a value .. this will be the
        // default value
        //
        DWORD dwLenName = lstrlen(szVCardAutoFile);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardAutoFile,
                                            dwLenName))
        {
            goto out;
        }

        dwLenName = lstrlen(szVCardContentType);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            szVCardContentTypeValue,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardContentType,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        // Create the other keys also

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardAutoFileNameKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        dwLenName = lstrlen(szVCardAutoFileName);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardAutoFileName,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardCommandOpenKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        GetWABExePath(szWABExe, sizeof(szWABExe));
        wnsprintf(sz, ARRAYSIZE(sz), szVCardCommandOpen, szWABExe);

        dwLenName = lstrlen(sz);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) sz,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardDefaultIconKey,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        wnsprintf(sz, ARRAYSIZE(sz), szVCardDefaultIcon, szWABExe);

        dwLenName = lstrlen(sz);

        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            NULL,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) sz,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;


        // Set HKCR\MIME\Database\Content Type\text/x-vCard: Extension=.vcf

        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                            szVCardMimeDatabase,
                                            0,      //reserved
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hKey,
                                            &dwDisposition))
        {
            goto out;
        }

        dwLenName = lstrlen(szVCardAutoFileKey);
        if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                            szVCardExtension,
                                            0,
                                            REG_SZ,
                                            (LPBYTE) szVCardAutoFileKey,
                                            dwLenName))
        {
            goto out;
        }

        RegCloseKey(hKey);
        hKey = NULL;

    }

out:

    if(hVCardKey)
        RegCloseKey(hVCardKey);
    if(hKey)
        RegCloseKey(hKey);

    return;
}


//$$//////////////////////////////////////////////////////////////////////
//
// Callback dismiss function for IADRBOOK->Address
//
//////////////////////////////////////////////////////////////////////////
void STDMETHODCALLTYPE WABDismissFunction(ULONG_PTR ulUIParam, LPVOID lpvContext)
{
    LPDWORD lpdw = (LPDWORD) lpvContext;
    PostQuitMessage(0);
    return;
}


void GetWABDllPath(LPTSTR szPath, ULONG cb);
static const LPTSTR szWABResourceDLL = TEXT("wab32res.dll");
static const LPTSTR szWABDLL = TEXT("wab32.dll");
static const LPTSTR c_szShlwapiDll = TEXT("shlwapi.dll");
static const LPTSTR c_szDllGetVersion = TEXT("DllGetVersion");
typedef HRESULT (CALLBACK * SHDLLGETVERSIONPROC)(DLLVERSIONINFO *);
typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
/*
-   LoadWABResourceDLL
-
*   WAB resources are split up into a seperate dll so we want to load them from there
*   The Resource DLL location should be the same as the wab32.dll location
*   So we will try to make sure we don't fail here - 
*   1. Get current WAB32.dll path and look in that directory
*   2. Just loadlibrary(wab32.dll)
*
*   The MLLoadLibrary function should be used if available (IE5 only thing)  since
*   it will load the correct language pack
*
*/
HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    HINSTANCE hinst = NULL; 
    PFNMLLOADLIBARY pfnLoadLibrary = NULL;
    HINSTANCE hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    SHDLLGETVERSIONPROC pfnVersion = NULL;
    DLLVERSIONINFO info = {0};

    // [PaulHi] 1/26/99  Raid 67380
    // Make sure we have the correct version of SHLWAPI.DLL before we use it
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (SHDLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
//                    pfnLoadLibrary = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378); // UNICODE version
                    pfnLoadLibrary = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377); //ANSI version
                }
            }
        }
    }

    hinst = pfnLoadLibrary ? 
             pfnLoadLibrary(szWABResourceDLL, hInstWAB32, 0) :
             LoadLibrary(szWABResourceDLL);
 
    if(!hinst)
    {
        // maybe not on the path so look in the wab32.dll directory
        TCHAR szResDLL[MAX_PATH];
        *szResDLL = '\0';
        GetWABDllPath(szResDLL, sizeof(szResDLL));
        if(lstrlen(szResDLL))
        {
            // the returned filename will always end in wab32.dll so we can nix that many characters off
            // and replace with wab32res.dll
            szResDLL[lstrlen(szResDLL) - lstrlen(szWABDLL)] = '\0';
            StrCatBuff(szResDLL, szWABResourceDLL, ARRAYSIZE(szResDLL));

            hinst = pfnLoadLibrary ?
                     pfnLoadLibrary(szResDLL, hInstWAB32, 0) :
                     LoadLibrary(szResDLL);
        }
    }
    
    if(hinstShlwapi)
        FreeLibrary(hinstShlwapi);

    return hinst;
}


/*
-   Strip quotes from File Names
-
*   szFileName needs to be a buffer
*/
void StripQuotes(LPTSTR szFileName)
{
    // now let's get rid of " and ' in the filename string
    if( szFileName && lstrlen(szFileName))
    {
        TCHAR szCopy[MAX_PATH];
        LPTSTR lpTemp, lpTempBegin;
        int len = lstrlen(szFileName);
        lpTempBegin = szFileName;
        StrCpyN(szCopy, szFileName, ARRAYSIZE(szCopy));
        for( lpTemp = szCopy; lpTemp < szCopy+len; lpTemp++)
        {
            if( *lpTemp != '"' )//&& *lpTemp != '\'' )
                *(lpTempBegin++) = *lpTemp;
        }
        *(lpTempBegin) = '\0';
    }
}

/*
-
-   CheckifRunningOnWinNT
*
*   Checks the OS we are running on and returns TRUE for WinNT
*   False for Win9x
*/
BOOL bCheckifRunningOnWinNT()
{
    OSVERSIONINFO osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


///////////////////////////////////////////////////////////////////////////////
//  ConvertAtoW
//
//  Helper function
///////////////////////////////////////////////////////////////////////////////
LPWSTR ConvertAtoW(LPCSTR lpszA)
{
    int cch;
    LPWSTR lpW = NULL;
    ULONG   ulSize;

    if ( !lpszA)
        goto ret;
    
    cch = (lstrlenA( lpszA ) + 1);
    ulSize = cch*sizeof(WCHAR);
    
    if(lpW = LocalAlloc(LMEM_ZEROINIT, ulSize))
    {
        MultiByteToWideChar( GetACP(), 0, lpszA, -1, lpW, cch );
    }
ret:
    return lpW;
}


//$$//////////////////////////////////////////////////////////////////////
//
// WinMain
//
//////////////////////////////////////////////////////////////////////////
int WINAPI WinMain( HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR lpszCmdLine,
                    int nCmdShow)
{
    HWND     hwnd = NULL;
    MSG      msg ;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    HRESULT hResult = hrSuccess;
    ADRPARM AdrParms = {0};
    WAB_PARAM WP = {0};
    LPTSTR szFileName = NULL;
    int nLen = MAX_PATH+1;
    //TCHAR szFileName[MAX_PATH+1];
    //TCHAR szDefaultFile[MAX_PATH+1];
    LPTSTR lpszTitle = NULL;
    ULONG ulFlag = 0;
    LPTSTR lpszVCardFileName = NULL;
    LPTSTR lpszCertFileName = NULL;
    LPTSTR lpszLDAPUrl = NULL;

    // "Windows Address Book" - used for msgboxes when we dont have
    // a file name
    TCHAR szWABTitle[MAX_PATH];

    // Contains the opened file name in the title
    // This makes it easier to search for a default address book
    // even if mutiple other ones are open
    TCHAR szWABTitleWithFileName[MAX_PATH];


    // Check which platform we are running on.
    BOOL bRunningOnNT = bCheckifRunningOnWinNT();

    hInstApp = hInstance;
    hInst = LoadWABResourceDLL(hInstance);

    if(lpszCmdLine && lstrlen(lpszCmdLine) > nLen)
        nLen = lstrlen(lpszCmdLine)+1;

    szFileName = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));
    if(!szFileName)
        goto out;


    // if this is the firstrun flag, all we need to do is call WABOpen and then exit
    //
    if(!lstrcmpi(lpszCmdLine,szParamFirstRun))
    {
        const LPTSTR lpszNewWABKey = TEXT("Software\\Microsoft\\WAB\\WAB4");
        const LPTSTR lpszFirstRunValue = TEXT("FirstRun");
        HKEY hKey = NULL;
        DWORD dwType = 0, dwValue = 0, dwSize = sizeof(DWORD);
        // First check if this is a first run - if its not a first run then we can just skip out
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpszNewWABKey, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx( hKey, lpszFirstRunValue, NULL, &dwType, (LPBYTE) &dwValue, &dwSize))
            {
                if(hKey)
                    RegCloseKey(hKey);
                goto out;
            }
            else
                if(hKey)
                    RegCloseKey(hKey);
        }
        // Either the WAB4 key did not exist, or the first run value was not found.
        // In either case, fix this
        hInstWABDll = LoadLibrary_WABDll();
        if(hInstWABDll)
            lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWABDll, szWABOpen);
        if(lpfnWABOpen)
            lpfnWABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        goto out;
    }

    CheckWABDefaultHandler();
    CheckVCardDefaultHandler(NULL, hInst);

    szFileName[0]='\0';

    // We will show a file name in the title only if a file name is 
    // explicitly specified .. if the file name is not explicitly specified,
    // we will revert to a generic "Address Book" title

    LoadString(hInst, idsWABTitle, szWABTitle, sizeof(szWABTitle));
    LoadString(hInst, idsWABTitleWithFileName, szWABTitleWithFileName, sizeof(szWABTitleWithFileName));


    // Get the default windows address book from the registry
    //szDefaultFile[0]='\0';
    //GetWABDefaultAddressBookName(szDefaultFile);


    if(!lstrcmpi(lpszCmdLine,szParamShowExisting))
    {
        //perhaps this already exists - find the window and set focus to it

        // /ShowExisting flag always opens the default wab file
        // The title of this wab.exe window will have the default file
        // name in the title.
/*
        LPTSTR lpsz = szDefaultFile;

        FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szWABTitleWithFileName,
                        0,
                        0,
                        (LPTSTR) &lpszTitle,
                        0,
                        (va_list *)&lpsz);
*/
        // Create the Expected Title from the default
        hwnd = FindWindow("WABBrowseView", NULL);//szWABTitle); //lpszTitle);
        if(hwnd)
        {
            ULONG ulFlags = SW_SHOWNORMAL;
            ulFlags |= IsZoomed(hwnd) ? SW_SHOWMAXIMIZED : SW_RESTORE;

            //SetForegroundWindow(hwnd);
            ShowWindow(hwnd, ulFlags);
            SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
            SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
            SetActiveWindow(hwnd);
            SetFocus(hwnd);

            goto out;
        }
    }

    if (bRunningOnNT)
    {
        LPWSTR      lpwszAppName = ConvertAtoW(szAppName);
        WNDCLASSW   wndclassW;

        // [PaulHi] 4/29/99  Raid 75578
        // On NT we need to create a Unicode main window so the child windows
        // can display Unicode characters.
        wndclassW.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclassW.lpfnWndProc   = WndProcW ;
        wndclassW.cbClsExtra    = 0 ;
        wndclassW.cbWndExtra    = 0 ;
        wndclassW.hInstance     = hInstApp;
        wndclassW.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1)) ;
        wndclassW.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclassW.hbrBackground = GetStockObject(WHITE_BRUSH) ;
        wndclassW.lpszMenuName  = lpwszAppName ;
        wndclassW.lpszClassName = lpwszAppName ;

        RegisterClassW(&wndclassW);

        hwnd = CreateWindowW (lpwszAppName, lpwszAppName,
                              WS_OVERLAPPEDWINDOW,
                              0,        // CW_USEDEFAULT,
                              0,        // CW_USEDEFAULT,
                              300,      // CW_USEDEFAULT,
                              200,      // CW_USEDEFAULT,
                              NULL,
                              NULL,
                              hInstApp,
                              NULL);

        LocalFree(lpwszAppName);
    }
    else
    {
        WNDCLASS    wndclass;

        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.lpfnWndProc   = WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = 0 ;
        wndclass.hInstance     = hInstApp;
        wndclass.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1)) ;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclass.hbrBackground = GetStockObject(WHITE_BRUSH) ;
        wndclass.lpszMenuName  = szAppName ;
        wndclass.lpszClassName = szAppName ;

        RegisterClass(&wndclass);

        hwnd = CreateWindow (szAppName, szAppName,
                              WS_OVERLAPPEDWINDOW,
                              0,        // CW_USEDEFAULT,
                              0,        // CW_USEDEFAULT,
                              300,      // CW_USEDEFAULT,
                              200,      // CW_USEDEFAULT,
                              NULL,
                              NULL,
                              hInstApp,
                              NULL);
    }

    if(!hwnd)
        goto out;
    else
        WP.hwnd = hwnd;

    if(lstrlen(lpszCmdLine))
    {
        if(!bGetFileNameFromCmdLine( hwnd,
                                     hInst,
                                     lpszCmdLine,
                                     szWABTitle,
                                     &ulFlag,
                                     szFileName,
                                     nLen))
        {
            goto out;
        }
    }

    if(ulFlag & WAB_VCARDFILE)
    {
        StripQuotes(szFileName);
        lpszVCardFileName = szFileName;
        // [PaulHi] 12/2/98  Raid #55033
        WP.ulFlags = WAB_ENABLE_PROFILES;
    }
    else if(ulFlag & WAB_LDAPURL)
    {
        lpszLDAPUrl = szFileName;
    }
    else if(ulFlag & WAB_CERTFILE)
    {
        StripQuotes(szFileName);
        lpszCertFileName = szFileName;
    }
    else if(ulFlag & WAB_ALLPROFILES)
    {
        WP.ulFlags &= ~WAB_ENABLE_PROFILES;
        ulFlag &= ~WAB_ALLPROFILES;
    }
    else if(szFileName && lstrlen(szFileName))
    {
        WP.szFileName = szFileName;
        // [PaulHi] 3/2/99  Raid 73492
        // [PaulHi] 4/22/99 Modified
        // Can't do this because identity mode will only show folders for that
        // identity, which may not be the folder in this general WAB file.
        // WP.ulFlags = WAB_ENABLE_PROFILES;   // Start with profiles on
    }
    else if(!(ulFlag & WAB_ALLPROFILES))
    {
        WP.ulFlags = WAB_ENABLE_PROFILES;
    }

    hInstWABDll = LoadLibrary_WABDll();
    if(hInstWABDll)
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWABDll, szWABOpen);

    if(!lpfnWABOpen)
        goto out;

    WP.cbSize = sizeof(WAB_PARAM);
    WP.guidPSExt = MPSWab_GUID;

    hResult = lpfnWABOpen(&lpAdrBook, &lpWABObject, &WP, 0);

    if(HR_FAILED(hResult))
    {
        TCHAR szBuf[MAX_PATH];
        int id;
        switch(hResult)
        {
        case MAPI_E_NOT_ENOUGH_MEMORY:
            id = idsWABOpenErrorMemory;
            break;
        case MAPI_E_NO_ACCESS:
            id = idsWABOpenErrorLocked;
            break;
        case MAPI_E_CORRUPT_DATA:
            id = idsWABOpenErrorCorrupt;
            break;
        case MAPI_E_DISK_ERROR:
            id = idsWABOpenErrorDisk;
            break;
        case MAPI_E_INVALID_OBJECT:
            id = idsWABOpenErrorNotWAB;
            break;
        case E_FAIL:
        default:
            id = idsWABOpenError;
            break;
        }
        LoadString(hInst, id, szBuf, sizeof(szBuf));
        MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONERROR);
        goto out;
    }

    if (lpAdrBook)
    {
        if(!ulFlag)
        {
            // We are in the business of showing the address book
            LPTSTR lpsz = NULL;

            lpszTitle = NULL;

            if(lstrlen(szFileName))
            {
                lpsz = szFileName;

                FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szWABTitleWithFileName,
                                0,
                                0,
                                (LPTSTR) &lpszTitle,
                                0,
                                (va_list *)&lpsz);
            }

            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_SDI;
            AdrParms.lpvDismissContext = NULL;
            AdrParms.lpfnDismiss = &WABDismissFunction;
            AdrParms.lpfnABSDI = NULL;

            //if(lpszTitle)
                AdrParms.lpszCaption = lpszTitle; //szWABTitle;
            //else // its possible to not have a file name the first time we run this ..
            //    AdrParms.lpszCaption = szWABTitle;

            AdrParms.nDestFieldFocus = AdrParms.cDestFields-1;

            hResult = lpAdrBook->lpVtbl->Address(  lpAdrBook,
                                                    (ULONG_PTR *) &hwnd,
                                                    &AdrParms,
                                                    NULL);
            if(HR_FAILED(hResult))
            {
                TCHAR szBuf[MAX_PATH];
                int id;
                switch(hResult)
                {
                case MAPI_E_UNCONFIGURED: // no commctrl
                    id = idsWABAddressErrorMissing;
                    break;
                default:
                    id = idsWABAddressErrorMissing;
                    break;
                }
                LoadString(hInst, id, szBuf, sizeof(szBuf));
                MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONERROR);
                goto out;
            }

            // [PaulHi] 4/29/99  Raid 75578  Must use Unicode versions of
            // message pump APIs for NT so Unicode data can be displayed.
            if (bRunningOnNT)
            {
                while (GetMessageW(&msg, NULL, 0, 0))
                {
                    if (AdrParms.lpfnABSDI)
                    {
                        if ((*(AdrParms.lpfnABSDI))((ULONG_PTR) hwnd, (LPVOID) &msg))
                            continue;
                    }

                    TranslateMessage(&msg);
                    DispatchMessageW(&msg);
                }
            }
            else
            {
                while (GetMessage(&msg, NULL, 0, 0))
                {
                    if (AdrParms.lpfnABSDI)
                    {
                        if ((*(AdrParms.lpfnABSDI))((ULONG_PTR) hwnd, (LPVOID) &msg))
                            continue;
                    }

                    TranslateMessage (&msg) ;
                    DispatchMessage (&msg) ;
                }
            }
        }
        else if(ulFlag & WAB_FINDSESSION)
        {
            lpWABObject->lpVtbl->Find(  lpWABObject,
                                        (LPADRBOOK) lpAdrBook,
                                        NULL);//hwnd);
        }
        else if(ulFlag & WAB_LDAPURL)
        {
            BOOL bUnicode = FALSE;
            BOOL bIsNT = bCheckifRunningOnWinNT();
            LPWSTR lpUrlW = NULL;
            LPWSTR lpCmdLineW = GetCommandLineW();

            //When working with LDAP URLs on NT, we want to err on the side of safety and
            // get the LDAP URL in UNICODE format if possible ..
            if(bIsNT)
            {
                LPWSTR lp = lpCmdLineW;
                WCHAR szLDAPW[] = L"/ldap:";
                WCHAR szTemp[16];
                int nLenW = lstrlenW(szLDAPW);
                // parse the command line till we find "/ldap:" and then use the
                // remainder as the LDAP URL
                while(lp && *lp)
                {
                    CopyMemory(szTemp, lp, min(sizeof(szTemp),nLenW * sizeof(WCHAR)));
                    szTemp[nLenW] = '\0';
                    if(!lstrcmpiW(szTemp, szLDAPW))
                    {
                        lp+=nLenW;
                        lpUrlW = lp;
                        break;
                    }
                    else
                        lp++;
                }
            }

            hResult = lpWABObject->lpVtbl->LDAPUrl(lpWABObject,
                                        (LPADRBOOK) lpAdrBook,
                                        hwnd,
                                        MAPI_DIALOG | (lpUrlW ? MAPI_UNICODE : 0 ),
                                        lpUrlW ? (LPSTR)lpUrlW : lpszLDAPUrl,
                                        NULL);

        }
        else if(ulFlag & WAB_VCARDFILE)
        {
            hResult = lpWABObject->lpVtbl->VCardDisplay(
                                        lpWABObject,
                                        (LPADRBOOK) lpAdrBook,
                                        NULL, //hwnd,
                                        lpszVCardFileName);
            if(HR_FAILED(hResult) && (hResult != MAPI_E_USER_CANCEL))
            {
                TCHAR szBuf[MAX_PATH];
                int id;
                switch(hResult)
                {
                default:
                    id = idsWABOpenVCardError;
                    break;
                }
                LoadString(hInst, id, szBuf, sizeof(szBuf));
                MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONERROR);
                goto out;
            }
        }
        else if(ulFlag & WAB_CERTFILE)
        {
            CertFileDisplay(NULL,   // hwnd
              lpWABObject,
              lpAdrBook,
              lpszCertFileName);
        }

    }
out:
    if(lpAdrBook)
        lpAdrBook->lpVtbl->Release(lpAdrBook);

    if (lpWABObject)
        lpWABObject->lpVtbl->Release(lpWABObject);

    if (lpszTitle)
        LocalFree(lpszTitle);

    if(hInstWABDll)
        FreeLibrary(hInstWABDll);

    if(szFileName)
        LocalFree(szFileName);

    if(hInst)
        FreeLibrary(hInst);

    return (int) msg.wParam;
}



//$$//////////////////////////////////////////////////////////////////
//
// WndProc for the hidden parent window that launches the UI
//
////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
        case WM_CREATE:
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            return(0);
        }
    return(DefWindowProc (hwnd, message, wParam, lParam));
}

//$$//////////////////////////////////////////////////////////////////
//
// WndProc for the hidden parent window that launches the UI.  Unicode version
//
////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK WndProcW (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
        case WM_CREATE:
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            return(0);
        }
    return(DefWindowProcW (hwnd, message, wParam, lParam));
}

//$$//////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////
int _stdcall WinMainCRTStartup (void)
{
    int i;
    STARTUPINFOA si;
    PTSTR pszCmdLine = GetCommandLine();

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if (*pszCmdLine == TEXT ('\"')) {
        // Scan, and skip over, subsequent characters until
        // another double-quote or a null is encountered.
        while (*++pszCmdLine && (*pszCmdLine != TEXT ('\"')));

        // If we stopped on a double-quote (usual case), skip over it.
        if (*pszCmdLine == TEXT ('\"')) {
            pszCmdLine++;
        }
    } else {
        while (*pszCmdLine > TEXT (' ')) {
            pszCmdLine++;
        }
    }

    // Skip past any white space preceeding the second token.
    while (*pszCmdLine && (*pszCmdLine <= TEXT (' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo (&si);

    i = WinMainT(GetModuleHandle (NULL), NULL, pszCmdLine,
    si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);

    return(i);
}

//$$//////////////////////////////////////////////////////////////////
//
// bGetFileNameFromDlg - opens the FIleOpen common dialog
//
////////////////////////////////////////////////////////////////////////
BOOL bGetFileNameFromDlg(HWND hwnd,
                  HINSTANCE hInstance,
                  LPTSTR lpszDirectory,
                  int szTitleID,
                  DWORD dwFlags,
                  LPTSTR szFileName,
                  DWORD cchFileName)
{
    OPENFILENAME ofn;
    TCHAR szBuf[MAX_PATH];
    BOOL bRet = FALSE;
    TCHAR szFile[MAX_PATH];

    LPTSTR lpFilter = FormatAllocFilter(idsWABOpenFileFilter, szWABFilter, hInstance);

    szFile[0]='\0';
    LoadString(hInstance, szTitleID, szBuf, sizeof(szBuf));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = hInstance;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = lpszDirectory;
    ofn.lpstrTitle = szBuf;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = "wab";
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    ofn.Flags = dwFlags;

    if(GetOpenFileName(&ofn))
    {
        bRet = TRUE;
        StrCpyN(szFileName, szFile, cchFileName);
    }

    if(lpFilter)
        LocalFree(lpFilter);

    return bRet;
}

/***************************************************************************

    Name      : StrICmpN

    Purpose   : Compare strings, ignore case, stop at N characters

    Parameters: szString1 = first string
                szString2 = second string
                N = number of characters to compare

    Returns   : 0 if first N characters of strings are equivalent.

    Comment   :

***************************************************************************/
int StrICmpN(LPTSTR lpsz1, LPTSTR lpsz2, ULONG N) {
    int Result = 0;
    LPTSTR szString1 = NULL, lp1 = NULL;
    LPTSTR szString2 = NULL, lp2 = NULL;
    ULONG cchString1, cchString2;

    cchString1 = lstrlen(lpsz1)+1;
    szString1 = LocalAlloc(LMEM_ZEROINIT, cchString1);
    if(!szString1)
        return 1;
    lp1 = szString1;

    cchString2 = lstrlen(lpsz2)+1;
    szString2 = LocalAlloc(LMEM_ZEROINIT, cchString2);
    if(!szString2)
        return 1;
    lp2 = szString2;

    StrCpyN(szString1, lpsz1, cchString1);
    StrCpyN(szString2, lpsz2, cchString2);

    if (szString1 && szString2) {

        szString1 = CharUpper(szString1);
        szString2 = CharUpper(szString2);

        while (*szString1 && *szString2 && N)
        {
            N--;

            if (*szString1 != *szString2)
            {
                Result = 1;
                break;
            }

            szString1=CharNext(szString1);
            szString2=CharNext(szString2);
        }
    } else {
        Result = -1;    // arbitrarily non-equal result
    }

    if(lp1)
        LocalFree(lp1);
    if(lp2)
        LocalFree(lp2);

    return(Result);
}


//$$//////////////////////////////////////////////////////////////////
//
// bGetFileNameFromCmdLine - Parses command line and acts appropriately till
//      we have a valid filename, cancel or failure.
//
// Input parameters -
//          hWnd
//          hInstance
//          lpszCmdLine
//          szWabTitle (for message boxes)
//          szFileName - file name returned from command line
//
//  Command line Parameters we understand so far
//
//      (none)  -   opens default wab file
//      /find   -   launches wab with find window
//      filename-   opens the file
//      /open   -   open file dialog to pick a wab file
//      /new    -   new file dialog to create a wab file
//      /showexisting - brings any already open default-wab file browse
//                      view to the forefront
//      /? -?   -   pops up a parameter dialog
//
////////////////////////////////////////////////////////////////////////
BOOL bGetFileNameFromCmdLine(HWND hwnd,
                             HINSTANCE hInstance,
                             LPTSTR lpszCmdLine,
                             LPTSTR szWABTitle,
                             ULONG * lpulFlag,
                             LPTSTR szFileName,
                             DWORD cchFileName)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[2*MAX_PATH];
    LPTSTR lpTemp = lpszCmdLine;

//    if(lpbIsVCardFile)
//        *lpbIsVCardFile = FALSE;

    if(lpulFlag)
        *lpulFlag = 0;
    else
        goto out;

    if (!lstrcmpi(lpszCmdLine,szParamShowExisting))
    {
        // do nothing
        szFileName[0] = '\0';
        bRet = TRUE;
        goto out;
    }
    else if (!lstrcmpi(lpszCmdLine,szParamFind))
    {
        // do nothing
        szFileName[0] = '\0';
        bRet = TRUE;
        *lpulFlag = WAB_FINDSESSION;
        goto out;
    }
    else if( (!lstrcmpi(lpszCmdLine,TEXT("/?"))) ||
             (!lstrcmpi(lpszCmdLine,TEXT("-?"))) )
    {
        LoadString(hInstance, idsWABUsage, szBuf, sizeof(szBuf));
        MessageBox(hwnd, szBuf, szWABTitle, MB_OK | MB_ICONINFORMATION);
        goto out;
    }
    else if(!lstrcmpi(lpszCmdLine,szParamOpen))
    {
        if(bGetFileNameFromDlg(hwnd,
                        hInstance,
                        NULL,
                        idsWABOpenFileTitle,
                        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                        szFileName,
                        cchFileName))
        {
            bRet = TRUE;
        }
        goto out;
    }
    else if(!lstrcmpi(lpszCmdLine,szParamNew))
    {
        if(bGetFileNameFromDlg(hwnd,
                        hInstance,
                        NULL,
                        idsWABNewFileTitle,
                        OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                        szFileName,
                        cchFileName))
        {
            bRet = TRUE;
        }
        goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szParamVCard, sizeof(szParamVCard)))
    {
               lpTemp += sizeof(szParamVCard);     // move past the switch

               while(lpTemp && *lpTemp && (*lpTemp==' '))
                   lpTemp=CharNext(lpTemp);

               if(lpTemp && lstrlen(lpTemp))
               {
                   StrCpyN(szFileName, lpTemp, cchFileName);
                   *lpulFlag = WAB_VCARDFILE;
                   bRet = TRUE;
               }
               goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szParamCert, sizeof(szParamCert)))
    {
       lpTemp += sizeof(szParamCert);     // move past the switch

       while(lpTemp && *lpTemp && (*lpTemp==' '))
           lpTemp=CharNext(lpTemp);

       if(lpTemp && lstrlen(lpTemp))
       {
           StrCpyN(szFileName, lpTemp, cchFileName);
           *lpulFlag = WAB_CERTFILE;
           bRet = TRUE;
       }
       goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szParamLDAPUrl, sizeof(szParamLDAPUrl)))
    {
        // We are expecting a url of the form
        //  /ldap:ldap-url
        lpTemp += sizeof(szParamLDAPUrl)-1;     // move past the switch

        if(lpTemp && lstrlen(lpTemp))
        {
           StrCpyN(szFileName, lpTemp, cchFileName);
           *lpulFlag = WAB_LDAPURL;
           bRet = TRUE;
        }
        goto out;
    }
    else if (!StrICmpN(lpTemp, (LPTSTR)szAllProfiles, sizeof(szAllProfiles)))
    {
        *lpulFlag = WAB_ALLPROFILES;
        bRet = TRUE;
        goto out;
    }
    else
    {
        //perhaps this is a file name
        //See if we can find this file in this computer
        DWORD dwAttr = GetFileAttributes(lpszCmdLine);
        if(dwAttr != 0xFFFFFFFF)
        {
            //Found the file
            if(!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
            {
                //Not a directory, must be a file
                StrCpyN(szFileName,lpszCmdLine, cchFileName);
            }
            else
            {
                //This is a directory - open a dialog in this directory
                if(bGetFileNameFromDlg(hwnd,
                                hInstance,
                                lpszCmdLine,
                                idsWABOpenFileTitle,
                                OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                                szFileName,
                                cchFileName))
                {
                    bRet = TRUE;
                }
                goto out;
            }
        }
        else
        {
            // we couldnt find any such file
            LPTSTR lpszMsg = NULL;
            int nRet;
            DWORD dwLastError = GetLastError();

            if(dwLastError == 3)
            {
                // Path not found
                LoadString(hInstance, idsWABPathNotFound, szBuf, sizeof(szBuf));
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szBuf,
                                0,
                                0,
                                (LPTSTR) &lpszMsg,
                                0,
                                (va_list *)&lpszCmdLine);
                MessageBox( NULL, lpszMsg, szWABTitle, MB_OK|MB_ICONEXCLAMATION );
                LocalFree( lpszMsg );
                goto out;
            }
            else if(dwLastError == 2)
            {
                // File not found
                LoadString(hInstance, idsWABFileNotFound, szBuf, sizeof(szBuf));
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szBuf,
                                0,
                                0,
                                (LPTSTR) &lpszMsg,
                                0,
                                (va_list *)&lpszCmdLine);
                nRet = MessageBox(hwnd, lpszMsg, szWABTitle, MB_YESNO | MB_ICONEXCLAMATION);
                LocalFree( lpszMsg );
                switch(nRet)
                {
                case IDYES:
                    // use this as the file name (TBD - waht if path doesnt match ?)
                    StrCpyN(szFileName,lpszCmdLine, cchFileName);
                    bRet = TRUE;
                    break;
                case IDNO:
                    goto out;
                    break;
                }
            }
            else
            {
                LoadString(hInstance, idsWABInvalidCmdLine, szBuf, sizeof(szBuf));
                MessageBox( NULL, szBuf, szWABTitle, MB_OK|MB_ICONEXCLAMATION );
                goto out;
            }
        }
    }

    bRet = TRUE;

out:
    return bRet;
}

//$$//////////////////////////////////////////////////////////////////////
//
// GetWABDllPath
//
//
//////////////////////////////////////////////////////////////////////////
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    ULONG  cbData;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH];

    if(szPath)
    {

        *szPath = '\0';

        // open the szWABDllPath key under
        if (ERROR_SUCCESS == RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                            WAB_DLL_PATH_KEY,
                                            0,      //reserved
                                            KEY_READ,
                                            &hKey))
        {
            cbData = sizeof(szPathT);
            if (ERROR_SUCCESS == RegQueryValueEx(    hKey,
                                "",
                                NULL,
                                &dwType,
                                (LPBYTE) szPathT,
                                &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        StrCpyN(szPath, szPathT, cb / sizeof(TCHAR));
                }
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
}

//$$//////////////////////////////////////////////////////////////////////
//
// LoadLibrary_WABDll()
//
//  Since we are moving the WAB directory out of Windows\SYstem, we cant be
//  sure it will be on the path. Hence we need to make sure that WABOpen will
//  work - by loading the wab32.dll upfront
//
///////////////////////////////////////////////////////////////////////////
HINSTANCE LoadLibrary_WABDll()
{
    LPTSTR lpszWABDll = TEXT("Wab32.dll");
    TCHAR  szWABDllPath[MAX_PATH];
    HINSTANCE hinst = NULL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    hinst = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : lpszWABDll );

    return hinst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\common.c ===
/*****************************************************************************
 *
 *	common.c - Shared stuff that operates on all classes
 *
 *	WARNING!  The Common services work only if you pass in the
 *	"primary object".  This is vacuous if you don't use multiple
 *	inheritance, since there's only one object in the first place.
 *
 *	If you use multiple inheritance, make sure you pass the pointer
 *	to the object that you use as IUnknown.
 *
 *	The exceptions are the Forward_* functions, which work on
 *	pointers to non-primary interfaces.  They forward the call to the
 *	primary interface.
 *
 *****************************************************************************/

#include "fnd.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCommon

/*****************************************************************************
 *
 *  USAGE FOR OLE OBJECTS
 *
 *	Suppose you want to implement an object called CObj that supports
 *	the interfaces Foo, Bar, and Baz.  Suppose that you opt for
 *	Foo as the primary interface.
 *
 *	>> NAMING CONVENTION <<
 *
 *	    COM objects begin with the letter "C".
 *
 *	(1) Declare the primary and secondary vtbls.
 *
 *		Primary_Interface(CObj, IFoo);
 *		Secondary_Interface(CObj, IBar);
 *		Secondary_Interface(CObj, IBaz);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct CObj {
 *		    IFoo 	foo;	    // Primary must come first
 *		    IBar	bar;
 *		    IBaz	baz;
 *		    ... other fields ...
 *		} CObj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* reimplement the AddRef and Release methods!
 *	    although you can subclass them.
 *
 *	(5) To allocate an object of the appropriate type, write
 *
 *		hres = Common_New(CObj, ppvOut);
 *
 *	    or, if the object is variable-sized,
 *
 *		hres = Common_NewCb(cb, CObj, ppvOut);
 *
 *	    If the object supports multiple interfaces, you also need to
 *	    initialize all the secondary interfaces.
 *
 *		CObj *pco = *ppvOut;
 *		pco->bar = Secondary_Vtbl(CObj, IBar);
 *		pco->baz = Secondary_Vtbl(CObj, IBaz);
 *
 *	(6) Define the vtbls.
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		// The macros will declare QueryInterface, AddRef and Release
 *		// so don't list them again
 *
 *		Primary_Interface_Begin(CObj, IFoo)
 *		    CObj_FooMethod1,
 *		    CObj_FooMethod2,
 *		    CObj_FooMethod3,
 *		    CObj_FooMethod4,
 *		Primary_Interface_End(Obj, IFoo)
 *
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *		    CObj_Bar_BarMethod1,
 *		    CObj_Bar_BarMethod2,
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *		    CObj_Baz_BazMethod1,
 *		    CObj_Baz_BazMethod2,
 *		    CObj_Baz_BazMethod3,
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  USAGE FOR NON-OLE OBJECTS
 *
 *	All objects are COM objects, even if they are never given out.
 *	In the simplest case, it just derives from IUnknown.
 *
 *	Suppose you want to implement an object called Obj which is
 *	used only internally.
 *
 *	(1) Declare the vtbl.
 *
 *		Simple_Interface(Obj);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct Obj {
 *		    IUnknown unk;
 *		    ... other fields ...
 *		} Obj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* override the QueryInterface, AddRef or
 *	    Release methods!
 *
 *	(5) Allocating an object of the appropriate type is the same
 *	    as with OLE objects.
 *
 *	(6) Define the "vtbl".
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		Simple_Interface_Begin(Obj)
 *		Simple_Interface_End(Obj)
 *
 *	    That's right, nothing goes between the Begin and the End.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	CommonInfo
 *
 *	Information tracked for all common objects.
 *
 *	A common object looks like this:
 *
 *			  riid
 *              cRef	  FinalizeProc
 *	pFoo -> lpVtbl -> QueryInterface
 *		data	  Common_AddRef
 *		data	  Common_Release
 *		...	  ...
 *
 *	Essentially, we use the otherwise-unused space above the
 *	pointers to record our bookkeeping information.
 *
 *	cRef	     = object reference count
 *	riid	     = object iid
 *	FinalizeProc = Finalization procedure
 *
 *	For secondary interfaces, it looks like this:
 *
 *              	  offset to primary interface
 *	pFoo -> lpVtbl -> Forward_QueryInterface
 *			  Forward_AddRef
 *			  Forward_Release
 *			  ...
 *
 *****************************************************************************/

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

typedef struct CommonInfoN {
  D(ULONG cin_dwSig;)
    ULONG cin_cRef;
} CommonInfoN, CIN, *PCIN;

typedef struct CommonInfoP {
    PREVTBL *cip_prevtbl;
} CommonInfoP, CIP, *PCIP;

typedef struct CommonInfoP2 {
    PREVTBL2 *cip2_prevtbl2;
} CommonInfoP2, CIP2, *PCIP2;

typedef union CommonInfo {
    CIN cin[1];
    CIP cip[1];
    CIP2 cip2[1];
} CommonInfo, CI, *PCI;


#define ci_dwSig	cin[-1].cin_dwSig
#define ci_cRef		cin[-1].cin_cRef
#define ci_rgfp		cip[0].cip_prevtbl
#define ci_riid		cip[0].cip_prevtbl[-1].riid
#define ci_Finalize	cip[0].cip_prevtbl[-1].FinalizeProc
#define ci_lib		cip2[0].cip2_prevtbl2[-1].lib

#define ci_Start	ci_cRef

#define ci_dwSignature	0x38162378		/* typed by my cat */

/*****************************************************************************
 *
 *	Common_QueryInterface (from IUnknown)
 *
 *	Use this for objects that support only one interface.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    HRESULT hres;
    EnterProc(Common_QueryInterface, (_ "pG", pv, riid));
    AssertF(pci->ci_dwSig == ci_dwSignature);

#ifdef _WIN64
    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IShellExtInit) || IsEqualIID(riid, &IID_IContextMenu))
#else
    if(IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, pci->ci_riid))
#endif 
    {
    	*ppvObj = pv;
	    Common_AddRef(pv);
	    hres = NOERROR;
    } 
    else
    {
	    *ppvObj = NULL;
	    hres = ResultFromScode(E_NOINTERFACE);
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Common_AddRef (from IUnknown)
 *
 *	Increment the object refcount and the dll refcount.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_AddRef(PV pv)
{
    PCI pci = pv;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    InterlockedIncrement((LPLONG)&g_cRef);
    return ++pci->ci_cRef;
}

/*****************************************************************************
 *
 *	Common_Finalize (from Common_Release)
 *
 *	By default, no finalization is necessary.
 *
 *****************************************************************************/

void EXTERNAL
Common_Finalize(PV pv)
{
}

/*****************************************************************************
 *
 *	Common_Release (from IUnknown)
 *
 *	Decrement the object refcount and the dll refcount.
 *
 *	If the object refcount drops to zero, finalize the object
 *	and free it.
 *
 *	The finalization handler lives ahead of the object vtbl.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_Release(PV pv)
{
    PCI pci = pv;
    ULONG ulRc;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    InterlockedDecrement((LPLONG)&g_cRef);
    ulRc = --pci->ci_cRef;
    if (ulRc == 0) 
    {
#ifndef _WIN64
	    pci->ci_Finalize(pv);
#endif // WIN64
	    FreePv(&pci->ci_Start);
    }
    return ulRc;
}

/*****************************************************************************
 *
 *	Forward_QueryInterface (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP
Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_QueryInterface(punk, riid, ppvObj);
}

/*****************************************************************************
 *
 *	Forward_AddRef (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_AddRef(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_AddRef(punk);
}

/*****************************************************************************
 *
 *	Forward_Release (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_Release(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_Release(punk);
}

/*****************************************************************************
 *
 *	_Common_New
 *
 *	Create a new object with refcount 1 and the specific vtbl.
 *	All other fields are zero-initialized.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_New(ULONG cb, PV vtbl, PPV ppvObj)
{
    HRESULT hres;
    UNALIGNED PVOID * ppv;

    EnterProc(Common_New, (_ "u", cb));
    hres = AllocCbPpv(cb + sizeof(CIN), ppvObj);
    if (SUCCEEDED(hres)) 
    {
	    PCI pci = pvAddPvCb(*ppvObj, sizeof(CIN));
        D(pci->ci_dwSig = ci_dwSignature);
        ppv = &(pci->cip[0].cip_prevtbl);
	    *ppv = vtbl;

	    *ppvObj = pci;
	    Common_AddRef(pci);
	    hres = NOERROR;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Invoke_Release
 *
 *	Release the object (if there is one) and wipe out the back-pointer.
 *	Note that we wipe out the value before calling the release, in order
 *	to ameliorate various weird callback conditions.
 *
 *****************************************************************************/

void EXTERNAL
Invoke_Release(PV pv)
{
    LPUNKNOWN punk = pvExchangePpvPv(pv, 0);
    if (punk) {
	punk->lpVtbl->Release(punk);
    }
}

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\fnd.c ===
/*****************************************************************************
 *
 *	fnd.c - Find ... On the Internet
 *
 *****************************************************************************/

#include "fnd.h"
#include <advpub.h>
#include <shlwapi.h>

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/*****************************************************************************
 *
 *	DllGetClassObject
 *
 *	OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *****************************************************************************/

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(DllGetClassObject, (_ "G", rclsid));
    if (IsEqualIID(rclsid, &CLSID_Fnd)) {
	hres = CFndFactory_New(riid, ppvObj);
    } else {
	*ppvObj = 0;
	hres = CLASS_E_CLASSNOTAVAILABLE;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	DllCanUnloadNow
 *
 *	OLE entry point.  Fail iff there are outstanding refs.
 *
;begin_internal
 *	There is an unavoidable race condition between DllCanUnloadNow
 *	and the creation of a new reference:  Between the time we
 *	return from DllCanUnloadNow() and the caller inspects the value,
 *	another thread in the same process may decide to call
 *	DllGetClassObject, thus suddenly creating an object in this DLL
 *	when there previously was none.
 *
 *	It is the caller's responsibility to prepare for this possibility;
 *	there is nothing we can do about it.
;end_internal
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

extern void GetWABDllPath(LPTSTR szPath, ULONG cb);

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");

HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
#ifdef UNICODE
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378);
#else
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377);
#endif // UNICODE
                    if (pfn != NULL)
                        hInst = pfn(c_szWABResourceDLL, hInstWAB32, 0);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if (NULL == hInst)
    {
        GetWABDllPath(szPath, sizeof(szPath));
        iEnd = lstrlen(szPath);
        if (iEnd > 0)
        {
            iEnd = iEnd - lstrlen(c_szWABDLL);
            StrCpyN(&szPath[iEnd], c_szWABResourceDLL, sizeof(szPath)/sizeof(TCHAR)-iEnd);
            hInst = LoadLibrary(szPath);
        }
    }

    return(hInst);
}

/*****************************************************************************
 *
 *	Entry32
 *
 *	DLL entry point.
 *
 *****************************************************************************/

BOOL APIENTRY
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) 
    {
    case DLL_PROCESS_ATTACH:
        g_hinstApp = hinst;
    	g_hinst = LoadWABResourceDLL(hinst);
	    DisableThreadLibraryCalls(hinst);
        break;

    case DLL_PROCESS_DETACH:
        if (g_hinst)
        {
            FreeLibrary(g_hinst);
            g_hinst = 0;
        }
        if (g_hinstWABDLL)
        {
            FreeLibrary(g_hinstWABDLL);
            g_hinstWABDLL = 0;
        }
        break;
    }
    return 1;
}

/*****************************************************************************
 *
 *	The long-awaited CLSID
 *
 *****************************************************************************/

#include <initguid.h>

// {37865980-75d1-11cf-bfc7-444553540000}
//DEFINE_GUID(CLSID_Fnd, 0x37865980, 0x75d1, 0x11cf,
//		       0xbf,0xc7,0x44,0x45,0x53,0x54,0,0);
// {32714800-2E5F-11d0-8B85-00AA0044F941}
DEFINE_GUID(CLSID_Fnd, 
0x32714800, 0x2e5f, 0x11d0, 0x8b, 0x85, 0x0, 0xaa, 0x0, 0x44, 0xf9, 0x41);

const static char c_szReg[]         = "Reg";
const static char c_szUnReg[]       = "UnReg";
const static char c_szAdvPackDll[]  = "ADVPACK.DLL";

// Selfreg.inx strings
const static char c_szWABPEOPLE[]   = "WAB_PEOPLE";
const static char c_szWABFIND[]     = "WABFIND";

#define CCHMAX_RES 255

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT     hr;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    char        szWabfindDll[MAX_PATH];
    char        szMenuText[CCHMAX_RES];
    char        szLocMenuText[CCHMAX_RES];
    STRENTRY    seReg[3];
    STRTABLE    stReg;

    hr = E_FAIL;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL)
        {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL)
            {
            UINT ids;

            // Figure out the OS we are running on for correct menu text (&People or For &People)
            OSVERSIONINFO verinfo;
            verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            if (GetVersionEx(&verinfo) && 
                (VER_PLATFORM_WIN32_NT == verinfo.dwPlatformId) && (5 <= verinfo.dwMajorVersion))
                // NT5+
                ids = IDS_FORPEOPLE;
            else
                // Something else
                ids = IDS_PEOPLE;
        
            LoadString(g_hinst, ids, szMenuText, CCHMAX_RES);


            seReg[0].pszName  = (LPSTR)c_szWABPEOPLE;
            seReg[0].pszValue = (LPSTR)szMenuText;
            
            // Borrow szWabfindDll to hold the resource DLL name
            GetModuleFileName(g_hinst, szWabfindDll, ARRAYSIZE(szWabfindDll));
            seReg[1].pszName = "LOC_WAB_PEOPLE";
            wnsprintf(szLocMenuText, ARRAYSIZE(szLocMenuText), "@%s,-%d", szWabfindDll, ids);
            seReg[1].pszValue = szLocMenuText;

            GetModuleFileName(g_hinstApp, szWabfindDll, ARRAYSIZE(szWabfindDll));
            seReg[2].pszName  = (LPSTR)c_szWABFIND;
            seReg[2].pszValue = szWabfindDll;
            
            stReg.cEntries = 3;
            stReg.pse = seReg;

            // Call the self-reg routine
            hr = pfnri(g_hinstApp, szSection, &stReg);
            }

        FreeLibrary(hAdvPack);
        }

    return(hr);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(c_szReg);

    return(hr);
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(c_szUnReg);

    return(hr);
}

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\makefile.inc ===
$O\wabfind.res : $(O)\selfreg.inf

selfreg.src : reg.src reg2.src

$(O)\selfreg.inx : selfreg.src
	cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\fndcf.c ===
/*****************************************************************************
 *
 * fndcf.c - IClassFactory interface
 *
 *****************************************************************************/

#include "fnd.h"

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflFactory

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CFndFactory, IClassFactory);

/*****************************************************************************
 *
 *	CFndFactory
 *
 *	Really nothing doing.
 *
 *****************************************************************************/

typedef struct CFndFactory {

    /* Supported interfaces */
    IClassFactory 	cf;

} CFndFactory, FCF, *PFCF;

typedef IClassFactory CF, *PCF;

/*****************************************************************************
 *
 *	CFndFactory_QueryInterface (from IUnknown)
 *	CFndFactory_AddRef (from IUnknown)
 *	CFndFactory_Finalize (from Common)
 *	CFndFactory_Release (from IUnknown)
 *
 *****************************************************************************/

#define CFndFactory_QueryInterface Common_QueryInterface
#define CFndFactory_AddRef	Common_AddRef
#define CFndFactory_Release	Common_Release
#define CFndFactory_Finalize	Common_Finalize

/*****************************************************************************
 *
 *	CFndFactory_CreateInstance (from IClassFactory)
 *
 *****************************************************************************/

STDMETHODIMP
CFndFactory_CreateInstance(PCF pcf, LPUNKNOWN punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    if (!punkOuter) {
	/* The only object we know how to create is a context menu */
	hres = CFndCm_New(riid, ppvObj);
    } else {		/* Does anybody support aggregation any more? */
	hres = ResultFromScode(CLASS_E_NOAGGREGATION);
    }
    return hres;
}

/*****************************************************************************
 *
 *	CFndFactory_LockServer (from IClassFactory)
 *
 *	Locking the server is identical to
 *	creating an object and not releasing it until you want to unlock
 *	the server.
 *
 *****************************************************************************/

STDMETHODIMP
CFndFactory_LockServer(PCF pcf, BOOL fLock)
{
    PFCF this = IToClass(CFndFactory, cf, pcf);
    if (fLock) {
	InterlockedIncrement((LPLONG)&g_cRef);
    } else {
	InterlockedDecrement((LPLONG)&g_cRef);
    }
    return NOERROR;
}

/*****************************************************************************
 *
 *	CFndFactory_New
 *
 *****************************************************************************/

STDMETHODIMP
CFndFactory_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IClassFactory)) {
	hres = Common_New(CFndFactory, ppvObj);
    } else {
	hres = ResultFromScode(E_NOINTERFACE);
    }
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbl
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CFndFactory, IClassFactory)
	CFndFactory_CreateInstance,
	CFndFactory_LockServer,
Primary_Interface_End(CFndFactory, IClassFactory)


#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inetfind.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\fndcm.c ===
/*****************************************************************************
 *
 *	fndcm.c - IContextMenu interface
 *
 *****************************************************************************/

#include "fnd.h"
#include <wab.h>
#include <shlwapi.h>

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCm

/*****************************************************************************
 *
 *	PICI
 *
 *	I'm getting lazy.
 *
 *****************************************************************************/

typedef LPCMINVOKECOMMANDINFO PICI;

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *	We must implement an IShellExtInit so the shell
 *	will know that we are ready for action.
 *
 *****************************************************************************/

Primary_Interface(CFndCm, IContextMenu);
Secondary_Interface(CFndCm, IShellExtInit);

/*****************************************************************************
 *
 *	CFndCm
 *
 *	The context menu extension for "Find... &People".
 *
 *****************************************************************************/

typedef struct CFndCm {

    /* Supported interfaces */
    IContextMenu 	cm;
    IShellExtInit	sxi;

} CFndCm, FCM, *PFCM;

typedef IContextMenu CM, *PCM;
typedef IShellExtInit SXI, *PSXI;
typedef IDataObject DTO, *PDTO;

/*****************************************************************************
 *
 *	CFndCm_QueryInterface (from IUnknown)
 *
 *	We need to check for our additional interfaces before falling
 *	through to Common_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_QueryInterface(PCM pcm, RIID riid, PPV ppvObj)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IShellExtInit)) {
	*ppvObj = &this->sxi;
	Common_AddRef(this);
	hres = NOERROR;
    } else {
	hres = Common_QueryInterface(this, riid, ppvObj);
    }
    AssertF(fLimpFF(FAILED(hres), *ppvObj == 0));
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_AddRef (from IUnknown)
 *	CFndCm_Release (from IUnknown)
 *
 *****************************************************************************/

#define CFndCm_AddRef Common_AddRef
#define CFndCm_Release Common_Release

/*****************************************************************************
 *
 *	CFndCm_Finalize (from Common)
 *
 *	Release the resources of an CFndCm.
 *
 *****************************************************************************/

void EXTERNAL
CFndCm_Finalize(PV pv)
{
    PFCM this = pv;

    EnterProc(CFndCm_Finalize, (_ "p", pv));

    ExitProc();
}


/*****************************************************************************
 *
 *	CFndCm_QueryContextMenu (From IContextMenu)
 *
 *	Given an existing context menu hmenu, insert new context menu
 *	items at location imi (imi = index to menu imi), returning the
 *	number of menu items added.
 *
 *	Our job is to add the "Find... People" menu option.
 *
 *	hmenu     - destination menu
 *	imi	  - location at which menu items should be inserted
 *	idcMin	  - first available menu identifier
 *	idcMax    - first unavailable menu identifier
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMyself[] = TEXT(".{32714800-2E5F-11d0-8B85-00AA0044F941}");

#pragma END_CONST_DATA

STDMETHODIMP
CFndCm_QueryContextMenu(PCM pcm, HMENU hmenu, UINT imi,
			UINT idcMin, UINT idcMax, UINT uFlags)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    MENUITEMINFO mii;
    TCHAR tsz[256];
    SHFILEINFO sfi;
    EnterProc(CFndCm_QueryContextMenu, (_ "pu", pcm, idcMin));

    LoadString(g_hinst, IDS_ONTHEINTERNET, tsz, cA(tsz));

    SHGetFileInfo(c_tszMyself, FILE_ATTRIBUTE_DIRECTORY, &sfi, cbX(sfi),
		  SHGFI_SMALLICON |
		  SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES);

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_UNCHECKED;
    mii.wID = idcMin;
    mii.dwItemData = sfi.iIcon;
    mii.dwTypeData = tsz;

    InsertMenuItem(hmenu, imi, TRUE, &mii);

    hres = hresUs(1);

    ExitOleProc();
    return hres;
}

const static TCHAR lpszWABRegPathKey[] = TEXT("Software\\Microsoft\\WAB\\DLLPath");
const static TCHAR lpszWABDll[] = TEXT("Wab32.dll");

// GetWABDllPath - loads the WAB DLL path from the registry
// szPath	- ptr to buffer
// cb		- sizeof buffer
//
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    ULONG  cbData = cb;
    HKEY hKey = NULL;
    if(szPath)
    {
        *szPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABRegPathKey, 0, KEY_READ, &hKey))
            RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szPath, &cbData);
    }
    if(hKey) RegCloseKey(hKey);
	return;
}

// LoadLibrary_WABDll() - Load the WAB library based on the WAB DLL path
//
HINSTANCE LoadLibrary_WABDll()
{
    TCHAR       szWABDllPath[MAX_PATH];

    // [PaulHi]  We only need one reference count on the wab32.dll.  The wabfind.dll
    // will unload the wab32.dll when it unloads.  The wabfind.dll won't unload
    // until all CMFind threads are finished through the global g_cRef variable.
    if (g_hinstWABDLL)
        return g_hinstWABDLL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    // if you want an IE4.0x WAB or later then you should fail here if the WAB
    // DLL path could not be retreived from the registry
    // Otherwise, if you don't care, you can just do a LoadLibrary("wab32.dll")
    return(g_hinstWABDLL = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : lpszWABDll ));
}


//
// Initialize the WAB and get an instance of IWABObject and IAddrBook
//
HRESULT InitWAB(LPWABOBJECT * lppWABObject,
				LPADRBOOK * lppAdrBook)
{
    HRESULT hr = E_FAIL;
    LPWABOPEN lpfnWABOpen = NULL; // defined in WABAPI.H
    HINSTANCE hinstWAB = NULL;
    WAB_PARAM WP = {0};

    WP.ulFlags = WAB_ENABLE_PROFILES;

    hinstWAB = LoadLibrary_WABDll();

    if(hinstWAB)
    {
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(hinstWAB, "WABOpen");
        if(lpfnWABOpen)
            hr = lpfnWABOpen(lppAdrBook, lppWABObject, &WP, 0);
    }

    // Remember to release the IAddrBook and IWABObject objects retrieved above

    return hr;
}


/*
-
-   WABThreadProc
*
*   Since the WAB Find thing is a dialog, it is blocking Explorer's thread
*   and user's can't access the Start menu anymore .. so we put the dialog
*   on a seperate thread
*
*/
DWORD WINAPI WABThreadProc( LPVOID lpParam )
{
    HRESULT hres;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    if(!HR_FAILED(hres = InitWAB(&lpWABObject,&lpAdrBook)))
    {
        hres = lpWABObject->lpVtbl->Find(lpWABObject,lpAdrBook,NULL);

        // Release the WAB and AB objects
        lpAdrBook->lpVtbl->Release(lpAdrBook);
        lpWABObject->lpVtbl->Release(lpWABObject);
    }

    // Our work is done, wabfind.dll can safely go away
    InterlockedDecrement((LPLONG)&g_cRef);

    return 0;
}
				
/*****************************************************************************
 *
 *	_CFndCm_InvokeFind
 *
 *****************************************************************************/

STDMETHODIMP
_CFndCm_InvokeFind(void)
{

    HANDLE hThread = NULL;
    DWORD dwThreadID = 0;

    // Increment the refcount so that when the Shell continues (the Invoke returns)
    // wabfind.dll doesn't unload when the Shell releases the FindCM
    InterlockedIncrement((LPLONG)&g_cRef);

    hThread = CreateThread( NULL,           // no security attributes
                            0,              // use default stack size
                            WABThreadProc,  // thread function
                            (LPVOID) NULL,  // argument to thread function
                            0,              // use default creation flags
                            &dwThreadID);   // returns the thread identifier

    CloseHandle(hThread);
    return S_OK;
}

/*****************************************************************************
 *
 *	CFndCm_InvokeCommand (from IContextMenu)
 *
 *	We have only one command, called "find".
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszFind[] = TEXT("find");

#pragma END_CONST_DATA

STDMETHODIMP
CFndCm_InvokeCommand(PCM pcm, PICI pici)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    EnterProc(CFndCm_InvokeCommand,
	    (_ HIWORD(pici->lpVerb) ? "pA" : "pu", pcm, pici->lpVerb));

    if (pici->cbSize >= sizeof(*pici)) {
	if (
#ifdef	SHELL32_IS_BUG_FREE //;Internal
	(HIWORD(pici->lpVerb) && lstrcmpi(c_tszFind, pici->lpVerb) == 0) || //;Internal
	     pici->lpVerb == 0 //;Internal
#else //;Internal
	fLimpFF(HIWORD(pici->lpVerb), lstrcmpi(c_tszFind, pici->lpVerb) == 0)
#endif //;Internal
	    ) {
	    hres = _CFndCm_InvokeFind();
	} else {
	    hres = E_INVALIDARG;
	}
    } else {
	hres = E_INVALIDARG;
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_GetCommandString (from IContextMenu)
 *
 *	Somebody wants to convert a command id into a string of some sort.
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_GetCommandString(PCM pcm, UINT_PTR idCmd, UINT uFlags, UINT *pwRsv,
			LPSTR pszName, UINT cchMax)
{
    PFCM this = IToClass(CFndCm, cm, pcm);
    HRESULT hres;
    EnterProc(CFndCm_GetCommandString, (_ "uu", idCmd, uFlags));

    if (idCmd == 0) {
	switch (uFlags) {
	case GCS_HELPTEXT:
	    if (cchMax) {
		pszName[0] = '\0';
		if (LoadString(g_hinst, IDS_FINDHELP, pszName, cchMax)) {
		    hres = NOERROR;
		} else {
		    hres = E_INVALIDARG;
		}
	    } else {
		hres = E_INVALIDARG;
	    }
	    break;

	case GCS_VALIDATE:
	    hres = NOERROR;
	    break;

	case GCS_VERB:
	    StrCpyN(pszName, c_tszFind, cchMax);
	    hres = NOERROR;
	    break;

	default:
	    hres = E_NOTIMPL;
	    break;
	}
    } else {
	hres = E_INVALIDARG;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_SXI_Initialize (from IShellExtension)
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_SXI_Initialize(PSXI psxi, PCIDL pidlFolder, PDTO pdto, HKEY hk)
{
    PFCM this = IToClass(CFndCm, sxi, psxi);
    HRESULT hres;
    EnterProc(CFndCm_SXI_Initialize, (_ ""));

    hres = S_OK;
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CFndCm_New (from IClassFactory)
 *
 *	Note that we release the pfcm that Common_New created, because we
 *	are done with it.  The real refcount is handled by the
 *	CFndCm_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CFndCm_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(CFndCm_New, (_ "G", riid));

    *ppvObj = 0;
    hres = Common_New(CFndCm, ppvObj);
    if (SUCCEEDED(hres)) {
	PFCM pfcm = *ppvObj;
	pfcm->sxi.lpVtbl = Secondary_Vtbl(CFndCm, IShellExtInit);
	hres = CFndCm_QueryInterface(&pfcm->cm, riid, ppvObj);
	Common_Release(pfcm);
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbls
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CFndCm, IContextMenu)
	CFndCm_QueryContextMenu,
	CFndCm_InvokeCommand,
	CFndCm_GetCommandString,
Primary_Interface_End(CFndCm, IContextMenu)

Secondary_Interface_Begin(CFndCm, IShellExtInit, sxi)
 	CFndCm_SXI_Initialize,
Secondary_Interface_End(CFndCm, IShellExtInit, sxi)

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\mem.c ===
/*****************************************************************************
 *
 *	mem.c - Memory management
 *
 *	WARNING!  These do not go through OLE allocation.  Use these
 *	only for private allocation.
 *
 *****************************************************************************/

#include "fnd.h"

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64


/*****************************************************************************
 *
 *	AllocCbPpv
 *
 *	Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
#ifdef _WIN64
    UINT cb1 = LcbAlignLcb(cb);
    *ppv = LocalAlloc(LPTR, cb1);
#else
    *ppv = LocalAlloc(LPTR, cb);
#endif // _WIN64

    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}


#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabfind\fnd.h ===
/*****************************************************************************
 *
 *	fnd.h - Main private header file
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	Coding conventions:
 *
 *	+ Follow standard shell coding conventions.
 *
 *	+ Standard K&R brace placement and indentation style.
 *
 *	+ Indent by 4 spaces.
 *
 *	+ Fully-brace all dependent clauses.  Never write "if (c) foo();"
 *
 *	+ Do not return in the middle of a function.  If forced,
 *	  use a "goto exit".  This way, you can stick entry/exit stuff
 *	  later without getting caught out.  (I learned this rule the
 *	  hard way.)
 *
 *	+ Declare variables with narrowest possible scope.
 *
 *	+ Always test for success, not failure!  The compiler will
 *	  thank you.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	NOTE!  This code was written for readability, not efficiency.
 *
 *	I'm trusting the compiler to do optimizations like these:
 *
 *	"Parameter alias":
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		LPBAR pbar = (LPBAR)pfoo;
 *		... use pbar and never mention pfoo again ...
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		#define pbar ((LPBAR)pfoo)
 *		... use pbar and never mention pfoo again ...
 *		#undef pbar
 *	    }
 *
 *	"Speculative Execution":
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		} else {		// condition 1 failed
 *		    *pfoo = 0;
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc = 0;
 *		*pfoo = 0;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		}
 *		return fRc;
 *	    }
 *
 *	"Single Exit":
 *
 *	    Function(...)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			fRc = 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			fRc = 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(...)
 *	    {
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			return 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			return 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    return 0;
 *		}
 *		NOTREACHED;
 *	    }
 *
 *
 *
 *****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE
#define _WIN32_WINDOWS 0x0400
#include <windows.h>

#ifdef	RC_INVOKED		/* Define some tags to speed up rc.exe */
#define __RPCNDR_H__		/* Don't need RPC network data representation */
#define __RPC_H__		/* Don't need RPC */
#include <oleidl.h>		/* Get the DROPEFFECT stuff */
#define _OLE2_H_		/* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#else
#include <windowsx.h>
#endif


#include <shlobj.h>
#include <shellapi.h>
#include <objbase.h>
#include "resrc2.h"

#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))

#ifndef	RC_INVOKED

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

/*****************************************************************************
 *
 *	Stuff I'm tired of typing over and over.
 *
 *****************************************************************************/

typedef LPITEMIDLIST PIDL, *PPIDL;
typedef LPCITEMIDLIST PCIDL;
typedef LPSHELLFOLDER PSF;
typedef LPVOID PV;
typedef LPVOID *PPV;
typedef LPCVOID PCV;
typedef REFIID RIID;
typedef LPUNKNOWN PUNK;

/*****************************************************************************
 *
 *	Baggage - Stuff I carry everywhere
 *
 *****************************************************************************/

#define INTERNAL NTAPI	/* Called only within a translation unit */
#define EXTERNAL NTAPI	/* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

#define OBJAT(T, v) (*(T *)(v))		/* Pointer punning */
#define PUN(T, v) OBJAT(T, &(v))	/* General-purpose type-punning */

/*
 * Convert a count of TCHAR's to a count of bytes.
 */
#define cbCtch(ctch) ((ctch) * sizeof(TCHAR))

/*
 * Convert an object (X) to a count of bytes (cb).
 */

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert an array name (A) to a pointer to its Max.
 * (I.e., one past the last element.)
 */
#define pvMaxA(a) (&a[cA(a)])

#ifdef _WIN64
#define ALIGNTYPE                       LARGE_INTEGER
#define ALIGN                           ((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)        (((lcb) + ALIGN) & ~ALIGN)
#endif

#ifdef _WIN64
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - LcbAlignLcb((cb))))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + LcbAlignLcb((cb))))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))
#else
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))
#endif //WIN64
/*
 * Round cb up to the nearest multiple of cbAlign.  cbAlign must be
 * a power of 2 whose evaluation entails no side-effects.
 */
#define ROUNDUP(cb, cbAlign) ((((cb) + (cbAlign) - 1) / (cbAlign)) * (cbAlign))

#define cbX(X) sizeof(X)

/*
 * lfNeVV
 *
 * Given two values, return zero if they are equal and nonzero if they
 * are different.  This is the same as (v1) != (v2), except that the
 * return value on unequal is a random nonzero value instead of 1.
 * (lf = logical flag)
 *
 * lfNePvPv
 *
 * The same as lfNeVV, but for pointers.
 *
 * lfPv
 *
 * Nonzero if pv is not null.
 *
 */
#define lfNeVV(v1, v2) ((v1) - (v2))
#define lfNePvPv(v1, v2) lfNeVV((DWORD)(PV)(v1), (DWORD)(PV)(v2))
#define lfPv(pv) ((BOOL)(PV)(pv))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately, due to the C language, this can't
 * be implemented, so we just return 1 if the first is nonzero.
 * GNU has an extension that supports this, which we use. //;Internal
 */

#if defined(__GNUC__) //;Internal
#define fLorFF(f1, f2) ((f1) ?: (f2)) //;Internal
#else //;Internal
#define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif //;Internal

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

/*
 * InOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

/*
 * memeq - Reverse of memcmp
 */
#define memeq !memcmp

/*
 * fPvPfnCmpPv - Compare two objects for equality using the comparison
 *		 function and the desired outcome.  E.g.,
 *
 *			fPvPfnCmpPv(psz1, lstrcmpi, >, psz2)
 *
 *		 returns nonzero if psz1 is greater than psz2 according
 *		 to lstrcmpi.
 */

#define fPvPfnCmpPv(p1, pfn, cmp, p2) (pfn(p1, p2) cmp 0)

/*
 * lstreq   - nonzero if two strings (according to lstrcmp) are equal
 * lstrne   - nonzero if two strings (according to lstrcmp) are different
 *
 * lstrieq   - nonzero if two strings (according to lstrcmpi) are equal
 * lstrine   - nonzero if two strings (according to lstrcmpi) are different
 *
 * lstrieqA  - nonzero if two strings (according to lstrcmpiA) are equal
 * lstrineA  - nonzero if two strings (according to lstrcmpiA) are different
 */

#define lstreq   !lstrcmp
#define lstrne   lstrcmp

#define lstrieq  !lstrcmpi
#define lstrine  lstrcmpi

#define lstrieqA !lstrcmpiA
#define lstrineA lstrcmpiA

/*****************************************************************************
 *
 *	Wrappers and other quickies
 *
 *****************************************************************************/

#define pvExchangePpvPv(ppv, pv) \
	(PV)InterlockedExchangePointer((ppv), (pv))

#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

/*****************************************************************************
 *
 *	Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

HINSTANCE g_hinst;		/* My resource instance handle */
HINSTANCE g_hinstApp;   /* My instance handle */
HINSTANCE g_hinstWABDLL; /* My WAB32.DLL instance handle */

//DEFINE_GUID(CLSID_Fnd, 0x37865980, 0x75d1, 0x11cf,
//		       0xbf,0xc7,0x44,0x45,0x53,0x54,0,0);
// {32714800-2E5F-11d0-8B85-00AA0044F941}
DEFINE_GUID(CLSID_Fnd, 
0x32714800, 0x2e5f, 0x11d0, 0x8b, 0x85, 0x0, 0xaa, 0x0, 0x44, 0xf9, 0x41);

/*****************************************************************************
 *
 *	Dynamic Globals.  There should be as few of these as possible.
 *
 *	All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef;			/* Global reference count */

/*****************************************************************************
 *
 *	fndcf.c - Class Factory
 *
 *****************************************************************************/

STDMETHODIMP CFndFactory_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *	fndcm.c - IContextMenu, IShellExtInit
 *
 *****************************************************************************/

STDMETHODIMP CFndCm_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *	Common object managers.
 *
 *****************************************************************************/


typedef struct PREVTBL0 {		/* Simple (non-OLE) object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL0, *PPREVTBL0;

typedef struct PREVTBL {		/* Primary interface */
    REFIID riid;			/* Type of this object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL, *PPREVTBL;

typedef struct PREVTBL2 {		/* Secondary interface */
    ULONG lib;				/* offset from start of object */
} PREVTBL2, *PPREVTBL2;

#define Simple_Interface(C) 		Primary_Interface(C, IUnknown)
#define Simple_Vtbl(C)	    		Primary_Vtbl(C)
#define Simple_Interface_Begin(C)	\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##IUnknown,				\
	    C##_Finalize,				\
	}, {						\
	    Common##_QueryInterface,			\
	    Common##_AddRef,				\
	    Common##_Release,				\

#define Simple_Interface_End(C)	    	Primary_Interface_End(C, IUnknown)

#define Primary_Interface(C, I)				\
	extern struct S_##C##Vtbl {			\
	    PREVTBL prevtbl;				\
	    I##Vtbl vtbl;				\
	} c_##C##VI					\

#define Primary_Vtbl(C) &c_##C##VI.vtbl

#define Primary_Interface_Begin(C, I)			\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##I,					\
	    C##_Finalize,				\
	}, {						\
	    C##_QueryInterface,				\
	    C##_AddRef,					\
	    C##_Release,				\

#define Primary_Interface_End(C, I)			\
	} };						\

#define Secondary_Interface(C, I)			\
	extern struct S_##I##_##C##Vtbl {		\
	    PREVTBL2 prevtbl;	 			\
	    I##Vtbl vtbl;	 			\
	} c_##I##_##C##VI				\

#define Secondary_Vtbl(C, I) &c_##I##_##C##VI.vtbl

#define Secondary_Interface_Begin(C, I, nm)		\
	struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {	\
	    _IOffset(C, nm),				\
	}, {						\
	    Forward_QueryInterface,			\
	    Forward_AddRef,				\
	    Forward_Release,				\

#define Secondary_Interface_End(C, I, nm)		\
	} };						\

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64

STDMETHODIMP Common_QueryInterface(PV, REFIID, PPV);
STDMETHODIMP_(ULONG) _Common_AddRef(PV pv);
STDMETHODIMP_(ULONG) _Common_Release(PV pv);

#define Common_AddRef _Common_AddRef
#define Common_Release _Common_Release

void EXTERNAL Common_Finalize(PV);

STDMETHODIMP _Common_New(ULONG cb, PV vtbl, PPV ppvObj);
#define Common_NewCb(cb, C, ppvObj) _Common_New(cb, Primary_Vtbl(C), ppvObj)
#define Common_New(C, ppvObj) Common_NewCb(cbX(C), C, ppvObj)

STDMETHODIMP Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj);
STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
STDMETHODIMP_(ULONG) Forward_Release(PV pv);

/*****************************************************************************
 *
 *	Common_CopyAddRef
 *
 *	Copy a pointer and increment its reference count.
 *
 *	Cannot be a macro because Common_AddRef evaluates its argument
 *	twice.
 *
 *****************************************************************************/

INLINE void Common_CopyAddRef(PV pvDst, PV pvSrc)
{
    PPV ppvDst = pvDst;
    *ppvDst = pvSrc;
    Common_AddRef(pvSrc);
}

/*****************************************************************************
 *
 *	Invoking OLE methods.
 *
 *	Invoke_Release is called with a pointer to the object, not with
 *	the object itself.  It zeros out the variable on the release.
 *
 *****************************************************************************/

void EXTERNAL Invoke_AddRef(PV pv);
void EXTERNAL Invoke_Release(PV pv);

/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *****************************************************************************/

typedef enum {
    sqflAlways		= 0x00000000,		/* Unconditional */
    sqflDll		= 0x00000001,		/* Dll bookkeeping */
    sqflFactory		= 0x00000002,		/* IClassFactory */
    sqflCm		= 0x00000004,		/* IContextMenu */
    sqflCommon		= 0x00000000,		/* common.c */
    sqflError		= 0x80000000,		/* Errors */
} SQFL;						/* squiffle */

void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);
int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);


/*****************************************************************************
 *
 *	Procedure enter/exit tracking.
 *
 *	Start a procedure with
 *
 *	EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *	The format string is documented in EmitPal.
 *
 *	End a procedure with one of the following:
 *
 *	    ExitProc();
 *
 *		Procedure returns no value.
 *
 *	    ExitProcX();
 *
 *		Procedure returns an arbitrary DWORD.
 *
 *	    ExitOleProc();
 *
 *		Procedure returns an HRESULT (named "hres").
 *
 *	    ExitOleProcPpv(ppvOut);
 *
 *		Procedure returns an HRESULT (named "hres") and, on success,
 *		puts a new object in ppvOut.
 *
 *****************************************************************************/

#define cpvArgMax	10	/* Max of 10 args per procedure */

#ifdef _WIN64
#pragma pack(push,8)
#endif // _WIN64

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCTSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);

#define AssertFPtsz(c, ptsz)
#define ValidateF(c)	(c)
#define D(x)

#define SetupEnterProc(nm)
#define DoEnterProc(v)
#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()


#define AssertF(c)	AssertFPtsz(c, TEXT(#c))

/*****************************************************************************
 *
 *	Macros that forward to the common handlers after squirting.
 *	Use these only in DEBUG.
 *
 *	It is assumed that sqfl has been #define'd to the appropriate sqfl.
 *
 *****************************************************************************/


/*****************************************************************************
 *
 *	mem.c
 *
 *	Be extremely careful with FreePv, because it doesn't work if
 *	the pointer is null.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#define FreePpv(ppv) ReallocCbPpv(0, ppv)
#define FreePv(pv) LocalFree((HLOCAL)(pv))

#ifdef _WIN64
#pragma pack(pop)
#endif //_WIN64

#endif /* !RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabhelp\adcs_ids.h ===
#define IDH_WAB_COMM_GROUPBOX	            96969600
#define IDH_WAB_PICK_RECIP_TYPE_NAME	    96969601
#define IDH_WAB_PICK_RECIP_NAME_LIST	    96969602
#define IDH_WAB_PICK_RECIP_NAME_NEW	    96969603
#define IDH_WAB_PICK_RECIP_NAME_NEW_GROUP   96969604
#define IDH_WAB_PICK_RECIP_NAME_PROPERTIES  96969605
#define IDH_WAB_PICK_RECIP_NAME_FIND        96969606
#define IDH_WAB_PICK_RECIP_NAME_TO_BUTTON   96969607
#define IDH_WAB_PICK_RECIP_NAME_TO_LIST     96969608  

//Select Group Members dialog
#define IDH_WAB_PICK_RECIP_NAME_CC_BUTTON   96969609
#define IDH_WAB_PICK_RECIP_NAME_CC_LIST     96969610
#define IDH_WAB_GROUPS_CONTACTS_FOLDER      96969670

#define IDH_WAB_FIND_FIRST                  96969611
#define IDH_WAB_FIND_LAST                   96969612	
#define IDH_WAB_FIND_E_MAIL                 96969613
#define IDH_WAB_CONTACT_PROPS_TITLE         96969614
#define IDH_WAB_CONTACT_PROPS_FIRST         96969615
#define IDH_WAB_CONTACT_PROPS_LAST          96969616
#define IDH_WAB_CONTACT_PROPS_SUFFIX        96969617
#define IDH_WAB_HOME_ADDRESS                96969618
#define IDH_WAB_HOME_CITY                   96969619
#define IDH_WAB_HOME_STATE                  96969620
#define IDH_WAB_HOME_ZIP                    96969621
#define IDH_WAB_HOME_COUNTRY                96969622
#define IDH_WAB_BUS_COMPANY                 96969623
#define IDH_WAB_BUS_TITLE                   96969624
#define IDH_WAB_BUS_DEPT                    96969625
#define IDH_WAB_BUS_OFFICE                  96969626
#define IDH_WAB_BUS_ADDRESS                 96969627
#define IDH_WAB_BUS_CITY                    96969628
#define IDH_WAB_BUS_STATE                   96969629
#define IDH_WAB_BUS_ZIP                     96969630
#define IDH_WAB_BUS_COUNTRY                 96969631
#define IDH_WAB_BUS_PHONE                   96969632
#define IDH_WAB_BUS_PHONE_BUTTON            96969633
#define IDH_WAB_BUS_FAX                     96969634
#define IDH_WAB_BUS_FAX_BUTTON              96969635
#define IDH_WAB_BUS_CELLULAR                96969636
#define IDH_WAB_BUS_CELLULAR_BUTTON         96969637
#define IDH_WAB_ANYTAB_OTHER_DROP_DOWN      96969638
#define IDH_WAB_BUS_PAGER                   96969639
#define IDH_WAB_BUS_PAGER_BUTTON            96969640
#define IDH_WAB_CONF_MODEM                  96969641
#define IDH_WAB_CONF_MODEM_BUTTON           96969642
#define IDH_WAB_NICKNAME                    96969643
#define IDH_WAB_MIDDLE_NAME                 96969644

#define IDH_WAB_APPLY                       96969646
#define IDH_WAB_ADD_EMAIL_NAME              96969647
#define IDH_WAB_EMAIL_NAME_LIST             96969648
#define IDH_WAB_DELETE_EMAIL_NAME           96969649
#define IDH_WAB_DEFAULT_EMAIL_NAME          96969650
#define IDH_WAB_HOMEPAGE                    96969651
#define IDH_WAB_HOMEPAGE_BUTTON             96969652

//Group Properties
#define IDH_WAB_GROUPNAME                   96969653
#define IDH_WAB_ADD_GROUP_MEMBERS           96969654
#define IDH_WAB_GROUP_NAME_LIST             96969655
#define IDH_WAB_DELETE_GROUP_MEMBERS        96969656
#define IDH_WAB_ADD_NEW_GROUP_CONTACTS      96969660 

#define IDH_WAB_CHK_NAME_LIST               96969657
#define IDH_WAB_PICK_USER                   96969658
#define IDH_WAB_EDIT_EMAIL_NAME             96969665
#define IDH_WAB_PICK_RECIP_NAME_BCC_BUTTON  96969666
#define IDH_WAB_PICK_RECIP_NAME_BCC_LIST    96969667
#define IDH_WAB_PICK_RECIP_NAME_DELETE      96969668
#define IDH_WABLDAP_DIR_SER_LIST            5
#define IDH_WABLDAP_GEN_ADD                 15
#define IDH_WABLDAP_GEN_REMOVE              25
#define IDH_WABLDAP_GEN_PROPERTIES          35
#define IDH_WABLDAP_OPT_SELECT              45
#define IDH_WABLDAP_OPT_REMOVE              55
#define IDH_WABLDAP_OPT_UP                  65
#define IDH_WABLDAP_OPT_DOWN                75
#define IDH_WABLDAP_OPT_DIRSERV_CHECK_AGAINST	  85
#define IDH_WABLDAP_DIRSERV_LIST            95
#define IDH_WABLDAP_OPT_COUNTRY             100
#define IDH_SHOW_NAMES_FROM                 125
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS_CONF  195
#define IDH_WABLDAP_CONNECT_TIMEOUT         205
//#define IDH_LDAP_SEARCH_SEARCH_IN         230
#define IDH_LDAP_SEARCH_FIRST_NAME          235
#define IDH_LDAP_SEARCH_LAST_NAME           240
#define IDH_LDAP_SEARCH_EMAIL_ADDRESS       245
#define IDH_LDAP_SEARCH_ORGANIZATION        250
#define IDH_LDAP_SEARCH_COUNTRY             255
#define IDH_WAB_DIR_SER_LIST                275
#define IDH_WAB_FIND_ADDRESS                280
#define IDH_WAB_FIND_PHONE                  285
#define IDH_WAB_FIND_OTHER                  290
#define IDH_WAB_FIND_FINDNOW                295
#define IDH_WAB_FIND_STOP                   297
#define IDH_WAB_FIND_CLEARALL               300
#define IDH_WAB_FIND_CLOSE                  305
#define IDH_WAB_FIND_RESULTS                310
#define IDH_WAB_FIND_DELETE                 315
#define IDH_WAB_FIND_ADD2WAB                320
#define IDH_WAB_PRINT_MEMO                  325
#define IDH_WAB_PRINT_BIZCARD               330
#define IDH_WAB_PRINT_PHONELIST             335
#define IDH_WAB_PERSONAL_NAME_DISPLAY       340
#define IDH_WAB_PROPERTIES_CERTIFICATES     4000
#define IDH_WAB_PROPERTIES_PROPERTIES       4005
#define IDH_WAB_PROPERTIES_REMOVE           4010
#define IDH_WAB_PROPERTIES_SETASDEFAULT     4015
#define IDH_WAB_PROPERTIES_IMPORT           4020
#define IDH_WAB_PROPERTIES_EXPORT           4025
#define IDH_WABLDAP_DIRSSERV_AUTH_ANON      145
#define IDH_WAB_VISITDS_BUTTON              4030
#define IDH_WAB_DIRSERV_ADDADDRESS          4035

//Conferencing tab for Properties
#define IDH_WAB_CONFERENCE_SELECT_ADDRESS   4050
#define IDH_WAB_CONFERENCE_CALL_NOW         4055
#define IDH_WAB_CONFERENCE_SERVER_NAME      4060
#define IDH_WAB_CONFERENCE_SERVER_LIST      4063
#define IDH_WAB_CONFERENCE_ADD_SERVER       4065
#define IDH_WAB_CONFERENCE_EDIT_SERVER      4070
#define IDH_WAB_CONFERENCE_REMOVE_SERVER    4075
#define IDH_WAB_CONFERENCE_SET_DEFAULT      4080
#define IDH_WAB_CONFERENCE_SET_BACKUP       4085

//Other tab for contact properties
#define IDH_WAB_NOTES                       96969645
#define IDH_WAB_OTHER_GROUP_MEMBERSHIP      4090

//Name tab for contact properties
#define IDH_WAB_PROPERTIES_SEND_USING_PLAIN_TEXT  4095

//Certificates tab for contact properties
#define IDH_WAB_CERTIFICATES_SELECT_EMAIL_ADDRESS 4100

//Advanced tab in Find People
#define IDH_WAB_FIND_ADV_CRITERIA           96969680
#define IDH_WAB_FIND_ADV_CRITERIA_DISPLAY   96969681
#define IDH_WAB_FIND_ADV_CRITERIA_ADD       96969682
#define IDH_WAB_FIND_ADV_CRITERIA_REMOVE    96969683

//Properties dialog, Home tab
#define IDH_WAB_HOME_GENDER                 96969684

//Properties dialog, Other tab
#define IDH_WAB_OTHER_FOLDER                96969685

//Properties dialog, Summary tab
#define IDH_WAB_SUMMARY                     96969686

//New Call dialog (the dialer)
#define IDH_WAB_DIALER_CONTACT              96969687
#define IDH_WAB_DIALER_PHONE                96969688
#define IDH_WAB_DIALER_PROPERTIES           96969689
#define IDH_WAB_DIALER_CALL                 96969690
#define IDH_WAB_DIALING_PROPERTIES          96969691

//Properties dialog, Business tab
#define IDH_WAB_BUSINESS_VIEWMAP            96969692
#define IDH_WAB_BUSINESS_DEFAULTBOX         96969693
#define IDH_WAB_BUSINESS_IPPHONE            96969694

//Properties dialog, Organization tab
#define IDH_WAB_ORGANIZATION_MANAGER        96969695
#define IDH_WAB_ORGANIZATION_REPORTS        96969696

//Properties dialog, Personal (new) tab
#define IDH_WAB_PERSONAL_SPOUSE             96969697
#define IDH_WAB_PERSONAL_CHILDREN           96969698
#define IDH_WAB_PERSONAL_BIRTHDAY           96969699
#define IDH_WAB_PERSONAL_ANNIVERSARY        96969700
#define IDH_WAB_PERSONAL_ADD                96969701
#define IDH_WAB_PERSONAL_EDIT               96969702
#define IDH_WAB_PERSONAL_REMOVE             96969703

//Money tab
#define IDH_WAB_FINANCIAL			400
#define IDH_WAB_PAYMENT_TERMS			405
#define IDH_WAB_BALANCE_DUE			410
#define IDH_WAB_BALANCE_OVERDUE			415
#define IDH_WAB_RECENT_INVOICES			420

//Group and Group Details tabs
#define IDH_WAB_GROUP_NAME                  96969710
#define IDH_WAB_GROUP_EMAIL                 96969712
#define IDH_WAB_GROUP_PROPERTIES            96969714
#define IDH_WAB_GROUP_ADD                   96969716
#define IDH_WAB_GROUP_UPDATE                96969718
#define IDH_WAB_GROUP_CANCEL_EDIT           96969720
#define IDH_WAB_DETAILS_ADDRESS             96969722
#define IDH_WAB_DETAILS_CITY                96969724
#define IDH_WAB_DETAILS_STATE               96969726
#define IDH_WAB_DETAILS_ZIP                 96969728
#define IDH_WAB_DETAILS_COUNTRY             96969730
#define IDH_WAB_DETAILS_PHONE               96969732
#define IDH_WAB_DETAILS_FAX                 96969734
#define IDH_WAB_DETAILS_WEBPAGE             96969736
#define IDH_WAB_DETAILS_GO                  96969738

//Choose Profile dialog box
#define IDH_WAB_CHOOSE_PROFILE_CREATE_NEW   96969740
#define IDH_WAB_CHOOSE_PROFILE_SELECTFROM   96969742
#define IDH_WAB_CHOOSE_PROFILE_LIST         96969744
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\loadgif.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\loadgif.cpp
//
//  Contents: gif decoder, copied from direct animation source: danim\src\appel\util\loadgif.cpp
//
//------------------------------------------------------------------------------------
//#include <wininetp.h>

//bw #include "headers.h"

// #define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ole2.h>
#include <math.h>


#include <windowsx.h>

/*lint ++flb*/

//bw DeclareTag(tagImageDecode, "Image Decode", "Image Decode Filters");

const long COLORKEY_NOT_SET = -1;

/*-- 
Structs from IE img.hxx 
--*/

void * __cdecl
_calloc(size_t num, size_t size)
{
    void * pv = malloc(num * size);
    if (NULL == pv)
    {
        return NULL;
    }
    ZeroMemory(pv, num * size);
    return pv;
}

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   free(_gifinfo.pstack);
   free(_gifinfo.table[0]);
   free(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      free(curPgf->ppixels);
      free(curPgf->pcolors);
      free(curPgf->pbmi);
      free(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout = 0;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return ((long)lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        //bw //bw TraceTag((tagImageDecode, "bad gif colormap."));
                        return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if(input_code_size < MINIMUM_CODE_SIZE)
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                free( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                free( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                free( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) malloc((_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) malloc((_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        free(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        free(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        free(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      //bw Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          //bw Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    long index;
    unsigned short *lp;
    
        if (_gifinfo.stacksize >= MAX_STACK_SIZE) return 0;

	index = long(_gifinfo.sp - _gifinfo.pstack);
    lp = (unsigned short *)realloc(_gifinfo.pstack, (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(lp == 0)
        return 0;
        
    _gifinfo.pstack = lp;
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    lp = &(_gifinfo.pstack[_gifinfo.stacksize]);
    return lp;
}

BOOL
CImgGif::growTables()
{
    unsigned short *lp;

    lp = (unsigned short *) realloc(_gifinfo.table[0], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[0] = lp;
    
    lp = (unsigned short *) realloc(_gifinfo.table[1], (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(lp == 0){
        return FALSE; 
    }
    _gifinfo.table[1] = lp;

    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (USHORT)(_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (USHORT)(_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return (NULL);
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

     cbImage = padlen * height * sizeof(char);

     if (   cbImage > dwMaxGIFBits
        ||  (image = (unsigned char *) _calloc(1, cbImage)) == NULL)
    {
         //bw TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
         return (NULL);
    }

        if (c == 1)
        {
                // Netscape seems to field these bogus GIFs by filling treating them
                // as transparent. While not the optimal way to simulate this effect,
                // we'll fake it by pushing the initial code size up to a safe value,
                // consuming the input, and returning a buffer full of the transparent
                // color or zero, if no transparency is indicated.
                if (initLWZ(MINIMUM_CODE_SIZE))
                        while (readLWZ() >= 0);
                else {
          //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
          free(image);
          return (NULL);
        }

                if (_gifinfo.Gif89.transparent != -1)
						FillMemory(image, cbImage, (BYTE)_gifinfo.Gif89.transparent);
                else // fall back on the background color 
                        FillMemory(image, cbImage, 0);
                
                return image;
        }
        else if (initLWZ(c) == FALSE)
        {
                free(image);
        //bw TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        return NULL;
        }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
//              message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                    goto abort;

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
//                  message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0)
                                ;
    return (image);

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                //bw TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) _calloc(1, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
    HRESULT hr = S_OK;
    unsigned char buf[16];
    unsigned char c;
    unsigned char localColorMap[3][MAXCOLORMAPSIZE];
    long useGlobalColormap;
    long imageCount = 0;
    long imageNumber = 1;
    unsigned char *image = NULL;
    unsigned long i;
    long bitPixel;
    PGIFFRAME pgfLast = NULL;
    PGIFFRAME pgfNew;
    GIFSCREEN* GifScreen = new GIFSCREEN;
    if (GifScreen == NULL)
    {
        hr = E_FAIL;
        goto done;  
    }
    
    _gifinfo.ZeroDataBlock = 0;
    
    /*
    * Initialize GIF89 extensions
    */
    _gifinfo.Gif89.transparent = -1;
    _gifinfo.Gif89.delayTime = 5;
    _gifinfo.Gif89.inputFlag = -1;
    _gifinfo.Gif89.disposal = 0;
    _gifinfo.lGifLoc = 0;
    
    // initialize our animation fields
    _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
    _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
    _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
    _gad.cLoops = 0;                
    _gad.pgf = NULL;
    _gad.pcolorsGlobal = NULL;
    
    if (!Read(buf, 6))
    {
        //bw TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
        hr = E_FAIL;
        goto done;  
    }
    
    if (!IsGifHdr(buf)) {
        //bw TraceTag((tagImageDecode, "GIF: Malformed header\n"));
        hr = E_FAIL;
        goto done;
    }
    
    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;
    
    if (!Read(buf, 7))
    {
        //bw TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
        hr = E_FAIL;
        goto done;
    }
    
    GifScreen->Width = LM_to_uint(buf[0], buf[1]);
    GifScreen->Height = LM_to_uint(buf[2], buf[3]);
    GifScreen->BitPixel = 2 << (buf[4] & 0x07);
    GifScreen->ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
    GifScreen->Background = buf[5];
    GifScreen->AspectRatio = buf[6];
    
    if (BitSet(buf[4], LOCALCOLORMAP))
    {                                                       /* Global Colormap */
        int scale = 65536 / MAXCOLORMAPSIZE;
        
        if (ReadColorMap(GifScreen->BitPixel, GifScreen->ColorMap))
        {
            //bw TraceTag((tagImageDecode, "error reading global colormap\n"));
            hr = E_FAIL;
            goto done;
        }
        for (i = 0; i < GifScreen->BitPixel; i++)
        {
            int tmp;
            
            tmp = (BYTE) (GifScreen->ColorMap[0][i]);
            _ape[i].peRed = (BYTE) (GifScreen->ColorMap[0][i]);
            _ape[i].peGreen = (BYTE) (GifScreen->ColorMap[1][i]);
            _ape[i].peBlue = (BYTE) (GifScreen->ColorMap[2][i]);
            _ape[i].peFlags = (BYTE) 0;
        }
        for (i = GifScreen->BitPixel; i < MAXCOLORMAPSIZE; i++)
        {
            _ape[i].peRed = (BYTE) 0;
            _ape[i].peGreen = (BYTE) 0;
            _ape[i].peBlue = (BYTE) 0;
            _ape[i].peFlags = (BYTE) 0;
        }
    }
    
    if (GifScreen->AspectRatio != 0 && GifScreen->AspectRatio != 49)
    {
        float r;
        r = ((float) (GifScreen->AspectRatio) + (float) 15.0) / (float) 64.0;
        //bw TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
    }
    
    for (;; ) // our appetite now knows no bounds save termination or error
    {
        if (!Read(&c, 1))
        {
            //bw TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if (c == ';')
        {                                               /* GIF terminator */
            if (imageCount < imageNumber)
            {
                //bw TraceTag((tagImageDecode, "No images found in file\n"));
                hr = E_FAIL;
                goto done;
            }
            break;
        }
        
        if (c == '!')
        {                                               /* Extension */
            if (!Read(&c, 1))
            {
                //bw TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                hr = E_FAIL;
                goto done;
            }
            DoExtension(c);
            continue;
        }
        
        if (c != ',')
        {                                               /* Not a valid start character */
            break;
        }
        
        ++imageCount;
        
        if (!Read(buf, 9))
        {
            //bw TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
            hr = E_FAIL;
            goto done;
        }
        
        useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);
        
        bitPixel = 1 << ((buf[8] & 0x07) + 1);
        
        /*
        * We only want to set width and height for the imageNumber
        * we are requesting.
        */
        if (imageCount == imageNumber)
        {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases
            
            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen->Width;
            rectLS.bottom = GifScreen->Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                    (rectImage.bottom == rectLS.bottom &&
                    rectImage.right == rectLS.right);
            }   
            
            if (!fGoofy87a && fNoSpill)
            {
                _xWidth = GifScreen->Width;  
                _yHeight = GifScreen->Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.
                
                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen->Width &&
                    LM_to_uint(buf[6], buf[7]) == GifScreen->Height) ||
                    fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }
                
                _xWidth = LM_to_uint(buf[4], buf[5]);
                _yHeight = LM_to_uint(buf[6], buf[7]);
            }
            
            _lTrans = _gifinfo.Gif89.transparent;
            
            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
        }
        
        if (!useGlobalColormap)
        {
            if (ReadColorMap(bitPixel, localColorMap))
            {
                //bw TraceTag((tagImageDecode, "error reading local colormap\n"));
                hr = E_FAIL;
                goto done;
            }
        }
        
        // We allocate a frame record for each imag in the GIF stream, including
        // the first/primary image.
        pgfNew = (PGIFFRAME) _calloc(1, sizeof(GIFFRAME));
        
        if ( pgfNew == NULL )
        {
            //bw TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if ( _gifinfo.Gif89.delayTime != -1 )
        {
            // we have a fresh control extension for this block
            
            // convert to milliseconds
            pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;
            
            
            //REVIEW(seanf): crude hack to cope with 'degenerate animations' whose timing is set to some
            //                               small value becaue of the delays imposed by Netscape's animation process
            if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
            
        }
        else
        {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
            // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
        }
        
        pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
        pgfNew->left = LM_to_uint(buf[0], buf[1]);
        pgfNew->width = LM_to_uint(buf[4], buf[5]);
        pgfNew->height = LM_to_uint(buf[6], buf[7]);
        
        // Images that are offset, or do not cover the full logical screen are 'transparent' in the
        // sense that they require us to matte the frame onto the background.
        
        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
            pgfNew->top != 0 ||
            pgfNew->left != 0 ||
            (UINT)pgfNew->width != (UINT)GifScreen->Width ||
            (UINT)pgfNew->height != (UINT)GifScreen->Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }
        
        // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
        pgfNew->hrgnVis = NULL;
        pgfNew->iRgnKind = NULLREGION;
        
        if (!useGlobalColormap)
        {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;
            
            // CALLOC will set unused colors to <0,0,0,0>
            pgfNew->pcolors = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
            if ( pgfNew->pcolors == NULL )
            {
                DeleteRgn( pgfNew->hrgnVis );
                free( pgfNew );
                
                //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                hr = E_FAIL;
                goto done;
            }
            else
            {
                for (i = 0; i < (ULONG)bitPixel; ++i)
                {
                    pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                    pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                    pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                }
                pgfNew->cColors = bitPixel;
            }
        }
        else
        {
            if ( _gad.pcolorsGlobal == NULL )
            { // Whoa! Somebody's interested in the global color table
                // CALLOC will set unused colors to <0,0,0,0>
                _gad.pcolorsGlobal = (PALETTEENTRY *) _calloc(MAXCOLORMAPSIZE, sizeof(PALETTEENTRY));
                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen->BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                {
                    CopyMemory(_gad.pcolorsGlobal, _ape,
                        GifScreen->BitPixel * sizeof(PALETTEENTRY) );
                }
                else
                {
                    DeleteRgn( pgfNew->hrgnVis );
                    free( pgfNew );
                    //bw TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    hr = E_FAIL;
                    goto done;  
                }
            }
            pgfNew->cColors = GifScreen->BitPixel;
            pgfNew->pcolors = _gad.pcolorsGlobal;
        }
        
        // Get this in here so that GifStrectchDIBits can use it during progressive
        // rendering.
        if ( _gad.pgf == NULL )
            _gad.pgf = pgfNew;
        
        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
            LM_to_uint(buf[6], buf[7]), // height
            BitSet(buf[8], INTERLACE),
            imageCount != imageNumber);
        
        if ( pgfNew->ppixels != NULL )
        {
            // Oh JOY of JOYS! We got the pixels!
            if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;
                
                _gad.fAnimated = TRUE; // say multi-image == animated
                
                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette
                    
                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }
                
                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    free( pgfNew->pcolors );
                pgfNew->pcolors = NULL;
                
                pgfLast->pgfNext = pgfNew;
                
                // Do something to here to get the new frame on the screen.
                
                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
            else
            { // first frame
                _gad.pgf = pgfNew;
                
                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;
                
                if ( imageCount == imageNumber )
                    image = pgfNew->ppixels;
            }
            pgfLast = pgfNew;
        }
        
        // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
        // GCE for the next image
        _gifinfo.Gif89.delayTime = -1;
        
        }
        
        if ( imageCount > imageNumber )
            _gad.fAnimated = TRUE; // say multi-image == animated
        
#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
        // Indefinite stays indefinite.
        // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
        //           We'll keep it around inside this ifdef in case we decide we want it.
        if ( _gad.fLooped &&
            (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
            _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        
done:
         if (GifScreen)
         {
             delete GifScreen;
         }
         return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
            _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }
    
    return pbmi;
}

//#include <vector>
//#define vector std::vector

//+-----------------------------------------------------------------------
//
//  Member:    LoadGifImage
//
//  Overview:  Given an IStream, decode an image into an array of bitmaps
//
//  Arguments: pStream      data source
//             colorKeys    pointer to where to store colorKey data
//             numBitmaps   where to store number of bitmaps
//             delays       where to store delay array
//             loop         where to store number of times to loop
//             ppBitMaps    where to store bitmaps
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP *phBitmap)
{
    HRESULT hr = S_OK;
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif* gifimage = new CImgGif;
   if (gifimage == NULL)
   {
       hr = E_FAIL;
       goto done;
   }
   gifimage->_szFileName = NULL;
   gifimage->_gifinfo.stream = stream;
   BYTE *pbBits = gifimage->ReadGIFMaster();

   if (pbBits) {
      gifimage->_pbBits = pbBits;
      gifimage->_gad.pgf->pbmi = gifimage->FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   /*vector<>*/HBITMAP vhbmp;
   /*vector<>*/COLORREF vcolorKey;
   /*vector<>*/int vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage->_gad.pgf;
   PGIFFRAME pgfOld = NULL;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;
   unsigned int disp = 0;
    int i = 0;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage->_xWidth;
   fullHeight = gifimage->_yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   if (NULL == pgf)
   {
       hr = E_FAIL;
       goto done;
   }

   while(1) 
   {     
//      Assert(pgf);      
      pbmi = pgf->pbmi;
      if (pbmi == NULL)
      {
          hr = E_FAIL;
          goto done;
      }

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) 
      {
          hr = E_OUTOFMEMORY;
          goto done;
      }

      // Correctly composite bitmaps based on disposal method specified        
      disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = COLORKEY_NOT_SET;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      // vcolorKey.push_back(colorKey);
      vcolorKey = colorKey;

      // biao change : vhbmp.push_back(hbm);
      vhbmp = hbm;
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      // vdelay.push_back(pgf->gced.uiDelayTime);      
      vdelay = pgf->gced.uiDelayTime;

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) 
          break;
      pgfOld = pgf;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   if (gifimage->_gad.cLoops == 0 && gifimage->_gad.fLooped != 0)
   {
		*loop = 0; // HUGE_VAL;
   }
   else
   {
        *loop = gifimage->_gad.cLoops;
   }
   
   *numBitmaps = 1;

   // Since the vector will go out of scope, move contents over to heap
   *delays = (int*)malloc(1 * sizeof(int)); 
   if (NULL == *delays)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *colorKeys = (COLORREF*)malloc( sizeof(COLORREF) * 1 ); 
   if (NULL == *colorKeys)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *phBitmap = vhbmp; // biao fix [i];
   (*colorKeys)[0] = vcolorKey; // [i];
   (*delays)[0] = vdelay; //[i];

   hr = S_OK;
done:
   if (FAILED(hr))
   {
       free(*delays);
       free(*colorKeys);
       if (gifimage)
       {
           delete gifimage;
       }
   }
   return hr;
}

/*lint --flb*/

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP* phBmp)
{
    HRESULT hr;
    int numGifs = 0;
    double loop = 0;
    int * pDelays = NULL;
    COLORREF * pColorKeys = NULL;

    hr = LoadGifImage(pStream,
                      &pColorKeys,
                      &numGifs,
                      &pDelays,
                      &loop,
                      phBmp);

    if (FAILED(hr))
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\httpsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

/*
#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinHTTP.h>
*/

#define INTERNET_DEFAULT_HTTP_PORT      80
#define INTERNET_DEFAULT_HTTPS_PORT     443
#define WINHTTP_HEADER_NAME_BY_INDEX    NULL
#define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY  0
#define INTERNET_OPEN_TYPE_PRECONFIG  INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000
#define INTERNET_FLAG_NO_AUTH           0x00040000
#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_STATUS_REDIRECT            302 // object temporarily moved
#define HTTP_QUERY_WWW_AUTHENTICATE     40

typedef
VOID
(CALLBACK * WINHTTP_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

typedef enum
{
    INTERNET_SCHEME_PARTIAL = -2,
    INTERNET_SCHEME_UNKNOWN = -1,
    INTERNET_SCHEME_DEFAULT = 0,
    INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_HTTPS,
    INTERNET_SCHEME_FILE,
    INTERNET_SCHEME_SOCKS,
    INTERNET_SCHEME_RES,
    INTERNET_SCHEME_FIRST = INTERNET_SCHEME_HTTP,
    INTERNET_SCHEME_LAST = INTERNET_SCHEME_RES
} INTERNET_SCHEME, * LPINTERNET_SCHEME;

#include "session.h"

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCWSTR lpszName OPTIONAL,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    INTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    INTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} URL_COMPONENTSW, * LPURL_COMPONENTSW;

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef WINHTTP_STATUS_CALLBACK
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    );

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);


class WINHTTP_SESSION : public SESSION
{
protected:
    WINHTTP_SESSION(void);
    virtual ~WINHTTP_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT);

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );

    virtual BOOL IsHostBypassProxy(
        INTERNET_SCHEME tScheme, 
        LPCSTR pszHost, 
        DWORD cchHost) 
    {
        return TRUE; // biaow: todo
    }


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;

friend class SESSION;
friend SESSION* CreateWinHttpSession(void);
};

SESSION* CreateWinHttpSession(void)
{
    return new WINHTTP_SESSION();
}

//
// Implementation for WINHTTP_SESSION
//

// -----------------------------------------------------------------------------
WINHTTP_SESSION::WINHTTP_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
}

// -----------------------------------------------------------------------------
WINHTTP_SESSION::~WINHTTP_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0,
						0, // optional total length
                        dwContext);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             WINHTTP_HEADER_NAME_BY_INDEX,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WINHTTP_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WINHTTP_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
}

// -----------------------------------------------------------------------------
BOOL WINHTTP_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WINHTTP_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}

PVOID WINHTTP_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    return (*m_pfnStatusCallback)(hInternet,
                                  (WINHTTP_STATUS_CALLBACK)lpfnCallback,
                                  0,
                                  0);

}

BOOL WINHTTP_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}

BOOL WINHTTP_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "WinHttpCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "WinHttpOpen"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpen not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "WinHttpConnect"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpConnect not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpOpenRequest"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenRequest not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "WinHttpSendRequest"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSendRequest not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "WinHttpQueryHeaders"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryHeaders not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpSetOption"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetOption not found");
        goto exit;
    }

    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "WinHttpOpenUrl"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpOpenUrl not found");
        goto exit;
    }

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "WinHttpQueryOption"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpQueryOption not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "WinHttpCrackUrl"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpCrackUrl not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "WinHttpReadData"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpReadData not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "WinHttpSetStatusCallback"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "WinHttpAddRequestHeaders"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point WinHttpAddRequestHeaders not found");
        goto exit;
    }
    
    fRet = TRUE;

exit:
    return fRet;
}

BOOL WINHTTP_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft WinHttp Passport Authentication Service 1.4",
                                         INTERNET_OPEN_TYPE_PRECONFIG,  // ? name didn't get changed yet
                                         NULL,
                                         NULL,
                                         0 /*WINHTTP_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WINHTTP_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WINHTTP_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0,
                        0,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WINHTTP_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\inetsess.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    InetSess.cpp

Abstract:

    Implements the Passport Session that uses WinInet as the underlying transport.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"

#ifdef HINTERNET
#undef HINTERNET
#endif

#ifdef INTERNET_PORT
#undef INTERNET_PORT
#endif

#include <WinInet.h>
#include "session.h"
#include <wchar.h>
#include "passport.h"
#include <sensapi.h>

// #include "inetsess.tmh"

//
// func pointer decl for WinInet
//

typedef HINTERNET
(WINAPI * PFN_INTERNET_OPEN)(
    IN LPCWSTR lpwszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpwszProxy OPTIONAL,
    IN LPCWSTR lpwszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef HINTERNET
(WINAPI * PFN_INTERNET_CONNECT)(
    IN HINTERNET hInternet,
    IN LPCWSTR lpwszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpwszUserName OPTIONAL,
    IN LPCWSTR lpwszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef HINTERNET
(WINAPI * PFN_OPEN_REQUEST)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpwszVerb,
    IN LPCWSTR lpwszObjectName,
    IN LPCWSTR lpwszVersion,
    IN LPCWSTR lpwszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

typedef BOOL
(WINAPI * PFN_SEND_REQUEST)(
    IN HINTERNET hRequest,
    IN LPCWSTR lpwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef BOOL 
(WINAPI * PFN_QUERY_INFO)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
);

typedef BOOL 
(WINAPI* PFN_CLOSE_HANDLE)(
    IN HINTERNET hInternet
);

typedef BOOL 
(WINAPI* PFN_SET_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
);

typedef BOOL 
(WINAPI* PFN_QUERY_OPTION)(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
);

typedef HINTERNET 
(WINAPI* PFN_OPEN_URL)(
    IN HINTERNET hInternet, 
    IN LPCWSTR lpwszUrl,
    IN LPCWSTR lpwszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
);

typedef BOOL 
(WINAPI* PFN_CRACK_URL)(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents
);

typedef BOOL 
(WINAPI* PFN_READ_FILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
);

typedef INTERNET_STATUS_CALLBACK 
(WINAPI* PFN_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
);

typedef BOOL 
(WINAPI* PFN_ADD_HEADERS)(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
);

typedef BOOL
(WINAPI* PFN_IS_HOST_BYPASS_PROXY)(
    IN INTERNET_SCHEME tScheme, 
    IN LPCSTR pszHost, 
    IN DWORD cchHost);

class WININET_SESSION : public SESSION
{
protected:
    WININET_SESSION(void);
    virtual ~WININET_SESSION(void);

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET);
    virtual void Close(void);

protected:    
    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT
        );

    virtual HINTERNET OpenRequest(
            HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0);

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0);

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL);

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet);

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength);    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength);

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags);

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead);

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents);

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        );

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        );

    virtual BOOL IsHostBypassProxy(
        INTERNET_SCHEME tScheme, 
        LPCSTR pszHost, 
        DWORD cchHost);


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR pwszData,
                                PDWORD pdwDataLength
                                );
#endif // PP_DEMO

    BOOL InitHttpApi(PFN_INTERNET_OPEN*);

protected:
    HINTERNET m_hInternet;

    PFN_INTERNET_CONNECT    m_pfnConnect;
    PFN_OPEN_REQUEST        m_pfnOpenRequest;
    PFN_SEND_REQUEST        m_pfnSendRequest;
    PFN_QUERY_INFO          m_pfnQueryInfo;
    PFN_CLOSE_HANDLE        m_pfnCloseHandle;
    PFN_SET_OPTION          m_pfnSetOption;
    PFN_OPEN_URL            m_pfnOpenUrl;
    PFN_QUERY_OPTION        m_pfnQueryOption;
    PFN_CRACK_URL           m_pfnCrack;
    PFN_READ_FILE           m_pfnReadFile;
    PFN_STATUS_CALLBACK     m_pfnStatusCallback;
    PFN_ADD_HEADERS         m_pfnAddHeaders;
    PFN_IS_HOST_BYPASS_PROXY m_pfnIsHostBypassProxy;

friend class SESSION;
};

//
// Implementation for SESSION
//

SESSION* CreateWinHttpSession(void);

// -----------------------------------------------------------------------------
BOOL SESSION::CreateObject(PCWSTR pwszHttpStack, HINTERNET hSession, SESSION*& pSess)
{
    PP_ASSERT(pwszHttpStack != NULL);
    
    pSess = NULL;

    if (!::_wcsicmp(pwszHttpStack, L"WinInet.dll") || 
        !::_wcsicmp(pwszHttpStack, L"WinInet"))
    {
        pSess = new WININET_SESSION();
    }
    else
    {
        pSess = ::CreateWinHttpSession();
    }

    if (pSess)
    {
        return pSess->Open(pwszHttpStack, hSession);
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "CreateObject() failed; not enough memory");
        return FALSE;
    }
}

// -----------------------------------------------------------------------------
SESSION::SESSION(void)
{
    m_hHttpStack = 0;
    m_hCredUI = 0;
    m_RefCount = 0;

    m_pfnReadDomainCred = NULL;
    m_pfnCredFree = NULL;

    m_hKeyLM = NULL;
    m_hKeyCU = NULL;
    m_hKeyDAMap = NULL;

    m_wCurrentDAUrl[0] = 0;

    m_LastNexusDownloadTime = 0xFFFFFFFF;
}

// -----------------------------------------------------------------------------
SESSION::~SESSION(void)
{
}

BOOL SESSION::GetDAInfoFromPPNexus(
    IN BOOL             fForce,         // ignored for now, always assumes TRUE regardless of actual value
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszRealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwRealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    BOOL fRetVal = FALSE;
    HINTERNET hRequest = NULL;
    HINTERNET hConnect = NULL;
    DWORD dwError;
    
    WCHAR wNexusHost[128] = L"nexus.passport.com";
    DWORD dwHostLen = sizeof(wNexusHost); // note: size of the buffer, not # of UNICODE characters
    WCHAR wNexusObj[128] = L"rdr/pprdr.asp";
    DWORD dwObjLen = sizeof(wNexusObj);
    
    PWSTR pwszPassportUrls = NULL;
    DWORD dwUrlsLen = 0;
    DWORD dwValueType;

    WCHAR Delimiters[] = L",";
    PWSTR Token = NULL;
    // we allow only one Nexus contact per session to avoid infinite loop due to Nexus misconfiguration

    DWORD dwCurrentTime = ::GetTickCount();

    if ((dwCurrentTime >= m_LastNexusDownloadTime) && 
        (dwCurrentTime - m_LastNexusDownloadTime < 5*60*1000)) // 5 minutes
    {
        DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() failed: Nexus info already downloaded");
        goto exit;
    }

    // biaow-todo: when the Passport Team gives us THE final Nexus name, we'll then hard-code it here. And
    //             there will be no need to query registry here by then.
    
    if (m_hKeyLM)
    {
        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusHost",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusHost),
                                     &dwHostLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!

        dwError = ::RegQueryValueExW(m_hKeyLM,
                                     L"NexusObj",
                                     0,
                                     &dwValueType,
                                     reinterpret_cast<LPBYTE>(wNexusObj),
                                     &dwObjLen);

        PP_ASSERT(!(dwError == ERROR_MORE_DATA));
        // PP_ASSERT(dwValueType == REG_SZ); BVT Break!!!
    }

    CHAR NexusHost[128];
    ::WideCharToMultiByte (CP_ACP, 0, wNexusHost, -1, NexusHost, 128, NULL, NULL);

   
    hConnect = Connect(wNexusHost,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                       );
    if (hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::GetDAInfoFromPPNexus(): failed to connect to %ws; Error = %d", 
                       wNexusHost, dwErrorCode);
        goto exit;
    }

    hRequest = OpenRequest(hConnect,
                           NULL,
                           wNexusObj,
#ifdef DISABLE_SSL
                           0
#else                                                 
                           INTERNET_FLAG_SECURE
#endif
                           );

    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wNexusObj, dwErrorCode);
        goto exit;
    }


    if (!SendRequest(hRequest, NULL, 0))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!SendRequest(hRequest, NULL, 0))
                {
                    DWORD dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): SendRequest() failed");
                    goto exit;
                }
            }
        }
#else
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus(): failed");
        goto exit;
#endif // BAD_CERT_OK
    }

    if (QueryHeaders(hRequest,
                     HTTP_QUERY_PASSPORT_URLS,
                     0,
                     &dwUrlsLen) == FALSE)
    {
        if ((::GetLastError() != ERROR_INSUFFICIENT_BUFFER) || (dwUrlsLen == 0))
        {
            DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; PassportUrls header not found");
            goto exit;
        }
    }
    else
    {
        PP_ASSERT(TRUE); // should not reach here
    }
    
    pwszPassportUrls = new WCHAR[dwUrlsLen];
    if (pwszPassportUrls == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; insufficient memory");
        goto exit;
    }
    
    if (QueryHeaders(hRequest,
                     HTTP_QUERY_PASSPORT_URLS,
                     pwszPassportUrls,
                     &dwUrlsLen) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, "SESSION::GetDAInfoFromPPNexus() failed; PassportUrls header not found");
        goto exit;
    }

    Token = ::wcstok(pwszPassportUrls, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no text in between commas");
            goto next_token;
        }

        // find DALocation
        if (!::_wcsnicmp(Token, L"DALogin", ::wcslen(L"DALogin")))
        {
            PWSTR pwszDAUrl = ::wcsstr(Token, L"=");
            if (pwszDAUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DALocation");
                goto exit;
            }
            
            pwszDAUrl++; // skip "="

            while (*pwszDAUrl == (L" ")[0]) { ++pwszDAUrl; } // skip leading white spaces

            ::wcscpy(m_wDefaultDAUrl, L"https://");
            ::wcscat(m_wDefaultDAUrl, pwszDAUrl);

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                    ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerUrl",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(m_wDefaultDAUrl),
                             ::wcslen(m_wDefaultDAUrl) * sizeof(WCHAR));
                }
            }

            m_LastNexusDownloadTime = ::GetTickCount();
            fRetVal = TRUE;

            DoTraceMessage(PP_LOG_INFO, "DALocation URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DARealm", ::wcslen(L"DARealm")))
        {
            PWSTR pwszDARealm = ::wcsstr(Token, L"=");
            if (pwszDARealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DARealm");
                goto exit;
            }

            pwszDARealm++; // skip "="

            while (*pwszDARealm == (L" ")[0]) { ++pwszDARealm; } // skip leading white spaces

            if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR)) != ERROR_SUCCESS)
            {
                if (m_hKeyCU)
                {
                ::RegSetValueExW(m_hKeyCU,
                             L"LoginServerRealm",
                             0,
                             REG_SZ,
                             reinterpret_cast<const LPBYTE>(pwszDARealm),
                             ::wcslen(pwszDARealm) * sizeof(WCHAR));
                }
            }

            if (pwszRealm)
            {
                if (*pdwRealmLen < ::wcslen(pwszDARealm) + 1)
                {
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                    fRetVal = FALSE;
                    goto exit;
                }
                else
                {
                    ::wcscpy(pwszRealm, pwszDARealm);
                    *pdwRealmLen = ::wcslen(pwszDARealm) + 1;
                }
            }
            
            DoTraceMessage(PP_LOG_INFO, "DARealm URL %ws found", m_wDefaultDAUrl);
        }
        else if (!::_wcsnicmp(Token, L"DAReg", ::wcslen(L"DAReg")))
            {
                PWSTR pwszDAReg = ::wcsstr(Token, L"=");
                if (pwszDAReg == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after DAReg");
                    goto exit;
                }

                pwszDAReg++; // skip "="

                while (*pwszDAReg == (L" ")[0]) { ++pwszDAReg; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"RegistrationUrl",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszDAReg),
                                 ::wcslen(pwszDAReg) * sizeof(WCHAR));
                    }
                }

                if (pwszRegUrl)
                {
                    if (*pdwRegUrlLen < ::wcslen(pwszDAReg) + 1)
                    {
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                        fRetVal = FALSE;
                        goto exit;
                    }
                    else
                    {
                        ::wcscpy(pwszRegUrl, pwszDAReg);
                        *pdwRegUrlLen = ::wcslen(pwszDAReg) + 1;
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "DAReg URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"ConfigVersion", ::wcslen(L"ConfigVersion")))
            {
                PWSTR pwszConfigVersion = ::wcsstr(Token, L"=");
                if (pwszConfigVersion == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after ConfigVersion");
                    goto exit;
                }

                pwszConfigVersion++; // skip "="

                while (*pwszConfigVersion == (L" ")[0]) { ++pwszConfigVersion; } // skip leading white spaces

                DWORD dwVersion = _wtoi(pwszConfigVersion);

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"ConfigVersion",
                                 0,
                                 REG_DWORD,
                                 reinterpret_cast<const LPBYTE>(&dwVersion),
                                 sizeof(DWORD)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"ConfigVersion",
                                 0,
                                 REG_DWORD,
                                 reinterpret_cast<const LPBYTE>(&dwVersion),
                                 sizeof(DWORD));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "ConfigVersion URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"Help", ::wcslen(L"Help")))
            {
                PWSTR pwszHelp = ::wcsstr(Token, L"=");
                if (pwszHelp == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after Help");
                    goto exit;
                }

                pwszHelp++; // skip "="

                while (*pwszHelp == (L" ")[0]) { ++pwszHelp; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"Help",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszHelp),
                                 ::wcslen(pwszHelp) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"Help",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszHelp),
                                 ::wcslen(pwszHelp) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "Help URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"Privacy", ::wcslen(L"Privacy")))
            {
                PWSTR pwszPrivacy = ::wcsstr(Token, L"=");
                if (pwszPrivacy == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after Privacy");
                    goto exit;
                }

                pwszPrivacy++; // skip "="

                while (*pwszPrivacy == (L" ")[0]) { ++pwszPrivacy; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"Privacy",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszPrivacy),
                                 ::wcslen(pwszPrivacy) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"Privacy",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszPrivacy),
                                 ::wcslen(pwszPrivacy) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "Privacy URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"Properties", ::wcslen(L"Properties")))
            {
                PWSTR pwszProperties = ::wcsstr(Token, L"=");
                if (pwszProperties == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after Properties");
                    goto exit;
                }

                pwszProperties++; // skip "="

                while (*pwszProperties == (L" ")[0]) { ++pwszProperties; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"Properties",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszProperties),
                                 ::wcslen(pwszProperties) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"Properties",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszProperties),
                                 ::wcslen(pwszProperties) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "Properties URL %ws found", m_wDefaultDAUrl);
            }
        else if (!::_wcsnicmp(Token, L"GeneralRedir", ::wcslen(L"GeneralRedir")))
            {
                PWSTR pwszGeneralRedir = ::wcsstr(Token, L"=");
                if (pwszGeneralRedir == NULL)
                {
                    DoTraceMessage(PP_LOG_WARNING, "SESSION::GetDAInfoFromPPNexus() : no = after GeneralRedir");
                    goto exit;
                }

                pwszGeneralRedir++; // skip "="

                while (*pwszGeneralRedir == (L" ")[0]) { ++pwszGeneralRedir; } // skip leading white spaces

                if (m_hKeyLM == NULL || ::RegSetValueExW(m_hKeyLM,
                                 L"GeneralRedir",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszGeneralRedir),
                                 ::wcslen(pwszGeneralRedir) * sizeof(WCHAR)) != ERROR_SUCCESS)
                {
                    if (m_hKeyCU)
                    {
                    ::RegSetValueExW(m_hKeyCU,
                                 L"GeneralRedir",
                                 0,
                                 REG_SZ,
                                 reinterpret_cast<const LPBYTE>(pwszGeneralRedir),
                                 ::wcslen(pwszGeneralRedir) * sizeof(WCHAR));
                    }
                }

                DoTraceMessage(PP_LOG_INFO, "GeneralRedir URL %ws found", m_wDefaultDAUrl);
            }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

exit:
    if (pwszPassportUrls)
    {
        delete [] pwszPassportUrls;
    }
    if (hRequest)
    {
        CloseHandle(hRequest);
    }
    if (hConnect)
    {
        CloseHandle(hConnect);
    }

    return fRetVal;
}

BOOL SESSION::GetRealm(
    PWSTR      pwszRealm,    // user supplied buffer ...
    PDWORD     pdwRealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    ) const
{
    WCHAR wRealm[64];
    DWORD RealmLen = sizeof(wRealm);
    DWORD dwValueType;
    BOOL fRealmFound = FALSE;

    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"LoginServerRealm",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(&wRealm),
                           &RealmLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"LoginServerRealm",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(&wRealm),
                               &RealmLen) == ERROR_SUCCESS)
        {
            fRealmFound = TRUE;
        }
    }
    else
    {
        fRealmFound = TRUE;
    }

    if (!fRealmFound)
    {
        *pdwRealmLen = 0;
        return FALSE;
    }
    
    if (!pwszRealm)
    {
        *pdwRealmLen = ::wcslen(wRealm) + 1;
        return FALSE;
    }
    
    if (*pdwRealmLen < ::wcslen(wRealm) + 1)
    {
        *pdwRealmLen = ::wcslen(wRealm) + 1;
        return FALSE;
    }
    
    ::wcscpy(pwszRealm, wRealm);
    *pdwRealmLen = ::wcslen(wRealm) + 1;

    return TRUE;
}


DWORD SESSION::GetNexusVersion(void)
{
    DWORD dwVersion = 0;
    DWORD dwValueType;
    DWORD dwVerLen = sizeof(dwVersion);
    BOOL fVersionFound = FALSE;

    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"ConfigVersion",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(&dwVersion),
                           &dwVerLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"ConfigVersion",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(&dwVersion),
                               &dwVerLen) == ERROR_SUCCESS)
        {
            fVersionFound = TRUE;
        }
    }
    else
    {
        fVersionFound = TRUE;
    }

    if (fVersionFound)
    {
        return dwVersion;
    }
    else
    {
        return 0;
    }
}

BOOL SESSION::UpdateDAInfo(
    PCWSTR pwszSignIn,
    PCWSTR pwszDAUrl
    )
{
    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            DWORD dwError = ::RegSetValueExW(m_hKeyDAMap,
                                             pwszDomain,
                                             0,
                                             REG_SZ,
                                             reinterpret_cast<const LPBYTE>(const_cast<PWSTR>(pwszDAUrl)),
                                             ::wcslen(pwszDAUrl) * sizeof(WCHAR));
            if (dwError == ERROR_SUCCESS)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL SESSION::PurgeDAInfo(PCWSTR pwszSignIn)
{
    if (pwszSignIn == NULL)
    {
        return TRUE;
    }

    LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
    if (pwszDomain && m_hKeyDAMap)
    {
        ::RegDeleteValueW(m_hKeyDAMap, pwszDomain);
        
        return TRUE;
    }

    return FALSE;
}

BOOL SESSION::GetDAInfo(PCWSTR pwszSignIn,
                        LPWSTR pwszDAHostName,
                        DWORD HostNameLen,
                        LPWSTR pwszDAHostObj,
                        DWORD HostObjLen)
{
    LPCWSTR pwszDAUrl = m_wDefaultDAUrl;

    PWSTR pwszDomainDAUrl = NULL;

    if (pwszSignIn)
    {
        LPCWSTR pwszDomain = ::wcsstr(pwszSignIn, L"@");
        if (pwszDomain && m_hKeyDAMap)
        {
            pwszDomainDAUrl = new WCHAR[512];
            if (pwszDomainDAUrl == NULL)
            {
                return FALSE;
            }

            DWORD dwDomainUrlLen = 512 * sizeof(sizeof(WCHAR));
            
            DWORD dwValueType;
            DWORD dwError = ::RegQueryValueExW(m_hKeyDAMap, 
                                               pwszDomain,
                                               0,
                                               &dwValueType,
                                               reinterpret_cast<LPBYTE>(pwszDomainDAUrl),
                                               &dwDomainUrlLen);
            
            PP_ASSERT(!(dwError == ERROR_MORE_DATA));
            // PP_ASSERT(dwValueType == REG_SZ);

            if (dwError == ERROR_SUCCESS)
            {
                pwszDAUrl = pwszDomainDAUrl;
            }
        }
    }

    ::wcscpy(m_wCurrentDAUrl, pwszDAUrl);

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));

    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);

    UrlComps.lpszHostName = pwszDAHostName;
    UrlComps.dwHostNameLength = HostNameLen;

    UrlComps.lpszUrlPath = pwszDAHostObj;
    UrlComps.dwUrlPathLength = HostObjLen;

    if (CrackUrl(pwszDAUrl, 
                 0, 
                 0, 
                 &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::GetDAInfo() failed; can not crack the URL %ws",
                       pwszDAUrl);
        delete [] pwszDomainDAUrl;
        return FALSE;
    }

    delete [] pwszDomainDAUrl;
    return TRUE;
}


BOOL SESSION::GetCachedCreds(
    PCWSTR	pwszRealm,
    PCWSTR  pwszTarget,
    PCREDENTIALW** pppCreds,
    DWORD* pdwCreds
    )
{
    *pppCreds = NULL;
    *pdwCreds = 0;

    if (m_pfnReadDomainCred == NULL)
    {
        return FALSE;
    }

    ULONG CredTypes = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
    DWORD dwFlags = CRED_CACHE_TARGET_INFORMATION;
    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;


    memset ( (void*)&TargetInfo, 0, sizeof(CREDENTIAL_TARGET_INFORMATIONW));

    TargetInfo.TargetName = const_cast<PWSTR>(pwszTarget);
    TargetInfo.DnsDomainName = const_cast<PWSTR>(pwszRealm);
    TargetInfo.PackageName = L"Passport1.4";    

    TargetInfo.Flags = 0;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;

    if ((*m_pfnReadDomainCred)(&TargetInfo, 
                                dwFlags,
                                pdwCreds,
                                pppCreds ) != TRUE)
    {
        *pppCreds = NULL;
        *pdwCreds = 0;
    }

    // check to see if we've been told to ignore cached creds
    if ( g_fIgnoreCachedCredsForPassport )
    {
        if ( *pppCreds != NULL )
        {
            if (m_pfnCredFree)
            {
                m_pfnCredFree(*pppCreds);
            }
        }

        *pppCreds = NULL;
        *pdwCreds = 0;
    }

    return (*pppCreds != NULL );
}



BOOL SESSION::Open(PCWSTR /*pwszHttpStack*/, HINTERNET)
{
    BOOL fRetVal = FALSE;
    DWORD dwError;
    DWORD dwValueType;
    DWORD dwUrlLen = sizeof(m_wDefaultDAUrl); // note: size of the buffer, not # of UNICODE characters
    BOOL fDAInfoCached = FALSE; // assume NO DA info's cached locally

    dwError = ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyLM,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
        // we can't open the Passport key for read & write, let's try open it for read only
        ::RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyLM,
                          NULL);

        // if we still can't open it for read, we are still fine since we can download the info from the
        // Nexus server. *NOTE* m_hKeyLM could be NULL from this point on.
    }

    dwError = ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &m_hKeyCU,
                          NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);

        ::RegCreateKeyExW(HKEY_CURRENT_USER,
                          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ,
                          NULL,
                          &m_hKeyCU,
                          NULL);
    }

    if (m_hKeyCU)
    {
        dwError = ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);

        if (dwError != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "SESSION::Open() failed; can not create/open the Passport key; Error = %d", dwError);
        
            ::RegCreateKeyExW(m_hKeyCU,
                              L"DAMap",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ,
                              NULL,
                              &m_hKeyDAMap,
                              NULL);        
        }
    }
    
    if (m_hKeyCU == NULL || ::RegQueryValueExW(m_hKeyCU, 
                           L"LoginServerUrl",
                           0,
                           &dwValueType,
                           reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                           &dwUrlLen) != ERROR_SUCCESS)
    {
        if (m_hKeyLM && ::RegQueryValueExW(m_hKeyLM, 
                               L"LoginServerUrl",
                               0,
                               &dwValueType,
                               reinterpret_cast<LPBYTE>(m_wDefaultDAUrl),
                               &dwUrlLen) == ERROR_SUCCESS)
        {
            fDAInfoCached = TRUE;
        }
    }
    else
    {
        fDAInfoCached = TRUE;
    }

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    // PP_ASSERT(dwValueType == REG_SZ); BVT break!!!

    if (!fDAInfoCached || (::wcslen(m_wDefaultDAUrl) == ::wcslen(L"")))
    {
        if (GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                 NULL, 
                                 0, 
                                 NULL, 
                                 0) == FALSE)
        {
            goto exit;
        }
    }
    else
    {
        /*
        URL_COMPONENTSW UrlComps;
        ::memset(&UrlComps, 0, sizeof(UrlComps));

        UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);

        UrlComps.lpszHostName = m_wDAHostName;
        UrlComps.dwHostNameLength = ARRAYSIZE(m_wDAHostName);

        UrlComps.lpszUrlPath = m_wDATargetObj;
        UrlComps.dwUrlPathLength = ARRAYSIZE(m_wDATargetObj);

        if (CrackUrl(m_wDefaultDAUrl, 
                          0, 
                          0, 
                          &UrlComps) == FALSE)
        {
            DoTraceMessage(PP_LOG_ERROR, 
                           "WININET_SESSION::Open() failed; can not crack the URL %ws",
                           m_wDefaultDAUrl);
            goto exit;
        }
        */
    }

    /*
    DWORD dwRegUrlLen = sizeof(m_wRegistrationUrl);
    dwError = ::RegQueryValueExW(m_hKeyLM, 
                       L"RegistrationUrl",
                       0,
                       &dwValueType,
                       reinterpret_cast<LPBYTE>(m_wRegistrationUrl),
                       &dwRegUrlLen);

    PP_ASSERT(!(dwError == ERROR_MORE_DATA));
    */

    m_hCredUI = ::LoadLibraryW(L"advapi32.dll");
    if (m_hCredUI)
    {
        m_pfnReadDomainCred = 
                    reinterpret_cast<PFN_READ_DOMAIN_CRED_W>(::GetProcAddress(m_hCredUI, "CredReadDomainCredentialsW"));
        if (m_pfnReadDomainCred == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredReadDomainCredentialsW()"); 
        }

        m_pfnCredFree = 
            reinterpret_cast<PFN_CRED_FREE>(::GetProcAddress(m_hCredUI, "CredFree"));
        if (m_pfnCredFree == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "failed to bind to CredFree()"); 
        }
    }

    fRetVal = TRUE;

exit:

    return fRetVal;
}

void SESSION::Close(void)
{
    if (m_hCredUI)
    {
       ::FreeLibrary(m_hCredUI);
        m_hCredUI = NULL;
    }

    if (m_hKeyDAMap)
    {
        ::RegCloseKey(m_hKeyDAMap);
    }

    if (m_hKeyCU)
    {
        ::RegCloseKey(m_hKeyCU);
    }
    
    if (m_hKeyLM)
    {
        ::RegCloseKey(m_hKeyLM);
    }
}


//
// Implementation for WININET_SESSION
//

// -----------------------------------------------------------------------------
WININET_SESSION::WININET_SESSION(void)
{
    m_hInternet = NULL;

    m_pfnConnect = NULL;
    m_pfnOpenRequest = NULL;
    m_pfnSendRequest = NULL;
    m_pfnQueryInfo = NULL;
    m_pfnCloseHandle = NULL;
    m_pfnSetOption = NULL;
    m_pfnOpenUrl = NULL;
    m_pfnQueryOption = NULL;
    m_pfnCrack = NULL;
    m_pfnReadFile = NULL;
    m_pfnStatusCallback = NULL;
    m_pfnAddHeaders = NULL;
    m_pfnIsHostBypassProxy = NULL;
}

// -----------------------------------------------------------------------------
WININET_SESSION::~WININET_SESSION(void)
{
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::Connect(
    LPCWSTR lpwszServerName,
    INTERNET_PORT nPort)
{
    PP_ASSERT(m_pfnConnect != NULL);

    return (*m_pfnConnect)(m_hInternet, 
                    lpwszServerName, 
                    nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenRequest(
    HINTERNET hConnect,
    LPCWSTR lpwszVerb,
    LPCWSTR lpwszObjectName,
    DWORD dwFlags,
    DWORD_PTR dwContext)
{
    PP_ASSERT(m_pfnOpenRequest != NULL);

    return (*m_pfnOpenRequest)(hConnect,
                               lpwszVerb,
                               lpwszObjectName,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               dwFlags,
							   dwContext);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SendRequest(
    HINTERNET hRequest,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD_PTR dwContext)
{                                                                 

    PP_ASSERT(m_pfnSendRequest != NULL);

    return (*m_pfnSendRequest)(hRequest,
                        lpwszHeaders,
                        dwHeadersLength,
                        NULL,
                        0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryHeaders(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex)
{
    PP_ASSERT(m_pfnQueryInfo != NULL);

    return (*m_pfnQueryInfo)(hRequest,
                             dwInfoLevel,
                             lpvBuffer,
                             lpdwBufferLength,
                             lpdwIndex);
}

// -----------------------------------------------------------------------------
BOOL  WININET_SESSION::CloseHandle(
    IN HINTERNET hInternet)
{
    PP_ASSERT(m_pfnCloseHandle != NULL);

    return (*m_pfnCloseHandle)(hInternet);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::QueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength)
{
    PP_ASSERT(m_pfnQueryOption != NULL);

    return (*m_pfnQueryOption)(hInternet,
                               dwOption,
                               lpBuffer,
                               lpdwBufferLength
                               );
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::SetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength)
{
    PP_ASSERT(m_pfnSetOption != NULL);

    return (*m_pfnSetOption)(hInternet,
                             dwOption,
                             lpBuffer,
                             dwBufferLength);
}

// -----------------------------------------------------------------------------
HINTERNET WININET_SESSION::OpenUrl(
    LPCWSTR lpwszUrl,
    LPCWSTR lpwszHeaders,
    DWORD dwHeadersLength,
    DWORD dwFlags)
{
    PP_ASSERT(m_pfnOpenUrl != NULL);

    return (*m_pfnOpenUrl)(m_hInternet,
                           lpwszUrl,
                           lpwszHeaders,
                           dwHeadersLength,
                           dwFlags,
                           0);
}

// -----------------------------------------------------------------------------
BOOL WININET_SESSION::ReadFile(
    HINTERNET hFile,
    LPVOID lpBuffer,
    DWORD dwNumberOfBytesToRead,
    LPDWORD lpdwNumberOfBytesRead)
{
    PP_ASSERT(m_pfnReadFile != NULL);

    return (*m_pfnReadFile)(
                            hFile,
                            lpBuffer,
                            dwNumberOfBytesToRead,
                            lpdwNumberOfBytesRead);
}

BOOL WININET_SESSION::CrackUrl(
    LPCWSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents)
{
    PP_ASSERT (m_pfnCrack != NULL);

    return (*m_pfnCrack)(lpszUrl,
                         dwUrlLength,
                         dwFlags,
                         lpUrlComponents);
}


PVOID WININET_SESSION::SetStatusCallback(
    HINTERNET hInternet,
    PVOID lpfnCallback
    )
{
    PP_ASSERT (m_pfnStatusCallback != NULL);

    return (*m_pfnStatusCallback)(hInternet,
                                  (INTERNET_STATUS_CALLBACK)lpfnCallback);

}

BOOL WININET_SESSION::AddHeaders(
    HINTERNET hConnect,
    LPCWSTR lpszHeaders,
    DWORD dwHeadersLength,
    DWORD dwModifiers
    )
{
    PP_ASSERT(m_pfnAddHeaders != NULL);

    return (*m_pfnAddHeaders)(hConnect,
                              lpszHeaders,
                              dwHeadersLength,
                              dwModifiers
                              );
}


BOOL WININET_SESSION::IsHostBypassProxy(
    INTERNET_SCHEME tScheme, 
    LPCSTR pszHost, 
    DWORD cchHost)
{
    PP_ASSERT(m_pfnIsHostBypassProxy != NULL);

    return (*m_pfnIsHostBypassProxy)(tScheme,
                                     pszHost,
                                     cchHost);
}




BOOL WININET_SESSION::InitHttpApi(PFN_INTERNET_OPEN* ppfnInternetOpen)
{
    BOOL  fRet = FALSE;

    m_pfnCloseHandle =
        reinterpret_cast<PFN_CLOSE_HANDLE>(::GetProcAddress(m_hHttpStack, "InternetCloseHandle"));
    if (m_pfnCloseHandle == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCloseHandle not found");
        goto exit;
    }

    *ppfnInternetOpen = 
        reinterpret_cast<PFN_INTERNET_OPEN>(::GetProcAddress(m_hHttpStack, "InternetOpenW"));
    if (*ppfnInternetOpen == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenW not found");
        goto exit;
    }

    m_pfnConnect = 
        reinterpret_cast<PFN_INTERNET_CONNECT>(::GetProcAddress(m_hHttpStack, "InternetConnectW"));
    if (m_pfnConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetConnectW not found");
        goto exit;
    }

    m_pfnOpenRequest = 
        reinterpret_cast<PFN_OPEN_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpOpenRequestW"));
    if (m_pfnOpenRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpOpenRequestW not found");
        goto exit;
    }

    m_pfnSendRequest =
        reinterpret_cast<PFN_SEND_REQUEST>(::GetProcAddress(m_hHttpStack, "HttpSendRequestW"));
    if (m_pfnSendRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpSendRequestW not found");
        goto exit;
    }

    m_pfnQueryInfo =
        reinterpret_cast<PFN_QUERY_INFO>(::GetProcAddress(m_hHttpStack, "HttpQueryInfoW"));
    if (m_pfnQueryInfo == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpQueryInfoW not found");
        goto exit;
    }
    
    m_pfnSetOption =
        reinterpret_cast<PFN_SET_OPTION>(::GetProcAddress(m_hHttpStack, "InternetSetOptionW"));
    if (m_pfnSetOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetOptionW not found");
        goto exit;
    }

    m_pfnOpenUrl =
        reinterpret_cast<PFN_OPEN_URL>(::GetProcAddress(m_hHttpStack, "InternetOpenUrlW"));
    if (m_pfnOpenUrl == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetOpenUrlW not found");
        goto exit;
    }

    m_pfnQueryOption =
            reinterpret_cast<PFN_QUERY_OPTION>(::GetProcAddress(m_hHttpStack, "InternetQueryOptionW"));
    if (m_pfnQueryOption == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetQueryOptionW not found");
        goto exit;
    }

    m_pfnCrack =
            reinterpret_cast<PFN_CRACK_URL>(::GetProcAddress(m_hHttpStack, "InternetCrackUrlW"));
        if (m_pfnCrack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetCrackUrlW not found");
        goto exit;
    }

    m_pfnReadFile =
            reinterpret_cast<PFN_READ_FILE>(::GetProcAddress(m_hHttpStack, "InternetReadFile"));
    if (m_pfnReadFile == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetReadFile not found");
        goto exit;
    }

    m_pfnStatusCallback =
        reinterpret_cast<PFN_STATUS_CALLBACK>(::GetProcAddress(m_hHttpStack, "InternetSetStatusCallbackW"));
    if (m_pfnStatusCallback == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point InternetSetStatusCallback not found");
        goto exit;
    }

    m_pfnAddHeaders =
        reinterpret_cast<PFN_ADD_HEADERS>(::GetProcAddress(m_hHttpStack, "HttpAddRequestHeadersW"));
    if (m_pfnAddHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point HttpAddRequestHeaders not found");
        goto exit;
    }

    m_pfnIsHostBypassProxy =
        reinterpret_cast<PFN_IS_HOST_BYPASS_PROXY>(::GetProcAddress(m_hHttpStack, "IsHostInProxyBypassList"));
    if (m_pfnIsHostBypassProxy == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "function entry point IsHostInProxyBypassList not found");
        goto exit;
    }


    fRet = TRUE;

exit:
    return fRet;
}

BOOL WININET_SESSION::Open(
    PCWSTR pwszHttpStack,
    HINTERNET hInternet
    )
{
    PP_ASSERT(pwszHttpStack != NULL);

    DWORD dwErrorCode;
    BOOL  fRet = FALSE;
    PFN_INTERNET_OPEN pfnInternetOpen = NULL;

    PP_ASSERT(m_hHttpStack == 0);
    m_hHttpStack = ::LoadLibraryW(pwszHttpStack);
    if (m_hHttpStack == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to load library %ws; error = %d", pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (InitHttpApi(&pfnInternetOpen) == FALSE)
    {
        goto exit;
    }

    if (hInternet)
    {
        m_hInternet = hInternet;
        m_fOwnedSession = FALSE;
    }
    else
    {
        m_hInternet = (*pfnInternetOpen)(
                                         L"Microsoft.NET-Passport-Authentication-Service/1.4; Q312461",
                                         INTERNET_OPEN_TYPE_PRECONFIG,
                                         NULL,
                                         NULL,
                                         0 /*INTERNET_FLAG_ASYNC*/ // biaow-todo: use async
                                         );
        (*m_pfnSetOption)(m_hInternet, INTERNET_OPTION_EXEMPT_CONNECTION_LIMIT, NULL, 0);

        m_fOwnedSession = TRUE;
    }
    if (m_hInternet == NULL)
    {
        dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "failed to open an HTTP session through %ws; error = %d", 
                       pwszHttpStack, dwErrorCode);
        goto exit;
    }

    if (SESSION::Open(pwszHttpStack, hInternet) == FALSE)
    {
        goto exit;
    }
    
    fRet = TRUE;

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session opened");

exit:
    if (!fRet)
    {
        if (m_hInternet && m_fOwnedSession)
        {
            (*m_pfnCloseHandle)(m_hInternet);
            m_hInternet = NULL;
        }
        if (m_hHttpStack)
        {
           ::FreeLibrary(m_hHttpStack);
            m_hHttpStack = NULL;
        }
        
        DoTraceMessage(PP_LOG_ERROR, "WinInet Http Session failed");
    }

    return fRet;
}

void WININET_SESSION::Close(void)
{
    PP_ASSERT(m_pfnCloseHandle);
    if (m_hInternet && m_fOwnedSession)
    {
        (*m_pfnCloseHandle)(m_hInternet);
        m_pfnCloseHandle = NULL;
    }

    if (m_hHttpStack)
    {
       ::FreeLibrary(m_hHttpStack);
        m_hHttpStack = NULL;
    }

    SESSION::Close();

    DoTraceMessage(PP_LOG_INFO, "WinInet Http Session closed");
}

#ifdef PP_DEMO
BOOL WININET_SESSION::ContactPartner(PCWSTR pwszPartnerUrl,
                                     PCWSTR pwszVerb,
                                     PCWSTR pwszHeaders,
                                     PWSTR  pwszData,
                                     PDWORD pdwDataLength
                                     )
{
    BOOL fRet = FALSE;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    WCHAR ServerName[128];
    WCHAR ObjectPath[1024];

    URL_COMPONENTSW UrlComps;
    ::memset(&UrlComps, 0, sizeof(UrlComps));
    
    UrlComps.dwStructSize = sizeof(UrlComps) / sizeof(WCHAR);
    
    UrlComps.lpszHostName = ServerName;
    UrlComps.dwHostNameLength = ARRAYSIZE(ServerName);

    UrlComps.lpszUrlPath = ObjectPath;
    UrlComps.dwUrlPathLength = ARRAYSIZE(ObjectPath);

    PP_ASSERT(m_pfnCrack != NULL);

    if ((*m_pfnCrack)(pwszPartnerUrl, 
                      0, 
                      0, 
                      &UrlComps) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not crack the URL %ws",
                       pwszPartnerUrl);
        goto exit;
    }

    PP_ASSERT(m_pfnConnect != NULL);

    hConnect = (*m_pfnConnect)(m_hInternet, 
                    UrlComps.lpszHostName, 
                    UrlComps.nPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);
    if (hConnect == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP sesstion to %ws:%d",
                       UrlComps.lpszHostName, UrlComps.nPort);
        goto exit;
    }

    PP_ASSERT(m_pfnOpenRequest != NULL);

    hRequest = (*m_pfnOpenRequest)(hConnect,
                               pwszVerb,
                               UrlComps.lpszUrlPath,
                               L"HTTP/1.1",
                               NULL,
                               NULL,
                               INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_NO_AUTH,
                               0);
    if (hRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not open an HTTP request to %ws:(%ws)",
                       UrlComps.lpszUrlPath, pwszVerb);
        goto exit;
    }

    PP_ASSERT(m_pfnSendRequest != NULL);

    if ((*m_pfnSendRequest)(hRequest,
                        pwszHeaders,
                        0,
                        NULL,
                        0) == FALSE)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not send an HTTP request");

        goto exit;
    }

    if (pwszData == NULL)
    {
        fRet = TRUE;
        goto exit;
    }
    
    DWORD dwStatus, dwStatusLen;
    dwStatusLen = sizeof(dwStatus);
    if (!QueryHeaders(hRequest, 
                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                      &dwStatus,
                      &dwStatusLen))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; can not query status code");
        goto exit;
    }

    if (dwStatus != HTTP_STATUS_REDIRECT)
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; expecting %d but get %d",
                       HTTP_STATUS_REDIRECT, dwStatus);
        goto exit;
    }

    ::wcscpy(pwszData, L"WWW-Authenticate: ");
    if(!QueryHeaders(hRequest,
                     HTTP_QUERY_WWW_AUTHENTICATE, 
                     (LPVOID)(pwszData + ::wcslen(L"WWW-Authenticate: ")),
                     pdwDataLength))
    {
        DoTraceMessage(PP_LOG_ERROR, 
                       "WININET_SESSION::ContactPartner() failed; no auth headers found");
        goto exit;
    }

    (*m_pfnCloseHandle)(hRequest);
    hRequest = NULL;
    (*m_pfnCloseHandle)(hConnect);
    hConnect = NULL;
    
    fRet = TRUE;

exit:
    if (hRequest)
    {
        (*m_pfnCloseHandle)(hRequest);
        hRequest = NULL;
    }

    if (hConnect)
    {
        (*m_pfnCloseHandle)(hConnect);
        hConnect = NULL;
    }

    return fRet;
}
#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\logon.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    logon.h

Abstract:

    This interface abstracts a Passport Logon Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef LOGON_H
#define LOGON_H

#include "xstring.h"

void DecryptPassword ( WCHAR* pClearPassword, PVOID pPassword, DWORD cbSize );


class SESSION;

class LOGON
{
public:
    LOGON(SESSION*, DWORD dwParentFlags);
    virtual ~LOGON(void);

    BOOL Open(PCWSTR pwszPartnerInfo);
    void Close(void);

    BOOL SetCredentials(
        PCWSTR      pwszRealm,
        PCWSTR      pwszTarget,
        PCWSTR      pwszSignIn,
        PCWSTR      pwszPassword,
        PSYSTEMTIME pTimeCredsEntered
        );

    BOOL GetLogonHost(
    	PWSTR       pwszHostName,
    	OUT PDWORD  pdwHostNameLen
        ) const;

    DWORD Logon(BOOL fAnonymous);

    PLIST_ENTRY GetPrivacyEvents(void) const { return (PLIST_ENTRY)&m_PrivacyEventList; }

    BOOL GetChallengeInfo(
		HBITMAP*		 phBitmap,
        PBOOL            pfPrompt,
    	PWSTR			 pwszCbText,
        PDWORD           pdwTextLen,
        PWSTR            pwszRealm,
        DWORD            dwMaxRealmLen,
        PWSTR            pwszReqUserName,
        PDWORD           pdwReqUserNameLen
        ) const;

    BOOL GetChallengeContent(
      	PBYTE    	     pContent,
        OUT PDWORD       pdwContentLen
        ) const;


    BOOL GetAuthorizationInfo(
        PWSTR   pwszTicket,       // e.g. "from-PP = ..."
        PDWORD  pdwTicketLen,
        PBOOL   pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
        PWSTR   pwszUrl,    // user supplied buffer ...
        PDWORD  pdwUrlLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        ) const;

    VOID StatusCallback(
        IN HINTERNET hInternet,
        IN DWORD dwInternetStatus,
        IN LPVOID lpvStatusInformation,
        IN DWORD dwStatusInformationLength);

protected:
    void GetCachedCreds(
        PCWSTR	pwszRealm,
        PCWSTR  pwszTarget,
        PCREDENTIALW** pppCreds,
        DWORD* pdwCreds
        );

    BOOL DownLoadCoBrandBitmap(
        PWSTR pwszChallenge
        );

    DWORD Handle401FromDA(
        HINTERNET   hRequest, 
        BOOL        fTicketRequest
        );

    DWORD Handle200FromDA(
        HINTERNET hRequest
        );

    void CheckForVersionChange(
        HINTERNET hRequest
        );

protected:

    SESSION*    m_pSession;

    HINTERNET   m_hConnect;
    BOOL        m_fCredsPresent;
    PWSTR       m_pwszSignIn;
    CSecureStr  m_Password;
    WCHAR       m_wNewDAUrl[1024];
    PWSTR       m_pwszTicketRequest;
    PWSTR       m_pwszAuthInfo;
    PWSTR		m_pwszReturnUrl;
    // PWSTR       m_pwszCbUrl;
	BOOL		m_fWhistler;
    HBITMAP     m_hBitmap;
    BOOL        m_fPrompt;
    WCHAR       m_wRealm[128];
    WCHAR       m_wTimeSkew[16];
    PWSTR       m_pwszAuthHeader;
    DWORD       m_dwParentFlags;
    PWSTR       m_pwszCbtxt;

    WCHAR       m_wDAHostName[256];
    LPSTREAM    m_p401Content;
    SYSTEMTIME  m_TimeCredsEntered;

    LIST_ENTRY  m_PrivacyEventList;
};

#endif // LOGON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\passport.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.cpp

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface implementation.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "ppdefs.h"
#include "wininet.h"
#include "Session.h"
#include "ole2.h"
#include "logon.h"
#include "passport.h"

// #include "passport.tmh"

BOOL g_fIgnoreCachedCredsForPassport = FALSE;
BOOL g_fCurrentProcessLoggedOn = FALSE;
WCHAR g_szUserNameLoggedOn[INTERNET_MAX_USER_NAME_LENGTH];

// -----------------------------------------------------------------------------
PP_CONTEXT 
PP_InitContext(
    PCWSTR	pwszHttpStack,
    HINTERNET hSession
    )
{
//	WPP_INIT_TRACING(L"Microsoft\\Passport1.4");
    
    if (pwszHttpStack == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitConect() : pwszHttpStack is null");
        return 0;
    }

    SESSION* pSession;
    if (SESSION::CreateObject(pwszHttpStack, hSession, pSession) == FALSE)
    {
        return 0;
    }


    DoTraceMessage(PP_LOG_INFO, "Passport Context Initialized");
    
    return reinterpret_cast<PP_CONTEXT>(pSession);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeContext(
	PP_CONTEXT hPP
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeContext() : hPP is null");
        return;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);
    
    if (pSession->RefCount() > 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "Passport Context ref count not zero before freed");
    }

    delete pSession;

    DoTraceMessage(PP_LOG_INFO, "Passport Context Freed");

//	WPP_CLEANUP();
}

BOOL
PP_GetRealm(
	PP_CONTEXT hPP,
    PWSTR      pwszDARealm,    // user supplied buffer ...
    PDWORD     pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeContext() : hPP is null");
        return FALSE;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->GetRealm(pwszDARealm, pdwDARealmLen);
}

// -----------------------------------------------------------------------------
PP_LOGON_CONTEXT
PP_InitLogonContext(
	PP_CONTEXT hPP,
    PCWSTR	pwszPartnerInfo,
    DWORD dwParentFlags
    )
{
    if (hPP == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() : hPP is null");
        return 0;
    }

    LOGON* pLogon = new LOGON(reinterpret_cast<SESSION*>(hPP), dwParentFlags);
    if (pLogon == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_InitLogonContext() failed; not enough memory");
        return 0;
    }

    if (pLogon->Open(pwszPartnerInfo) == FALSE)
    {
        delete pLogon;
        return 0;
    }

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Initialized");
    
    return reinterpret_cast<PP_LOGON_CONTEXT>(pLogon);
}

// -----------------------------------------------------------------------------
VOID 
PP_FreeLogonContext(
    PP_LOGON_CONTEXT    hPPLogon
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_FreeLogonContext() : hPPLogon is null");
        return;
    }

    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    delete  pLogon;

    DoTraceMessage(PP_LOG_INFO, "Passport Logon Context Freed");
}

// -----------------------------------------------------------------------------
DWORD
PP_Logon(
    PP_LOGON_CONTEXT    hPPLogon,
    BOOL                fAnonymous,
	HANDLE	            hEvent,
    PFN_LOGON_CALLBACK  pfnLogonCallback,
    DWORD               dwContext	
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_Logon() : hPPLogon is null");
        return 0;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->Logon(fAnonymous);
}

PLIST_ENTRY
PP_GetPrivacyEvents(
    IN PP_LOGON_CONTEXT hPPLogon
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetPrivacyEvents() : hPPLogon is null");
        return 0;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetPrivacyEvents();
}


// -----------------------------------------------------------------------------
BOOL
PP_GetChallengeInfo(
    PP_LOGON_CONTEXT hPPLogon,
	HBITMAP*		 phBitmap,
    PBOOL            pfPrompt,
  	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen,
    PWSTR            pwszReqUserName,
    PDWORD           pdwReqUserNameLen
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetInfoFromChallenge() : hPPLogon is null");
        return FALSE;
    }

	//PP_ASSERT(ppBitmap != NULL);
	//PP_ASSERT(pfPrompt != NULL);
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

	return pLogon->GetChallengeInfo(phBitmap,
									pfPrompt,
                                    pwszCbText,
                                    pdwTextLen,
                                    pwszRealm,
                                    dwMaxRealmLen,
                                    pwszReqUserName,
                                    pdwReqUserNameLen);
}

// -----------------------------------------------------------------------------
BOOL 
PP_SetCredentials(
    PP_LOGON_CONTEXT    hPPLogon,
    PCWSTR              pwszRealm,
    PCWSTR              pwszTarget,
    PCWSTR              pwszSignIn,
    PCWSTR              pwszPassword,
    PSYSTEMTIME         pTimeCredsEntered
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_SetCredentials() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->SetCredentials(pwszRealm, 
                                  pwszTarget, 
                                  pwszSignIn, 
                                  pwszPassword, 
                                  pTimeCredsEntered);
}

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetLogonHost() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);
    
    return pLogon->GetLogonHost(pwszHostName, pdwHostNameLen);
}


// -----------------------------------------------------------------------------
BOOL 
PP_GetAuthorizationInfo(
    PP_LOGON_CONTEXT hPPLogon,
	PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	OUT PDWORD       pdwTicketLen,
	PBOOL            pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	PWSTR            pwszUrl,    // user supplied buffer ...
	OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetReturnVerbAndUrl() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetAuthorizationInfo(pwszTicket, 
                                        pdwTicketLen, 
                                        pfKeepVerb, 
                                        pwszUrl, 
                                        pdwUrlLen);
}

BOOL
PP_GetChallengeContent(
    IN PP_LOGON_CONTEXT hPPLogon,
  	IN PBYTE    	    pContent,
    IN OUT PDWORD       pdwContentLen
    )
{
    if (hPPLogon == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_GetChallengeContent() : hPPLogon is null");
        return FALSE;
    }
    
    LOGON* pLogon = reinterpret_cast<LOGON*>(hPPLogon);

    return pLogon->GetChallengeContent(pContent,
                                       pdwContentLen);
}

// -----------------------------------------------------------------------------
VOID 
PP_Logout(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    )
{

    // todo - flush passport cookies


    // set flag to ignore credmgr so we don't just auto-logon again
    g_fIgnoreCachedCredsForPassport = TRUE;    

    // unset our login flag and username
    g_fCurrentProcessLoggedOn = FALSE;
    memset ( g_szUserNameLoggedOn, 0, INTERNET_MAX_USER_NAME_LENGTH*sizeof(WCHAR) );

}

BOOL
PP_ForceNexusLookup(
    PP_LOGON_CONTEXT    hPP,
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	)
{

    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

	if ( pSession != NULL )
	{
	    return pSession->GetDAInfoFromPPNexus(fForce,
                                              pwszRegUrl,
                                              pdwRegUrlLen,
                                              pwszDARealm,
                                              pdwDARealmLen);
	}
	else
	{
		return FALSE;
	}

	
}

#define PASSPORT_MAX_REALM_LENGTH   256

// returns TRUE if it was found, with the value copied to pszRealm. 
// pszRealm is expected to be at least PASSPORT_MAX_REALM_LENGTH in length
// returns FALSE if not found
BOOL ReadPassportRealmFromRegistry ( 
    WCHAR* pszRealm 
    )
{
    BOOL retval = FALSE;
    HKEY key;

    if ( pszRealm == NULL )
        return FALSE;

    if ( RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSize;

        dwSize = PASSPORT_MAX_REALM_LENGTH * sizeof(WCHAR);

        if ( RegQueryValueExW(
                key,
                L"LoginServerRealm",
                NULL,
                &dwType,
                (LPBYTE)(pszRealm),
                &dwSize) == ERROR_SUCCESS )
        {
            if ( wcslen(pszRealm) > 0 )
                retval = TRUE;
            else
                retval = FALSE;
        }
        else
        {
            retval = FALSE;
            pszRealm[0] = L'\0';
        }

        RegCloseKey(key);

    }

    return retval;

}


// if either pwszUsername or pwszPassword is not NULL, it must represent a string at least 
// INTERNET_MAX_USER_NAME_LENGTH or INTERNET_MAX_PASSWORD_LENGTH chars long, respectively

BOOL
PP_GetCachedCredential(
    PP_LOGON_CONTEXT    hPP,
    IN PWSTR            pwszRealm,
    IN PWSTR            pwszTarget,
    OUT PWSTR           pwszUsername,
    OUT PWSTR           pwszPassword
	)
{

    BOOL bRetVal = FALSE;
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    if ( pSession != NULL )
    {
        PCREDENTIALW* ppCreds;
        DWORD dwNumCreds;
        WCHAR szRealm[PASSPORT_MAX_REALM_LENGTH];
        WCHAR* pszRealm;

        if ( pwszRealm == NULL )
        {
            ReadPassportRealmFromRegistry ( szRealm );
            pszRealm = szRealm;
        }
        else
        {
            pszRealm = pwszRealm;
        }

        if (pSession->GetCachedCreds(pszRealm,
                                     pwszTarget,
                                     &ppCreds,
                                     &dwNumCreds) )
	    {
		    // look for the right cred
		    WCHAR wPass[256];
		    PCREDENTIALW pCredToUse = NULL;

		    if (dwNumCreds > 0 && ppCreds[0] != NULL )
		    {
			    for ( DWORD idx = 0; idx < dwNumCreds; idx++ )
			    {
				    if ( ppCreds[idx]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
				    {
					    // check to see if prompt bit is set.   If set, keep looking, only use if
					    // the prompt bit isn't set.
					    if ( !(ppCreds[idx]->Flags & CRED_FLAGS_PROMPT_NOW) )
					    {
						    pCredToUse = ppCreds[idx];
						    break;
					    }
				    }
			    }
		    }



		    if (pCredToUse )
		    {
			    bRetVal = TRUE;

			    DecryptPassword(wPass, 
					      PVOID(pCredToUse->CredentialBlob), 
					      pCredToUse->CredentialBlobSize);

			    if ( pwszUsername != NULL )
			    {
				    wcsncpy ( pwszUsername, pCredToUse->UserName, INTERNET_MAX_USER_NAME_LENGTH-1 );
			    }

			    if ( pwszPassword != NULL )
			    {
				    wcsncpy ( pwszPassword, wPass, INTERNET_MAX_PASSWORD_LENGTH-1 );
			    }
		    }

	    }


    }

    return bRetVal;
	
}



#ifdef PP_DEMO

// -----------------------------------------------------------------------------
BOOL PP_ContactPartner(
	PP_CONTEXT hPP,
    PCWSTR pwszPartnerUrl,
    PCWSTR pwszVerb,
    PCWSTR pwszHeaders,
    PWSTR pwszData,
    PDWORD pdwDataLength
    )
{
    if (hPP == 0)
    {
        DoTraceMessage(PP_LOG_ERROR, "PP_ContactPartner() : hPPLogon is null");
        return FALSE;
    }
    
    SESSION* pSession = reinterpret_cast<SESSION*>(hPP);

    return pSession->ContactPartner(pwszPartnerUrl,
                                    pwszVerb,
                                    pwszHeaders,
                                    pwszData,
                                    pdwDataLength
                                    );
}

#endif // PP_DEMO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\passport.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passport.h

Abstract:

    WinInet/WinHttp- Passport Auenthtication Package Interface.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PASSPORT_H
#define PASSPORT_H


extern BOOL g_fIgnoreCachedCredsForPassport;
extern BOOL g_fCurrentProcessLoggedOn;
extern WCHAR g_szUserNameLoggedOn[128];         // 128 = INTERNET_MAX_USER_NAME_LENGTH, defined in wininet.h


typedef void* PP_CONTEXT;
typedef void* PP_LOGON_CONTEXT;

//
// Passport related error codes
//

// generic internal error
#define PP_GENERIC_ERROR   -1   // biaow-todo: GetLastError() to return more specific error codes

// generic async error
#define PP_REQUEST_PENDING -9

//
// return codes from PP_Logon
//
#define PP_LOGON_SUCCESS    0
#define PP_LOGON_FAILED     1
#define PP_LOGON_REQUIRED   2

//
// return codes from PP_GetReturnVerbAndUrl
//
#define PP_RETURN_KEEP_VERB 1
#define PP_RETURN_USE_GET   0

#define PFN_LOGON_CALLBACK PVOID    // biaow-todo: define the async callback prototype

struct PRIVACY_EVENT
{
    LIST_ENTRY List;
    DWORD dwStatus;
    PVOID lpvInfo;
    DWORD dwInfoLength;
};


//
// Passport Context routines
//

PP_CONTEXT 
PP_InitContext(
    IN PCWSTR    pwszHttpStack, // "WinInet.dll" or "WinHttp5.dll"

    IN HINTERNET hSession       // An existing session (i.e. hInternet) returned by InternetOpen() 
                                // or WinHttpOpen(); hSession must compatible with pwszHttpStack. 
                                // (e.g.WinInet.Dll<->InternetOpen() or WinHttp5.Dll<->WinHttpOpen() )
    );

VOID 
PP_FreeContext(
	IN PP_CONTEXT hPP
    );

BOOL
PP_GetRealm(
	IN PP_CONTEXT hPP,
    IN PWSTR      pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    );

//
// Passport Logon Context routines
//

PP_LOGON_CONTEXT
PP_InitLogonContext(
	IN PP_CONTEXT  hPP,
	IN PCWSTR      pwszPartnerInfo,   // i.e. "WWW-Authenticate: Passport1.4 ..." from partner 
                                      // site's 302 re-direct
    IN DWORD       dwParentFlags
    );

DWORD
PP_Logon(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN BOOL                fAnonymous,
	IN HANDLE	           hEvent,          // biaow-todo: async
    IN PFN_LOGON_CALLBACK  pfnLogonCallback,// biaow-todo: async
    IN DWORD               dwContext        // biaow-todo: async
    );

PLIST_ENTRY
PP_GetPrivacyEvents(
    IN PP_LOGON_CONTEXT hPPLogon
    );

// -- This method should be called when PP_Logon() returns PP_LOGON_REQUIRED 
// -- (i.e. 401 from a Passport DA)
BOOL
PP_GetChallengeInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
    OUT HBITMAP*        phBitmap,   // can be NULL; if not NULL, ownership of the bitmap 
                                    // is not transferred to the user
    OUT PBOOL           pfPrompt,
  	IN PWSTR    	    pwszCbText,
    IN OUT PDWORD       pdwTextLen,
    IN PWSTR            pwszRealm,
    IN DWORD            dwMaxRealmLen,
    PWSTR               pwszReqUserName,
    PDWORD              pdwReqUserNameLen
    );

BOOL
PP_GetChallengeContent(
    IN PP_LOGON_CONTEXT hPPLogon,
  	IN PBYTE    	    pContent,
    IN OUT PDWORD       pdwContentLen
    );

// -- if the credentials are NULL/NULL, the means the default creds will be used
// -- if default creds can not be retrieved, this method will return FALSE
BOOL 
PP_SetCredentials(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN PCWSTR              pwszRealm,
    IN PCWSTR              pwszTarget,  // optional if user/pass are known (not null)
    IN PCWSTR              pwszSignIn,  // can be NULL
    IN PCWSTR              pwszPassword, // can be NULL
    IN PSYSTEMTIME         pTimeCredsEntered // ignore if both SignIn and Pass are NULL (should be set to NULL in that case)
    );

BOOL
PP_GetLogonHost(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszHostName,    // user supplied buffer ...
	IN OUT PDWORD       pdwHostNameLen  // ... and length (will be updated to actual length 
    );

BOOL 
PP_GetAuthorizationInfo(
    IN PP_LOGON_CONTEXT hPPLogon,
	IN PWSTR            pwszTicket,       // e.g. "from-PP = ..."
	IN OUT PDWORD       pdwTicketLen,
	OUT PBOOL           pfKeepVerb, // if TRUE, no data will be copied into pwszUrl
	IN PWSTR            pwszUrl,    // user supplied buffer ...
	IN OUT PDWORD       pdwUrlLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);

// -- biaow-todo: async
VOID 
PP_AbortLogon(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    );

// -- biaow-todo: 
VOID 
PP_Logout(
    IN PP_LOGON_CONTEXT    hPPLogon,
    IN DWORD               dwFlags
    );

VOID 
PP_FreeLogonContext(
    IN PP_LOGON_CONTEXT    hPPLogon
	);

BOOL
PP_ForceNexusLookup(
    IN PP_LOGON_CONTEXT hPPLogon,
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
	);

// if either pwszUsername or pwszPassword is not NULL, it must represent a string at least 
// INTERNET_MAX_USER_NAME_LENGTH or INTERNET_MAX_PASSWORD_LENGTH chars long, respectively

BOOL
PP_GetCachedCredential(
    PP_LOGON_CONTEXT    hPP,
    IN PWSTR            pwszRealm,
    IN PWSTR            pwszTarget,
    OUT PWSTR           pwszUsername,
    OUT PWSTR           pwszPassword
	);


#ifdef PP_DEMO

BOOL PP_ContactPartner(
	IN PP_CONTEXT   hPP,
    IN PCWSTR       pwszPartnerUrl,
    IN PCWSTR       pwszVerb,
    IN PCWSTR       pwszHeaders,
    IN PWSTR        pwszData,
    IN OUT PDWORD   pdwDataLength
    );

#endif // PP_DEMO

#endif // PASSPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\logon.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Logon.cpp

Abstract:


Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#include "PPdefs.h"
#include "passport.h"
typedef int INTERNET_SCHEME;
#include "session.h"
#include "ole2.h"
#include "logon.h"
#include "wincrypt.h"

#define SIZE_OF_SALT  37
#define SALT_SHIFT     2

WCHAR g_szSalt[] = L"82BD0E67-9FEA-4748-8672-D5EFE5B779B0";

// #include "wininet.h"
#define INTERNET_MAX_USER_NAME_LENGTH   128

#include "shlwapi.h"
#include <stdio.h>

// #include "logon.tmh"

#define HTTP_STATUS_DENIED              401 // access denied
#define HTTP_STATUS_OK                  200 // request completed

#define HTTP_QUERY_FLAG_NUMBER          0x20000000
#define HTTP_QUERY_STATUS_CODE          19  // special: part of status line
#define HTTP_QUERY_AUTHENTICATION_INFO  76
#define HTTP_QUERY_WWW_AUTHENTICATE     40
#define HTTP_QUERY_RAW_HEADERS_CRLF             22  // special: all headers
#define HTTP_QUERY_PASSPORT_CONFIG              78


// NOTE*** below we assume(!) the WinInet & WinHttp shared the same error VALUE

#define ERROR_HTTP_HEADER_NOT_FOUND     12150L
#define ERROR_INTERNET_INVALID_CA       12045L
#define INTERNET_OPTION_SECURITY_FLAGS  31

#define SECURITY_FLAG_IGNORE_REVOCATION         0x00000080
#define SECURITY_FLAG_IGNORE_UNKNOWN_CA         0x00000100
#define SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200

#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.
#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID

#define SECURITY_SET_MASK       (SECURITY_FLAG_IGNORE_REVOCATION |\
                                 SECURITY_FLAG_IGNORE_UNKNOWN_CA |\
                                 SECURITY_FLAG_IGNORE_CERT_CN_INVALID |\
                                 SECURITY_FLAG_IGNORE_CERT_DATE_INVALID |\
                                 SECURITY_FLAG_IGNORE_WRONG_USAGE)

#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "
#define INTERNET_DEFAULT_HTTPS_PORT     443         //    "     "  HTTPS  "
#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://
#define INTERNET_STATUS_REDIRECT                110

#define HTTP_ADDREQ_FLAG_ADD        0x20000000
#define HTTP_ADDREQ_FLAG_REPLACE    0x80000000

#define INTERNET_FLAG_SECURE            0x00800000  // use PCT/SSL if applicable (HTTP)

#define INTERNET_STATUS_COOKIE_SENT             320
#define INTERNET_STATUS_COOKIE_RECEIVED         321

typedef struct {

    int         cSession;           // Session cookies received
    int         cPersistent;        // Persistent cookies received

    int         cAccepted;          // Number of cookies accepted
    int         cLeashed;           //               ... leashed
    int         cDowngraded;        //               ... converted to session-cookies
    int         cBlocked;           //               ... rejected

    const char *pszLocation;        // Optional: URL associated with reported cookie events
                                    // This can be used to override request URL
}
IncomingCookieState;

typedef struct {

    int     cSent;           
    int     cSuppressed;

    const char *pszLocation;        // Optional: URL associated with reported cookie events
                                    // This can be used to override request URL
}
OutgoingCookieState;

LOGON::LOGON(SESSION* pSession, DWORD dwParentFlags)
    : m_pSession(pSession)
{
    m_pSession->AddRef();

    m_hConnect = NULL;
    
    m_fCredsPresent = FALSE;
    m_pwszSignIn = NULL;

    m_pwszTicketRequest = NULL;
    m_pwszAuthInfo = NULL;
    m_pwszReturnUrl = NULL;

    m_hBitmap = NULL;
    m_fPrompt = FALSE;

    m_wTimeSkew[0] = L'\0';
    m_wNewDAUrl[0] = 0;
    m_dwParentFlags = dwParentFlags;

    m_p401Content = NULL;

    m_pwszCbtxt = NULL;

    InitializeListHead(&m_PrivacyEventList);
}

LOGON::~LOGON(void)
{
    while (!IsListEmpty(&m_PrivacyEventList)) 
    {
        PLIST_ENTRY pEntry = RemoveHeadList(&m_PrivacyEventList);
        
        PRIVACY_EVENT* pEvent = (PRIVACY_EVENT*)pEntry;

        if (pEvent->dwStatus == INTERNET_STATUS_COOKIE_SENT)
        {
            delete [] ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }
        else
        {
            delete [] ((IncomingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }

        delete [] pEvent->lpvInfo;
        
        delete pEvent;
    }

    if (m_pwszAuthInfo)
    {
        delete [] m_pwszAuthInfo;
    }
    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }
    if (m_pwszTicketRequest)
    {
        delete [] m_pwszTicketRequest;
    }
    if (m_pwszAuthHeader)
    {
        SecureZeroMemory(m_pwszAuthHeader, ::wcslen(m_pwszAuthHeader) * sizeof(WCHAR));
        delete [] m_pwszAuthHeader;
    }
    m_pSession->RemoveRef();
    if (m_p401Content)
    {
        m_p401Content->Release();
    }

    if (m_pwszCbtxt)
    {
        delete [] m_pwszCbtxt;
    }

    if (m_hBitmap)
        DeleteObject(m_hBitmap);
}

// -----------------------------------------------------------------------------
BOOL LOGON::Open(
    PCWSTR	pwszPartnerInfo // in the form of "WWW-Authenticate: Passport1.4 ..."
    )
{
    PP_ASSERT(pwszPartnerInfo != NULL);

    // locate the auth scheme name, i.e. Passport1.4
    
    PCWSTR pwszTicketRequest = ::wcsstr(pwszPartnerInfo, L"Passport1.4");
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Passport1.4 scheme not found");
        return FALSE;
    }
    
    pwszTicketRequest += ::wcslen(L"Passport1.4");
    
    // skip white spaces between the scheme name and the Ticket Request (TR)

    while (*pwszTicketRequest == (L" ")[0]) { ++pwszTicketRequest; }
    
    if (pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; Ticket Request missing");
        return FALSE;
    }
    
    // save the TR
    
    DWORD dwTrLen = ::wcslen(pwszTicketRequest);
    m_pwszTicketRequest = new WCHAR[dwTrLen + 1];
    if (m_pwszTicketRequest == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }
    ::wcscpy(m_pwszTicketRequest, pwszTicketRequest);

    m_pwszAuthHeader = new WCHAR[dwTrLen + 
                                 2048 + // Prepared for long creds
                                 512 + // some more head room
                                 1]; 
    if (m_pwszAuthHeader == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; not enough memory");
        return FALSE;
    }


    DoTraceMessage(PP_LOG_INFO, "LOGON::Open() succeed");

    return TRUE;
}

void LOGON::Close(void)
{
    PP_ASSERT(m_hConnect != NULL);
    PP_ASSERT(m_pSession != NULL);

    m_pSession->CloseHandle(m_hConnect);
    m_hConnect = NULL;
}



// pClearPassword is assumed to be at least 256 chars

void DecryptPassword ( WCHAR* pClearPassword, PVOID pPassword, DWORD cbSize )
{
    BOOL bOrigEncrypted = FALSE;

    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;
    LPWSTR pszDesc;

    if ( pClearPassword == NULL )
        return;

    if ( cbSize == 0 )
    {
        // CryptUnprotectData doesn't like to be sent a zero-length buffer
        pClearPassword[0] = L'\0';
        return;		
    }

    InBlob.pbData = (BYTE*)pPassword;
    InBlob.cbData = cbSize;

    DATA_BLOB EntropyBlob;
    WCHAR szSalt[SIZE_OF_SALT];
    wcscpy ( szSalt, g_szSalt);
    for ( int i = 0; i < SIZE_OF_SALT; i++ )
        szSalt[i] <<= SALT_SHIFT;
    EntropyBlob.pbData = (BYTE*)szSalt;
    EntropyBlob.cbData = sizeof(WCHAR)*(wcslen(szSalt)+1);

    // Should be assumed that client won't get this far without
    // having initialized for SSL via LoadSecurity().

    if ( CryptUnprotectData ( &InBlob,
                            &pszDesc,
                            &EntropyBlob,
//                            NULL,
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        if ( wcscmp (L"SSOCred", pszDesc) == 0 )
        {
            DWORD dwOutChars = OutBlob.cbData/sizeof(WCHAR);
            if ( dwOutChars < 256 )
            {
                wcsncpy ( pClearPassword, (WCHAR*)OutBlob.pbData, dwOutChars );
                pClearPassword[dwOutChars] = L'\0';
            }
            bOrigEncrypted = TRUE;
        }
        LocalFree ( pszDesc );
        LocalFree ( OutBlob.pbData );
    }

    memset ( szSalt, 0, SIZE_OF_SALT);

    if ( !bOrigEncrypted )
    {
        // copy the plain text
        wcsncpy ( pClearPassword, (WCHAR*)pPassword, 256 );
        pClearPassword[cbSize/sizeof(WCHAR)] = L'\0';
    }

    return;
}



void LOGON::GetCachedCreds(
	PCWSTR	pwszRealm,
    PCWSTR  pwszTarget,
    PCREDENTIALW** pppCreds,
    DWORD* pdwCreds
    )
{
    if (m_pSession->GetCachedCreds(pwszRealm,pwszTarget,pppCreds,pdwCreds) != FALSE)
    {
        PCREDENTIALW pCredToUse = *pppCreds[0];
        ::FileTimeToSystemTime(&(pCredToUse->LastWritten), &m_TimeCredsEntered);
    }
}

// -----------------------------------------------------------------------------
BOOL LOGON::SetCredentials(
    PCWSTR      pwszRealm,
    PCWSTR      pwszTarget,
    PCWSTR      pwszSignIn,
    PCWSTR      pwszPassword,
    PSYSTEMTIME pTimeCredsEntered
    )
{
    WCHAR wPass[256];
    PCREDENTIALW* ppCred = NULL;
    DWORD dwCreds = 0;
    PCREDENTIALW pCredToUse = NULL;

    if ((!pwszSignIn) && (!pwszPassword))
    {
        pTimeCredsEntered = NULL; // invalidate this parameter if cached creds are to be used

        GetCachedCreds(pwszRealm, pwszTarget, &ppCred, &dwCreds);

        if (dwCreds > 0 && ppCred[0] != NULL )
        {
            for ( DWORD idx = 0; idx < dwCreds; idx++ )
            {
                if ( ppCred[idx]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
                {
                    // check to see if prompt bit is set.   If set, keep looking, only use if
                    // the prompt bit isn't set.
                    if ( !(ppCred[idx]->Flags & CRED_FLAGS_PROMPT_NOW) )
                    {
                        pCredToUse = ppCred[idx];
                        break;
                    }
                }
            }
        }

        if (pCredToUse == NULL)
        {
            return FALSE;
        }

        DecryptPassword(wPass, 
                  PVOID(pCredToUse->CredentialBlob), 
                  pCredToUse->CredentialBlobSize);

        pwszSignIn = pCredToUse->UserName;
        pwszPassword = wPass;
    }
    else
    {
        if (pTimeCredsEntered == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; Timestamp not specified");
            return FALSE;
        }
    }

    if (m_pwszSignIn)
    {
        delete [] m_pwszSignIn;
    }

    DWORD dwSignInLen = ::wcslen(pwszSignIn);
    m_pwszSignIn = new WCHAR[dwSignInLen + 1];
    if (m_pwszSignIn == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        return FALSE;
    }

    ::wcscpy(m_pwszSignIn, pwszSignIn);

    if (!m_Password.SetData(pwszPassword))
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::SetCredentials() failed; not enough memory");
        delete [] m_pwszSignIn;
        m_pwszSignIn = NULL;
        return FALSE;
    }

    if (pTimeCredsEntered)
    {
        m_TimeCredsEntered = *pTimeCredsEntered;
    }
    
    m_fCredsPresent = TRUE;

    if (ppCred)
    {
        if (m_pSession->m_pfnCredFree)
        {
            m_pSession->m_pfnCredFree(ppCred);
        }
    }

    return TRUE;
}

BOOL Gif2Bmp(LPSTREAM pStream, HBITMAP* phBmp);
// -----------------------------------------------------------------------------
BOOL LOGON::DownLoadCoBrandBitmap(
    PWSTR pwszChallenge
    )
{
    PP_ASSERT(pwszChallenge != NULL);

    PWSTR pwszCbUrl = NULL;
    BOOL fRet = FALSE;

    WCHAR Delimiters[] = L",";
    PWSTR Token = ::wcstok(pwszChallenge, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no text in between commas");
            goto next_token;
        }

        // find cburl
        if (!::_wcsnicmp(Token, L"cburl", ::wcslen(L"cburl")))
        {
            PWSTR CbUrl = ::wcsstr(Token, L"=");
            if (CbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            CbUrl++; // skip "="

            while (*CbUrl == (L" ")[0]) { ++CbUrl; } // skip leading white spaces

            pwszCbUrl = new WCHAR[::wcslen(CbUrl)+1];
            if (pwszCbUrl == NULL)
            {
                DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; not enough memory");
                goto exit;
            }
            ::wcscpy(pwszCbUrl, CbUrl);

            DoTraceMessage(PP_LOG_INFO, "CoBrand URL %ws found", pwszCbUrl);
        }
        else if (!::_wcsnicmp(Token, L"ts", ::wcslen(L"ts")))
        {
            ::wcscpy(m_wTimeSkew, Token);
        }
        else if (!::_wcsnicmp(Token, L"srealm", ::wcslen(L"srealm")))
        {
            PWSTR pwszRealm = ::wcsstr(Token, L"=");
            if (pwszRealm == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cburl");
                goto next_token;
            }
            
            pwszRealm++; // skip "="

            while (*pwszRealm == (L" ")[0]) { ++pwszRealm; } // skip leading white spaces

            ::wcscpy( m_wRealm, pwszRealm);
		
            DoTraceMessage(PP_LOG_INFO, "sRealm URL %ws found", pwszCbUrl);
        }
        else if (!::_wcsnicmp(Token, L"cbtxt", ::wcslen(L"cbtxt")))
        {
            PWSTR pwszCbTxt = ::wcsstr(Token, L"=");
            if (pwszCbTxt == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::DownLoadCoBrandBitmap() : no = after cbtxt");
                goto next_token;
            }
            
            pwszCbTxt++; // skip "="

            while (*pwszCbTxt == (L" ")[0]) { ++pwszCbTxt; } // skip leading white spaces

            if (m_pwszCbtxt)
            {
                delete [] m_pwszCbtxt;
            }

            m_pwszCbtxt = new WCHAR[wcslen(pwszCbTxt)+1];
            if (m_pwszCbtxt)
            {
                ::wcscpy( m_pwszCbtxt, pwszCbTxt);

                DoTraceMessage(PP_LOG_INFO, "cbtxt %ws found", m_pwszCbtxt);
            }
        }


    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

    if (pwszCbUrl)
    {
        HINTERNET hCbUrl = m_pSession->OpenUrl(pwszCbUrl, NULL, 0, 0);
        if (hCbUrl == NULL)
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::DownLoadCoBrandBitmap() failed; can not open URL %ws",
                           pwszCbUrl);
            goto exit;
        }

        {
            LPSTREAM pStream;

            if (CreateStreamOnHGlobal(NULL, TRUE, &pStream) != S_OK)
            {
                DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            {
                DWORD cbRead = 0;
                PBYTE bBuf = new BYTE[1024];
                if (bBuf == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed; out of memory");
                    m_pSession->CloseHandle(hCbUrl);

                    goto exit;
                }

                DWORD cbBuf = 1024;
                
                while (m_pSession->ReadFile(hCbUrl, bBuf, cbBuf, &cbRead) && cbRead)
                    pStream->Write(bBuf, cbRead, NULL);

                delete [] bBuf;
            }

            LARGE_INTEGER Zero = {0};
            pStream->Seek(Zero, STREAM_SEEK_SET, NULL); // seek to the beginning of the stream

            DoTraceMessage(PP_LOG_INFO, "CoBrand Graphic %ws downloaded", pwszCbUrl);
            
            if (m_hBitmap)
            {
                DeleteObject(m_hBitmap);
                m_hBitmap = NULL;
            }

            if (Gif2Bmp(pStream, &m_hBitmap) == FALSE)
            {
                DoTraceMessage(PP_LOG_ERROR, "Gif2Bmp() failed");
                m_pSession->CloseHandle(hCbUrl);

                goto exit;
            }

            pStream->Release();
            m_pSession->CloseHandle(hCbUrl);

            fRet = TRUE;

            DoTraceMessage(PP_LOG_INFO, "CoBrand Bitmap created");
        }
    }

exit:
    if (pwszCbUrl)
    {
        delete [] pwszCbUrl;
    }

    return fRet;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle401FromDA(
    HINTERNET   hRequest, 
    BOOL        fTicketRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    PWSTR pwszRawHeaders = NULL;
    PSTR  pszRawHeaders = NULL;
    PWSTR  pwszChallenge = NULL;
    PWSTR  pwszChallengeEnd = NULL;
    DWORD ChallengeLength = 0;

    if(m_pSession->QueryHeaders(hRequest,
                                HTTP_QUERY_RAW_HEADERS_CRLF, 
                                0,
                                &ChallengeLength) == FALSE)
    {
        if ((::GetLastError() != ERROR_INSUFFICIENT_BUFFER) || (ChallengeLength == 0))
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; QueryHeaders() failed; Error Code = %d",
                           dwErrorCode);
            goto exit;
        }
    }
    else
    {
        PP_ASSERT(TRUE); // control should not reach here
    }

    pwszRawHeaders = new WCHAR[ChallengeLength];
    if (pwszRawHeaders == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; out of memory");
        goto exit;
    }

    if(m_pSession->QueryHeaders(hRequest,
                                HTTP_QUERY_RAW_HEADERS_CRLF, 
                                pwszRawHeaders,
                                &ChallengeLength) == FALSE)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; QueryHeaders() failed; Error Code = %d",
                       dwErrorCode);
        goto exit;
    }

    if ((pwszChallenge = ::wcsstr(pwszRawHeaders, L"Passport1.4")) == NULL)
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; Passport1.4 auth header not found");
        goto exit;
    }

    if (pwszChallengeEnd = ::wcsstr(pwszChallenge, L"\r\n"))
    {
        *pwszChallengeEnd = 0;
    }
    
    if (::wcsstr(pwszChallenge, L"noretry"))
    {
        dwRetVal = PP_LOGON_FAILED; // Login Request Failed; bad news!
        DoTraceMessage(PP_LOG_WARNING, "Handle401FromDA() : Logon failed");
    }
    else if (::wcsstr(pwszChallenge, L"retry"))
    {
        // biaow-todo: not yet implemented
        PP_ASSERT(TRUE); // shouldn't reach here
        dwRetVal = PP_LOGON_REQUIRED;
    }
    else if (::wcsstr(pwszChallenge, L"failed"))
    {
        // if (fTicketRequest)
        // {
        dwRetVal = PP_LOGON_REQUIRED;
        DoTraceMessage(PP_LOG_INFO, "Handle401FromDA() : Logon required by DA");
        // }
        // else
        // {
        //     dwRetVal = PP_LOGON_FAILED; // Login Request Failed; bad news!
        //     DoTraceMessage(PP_LOG_WARNING, "Handle401FromDA() : Logon failed");
        // }
    }
    else
    {
        DoTraceMessage(PP_LOG_ERROR, "Handle401FromDA() failed; no valid DA status");
        goto exit;
    }

    if (dwRetVal == PP_LOGON_REQUIRED || dwRetVal == PP_LOGON_FAILED)
    {
        if (::wcsstr(pwszChallenge, L"prompt"))
        {
            m_fPrompt = TRUE;
        }
        else
        {
            m_fPrompt = FALSE;
        }

        if (CreateStreamOnHGlobal(NULL, TRUE, &m_p401Content) != S_OK)
        {
            DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed");
            goto exit;
        }

        if (pwszChallengeEnd)
        {
            PP_ASSERT(*pwszChallengeEnd == 0);
            *pwszChallengeEnd = L'\r';
        }

        pszRawHeaders = new CHAR[2048];
        if (pszRawHeaders == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed, out of memory");
            goto exit;
        }

        ::WideCharToMultiByte(CP_ACP, 0, pwszRawHeaders, -1, pszRawHeaders, 2048, NULL, NULL);

        m_p401Content->Write(pszRawHeaders, strlen(pszRawHeaders), NULL);

        {
            DWORD cbRead = 0;
            PBYTE bBuf = new BYTE [1024];
            if (bBuf == NULL)
            {
                DoTraceMessage(PP_LOG_ERROR, "CreateStreamOnHGlobal() failed, out of memory");
                goto exit;
            }
            DWORD cbBuf = 1024;
            
            while (m_pSession->ReadFile(hRequest, bBuf, cbBuf, &cbRead) && cbRead)
                m_p401Content->Write(bBuf, cbRead, NULL);

            delete [] bBuf;
        }

        LARGE_INTEGER Zero = {0};
        m_p401Content->Seek(Zero, STREAM_SEEK_SET, NULL); // seek to the beginning of the stream
    
        if (pwszChallengeEnd)
        {
            *pwszChallengeEnd = 0;
        }


        DownLoadCoBrandBitmap(pwszChallenge);
    }

exit:

    if (pwszRawHeaders)
    {
        delete [] pwszRawHeaders;
    }

    if (pszRawHeaders)
    {
        delete [] pszRawHeaders;
    }
    
    return dwRetVal;
}

// -----------------------------------------------------------------------------
DWORD LOGON::Handle200FromDA(
    HINTERNET hRequest
    )
{
    PP_ASSERT(hRequest != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    
    PWSTR pwszBuffer = NULL;
    DWORD dwBuffer = 0;
    if((!m_pSession->QueryHeaders(hRequest,
                                  HTTP_QUERY_AUTHENTICATION_INFO, 
                                  pwszBuffer,
                                  &dwBuffer))
       && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        pwszBuffer = new WCHAR[dwBuffer];
        if (pwszBuffer == NULL)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
            goto exit;
        }

        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_AUTHENTICATION_INFO, 
                                      pwszBuffer,
                                      &dwBuffer))
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; no Authenticate-Info header found");
            goto exit;
        }

        WCHAR Delimiters[] = L",";
        PWSTR Token = ::wcstok(pwszBuffer, Delimiters);
        while (Token != NULL)
        {
            while (*Token == (L" ")[0]) { ++Token; }
            if (Token == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::Handle200FromDA() : no text in between commas");
                goto next_token;
            }

            if (!::_wcsnicmp(Token, L"ru", ::wcslen(L"ru")))
            {
                PWSTR ReturnUrl = ::wcsstr(Token, L"=");
                if (ReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() : no = after cburl");
                    goto exit;
                }
                ReturnUrl++; // skip =
                
                while (*ReturnUrl == (L" ")[0]) { ++ReturnUrl; }  // skip leading white spaces
                
                m_pwszReturnUrl = new WCHAR[::wcslen(ReturnUrl)+1];
                if (m_pwszReturnUrl == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszReturnUrl, ReturnUrl);
            }
            else if (!::_wcsnicmp(Token, L"from-pp", ::wcslen(L"from-pp")))
            {
                m_pwszAuthInfo = new WCHAR[::wcslen(Token)+1];
                if (m_pwszAuthInfo == NULL)
                {
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Handle200FromDA() failed; not enough memory");
                    goto exit;
                }

                ::wcscpy(m_pwszAuthInfo, Token);
            }

        next_token:

            Token = ::wcstok(NULL, Delimiters);
        }

        dwRetVal = PP_LOGON_SUCCESS;
        g_fCurrentProcessLoggedOn = TRUE;

    }
    else
    {
        PP_ASSERT(TRUE); // shouldn't reach here
        goto exit;
    }

exit:

    if (pwszBuffer)
    {
        delete [] pwszBuffer;
    }

    return dwRetVal;
}

void LOGON::CheckForVersionChange(
    HINTERNET hRequest
    )
{
    WCHAR wszBuffer[256];
    DWORD dwBufferLen = sizeof(wszBuffer) / sizeof(WCHAR);
    BOOL fDownloadNewNexusConfig = FALSE;
    
    if (!m_pSession->QueryHeaders(hRequest,
                                  HTTP_QUERY_PASSPORT_CONFIG, 
                                  wszBuffer,
                                  &dwBufferLen))
    {
        DoTraceMessage(PP_LOG_ERROR, "LOGON::CheckForVersionChange() failed; no PassportConfig header found");
        goto exit;
    }

    WCHAR Delimiters[] = L",";
    PWSTR Token = ::wcstok(wszBuffer, Delimiters);
    while (Token != NULL)
    {
        // skip leading white spaces
        while (*Token == (L" ")[0]) { ++Token; }
        if (Token == NULL)
        {
            DoTraceMessage(PP_LOG_WARNING, "LOGON::CheckForVersionChange() : no text in between commas");
            goto next_token;
        }

        if (!::_wcsnicmp(Token, L"ConfigVersion", ::wcslen(L"ConfigVersion")))
        {
            PWSTR pwszConfigVersion = ::wcsstr(Token, L"=");
            if (pwszConfigVersion == NULL)
            {
                DoTraceMessage(PP_LOG_WARNING, "LOGON::CheckForVersionChange() : no = after ConfigVersion");
                goto next_token;
            }
            
            pwszConfigVersion++; // skip "="

            while (*pwszConfigVersion == (L" ")[0]) { ++pwszConfigVersion; } // skip leading white spaces

            if ((DWORD)_wtoi(pwszConfigVersion) > m_pSession->GetNexusVersion())
            {
                fDownloadNewNexusConfig = TRUE;
            }
		
            DoTraceMessage(PP_LOG_INFO, "ConfigVersion URL %ws found", pwszConfigVersion);
        }

    next_token:

        Token = ::wcstok(NULL, Delimiters);
    }

    if (fDownloadNewNexusConfig)
    {
        m_pSession->GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                         NULL, 
                                         0, 
                                         NULL, 
                                         0);
    }

exit:
    return;
}


VOID PrvLogonStatusCallback(    
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength
)
{
    LOGON* pLogon = reinterpret_cast<LOGON*>(dwContext);

    pLogon->StatusCallback(hInternet,
                           dwInternetStatus,
                           lpvStatusInformation,
                           dwStatusInformationLength);


}

VOID LOGON::StatusCallback(
    IN HINTERNET hInternet,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation,
    IN DWORD dwStatusInformationLength)
{
    if (dwInternetStatus == INTERNET_STATUS_REDIRECT)
    {
        ::wcscpy(m_wNewDAUrl, (LPCWSTR)lpvStatusInformation);
        BOOL fRet = m_pSession->AddHeaders(hInternet, 
                               m_pwszAuthHeader, 
                               ::wcslen(m_pwszAuthHeader),
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE
                               );

        PP_ASSERT(fRet == TRUE);
    }
    else if ((dwInternetStatus == INTERNET_STATUS_COOKIE_SENT) || 
             (dwInternetStatus == INTERNET_STATUS_COOKIE_RECEIVED))
    {
        PVOID lpvInfo = new BYTE [dwStatusInformationLength];
        if (lpvInfo == 0)
        {
            return;
        }
        memcpy(lpvInfo, lpvStatusInformation, dwStatusInformationLength); 
        
        LPCWSTR pwszLocation = m_wNewDAUrl[0] ? m_wNewDAUrl : m_pSession->GetCurrentDAUrl();
        LPSTR   pszLocation = NULL;
        DWORD dwLocationLen = 0;
        if (dwLocationLen = wcslen(pwszLocation))
        {
            pszLocation = new CHAR[dwLocationLen + 1];
            if (pszLocation == 0)
            {
                return;
            }
            ::WideCharToMultiByte(CP_ACP, 0, pwszLocation, -1, pszLocation, dwLocationLen + 1, NULL, NULL);

            if (dwInternetStatus == INTERNET_STATUS_COOKIE_SENT)
            {
                ((OutgoingCookieState*)lpvInfo)->pszLocation = pszLocation;
            }
            else
            {
                ((IncomingCookieState*)lpvInfo)->pszLocation = pszLocation;
            }
        }

        PRIVACY_EVENT* pEvent = new PRIVACY_EVENT;
        if (pEvent != NULL)
        {
            pEvent->dwStatus = dwInternetStatus;
            pEvent->lpvInfo = lpvInfo;
            pEvent->dwInfoLength = dwStatusInformationLength;

            InsertTailList(&m_PrivacyEventList, &(pEvent->List));
        }
    }
}

BOOL LOGON::GetLogonHost(
    PWSTR       pwszHostName,
    OUT PDWORD  pdwHostNameLen
    ) const
{
    if (*pdwHostNameLen < DWORD(::wcslen(m_wDAHostName) + 1))
    {
        *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszHostName != NULL);

    ::wcscpy(pwszHostName, m_wDAHostName);

    *pdwHostNameLen = ::wcslen(m_wDAHostName) + 1;

    return TRUE;
}

BOOL PPEscapeUrl(LPCSTR lpszStringIn,
                 LPSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags);

// -----------------------------------------------------------------------------
DWORD LOGON::Logon(
    BOOL fAnonymous
    )
{
    PP_ASSERT(m_pSession != NULL);

    DWORD dwRetVal = PP_GENERIC_ERROR;
    BOOL fTicketRequest;
    HINTERNET hRequest = 0;
    DWORD dwFlags = 0;

    ::wcscpy(m_pwszAuthHeader, L"Authorization: Passport1.4 ");

    LPWSTR pwszPassword = m_Password.GetUnencryptedString();

    if (m_fCredsPresent && !fAnonymous)
    {
        if (m_pSession->GetNexusVersion() >= 10)
        {
            DWORD dwUTF8CredLen = max(::wcslen(m_pwszSignIn), ::wcslen(pwszPassword)) * 3;
            DWORD dwEscCredLen  = dwUTF8CredLen * 3;
            DWORD dwActualEscCredLen;

            PSTR pszUTF8Cred = new CHAR[dwUTF8CredLen];
            if (pszUTF8Cred == NULL)
            {
                goto exit;
            }
            PSTR pszEscCred  = new CHAR[dwEscCredLen];
            if (pszEscCred == NULL)
            {
                delete [] pszUTF8Cred;
                goto exit;
            }
            PWSTR pwszEscCred = new WCHAR[dwEscCredLen];
            if (pwszEscCred == NULL)
            {
                delete [] pszEscCred;
                delete [] pszUTF8Cred;
                goto exit;
            }

            ::WideCharToMultiByte(CP_UTF8, 0, m_pwszSignIn, -1, pszUTF8Cred, dwUTF8CredLen, NULL, NULL);
            ::PPEscapeUrl(pszUTF8Cred, pszEscCred, &dwActualEscCredLen, dwEscCredLen, 0);
            int cchEscCred = ::MultiByteToWideChar(CP_ACP, 0, pszEscCred, -1, pwszEscCred, dwEscCredLen);

            if ((cchEscCred - 1) > 1024)
            {
                pwszEscCred[1024] = L'\0';
            }

            ::wcscat(m_pwszAuthHeader, L"sign-in=");
            ::wcscat(m_pwszAuthHeader, pwszEscCred);
            ::wcscat(m_pwszAuthHeader, L",");

            ::WideCharToMultiByte(CP_UTF8, 0, pwszPassword, -1, pszUTF8Cred, dwUTF8CredLen, NULL, NULL);
            ::PPEscapeUrl(pszUTF8Cred, pszEscCred, &dwActualEscCredLen, dwEscCredLen, 0);
            cchEscCred = ::MultiByteToWideChar(CP_ACP, 0, pszEscCred, -1, pwszEscCred, dwEscCredLen); 

            if ((cchEscCred - 1) > 1024)
            {
                pwszEscCred[1024] = L'\0';
            }

            ::wcscat(m_pwszAuthHeader, L"pwd=");
            ::wcscat(m_pwszAuthHeader, pwszEscCred);
            ::wcscat(m_pwszAuthHeader, L",");

            delete [] pwszEscCred;
            delete [] pszEscCred;
            delete [] pszUTF8Cred;
        }
        else
        {
            if (::wcslen(m_pwszSignIn) > 1024)
            {
                m_pwszSignIn[1024] = L'\0';
            }

            ::wcscat(m_pwszAuthHeader, L"sign-in=");
            ::wcscat(m_pwszAuthHeader, m_pwszSignIn);
            ::wcscat(m_pwszAuthHeader, L",");

            if (::wcslen(pwszPassword) > 1024)
            {
                pwszPassword[1024] = L'\0';
            }
        
            ::wcscat(m_pwszAuthHeader, L"pwd=");
            ::wcscat(m_pwszAuthHeader, pwszPassword);
            ::wcscat(m_pwszAuthHeader, L",");
        }

        FILETIME ftCredsEntered;
        ::SystemTimeToFileTime(&m_TimeCredsEntered, &ftCredsEntered);

        SYSTEMTIME stCurrent;
        ::GetSystemTime(&stCurrent);
        FILETIME ftCurrent;
        ::SystemTimeToFileTime(&stCurrent, &ftCurrent);
        
        LONGLONG llElapsedTime;
        llElapsedTime = (*(LONGLONG *)&ftCurrent) - (*(LONGLONG *)&ftCredsEntered);
        llElapsedTime /= (LONGLONG)10000000;
        DWORD dwElapsedTime = (DWORD)llElapsedTime;
        WCHAR wElapsedTime[16];
        ::wsprintfW(wElapsedTime, L"%d", dwElapsedTime);

        ::wcscat(m_pwszAuthHeader, L"elapsed-time=");
        ::wcscat(m_pwszAuthHeader, wElapsedTime);
        ::wcscat(m_pwszAuthHeader, L",");
        
        if (m_wTimeSkew[0])
        {
            ::wcscat(m_pwszAuthHeader, m_wTimeSkew);
            ::wcscat(m_pwszAuthHeader, L",");
        }

        fTicketRequest = FALSE; // this is a login request, since we've gather credentials

        // save off the sign-in name
        if ( ::wcslen ( m_pwszSignIn ) < INTERNET_MAX_USER_NAME_LENGTH )  
            ::wcscpy ( g_szUserNameLoggedOn, m_pwszSignIn );

    }
    else
    {
        ::wcscat(m_pwszAuthHeader, L"tname = , ");
        
        fTicketRequest = TRUE;
    }
    
    ::wcscat(m_pwszAuthHeader, m_pwszTicketRequest);

    if (pwszPassword != NULL)
    {
        SecureZeroMemory(pwszPassword, ::wcslen(pwszPassword) * sizeof(WCHAR));
        delete [] pwszPassword;
        pwszPassword = NULL;
    }

retry:

    // attempt connecting to the Passport DA

    if (m_hConnect)
    {
        m_pSession->CloseHandle(m_hConnect);
    }

    WCHAR       wDATargetObj[256];
    
    DWORD fStstus = m_pSession->GetDAInfo(m_pwszSignIn,
                                          m_wDAHostName, 256,
                                          wDATargetObj, 256);

    if (fStstus == FALSE)
    {
        goto exit;
    }
    
    m_hConnect = m_pSession->Connect(m_wDAHostName/*m_pSession->GetLoginHost()*/,
#ifdef DISABLE_SSL
                    INTERNET_DEFAULT_HTTP_PORT
#else
                    INTERNET_DEFAULT_HTTPS_PORT
#endif
                                     );
    if (m_hConnect == NULL)
    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Open() failed; can not connect to %ws, Error = %d",
                       m_wDAHostName, dwErrorCode);
        goto exit;
    }
    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }

    dwFlags = m_dwParentFlags;

    hRequest = m_pSession->OpenRequest(m_hConnect,
                                       NULL, // "GET"
                                       wDATargetObj/*m_pSession->GetLoginTarget()*/,
#ifdef DISABLE_SSL
                                       dwFlags | INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS,
#else                                                 
                                                 dwFlags | INTERNET_FLAG_SECURE,
#endif
                                       (DWORD_PTR)this
                                       );
    if (hRequest == NULL)

    {
        DWORD dwErrorCode = ::GetLastError();
        DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; OpenRequest() to %ws failed, Error Code = %d",
                       wDATargetObj, dwErrorCode);
        goto exit;
    }
    
    m_wNewDAUrl[0] = 0;
    m_pSession->SetStatusCallback(hRequest, PrvLogonStatusCallback);
    
    if (!m_pSession->SendRequest(hRequest, 
                                 m_pwszAuthHeader, 
                                 ::wcslen(m_pwszAuthHeader),
                                 (DWORD_PTR)this))
    {
        DWORD dwErrorCode = ::GetLastError();

#ifdef BAD_CERT_OK
        if (dwErrorCode == ERROR_INTERNET_INVALID_CA)
        {
            DWORD dwSecFlags;
            DWORD dwSecurityFlagsSize = sizeof(dwSecFlags);

            if (!m_pSession->QueryOption(hRequest, 
                                    INTERNET_OPTION_SECURITY_FLAGS,
                                    &dwSecFlags,
                                    &dwSecurityFlagsSize))
            {
                dwSecFlags = 0;
            }
            else
            {
                dwSecFlags |= SECURITY_SET_MASK;
            }

            if (!m_pSession->SetOption(hRequest, 
                                      INTERNET_OPTION_SECURITY_FLAGS, 
                                      &dwSecFlags, 
                                      dwSecurityFlagsSize))
            {
                PP_ASSERT(TRUE); // shouldn't reach here
                goto exit;
            }
            else
            {
                if (!m_pSession->SendRequest(hRequest, NULL, 0))
                {
                    dwErrorCode = ::GetLastError();
                    DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                                   dwErrorCode);
                    goto exit;
                }
                else
                {
                    dwErrorCode = ERROR_SUCCESS;
                }
            }
        }
#endif // BAD_CERT_OK
        
        if (dwErrorCode != ERROR_SUCCESS)
        {
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; SendRequest() failed, Error Code = %d",
                           dwErrorCode);

            m_pSession->PurgeDAInfo(m_pwszSignIn);

            if (m_pSession->GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                                 NULL, 
                                                 0, 
                                                 NULL, 
                                                 0) == TRUE)
            {
                goto retry;
            }

            goto exit;
        }
    }

    {
        DWORD dwStatus, dwStatusLen;
        dwStatusLen = sizeof(dwStatus);
        if (!m_pSession->QueryHeaders(hRequest,
                                      HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, 
                                      &dwStatus,
                                      &dwStatusLen))
        {
            DWORD dwErrorCode = ::GetLastError();
            DoTraceMessage(PP_LOG_ERROR, "LOGON::Logon() failed; can not retrieve Status Code, Error Code = %d",
                           dwErrorCode);
            goto exit;
        }
    
        if (dwStatus == HTTP_STATUS_DENIED)
        {
            dwRetVal = Handle401FromDA(hRequest, fTicketRequest);
        }
        else if (dwStatus == HTTP_STATUS_OK)
        {
            dwRetVal = Handle200FromDA(hRequest);
        }
        else
        {
            //PP_ASSERT(TRUE); // shouldn't reach here
            //goto exit;
        }

        CheckForVersionChange(hRequest);

        if (dwRetVal == PP_GENERIC_ERROR)
        {
            m_pSession->PurgeDAInfo(m_pwszSignIn);
            
            if (m_pSession->GetDAInfoFromPPNexus(FALSE, // don't force connection establishment if nexus not reachable
                                                 NULL, 
                                                 0, 
                                                 NULL, 
                                                 0) == TRUE)
            {
                goto retry;
            }
        }
        else
        {
            if (m_wNewDAUrl[0])
            {
                m_pSession->UpdateDAInfo(m_pwszSignIn,
                                         m_wNewDAUrl);
                m_wNewDAUrl[0] = 0;
            }
        }
    }

exit:

    if (hRequest)
    {
        m_pSession->CloseHandle(hRequest);
    }

    if (pwszPassword)
    {
        SecureZeroMemory(pwszPassword, ::wcslen(pwszPassword) * sizeof(WCHAR));
        delete [] pwszPassword;
    }

    return dwRetVal;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetChallengeInfo(
	HBITMAP*		 phBitmap,
	PBOOL			 pfPrompt,
	PWSTR			 pwszCbText,
    PDWORD           pdwTextLen,
    PWSTR            pwszRealm,
    DWORD            dwMaxRealmLen,
    PWSTR            pwszReqUserName,
    PDWORD           pdwReqUserNameLen

    ) const
{
    if (phBitmap)
    {
        *phBitmap = m_hBitmap;
    }
    if (pfPrompt)
    {
        *pfPrompt = m_fPrompt;
    }

	// *pdwTextLen = 0; // biaow-todo:
    
    if (pwszRealm)
    {
        ::wcsncpy(pwszRealm, m_wRealm, dwMaxRealmLen-1);
    }

    if (m_pwszCbtxt == NULL)
    {
        if (pdwTextLen)
        {
            // tell them how much is needed
            *pdwTextLen = 0;
        }

        goto CheckReqUserName;
    }

    if (pwszCbText && pdwTextLen )
    {
        // only copy if they gave us enough bytes.
        if ( *pdwTextLen >= ::wcslen(m_pwszCbtxt) ) 
            ::wcsncpy(pwszCbText, m_pwszCbtxt, *pdwTextLen);
    }

    if (pdwTextLen)
    {
        // tell them how much is needed
        *pdwTextLen = ::wcslen(m_pwszCbtxt);
	}


CheckReqUserName:

    // username
    if (pdwReqUserNameLen)
    {
        if (m_fPrompt && g_fCurrentProcessLoggedOn)
        {
            if ( *pdwReqUserNameLen >= ::wcslen (g_szUserNameLoggedOn) )
            {
                if ( pwszReqUserName != NULL )
                {
                    wcsncpy ( pwszReqUserName, g_szUserNameLoggedOn, *pdwReqUserNameLen );
                }

            }

            // tell them how much is needed
            *pdwReqUserNameLen = ::wcslen (g_szUserNameLoggedOn) + 1;
        }
        else
        {
            // nothing is needed
            *pdwReqUserNameLen = 0;
        }

    }
    
    return TRUE;
}

BOOL LOGON::GetChallengeContent(
    PBYTE    	     pContent,
    OUT PDWORD       pdwContentLen
    ) const
{
    if (m_p401Content == NULL)
    {
        *pdwContentLen = 0;
        return FALSE;
    }

    HGLOBAL hContent;
    if (GetHGlobalFromStream(m_p401Content, &hContent) != S_OK)
    {
        *pdwContentLen = 0;
        return FALSE;
    }

    DWORD dwContentLen = (DWORD)GlobalSize(hContent);
    if (*pdwContentLen < dwContentLen)
    {
        *pdwContentLen = dwContentLen;
        return FALSE;
    }

    LPVOID pvContent = GlobalLock(hContent);
    memcpy(pContent, pvContent, dwContentLen);
    GlobalUnlock(hContent);

    *pdwContentLen = dwContentLen;
    
    return TRUE;
}

// -----------------------------------------------------------------------------
BOOL LOGON::GetAuthorizationInfo(
    PWSTR   pwszTicket,
    PDWORD  pdwTicketLen,
    PBOOL   pfKeepVerb,
    PWSTR   pwszUrl,
    PDWORD  pdwUrlLen 
    ) const
{
    if (*pdwTicketLen < DWORD(::wcslen(m_pwszAuthInfo) + 1))
    {
        *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszTicket != NULL);

    ::wcscpy(pwszTicket, m_pwszAuthInfo);
    *pdwTicketLen = ::wcslen(m_pwszAuthInfo) + 1;
    
    if (m_pwszReturnUrl == NULL)
    {
        if (pfKeepVerb)
        {
            *pfKeepVerb = TRUE;
        }
        *pdwUrlLen = 0;
        return TRUE;
    }

    if (*pdwUrlLen < DWORD(::wcslen(m_pwszReturnUrl) + 1))
    {
        *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;
        return FALSE;
    }

    PP_ASSERT(pwszUrl != NULL);

    ::wcscpy(pwszUrl, m_pwszReturnUrl);

    if (pfKeepVerb)
    {
        *pfKeepVerb = FALSE;
    }

    *pdwUrlLen = ::wcslen(m_pwszReturnUrl) + 1;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\ppdefs.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ppdefs.h

Abstract:

    Basic Passport definitions.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef PP_DEFS_H
#define PP_DEFS_H

#include <Windows.h>

#define HINTERNET PVOID
#define INTERNET_PORT WORD

#define PP_LOG_INFO	 /*Noise*/ 0x00000001
#define PP_LOG_WARNING	/*Unusual*/ 0x00000002
#define PP_LOG_ERROR	 /*Error*/ 0x00000004

#ifdef DBG
#define PP_ASSERT(fVal) if (!fVal) DebugBreak();
#else
#define PP_ASSERT(fVal)
#endif

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

 #define WPP_CONTROL_GUIDS \
     WPP_DEFINE_CONTROL_GUID(Regular,(81b20fea,73a8,4b62,95bc,354477c97a6f), \
         WPP_DEFINE_BIT(Error)      \
         WPP_DEFINE_BIT(Unusual)    \
         WPP_DEFINE_BIT(Noise)      \
    ) 
    
//
// func pointer decl for CredUI
//

//#include <credui.h>
#include <wincred.h>

typedef BOOL
(WINAPI * PFN_READ_DOMAIN_CRED_W) (
	IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
	IN DWORD Flags,
	OUT DWORD *Count,
	OUT PCREDENTIALW **Credential
	);

typedef VOID
(WINAPI * PFN_CRED_FREE)(
    IN PVOID Buffer
    );

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#define DoTraceMessage

#endif // PP_DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\inetcorepch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\advpack.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <advpub.h>

static
HRESULT
WINAPI
RunSetupCommand(
    HWND hWnd,
    LPCSTR szCmdName,
    LPCSTR szInfSection,
    LPCSTR szDir,
    LPCSTR lpszTitle,
    HANDLE *phEXE,
    DWORD dwFlags,
    LPVOID pvReserved
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
HRESULT 
WINAPI
RegInstall(
    HMODULE hm, 
    LPCSTR pszSection, 
    LPCSTRTABLE pstTable)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
BOOL
WINAPI
IsNTAdmin(
    DWORD dwReserved,
    DWORD *lpdwReserved
    )
{
    // default to being more secure
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(advpack)
{
    DLPENTRY(IsNTAdmin)
    DLPENTRY(RegInstall)
    DLPENTRY(RunSetupCommand)
};

DEFINE_PROCNAME_MAP(advpack)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\xstring.h ===
/*++

Copyright (c) 2003  Microsoft Corporation

Module Name:

    xstring.h

Abstract:


Author:

    Stephen A Sulzer (ssulzer) 16-Jan-2003

--*/

//
// class implementation of CSecureStr
//

class CSecureStr
{
    LPWSTR _lpsz;
    int    _stringLength;
    BOOL   _fEncryptString;

public:

    CSecureStr()
    {
        _lpsz = NULL;
        _stringLength = 0;
        _fEncryptString = TRUE;
    }

    ~CSecureStr()
    {
        Free();
    }

    void Free (void)
    {
        if (_lpsz)
        {
            SecureZeroMemory(_lpsz, _stringLength * sizeof(WCHAR));
            delete [] _lpsz;
        }
        _lpsz = NULL;
        _stringLength = 0;
    }

    LPWSTR GetPtr(void)
    {
        return _lpsz;
    }

    DWORD GetStrLen() const
    {
        return _stringLength;
    }

    LPWSTR GetUnencryptedString();  // always allocates memory regardless of _fEncryptString

    BOOL SetData(LPCWSTR lpszIn);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\imgutil.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <ddraw.h>
#include <imgutil.h>

static
HRESULT
WINAPI
DecodeImage(
    IStream* pStream,
    IMapMIMEToCLSID* pMap,
    IUnknown* pEventSink
    )
{
    return E_FAIL;
}

static
HRESULT
WINAPI
CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface)
{
    return E_FAIL;
}

static
HRESULT
WINAPI
IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes, UINT* pnFormat )
{
    return E_FAIL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(imgutil)
{
    DLPENTRY(CreateDDrawSurfaceOnDIB)
    DLPENTRY(DecodeImage)
    DLPENTRY(IdentifyMIMEType)
};

DEFINE_PROCNAME_MAP(imgutil)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\session.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    session.h

Abstract:

    This interface abstracts a Passport Session.

Author:

    Biao Wang (biaow) 01-Oct-2000

--*/

#ifndef SESSION_H
#define SESSION_H

class SESSION
{
public:
    static
    BOOL CreateObject(PCWSTR pwszHttpStack,  HINTERNET hSession, SESSION*& pSess);

public:
    SESSION(void);
    virtual ~SESSION(void);

    UINT GetSessionId(void) const { return m_SessionId; }
    BOOL Match(UINT SessionId) const { return SessionId == m_SessionId; }

    void AddRef(void) { ++m_RefCount; }
    
    void RemoveRef(void) 
    {
        if (m_RefCount > 0)
        {
            --m_RefCount;
        }
    }

    UINT RefCount(void) const { return m_RefCount; }

    // methods to retrieve the registry-configured value

    // PCWSTR GetLoginHost(void) const { return m_wDAHostName; }
    // PCWSTR GetLoginTarget(void) const { return m_wDATargetObj; }
    PCWSTR GetRegistrationUrl(void) const { return m_wRegistrationUrl; }
    
    BOOL GetDAInfoFromPPNexus(
        IN BOOL             fForce,
        IN PWSTR            pwszRegUrl,    // user supplied buffer ...
        IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                        // on successful return)
        IN PWSTR            pwszDARealm,    // user supplied buffer ...
        IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        );

    BOOL GetDAInfo(PCWSTR pwszSignIn,
                   LPWSTR pwszDAHostName,
                   DWORD HostNameLen,
                   LPWSTR pwszDAHostObj,
                   DWORD HostObjLen);

    BOOL UpdateDAInfo(
        PCWSTR pwszSignIn,
        PCWSTR pwszDAUrl
        );

    BOOL PurgeDAInfo(PCWSTR pwszSignIn);

    DWORD GetNexusVersion(void);

    BOOL GetCachedCreds(
        PCWSTR	pwszRealm,
        PCWSTR  pwszTarget,
        PCREDENTIALW** pppCreds,
        DWORD* pdwCreds
        );

    BOOL GetRealm(
        PWSTR      pwszDARealm,    // user supplied buffer ...
        PDWORD     pdwDARealmLen  // ... and length (will be updated to actual length 
                                        // on successful return)
        ) const;

    virtual BOOL Open(PCWSTR pwszHttpStack, HINTERNET) = 0;
    virtual void Close(void) = 0;

    // methods below abstracts a subset of WinInet/WinHttp functionalities.

    virtual HINTERNET Connect(
        LPCWSTR lpwszServerName,
        INTERNET_PORT) = 0;

    virtual HINTERNET OpenRequest(
        HINTERNET hConnect,
        LPCWSTR lpwszVerb,
        LPCWSTR lpwszObjectName,
        DWORD dwFlags,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL SendRequest(
        HINTERNET hRequest,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD_PTR dwContext = 0) = 0;

    virtual BOOL QueryHeaders(
        HINTERNET hRequest,
        DWORD dwInfoLevel,
        LPVOID lpvBuffer,
        LPDWORD lpdwBufferLength,
        LPDWORD lpdwIndex = NULL) = 0;

    virtual BOOL CloseHandle(
        IN HINTERNET hInternet) = 0;

    virtual BOOL QueryOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        LPDWORD lpdwBufferLength) = 0;    
    
    virtual BOOL SetOption(
        HINTERNET hInternet,
        DWORD dwOption,
        LPVOID lpBuffer,
        DWORD dwBufferLength) = 0;

    virtual HINTERNET OpenUrl(
        LPCWSTR lpwszUrl,
        LPCWSTR lpwszHeaders,
        DWORD dwHeadersLength,
        DWORD dwFlags) = 0;

    virtual BOOL ReadFile(
        HINTERNET hFile,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead) = 0;

    virtual BOOL CrackUrl(
        LPCWSTR lpszUrl,
        DWORD dwUrlLength,
        DWORD dwFlags,
        PVOID/*LPURL_COMPONENTSW*/ lpUrlComponents) = 0;

    virtual PVOID SetStatusCallback(
        HINTERNET hInternet,
        PVOID lpfnCallback
        ) = 0;

    virtual BOOL AddHeaders(
        HINTERNET hConnect,
        LPCWSTR lpszHeaders,
        DWORD dwHeadersLength,
        DWORD dwModifiers
        ) = 0;

    virtual BOOL IsHostBypassProxy(
        INTERNET_SCHEME tScheme, 
        LPCSTR pszHost, 
        DWORD cchHost) = 0;


#ifdef PP_DEMO
    virtual BOOL ContactPartner(PCWSTR pwszPartnerUrl,
                                PCWSTR pwszVerb,
                                PCWSTR pwszHeaders,
                                PWSTR  pwszData,
                                PDWORD pdwDataLength
                                ) = 0;
#endif // PP_DEMO

    LPCWSTR GetCurrentDAUrl(void) const { return m_wCurrentDAUrl; }

protected:
    static UINT m_SessionIdSeed;

    HMODULE     m_hHttpStack;
    HMODULE     m_hCredUI;
    UINT        m_SessionId;
    BOOL        m_fOwnedSession;
    UINT        m_RefCount;

    // WCHAR       m_wDAHostName[256];
    // WCHAR       m_wDATargetObj[64];
    WCHAR       m_wRegistrationUrl[256];
    
    PFN_READ_DOMAIN_CRED_W
                m_pfnReadDomainCred;
    PFN_CRED_FREE m_pfnCredFree;

    HKEY m_hKeyLM;
    HKEY m_hKeyCU;
    HKEY m_hKeyDAMap;
    WCHAR m_wDefaultDAUrl[1024];
    WCHAR m_wCurrentDAUrl[1024];

    DWORD m_LastNexusDownloadTime;

    friend class LOGON;
};

#endif // SESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\inetcomm.c ===
#include "inetcorepch.h"
#pragma hdrstop

#define _MIMEOLE_
#include <mimeole.h>

#undef MIMEOLEAPI
#define MIMEOLEAPI       HRESULT STDAPICALLTYPE


static
MIMEOLEAPI
MimeOleCreateVirtualStream(
    IStream **ppStream
    )
{
    if (ppStream)
    {
        *ppStream = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
MIMEOLEAPI
MimeOleCreateMessage(
    IUnknown *pUnkOuter,
    IMimeMessage **ppMessage
    )
{
    if (ppMessage)
    {
        *ppMessage = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
MIMEOLEAPI
MimeOleSetCompatMode(
    DWORD dwMode
    )
{
    return S_OK;
}

static
MIMEOLEAPI
MimeOleParseMhtmlUrl(
    LPSTR pszUrl,
    LPSTR *ppszRootUrl,
    LPSTR *ppszBodyUrl
    )
{
    if (pszUrl)
    {
        if (ppszRootUrl)
        {
            *ppszRootUrl = NULL;
        }

        if (ppszBodyUrl)
        {
            *ppszBodyUrl = NULL;
        }
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}        


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(inetcomm)
{
    DLPENTRY(MimeOleCreateMessage)
    DLPENTRY(MimeOleCreateVirtualStream)
    DLPENTRY(MimeOleParseMhtmlUrl)
    DLPENTRY(MimeOleSetCompatMode)
};

DEFINE_PROCNAME_MAP(inetcomm)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\passport\xstring.cpp ===
/*++

Copyright (c) 2003  Microsoft Corporation

Module Name:

    xstring.h

Abstract:


Author:

    Stephen A Sulzer (ssulzer) 16-Jan-2003

--*/

//
// class implementation of CSecureStr
//


#include "PPdefs.h"
#include "passport.h"
typedef int INTERNET_SCHEME;
#include "session.h"
#include "ole2.h"
#include "logon.h"
#include "wincrypt.h"

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#define RTL_ENCRYPT_MEMORY_SIZE     8

typedef NTSTATUS (WINAPI * ENCRYPTIONFUNCTION)(PVOID, ULONG, ULONG);


NTSTATUS
(WINAPI * _I_EncryptMemory)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

NTSTATUS
(WINAPI * _I_DecryptMemory)(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

HMODULE hAdvApi32Dll;

//
// methods
//


BOOL LoadEncryptionFunctions()
{
    if (NULL == hAdvApi32Dll)
    {
        hAdvApi32Dll = LoadLibrary("ADVAPI32.DLL");

        if (hAdvApi32Dll)
        {
            _I_EncryptMemory = (ENCRYPTIONFUNCTION) GetProcAddress(hAdvApi32Dll, "SystemFunction040");
            _I_DecryptMemory = (ENCRYPTIONFUNCTION) GetProcAddress(hAdvApi32Dll, "SystemFunction041");
        }
    }

    return (_I_EncryptMemory != NULL && _I_DecryptMemory != NULL);
}


LPWSTR CSecureStr::GetUnencryptedString()
{
    if (NULL == _lpsz)
        return NULL;

    LPWSTR lpszUnencryptedString = new WCHAR[_stringLength];
    
    if (lpszUnencryptedString != NULL)
    {
        memcpy(lpszUnencryptedString, _lpsz, _stringLength * sizeof(WCHAR));

        if (_fEncryptString)
        {
            _I_DecryptMemory(lpszUnencryptedString, _stringLength * sizeof(WCHAR), 0);
        }
    }

    return lpszUnencryptedString;
}


BOOL CSecureStr::SetData(LPCWSTR lpszIn)
{
    PP_ASSERT(lpszIn != NULL);

    DWORD  dwStrLen = (wcslen(lpszIn) + 1) * sizeof(WCHAR);

    if (_fEncryptString && LoadEncryptionFunctions())
    {
        DWORD  dwLen = 0;
        LPWSTR lpszTemp;

        dwLen = dwStrLen + (RTL_ENCRYPT_MEMORY_SIZE - dwStrLen % RTL_ENCRYPT_MEMORY_SIZE);

        lpszTemp = (LPWSTR) new CHAR[dwLen];  // dwLen is bytes not wide chars

        if (!lpszTemp)
            return FALSE;

        ZeroMemory(lpszTemp, dwLen);

        memcpy(lpszTemp, lpszIn, dwStrLen);

        NTSTATUS status = _I_EncryptMemory(lpszTemp, dwLen, 0);
        
        if (! NT_SUCCESS(status))
        {
            _fEncryptString = FALSE;
            memcpy(lpszTemp, lpszIn, dwStrLen);
            dwLen = dwStrLen;
        }

        Free();  // release current buffer if it exists

        _lpsz         = lpszTemp;
        PP_ASSERT((dwLen % 2) == 0);
        _stringLength = dwLen / sizeof(WCHAR);
        return TRUE;
    }
    else
    {
        // Make a copy of the data passed in.

        LPWSTR lpszTemp = new WCHAR[wcslen(lpszIn) + 1];
        if (!lpszTemp)
            return FALSE;

        Free();  // release current buffer if it exists

        memcpy(lpszTemp, lpszIn, dwStrLen);

        _lpsz           = lpszTemp;
        _stringLength   = wcslen(lpszIn) + 1;
        _fEncryptString = FALSE;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\mshtml.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <mshtmhst.h>

#undef STDAPI
#define STDAPI  HRESULT WINAPI


static
STDAPI
ShowHTMLDialog(                   
    HWND        hwndParent,              
    IMoniker *  pMk,                     
    VARIANT *   pvarArgIn,               
    WCHAR *     pchOptions,              
    VARIANT *   pvarArgOut               
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ShowHTMLDialogEx(
    HWND        hwndParent,
    IMoniker *  pMk,
    DWORD       dwDialogFlags,
    VARIANT *   pvarArgIn,
    WCHAR *     pchOptions,
    VARIANT *   pvarArgOut
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ShowModelessHTMLDialog(
    HWND        hwndParent,
    IMoniker *  pMk,
    VARIANT *   pvarArgIn,
    VARIANT *   pvarOptions,
    IHTMLWindow2 ** ppWindow)
{
    if (ppWindow)
    {
        *ppWindow = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mshtml)
{
    DLPENTRY(ShowHTMLDialog)
    DLPENTRY(ShowHTMLDialogEx)
    DLPENTRY(ShowModelessHTMLDialog)
};

DEFINE_PROCNAME_MAP(mshtml)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\urlmon.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <urlmon.h>

#undef STDAPI
#define STDAPI          HRESULT STDAPICALLTYPE
#undef STDAPI_
#define STDAPI_(type)   type    STDAPICALLTYPE

static
STDAPI CoInternetGetSession(DWORD dwSessionMode,
                                    IInternetSession **ppIInternetSession,
                                    DWORD dwReserved)
{
    *ppIInternetSession = NULL;
    return E_OUTOFMEMORY;
}

static
STDAPI RevokeBindStatusCallback(LPBC pBC,
                                        IBindStatusCallback *pBSCb)
{
    return E_FAIL;
}

static
STDAPI CreateURLMoniker(LPMONIKER pMkCtx,
                                LPCWSTR szURL,
                                LPMONIKER FAR * ppmk)
{
    *ppmk = NULL;
    return E_OUTOFMEMORY;
}

static
STDAPI HlinkNavigateString(IUnknown *pUnk,
                                   LPCWSTR szTarget)
{
    return E_FAIL;
}

static
STDAPI HlinkSimpleNavigateToString (
    LPCWSTR  szTarget,    
    LPCWSTR  szLocation,  
    LPCWSTR  szTargetFrame,
    IUnknown *pUnk,        
    IBindCtx *pBndctx,     
    IBindStatusCallback * pBscb,
    DWORD    grfHLNF,    
    DWORD    dwReserved  
    )
{
    return E_FAIL;
}

static
STDAPI RegisterBindStatusCallback(LPBC pBC,
                                          IBindStatusCallback *pBSCb,
                                          IBindStatusCallback** ppBSCBPrev,
                                          DWORD dwReserved)
{
    return E_OUTOFMEMORY;
}

static
HRESULT WINAPI
UrlMkGetSessionOption(DWORD dwOption,
                      LPVOID pBuffer,
                      DWORD dwBufferLength,
                      DWORD *pdwBufferLength,
                      DWORD dwReserved)
{
    return E_FAIL;
}

STDAPI
UrlMkSetSessionOption(DWORD dwOption,
                      LPVOID pBuffer,
                      DWORD dwBufferLength,
                      DWORD dwReserved)
{
    return E_FAIL;
}

static
STDAPI
CoInternetQueryInfo(LPCWSTR     pwzUrl,
                    QUERYOPTION QueryOptions,
                    DWORD       dwQueryFlags,
                    LPVOID      pvBuffer,
                    DWORD       cbBuffer,
                    DWORD      *pcbBuffer,
                    DWORD       dwReserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI
CreateFormatEnumerator(UINT cfmtetc,
                       FORMATETC* rgfmtetc,
                       IEnumFORMATETC** ppenumfmtetc)
{
    return E_FAIL;
}

static
STDAPI
URLDownloadToFileA(LPUNKNOWN          caller,
                   LPCSTR             szURL,
                   LPCSTR             szFileName,
                   DWORD              dwReserved,
                   LPBINDSTATUSCALLBACK callback)
{
    return E_OUTOFMEMORY;
}

static
STDAPI
URLDownloadToFileW(LPUNKNOWN           caller,
                   LPCWSTR             szURL,
                   LPCWSTR             szFileName,
                   DWORD               dwReserved,
                   LPBINDSTATUSCALLBACK callback)
{
    return E_OUTOFMEMORY;
}

static
STDAPI
FaultInIEFeature(HWND hWnd,
                 uCLSSPEC *pClassSpec,
                 QUERYCONTEXT *pQuery,
                 DWORD dwFlags)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoInternetParseUrl(LPCWSTR     pwzUrl,
                   PARSEACTION ParseAction,
                   DWORD       dwFlags,
                   LPWSTR      pszResult,
                   DWORD       cchResult,
                   DWORD      *pcchResult,
                   DWORD       dwReserved)
{
    return E_FAIL;
}

static
STDAPI
GetSoftwareUpdateInfo(LPCWSTR szDistUnit,
                      LPSOFTDISTINFO psdi)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI SetSoftwareUpdateAdvertisementState(LPCWSTR szDistUnit,
                                           DWORD dwAdState,
                                           DWORD dwAdvertisedVersionMS,
                                           DWORD dwAdvertisedVersionLS)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoInternetCreateSecurityManager(IServiceProvider* pSP,
                                IInternetSecurityManager** ppSM,
                                DWORD dwReserved)
{
    *ppSM = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
GetMarkOfTheWeb(LPCSTR pszURL,
                LPCSTR pszFile,
                DWORD dwFlags,
                LPSTR *ppszMark)
{
    *ppszMark = NULL;
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
URLOpenBlockingStreamW(LPUNKNOWN caller,
                       LPCWSTR szURL,
                       LPSTREAM* ppStream,
                       DWORD dwReserved,
                       LPBINDSTATUSCALLBACK callback)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI FindMimeFromData(LPBC pBC,
                        LPCWSTR pwzUrl,
                        LPVOID pBuffer,
                        DWORD cbSize,
                        LPCWSTR pwzMimeProposed,
                        DWORD dwMimeFlags,
                        LPWSTR *ppwzMimeOut,
                        DWORD dwReserved)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
URLDownloadToCacheFileA(LPUNKNOWN caller,
                        LPCSTR szURL,
                        LPTSTR szFileName,
                        DWORD dwBufLength,
                        DWORD dwReserved,
                        LPBINDSTATUSCALLBACK callback)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
URLDownloadToCacheFileW(LPUNKNOWN caller,
                        LPCWSTR szURL,
                        LPWSTR szFileName,
                        DWORD dwBufLength,
                        DWORD dwReserved,
                        LPBINDSTATUSCALLBACK callback)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
ObtainUserAgentString(DWORD dwOption,
                      LPSTR pszUAOut,
                      DWORD *cbSize)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoInternetGetSecurityUrl(
    LPCWSTR pwszUrl,
    LPWSTR *ppwszSecUrl,
    PSUACTION   psuAction,
    DWORD dwReserved
    )
{
    if (ppwszSecUrl)
    {
        *ppwszSecUrl = NULL;
    }
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CreateAsyncBindCtxEx(IBindCtx *pbc,
                     DWORD dwOptions,
                     IBindStatusCallback *pBSCb,
                     IEnumFORMATETC *pEnum,
                     IBindCtx **ppBC,
                     DWORD reserved)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
RegisterMediaTypeClass(LPBC pBC,
                       UINT ctypes,
                       const LPCSTR* rgszTypes,
                       CLSID *rgclsID,
                       DWORD reserved)
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI_(void)
ReleaseBindInfo(BINDINFO * pbindinfo)
{
}

static
HRESULT WINAPI
RevokeFormatEnumerator(LPBC pBC,
                       IEnumFORMATETC *pEFetc)
{
    return E_FAIL;
}

static
HRESULT WINAPI
RegisterFormatEnumerator(LPBC pBC,
                         IEnumFORMATETC *pEFetc,
                         DWORD reserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI
CoInternetCombineUrl(LPCWSTR pwzBaseUrl,
                     LPCWSTR pwzRelativeUrl,
                     DWORD dwCombineFlags,
                     LPWSTR pszResult,
                     DWORD cchResult,
                     DWORD * pcchResult,
                     DWORD dwReserved)
{
    return E_FAIL;
}

static
HRESULT WINAPI
IsValidURL(LPBC pBC,
           LPCWSTR szURL,
           DWORD dwReserved)
{
    return E_FAIL;
}

static
STDAPI
GetClassFileOrMime(
    LPBC pBC,
    LPCWSTR szFilename,
    LPVOID pBuffer,
    DWORD cbSize,
    LPCWSTR szMime,
    DWORD dwReserved,
    CLSID *pclsid
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
MkParseDisplayNameEx(
    IBindCtx *pbc,
    LPCWSTR szDisplayName,
    ULONG *pchEaten,
    LPMONIKER *ppmk
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoGetClassObjectFromURL(
    REFCLSID rCLASSID,
    LPCWSTR szCODE,
    DWORD dwFileVersionMS, 
    DWORD dwFileVersionLS,
    LPCWSTR szTYPE,
    LPBINDCTX pBindCtx,
    DWORD dwClsContext,
    LPVOID pvReserved,
    REFIID riid,
    LPVOID * ppv
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CoInternetCreateZoneManager(
    IServiceProvider *pSP,
    IInternetZoneManager **ppZM,
    DWORD dwReserved
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}  

static
STDAPI
CreateURLMonikerEx(
    LPMONIKER pMkCtx,
    LPCWSTR szURL,
    LPMONIKER FAR * ppmk,
    DWORD dwFlags
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CompareSecurityIds(
    BYTE* pbSecurityId1,
    DWORD dwLen1,
    BYTE* pbSecurityId2,
    DWORD dwLen2,
    DWORD dwReserved
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI IsAsyncMoniker(
    IMoniker* pmk
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}

static
STDAPI
CreateAsyncBindCtx(
    DWORD reserved,
    IBindStatusCallback *pBSCb,
    IEnumFORMATETC *pEFetc,
    IBindCtx **ppBC
    )
{
    return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(urlmon)
{
    DLPENTRY(CoGetClassObjectFromURL)
    DLPENTRY(CoInternetCombineUrl)
    DLPENTRY(CoInternetCreateSecurityManager)
    DLPENTRY(CoInternetCreateZoneManager)
    DLPENTRY(CoInternetGetSecurityUrl)
    DLPENTRY(CoInternetGetSession)
    DLPENTRY(CoInternetParseUrl)
    DLPENTRY(CoInternetQueryInfo)
    DLPENTRY(CompareSecurityIds)
    DLPENTRY(CreateAsyncBindCtx)
    DLPENTRY(CreateAsyncBindCtxEx)
    DLPENTRY(CreateFormatEnumerator)
    DLPENTRY(CreateURLMoniker)
    DLPENTRY(CreateURLMonikerEx)
    DLPENTRY(FaultInIEFeature)
    DLPENTRY(FindMimeFromData)
    DLPENTRY(GetClassFileOrMime)
    DLPENTRY(GetMarkOfTheWeb)
    DLPENTRY(GetSoftwareUpdateInfo)
    DLPENTRY(HlinkNavigateString)
    DLPENTRY(HlinkSimpleNavigateToString)
    DLPENTRY(IsAsyncMoniker)
    DLPENTRY(IsValidURL)
    DLPENTRY(MkParseDisplayNameEx)
    DLPENTRY(ObtainUserAgentString)
    DLPENTRY(RegisterBindStatusCallback)
    DLPENTRY(RegisterFormatEnumerator)
    DLPENTRY(RegisterMediaTypeClass)
    DLPENTRY(ReleaseBindInfo)
    DLPENTRY(RevokeBindStatusCallback)
    DLPENTRY(RevokeFormatEnumerator)
    DLPENTRY(SetSoftwareUpdateAdvertisementState)
    DLPENTRY(URLDownloadToCacheFileA)
    DLPENTRY(URLDownloadToCacheFileW)
    DLPENTRY(URLDownloadToFileA)
    DLPENTRY(URLDownloadToFileW)
    DLPENTRY(URLOpenBlockingStreamW)
    DLPENTRY(UrlMkGetSessionOption)
    DLPENTRY(UrlMkSetSessionOption)
};

DEFINE_PROCNAME_MAP(urlmon)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\msjava.c ===
#include "inetcorepch.h"
#pragma hdrstop

#include <unknwn.h>

#define JAVAVMAPI
#include <native.h>

static
JAVAVMAPI
long
__cdecl
execute_java_dynamic_method(
    ExecEnv *Unused,
    HObject *phObj,
    PCUTF8   putfMethod,
    PCUTF8   putfSignature,
    ...                             
    )
{
    return 0;
}

static
JAVAVMAPI
int64_t
__cdecl
execute_java_dynamic_method64(
    ExecEnv *Unused,
    HObject *phObj,
    PCUTF8   putfMethod,
    PCUTF8   putfSignature,
    ...
    )
{
    return 0;
}

static
JAVAVMAPI
void
__cdecl
GCFramePush(
    PVOID pGCFrame,
    PVOID pObjects,
    DWORD cbObjectStructSize
    )
{
}

static
JAVAVMAPI
BOOL
__cdecl
is_instance_of(
    HObject    *phObj,
    ClassClass *pClass,
    ExecEnv    *Unused
    )
{
    return FALSE;
}

static
JAVAVMAPI
void
__cdecl
GCFramePop(
    PVOID pGCFrame
    )
{
}

static
JAVAVMAPI
HObject*
__cdecl
execute_java_constructor(
    ExecEnv *Unused,
    PCUTF8 putfClassName,
    ClassClass *pClass,
    PCUTF8 putfSignature,
    ...
    )
{
    return NULL;
}

static
JAVAVMAPI
HString *
__cdecl
makeJavaStringW(
    LPCWSTR pcwsz,
    int cch
    )
{
    return NULL;
}

static
JAVAVMAPI
HObject *
__cdecl
convert_IUnknown_to_Java_Object(
    IUnknown *punk,
    HObject *phJavaClass,
    int fAssumeThreadSafe
    )
{
    return NULL;
}

static
JAVAVMAPI
ClassClass*
__cdecl
FindClass(
    ExecEnv *Unused,
    PCUTF8   putfClassName,
    bool_t   fResolve
    )
{
    return NULL;
}

static
JAVAVMAPI
void*
__cdecl
jcdwGetData(
    HObject *phJCDW
    )
{
    return NULL;
}

static
JAVAVMAPI
IUnknown *
__cdecl
convert_Java_Object_to_IUnknown(
    HObject *phJavaObject,
    const IID *pIID
    )
{
    return NULL;
}

static
JAVAVMAPI
LPWSTR
__cdecl
javaStringStart(
    HString *phString
    )
{
    return NULL;
}

static
JAVAVMAPI
int
__cdecl
javaStringLength(
    HString *phString
    )
{
    return 0;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msjava)
{
    DLPENTRY(FindClass)
    DLPENTRY(GCFramePop)
    DLPENTRY(GCFramePush)
    DLPENTRY(convert_IUnknown_to_Java_Object)
    DLPENTRY(convert_Java_Object_to_IUnknown)
    DLPENTRY(execute_java_constructor)
    DLPENTRY(execute_java_dynamic_method)
    DLPENTRY(execute_java_dynamic_method64)
    DLPENTRY(is_instance_of)
    DLPENTRY(javaStringLength)    
    DLPENTRY(javaStringStart)
    DLPENTRY(jcdwGetData)
    DLPENTRY(makeJavaStringW)
};

DEFINE_PROCNAME_MAP(msjava)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\wininet.c ===
#include "inetcorepch.h"
#pragma hdrstop

#define _WINX32_
#include <wininet.h>
#include <winineti.h>

#include <wincrypt.h>  // for ALG_ID

#undef  INTERNETAPI
#define INTERNETAPI         HRESULT STDAPICALLTYPE
#undef  INTERNETAPI_
#define INTERNETAPI_(type)  type STDAPICALLTYPE
#undef  BOOLAPI
#define BOOLAPI             BOOL STDAPICALLTYPE
#undef  STDAPI
#define STDAPI              HRESULT STDAPICALLTYPE
#undef  STDAPI_
#define STDAPI_(type)       type STDAPICALLTYPE
#undef  URLCACHEAPI_
#define URLCACHEAPI_(type)  type STDAPICALLTYPE    

static
BOOLAPI
CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD) 
InternetAttemptConnect(
    IN DWORD dwReserved
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
VOID
InternetAutodialCallback(
    IN DWORD dwOpCode,
    IN LPCVOID lpParam
    )
{
    return;
}

static
INTERNETAPI_(BOOL) 
InternetAutodial(
    IN DWORD    dwFlags,
    IN HWND     hwndParent
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
	return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetCheckConnectionW(
    IN      LPCWSTR   pszUrlW,
    IN      DWORD   dwFlags,
    IN      DWORD   dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetCombineUrlW(
    IN LPCWSTR pszBaseUrl,
    IN LPCWSTR pszRelativeUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetEnumPerSiteCookieDecisionA(
    OUT LPSTR pszSiteName, 
    IN OUT unsigned long *pcSiteNameSize, 
    OUT unsigned long *pdwDecision, 
    IN unsigned long dwIndex
    ) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
BOOLAPI
CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    *lpdwNumberOfBytesRead = 0;
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
InternetOpenW(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    return NULL;
}

static
BOOLAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetCrackUrlW(
    IN LPCWSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
HttpOpenRequestW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(BOOL) 
HttpEndRequestA(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
	return FALSE;
}

static
INTERNETAPI_(BOOL) 
HttpEndRequestW(
    IN HINTERNET hRequest,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
	return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
HttpSendRequestW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
HttpSendRequestExA(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSA lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
HttpSendRequestExW(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERSW lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERSW lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
	 SetLastError(ERROR_PROC_NOT_FOUND);
	 return FALSE;
}


static
INTERNETAPI_(DWORD)
InternetErrorDlg(
    IN HWND hWnd,
    IN OUT HINTERNET hRequest,
    IN DWORD dwError,
    IN DWORD dwFlags,
    IN OUT LPVOID * lppvData
    )
{
    return ERROR_CANCELLED;
}

static
INTERNETAPI_(BOOL)
InternetFortezzaCommand(
    DWORD dwCommand,
    HWND hwnd,
    DWORD_PTR dwReserved
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOLAPI
GetUrlCacheEntryInfoExW(
    IN LPCWSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPWSTR      lpszReserved,
    IN OUT LPDWORD lpdwReserved,
    LPVOID         lpReserved,
    DWORD          dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetGoOnlineW(
    IN LPWSTR   lpszURL,
    IN HWND     hwndParent,
    IN DWORD    dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetQueryFortezzaStatus(
    DWORD *pdwStatus,
    DWORD_PTR dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD)
InternetConfirmZoneCrossingW(
    IN HWND hWnd,
    IN LPWSTR szUrlPrev,
    IN LPWSTR szUrlNew,
    IN BOOL bPost
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOLAPI
GetUrlCacheEntryInfoExA(
    IN LPCSTR lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufSize,
    OUT LPSTR      lpszReserved, 
    IN OUT LPDWORD lpdwReserved,
    LPVOID         lpReserved,
    DWORD          dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
ReadUrlCacheEntryStream(
    IN HANDLE hUrlCacheStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
STDAPI_(BOOL)
IsProfilesEnabled()
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
CreateUrlCacheContainerA(
    IN LPCSTR Name, 
    IN LPCSTR CachePrefix, 
    IN LPCSTR CachePath, 
    IN DWORD KBCacheLimit,
    IN DWORD dwContainerType,
    IN DWORD dwOptions,
    IN OUT LPVOID pvBuffer,
    IN OUT LPDWORD cbBuffer
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheContainerA(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
DeleteUrlCacheContainerA(
    IN LPCSTR Name,
    IN DWORD dwOptions
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheContainerA(
    IN HANDLE hFind, 
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
RetrieveUrlCacheEntryStreamW(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
UnlockUrlCacheEntryStream(
    HANDLE hStream,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetClearAllPerSiteCookieDecisions()
{
    return TRUE;
}

static
INTERNETAPI_(DWORD)
PrivacySetZonePreferenceW(
    DWORD       dwZone, 
    DWORD       dwType,
    DWORD       dwTemplate,
    LPCWSTR     pszPreference
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
URLCACHEAPI_(BOOL)
DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
GetP3PPolicy(
    P3PCURL pszPolicyURL,
    HANDLE hDestination,
    P3PCXSL pszXSLtransform,
    struct P3PSignal *pSignal
    )
{
    return P3P_Error;
}

static
INTERNETAPI_(int)
MapResourceToPolicy(
    struct P3PResource *pResource,
    P3PURL pszPolicy,
    unsigned long dwSize,
    struct P3PSignal *pSignal
    )
{
    return P3P_Error;
}

static
INTERNETAPI_(BOOL)
InternetGetPerSiteCookieDecisionW(
    IN LPCWSTR pwchHostName,
    unsigned long* pResult
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static 
INTERNETAPI_(BOOL) 
InternetEnumPerSiteCookieDecisionW(
    OUT LPWSTR pwszSiteName, 
    IN OUT unsigned long *pcSiteNameSize, 
    OUT unsigned long *pdwDecision, 
    IN unsigned long dwIndex)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetSetPerSiteCookieDecisionW(
    IN LPCWSTR pwchHostName,
    DWORD dwDecision
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
FreeP3PObject(
    P3PHANDLE hObject
    )
{
    return P3P_Done;
}

static
BOOLAPI
ImportCookieFileW(
    IN LPCWSTR szFilename
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
ExportCookieFileW(
    IN LPCWSTR szFilename,
    IN BOOL fAppend
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheContainerW(
    IN OUT DWORD *pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
    IN OUT LPDWORD lpcbContainerInfo,
    IN DWORD dwOptions
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheContainerW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
    IN OUT LPDWORD lpcbContainerInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindCloseUrlCache(
    IN HANDLE hFind
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetCanonicalizeUrlA(
    IN LPCSTR pszUrl,
    OUT LPSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetCanonicalizeUrlW(
    IN LPCWSTR pszUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetGetConnectedStateExA(
    OUT LPDWORD lpdwFlags,
    OUT LPSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetGetConnectedState(
    OUT LPDWORD lpdwFlags,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheEntryA(
    IN HANDLE hFind,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
FreeUrlCacheSpaceW(
    IN LPCWSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD pcbEntryInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(HANDLE)
FindFirstUrlCacheEntryW(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    return NULL;
}

static
URLCACHEAPI_(BOOL)
DeleteUrlCacheEntryW(
    IN LPCWSTR lpszUrlName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetShowSecurityInfoByURLW(
    IN LPWSTR    pszUrlW,
    IN HWND      hwndRootWindow
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
SetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheConfigInfoW(
    OUT LPINTERNET_CACHE_CONFIG_INFOW pCacheConfigInfo,
    IN OUT LPDWORD pcbCacheConfigInfo,
    IN DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetCreateUrlW(
    IN LPURL_COMPONENTSW pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
HttpOpenRequestA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb OPTIONAL,
    IN LPCSTR lpszObjectName OPTIONAL,
    IN LPCSTR lpszVersion OPTIONAL,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return NULL;
}

static
INTERNETAPI_(INTERNET_STATUS_CALLBACK)
InternetSetStatusCallbackA(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )
{
    return INTERNET_INVALID_STATUS_CALLBACK;
}

static
INTERNETAPI_(HINTERNET)
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    return NULL;
}

static
INTERNETAPI_(BOOL)
InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpAddRequestHeadersA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpAddRequestHeadersW(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
HttpQueryInfoW(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
RegisterUrlCacheNotification(
    HWND        hWnd, 
    UINT        uMsg, 
    GROUPID     gid, 
    DWORD       dwFilter, 
    DWORD       dwReserve
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
SetUrlCacheEntryGroupW(
    IN LPCWSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes,
    IN DWORD    cbGroupAttributes,
    IN LPVOID   lpReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetTimeToSystemTimeW(
    IN  LPCWSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL)
GetUrlCacheConfigInfoA(
    LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetInitializeAutoProxyDll(
    DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
FindP3PPolicySymbol(
    const char *pszSymbol
    )
{
    return -1;
}

static
BOOLAPI
IsDomainLegalCookieDomainW(
    IN LPCWSTR pchDomain,
    IN LPCWSTR pchFullDomain
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(int)
GetP3PRequestStatus(
    P3PHANDLE hObject
    )
{
    return P3P_Error;
}

static
BOOLAPI
HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpPutFileEx(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpDeleteFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpDeleteFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOLAPI
FtpRenameFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
FtpOpenFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
FtpOpenFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOLAPI
FtpCreateDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpCreateDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
FtpGetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpRemoveDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET)
FtpFindFirstFileA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATAA lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    if (lpFindFileData)
    {
        lpFindFileData->cFileName[0] = 0;
    }
    return NULL;
}

static
INTERNETAPI_(HINTERNET)
FtpFindFirstFileW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATAW lpFindFileData OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    if (lpFindFileData)
    {
        lpFindFileData->cFileName[0] = 0;
    }
    return NULL;
}


static
BOOLAPI
FtpCommandA(
    IN HINTERNET hConnect,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand,
    IN DWORD_PTR dwContext,
    OUT HINTERNET *phFtpCommand OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpGetFileEx(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetWriteFile(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(INTERNET_STATUS_CALLBACK)
InternetSetStatusCallbackW(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpGetCurrentDirectoryA(
    IN HINTERNET hConnect,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpSetCurrentDirectoryA(
    IN HINTERNET hConnect,
    IN LPCSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
FtpSetCurrentDirectoryW(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszDirectory
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD)
FtpGetFileSize(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwFileSizeHigh OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HINTERNET) 
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
CreateUrlCacheEntryA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwExpectedFileSize,
    IN LPCSTR   lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetTimeToSystemTimeA(
    IN  LPCSTR lpcszTimeString,
    OUT SYSTEMTIME *lpSysTime,
    IN  DWORD dwReserved )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    ) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) 
InternetTimeFromSystemTimeW(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPWSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    ) 
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
INTERNETAPI_(BOOL)
InternetQueryOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
URLCACHEAPI_(BOOL) 
SetUrlCacheConfigInfoA(
    LPINTERNET_CACHE_CONFIG_INFOA pConfig,
    DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
URLCACHEAPI_(BOOL) 
CreateUrlCacheContainerW(
        IN LPCWSTR Name,
        IN LPCWSTR CachePrefix,
        IN LPCWSTR CachePath,
        IN DWORD KBCacheLimit,
        IN DWORD dwContainerType,
        IN DWORD dwOptions,
        IN OUT LPVOID pvBuffer,
        IN OUT LPDWORD cbBuffer)
{   
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetAutodialHangup(
    IN DWORD dwReserved
    )
{   
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
LoadUrlCacheContent(VOID)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(GROUPID) CreateUrlCacheGroup(
    IN DWORD  dwFlags,
    IN LPVOID lpReserved  // must pass NULL
    )
{
    GROUPID gid = 0;
    SetLastError(ERROR_PROC_NOT_FOUND);
    return gid;
}

static
BOOLAPI DeleteUrlCacheGroup(
    IN  GROUPID GroupId,
    IN  DWORD   dwFlags,       // must pass 0
    IN  LPVOID  lpReserved    // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) InternetGetConnectedStateExW(
    OUT LPDWORD lpdwFlags,
    OUT LPWSTR  lpszConnectionName,
    IN DWORD    dwNameLen,
    IN DWORD    dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
BOOLAPI FindNextUrlCacheEntryExA(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI FindNextUrlCacheEntryExW(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExA(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
INTERNETAPI_(HANDLE) FindFirstUrlCacheEntryExW(
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
    OUT    LPVOID    lpReserved,     // must pass NULL
    IN OUT LPDWORD   pcbReserved2,   // must pass NULL
    IN     LPVOID    lpReserved3     // must pass NULL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOLAPI IsHostInProxyBypassList (INTERNET_SCHEME tScheme, LPCSTR pszHost, DWORD cchHost)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl,
    IN OUT LPDWORD lpdwUrlLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) InternetReadFileExA(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSA lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD) InternetSetFilePointer(
    IN HINTERNET hFile,
    IN LONG  lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL) ResumeSuspendedDownload(
    IN HINTERNET hRequest,
    IN DWORD dwResultCode
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI UnlockUrlCacheEntryFileA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetUnlockRequestFile(
    IN HANDLE hLockRequestInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static 
BOOLAPI InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI InternetLockRequestFile(
    IN  HINTERNET hInternet,
    OUT HANDLE * lphLockRequestInfo
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI RetrieveUrlCacheEntryFileA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(DWORD)
InternetSetCookieExW(
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszCookieName,
    IN LPCWSTR lpszCookieData,
    DWORD dwFlags,
    DWORD_PTR dwReserved
    )
{
    return COOKIE_STATE_UNKNOWN;
}

static
BOOLAPI
InternetGetCookieExW(
    IN LPCWSTR pchURL,
    IN LPCWSTR pchCookieName,
    IN LPWSTR pchCookieData OPTIONAL,
    IN OUT LPDWORD pcchCookieData OPTIONAL,
    IN DWORD dwFlags,
    IN LPVOID lpReserved
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
IsUrlCacheEntryExpiredW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwFlags,
    IN OUT FILETIME* pftLastModified
    )
{
    return TRUE;
}

static
BOOLAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetSecurityProtocolToStringW(
    IN DWORD dwProtocol,
    IN LPWSTR lpstr,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
INTERNETAPI_(BOOL)
InternetAlgIdToStringW(
    IN ALG_ID ai,
    IN LPWSTR lpstr,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwReserved
    )
{
    return FALSE;
}

static
INTERNETAPI_(BOOL)
WINAPI
InternetGetCertByURL(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(wininet)
{
    DLOENTRY(110, ImportCookieFileW)
    DLOENTRY(111, ExportCookieFileW)
    DLOENTRY(112, IsProfilesEnabled)
    DLOENTRY(117, IsDomainLegalCookieDomainW)
    DLOENTRY(118, FindP3PPolicySymbol)
    DLOENTRY(120, MapResourceToPolicy)
    DLOENTRY(121, GetP3PPolicy)
    DLOENTRY(122, FreeP3PObject)
    DLOENTRY(123, GetP3PRequestStatus)
};

DEFINE_ORDINAL_MAP(wininet)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wininet)
{
    DLPENTRY(CommitUrlCacheEntryA)
    DLPENTRY(CommitUrlCacheEntryW)
    DLPENTRY(CreateUrlCacheContainerA)
    DLPENTRY(CreateUrlCacheContainerW)
    DLPENTRY(CreateUrlCacheEntryA)
    DLPENTRY(CreateUrlCacheEntryW)
    DLPENTRY(CreateUrlCacheGroup)
    DLPENTRY(DeleteUrlCacheContainerA)
    DLPENTRY(DeleteUrlCacheEntryA)
    DLPENTRY(DeleteUrlCacheEntryW)
    DLPENTRY(DeleteUrlCacheGroup)
    DLPENTRY(FindCloseUrlCache)
    DLPENTRY(FindFirstUrlCacheContainerA)
    DLPENTRY(FindFirstUrlCacheContainerW)
    DLPENTRY(FindFirstUrlCacheEntryA)
    DLPENTRY(FindFirstUrlCacheEntryExA)
    DLPENTRY(FindFirstUrlCacheEntryExW)
    DLPENTRY(FindFirstUrlCacheEntryW)
    DLPENTRY(FindNextUrlCacheContainerA)
    DLPENTRY(FindNextUrlCacheContainerW)
    DLPENTRY(FindNextUrlCacheEntryA)
    DLPENTRY(FindNextUrlCacheEntryExA)
    DLPENTRY(FindNextUrlCacheEntryExW)
    DLPENTRY(FindNextUrlCacheEntryW)
    DLPENTRY(FreeUrlCacheSpaceW)
    DLPENTRY(FtpCommandA)
    DLPENTRY(FtpCreateDirectoryA)
    DLPENTRY(FtpCreateDirectoryW)
    DLPENTRY(FtpDeleteFileA)
    DLPENTRY(FtpDeleteFileW)
    DLPENTRY(FtpFindFirstFileA)
    DLPENTRY(FtpFindFirstFileW)
    DLPENTRY(FtpGetCurrentDirectoryA)
    DLPENTRY(FtpGetCurrentDirectoryW)
    DLPENTRY(FtpGetFileEx)
    DLPENTRY(FtpGetFileSize)
    DLPENTRY(FtpOpenFileA)
    DLPENTRY(FtpOpenFileW)
    DLPENTRY(FtpPutFileEx)
    DLPENTRY(FtpRemoveDirectoryA)
    DLPENTRY(FtpRenameFileA)
    DLPENTRY(FtpSetCurrentDirectoryA)
    DLPENTRY(FtpSetCurrentDirectoryW)
    DLPENTRY(GetUrlCacheConfigInfoA)
    DLPENTRY(GetUrlCacheConfigInfoW)
    DLPENTRY(GetUrlCacheEntryInfoA)
    DLPENTRY(GetUrlCacheEntryInfoExA)
    DLPENTRY(GetUrlCacheEntryInfoExW)
    DLPENTRY(GetUrlCacheEntryInfoW)
    DLPENTRY(HttpAddRequestHeadersA)
    DLPENTRY(HttpAddRequestHeadersW)
    DLPENTRY(HttpEndRequestA)
    DLPENTRY(HttpEndRequestW)
    DLPENTRY(HttpOpenRequestA)
    DLPENTRY(HttpOpenRequestW)
    DLPENTRY(HttpQueryInfoA)
    DLPENTRY(HttpQueryInfoW)
    DLPENTRY(HttpSendRequestA)
    DLPENTRY(HttpSendRequestExA)
    DLPENTRY(HttpSendRequestExW)
    DLPENTRY(HttpSendRequestW)
    DLPENTRY(InternetAlgIdToStringW)
    DLPENTRY(InternetAttemptConnect)
    DLPENTRY(InternetAutodial)
    DLPENTRY(InternetAutodialCallback)
    DLPENTRY(InternetAutodialHangup)
    DLPENTRY(InternetCanonicalizeUrlA)
    DLPENTRY(InternetCanonicalizeUrlW)
    DLPENTRY(InternetCheckConnectionW)
    DLPENTRY(InternetClearAllPerSiteCookieDecisions)
    DLPENTRY(InternetCloseHandle)
    DLPENTRY(InternetCombineUrlW)
    DLPENTRY(InternetConfirmZoneCrossingW)
    DLPENTRY(InternetConnectA)
    DLPENTRY(InternetConnectW)
    DLPENTRY(InternetCrackUrlA)
    DLPENTRY(InternetCrackUrlW)
    DLPENTRY(InternetCreateUrlA)
    DLPENTRY(InternetCreateUrlW)
    DLPENTRY(InternetEnumPerSiteCookieDecisionA)
    DLPENTRY(InternetEnumPerSiteCookieDecisionW)
    DLPENTRY(InternetErrorDlg)
    DLPENTRY(InternetFindNextFileA)
    DLPENTRY(InternetFindNextFileW)
    DLPENTRY(InternetFortezzaCommand)
    DLPENTRY(InternetGetCertByURL)
    DLPENTRY(InternetGetConnectedState)
    DLPENTRY(InternetGetConnectedStateExA)
    DLPENTRY(InternetGetConnectedStateExW)
    DLPENTRY(InternetGetCookieExW)
    DLPENTRY(InternetGetLastResponseInfoA)
    DLPENTRY(InternetGetLastResponseInfoW)
    DLPENTRY(InternetGetPerSiteCookieDecisionW)
    DLPENTRY(InternetGoOnlineW)
    DLPENTRY(InternetInitializeAutoProxyDll)
    DLPENTRY(InternetLockRequestFile)
    DLPENTRY(InternetOpenA)
    DLPENTRY(InternetOpenUrlA)    
    DLPENTRY(InternetOpenUrlW)
    DLPENTRY(InternetOpenW)
    DLPENTRY(InternetQueryDataAvailable)
    DLPENTRY(InternetQueryFortezzaStatus)
    DLPENTRY(InternetQueryOptionA)
    DLPENTRY(InternetQueryOptionW)
    DLPENTRY(InternetReadFile)
    DLPENTRY(InternetReadFileExA)\
    DLPENTRY(InternetSecurityProtocolToStringW)
    DLPENTRY(InternetSetCookieExW)
    DLPENTRY(InternetSetFilePointer)
    DLPENTRY(InternetSetOptionA)
    DLPENTRY(InternetSetOptionW)
    DLPENTRY(InternetSetPerSiteCookieDecisionW)
    DLPENTRY(InternetSetStatusCallbackA)
    DLPENTRY(InternetSetStatusCallbackW)
    DLPENTRY(InternetShowSecurityInfoByURLW)
    DLPENTRY(InternetTimeFromSystemTimeA)   
    DLPENTRY(InternetTimeFromSystemTimeW)   
    DLPENTRY(InternetTimeToSystemTimeA)   
    DLPENTRY(InternetTimeToSystemTimeW)
    DLPENTRY(InternetUnlockRequestFile)
    DLPENTRY(InternetWriteFile)
    DLPENTRY(IsHostInProxyBypassList)
    DLPENTRY(IsUrlCacheEntryExpiredW)
    DLPENTRY(LoadUrlCacheContent)
    DLPENTRY(PrivacySetZonePreferenceW)
    DLPENTRY(ReadUrlCacheEntryStream)
    DLPENTRY(RegisterUrlCacheNotification)
    DLPENTRY(ResumeSuspendedDownload)
    DLPENTRY(RetrieveUrlCacheEntryFileA)
    DLPENTRY(RetrieveUrlCacheEntryStreamW)
    DLPENTRY(SetUrlCacheConfigInfoA)
    DLPENTRY(SetUrlCacheEntryGroupW)
    DLPENTRY(SetUrlCacheEntryInfoA)
    DLPENTRY(SetUrlCacheEntryInfoW)
    DLPENTRY(UnlockUrlCacheEntryFileA)
    DLPENTRY(UnlockUrlCacheEntryStream)
};

DEFINE_PROCNAME_MAP(wininet)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\dload\winhttp.c ===
#include "inetcorepch.h"
#pragma hdrstop

#define _WINHTTP_INTERNAL_
#include <winhttp.h>

static
BOOLAPI
WinHttpCloseHandle
(
    IN HINTERNET hInternet
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
WINHTTPAPI
HINTERNET
WINAPI
WinHttpConnect
(
    IN HINTERNET hSession,
    IN LPCWSTR pswzServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOLAPI
WinHttpCrackUrl
(
    IN LPCWSTR pwszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINHTTPAPI BOOL WINAPI WinHttpGetDefaultProxyConfiguration( IN OUT WINHTTP_PROXY_INFO * pProxyInfo)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOLAPI
WinHttpGetIEProxyConfigForCurrentUser
(
    IN OUT WINHTTP_CURRENT_USER_IE_PROXY_CONFIG * pProxyConfig
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
WinHttpGetProxyForUrl
(
    IN  HINTERNET                   hSession,
    IN  LPCWSTR                     lpcwszUrl,
    IN  WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    OUT WINHTTP_PROXY_INFO *        pProxyInfo  
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINHTTPAPI
HINTERNET
WINAPI
WinHttpOpen
(
    IN LPCWSTR pwszUserAgent,
    IN DWORD   dwAccessType,
    IN LPCWSTR pwszProxyName   OPTIONAL,
    IN LPCWSTR pwszProxyBypass OPTIONAL,
    IN DWORD   dwFlags
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINHTTPAPI
HINTERNET
WINAPI
WinHttpOpenRequest
(
    IN HINTERNET hConnect,
    IN LPCWSTR pwszVerb,
    IN LPCWSTR pwszObjectName,
    IN LPCWSTR pwszVersion,
    IN LPCWSTR pwszReferrer OPTIONAL,
    IN LPCWSTR FAR * ppwszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
BOOLAPI WinHttpQueryAuthSchemes
(
    IN  HINTERNET   hRequest,             // HINTERNET handle returned by WinHttpOpenRequest   
    OUT LPDWORD     lpdwSupportedSchemes, // a bitmap of available Authentication Schemes
    OUT LPDWORD     lpdwPreferredScheme,   // WinHttp's preferred Authentication Method    
    OUT LPDWORD     pdwAuthTarget  
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOLAPI
WinHttpQueryDataAvailable
(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOLAPI
WinHttpQueryHeaders
(
    IN     HINTERNET hRequest,
    IN     DWORD     dwInfoLevel,
    IN     LPCWSTR   pwszName OPTIONAL, 
       OUT LPVOID    lpBuffer OPTIONAL,
    IN OUT LPDWORD   lpdwBufferLength,
    IN OUT LPDWORD   lpdwIndex OPTIONAL
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOLAPI
WinHttpQueryOption
(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


BOOLAPI
WinHttpReadData
(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINHTTPAPI
BOOL
WINAPI
WinHttpReceiveResponse
(
    IN HINTERNET hRequest,
    IN LPVOID lpReserved
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
WinHttpSendRequest
(
    IN HINTERNET hRequest,
    IN LPCWSTR pwszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI WinHttpSetCredentials
(
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by WinHttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from WinHttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCWSTR     pwszUserName,    // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCWSTR     pwszPassword,    // 1) "" == Blank Password; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID      pAuthParams
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLAPI
WinHttpSetOption
(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINHTTPAPI
WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpSetStatusCallback
(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOLAPI
WinHttpSetTimeouts
(    
    IN HINTERNET    hInternet,           // Session/Request handle.
    IN int          nResolveTimeout,
    IN int          nConnectTimeout,
    IN int          nSendTimeout,
    IN int          nReceiveTimeout
)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order,
// and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(winhttp)
{
    DLPENTRY(WinHttpCloseHandle)
    DLPENTRY(WinHttpConnect)
    DLPENTRY(WinHttpCrackUrl)
    DLPENTRY(WinHttpGetDefaultProxyConfiguration)
    DLPENTRY(WinHttpGetIEProxyConfigForCurrentUser)
    DLPENTRY(WinHttpGetProxyForUrl)
    DLPENTRY(WinHttpOpen)
    DLPENTRY(WinHttpOpenRequest)
    DLPENTRY(WinHttpQueryAuthSchemes)
    DLPENTRY(WinHttpQueryDataAvailable)
    DLPENTRY(WinHttpQueryHeaders)
    DLPENTRY(WinHttpQueryOption)
    DLPENTRY(WinHttpReadData)
    DLPENTRY(WinHttpReceiveResponse)
    DLPENTRY(WinHttpSendRequest)
    DLPENTRY(WinHttpSetCredentials)
    DLPENTRY(WinHttpSetOption)
    DLPENTRY(WinHttpSetStatusCallback)
    DLPENTRY(WinHttpSetTimeouts)
};

DEFINE_PROCNAME_MAP(winhttp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\advpub.h ===
//*     Copyright (c) Microsoft Corporation 1995-1998. All rights reserved. *
//***************************************************************************
//*                                                                         *
//* ADVPUB.H - Specify the Interface for ADVPACK.DLL                        *
//*                                                                         *
//***************************************************************************


#ifndef _ADVPUB_H_
#define _ADVPUB_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RunSetupCommand
//
// SYNOPSIS:    Execute an install section in an INF file, or execute a
//              program.  Advanced INF files are supported.
//
// RETURN CODES:
//
//      S_OK                                 Everything OK, no reboot needed.
//                                           No EXE to wait for.
//      S_ASYNCHRONOUS                       Please wait on phEXE.
//      ERROR_SUCCESS_REBOOT_REQUIRED        Reboot required.
//      E_INVALIDARG                         NULL specified in szCmdName or szDir
//      HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION) INF's not supported on this OS version
//      E_UNEXPECTED                         Catastrophic failure(should never happen).
//      HRESULT_FROM_WIN32(GetLastError())   Anything else
/////////////////////////////////////////////////////////////////////////////

#ifndef S_ASYNCHRONOUS
#define S_ASYNCHRONOUS  _HRESULT_TYPEDEF_(0x401e8L)
#endif

#define achRUNSETUPCOMMANDFUNCTION   "RunSetupCommand"

HRESULT WINAPI RunSetupCommand( HWND hWnd, LPCSTR szCmdName,
                                LPCSTR szInfSection, LPCSTR szDir,
                                LPCSTR lpszTitle, HANDLE *phEXE,
                                DWORD dwFlags, LPVOID pvReserved );

typedef HRESULT (WINAPI *RUNSETUPCOMMAND)(
    HWND    hWnd,                       // Handle to parent window  NULL=Quiet mode
    LPCSTR  szCmdName,                  // Inf or EXE filename to "run"
    LPCSTR  szInfSection,               // Inf section to install.  NULL="DefaultInstall"
    LPCSTR  szDir,                      // Path to extracted files
    LPCSTR  szTitle,                    // Title for all dialogs
    HANDLE *phEXE,                      // Handle to EXE to wait for
    DWORD   dwFlags,                    // Flags to specify functionality (see above)
    LPVOID  pvReserved                  // Reserved for future use
);

// FLAGS:

#define RSC_FLAG_INF                1   // exxcute INF install
#define RSC_FLAG_SKIPDISKSPACECHECK 2   // Currently does nothing
#define RSC_FLAG_QUIET              4   // quiet mode, no UI
#define RSC_FLAG_NGCONV             8   // don't run groupConv
#define RSC_FLAG_UPDHLPDLLS         16  // force to self-updating on user's system
#define RSC_FLAG_DELAYREGISTEROCX  512  // force delay of ocx registration
#define RSC_FLAG_SETUPAPI	  1024  // use setupapi.dll

// please not adding flag after this.  See LaunchINFSectionEx() flags.

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: NeedRebootInit
//
// SYNOPSIS:    Initializes state for reboot checking.  Call this function
//              before calling RunSetupCommand.
// RETURNS:     value required to be passed to NeedReboot()
/////////////////////////////////////////////////////////////////////////////

#define achNEEDREBOOTINITFUNCTION   "NeedRebootInit"

DWORD WINAPI NeedRebootInit( VOID );

typedef DWORD (WINAPI *NEEDREBOOTINIT)(VOID);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: NeedReboot
//
// SYNOPSIS:    Compares stored state with current state to determine if a
//              reboot is required.
//      dwRebootCheck   the return value from NeedRebootInit
//
// RETURNS:
//      TRUE            if a reboot is required;
//      FALSE           otherwise.
/////////////////////////////////////////////////////////////////////////////

#define achNEEDREBOOTFUNCTION   "NeedReboot"

BOOL WINAPI NeedReboot( DWORD dwRebootCheck );

typedef BOOL (WINAPI *NEEDREBOOT)(
	DWORD dwRebootCheck                                     // Value returned from NeedRebootInit
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DoReboot
//
// SYNOPSIS:    Ask advpack to do reboot.
//      hwnd        if it is INVALID_HANDLE_VALUE, no user prompt.  Otherwise promp.
//      pszTitle    User prompt UI title string.
//      dwReserved  Not used.
// RETURNS:
//      FALSE       User choose NO to reboot prompt.
/////////////////////////////////////////////////////////////////////////////

// #define achDOREBOOT "DoReboot"

// BOOL WINAPI DoReboot( HWND hwnd, BOOL bDoUI );
// typedef BOOL (WINAPI* DOREBOOT)( HWND hwnd, BOOL bDoUI );

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RebootCheckOnInstall
//
// SYNOPSIS:    Check reboot condition if the given INF section is installed.
//      hwnd    windows handle
//      pszINF  INF filename with fully qualified path
//      pszSec  INF section.  NULL is translated as DefaultInstall or DefaultInstall.NT.
//      dwReserved Not used.
// RETURN:
//      S_OK    Reboot needed if INF section is installed.
//      S_FALSE Reboot is not needed if INF section is installed.
//      HRESULT of Win 32 errors
//
/////////////////////////////////////////////////////////////////////////////

#define achPRECHECKREBOOT   "RebootCheckOnInstall"

HRESULT WINAPI RebootCheckOnInstall( HWND hwnd, PCSTR pszINF, PCSTR pszSec, DWORD dwReserved );

typedef HRESULT (WINAPI *REBOOTCHECKONINSTALL)( HWND, PCSTR, PCSTR, DWORD );

//////////////////////////////////////////////////////////////////////////
// ENTRY POINT: TranslateInfString
//
// SYNOPSIS:    Translates a key value in an INF file, using advanced INF
//              syntax.
// RETURN CODES:
//      S_OK                                 Everything OK.
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//                                      The buffer size is too small to hold the
//                                      translated string.  Required size is in *pdwRequiredSize.
//      E_INVALIDARG                         NULL specified in pszInfFilename, pszTranslateSection,
//                                      pszTranslateKey, pdwRequiredSize.
//      HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION)
//                                      OS not supported.
//      E_UNEXPECTED                         Catastrophic failure -- should never happen.
//      HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)
//                                      The section or key specified does not exist.
//      HRESULT_FROM_WIN32(GetLastError())   Anything else
//
/////////////////////////////////////////////////////////////////////////////

#define c_szTRANSLATEINFSTRING "TranslateInfString"

HRESULT WINAPI TranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                                   PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                   PSTR pszBuffer, DWORD dwBufferSize,
                                   PDWORD pdwRequiredSize, PVOID pvReserved );

typedef HRESULT (WINAPI *TRANSLATEINFSTRING)(
    PCSTR  pszInfFilename,              // Name of INF file to process
    PCSTR  pszInstallSection,           // Install section name (NULL=DefaultInstall)
    PCSTR  pszTranslateSection,         // Section that contains key to translate
    PCSTR  pszTranslateKey,             // Key to translate
    PSTR   pszBuffer,                   // Buffer to store translated key.  (NULL=return required size only)
    DWORD  dwBufferSize,                // Size of this buffer.  If pszBuffer==NULL, this is ignored.
    PDWORD pdwRequiredSize,             // Required size of buffer
    PVOID  pvReserved                   // Reserved for future use
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegInstall
//
// SYNOPSIS:    Loads an INF from a string resource, adds some entries to the
//              INF string substitution table, and executes the INF.
// RETURNS:
//      S_OK    success.
//      E_FAIL  failure,
/////////////////////////////////////////////////////////////////////////////

#define achREGINSTALL   "RegInstall"

typedef struct _StrEntry {
    LPSTR   pszName;            // String to substitute
    LPSTR   pszValue;           // Replacement string or string resource
} STRENTRY, *LPSTRENTRY;

typedef const STRENTRY CSTRENTRY;
typedef CSTRENTRY *LPCSTRENTRY;

typedef struct _StrTable {
    DWORD       cEntries;       // Number of entries in the table
    LPSTRENTRY  pse;            // Array of entries
} STRTABLE, *LPSTRTABLE;

typedef const STRTABLE CSTRTABLE;
typedef CSTRTABLE *LPCSTRTABLE;

HRESULT WINAPI RegInstall( HMODULE hm, LPCSTR pszSection, LPCSTRTABLE pstTable );

typedef HRESULT (WINAPI *REGINSTALL)(
    HMODULE hm,                         // Module that contains REGINST resource
    LPCSTR pszSection,                  // Section of INF to execute
    LPCSTRTABLE pstTable                // Additional string substitutions
);


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: LaunchINFSectionEx
//
// SYNOPSIS:    Install INF section with BACKUP/ROLLBACK capabilities.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#define achLAUNCHINFSECTIONEX   "LaunchINFSectionEx"

HRESULT WINAPI LaunchINFSectionEx( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow );

typedef HRESULT (WINAPI *LAUNCHINFSECTIONEX)(
    HWND     hwnd,                      // pass in window handle
    HINSTANCE hInst,                    // instance handle
    PSTR     pszParams,                 // String contains params: INF,section,CAB,flags
    INT      nShow
);

// FLAGS:
// FLAGS value this way is for compatibility. Don't change them.
//
#define ALINF_QUIET              4      // quiet mode, no UI
#define ALINF_NGCONV             8      // don't run groupConv
#define ALINF_UPDHLPDLLS         16     // force to self-updating on user's system
#define ALINF_BKINSTALL          32     // backup data before install
#define ALINF_ROLLBACK           64     // rollback to previous state
#define ALINF_CHECKBKDATA        128    // validate the backup data
#define ALINF_ROLLBKDOALL        256    // bypass building file list
#define ALINF_DELAYREGISTEROCX   512    // force delay of ocx registration


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: ExecuteCab
//
// SYNOPSIS:    Extract the an INF from the CAB file, and do INF install on it.
/////////////////////////////////////////////////////////////////////////////

// RETURNS: E_FAIL on failure, S_OK on success.

#define achEXECUTECAB   "ExecuteCab"

typedef struct _CabInfo {
    PSTR  pszCab;
    PSTR  pszInf;
    PSTR  pszSection;
    char  szSrcPath[MAX_PATH];
    DWORD dwFlags;
} CABINFO, *PCABINFO;

HRESULT WINAPI ExecuteCab( HWND hwnd, PCABINFO pCab, LPVOID pReserved );

typedef HRESULT (WINAPI *EXECUTECAB)(
    HWND     hwnd,
    PCABINFO pCab,
    LPVOID   pReserved
);

// flag as LaunchINFSectionEx's flag defines

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: AdvInstallFile
//
// SYNOPSIS:    To copy a file from the source to a destination
//              Basicly a wrapper around the setupapi file copy engine
/////////////////////////////////////////////////////////////////////////////

// Flags which can be passed to AdvInstallFile
// Here is a copy of the flags defined in setupapi.h for reference below.
//#define COPYFLG_WARN_IF_SKIP            0x00000001   // warn if user tries to skip file
//#define COPYFLG_NOSKIP                  0x00000002   // disallow skipping this file
//#define COPYFLG_NOVERSIONCHECK          0x00000004   // ignore versions and overwrite target
//#define COPYFLG_FORCE_FILE_IN_USE       0x00000008   // force file-in-use behavior
//#define COPYFLG_NO_OVERWRITE            0x00000010   // do not copy if file exists on target
//#define COPYFLG_NO_VERSION_DIALOG       0x00000020   // do not copy if target is newer
//#define COPYFLG_REPLACEONLY             0x00000400   // copy only if file exists on target

#define AIF_WARNIFSKIP          0x00000001              // system critical file: warn if user tries to skip
#define AIF_NOSKIP              0x00000002              // Skip is disallowed for this file
#define AIF_NOVERSIONCHECK      0x00000004              // don't check the version number of the file overwrite
#define AIF_FORCE_FILE_IN_USE   0x00000008              // force file-in-use behavior
#define AIF_NOOVERWRITE         0x00000010              // copy only if target doesn't exist
                                                        // if AIF_QUIET, the file is not copied and
                                                        // the user is not notified
#define AIF_NO_VERSION_DIALOG   0x00000020              // do not copy if target is newer
#define AIF_REPLACEONLY         0x00000400              // copy only if target file already present

// Flags only known to AdvInstallFile
#define AIF_NOLANGUAGECHECK     0x10000000              // don't check the language of the file
                                                        // if the flags is NOT specified and AIF_QUIET
                                                        // the file is not copied and the user is not notified
#define AIF_QUIET               0x20000000              // No UI to the user


#define achADVINSTALLFILE   "AdvInstallFile"

HRESULT WINAPI AdvInstallFile(HWND hwnd, LPCSTR lpszSourceDir, LPCSTR lpszSourceFile,
                              LPCSTR lpszDestDir, LPCSTR lpszDestFile, DWORD dwFlags, DWORD dwReserved);

typedef HRESULT (WINAPI *ADVINSTALLFILE)(
                                            HWND hwnd,                  // Parent Window for messages
                                            LPCSTR lpszSourceDir,       // Source directory (does not contain filename)
                                            LPCSTR lpszSourceFile,      // Filename only
                                            LPCSTR lpszDestDir,         // Destination directory (does not contain filename)
                                            LPCSTR lpszDestFile,        // optional filename. if NULL lpszSourceFile is used
                                            DWORD dwFlags,              // AIF_* FLAGS
                                            DWORD dwReserved);

//////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////
// the following flags are for backwards compatiable.  No API user
// should reference them directly now.
//
#define  IE4_RESTORE        0x00000001      // if this bit is off, save the registries.
#define  IE4_BACKNEW        0x00000002      // backup all files which are not backed up before
#define  IE4_NODELETENEW    0x00000004      // don't delete files we don't backed up before
#define  IE4_NOMESSAGES     0x00000008      // No message display in any events.
#define  IE4_NOPROGRESS     0x00000010      // this bit on: No file backup progressbar
#define  IE4_NOENUMKEY      0x00000020      // this bit on: Don't Enum sub key even there is no given valuename
#define  IE4_NO_CRC_MAPPING 0x00000040      // Normally you should not turn on this bit, advpack creates
                                            // internal mapping for all the entries backed up.
#define  IE4_REGSECTION     0x00000080      // INF AddReg/DelReg section
#define  IE4_FRDOALL        0x00000100      // FileRestore DoAll
#define  IE4_UPDREFCNT	    0x00000200      // Update the ref count in .ini backup file list
#define  IE4_USEREFCNT	    0x00000400      // use ref count to determin if the backup file should be put back
#define  IE4_EXTRAINCREFCNT 0x00000800	    // if increase the ref cnt if it has been updated before

#define  IE4_REMOVREGBKDATA 0x00001000      // This bit should be used with restore bit

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegSaveRestore
//
// SYNOPSIS:    Save or Restore the given register value or given INF reg section.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

// Save or Restore the given register value
HRESULT WINAPI RegSaveRestore(HWND hWnd, PCSTR pszTitleString, HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags);

typedef HRESULT (WINAPI *REGSAVERESTORE)( HWND hWnd,
                                          PCSTR pszTitleString,  // user specified UI title
                                          HKEY hkBckupKey,       // opened Key handle to store the backup data
                                          PCSTR pcszRootKey,     // RootKey string
                                          PCSTR pcszSubKey,      // SubKey string
                                          PCSTR pcszValueName,   // Value name string
                                          DWORD dwFlags);        // Flags

// Save or Restore the given INF Reg Section. At restore, if INF and Section pointers are NULL,
// Restore all from the given backup key handle.
HRESULT WINAPI RegSaveRestoreOnINF( HWND hWnd, PCSTR pszTitle, PCSTR pszINF,
                                    PCSTR pszSection, HKEY hHKLMBackKey, HKEY hHKCUBackKey, DWORD dwFlags );

typedef HRESULT (WINAPI *REGSAVERESTOREONINF)( HWND hWnd,
                                              PCSTR pszTitle,        // user specified UI title
                                              PCSTR pszINF,          // INF filename with fully qualified path
                                              PCSTR pszSection,       // INF section name.  NULL == default
                                              HKEY hHKLMBackKey,       // openned key handle to store the data
                                              HKEY hHKCUBackKey,       // openned key handle to store the data
                                              DWORD dwFlags );       // Flags

// FLAG:
#define ARSR_RESTORE    IE4_RESTORE       // if this bit is off, means Save. Otherwise, restore.
#define ARSR_NOMESSAGES IE4_NOMESSAGES    // Quiet no messages in any event.
#define ARSR_REGSECTION IE4_REGSECTION    // if this bit is off, the given section is GenInstall Section
#define ARSR_REMOVREGBKDATA IE4_REMOVREGBKDATA // if both this bit and restore bit on, remove the backup reg data without restore it

// Turn on the logging by add these RegVale in HKLM\software\microsoft\IE4
#define  REG_SAVE_LOG_KEY    "RegSaveLogFile"
#define  REG_RESTORE_LOG_KEY "RegRestoreLogFile"

// for backwards compatible add this one back
HRESULT WINAPI RegRestoreAll(HWND hWnd, PSTR pszTitleString, HKEY hkBckupKey);
typedef HRESULT (WINAPI *REGRESTOREALL)(HWND hWnd, PSTR pszTitleString, HKEY hkBckupKey);
/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: FileSaveRestore
//
// SYNOPSIS:    Save or Restore the files on the list lpFileList.
//              If lpFileList is NULL at restore time, the function will restore
//              all based on INI index file.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI FileSaveRestore( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags);

typedef HRESULT (WINAPI *FILESAVERESTORE)( HWND hDlg,
                                           LPSTR lpFileList,    // File list file1\0file2\0filen\0\0
                                           LPSTR lpDir,         // pathname of the backup directory
                                           LPSTR lpBaseName,    // backup file basename
                                           DWORD dwFlags);      // Flags

HRESULT WINAPI FileSaveRestoreOnINF( HWND hWnd, PCSTR pszTitle, PCSTR pszINF,
                                     PCSTR pszSection, PCSTR pszBackupDir, PCSTR pszBaseBackupFile,
                                     DWORD dwFlags );

typedef HRESULT (WINAPI *FILESAVERESTOREONINF)( HWND hDlg,
                                                  PCSTR pszTitle,        // user specified UI title
                                                  PCSTR pszINF,          // INF filename with fully qualified path
                                                  PCSTR pszSection,      // GenInstall INF section name.  NULL == default
                                                  PCSTR pszBackupDir,    // directory to store the backup file
                                                  PCSTR pszBaseBackFile, // Basename of the backup data files
                                                  DWORD dwFlags );       // Flags


// FLAGS:
#define  AFSR_RESTORE        IE4_RESTORE      // if this bit is off, save the file.
#define  AFSR_BACKNEW        IE4_BACKNEW      // backup all files which are not backed up before
#define  AFSR_NODELETENEW    IE4_NODELETENEW  // don't delete files we don't backed up before
#define  AFSR_NOMESSAGES     IE4_NOMESSAGES   // No message display in any events.
#define  AFSR_NOPROGRESS     IE4_NOPROGRESS   // this bit on: No file backup progressbar
#define  AFSR_UPDREFCNT      IE4_UPDREFCNT    // update the reference count for the files
#define  AFSR_USEREFCNT	     IE4_USEREFCNT    // use the ref count to guide the restore file
#define  AFSR_EXTRAINCREFCNT IE4_EXTRAINCREFCNT

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: AddDelBackupEntry
//
// SYNOPSIS:    If AADBE_ADD_ENTRY is specified, mark the file in the File list as not existing
//              during file save in the INI file.  This can be used to mark additional files that
//              they did not exist during backup to avoid having them backup the next time the
//              FileSaveRestore is called to save files.
//              If AADBE_DEL_ENTRY is specified, delete the entry from the INI.  This mechanism can
//              be used to leave files permanently on the system.
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI AddDelBackupEntry(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags);

typedef HRESULT (WINAPI *ADDDELBACKUPENTRY)(LPCSTR lpcszFileList,   // File list file1\0file2\0filen\0\0
                                           LPCSTR lpcszBackupDir,   // pathname of the backup directory
                                           LPCSTR lpcszBaseName,    // backup file basename
                                           DWORD  dwFlags);

#define  AADBE_ADD_ENTRY    0x01            // add entries to the INI file
#define  AADBE_DEL_ENTRY    0x02            // delete entries from the INI file

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: FileSaveMarkNotExist
//
// SYNOPSIS:    Mark the file in the File list as not existing during file save in the INI file
//              This can be used to mark additional files that they did not exist during backup
//              to avoid having them backup the next time the FileSaveRestore is called to save
//              files
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI FileSaveMarkNotExist( LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName);

typedef HRESULT (WINAPI *FILESAVEMARKNOTEXIST)( LPSTR lpFileList,    // File list file1\0file2\0filen\0\0
                                           LPSTR lpDir,         // pathname of the backup directory
                                           LPSTR lpBaseName);    // backup file basename

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: GetVersionFromFile
//
// SYNOPSIS:    Get the given file's version and lang information.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI GetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);

typedef HRESULT (WINAPI *GETVERSIONFROMFILE)(
                                                LPSTR lpszFilename,         // filename to get info from
                                                LPDWORD pdwMSVer,           // Receive Major version
                                                LPDWORD pdwLSVer,           // Receive Minor version
                                                BOOL bVersion);             // if FALSE, pdwMSVer receive lang ID
                                                                            // pdwLSVer receive Codepage ID

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: GetVersionFromFileEx
//
// SYNOPSIS:    Get the given disk file's version and lang information.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI GetVersionFromFileEx(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);

typedef HRESULT (WINAPI *GETVERSIONFROMFILE)(
                                                LPSTR lpszFilename,         // filename to get info from
                                                LPDWORD pdwMSVer,           // Receive Major version
                                                LPDWORD pdwLSVer,           // Receive Minor version
                                                BOOL bVersion);             // if FALSE, pdwMSVer receive lang ID
                                                                            // pdwLSVer receive Codepage ID

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: IsNTAdmin
//
// SYNOPSIS:    On NT, check if user has admin right.
//
// RETURNS:     TURE  has admin right; FLSE  no admin right.
/////////////////////////////////////////////////////////////////////////////

#define achISNTADMIN "IsNTAdmin"

BOOL WINAPI IsNTAdmin( DWORD dwReserved, DWORD *lpdwReserved );

typedef BOOL (WINAPI *ISNTADMIN)( DWORD,        // not used
                                  DWORD * );    // not used

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNode
//
// SYNOPSIS:    Deletes a file or directory
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

// FLAGS:
#define ADN_DEL_IF_EMPTY        0x00000001  // delete the directory only if it's empty
#define ADN_DONT_DEL_SUBDIRS    0x00000002  // don't delete any sub-dirs; delete only the files
#define ADN_DONT_DEL_DIR        0x00000004  // don't delete the dir itself
#define ADN_DEL_UNC_PATHS       0x00000008  // delete UNC paths

#define achDELNODE              "DelNode"

HRESULT WINAPI DelNode(LPCSTR pszFileOrDirName, DWORD dwFlags);

typedef HRESULT (WINAPI *DELNODE)(
    LPCSTR pszFileOrDirName,                // Name of file or directory to delete
    DWORD dwFlags                           // 0, ADN_DEL_IF_EMPTY, etc. can be specified
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNodeRunDLL32
//
// SYNOPSIS:    Deletes a file or directory; the parameters to this API are of
//              WinMain type
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#define achDELNODERUNDLL32      "DelNodeRunDLL32"

HRESULT WINAPI DelNodeRunDLL32(HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow);

typedef HRESULT (WINAPI *DELNODERUNDLL32)(
    HWND     hwnd,                          // pass in window handle
    HINSTANCE hInst,                        // instance handle
    PSTR     pszParams,                     // String contains params: FileOrDirName,Flags
    INT      nShow
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: OpenINFEngine, TranslateINFStringEx, CloseINFEngine
//
// SYNOPSIS:    Three APIs give the caller the option to be more efficient when need
//              Advpack to translate INF file in a continue fashion.
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if !defined(UNIX) || !defined(_INC_SETUPAPI) // IEUNIX: Prevent re-def.
//
// Define type for reference to loaded inf file
// (from setupapi.h)
//
typedef PVOID HINF;
#endif

HRESULT WINAPI OpenINFEngine( PCSTR pszInfFilename, PCSTR pszInstallSection,
                              DWORD dwFlags, HINF *phInf, PVOID pvReserved );

HRESULT WINAPI TranslateInfStringEx( HINF hInf, PCSTR pszInfFilename,
                                     PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                     PSTR pszBuffer, DWORD dwBufferSize,
                                     PDWORD pdwRequiredSize, PVOID pvReserved );

HRESULT WINAPI CloseINFEngine( HINF hInf );



HRESULT WINAPI ExtractFiles( LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                             LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: LaunchINFSection
//
// SYNOPSIS:    Install INF section WITHOUT BACKUP/ROLLBACK capabilities.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

INT     WINAPI LaunchINFSection( HWND, HINSTANCE, PSTR, INT );

// LaunchINFSection flags
#define LIS_QUIET               0x0001      // Bit 0
#define LIS_NOGRPCONV           0x0002      // Bit 1

// Flags in Advanced INF RunPreSetupCommands and RunPostSetupCommands of the Install section
// Those flags can tell advpack how to run those commands, quiet or not quiet, wait or not wait.
// The Default for runing those commands are:  Not Quiet and Wait for finish before return the caller.
// I.E>  RunPostSetupCommands = MyCmdsSecA:1, MyCmdsSecB:2, MyCmdsSecC
//
#define RUNCMDS_QUIET		0x00000001
#define RUNCMDS_NOWAIT		0x00000002
#define RUNCMDS_DELAYPOSTCMD	0x00000004

// Active Setup Installed Components GUID for IE4
#define awchMSIE4GUID L"{89820200-ECBD-11cf-8B85-00AA005B4383}"

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: UserStubWrapper
//
// SYNOPSIS:    The function wrapper around the real per-user restore stub to 
//              do some generic/intelligent function on behalf of every component.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI UserInstStubWrapper( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow ); 

#define achUserInstStubWrapper      "UserInstStubWrapper"

typedef HRESULT (WINAPI *USERINSTSTUBWRAPPER)(
                                           HWND     hwnd,                          // pass in window handle
                                           HINSTANCE hInst,                        // instance handle
                                           PSTR     pszParams,                     // String contains params: {GUID}
                                           INT      nShow
                                          );

HRESULT WINAPI UserUnInstStubWrapper( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow ); 

#define achUserUnInstStubWrapper      "UserUnInstStubWrapper"

typedef HRESULT (WINAPI *USERUNINSTSTUBWRAPPER)(
                                           HWND     hwnd,                          // pass in window handle
                                           HINSTANCE hInst,                        // instance handle
                                           PSTR     pszParams,                     // String contains params: {GUID}
                                           INT      nShow
                                          );

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: SetPerUserInstValues
//
// SYNOPSIS:    The function set the per-user stub reg values under IsInstalled\{GUID} 
//              related key to ensure the later per-user process correctly.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

// Args passed to the following API
// MAX_GUID_STRING_LEN is 39 defined in cfgmgr32.h, here we just use it.
//
typedef struct _PERUSERSECTION { char szGUID[39+20];
                                 char szDispName[128];
       		                 char szLocale[10];
                                 char szStub[MAX_PATH*4];
                                 char szVersion[32];
                				 char szCompID[128]; 
                                 DWORD dwIsInstalled;
                                 BOOL  bRollback;
} PERUSERSECTION, *PPERUSERSECTION;


HRESULT WINAPI SetPerUserSecValues( PPERUSERSECTION pPerUser );

#define achSetPerUserSecValues      "SetPerUserSecValues"

typedef HRESULT (WINAPI *SETPERUSERSECVALUES)( PPERUSERSECTION pPerUser );


/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif // _ADVPUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\capi.h ===
#include <wincrypt.h>
#include <sipbase.h>
#include <mscat.h>
#include <mssip.h>
#include <wintrust.h>

#ifndef _JTRUST_H
#define _JTRUST_H

#if !defined(JAVA_TRUST_PROVIDER)

#ifdef __cplusplus
extern "C" {
#endif


// New guids for Java Policy Provider
// {E6F795B1-F738-11d0-A72F-00A0C903B83D}
#define JAVA_POLICY_PROVIDER_DOWNLOAD \
{ 0xe6f795b1, 0xf738, 0x11d0, {0xa7, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0xb8, 0x3d } }

// {E6F795B2-F738-11d0-A72F-00A0C903B83D}
#define JAVA_POLICY_PROVIDER_CHECK \
{ 0xe6f795b2, 0xf738, 0x11d0, {0xa7, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0xb8, 0x3d } }

typedef struct _JAVA_TRUST {
    DWORD       cbSize;                   // Size of structure
    DWORD       flag;                     // Reserved
    BOOL        fAllActiveXPermissions;   // ActiveX explicitly asked for all (must have been signed)
    BOOL        fAllPermissions;          // Java permissions, explicit ask for all
    DWORD       dwEncodingType;           // Encoding type
    PBYTE       pbJavaPermissions;        // Encoded java permission blob
    DWORD       cbJavaPermissions;
    PBYTE       pbSigner;                 // Encoded signer.
    DWORD       cbSigner;
    LPCWSTR     pwszZone;                 // Zone index (copied from action data)
    GUID        guidZone;                 // Not used currently
    HRESULT     hVerify;                  // Authenticode policy return
} JAVA_TRUST, *PJAVA_TRUST;

typedef struct _JAVA_POLICY_PROVIDER {
    DWORD                 cbSize;                   // Size of policy provider
    LPVOID                pZoneManager;             // Zone interface manager
    LPCWSTR               pwszZone;                 // Zone index
    BOOL                  fNoBadUI;                 // Optional bad ui
    PJAVA_TRUST           pbJavaTrust;              // Returned java information (CoTaskMemAlloc)
    DWORD                 cbJavaTrust;              // Total allocated size of pJavaTrust
    DWORD                 dwActionID;               // Optional ActionID ID
    DWORD                 dwUnsignedActionID;       // Optional ActionID ID
    BOOL                  VMBased;                  // Called from VM (FALSE by DEFAULT)
} JAVA_POLICY_PROVIDER, *PJAVA_POLICY_PROVIDER;

#ifdef __cplusplus
}
#endif

#endif // !defined(JAVA_TRUST_PROVIDER)
#endif // _JTRUST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\autodiscoveryid.h ===
/**************************************************************************\
    FILE: AutoDiscoveryIDs.h
    DATE: BryanSt (1/19/2000)

    DESCRIPTION:
        AutoDiscovery API (Object Model).

    Copyright 1999-2000 Microsoft Corporation. All Rights Reserved.
\**************************************************************************/

#ifndef _AUTODISCOVERYID_H_

// define the ...
#define DISPID_NXOBJ_MIN                 0x00000000
#define DISPID_NXOBJ_MAX                 0x0000FFFF
#define DISPID_NXOBJ_BASE                DISPID_NXOBJ_MIN


//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------


// IAccountDiscovery Properties
// IAccountDiscovery Methods
#define DISPIDAD_DISCOVERNOW            (DISPID_NXOBJ_BASE + 51)
#define DISPIDAD_WORKASYNC              (DISPID_NXOBJ_BASE + 52)

// IMailAutoDiscovery Properties
#define DISPIDAD_DISPLAYNAME            (DISPID_NXOBJ_BASE + 100)
#define DISPIDAD_INFOURL                (DISPID_NXOBJ_BASE + 101)
#define DISPIDAD_XML                    (DISPID_NXOBJ_BASE + 102)
#define DISPIDAD_PREFEREDPROTOCOL       (DISPID_NXOBJ_BASE + 103)
#define DISPIDAD_LENGTH                 (DISPID_NXOBJ_BASE + 104)
#define DISPIDAD_ITEM                   (DISPID_NXOBJ_BASE + 105)
// IMailAutoDiscovery Methods
#define DISPIDAD_PURGE                  (DISPID_NXOBJ_BASE + 150)
#define DISPIDAD_DISCOVERMAIL           (DISPID_NXOBJ_BASE + 151)
#define DISPIDMAD_WORKASYNC             (DISPID_NXOBJ_BASE + 152)
#define DISPIDADMP_PRIMARYPROVIDERS     (DISPID_NXOBJ_BASE + 153)
#define DISPIDADMP_SECONDARYPROVIDERS   (DISPID_NXOBJ_BASE + 154)


// IMailProtocolADEntry Properties
#define DISPIDADMP_PROTOCOL             (DISPID_NXOBJ_BASE + 201)
#define DISPIDADMP_SERVERNAME           (DISPID_NXOBJ_BASE + 202)
#define DISPIDADMP_SERVERPORTNUM        (DISPID_NXOBJ_BASE + 203)
#define DISPIDADMP_LOGIN_NAME           (DISPID_NXOBJ_BASE + 204)
#define DISPIDADMP_POST_HTML            (DISPID_NXOBJ_BASE + 205)
#define DISPIDADMP_USE_SSL              (DISPID_NXOBJ_BASE + 206)
#define DISPIDADMP_ISAUTHREQ            (DISPID_NXOBJ_BASE + 207)
#define DISPIDADMP_USESPA               (DISPID_NXOBJ_BASE + 208)
#define DISPIDADMP_SMTPUSESPOP3AUTH     (DISPID_NXOBJ_BASE + 209)
// IMailProtocolADEntry Methods




#define SZ_DISPIDAD_DISCOVERNOW                     helpstring("Set the xml of this message")
#define SZ_DISPIDAD_WORKASYNC                       helpstring("Make DiscoverNow return right way before finished.  The specified message will be sent to the hwnd when it finishes.  The LPARAM will have the IXMLDOMDocument result.")

#define SZ_DISPIDAD_DISPLAYNAME                     helpstring("Get the display name for the account")
#define SZ_DISPIDAD_INFOURL                         helpstring("Get the URL that the server or service may provide that describes how to configure your e-mail or other information about getting email.")
#define SZ_DISPIDAD_GETXML                          helpstring("Get XML")
#define SZ_DISPIDAD_PUTXML                          helpstring("Put XML")
#define SZ_DISPIDAD_PREFEREDPROTOCOL                helpstring("Get the prefered protocol")
#define SZ_DISPIDAD_GETLENGTH                       helpstring("Put the number of supported protocols")
#define SZ_DISPIDAD_GETITEM                         helpstring("Get the protocol by index")
#define SZ_DISPIDAD_DISCOVERMAIL                    helpstring("Get the information for this email address.")
#define SZ_DISPIDAD_PURGE                           helpstring("Delete this from the cache so we hit the net the next time")

#define SZ_DISPIDAD_PROTOCOL                        helpstring("Get the protocol name")
#define SZ_DISPIDAD_SERVERNAME                      helpstring("Get the Server Name (pop.mail.yahoo.com)")
#define SZ_DISPIDAD_SERVERPORTNUM                   helpstring("Get the Server Port Number (default or 123)")
#define SZ_DISPIDAD_LOGIN_NAME                      helpstring("Get the login name for this account")
#define SZ_DISPIDAD_POST_HTML                       helpstring("Get the HTTP Post HTML")
#define SZ_DISPIDAD_USE_SSL                         helpstring("Does the Server support SSL?")
#define SZ_DISPIDAD_ISAUTHREQ                       helpstring("Is Authentication required when logging into the server?")
#define SZ_DISPIDAD_USESPA                          helpstring("Should SPA be used during authentication")
#define SZ_DISPIDAD_SMTPUSESPOP3AUTH                helpstring("If SMTP, does it use the auth settings from POP3?")
#define SZ_DISPIDAD_PRIMARYPROVIDERS                helpstring("What servers will be contacted that will have the full email address uploaded?")
#define SZ_DISPIDAD_SECONDARYPROVIDERS              helpstring("What servers will be contacted that will have the hostname of the email address uploaded?")

#define _AUTODISCOVERYID_H_
#endif // _AUTODISCOVERYID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dtbase.h ===
/*******************************************************************************
* DTBase.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseNTo1 implementation. It is
*   used as a base class to implement discrete transform objects that support
*   DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DTBase_h
#define DTBase_h

//--- Additional includes
#ifndef DXHelper_h
#include <DXHelper.h>
#endif

#ifndef DXTmpl_h
#include <DXTmpl.h>
#endif

#ifndef dxatlpb_h
#include <dxatlpb.h>
#endif

#ifndef _ASSERT
#include <crtdbg.h>
#endif

#ifndef DXTDbg_h
#include <DXTDbg.h>
#endif

//=== Constants ====================================================
#define DXBOF_INPUTS_MESHBUILDER    0x00000001
#define DXBOF_OUTPUT_MESHBUILDER    0x00000002
#define DXBOF_SAME_SIZE_INPUTS      0x00000004
#define DXBOF_CENTER_INPUTS         0x00000008

#define DXB_MAX_IMAGE_BANDS         4           // Maximum of 4 image bands

//=== Class, Enum, Struct and Union Declarations ===================
class CDXBaseNTo1;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXDataPtr
*
*/
class CDXDataPtr
{
    friend CDXBaseNTo1;
public:
    IUnknown           *m_pUnkOriginalObject;
    IUnknown           *m_pNativeInterface;
    IDXBaseObject      *m_pBaseObj;
    DWORD               m_dwLastDirtyGenId;
    DXSAMPLEFORMATENUM  m_SampleFormat;

    CDXDataPtr() : 
        m_pUnkOriginalObject(NULL),
        m_pNativeInterface(NULL), 
        m_pBaseObj(NULL),
        m_dwLastUpdGenId(0),
        m_dwLastDirtyGenId(0),
        m_SampleFormat(DXPF_NONSTANDARD)
        {};
    ~CDXDataPtr() { Release(); }
    void Release()
    {
        if (m_pNativeInterface)
        {
            m_pNativeInterface->Release();
            m_pNativeInterface = NULL;
        }
        if (m_pBaseObj)
        {
            m_pBaseObj->Release();
            m_pBaseObj = NULL;
        }
        if (m_pUnkOriginalObject)
        {
            m_pUnkOriginalObject->Release();
            m_pUnkOriginalObject = NULL;
        }
    }
    HRESULT Assign(BOOL bMeshBuilder, IUnknown * pObject, IDXSurfaceFactory *pSurfFact);
    bool IsDirty(void);
    DWORD GenerationId(void);
    ULONG ObjectSize(void);
private:    // This should only be called by base class
    DWORD           m_dwLastUpdGenId;
    bool UpdateGenerationId(void);
};

/*--- CDXTWorkInfoNTo1
*   This structure is used to hold the arguments needed by the
*   image processing function defined by the derived class
*/
class CDXTWorkInfoNTo1
{
public:
    CDXTWorkInfoNTo1()
    { pvThis = NULL; pUserInstData = NULL; hr = S_OK; }
    void *   pvThis;          // The owning class object (must be cast to the right type)
    CDXDBnds DoBnds;          // The portion of the output space to render
    CDXDBnds OutputBnds;      // The portion of the output SURFACE to render
    void*    pUserInstData;   // User field for instance data
    HRESULT  hr;              // Error return code from work procedure
};

/*** CDXBaseNTo1
*   This is a base class used for implementing 1 in 1 out discrete transforms.
*/
class ATL_NO_VTABLE CDXBaseNTo1 : 
    public CComObjectRootEx<CComMultiThreadModel>,
#if(_ATL_VER < 0x0300)
    public IObjectSafetyImpl<CDXBaseNTo1>,
#else
    public IObjectSafetyImpl<CDXBaseNTo1,INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
#endif
    public IDXTransform,
    public IDXSurfacePick,
    public IObjectWithSite
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CDXBaseNTo1)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY(IObjectWithSite)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
#else
        COM_INTERFACE_ENTRY(IObjectSafety)
#endif
        COM_INTERFACE_ENTRY_FUNC(IID_IDXSurfacePick, 0, QI2DPick)
    END_COM_MAP()

    //
    //  Only return the 2D pick inteface for surface to surface transforms
    //
    static HRESULT WINAPI QI2DPick(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw)
    {
        CDXBaseNTo1 * pThis = (CDXBaseNTo1 *)pv;
        if (pThis->m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER))
        {
            return S_FALSE; // Continue processing COM map
        }
        *ppv = (IDXSurfacePick *)pThis;
        ((IDXSurfacePick *)pThis)->AddRef();
        return S_OK;
    }

    CComPtr<IOleClientSite> m_cpOleClientSite;

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>            m_cpUnkSite;
    CComPtr<IDXTransformFactory> m_cpTransFact;   
    CComPtr<IDXSurfaceFactory>   m_cpSurfFact;
    CComPtr<IDXTaskManager>      m_cpTaskMgr;
    CComPtr<IDirectDraw>         m_cpDirectDraw;
    CComPtr<IDirect3DRM3>        m_cpDirect3DRM;
    DWORD        m_dwMiscFlags;
    HANDLE       m_aEvent[DXB_MAX_IMAGE_BANDS];
    ULONG        m_ulNumProcessors;
    DWORD        m_dwGenerationId;
    DWORD        m_dwCleanGenId;
    BOOL         m_bPickDoneByBase;
    float        m_Duration;
    float        m_StepResolution;
    float        m_fQuality;        // Set DXTMF_QUALITY_SUPPORTED in m_dwMiscFlags if you use this property.    
    ULONG        m_ulNumInputs;
    DWORD        m_dwBltFlags;      // Ser prior to OnSetup and any Execute for classes with surface outputs
    BOOL         m_bInMultiThreadWorkProc;  // Base class sets to TRUE when scheduling tasks on multiple threads

    //
    //  Derived classes should set these values in their constructor or in FinalConstruct()
    //
    DWORD        m_dwOptionFlags;
    ULONG        m_ulLockTimeOut;     // The amount of time used for blocking
    ULONG        m_ulMaxInputs;
    ULONG        m_ulNumInRequired;
    ULONG        m_ulMaxImageBands;   // Only used for surface->Surface transforms
    float        m_Progress;

private:
    CDXDataPtr* m_aInputs;
    CDXDataPtr  m_Output;

    // m_fIsSetup   This is true when the DXTransform has been properly set up.

    unsigned    m_fIsSetup : 1;

  /*=== Methods =======*/
  public:
    //--- Constructors
    CDXBaseNTo1();
    ~CDXBaseNTo1();

    //--- Support virtuals for derived classes
    virtual HRESULT OnInitInstData( CDXTWorkInfoNTo1& /*WorkInfo*/, ULONG& /*ulNumBandsToDo*/) { return S_OK; }
    virtual HRESULT OnFreeInstData( CDXTWorkInfoNTo1& /*WorkInfo*/ ) { return S_OK; }
    virtual HRESULT OnSetup( DWORD /* dwFlags */) { return S_OK; }    // Override to be notified of a new non-null setup
    virtual void OnReleaseObjects() {}  // Override to be notified of NULL setup
    virtual HRESULT OnExecute(const GUID* /* pRequestID */, const DXBNDS * /*pClipBnds */,
                              const DXVEC * /*pPlacement */ ) { return E_FAIL; }
    virtual void OnUpdateGenerationId(void);
    virtual ULONG OnGetObjectSize(void);
    virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WorkInfo, BOOL* pbContinueProcessing) { return E_FAIL; }   // Override to do work
    virtual HRESULT DetermineBnds(CDXCBnds & Bnds) { return S_OK; } // Override for mesh output transforms
    virtual HRESULT DetermineBnds(CDXDBnds & Bnds) { return S_OK; } // Override for surface output transforms
    //
    //  Only override this function if you need to do a customized point pick implementation.  Otherwise simply
    //  override GetPointPickOrder() and return appropriate information.
    //
    virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec) { return E_NOTIMPL; }
    virtual void OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, ULONG aInIndex[], BYTE aWeight[])
    {
        m_bPickDoneByBase = true;
        ulInToTest  = 1;
        aInIndex[0] = 0;
        aWeight[0]  = 255;
    }

    //--- Private helpers
 private:
    static DXTASKPROC _TaskProc;
    void _ReleaseReferences();
    void _ReleaseServices();
    void _UpdateBltFlags(void);
    HRESULT _MakeInputsSameSize(void);
    HRESULT _ImageMapIn2Out(CDXDBnds & bnds, ULONG ulNumBnds, const CDXDBnds * pInBounds);
    HRESULT _MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds);


    //
    //--- Public helpers
    //
 public:
    float GetEffectProgress(void) { return m_Progress; }
    ULONG GetNumInputs(void) { return m_ulNumInputs; }

    //
    //  Use these inline functions to access input and output objects
    //
    BOOL HaveInput(ULONG i = 0) { return (m_ulNumInputs > i && m_aInputs[i].m_pNativeInterface); }

    IDirect3DRMMeshBuilder3 * OutputMeshBuilder()
    {
        _ASSERT(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_Output.m_pNativeInterface;
    }

    IDXSurface * OutputSurface()
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return (IDXSurface *)m_Output.m_pNativeInterface;
    }

    IDirect3DRMMeshBuilder3 * InputMeshBuilder(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_aInputs[i].m_pNativeInterface;
    }

    IDXSurface * InputSurface(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return (IDXSurface *)m_aInputs[i].m_pNativeInterface;
    }

    DXSAMPLEFORMATENUM OutputSampleFormat(void)
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return m_Output.m_SampleFormat;
    }

    DXSAMPLEFORMATENUM InputSampleFormat(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return m_aInputs[i].m_SampleFormat;
    }

    BOOL HaveOutput(void) { return m_Output.m_pNativeInterface != NULL; }

    bool IsInputDirty(ULONG i = 0)
    {   
        _ASSERT(i < m_ulNumInputs);
        return m_aInputs[i].IsDirty();
    }

    bool IsOutputDirty()
    {   
        _ASSERT(HaveOutput());
        return m_Output.IsDirty();
    }

    //--- Public helpers.  Should be called with critical seciton claimed.
    inline BOOL DoOver(void) const
    { 
        return m_dwBltFlags & DXBOF_DO_OVER;
    }

    inline BOOL DoDither(void) const
    {
        return m_dwBltFlags & DXBOF_DITHER;
    }

    BOOL NeedSrcPMBuff(ULONG i = 0)
    {
        return ((m_dwBltFlags & DXBOF_DITHER) || InputSampleFormat(i) != DXPF_PMARGB32);
    }

    BOOL NeedDestPMBuff(void)
    {
        return OutputSampleFormat() != DXPF_PMARGB32;
    }

    void SetDirty() { m_dwGenerationId++; }
    void ClearDirty() { OnUpdateGenerationId(); m_dwCleanGenId = m_dwGenerationId; }
    BOOL IsTransformDirty() { OnUpdateGenerationId(); return m_dwCleanGenId != m_dwGenerationId; }

    
  public:
    //=== IObjectWithSite =======================================
    STDMETHOD( SetSite )( IUnknown *pUnkSite );
    STDMETHOD( GetSite )( REFIID riid, void ** ppvSite );

    //=== IDXBaseObject =========================================
    STDMETHOD( GetGenerationId ) (ULONG * pGenId);
    STDMETHOD( IncrementGenerationId) (BOOL bRefresh);
    STDMETHOD( GetObjectSize ) (ULONG * pcbSize); 

  
      //=== IDXTransform ===============================================
    STDMETHOD( Setup )( IUnknown * const * punkInputs, ULONG ulNumIn,
                        IUnknown * const * punkOutputs, ULONG ulNumOut, DWORD dwFlags );
    STDMETHOD( Execute )( const GUID* pRequestID,
                          const DXBNDS *pOutBounds, const DXVEC *pPlacement );
    STDMETHOD( MapBoundsIn2Out )( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                  ULONG ulOutIndex, DXBNDS *pOutBounds );
    STDMETHOD( MapBoundsOut2In )( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds );
    STDMETHOD( SetMiscFlags ) ( DWORD dwOptionFlags );
    STDMETHOD( GetMiscFlags ) ( DWORD * pdwMiscFlags );
    STDMETHOD( GetInOutInfo )( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj);
    STDMETHOD( SetQuality )( float fQuality );
    STDMETHOD( GetQuality )( float *pfQuality );

    STDMETHOD (PointPick) (const DXVEC *pPoint,
                           ULONG * pulInputSurfaceIndex,
                           DXVEC *pInputPoint);

    //
    //  Effect interface
    //
    //  NOTE:  Derived classes MUST implement get_Capabilities.  Use macros below.
    //
    STDMETHODIMP get_Capabilities(long *pVal) { _ASSERT(true); return E_NOTIMPL; }
    //
    //  All other methods are implemented in the base.
    //
    STDMETHODIMP get_Progress(float *pVal);
    STDMETHODIMP put_Progress(float newVal);
    STDMETHODIMP get_StepResolution(float *pVal);
    STDMETHODIMP get_Duration(float *pVal);
    STDMETHODIMP put_Duration(float newVal);

    //
    //  Helper functions derived classes can use
    //

    //
    //  Static function for registering in one or more component categories
    //
    static HRESULT RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                     ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);

};

//=== Inline Function Definitions ==================================

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_TRANSFORM(id, catid)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 1, &(catid), 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_TRANS_CATS(id, countimpl, pcatidsimpl, countreq, pcatidsreq)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), (count), (pcatids), (countreq), (pcatidsreq), bRegister); \
        } 

#define DECLARE_REGISTER_DX_IMAGE_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DXImageTransform)

#define DECLARE_REGISTER_DX_3D_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DX3DTransform)

#define DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DXImageTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_3D_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DX3DTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

//
//  Effect interface
//
#define DECLARE_GET_CAPABILITIES(Caps)\
STDMETHODIMP get_Capabilities(long *pVal) { if (DXIsBadWritePtr(pVal, sizeof(*pVal))) return E_POINTER; *pVal = Caps; return S_OK; }

#define DECLARE_GET_PROGRESS()\
        STDMETHODIMP get_Progress(float *pVal) { return CDXBaseNTo1::get_Progress(pVal); }

#define DECLARE_PUT_PROGRESS()\
        STDMETHODIMP put_Progress(float newVal) { return CDXBaseNTo1::put_Progress(newVal); }

#define DECLARE_GET_STEPRESOLUTION()\
        STDMETHODIMP get_StepResolution(float *pVal) { return CDXBaseNTo1::get_StepResolution(pVal); }
        
#define DECLARE_GET_DURATION()\
        STDMETHODIMP get_Duration(float *pVal) { return CDXBaseNTo1::get_Duration(pVal); }

#define DECLARE_PUT_DURATION()\
        STDMETHODIMP put_Duration(float newVal) { return CDXBaseNTo1::put_Duration(newVal); }
        
#define DECLARE_IDXEFFECT_METHODS(Caps)\
        DECLARE_GET_CAPABILITIES(Caps)\
        DECLARE_GET_PROGRESS()\
        DECLARE_PUT_PROGRESS()\
        DECLARE_GET_STEPRESOLUTION()\
        DECLARE_GET_DURATION()\
        DECLARE_PUT_DURATION()

//=== Global Data Declarations =====================================

//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dtbase.cpp ===
/*******************************************************************************
* DTBase.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseNTo1 transform
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/28/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DTBase.h"
#include "new.h"

//--- Initialize static member of debug scope class
#ifdef _DEBUG
CDXTDbgFlags CDXTDbgScope::m_DebugFlags;
#endif

//--- This should only be used locally in this file. We duplicated this GUID
//    value to avoid having to include DDraw.
static const IID IID_IDXDupDirectDraw =
    { 0x6C14DB80,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDDrawSurface =
    { 0x6C14DB81,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDirect3DRM =
    {0x2bc49361, 0x8327, 0x11cf, {0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1 } };

static const IID IID_IDXDupDirect3DRM3 =
    {0x4516ec83, 0x8f20, 0x11d0, {0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3 } };

static const IID IID_IDXDupDirect3DRMMeshBuilder3 =
    { 0x4516ec82, 0x8f20, 0x11d0, { 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3} };

HRESULT CDXDataPtr::Assign(BOOL bMesh, IUnknown * pObject, IDXSurfaceFactory *pSurfaceFactory)
{
    HRESULT hr = S_OK;
    if (pObject)
    {
        IUnknown *pNative = NULL;
        if (!bMesh)
        {
            //--- Try to get a DX surface
            hr = pObject->QueryInterface( IID_IDXSurface, (void **)&pNative );
            if( FAILED( hr ) )
            {
                IDirectDrawSurface *pSurf;
                //--- Try to get a DDraw surface
                hr = pObject->QueryInterface( IID_IDXDupDDrawSurface, (void **)&pSurf );
                if( SUCCEEDED( hr ) )
                {
                    //--- Create a DXSurface from the DDraw surface
                    hr = pSurfaceFactory->CreateFromDDSurface(
                                pSurf, NULL, 0, NULL, IID_IDXSurface,
                                (void **)&pNative );
                    pSurf->Release();
                }
            }
        }
        else // Must be a mesh builder
        {
            hr = pObject->QueryInterface(IID_IDXDupDirect3DRMMeshBuilder3, (void **)&pNative);
        }
        if (SUCCEEDED(hr))
        {
            Release();
            m_pNativeInterface = pNative;
            pObject->AddRef();
            m_pUnkOriginalObject = pObject;
            if (SUCCEEDED(pNative->QueryInterface(IID_IDXBaseObject, (void **)&m_pBaseObj)))
            {
                m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
                m_dwLastDirtyGenId--;
            }
            if (!bMesh)
            {   
                ((IDXSurface *)pNative)->GetPixelFormat(NULL, &m_SampleFormat);
            }
        }
        else
        {
            if (hr == E_NOINTERFACE)
            {
                hr = E_INVALIDARG;
            }
        }
    }
    else 
    {
        Release();
    }
    return hr;
} /* CDXDataPtr::Assign */

bool CDXDataPtr::IsDirty(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastDirtyGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
        return dwOldId != m_dwLastDirtyGenId;
    }
    else
    {
        return false;
    }

}

DWORD CDXDataPtr::GenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwGenId;
        m_pBaseObj->GetGenerationId(&dwGenId);
        return dwGenId;
    }
    else
    {
        return 0;
    }
}


bool CDXDataPtr::UpdateGenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastUpdGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastUpdGenId);
        return dwOldId != m_dwLastUpdGenId;
    }
    else
    {
        return false;
    }
} /* CDXDataPtr::UpdateGenerationId */

ULONG CDXDataPtr::ObjectSize(void)
{
    ULONG ulSize = 0;
    if (m_pBaseObj)
    {
        m_pBaseObj->GetObjectSize(&ulSize);
    }
    return ulSize;    
}

/*****************************************************************************
* CDXBaseNTo1::CDXBaseNTo1 *
*--------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::CDXBaseNTo1() :
    m_aInputs(NULL),
    m_ulNumInputs(0),
    m_ulNumProcessors(1),   // Default to one until task manager is set
    m_dwGenerationId(1),
    m_dwCleanGenId(0),
    m_Duration(1.0f),
    m_StepResolution(0.0f),
    m_Progress(0.0f),
    m_dwBltFlags(0),
    m_bPickDoneByBase(false),
    m_bInMultiThreadWorkProc(FALSE),
    m_fQuality(0.5f),   // Default to normal quality.
    //  Wait forever before timing out on a lock by default
    m_ulLockTimeOut(INFINITE),
    //
    //  Override these flags if your object does not support one or more of these options.
    //  Typically, 3-D effects should set this member to 0.
    //
    m_dwMiscFlags(DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT |
                  DXTMF_BLEND_SUPPORTED | DXTMF_DITHER_SUPPORTED | DXTMF_BOUNDS_SUPPORTED | DXTMF_PLACEMENT_SUPPORTED),
    //
    //  If your object has a different number of objects or a different number of
    //  required objects than 1, simply set these members in the body of your
    //  constructor or in FinalConstruct().  For every input that is > the number
    //  required, that input will be reported as optional.
    //
    //  If your transform takes 2 required inputs, set both to 2.
    //  If your transform takes 2 optional inputs, set MaxInputs = 2, NumInRequired = 0
    //  If your transform takes 1 required and 2 optional inputs,
    //      set MaxInputs = 2, NumInRequired = 1
    //
    //  For more complex combinations of optinal/required, you will need to override
    //  the OnSetup method of this base class, and override the methods
    //      GetInOutInfo
    //
    m_ulMaxInputs(1),
    m_ulNumInRequired(1),
    //
    //  If the intputs or output types are not surfaces then set appropriate object type
    //
    m_dwOptionFlags(0),     // Inputs and output are surfaces, don't have to be the same size
    m_ulMaxImageBands(DXB_MAX_IMAGE_BANDS),
    m_fIsSetup(false)
{
    DXTDBG_FUNC( "CDXBaseNTo1::CDXBaseNTo1" );
    //
    //  Set event handles to NULL.
    //
    memset(m_aEvent, 0, sizeof(m_aEvent));
} /* CDXBaseNTo1::CDXBaseNTo1 */

/*****************************************************************************
* CDXBaseNTo1::~CDXBaseNTo1 *
*---------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::~CDXBaseNTo1()
{
    DXTDBG_FUNC( "CDXBaseNTo1::~CDXBaseNTo1" );
    _ReleaseReferences();
    delete[] m_aInputs;

    //--- Release event objects
    for(ULONG i = 0; i < DXB_MAX_IMAGE_BANDS; ++i )
    {
        if( m_aEvent[i] ) ::CloseHandle( m_aEvent[i] );
    }
} /* CDXBaseNTo1::~CDXBaseNTo1 */


/*****************************************************************************
* CDXBaseNTo1::_ReleaseRefernces *
*--------------------------------*
*   Description:
*       Releases all references to input and output objects
*-----------------------------------------------------------------------------
*   Created By: RAL
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::_ReleaseReferences()
{
    //--- Release data objects
    if( m_aInputs )
    {
        for( ULONG i = 0; i < m_ulNumInputs; ++i )
        {
            m_aInputs[i].Release();
        }
    }

    m_Output.Release();

    m_fIsSetup = false;
} /* CDXBaseNTo1::_ReleaseRefernces */



STDMETHODIMP CDXBaseNTo1::GetGenerationId(ULONG *pGenerationId)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetGenerationId" );
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseNTo1::IncrementGenerationId(BOOL bRefresh)
{
    DXTDBG_FUNC( "CDXBaseNTo1::IncrementGenerationId" );
    HRESULT hr = S_OK;
    Lock();
    m_dwGenerationId++;
    if (bRefresh)
    {
        //
        //  If we have any inputs or outputs, call Setup again to refresh all internal
        //  knowledge about the surfaces (formats, height or width could change, etc.)
        //
        //  Note that we need to AddRef the objects prior to calling Setup becuase the
        //  DXTransform may be the only object holding a referec
        //
        ULONG cInputs = m_ulNumInputs;
        ULONG cOutputs = 0;
        IUnknown *pOutput = m_Output.m_pUnkOriginalObject;
        if (pOutput)
        {
            cOutputs = 1;
            pOutput->AddRef();
        }
        IUnknown ** ppInputs = NULL;
        if (cInputs)
        {
            ppInputs = (IUnknown **)_alloca(m_ulNumInputs * sizeof(IUnknown *));
            for (ULONG i = 0; i < cInputs; i++)
            {
                ppInputs[i] = m_aInputs[i].m_pUnkOriginalObject;
                if (ppInputs[i]) ppInputs[i]->AddRef();
            }
        }
        if (cInputs || cOutputs)    // If we're not setup, skip this step.
        {
            hr = Setup(ppInputs, cInputs, &pOutput, cOutputs, 0);
            if (pOutput) pOutput->Release();
            for (ULONG i = 0; i < cInputs; i++)
            {
                if (ppInputs[i]) ppInputs[i]->Release();
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetObjectSize(ULONG *pcbSize)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetObjectSize" );
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}


void CDXBaseNTo1::_ReleaseServices(void)
{
    m_cpTransFact.Release();
    m_cpSurfFact.Release();
    m_cpTaskMgr.Release();
    m_cpDirectDraw.Release();
    m_cpDirect3DRM.Release();
}

//
//  The documentation for SetSite indicates that it is invaid to return
//  an error from this function, even if the site does not support the
//  functionality we want.  So, even if there is no service provider, or
//  the required services are not available, we will return S_OK.
//
STDMETHODIMP CDXBaseNTo1::SetSite(IUnknown * pUnkSite)
{
    DXTDBG_FUNC( "CDXBaseNTo1::SetSite" );
    HRESULT hr = S_OK;
    Lock();
    m_cpUnkSite = pUnkSite;
    _ReleaseServices();
    if (pUnkSite)
    {
        if (DXIsBadInterfacePtr(pUnkSite))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            HRESULT hr2;
            hr2 = pUnkSite->QueryInterface(IID_IDXTransformFactory, (void **)&m_cpTransFact);
	    if (SUCCEEDED(hr2))
	    {
                //
                //  Allocate memory for inputs if necessary
                //
                if (m_aInputs == NULL && m_ulMaxInputs)
                {
                    m_aInputs  = new CDXDataPtr[m_ulMaxInputs];
                    if (!m_aInputs)
                    {
                        _ASSERT(TRUE);
                        hr2 = E_OUTOFMEMORY;
                    }
                }
                hr2 = m_cpTransFact->QueryService( SID_SDXSurfaceFactory, IID_IDXSurfaceFactory, (void **)&m_cpSurfFact);
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService( SID_SDXTaskManager, IID_IDXTaskManager, (void **)&m_cpTaskMgr);
                }
                if (SUCCEEDED(hr2))
                {
                    m_cpTaskMgr->QueryNumProcessors(&m_ulNumProcessors);
                    if (m_ulMaxImageBands && (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)) == 0)
                    {
                        for (ULONG i = 0; SUCCEEDED(hr2) && i < m_ulMaxImageBands; i++)
                        {
                            //
                            // In theory we could get back here after failing to create an event, or
                            // by getting a new site, so make sure it's non-null before creating one.
                            //
                            if (m_aEvent[i] == NULL)
                            {
                                m_aEvent[i] = ::CreateEvent(NULL, true, false, NULL);
                                if (m_aEvent[i] == NULL)
                                {
                                    hr2 = E_OUTOFMEMORY;
                                }
                            }

                        }
                    }
                }
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService(SID_SDirectDraw, IID_IDXDupDirectDraw, (void**)&m_cpDirectDraw);
                }
                if (SUCCEEDED(hr2) && 
                    (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
                {
                    hr2 = m_cpTransFact->QueryService(SID_SDirect3DRM, IID_IDXDupDirect3DRM3, (void **)&m_cpDirect3DRM);
                }
                if (FAILED(hr2))
                {
                    _ASSERT(TRUE);
                    _ReleaseServices();
                }
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetSite(REFIID riid, void **ppv)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetSite" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(ppv, sizeof(*ppv)) )
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        if (m_cpUnkSite)
        {
            hr = m_cpUnkSite->QueryInterface(riid, ppv);
        }
        else
        {
            *ppv = NULL;
            hr = E_FAIL;    // This is the proper documented return code
                            // for this interface if no service provider.
        }
        Unlock();
    }
    return hr;
} 


void CDXBaseNTo1::_UpdateBltFlags(void)
{
    m_dwBltFlags = 0;
    if ((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0)
    {
        if (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT) 
        {
            if ((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) || m_ulNumInputs == 0)
            {
                m_dwBltFlags |= DXBOF_DO_OVER;
            }
            else
            {
                for(ULONG i = 0; i < m_ulNumInputs; ++i )
                {
                    if (InputSampleFormat(i) & DXPF_TRANSPARENCY)
                    {
                        m_dwBltFlags |= DXBOF_DO_OVER;
                        break;
                    }
                }
            }
        }
        //
        //  Set the dither flag to true only if output error is > at least one input
        //
        if (m_dwMiscFlags & DXTMF_DITHER_OUTPUT)
        {
            ULONG OutputErr = (OutputSampleFormat() & DXPF_ERRORMASK);
            if (OutputErr)
            {
                if (m_ulNumInputs)
                {
                    for(ULONG i = 0; i < m_ulNumInputs; ++i )
                    {
                        if (InputSurface(i) && (ULONG)(InputSampleFormat(i) & DXPF_ERRORMASK) < OutputErr)
                        {
                            m_dwBltFlags |= DXBOF_DITHER;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    // If output has no error then don't set dither in blt flags
                    //  
                    if (OutputErr)
                    {
                        m_dwBltFlags |= DXBOF_DITHER; 
                    }
                }
            }
        }
    }
}



/*****************************************************************************
* CDXBaseNTo1::Setup *
*--------------------*
*   Description:
*       The Setup method is used to perform any required one-time setup
*   before the Execute method is called. Single surfaces or SurfaceSets may
*   be used as arguments in any combination. 
*   If punkOutputs is NULL, Execute will allocate an output result of the
*   appropriate size and return it.
*   if punkInputs and punkOutputs are NULL and it is a quick setup, the current
*   input and output objects are released.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::Setup( IUnknown * const * punkInputs, ULONG ulNumInputs,
                                 IUnknown * const * punkOutputs, ULONG ulNumOutputs, DWORD dwFlags )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Setup" );
    //--- Lock object so state cannot change during setup
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    ULONG i;

    //
    //  Early out for null setup.  Forget about all other param validation, just do it.
    //  
    if (ulNumInputs == 0 && ulNumOutputs == 0)
    {
        _ReleaseReferences();
        OnReleaseObjects();
        return hr;
    }

    //--- Validate Params
    //--- Make sure we have a reference to the transform factory
    if( !m_cpTransFact )
    {
        hr = DXTERR_UNINITIALIZED;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
    }
    else
    {
        //
        //  We know that if we have a transform factory that we must also have
        //  allocated m_aInputs since this is done on SetSite to avoid work during
        //  each setup.
        //
        _ASSERT(m_aInputs || m_ulMaxInputs == 0);
        if( dwFlags ||              // No flags are valid
            ulNumOutputs != 1 ||
            ulNumInputs < m_ulNumInRequired ||
            ulNumInputs > m_ulMaxInputs ||
            (ulNumInputs && DXIsBadReadPtr( punkInputs , sizeof( *punkInputs ) * ulNumInputs )) ||
            DXIsBadReadPtr(punkOutputs, sizeof(*punkOutputs)) ||
            DXIsBadInterfacePtr(punkOutputs[0]))
        {
            hr = E_INVALIDARG;
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
        }
        else
        {
            for( i = 0; i < ulNumInputs; ++i )
            {
                if((punkInputs[i] && DXIsBadInterfacePtr(punkInputs[i])) ||
                    (punkInputs[i] == NULL && i < m_ulNumInRequired))
                {
                    hr = E_INVALIDARG;
                    DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
                    break;
                }
            }        
        }
    }

    //--- Allocate slots for input data object pointers
    if( SUCCEEDED( hr ) )
    {
        //--- Release data objects
        _ReleaseReferences();
        m_ulNumInputs = ulNumInputs;
    }

    //
    //  Assign 
    //
    for( i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
    {
        hr = m_aInputs[i].Assign((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER), punkInputs[i], m_cpSurfFact);
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_Output.Assign((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER), punkOutputs[0], m_cpSurfFact);
    }   

    if (SUCCEEDED(hr) && (m_dwOptionFlags & DXBOF_SAME_SIZE_INPUTS))
    {
        hr = _MakeInputsSameSize();
    }

    if (SUCCEEDED(hr))
    {
        _UpdateBltFlags();      // Do this before calling OnSetup...
        hr = OnSetup(dwFlags);
    }
    
    if (FAILED(hr))
    {
        _ReleaseReferences();
        OnReleaseObjects();
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup failed" );
    }
    else
    {
        m_fIsSetup = true;
    }

    return hr;
} /* CDXBaseNTo1::Setup */


/*****************************************************************************
* CDXBaseNTo1::_MakeInputsSameSize *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 03/31/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

HRESULT CDXBaseNTo1::_MakeInputsSameSize(void)
{
    _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);

    HRESULT hr = S_OK;
    if (m_ulNumInputs > 1)      // No need to do this for just one input!
    {
        CDXDBnds SurfBnds(false);
        CDXDBnds Union(true);
        ULONG i;
        for (i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                Union |= SurfBnds;
            }
        }
        for (i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                if (SUCCEEDED(hr) && SurfBnds != Union)
                {
                    IDXSurfaceModifier *pSurfMod;
                    hr = ::CoCreateInstance(CLSID_DXSurfaceModifier, NULL, CLSCTX_INPROC,
                                            IID_IDXSurfaceModifier, (void **)&pSurfMod);
                    if (SUCCEEDED(hr))
                    {
                        POINT p;
                        p.x = p.y = 0;
                        if (m_dwOptionFlags & DXBOF_CENTER_INPUTS)
                        {
                            p.x = (Union.Width() - SurfBnds.Width()) / 2;
                            p.y = (Union.Height() - SurfBnds.Height()) / 2;
                        }
                        pSurfMod->SetForeground(InputSurface(i), FALSE, &p);
                        pSurfMod->SetBounds(&Union);
                        InputSurface(i)->Release();
                        pSurfMod->QueryInterface(IID_IDXSurface, (void **)&(m_aInputs[i].m_pNativeInterface));
                        ((IDXSurface *)m_aInputs[i].m_pNativeInterface)->GetPixelFormat(NULL, &m_aInputs[i].m_SampleFormat);
                        pSurfMod->Release();
                    }
                }
            }
        }
    }
    return hr;
}


/*****************************************************************************
* CDXBaseNTo1::Execute *
*----------------------*
*   Description:
*       The Execute method is used to walk the inputs/outputs and break up the
*   work into suitably sized pieces to spread symetrically accross the available
*   processors in the system.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    Execute( const GUID* pRequestID, const DXBNDS *pClipBnds, const DXVEC *pPlacement )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Execute" );
    //--- Lock object so state cannot change during execution
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;

    //--- Check args
    if( !HaveOutput() )
    {
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
        return DXTERR_UNINITIALIZED;
    }

    if (m_ulMaxImageBands == 0 ||
        (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
    {
        if ((pClipBnds && (m_dwMiscFlags & DXTMF_BOUNDS_SUPPORTED) == 0) ||
            (pPlacement && (m_dwMiscFlags & DXTMF_PLACEMENT_SUPPORTED) == 0) )
        {
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
            return E_INVALIDARG;
        }
        return OnExecute( pRequestID, pClipBnds, pPlacement );
    }

    //--- Banded image working variables
    CDXTWorkInfoNTo1 WI;

    if ((pClipBnds && pClipBnds->eType != DXBT_DISCRETE) ||
        (pPlacement && pPlacement->eType != DXBT_DISCRETE))
    {
        hr = E_INVALIDARG;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
    }
    else
    {
        hr = MapBoundsIn2Out( NULL, 0, 0, &WI.DoBnds );
        if( hr == S_OK )
        {
            hr = WI.OutputBnds.SetToSurfaceBounds(OutputSurface());
            if (hr == S_OK)
            {
                hr = DXClipToOutputWithPlacement(WI.DoBnds, (CDXDBnds *)pClipBnds, WI.OutputBnds, (CDXDVec *)pPlacement);
            }
        }
    }

    //--- Check for clipping early exit
    if( hr != S_OK )
    {
        return hr;
    }

    //=== Process ====================================================
    _ASSERT(m_ulMaxImageBands <= DXB_MAX_IMAGE_BANDS);
    ULONG ulNumBandsToDo = m_ulNumProcessors;
    if( ulNumBandsToDo > 1 )
    {
        ulNumBandsToDo = 1 + ((WI.OutputBnds.Width() * WI.OutputBnds.Height()) / 0x1000);
        if (ulNumBandsToDo > m_ulMaxImageBands)
        {
            ulNumBandsToDo = m_ulMaxImageBands;
        }
        if (ulNumBandsToDo > m_ulNumProcessors)
        {
            ulNumBandsToDo = m_ulNumProcessors;
        }
    }
    hr = OnInitInstData(WI, ulNumBandsToDo);
    if( SUCCEEDED( hr ) )
    {
        if (ulNumBandsToDo == 1 && pRequestID == NULL)
        {
            static BOOL bContinue = TRUE;
            hr = WorkProc(WI, &bContinue);
        }
        else
        {
            _ASSERT( ulNumBandsToDo <= DXB_MAX_IMAGE_BANDS );
            _ASSERT( m_aEvent[ulNumBandsToDo-1] );

            long lStartAtRow = WI.DoBnds[DXB_Y].Min;
            ULONG ulRowCount = WI.DoBnds[DXB_Y].Max - lStartAtRow;
            _ASSERT( ( ulRowCount / ulNumBandsToDo ) != 0 );

            //--- Init the work info structures
            ULONG ulBand, RowsPerBand = ulRowCount / ulNumBandsToDo;
            CDXTWorkInfoNTo1 *WIArray = (CDXTWorkInfoNTo1*)alloca( sizeof(CDXTWorkInfoNTo1) *
                                                         ulNumBandsToDo );
            DWORD *TaskIDs = (DWORD*)alloca( sizeof(DWORD) * ulNumBandsToDo );
            DXTMTASKINFO* TaskInfo = (DXTMTASKINFO*)alloca( sizeof( DXTMTASKINFO ) *
                                                            ulNumBandsToDo );

            //--- Build task info list
            WI.hr       = S_OK;
            WI.pvThis   =  this;
            long Start  = lStartAtRow;
            ULONG Count = RowsPerBand;
            long OutputYDelta = WI.OutputBnds[DXB_Y].Min - WI.DoBnds[DXB_Y].Min;

            for (ulBand = 0; ulBand < ulNumBandsToDo; ++ulBand)
            {
                memcpy(&WIArray[ulBand], &WI, sizeof(WI));

                WIArray[ulBand].DoBnds[DXB_Y].Min       = Start;
                WIArray[ulBand].OutputBnds[DXB_Y].Min   = Start + OutputYDelta;

                // If this is the last band, make sure it includes the last row.

                if (ulBand == ulNumBandsToDo - 1)
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = WI.DoBnds[DXB_Y].Max;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = WI.OutputBnds[DXB_Y].Max;
                }
                else // Not the last band.
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = Start + Count;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = Start + Count 
                                                              + OutputYDelta;
                }

                TaskInfo[ulBand].pfnTaskProc      = _TaskProc;
                TaskInfo[ulBand].pTaskData        = &WIArray[ulBand];
                TaskInfo[ulBand].pfnCompletionAPC = NULL;
                TaskInfo[ulBand].dwCompletionData = 0;
                TaskInfo[ulBand].pRequestID       = pRequestID;

                // Advance.

                Start += Count;
            }

            //
            //  Procedural surfaces (and perhaps some transforms) need to "know" that
            //  they are in a multi-threaded work procedure to avoid deadlocks.  Procedural
            //  surfaces need to allow LockSurface to work WITHOUT taking the object
            //  critical section.  Other transforms may also want to know this information
            //  to avoid deadlocks.
            //
            m_bInMultiThreadWorkProc = TRUE;

            //--- Schedule the work and wait for it to complete
            hr = m_cpTaskMgr->ScheduleTasks( TaskInfo, m_aEvent,
                                             TaskIDs, ulNumBandsToDo, m_ulLockTimeOut );

            m_bInMultiThreadWorkProc = FALSE;

            //--- Check return codes from work info structures
            //    return the first bad hr if any
            for( ulBand = 0; SUCCEEDED( hr ) && ( ulBand < ulNumBandsToDo ); ++ulBand )
            {
                hr = WIArray[ulBand].hr;
                if( hr != S_OK ) break;
            }
        }
        OnFreeInstData( WI );
    }

#ifdef _DEBUG
    if( FAILED( hr ) ) DXTDBG_MSG1( _CRT_ERROR, "\nExecute failed. HR = %X", hr );
#endif

    return hr;
} /* CDXBaseNTo1::Execute */

/*****************************************************************************
* CDXBaseNTo1::_ImageMapIn2Out *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_ImageMapIn2Out( CDXDBnds & bnds, ULONG ulNumInBnds,
                                      const CDXDBnds * pInBounds )
{
    HRESULT hr = S_OK;
    if(ulNumInBnds)
    {
        for(ULONG i = 0; i < ulNumInBnds; ++i )
        {
            bnds |= pInBounds[i];
        }
    }
    else
    {
        for( ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
        {
            if (InputSurface(i))
            {
                CDXDBnds SurfBnds(InputSurface(i), hr);
                bnds |= SurfBnds;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = DetermineBnds(bnds);
    }
    return hr;
} /* CDXBaseNTo1::_ImageMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::_MeshMapIn2Out *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds)
{
    HRESULT hr = S_OK;
    if (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER)
    {
        if(ulNumInBnds)
        {
            for(ULONG i = 0; i < ulNumInBnds; ++i )
            {
                bnds |= pInBounds[i];
            }
        }
        else
        {
            for(ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
            {
                if (InputMeshBuilder(i))
                {
                    CDXCBnds MeshBnds(InputMeshBuilder(i), hr);
                    bnds |= MeshBnds;
                }
            }

        }
    }
    else
    {
        //  Already done -> bnds[DXB_T].Min = 0.0f;
        bnds[DXB_X].Min = bnds[DXB_Y].Min = bnds[DXB_Z].Min = -1.0f;
        bnds[DXB_X].Max = bnds[DXB_Y].Max = bnds[DXB_Z].Max = bnds[DXB_T].Max = 1.0f;
    }

    //
    //  Call the derived class to get the scale values.
    //
    if (SUCCEEDED(hr))
    {
	// Increase the size just a bit so we won't have rounding errors
	// result in bounds that don't actually contain the result.
	const float fBndsIncrease = 0.0001F;
	float fTemp = bnds.Width() * fBndsIncrease;

	bnds[DXB_X].Min -= fTemp;
	bnds[DXB_X].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Height();
	bnds[DXB_Y].Min -= fTemp;
	bnds[DXB_Y].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Depth();
	bnds[DXB_Z].Min -= fTemp;
	bnds[DXB_Z].Max += fTemp;

        hr = DetermineBnds(bnds);
    }
    return hr;
} /* CDXBaseNTo1::_MeshMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsIn2Out *
*------------------------------*
*   Description:
*       The MapBoundsIn2Out method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                           ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsIn2Out" );
    if((ulNumInBnds && DXIsBadReadPtr( pInBounds, ulNumInBnds * sizeof( *pInBounds ) )) ||
        ulOutIndex)
    {
        return E_INVALIDARG;
    }

    if( DXIsBadWritePtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        return E_POINTER;
    }
    //
    //  Set the bounds to empty and the appropriate type.
    //
    memset(pOutBounds, 0, sizeof(*pOutBounds));
    _ASSERT(DXBT_DISCRETE == 0);
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        pOutBounds->eType = DXBT_CONTINUOUS;
    }

    //
    //  Make sure all input bounds are of the correct type.
    //
    if( ulNumInBnds )
    {
        DXBNDTYPE eType = (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) ? DXBT_CONTINUOUS : DXBT_DISCRETE;
        for (ULONG i = 0; i < ulNumInBnds; i++)
        {
            if (pInBounds[i].eType != eType)
            {
                return E_INVALIDARG;
            }
        }
    }

    //
    //  Now do the appropriate mapping
    //
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        //
        //  NOTE:  In the case of non-mesh inputs, the inputs are discrete, but they will
        //         be completely ignored by the function so it's OK to cast them to CDXCBnds
        //
        return _MeshMapIn2Out(*((CDXCBnds *)pOutBounds), ulNumInBnds, (CDXCBnds *)pInBounds);
    }
    else 
    {
        return _ImageMapIn2Out(*(CDXDBnds *)pOutBounds, ulNumInBnds, (CDXDBnds *)pInBounds);
    }
} /* CDXBaseNTo1::MapBoundsIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsOut2In *
*------------------------------*
*   Description:
*       The MapBoundsOut2In method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsOut2In" );
    HRESULT hr = S_OK;
    
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        hr = E_NOTIMPL;     // This is pointless for meshes.
    }
    else if(ulInIndex >= m_ulMaxInputs || ulOutIndex || DXIsBadReadPtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pInBounds, sizeof( *pInBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pInBounds = *pOutBounds;
    }
    return hr;
} /* CDXBaseNTo1::MapBoundsOut2In */

/*****************************************************************************
* CDXBaseNTo1::SetMiscFlags *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30.97
*-----------------------------------------------------------------------------
*   Parameters:
*       bMiscFlags - New value to set 
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetMiscFlags( DWORD dwMiscFlags )
{ 
    DXTDBG_FUNC( "CDXBaseNTo1::SetMiscFlags" );
    HRESULT hr = S_OK;
    Lock();
    WORD wOpts = (WORD)dwMiscFlags;     // Ignore high word.  Only set low word.
    if (((WORD)m_dwMiscFlags) != wOpts)
    {
        if ((wOpts & (~DXTMF_VALID_OPTIONS)) ||
            ((wOpts & DXTMF_BLEND_WITH_OUTPUT) && (m_dwMiscFlags & DXTMF_BLEND_SUPPORTED) == 0) ||
            ((wOpts & DXTMF_DITHER_OUTPUT) && (m_dwMiscFlags & DXTMF_DITHER_SUPPORTED) == 0))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_dwMiscFlags &= 0xFFFF0000;
            m_dwMiscFlags |= wOpts;
            _UpdateBltFlags();
            m_dwGenerationId++;
        }
    }
    Unlock();  
    return hr;
} /* CDXBaseNTo1::SetMiscFlags */

/*****************************************************************************
* CDXBaseNTo1::GetMiscFlags *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetMiscFlags( DWORD* pdwMiscFlags )
{
    if( DXIsBadWritePtr( pdwMiscFlags, sizeof( *pdwMiscFlags ) ) )
    {
        return E_POINTER;
    }
    *pdwMiscFlags = m_dwMiscFlags;
    return S_OK;
} /* CDXBaseNTo1::GetMiscFlags */


/*****************************************************************************
* CDXBaseNTo1::SetQuality *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetQuality(float fQuality)
{
    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        return E_NOTIMPL;
    }

    if (fQuality < 0.0f || fQuality > 1.0f)
    {
        return E_INVALIDARG;
    }

    Lock();
    if (m_fQuality != fQuality)
    {
        m_fQuality = fQuality;
        m_dwGenerationId++;
    }
    Unlock();

    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::GetQuality *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

STDMETHODIMP CDXBaseNTo1::GetQuality(float *pfQuality)
{
    HRESULT hr = S_OK;

    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        hr = E_NOTIMPL;
    }
    else 
    {
        if( DXIsBadWritePtr( pfQuality, sizeof( *pfQuality ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            *pfQuality = m_fQuality;
        }
    }
    return hr;
}



/*****************************************************************************
* GetInOutInfo
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetInOutInfo( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags,
                                        GUID * pIDs, ULONG *pcIDs, IUnknown **ppUnkCurObj )
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetInOutInfo" );
    HRESULT hr = S_FALSE;
    DWORD dwFlags = 0;
    BOOL bImage;
    if( bOutput )
    {
        bImage = !(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        if (ulIndex == 0)
        {
            hr = S_OK;
        }
    }
    else
    {
        bImage = !(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        if (ulIndex < m_ulMaxInputs)
        {
            hr = S_OK;
            if (ulIndex >= m_ulNumInRequired)
            {
                dwFlags = DXINOUTF_OPTIONAL;
            }
        }
    }
    if( hr == S_OK )
    {
        if( pdwFlags && !DXIsBadWritePtr( pdwFlags, sizeof( *pdwFlags ) ) )
        {
            *pdwFlags = dwFlags;
        }

        if( pIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) ||
                DXIsBadWritePtr( pIDs, *pcIDs * sizeof( *pIDs ) ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if (bImage)
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXSurface;
                    }
                    if (*pcIDs > 1)
                    {
                        pIDs[1] = IID_IDXDupDDrawSurface;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 2;
                }
                else
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXDupDirect3DRMMeshBuilder3;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 1;
                }
            }
        }
        else if( pcIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) )
            {
                hr = E_POINTER;
            }
            else
            {
                *pcIDs = bImage ? 2 : 1;
            }
        }
        if (hr == S_OK && ppUnkCurObj)
        {
            if (DXIsBadWritePtr(ppUnkCurObj, sizeof(*ppUnkCurObj)))
            {
                hr = E_POINTER;
            }
            else
            {
                if (bOutput)
                {
                    *ppUnkCurObj = m_Output.m_pNativeInterface;
                }
                else
                {
                    *ppUnkCurObj = NULL;
                    if (ulIndex < GetNumInputs())
                    {
                        *ppUnkCurObj = m_aInputs[ulIndex].m_pUnkOriginalObject;
                    }
                }
                if (*ppUnkCurObj)
                {
                    (*ppUnkCurObj)->AddRef();
                }
            }
        }
    }
    return hr;
} /* CDXBaseNTo1::GetInOutInfo */

/*****************************************************************************
* CDXBaseNTo1::OnUpdateGenerationId *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::OnUpdateGenerationId(void)
{
    DXTDBG_FUNC( "CDXBaseNTo1::OnUpdateGenerationId" );
    if( (m_dwMiscFlags & DXTMF_INPLACE_OPERATION) &&
        m_Output.UpdateGenerationId())
    {
        m_dwGenerationId++;
    }
    for (ULONG i = 0; i < m_ulNumInputs; i++)
    {
        if (m_aInputs[i].UpdateGenerationId())
        {
            m_dwGenerationId++;
        }
    }
} /* CDXBaseNTo1::OnUpdateGenerationId */

/*****************************************************************************
* CDXBaseNTo1::OnGetObjectSize *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
ULONG CDXBaseNTo1::OnGetObjectSize(void)
{
    return sizeof(*this);
}

//
//  Effect interface
//

/*****************************************************************************
* CDXBaseNTo1::get_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Progress(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Progress" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Progress;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::put_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Progress(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Progress" );
    HRESULT hr = S_OK;
    if (newVal < 0.0 || newVal > 1.0f)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        Lock();
        m_Progress = newVal;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_dwGenerationId++;     
        Unlock();
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_StepResolution *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_StepResolution(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_StepResolution" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_StepResolution;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Duration(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Duration" );
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        return E_POINTER;
    }
    else
    {
        *pVal = m_Duration;
    }
    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::put_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Duration(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Duration" );
    if (newVal <= 0.)
    {
        return E_INVALIDARG;
    }
    if(newVal != m_Duration)
    {
	Lock();
	m_dwGenerationId++;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_Duration = newVal;
    	Unlock();
    }
    return S_OK;
}


/*****************************************************************************
* CDXBaseNTo1::PointPick *
*------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 5/5/98
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::PointPick(const DXVEC *pPoint,
                                    ULONG * pulInputSurfaceIndex,
                                    DXVEC *pInputPoint)
{
    HRESULT hr          = S_OK;
    BOOL    bFoundIt    = FALSE;

    // If we haven't been set up yet, we will just act as if we're transparent.

    if (!m_fIsSetup)
    {
        hr = S_FALSE;

        goto done;
    }

    if (DXIsBadReadPtr(pPoint, sizeof(*pPoint)) || pPoint->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        if (DXIsBadWritePtr(pulInputSurfaceIndex, sizeof(*pulInputSurfaceIndex)) ||
            DXIsBadWritePtr(pInputPoint, sizeof(*pInputPoint)))
        {
            hr = E_POINTER;
        }
        else 
        {
            HRESULT     hr2         = S_OK;
            CDXDBnds    bndsOutput;
            CDXDBnds    OutBndsPoint(*((CDXDVec *)pPoint));
            CDXDVec &   InVec       = *(new(pInputPoint) CDXDVec(*((CDXDVec *)pPoint)));

            // Get the output size of the DXTransform.  If this point is not on
            // the output at all, we can return S_FALSE right now.

            hr = MapBoundsIn2Out(NULL, 0, 0, &bndsOutput);

            if (FAILED(hr))
            {
                goto done;
            }

            if (!bndsOutput.TestIntersect(OutBndsPoint))
            {
                hr = S_FALSE;

                goto done;
            }

            hr2 = OnSurfacePick(OutBndsPoint, *pulInputSurfaceIndex, InVec);

            if (hr2 != E_NOTIMPL)
            {
                hr = hr2;
            }
            else
            {
                //--- The derived class does not implement so we will do
                //    the hit test against the input for them.
                ULONG * aulInIndex = (ULONG *)_alloca(sizeof(ULONG) * m_ulMaxInputs);
                BYTE * aWeights = (BYTE *)_alloca(sizeof(BYTE) * m_ulMaxInputs);
                ULONG ulNumToTest;
                OnGetSurfacePickOrder(OutBndsPoint, ulNumToTest, aulInIndex, aWeights);

                if( m_bPickDoneByBase && ( m_ulNumInputs > 1 ) )
                {
                    //--- We don't know how to do multi-input picking from the base.
                    hr = E_NOTIMPL;
                }

                for (ULONG i = 0; SUCCEEDED(hr) && i < ulNumToTest; i++)
                {
                    ULONG ulInput = aulInIndex[i];
                    if (HaveInput(ulInput) && aWeights[i])
                    {
                        CDXDBnds Out2InBnds(false);
                        hr = MapBoundsOut2In(0, &OutBndsPoint, ulInput, &Out2InBnds);
                        if (SUCCEEDED(hr))
                        {
                            CDXDBnds InSurfBnds(InputSurface(ulInput), hr);
                            if (SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds))
                            {
                                IDXARGBReadPtr * pPtr;
                                hr = InputSurface(ulInput)->LockSurface(&InSurfBnds, m_ulLockTimeOut, DXLOCKF_READ, 
                                                                        IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
                                if( SUCCEEDED(hr) )
                                {
                                    DXPMSAMPLE val;
                                    pPtr->UnpackPremult(&val, 1, FALSE);
                                    pPtr->Release();
                                    if (val.Alpha * aWeights[i] / 255)
                                    {
                                        InSurfBnds.GetMinVector(InVec);
                                        bFoundIt = TRUE;
                                        *pulInputSurfaceIndex = ulInput;
                                        break;
                                    }
                                }
                            }   
                        }
                    }
                }
                if (SUCCEEDED(hr) & (!bFoundIt))
                {
                    hr = S_FALSE;
                }
            }
        }
    }

done:

    return hr;
} /* CDXBaseNTo1::PointPick */

/*****************************************************************************
* RegisterTansform (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseNTo1::
RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                  ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    DXTDBG_FUNC( "CDXBaseNTo1::RegisterTransform" );
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = ::CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}


void CDXBaseNTo1::_TaskProc(void* pTaskInfo, BOOL* pbContinue )
{ 
    _ASSERT( pTaskInfo );
    CDXTWorkInfoNTo1& WI = *((CDXTWorkInfoNTo1 *)pTaskInfo);
    CDXBaseNTo1& This = *((CDXBaseNTo1 *)WI.pvThis);
    WI.hr = This.WorkProc(WI, pbContinue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxatlpb.h ===
#ifndef dxatlpb_h
#define dxatlpb_h

#include <atlctl.h>

#ifndef DXTDbg_h
#include <dxtdbg.h>
#endif

#define COM_INTERFACE_ENTRY_DXIMPL(x)\
	COM_INTERFACE_ENTRY_IID(IID_##x, x##DXImpl<_ComMapClass>)

/*** IOleObjectDXImpl
*   This is a simplified version used to allow a transform
*   to be hosted by IE
*/
template <class T>
class ATL_NO_VTABLE IOleObjectDXImpl
{
  public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        STDMETHOD_(ULONG,AddRef)() = 0;
        STDMETHOD_(ULONG,Release)() = 0;

	// IOleObject
	//
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetClientSite" );
        HRESULT hr = S_OK;
        if( pClientSite && DXIsBadInterfacePtr( pClientSite ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
    		T* pT = static_cast<T*>(this);
            pT->m_cpOleClientSite = pClientSite;
        }
        return hr;
	}

	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClientSite" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( ppClientSite, sizeof( *ppClientSite )) )
        {
            hr = E_POINTER;
        }
        else
        {
    		T* pT = static_cast<T*>(this);
            *ppClientSite = pT->m_cpOleClientSite;
        }
        return hr;
	}

	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetHostNames" );
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Close" );
		return S_OK;
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetMoniker" );
        return E_NOTIMPL;
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMoniker" );
        return E_NOTIMPL;
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::InitFromData" );
        return E_NOTIMPL;
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClipboardData" );
        return E_NOTIMPL;
	}

	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
		return S_OK;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
		return OLEOBJ_E_NOVERBS;
	}
	STDMETHOD(Update)(void)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Update" );
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::IsUpToDate" );
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserClassID" );
		_ASSERTE(pClsid);
		if( DXIsBadWritePtr( pClsid, sizeof( *pClsid ) ) )
        {
			return E_POINTER;
        }
        else
        {
		    *pClsid = T::GetObjectCLSID();
		    return S_OK;
        }
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserType" );
		return OLE_S_USEREG;
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetExtent" );
        return S_OK;
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetExtent" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( psizel, sizeof( *psizel ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            psizel->cx = 0;
            psizel->cy = 0;
        }
		return hr;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Advise" );
        return S_OK;
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::Unadvise" );
        return S_OK;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::EnumAdvise" );
        return E_FAIL;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMiscStatus" );
		return OLE_S_USEREG;
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
        DXTDBG_FUNC( "IOleObjectDXImpl::SetColorScheme" );
        return E_NOTIMPL;
	}
};

/*** CComPropBase
*
*/
class ATL_NO_VTABLE CComPropBase
{
public:
    HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
	    LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
    {
	    USES_CONVERSION;
	    CComPtr<IDispatch> pDispatch;
	    const IID* piidOld = NULL;
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (pMap[i].szDesc == NULL)
			    continue;
		    CComVariant var;

		    if(pMap[i].piidDispatch != piidOld)
		    {
			    pDispatch.Release();
			    if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			    {
				    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				    return E_FAIL;
			    }
			    piidOld = pMap[i].piidDispatch;
		    }

		    if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }

		    HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		    if (FAILED(hr))
		    {
			    if (hr == E_INVALIDARG)
			    {
				    ATLTRACE(_T("Property %s not in Bag\n"), OLE2CT(pMap[i].szDesc));
			    }
			    else
			    {
				    // Many containers return different ERROR values for Member not found
				    ATLTRACE(_T("Error attempting to read Property %s from PropertyBag \n"), OLE2CT(pMap[i].szDesc));
			    }
			    continue;
		    }

		    if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }
	    }
	    return S_OK;

    }

    HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
	    BOOL fClearDirty, BOOL /*fSaveAllProperties*/, ATL_PROPMAP_ENTRY* pMap)
    {
	    if (pPropBag == NULL)
	    {
		    ATLTRACE(_T("PropBag pointer passed in was invalid\n"));
		    return E_POINTER;
	    }

	    CComPtr<IDispatch> pDispatch;
	    const IID* piidOld = NULL;
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (pMap[i].szDesc == NULL)
			    continue;
		    CComVariant var;

		    if(pMap[i].piidDispatch != piidOld)
		    {
			    pDispatch.Release();
			    if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			    {
				    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
				    return E_FAIL;
			    }
			    piidOld = pMap[i].piidDispatch;
		    }

		    if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		    {
			    ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			    return E_FAIL;
		    }

		    if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		    {
			    if (var.punkVal == NULL)
			    {
				    ATLTRACE(_T("Warning skipping empty IUnknown in Save\n"));
				    continue;
			    }
		    }

		    HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		    if (FAILED(hr))
			    return hr;
	    }
	    m_bRequiresSave = FALSE;
	    return S_OK;
    }

    HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages,
	    ATL_PROPMAP_ENTRY* pMap)
    {
	    _ASSERTE(pMap != NULL);
	    int nCnt = 0;
	    // Get count of unique pages
	    for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
			    nCnt++;
	    }
	    pPages->pElems = NULL;
	    pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
	    if (pPages->pElems == NULL)
		    return E_OUTOFMEMORY;
	    nCnt = 0;
	    for(i = 0; pMap[i].pclsidPropPage != NULL; i++)
	    {
		    if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
		    {
			    BOOL bMatch = FALSE;
			    for (int j=0;j<nCnt;j++)
			    {
				    if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
				    {
					    bMatch = TRUE;
					    break;
				    }
			    }
			    if (!bMatch)
				    pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
		    }
	    }
	    pPages->cElems = nCnt;
	    return S_OK;
    }
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv) = 0;
    BOOL m_bRequiresSave;
};


template <class T>
class ATL_NO_VTABLE CComPropertySupport :  public CComPropBase
{
public:
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv)
    {
        T* pT = static_cast<T*>(this);
	return pT->_InternalQueryInterface(iid, ppv);
    }
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//

template <class T> 
class ATL_NO_VTABLE IObjectSafetyImpl2
{
public:
        DWORD m_dwSafety[4];
        const IID *m_pIID[4];

        IObjectSafetyImpl2()
	{
            m_pIID[0] = &IID_IDispatch;
            m_pIID[1] = &IID_IPersistPropertyBag;
            m_pIID[2] = &IID_IPersistStorage;
            m_pIID[3] = &IID_IPersistStream;
            for (int i = 0; i < 4; i++)
            {
		m_dwSafety[i] = 0;
            }
	}

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl2)

	// IObjectSafety
	//
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
                for (int i = 0; i < 4 && m_pIID[i]; i++)
                {
                    if (riid == *m_pIID[i]) {
			*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			*pdwEnabledOptions = m_dwSafety[i] & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
                        return S_OK;
                    }
		}
            	*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		return E_NOINTERFACE;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
		// If we're being asked to set our safe for scripting option then oblige
                for (int i = 0; i < 4 && m_pIID[i]; i++)
                {
                    if (riid == *m_pIID[i]) {
			m_dwSafety[i] = dwEnabledOptions & dwOptionSetMask;
                        return S_OK;
                    }
		}
		return E_NOINTERFACE;
	}

};

#endif // This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\cryptdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

// Master flags to control how revocation is managed

#define CRYTPDLG_FLAGS_MASK                 0xff000000
#define CRYPTDLG_REVOCATION_DEFAULT         0x00000000
#define CRYPTDLG_REVOCATION_ONLINE          0x80000000
#define CRYPTDLG_REVOCATION_CACHE           0x40000000
#define CRYPTDLG_REVOCATION_NONE            0x20000000


// Policy flags which control how we deal with user's certificates

#define CRYPTDLG_POLICY_MASK                0x0000FFFF
#define POLICY_IGNORE_NON_CRITICAL_BC       0x00000001

#define CRYPTDLG_ACTION_MASK                0xFFFF0000
#define ACTION_REVOCATION_DEFAULT_ONLINE    0x00010000
#define ACTION_REVOCATION_DEFAULT_CACHE     0x00020000

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD,   // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_SELECTCERT_MASK             0x00ffffff
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC

/////////////////////////////////////////////////////////////

#define CM_VIEWFLAGS_MASK       0x00ffffff
#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200
#define CERTVIEW_CRYPTUI_LPARAM 0x00800000

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pchBuffer,
                             DWORD cchBuffer);
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pchBuffer,
                              DWORD cchBuffer);
#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }
#define szCERT_CERTIFICATE_ACTION_VERIFY    \
    "{7801ebd0-cf4b-11d0-851f-0060979387ea}"  

typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN DWORD                lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_PERIOD_NESTING_FAILURE    0x00000400
#define CERT_VALIDITY_OTHER_ERROR               0x00000800
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_MASK                         0x00ffffff
#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    DWORD               lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);
#endif // !WIN16

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxclrhlp.h ===
HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor );

typedef struct _COLORVALUE_PAIR
{
    const CHAR  *szName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { ("aliceblue"),             0xfff0f8ff },
    { ("antiquewhite"),          0xfffaebd7 },
    { ("aqua"),                  0xff00ffff },
    { ("aquamarine"),            0xff7fffd4 },
    { ("azure"),                 0xfff0ffff },
    { ("beige"),                 0xfff5f5dc },
    { ("bisque"),                0xffffe4c4 },
    { ("black"),                 0xff000000 },
    { ("blanchedalmond"),        0xffffebcd },
    { ("blue"),                  0xff0000ff },
    { ("blueviolet"),            0xff8a2be2 },
    { ("brown"),                 0xffa52a2a },
    { ("burlywood"),             0xffdeb887 },
    { ("cadetblue"),             0xff5f9ea0 },
    { ("chartreuse"),            0xff7fff00 },
    { ("chocolate"),             0xffd2691e },
    { ("coral"),                 0xffff7f50 },
    { ("cornflowerblue"),        0xff6495ed },
    { ("cornsilk"),              0xfffff8dc },
    { ("crimson"),               0xffdc143c },
    { ("cyan"),                  0xff00ffff },
    { ("darkblue"),              0xff00008b },
    { ("darkcyan"),              0xff008b8b },
    { ("darkgoldenrod"),         0xffb8860b },
    { ("darkgray"),              0xffa9a9a9 },
    { ("darkgreen"),             0xff006400 },
    { ("darkkhaki"),             0xffbdb76b },
    { ("darkmagenta"),           0xff8b008b },
    { ("darkolivegreen"),        0xff556b2f },
    { ("darkorange"),            0xffff8c00 },
    { ("darkorchid"),            0xff9932cc },
    { ("darkred"),               0xff8b0000 },
    { ("darksalmon"),            0xffe9967a },
    { ("darkseagreen"),          0xff8fbc8f },
    { ("darkslateblue"),         0xff483d8b },
    { ("darkslategray"),         0xff2f4f4f },
    { ("darkturquoise"),         0xff00ced1 },
    { ("darkviolet"),            0xff9400d3 },
    { ("deeppink"),              0xffff1493 },
    { ("deepskyblue"),           0xff00bfff },
    { ("dimgray"),               0xff696969 },
    { ("dodgerblue"),            0xff1e90ff },
    { ("firebrick"),             0xffb22222 },
    { ("floralwhite"),           0xfffffaf0 },
    { ("forestgreen"),           0xff228b22 },
    { ("fuchsia"),               0xffff00ff },
    { ("gainsboro"),             0xffdcdcdc },
    { ("ghostwhite"),            0xfff8f8ff },
    { ("gold"),                  0xffffd700 },
    { ("goldenrod"),             0xffdaa520 },
    { ("gray"),                  0xff808080 },
    { ("green"),                 0xff008000 },
    { ("greenyellow"),           0xffadff2f },
    { ("honeydew"),              0xfff0fff0 },
    { ("hotpink"),               0xffff69b4 },
    { ("indianred"),             0xffcd5c5c },
    { ("indigo"),                0xff4b0082 },
    { ("ivory"),                 0xfffffff0 },
    { ("khaki"),                 0xfff0e68c },
    { ("lavender"),              0xffe6e6fa },
    { ("lavenderblush"),         0xfffff0f5 },
    { ("lawngreen"),             0xff7cfc00 },
    { ("lemonchiffon"),          0xfffffacd },
    { ("lightblue"),             0xffadd8e6 },
    { ("lightcoral"),            0xfff08080 },
    { ("lightcyan"),             0xffe0ffff },
    { ("lightgoldenrodyellow"),  0xfffafad2 },
    { ("lightgreen"),            0xff90ee90 },
    { ("lightgrey"),             0xffd3d3d3 },
    { ("lightpink"),             0xffffb6c1 },
    { ("lightsalmon"),           0xffffa07a },
    { ("lightseagreen"),         0xff20b2aa },
    { ("lightskyblue"),          0xff87cefa },
    { ("lightslategray"),        0xff778899 },
    { ("lightsteelblue"),        0xffb0c4de },
    { ("lightyellow"),           0xffffffe0 },
    { ("lime"),                  0xff00ff00 },
    { ("limegreen"),             0xff32cd32 },
    { ("linen"),                 0xfffaf0e6 },
    { ("magenta"),               0xffff00ff },
    { ("maroon"),                0xff800000 },
    { ("mediumaquamarine"),      0xff66cdaa },
    { ("mediumblue"),            0xff0000cd },
    { ("mediumorchid"),          0xffba55d3 },
    { ("mediumpurple"),          0xff9370db },
    { ("mediumseagreen"),        0xff3cb371 },
    { ("mediumslateblue"),       0xff7b68ee },
    { ("mediumspringgreen"),     0xff00fa9a },
    { ("mediumturquoise"),       0xff48d1cc },
    { ("mediumvioletred"),       0xffc71585 },
    { ("midnightblue"),          0xff191970 },
    { ("mintcream"),             0xfff5fffa },
    { ("mistyrose"),             0xffffe4e1 },
    { ("moccasin"),              0xffffe4b5 },
    { ("navajowhite"),           0xffffdead },
    { ("navy"),                  0xff000080 },
    { ("oldlace"),               0xfffdf5e6 },
    { ("olive"),                 0xff808000 },
    { ("olivedrab"),             0xff6b8e23 },
    { ("orange"),                0xffffa500 },
    { ("orangered"),             0xffff4500 },
    { ("orchid"),                0xffda70d6 },
    { ("palegoldenrod"),         0xffeee8aa },
    { ("palegreen"),             0xff98fb98 },
    { ("paleturquoise"),         0xffafeeee },
    { ("palevioletred"),         0xffdb7093 },
    { ("papayawhip"),            0xffffefd5 },
    { ("peachpuff"),             0xffffdab9 },
    { ("peru"),                  0xffcd853f },
    { ("pink"),                  0xffffc0cb },
    { ("plum"),                  0xffdda0dd },
    { ("powderblue"),            0xffb0e0e6 },
    { ("purple"),                0xff800080 },
    { ("red"),                   0xffff0000 },
    { ("rosybrown"),             0xffbc8f8f },
    { ("royalblue"),             0xff4169e1 },
    { ("saddlebrown"),           0xff8b4513 },
    { ("salmon"),                0xfffa8072 },
    { ("sandybrown"),            0xfff4a460 },
    { ("seagreen"),              0xff2e8b57 },
    { ("seashell"),              0xfffff5ee },
    { ("sienna"),                0xffa0522d },
    { ("silver"),                0xffc0c0c0 },
    { ("skyblue"),               0xff87ceeb },
    { ("slateblue"),             0xff6a5acd },
    { ("slategray"),             0xff708090 },
    { ("snow"),                  0xfffffafa },
    { ("springgreen"),           0xff00ff7f },
    { ("steelblue"),             0xff4682b4 },
    { ("tan"),                   0xffd2b48c },
    { ("teal"),                  0xff008080 },
    { ("thistle"),               0xffd8bfd8 },
    { ("tomato"),                0xffff6347 },
    { ("turquoise"),             0xff40e0d0 },
    { ("violet"),                0xffee82ee },
    { ("wheat"),                 0xfff5deb3 },
    { ("white"),                 0xffffffff },
    { ("whitesmoke"),            0xfff5f5f5 },
    { ("yellow"),                0xffffff00 },
    { ("yellowgreen"),           0xff9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))

const COLORVALUE_PAIR 
rgSystemColorNames[] =
{
    { ("activeborder"),       COLOR_ACTIVEBORDER},    // Active window border.
    { ("activecaption"),      COLOR_ACTIVECAPTION},   // Active window caption.
    { ("appworkspace"),       COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { ("background"),         COLOR_BACKGROUND},      // Desktop background.
    { ("buttonface"),         COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { ("buttonhighlight"),    COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { ("buttonshadow"),       COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { ("buttontext"),         COLOR_BTNTEXT},         // Text on push buttons.
    { ("captiontext"),        COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { ("graytext"),           COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { ("highlight"),          COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { ("highlighttext"),      COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { ("inactiveborder"),     COLOR_INACTIVEBORDER},  // Inactive window border.
    { ("inactivecaption"),    COLOR_INACTIVECAPTION}, // Inactive window caption.
    { ("inactivecaptiontext"),COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { ("infobackground"),     COLOR_INFOBK},          // Background color for tooltip controls.
    { ("infotext"),           COLOR_INFOTEXT},        // Text color for tooltip controls.
    { ("menu"),               COLOR_MENU},            // Menu background.
    { ("menutext"),           COLOR_MENUTEXT},        // Text in menus.
    { ("scrollbar"),          COLOR_SCROLLBAR},       // Scroll bar gray area.
    { ("threeddarkshadow"),   COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { ("threedface"),         COLOR_3DFACE},
    { ("threedhighlight"),    COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { ("threedlightshadow"),  COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { ("threedshadow"),       COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { ("window"),             COLOR_WINDOW},          // Window background.
    { ("windowframe"),        COLOR_WINDOWFRAME},     // Window frame.
    { ("windowtext"),         COLOR_WINDOWTEXT},      // Text in windows.
}; // rgSystemColorNames[]

#define SIZE_OF_SYSTEM_COLOR_TABLE (sizeof(rgSystemColorNames) / sizeof(COLORVALUE_PAIR))

//
// Used by DXColorFromBSTR to parse the hex string.
//

inline HRESULT _HexStrToDWORD( char * pch, DWORD * pdwColor )
{

    HRESULT hr = S_OK;
    short hexVals[8];
    int numVals;
    int i;
    DWORD dwmult;

    if( !pch || !pdwColor )
    {
        hr = E_FAIL;
    }
    else
    {
        //--- parse input string
        numVals = 0;
        while( *pch && numVals < 8 )
        {
            if( *pch >= '0' && *pch <= '9' )
            {
                hexVals[numVals++] = *pch++ - '0';
            }
            else if( *pch >= 'a' && *pch <= 'f' )
            {
                hexVals[numVals++] = *pch++ - 'a' + 10;
            }
            else if( *pch >= 'A' && *pch <= 'F' )
            {
                hexVals[numVals++] = *pch++ - 'A' + 10;
            }
            else
            {
                break;
            }
        }

        if( numVals < 6 )
        {
            hr = E_FAIL;
        }
        else
        {
            //--- if we were passed 7 hex digits, only use the first 6
            if( numVals == 7 )
            {
                numVals = 6;
            }

            //--- initialize multiplier
            dwmult = 1;
            *pdwColor = 0;

            //--- multiply hexVals by 16^i
            for( i = 0; i < numVals; i++ )
            {
                *pdwColor += (hexVals[numVals-(i+1)]*dwmult);
                dwmult <<= 4;
            }
        }
    }
   
    return hr;
}

// 
// Used by DXColorFromBSTR to convert a string to lower case
//

inline void StringToLowerCase( CHAR * pstrKey )
{
    if( pstrKey )
    {
        while( *pstrKey )
        {
            if( *pstrKey >= 'A' && *pstrKey <= 'Z' )
            {
                *pstrKey = 'a' + *pstrKey - 'A';
            }
            pstrKey++;
        }
    }
}


inline HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor )
{
    HRESULT hr = S_OK;
    // validate arguments
    int strLen = wcslen(Color);
    if( strLen < 3 || DXIsBadReadPtr( Color, strLen ) || 
        DXIsBadWritePtr( pdwColor, sizeof(*pdwColor) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- first check for #AARRGGBB and #RRGGBB strings
        if( Color[0] == L'#' )
        {
            CHAR ch[11] = "0xffffffff";
            if( strLen > 9 ) strLen = 9;
            if( strLen >= 7 )
            {
                WideCharToMultiByte( CP_ACP, NULL, &Color[1], strLen-1, &ch[11-strLen], strLen, NULL, NULL );
                hr = _HexStrToDWORD( &ch[2], pdwColor);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            //--- convert the string to lower case
            LPSTR pstrKey = (LPSTR) alloca((strLen + 1) * sizeof(CHAR));
            WideCharToMultiByte( CP_ACP, NULL, Color, strLen+1, pstrKey, strLen+1, NULL, NULL );
            StringToLowerCase( pstrKey );

            //--- search the string table using a binary search
            int nFirst = 0;
            int nLast = SIZE_OF_COLOR_TABLE - 1;
            int nCur, nCmp;
            bool bFound = false;
            while( (nFirst <= nLast) && !bFound )
            {
                nCur = (nFirst + nLast) / 2;
                nCmp = strcmp( rgColorNames[nCur].szName, pstrKey );
                if( nCmp < 0 )
                {
                    nFirst = nCur + 1;
                }
                else if( nCmp > 0 )
                {
                    nLast = nCur - 1;
                }
                else
                {
                    bFound = true;
                    *pdwColor = rgColorNames[nCur].dwValue;
                }
            }

            // String not in regular color table, try the system color table.

            if (!bFound)
            {
                nFirst  = 0;
                nLast   = SIZE_OF_SYSTEM_COLOR_TABLE - 1;

                while ((nFirst <= nLast) && !bFound)
                {
                    nCur = (nFirst + nLast) / 2;
                    nCmp = strcmp(rgSystemColorNames[nCur].szName, pstrKey);

                    if (nCmp < 0)
                    {
                        nFirst = nCur + 1;
                    }
                    else if (nCmp > 0)
                    {
                        nLast = nCur - 1;
                    }
                    else
                    {
                        bFound = true;
                        *pdwColor =  ::GetSysColor((int)rgSystemColorNames[nCur].dwValue);
                        *pdwColor |= 0xFF000000;
                    }
                }

                // String not found in regular or system color table.

                if (!bFound)
                {
                    hr = E_FAIL;
                }
            }
        }

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxbounds.h ===
/*******************************************************************************
* DXBounds.h *
*------------*
*   Description:
*       This is the header file for the bounds helper class implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/22/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXBounds_h
#define DXBounds_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_FLOAT
#include <float.h>
#endif

#ifndef __DXTrans_h__
#include <DXTrans.h>
#endif

#ifndef DXVector_h
#include <DXVector.h>
#endif

//=== Constants ====================================================

#ifdef _ASSERT
#define CHKTYPE() _ASSERT( eType == eBndType )
#else
#define CHKTYPE()
#endif

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXBnds
*
*/
#define CDXB_C CDXBnds<TYPE, USTYPE, STTYPE, eBndType>
#define CDXB_T ((STTYPE*)u.D)
#define CDXB_O( OtherBnd ) ((STTYPE*)(OtherBnd).u.D)

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
class CDXBnds : public DXBNDS
{
  public:
  /*--- Constructors ---*/
    CDXBnds() { eType = eBndType; SetEmpty(); }
    CDXBnds( BOOL bInit ) { eType = eBndType; if (bInit) SetEmpty(); }
    CDXBnds( const DXBNDS& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const CDXB_C& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const RECT & Rect )    { eType = eBndType; SetXYRect( Rect ); }
    CDXBnds( TYPE Width, TYPE Height ) { eType = eBndType; SetXYSize( Width, Height ); }
    CDXBnds( IDXSurface *pSurface, HRESULT & hr) { _ASSERT(eBndType == DXBT_DISCRETE); eType = eBndType; hr = pSurface->GetBounds(this); }
    CDXBnds( IDirect3DRMMeshBuilder3 *pMesh, HRESULT & hr) { _ASSERT(eBndType == DXBT_CONTINUOUS); eType = eBndType; hr = SetToMeshBounds(pMesh); }
    CDXBnds( const CDXV_C& VecPoint ) { eType = eBndType; *this = VecPoint; }

    HRESULT InitFromSafeArray( SAFEARRAY *psa);
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void SetEmpty();
    void Copy( const DXBNDS& Other );
    void Copy( const CDXB_C& Other );

    /*--- Type casts ---*/
    operator STTYPE *   () { CHKTYPE(); return CDXB_T; }
    operator DXDBNDS&   () { CHKTYPE(); return u.D;  }
    operator DXDBNDS64& () { CHKTYPE(); return u.LD; }
    operator DXCBNDS&   () { CHKTYPE(); return u.C;  }
    operator DXCBNDS64& () { CHKTYPE(); return u.LC; }

    //--- Access methods
    USTYPE Width( DXBNDID i ) const { CHKTYPE(); return (USTYPE)(CDXB_T[i].Max - CDXB_T[i].Min); }

    USTYPE Width()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min); }
    USTYPE Height()   const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min); }
    USTYPE Depth()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min); }
    USTYPE Duration() const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min); }

    TYPE  Left()     const { CHKTYPE(); return CDXB_T[DXB_X].Min; }
    TYPE  Right()    const { CHKTYPE(); return CDXB_T[DXB_X].Max; }
    TYPE  Top()      const { CHKTYPE(); return CDXB_T[DXB_Y].Min; }
    TYPE  Bottom()   const { CHKTYPE(); return CDXB_T[DXB_Y].Max; }

    void SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                    TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax );
    void SetXYRect( const RECT& xyRect);
    void SetXYSize( const SIZE& xySize);
    void SetXYSize( TYPE width, TYPE height);
    void SetXYPoint(const POINT& xyPoint);
    void Offset( TYPE x, TYPE y, TYPE z, TYPE t );
    void Offset( const CDXV_C& v );
    void SetPlacement(const CDXV_C& v);
    void SetToSize(void);
    void GetXYRect( RECT& xyRect ) const;
    void GetXYSize( SIZE& xySize ) const;
    void GetMinVector( CDXV_C& v ) const;
    void GetMaxVector( CDXV_C& v ) const;
    void GetSize( CDXB_C& SizeBounds ) const;
    CDXB_C Size( void ) const;
 


    //--- Region Functions
    void NormalizeBounds();
    BOOL BoundsAreEmpty() const;
    BOOL BoundsAreNull() const;
    BOOL TestIntersect( const CDXB_C& Other ) const;
    BOOL IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );
    BOOL IntersectBounds( const CDXB_C& OtherBounds );
    void UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );

// Additional Operations
    STTYPE& operator[]( int index )    const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( long index )   const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( USHORT index ) const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DWORD index )  const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DXBNDID index) const { CHKTYPE(); return CDXB_T[index]; }

    void operator=(const CDXB_C& Bounds);
    void operator=(const CDXV_C& v);
    void operator+=(const POINT& point);
    void operator-=(const POINT& point);
    void operator+=(const SIZE& size);
    void operator-=(const SIZE& size);
    void operator+=(const CDXV_C& v);
    void operator-=(const CDXV_C& v);
    void operator+=(const CDXB_C& Bounds);
    void operator-=(const CDXB_C& Bounds);
    void operator&=(const CDXB_C& Bounds);
    void operator|=(const CDXB_C& Bounds);
    BOOL operator==(const CDXB_C& Bounds) const;
    BOOL operator!=(const CDXB_C& Bounds) const;

// Operators returning CDXDBnds values
    CDXB_C operator+(const POINT& point) const;
    CDXB_C operator-(const POINT& point) const;
    CDXB_C operator+(const SIZE& size) const;
    CDXB_C operator-(const SIZE& size) const;
    CDXB_C operator+(const CDXV_C& v) const;
    CDXB_C operator-(const CDXV_C& v) const;
    CDXB_C operator&(const CDXB_C& Bounds2) const;
    CDXB_C operator|(const CDXB_C& Bounds2) const;

//
// Helpers to grow bounds from their midpoints.
//
    void Scale(TYPE x, TYPE y = 1, TYPE z = 1, TYPE t = 1);
    void Scale(const CDXV_C& v);
    void Expand(TYPE x, TYPE y = 0, TYPE z = 0, TYPE t = 0);
    void Expand(const CDXV_C& v);

// Helpers for DXSurfaces  These functions only work with DISCRETE bounds
    HRESULT SetToSurfaceBounds(IDXSurface * pDXSurface);

// Helpers for D3DRM Meshes.  These functions only work with CONTINUOUS bounds.
    HRESULT SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh);
};

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetEmpty()
{
    CHKTYPE(); 
    memset(CDXB_T, 0, sizeof(STTYPE) * 4);
} /* CDXBnds::SetEmpty() */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const CDXB_C& Other )
{
    CHKTYPE();
    memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const DXBNDS& Other )
{
    CHKTYPE(); 
    if( eBndType == Other.eType )
    {
        memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
    }
    else
    {
        int i = 4;
        switch( Other.eType )
        {
          case DXBT_DISCRETE:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.D[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.D[i].Max;
            }
            break;
          case DXBT_DISCRETE64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LD[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LD[i].Max;
            }
            break;
          case DXBT_CONTINUOUS:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.C[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.C[i].Max;
            }
            break;
          case DXBT_CONTINUOUS64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LC[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LC[i].Max;
            }
            break;
          default:
            _ASSERT(0);
        }
    }
} /* CDXBnds::Copy constructor */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::InitFromSafeArray( SAFEARRAY *pSA )
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    TYPE *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(TYPE) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                CDXB_T[i].Min = pData[i];
                CDXB_T[i].Max = pData[i+4];
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }

    return hr;
} /* CDXBnds::InitFromSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::GetSafeArray( SAFEARRAY **ppSA ) const
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 8;
        static VARTYPE VTypes[4] = { VT_I4, VT_I8, VT_R4, VT_R8 };

        pSA = SafeArrayCreate( VTypes[eBndType], 1, &rgsabound );

        if( pSA == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            TYPE *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = CDXB_T[i].Min;
                    pData[i+4] = CDXB_T[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }

    return hr;
} /* CDXBnds::GetSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::NormalizeBounds()
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max < CDXB_T[i].Min )
        {
            TYPE Temp = CDXB_T[i].Min;
            CDXB_T[i].Min = CDXB_T[i].Max;
            CDXB_T[i].Max = Temp;
        }
    }
} /* CDXBnds::NormalizeBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;

    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = min( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );

        if( CDXB_T[i].Max <= CDXB_T[i].Min )
        {
            //--- no intersection
            SetEmpty();
            bDoesIntersect = FALSE;
        }
    }
    return bDoesIntersect;
} /* CDXBnds::IntersectBounds */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::TestIntersect( const CDXB_C& Other ) const
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;
    TYPE BndMin, BndMax;
    for( int i = 0; i < 4; ++i )
    {
        BndMin = max( CDXB_T[i].Min, CDXB_O( Other )[i].Min );
        BndMax = min( CDXB_T[i].Max, CDXB_O( Other )[i].Max );
        if( BndMax <= BndMin ) bDoesIntersect = FALSE;
    }
    return bDoesIntersect;
} /* CDXBnds::TestIntersect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    // This assumes the bounds are already normalized.
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = max( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );
    }
} /* CDXDBnds::UnionBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& OtherBounds )
{
    CHKTYPE(); 
    return IntersectBounds( *this, OtherBounds );
} /* CDXBnds::IntersectBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreEmpty() const
{
    CHKTYPE(); 
    //--- Must exist in all dimensions
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max <= CDXB_T[i].Min ) return TRUE;
    }
    return FALSE;
} /* CDXBnds::BoundsAreEmpty */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreNull() const
{
    CHKTYPE(); 
    DWORD *pTest = (DWORD *)CDXB_T;
    DWORD *pLimit = pTest + (sizeof(STTYPE) * 4 / sizeof(*pTest));
    do
    {
        if (*pTest) return FALSE;
        pTest++;
    } while (pTest < pLimit);
    return TRUE;
} /* CDXDBnds::BoundsAreNull */

// Additional Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXB_C& srcBounds )
{
    CHKTYPE(); 
    memcpy(CDXB_T, CDXB_O(srcBounds), sizeof(STTYPE)*4);
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = v[i];
        CDXB_T[i].Max = v[i] + 1;
    }
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator==( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return false;
        }
    }
    return true;
} /* CDXB_C::operator== */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator!=( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return true;
        }
    }
    return false;
} /* CDXBnds::operator!= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator&( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.IntersectBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator& */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator|( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.UnionBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator| */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMinVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Min;
    }
} /* CDXBnds::GetMinVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMaxVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Max;
    }
} /* CDXBnds::GetMaxVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetSize( CDXB_C& SizeBounds ) const
{
    CHKTYPE(); 
    SizeBounds.SetEmpty();
    SizeBounds[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    SizeBounds[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    SizeBounds[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    SizeBounds[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
} /* CDXBnds::GetSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::Size( void ) const
{
    CHKTYPE(); 
    CDXB_C Size;
    Size[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    Size[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    Size[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    Size[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
    return Size;
} /* CDXBnds::Size */

// Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                        TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min = xmin;
    CDXB_T[DXB_X].Max = xmax;
    CDXB_T[DXB_Y].Min = ymin;
    CDXB_T[DXB_Y].Max = ymax;
    CDXB_T[DXB_Z].Min = zmin;
    CDXB_T[DXB_Z].Max = zmax;
    CDXB_T[DXB_T].Min = tmin;
    CDXB_T[DXB_T].Max = tmax;
} /* CDXBnds::SetBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYRect( const RECT& xyRect )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyRect.left;
    CDXB_T[DXB_X].Max = (TYPE)xyRect.right;
    CDXB_T[DXB_Y].Min = (TYPE)xyRect.top;
    CDXB_T[DXB_Y].Max = (TYPE)xyRect.bottom;
    CDXB_T[DXB_Z].Max = 1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYRect( RECT& xyRect ) const
{
    CHKTYPE(); 
    xyRect.left   = CDXB_T[DXB_X].Min;
    xyRect.right  = CDXB_T[DXB_X].Max;
    xyRect.top    = CDXB_T[DXB_Y].Min;
    xyRect.bottom = CDXB_T[DXB_Y].Max;
} /* CDXBnds::GetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYSize( SIZE& xySize ) const
{
    CHKTYPE(); 
    xySize.cx = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    xySize.cy = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
} /* CDXBnds::GetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( const SIZE& xySize )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)xySize.cx;
    CDXB_T[DXB_Y].Max = (TYPE)xySize.cy;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( TYPE width, TYPE height )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)width;
    CDXB_T[DXB_Y].Max = (TYPE)height;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYPoint( const POINT& xyPoint )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyPoint.x;
    CDXB_T[DXB_X].Max = (TYPE)xyPoint.x + 1;
    CDXB_T[DXB_Y].Min = (TYPE)xyPoint.y;
    CDXB_T[DXB_Y].Max = (TYPE)xyPoint.y + 1;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXDBnds::SetRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( TYPE x, TYPE y, TYPE z, TYPE t )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += x;
    CDXB_T[DXB_X].Max += x;
    CDXB_T[DXB_Y].Min += y;
    CDXB_T[DXB_Y].Max += y;
    CDXB_T[DXB_Z].Min += z;
    CDXB_T[DXB_Z].Max += z;
    CDXB_T[DXB_T].Min += t;
    CDXB_T[DXB_T].Max += t;
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetToSize(void)
{
    CHKTYPE();
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max -= CDXB_T[i].Min;
        CDXB_T[i].Min = 0;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetPlacement(const CDXV_C & v)
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max += (CDXV_O( v )[i] - CDXB_T[i].Min);
        CDXB_T[i].Min = CDXV_O( v )[i];
    }
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min += v[i];
        CDXB_T[i].Max += v[i];
    }
} /* CDXBnds::Offset */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)point.x;
    CDXB_T[DXB_X].Max += (TYPE)point.x;
    CDXB_T[DXB_Y].Min += (TYPE)point.y;
    CDXB_T[DXB_Y].Max += (TYPE)point.y;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)point.x;
    CDXB_T[DXB_X].Max -= (TYPE)point.x;
    CDXB_T[DXB_Y].Min -= (TYPE)point.y;
    CDXB_T[DXB_Y].Max -= (TYPE)point.y;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)size.cx;
    CDXB_T[DXB_X].Max += (TYPE)size.cx;
    CDXB_T[DXB_Y].Min += (TYPE)size.cy;
    CDXB_T[DXB_Y].Max += (TYPE)size.cy;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)size.cx;
    CDXB_T[DXB_X].Max -= (TYPE)size.cx;
    CDXB_T[DXB_Y].Min -= (TYPE)size.cy;
    CDXB_T[DXB_Y].Max -= (TYPE)size.cy;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max += CDXV_O( v )[DXB_T];
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max -= CDXV_O( v )[DXB_T];
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max += CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min += CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max += CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min += CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max += CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min += CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max += CDXB_O( Bounds )[DXB_T].Max;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max -= CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min -= CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max -= CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min -= CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max -= CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min -= CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max -= CDXB_O( Bounds )[DXB_T].Max;
} /* CDXB_C::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator&=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = min( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator&= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator|=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( long i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = max( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator|= */


// operators returning CDXDBnds values
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += point.x;
    CDXB_O( Result )[DXB_X].Max += point.x;
    CDXB_O( Result )[DXB_Y].Min += point.y;
    CDXB_O( Result )[DXB_Y].Max += point.y;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= point.x;
    CDXB_O( Result )[DXB_X].Max -= point.x;
    CDXB_O( Result )[DXB_Y].Min -= point.y;
    CDXB_O( Result )[DXB_Y].Max -= point.y;
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const SIZE &size) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += size.cx;
    CDXB_O( Result )[DXB_X].Max += size.cx;
    CDXB_O( Result )[DXB_Y].Min += size.cy;
    CDXB_O( Result )[DXB_Y].Max += size.cy;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-( const SIZE &size ) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= size.cx;
    CDXB_O( Result )[DXB_X].Max -= size.cx;
    CDXB_O( Result )[DXB_Y].Min -= size.cy;
    CDXB_O( Result )[DXB_Y].Max -= size.cy;
    return Result;
} /* CDXB_C::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max += CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max -= CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToSurfaceBounds(IDXSurface * pDXSurface)
{
#if (eBndType != DXBT_DISCRETE)
#error SetToSurfacBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    return pDXSurface->GetBounds( this );
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh)
{
#if (eBndType != DXBT_CONTINUOUS)
#error SetToMeshBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    D3DRMBOX Box;
    HRESULT hr = pMesh->GetBox(&Box);
    u.C[DXB_X].Min = Box.min.x;
    u.C[DXB_X].Max = Box.max.x;
    u.C[DXB_Y].Min = Box.min.y;
    u.C[DXB_Y].Max = Box.max.y;
    u.C[DXB_Z].Min = Box.min.z;
    u.C[DXB_Z].Max = Box.max.z;
    u.C[DXB_T].Min = 0;
    u.C[DXB_T].Max = 1.;
    return hr;
}


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE mid = (CDXB_T[i].Min + CDXB_T[i].Max) / 2;
        TYPE scale = CDXV_O(v)[i] * (CDXB_T[i].Max - mid);
        CDXB_T[i].Min = mid - scale;
        CDXB_T[i].Max = mid + scale;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Scale(CDXV_C(x, y, z, t));
}


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE scale = CDXV_O(v)[i] / 2;
        CDXB_T[i].Min -= scale;
        CDXB_T[i].Max += scale;
    }
}

    
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Expand(CDXV_C(x, y, z, t));
}


//---
typedef CDXBnds<long, unsigned long, DXDBND, DXBT_DISCRETE> CDXDBnds;
typedef CDXBnds<LONGLONG, ULONGLONG, DXDBND64, DXBT_DISCRETE64> CDXDBnds64;
typedef CDXBnds<float, float, DXCBND, DXBT_CONTINUOUS> CDXCBnds;
typedef CDXBnds<double, double, DXCBND64, DXBT_CONTINUOUS64> CDXCBnds64;

//=== Macro Definitions ============================================


//=== Global Data Declarations =====================================


//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxhelp3.cpp ===
// DXHELP3.cpp : Contains routines shared by multiple 3D effects
#include "dxhelp3.h"
#include <malloc.h>
#include <math.h>
#include <stdio.h>

void Rotate::Set(D3DVECTOR d3dvctrNormal, double dAngle)
{
#ifdef _DEBUG
    float NormalSum =   d3dvctrNormal.x * d3dvctrNormal.x + 
                        d3dvctrNormal.y * d3dvctrNormal.y + 
                        d3dvctrNormal.z * d3dvctrNormal.z;
    _ASSERT(NormalSum == 0.0f || (0.99f < NormalSum && NormalSum < 1.01f));
#endif

    // The following transformation matrix routines are from
    // Graphics Gems (the first one) page 466 (Converting 
    // between Matrix and Axis-Amount Representations)
    float s = (float)sin(dAngle), c = (float)cos(dAngle);
    float t = 1.0f - c;

    m_d3dvctrXComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.x + c;
    m_d3dvctrXComponent.y = t * d3dvctrNormal.x * d3dvctrNormal.y - s * d3dvctrNormal.z;
    m_d3dvctrXComponent.z = t * d3dvctrNormal.x * d3dvctrNormal.z + s * d3dvctrNormal.y;

    m_d3dvctrYComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.y + s * d3dvctrNormal.z;
    m_d3dvctrYComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.y + c;
    m_d3dvctrYComponent.z = t * d3dvctrNormal.y * d3dvctrNormal.z - s * d3dvctrNormal.x;

    m_d3dvctrZComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.z - s * d3dvctrNormal.y;
    m_d3dvctrZComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.z + s * d3dvctrNormal.x;
    m_d3dvctrZComponent.z = t * d3dvctrNormal.z * d3dvctrNormal.z + c;
}

static HRESULT DecoupleOneMeshBuilder(void *lpThis /* Ignored */, 
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderOut,
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderIn)
{
    HRESULT hr = lpMeshBuilderOut->SetAppData(lpMeshBuilderIn->GetAppData());

    if(FAILED(hr))
    {
	return hr;
    }

    const int ciOutputFaceCount = lpMeshBuilderOut->GetFaceCount();
    const int ciMaxFaceCount = lpMeshBuilderIn->GetFaceCount();
    if(!ciMaxFaceCount)
    {
	return hr;
    }
    CComPtr<IDirect3DRMFaceArray> cpD3DRMFaceArray;

    hr = lpMeshBuilderIn->GetFaces(&cpD3DRMFaceArray);
    if(hr != D3DRM_OK)
    {
	return hr;
    }

    D3DVECTOR *lpvctrPosition = NULL;
    D3DVECTOR *lpvctrFaceNormals = NULL;
    DWORD dwMaxVertexCount = 0;

    // By reserving space we speed things up by a factor of 20 or 30 X!

    DWORD dwTotalVertexCount = lpMeshBuilderIn->GetVertexCount();
    _ASSERT(dwTotalVertexCount >= 3);
    if (dwTotalVertexCount/ciMaxFaceCount < 3)
    {
	dwTotalVertexCount = ciMaxFaceCount * 3;  // There will be at least 3 vertices per face.
    }
    hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount);

    if(hr != D3DRM_OK)
    {
	return hr;
    }

    // Need to have seperate vertices for each face in the output mesh.
    int iFaceIndex = 0;
    do
    {
	CComPtr<IDirect3DRMFace> cpd3dInFaceTemp;
	CComPtr<IDirect3DRMFace2> cpd3dOutFace;

        if(FAILED(hr = cpD3DRMFaceArray->GetElement((DWORD)iFaceIndex, &cpd3dInFaceTemp)))
        {
            break;
        }
        _ASSERT(cpd3dInFaceTemp);

	CComPtr<IDirect3DRMFace2> cpd3dInFace;
	if(FAILED(hr = cpd3dInFaceTemp->QueryInterface(
		IID_IDirect3DRMFace2, (void **)&cpd3dInFace)))
	{
	    break;
	}

        DWORD dwVertexCount;

        cpd3dInFace->GetVertices(&dwVertexCount, NULL, NULL);
        _ASSERT(dwVertexCount >= 3);

        if(dwVertexCount > dwMaxVertexCount)
        {
            dwMaxVertexCount = dwVertexCount;

	    D3DVECTOR *lpTemp = lpvctrPosition;
            D3DVECTOR *lpNormalTemp = lpvctrFaceNormals;

	    lpvctrPosition = (D3DVECTOR *)realloc(lpvctrPosition, dwMaxVertexCount * sizeof (*lpvctrPosition));
	    lpvctrFaceNormals = (D3DVECTOR *)realloc(lpvctrFaceNormals, dwMaxVertexCount * sizeof (*lpvctrFaceNormals));

	    if(!lpvctrPosition || !lpvctrFaceNormals)
	    {
		free(lpTemp);
		free(lpNormalTemp);
		hr = E_OUTOFMEMORY;
		break;
	    }

	    // We may have a problem in the amount of space reserved in the output meshbuilder.
	    if((ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount > dwTotalVertexCount)
	    {
		dwTotalVertexCount = (ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount;
		hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount - iFaceIndex);

		if(hr != D3DRM_OK)
		{
		    break;
		}
	    }
        }

        if(FAILED(hr = cpd3dInFace->GetVertices(&dwVertexCount, lpvctrPosition, lpvctrFaceNormals)) ||
	   FAILED(hr = lpMeshBuilderOut->CreateFace(&cpd3dOutFace)) ||
	   FAILED(hr = cpd3dOutFace->SetAppData(cpd3dInFace->GetAppData())))
        {
            break;
        }


	CComPtr<IDirect3DRMMaterial2> cpMaterial;
        CComPtr<IDirect3DRMTexture3> cpTexture;
        BOOL bU, bV;

        if(hr != D3DRM_OK ||
          (hr = cpd3dInFace->GetMaterial(&cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetMaterial(cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetColor(cpd3dInFace->GetColor())) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTexture(&cpTexture)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTexture(cpTexture)) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTextureTopology(&bU, &bV)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTextureTopology(bU, bV)) != D3DRM_OK)
        {
            break;
        }

        DWORD dwInFaceVertex = 0;
        do
        {
            int iVIndex = lpMeshBuilderOut->AddVertex(lpvctrPosition[dwInFaceVertex].x, 
					 lpvctrPosition[dwInFaceVertex].y, 
					 lpvctrPosition[dwInFaceVertex].z);
            int iNIndex = lpMeshBuilderOut->AddNormal(lpvctrFaceNormals[dwInFaceVertex].x, 
					 lpvctrFaceNormals[dwInFaceVertex].y, 
					 lpvctrFaceNormals[dwInFaceVertex].z);

            D3DVALUE U, V;

            if(FAILED(hr = cpd3dOutFace->AddVertexAndNormalIndexed(iVIndex, iNIndex)) ||
               FAILED(hr = cpd3dInFace->GetTextureCoordinates(dwInFaceVertex, &U, &V)) ||
               FAILED(hr = cpd3dOutFace->SetTextureCoordinates(dwInFaceVertex, U, V)))
            {
                break;
            }
        } while (++dwInFaceVertex < dwVertexCount);
	dwTotalVertexCount -= dwVertexCount;
    } while (hr == D3DRM_OK && ++iFaceIndex < ciMaxFaceCount);

    free(lpvctrPosition);
    free(lpvctrFaceNormals);

    return hr;
}

HRESULT TraverseSubMeshes(  HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			    void *lpThis, 
			    IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			    IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    HRESULT hr;

    _ASSERT(lpCallBack);
    if(FAILED(hr = (*lpCallBack)(lpThis, lpMeshBuilderOut, lpMeshBuilderIn)))
	return hr;

    DWORD dwInSubMeshCount;
    hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, NULL);

    if(FAILED(hr) || dwInSubMeshCount == 0)
	return hr;

    DWORD dwOutSubMeshCount;
    if(FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, NULL)))
    {
	return hr;
    }

    const BOOL bCreateOutMeshes = (dwOutSubMeshCount == 0);
    _ASSERT(bCreateOutMeshes || dwInSubMeshCount == dwOutSubMeshCount);

    LPUNKNOWN *lplpunkInSubMeshes =
	(LPUNKNOWN *)malloc(dwInSubMeshCount * sizeof(*lplpunkInSubMeshes));

    LPUNKNOWN *lplpunkOutSubMeshes = (bCreateOutMeshes? NULL:
	(LPUNKNOWN *)malloc(dwOutSubMeshCount * sizeof(*lplpunkOutSubMeshes)));

    if(!lplpunkInSubMeshes || !bCreateOutMeshes && !lplpunkOutSubMeshes)
    {
	return E_OUTOFMEMORY;
    }

    if(FAILED(hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, lplpunkInSubMeshes)) ||
	!bCreateOutMeshes && 
	FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, lplpunkOutSubMeshes)))
    {
	return hr;
    }

    CComPtr<IDirect3DRMMeshBuilder3> cpInSubMesh, cpOutSubMesh;

    DWORD dwSubMesh;
    for(dwSubMesh = 0; SUCCEEDED(hr) && dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	cpInSubMesh = NULL;
	cpOutSubMesh = NULL;

	// Get the current input submesh.
	hr = lplpunkInSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3, 
		(void **)&cpInSubMesh);

	if(FAILED(hr))
	    break;

	if(bCreateOutMeshes)
	{
	    // Create a new submesh in the output mesh to match the input submesh.	    
	    LPUNKNOWN lpunkSubmesh;

	    if(FAILED(hr = lpMeshBuilderOut->CreateSubMesh(&lpunkSubmesh)))
		break;

	    hr = lpunkSubmesh->QueryInterface(IID_IDirect3DRMMeshBuilder3,
							(void **)&cpOutSubMesh);
	    lpunkSubmesh->Release();
	}
	else
	{
	    // Get the current output submesh.
	    hr = lplpunkOutSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3,
		    (void **)&cpOutSubMesh);
	}
	if(FAILED(hr))
	    break;

	// Do all the children for these two MeshBuilders.
	hr = TraverseSubMeshes(lpCallBack, lpThis, cpOutSubMesh, cpInSubMesh);
    }

    for(dwSubMesh = 0; dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	lplpunkInSubMeshes[dwSubMesh]->Release();

	if(lplpunkOutSubMeshes)
	{
	    lplpunkOutSubMeshes[dwSubMesh]->Release();
	}
    }

    free(lplpunkInSubMeshes);
    free(lplpunkOutSubMeshes);

    return hr;
}

HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    DWORD dwSubMeshCount;

    HRESULT hr = lpMeshBuilderOut->GetSubMeshes(&dwSubMeshCount, NULL);

    if(FAILED(hr))
	return hr;

    if(lpMeshBuilderOut->GetFaceCount() || dwSubMeshCount)
    {
	if(FAILED(hr = lpMeshBuilderOut->Empty(0)))
	    return hr;
    }
    hr = TraverseSubMeshes(DecoupleOneMeshBuilder, NULL,
			    lpMeshBuilderOut, lpMeshBuilderIn);
    return hr;
}

float GetDlgItemFloat(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return (float)strtod(szItemText, &pEnd);
}

BOOL SetDlgItemFloat( HWND hDlg, int id, float f )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2f"), f );
    return SetDlgItemText( hDlg, id, szItem );
}

double GetDlgItemDouble(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return strtod(szItemText, &pEnd);
}

BOOL SetDlgItemDouble( HWND hDlg, int id, double d )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2d"), d );
    return SetDlgItemText( hDlg, id, szItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxhelp3.h ===
// DXHELP3.cpp : Contains definitions of routines shared by multiple effects

#ifndef __DXHELP3_H_
#define __DXHELP3_H_

#include <d3d.h>
#include <d3drm.h>
#include <math.h>


#ifndef PI
#define PI 3.1415926538
#endif

/*******************
This class is used to rotate a set of points about an axis.  An example of
how this is used is in Explode.cpp.  Basically you set up the axis and the
angle with the Set() function. The angle is in radians, and the Axis given
MUST be normalized.  That is the magnitude of the vector must be one. Then
you call RotatePoint() for each point.
*******************/
class Rotate
{
public:
    Rotate(){ D3DVECTOR v; v.x = 1; v.y = 0; v.z = 0; Set(v, PI); }
    Rotate(D3DVECTOR NormalAxis, double Angle) { Set(NormalAxis, Angle); }

    D3DVECTOR RotatePoint(D3DVECTOR Org)
    {
	D3DVECTOR Result;

	Result.x = Org.x * m_d3dvctrXComponent.x + 
		   Org.y * m_d3dvctrXComponent.y + 
		   Org.z * m_d3dvctrXComponent.z;

	Result.y = Org.x * m_d3dvctrYComponent.x + 
		   Org.y * m_d3dvctrYComponent.y + 
		   Org.z * m_d3dvctrYComponent.z;

	Result.z = Org.x * m_d3dvctrZComponent.x + 
		   Org.y * m_d3dvctrZComponent.y + 
		   Org.z * m_d3dvctrZComponent.z;

	return Result;
    }

    void Set(D3DVECTOR d3dvtcrAxis, double dAngle);

private:
    D3DVECTOR m_d3dvctrXComponent, m_d3dvctrYComponent, m_d3dvctrZComponent;
};

/******************
Copy the input MeshBuilder to the Output MeshBuilder.  
But, create independent vertices for each face in the output
mesh.  That is no two faces share a single vertice.
******************/
HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/******************
For each MeshBuilder in lpMeshBuilderIn find the corresponding 
MeshBuilder in lpMeshBuilderOut and call (*lpCallBack)(lpThis, lpmbOutX, lpmbInX).
If there is no corresponding output mesh for the input mesh, create it.
*******************/
HRESULT TraverseSubMeshes(HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			  void *lpThis, 
			  IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			  IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/***********************
Given three points, return the normal to the plane defined by these three points.
For a Right Handed system points A, B, and C should be in a CW order on the plane.
From CRC Standard Mathematical Tables 22nd Edition, page 380.  
Direction Numbers and Direction Cosines.
***********************/
inline D3DVECTOR ComputeNormal(D3DVECTOR d3dptA, D3DVECTOR d3dptB, D3DVECTOR d3dptC)
{
    const D3DVECTOR d3dptOne = d3dptB - d3dptA;
    const D3DVECTOR d3dptTwo = d3dptC - d3dptB;

    D3DVECTOR d3dptRetValue;
    d3dptRetValue.x = d3dptOne.y * d3dptTwo.z - d3dptOne.z * d3dptTwo.y;
    d3dptRetValue.y = d3dptOne.z * d3dptTwo.x - d3dptOne.x * d3dptTwo.z;
    d3dptRetValue.z = d3dptOne.x * d3dptTwo.y - d3dptOne.y * d3dptTwo.x;

    float Magnitude = (float)sqrt(d3dptRetValue.x * d3dptRetValue.x + 
                                  d3dptRetValue.y * d3dptRetValue.y + 
                                  d3dptRetValue.z * d3dptRetValue.z);

    // There's no good answer for how to get around this problem. The magnitude
    // here can be zero if the points given are not unique or are collinear. In
    // that case, there is no single normal, but rather there is a whole range of
    // them (either there are two unique points describing a line, or there is
    // only one describing a point).  We choose simply to return the un-normalized
    // vector, which is probably almost a zero vector.
    if (fabs(Magnitude) < 1.0e-5)
        return d3dptRetValue;
    else
        return d3dptRetValue/Magnitude;
}

float GetDlgItemFloat(HWND hDlg, int id);
BOOL SetDlgItemFloat( HWND hDlg, int id, float f );
double GetDlgItemDouble(HWND hDlg, int id);
BOOL SetDlgItemDouble( HWND hDlg, int id, double d );

#endif // __DXHELP3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxsurfb.cpp ===
/*******************************************************************************
* DXSurfB.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseSurface implementaion.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DXSurfB.h"
#include "new.h"

CDXBaseSurface::CDXBaseSurface() :
    m_ulLocks(0),
    m_ulThreadsWaiting(0),
    m_Height(0),
    m_Width(0),
    m_pFreePtr(NULL),
    m_dwStatusFlags(DXSURF_READONLY),
    m_dwAppData(0)
{
    m_hSemaphore = CreateSemaphore(NULL, 0, MAXLONG, NULL);
    m_ulNumInRequired = m_ulMaxInputs = 0;
}

HRESULT CDXBaseSurface::FinalConstruct()
{
    return m_hSemaphore ? S_OK : E_OUTOFMEMORY;
}

void CDXBaseSurface::FinalRelease()
{
    while (m_pFreePtr)
    {
        CDXBaseARGBPtr *pNext = m_pFreePtr->m_pNext;
        DeleteARGBPointer(m_pFreePtr);
        m_pFreePtr = pNext;
    }
    if (m_hSemaphore)
    {
        CloseHandle(m_hSemaphore);
    }
}

STDMETHODIMP CDXBaseSurface::GetGenerationId(ULONG *pGenerationId)
{
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseSurface::IncrementGenerationId(BOOL /*bRefresh */)
{
    Lock();
    m_dwGenerationId++;
    Unlock();
    return S_OK;
}


STDMETHODIMP CDXBaseSurface::GetObjectSize(ULONG *pcbSize)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::MapBoundsIn2Out
    (const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG /*ulOutIndex*/, DXBNDS *pOutBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pOutBounds, sizeof(*pOutBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pOutBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
}

STDMETHODIMP CDXBaseSurface::InitSurface(IUnknown *pDirectDraw,
                                         const DDSURFACEDESC * pDDSurfaceDesc,
                                         const GUID * pFormatId,
                                         const DXBNDS *pBounds,
                                         DWORD dwFlags)
{
    HRESULT hr = S_OK;
    if (pDDSurfaceDesc || DXIsBadReadPtr(pBounds, sizeof(*pBounds)) || pBounds->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        _EnterCritWith0PtrLocks();
        if (m_Width)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
        }
        else
        {
            CDXDBnds *pbnds = (CDXDBnds *)pBounds;
            hr = OnSetSize(pbnds->Width(), pbnds->Height());
        }
        Unlock();
    }
    return hr;
}


STDMETHODIMP CDXBaseSurface::GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleFormatEnum)
{
    HRESULT hr = S_OK;
    if (DX_IS_BAD_OPTIONAL_WRITE_PTR(pFormat) ||
        DX_IS_BAD_OPTIONAL_WRITE_PTR(pSampleFormatEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        if (pFormat) *pFormat = SurfaceCLSID();
        if (pSampleFormatEnum) *pSampleFormatEnum = SampleFormatEnum();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::GetBounds(DXBNDS* pBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pBounds, sizeof(*pBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::GetStatusFlags(DWORD* pdwStatusFlags)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pdwStatusFlags, sizeof(*pdwStatusFlags)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        *pdwStatusFlags = m_dwStatusFlags;
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::SetStatusFlags(DWORD dwStatusFlags )
{
    _EnterCritWith0PtrLocks();
    m_dwStatusFlags = dwStatusFlags | DXSURF_READONLY;
    m_dwGenerationId++;
    Unlock();
    return S_OK;
} 

STDMETHODIMP CDXBaseSurface::GetDirectDrawSurface(REFIID riid, void **ppSurface)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDXBaseSurface::LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut,
                                         DWORD dwFlags, REFIID riid, void **ppPointer,
                                         DWORD * pGenerationId)
{
    HRESULT hr = S_OK;
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();

    if (m_Width == 0)
    {
        hr = E_FAIL;
    }
    else
    {
        RECT r;
        r.top = r.left = 0;
        r.right = m_Width;
        r.bottom = m_Height;
        if (pBounds)
        {
            if (pBounds->eType != DXBT_DISCRETE)
            {
                hr = DXTERR_INVALID_BOUNDS;
            }
            else
            {
                ((CDXDBnds *)pBounds)->GetXYRect(r);
                if (r.top < 0 || r.left < 0 || (ULONG)r.right > m_Width || (ULONG)r.bottom > m_Height || r.bottom <= r.top || r.right <= r.left)
                {
                    hr = DXTERR_INVALID_BOUNDS;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CDXBaseARGBPtr * pPtr = m_pFreePtr;
            if (pPtr)
            {
                m_pFreePtr = pPtr->m_pNext;
            }
            else
            {
                hr = CreateARGBPointer(this, &pPtr);
            }
            if (SUCCEEDED(hr))
            {
                hr = pPtr->InitFromLock(r, ulTimeOut, dwFlags, riid, ppPointer);
                if (pGenerationId)
                {
                    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
                    {
                        hr = E_POINTER;
                    }
                    else
                    {
                        *pGenerationId = m_dwGenerationId;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    m_ulLocks++;
                }
                else
                {
                    pPtr->m_pNext = m_pFreePtr;
                    m_pFreePtr = pPtr;
                }
            }
        }
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();
    return hr;
}

void CDXBaseSurface::_InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock)
{
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();
    pPtrToUnlock->m_pNext = m_pFreePtr;
    m_pFreePtr = pPtrToUnlock;
    m_ulLocks--;
    if ((m_ulLocks == 0) && m_ulThreadsWaiting)
    {
        ReleaseSemaphore(m_hSemaphore, m_ulThreadsWaiting, NULL);
        m_ulThreadsWaiting = 0;
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();

    IUnknown *punkOuter = GetControllingUnknown();
    punkOuter->Release();   // Release pointer's reference to us
                            // which could kill us!  Don't touch
                            // any members after this point.
}

//
//  Picking interface needs to test the appropriate point for hit testing
//
HRESULT CDXBaseSurface::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec)
{
    HRESULT hr;
    IDXARGBReadPtr *pPtr;
    hr = LockSurface(&OutPoint, m_ulLockTimeOut, DXLOCKF_READ, 
                     IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        DXPMSAMPLE val;
        pPtr->UnpackPremult(&val, 1, FALSE);
        pPtr->Release();
        hr = val.Alpha ? DXT_S_HITOUTPUT : S_FALSE;
    }
    else
    {
        if (hr == DXTERR_INVALID_BOUNDS) hr = S_FALSE;
    }
    return hr;
}

/*****************************************************************************
* RegisterSurface (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseSurface::
RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_ALL, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}

//
//  CDXBaseARGBPtr
//
STDMETHODIMP CDXBaseARGBPtr::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IDXARGBReadPtr))
    {
        *ppv = (IDXARGBReadPtr *)this;
        m_ulRefCount++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::AddRef()
{
    return ++m_ulRefCount;
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::Release()
{
    --m_ulRefCount;
    ULONG c = m_ulRefCount;
    if (c == 0)
    {
        m_pSurface->_InternalUnlock(this);  // Don't touch members after this call.
    }
    return c;
}

HRESULT STDMETHODCALLTYPE CDXBaseARGBPtr::GetSurface(REFIID riid, void **ppSurface)
{
    return m_pSurface->GetControllingUnknown()->QueryInterface(riid, ppSurface);
}


DXSAMPLEFORMATENUM STDMETHODCALLTYPE CDXBaseARGBPtr::GetNativeType(DXNATIVETYPEINFO *pInfo)
{
    if (pInfo)
    {
        memset(pInfo, 0, sizeof(pInfo));
    }
    return m_pSurface->SampleFormatEnum();
}


void STDMETHODCALLTYPE CDXBaseARGBPtr::Move(long cSamples)
{
    m_FillInfo.x += cSamples;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToRow(ULONG y)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToXY(ULONG x, ULONG y)
{
    m_FillInfo.x = x + m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = Row + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
    *ppInfo = &m_RunInfo;
    return 1;
}

DXSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = false;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

DXPMSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = true;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackRect(const DXPACKEDRECTDESC *pDesc)
{
    DXPtrFillInfo FillInfo;
    FillInfo.pSamples = pDesc->pSamples;
    FillInfo.cSamples = pDesc->rect.right - pDesc->rect.left;
    FillInfo.x = pDesc->rect.left + m_LockedRect.left;
    FillInfo.bPremult = pDesc->bPremult;
    ULONG YLimit = pDesc->rect.bottom + m_LockedRect.top;
    for (FillInfo.y = pDesc->rect.top + m_LockedRect.top;
         FillInfo.y < YLimit;
         FillInfo.y++)
    {
        FillSamples(FillInfo);
        FillInfo.pSamples += FillInfo.cSamples;
    }
}

HRESULT CDXBaseARGBPtr::InitFromLock(const RECT & rect, ULONG /*ulTimeOut*/, DWORD dwLockFlags, REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    if (dwLockFlags & DXLOCKF_READWRITE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_LockedRect = rect;
        m_RunInfo.Count = rect.right - rect.left;
        if (m_pSurface->SampleFormatEnum() & DXPF_TRANSPARENCY)
        {
            m_RunInfo.Type = DXRUNTYPE_UNKNOWN;
        }
        else
        {
            m_RunInfo.Type = DXRUNTYPE_OPAQUE;
        }
        m_FillInfo.x = rect.left;
        m_FillInfo.y = rect.top;
        hr = QueryInterface(riid, ppv);
        if (SUCCEEDED(hr))
        {
            m_pSurface->GetControllingUnknown()->AddRef();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxsurfb.h ===
/*******************************************************************************
* DXSurfB.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseSurface implementation. It is
*   used as a base class to implement read-only procedural DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

#ifndef __DXSurfB_H__
#define __DXSurfB_H__

#include "dtbase.h"

class CDXBaseSurface;
class CDXBaseARGBPtr;

class ATL_NO_VTABLE CDXBaseSurface :
    public CDXBaseNTo1, 
    public IDXSurface,
    public IDXSurfaceInit
{
    /*=== ATL Setup ===*/
    public:
        BEGIN_COM_MAP(CDXBaseSurface)
        COM_INTERFACE_ENTRY(IDXSurface)
        COM_INTERFACE_ENTRY(IDXSurfaceInit)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
        END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

    /*=== Member Data ===*/
    public:
        ULONG           m_Height;
        ULONG           m_Width;
        DWORD           m_dwStatusFlags;
        HANDLE          m_hSemaphore;
        ULONG           m_ulLocks;
        ULONG           m_ulThreadsWaiting;
        CDXBaseARGBPtr  *m_pFreePtr;
        DWORD_PTR       m_dwAppData;
        CComAutoCriticalSection m_MPWorkProcCrit;   // See comments in LockSurface for details

        CDXBaseSurface();
        HRESULT FinalConstruct();
        void FinalRelease();

        //
        //  IDXBaseObject
        //
        STDMETHODIMP GetGenerationId(ULONG *pGenId);
        STDMETHODIMP IncrementGenerationId(BOOL bRefresh);
        STDMETHODIMP GetObjectSize(ULONG *pulze);

        //
        //  Overridden methods of DXTransform
        //
        STDMETHODIMP MapBoundsIn2Out(const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                     ULONG /*ulOutIndex*/, DXBNDS *pOutBounds );

        //
        //  IDXSurfaceInit
        //
        STDMETHODIMP InitSurface(IUnknown *pDirectDraw,
                                 const DDSURFACEDESC * pDDSurfaceDesc,
                                 const GUID * pFormatId,
                                 const DXBNDS *pBounds,
                                 DWORD dwFlags);
        //
        //  IDXSurface methods
        //
        STDMETHODIMP GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleEnum);
        STDMETHODIMP GetBounds(DXBNDS *pBounds);
        STDMETHODIMP GetStatusFlags(DWORD * pdwStatusFlags);
        STDMETHODIMP SetStatusFlags(DWORD dwStatusFlags);
        STDMETHODIMP GetDirectDrawSurface(REFIID riid, void **ppSurface);
        STDMETHODIMP LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags,
                                 REFIID riid, void **ppPointer, DWORD * pGenerationId);
        STDMETHODIMP SetAppData(DWORD_PTR dwAppData)
        {
            m_dwAppData = dwAppData;
            return S_OK;
        }
        STDMETHODIMP GetAppData(DWORD_PTR *pdwAppData)
        {
            if (DXIsBadWritePtr(pdwAppData, sizeof(*pdwAppData)))
            {
                return E_POINTER;
            }
            *pdwAppData = m_dwAppData;
            return S_OK;
        }


        //
        //  These methods aren't supported by procedural surfaces...
        //
        STDMETHODIMP GetColorKey(DXSAMPLE *pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP SetColorKey(DXSAMPLE pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP LockSurfaceDC(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags, IDXDCLock **ppDXLock)
        {
            return E_NOTIMPL;
        }

        //
        //  Surfaces should override this.
        //
        virtual ULONG OnGetObjectSize(void) { return sizeof(*this); }

        //
        //  This work procedure can be overridden by the derived class to improve performance
        //  or execution of the transform by directly producing data in large blocks if desired.
        //
        virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
        {
            return DXBitBlt(OutputSurface(), WI.OutputBnds, this, WI.DoBnds, m_dwBltFlags, m_ulLockTimeOut);
        }

        //
        //  Pick interface needs to test procedural surface.
        //
        virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec);

        //
        //  Helper functions
        //

        //  _EnterCritWith0PtrLocks()
        //
        //  This function is similar to calling Lock() except that it will wait until there
        //  are no pointers to the surface before returning.  This should be used whenever you
        //  are going to change the state of a surface, for example the size or some other
        //  property that the read pointers rely on.
        //
        //  WARNING:  You must be sure that one of the following is true:
        //      1) The objects critical section has NOT been taken prior to calling this function
        //   or 2) There are no pointers to the surface taken prior to calling this function.
        //
        //  Case 2 is useful in nested function calls.  If the outer function has already used this
        //  function to enter the critical section, then it is OK to use it on the inner nested
        //  function.  If the object's lock is taken, but there are outstanding pointers, YOU WILL DEADLOCK!
        //
        inline void _EnterCritWith0PtrLocks(void)
        {
            while (TRUE)
            {
                Lock();
                if (m_ulLocks == 0) break;
                m_ulThreadsWaiting++;
                Unlock();
                WaitForSingleObject(m_hSemaphore, INFINITE);
            }
        }
        //
        //  Virtual functions derived class MUST override
        //
        virtual const GUID & SurfaceCLSID() = 0;
        virtual HRESULT CreateARGBPointer(CDXBaseSurface * pSurface, CDXBaseARGBPtr ** ppPtr) = 0;
        virtual void DeleteARGBPointer(CDXBaseARGBPtr *pPtr) = 0;
    
        //
        //  Class may override this virtual function to return a more accurate enum
        //  for example, no transparency or translucency.
        //
        virtual DXSAMPLEFORMATENUM SampleFormatEnum()
        {
            return (DXSAMPLEFORMATENUM)(DXPF_NONSTANDARD | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY);
        }

        //
        //  Class may override this virtual function to perform necessary computations
        //  when the size of the surface changes.  The base class will only call this
        //  function from InitSurface.  You may choose to call it from other interfaces
        //  you implement, for example IDXTScaleOutput.
        //
        //  This function will be called with the critical section taken and 0 outstanding
        //  surface pointers (_EnterCritWith0PtrLocks).
        //  
        virtual HRESULT OnSetSize(ULONG Width, ULONG Height)
        {
            if (m_Width != Width || m_Height != Height)
            {
                m_Width = Width;
                m_Height = Height;
                m_dwGenerationId++;
            }
            return S_OK;
        }

        //
        //  Internal functions for base class
        //
        void _InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock);

        //
        //  Static member function for registering surface
        //
        static HRESULT RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                       ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);
};

struct DXPtrFillInfo
{
    DXBASESAMPLE *  pSamples;
    ULONG           cSamples;
    ULONG           x;
    ULONG           y;
    BOOL            bPremult;
};


class CDXBaseARGBPtr : public IDXARGBReadPtr
{
public:
    CDXBaseARGBPtr    * m_pNext;
    CDXBaseSurface    * m_pSurface;
    ULONG               m_ulRefCount;
    DXPtrFillInfo       m_FillInfo;
    RECT                m_LockedRect;
    DXRUNINFO           m_RunInfo;
    
    CDXBaseARGBPtr(CDXBaseSurface *pSurface) :
        m_pSurface(pSurface),
        m_pNext(NULL),
        m_ulRefCount(0) {}

    //
    //  IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    //
    //  IDXARGBReadPtr
    //
    HRESULT STDMETHODCALLTYPE GetSurface(REFIID riid, void **ppSurface);
    DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType(DXNATIVETYPEINFO *pInfo);
    void STDMETHODCALLTYPE Move(long cSamples);
    void STDMETHODCALLTYPE MoveToRow(ULONG y);
    void STDMETHODCALLTYPE MoveToXY(ULONG x, ULONG y);
    ULONG STDMETHODCALLTYPE MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo);
    DXSAMPLE *STDMETHODCALLTYPE Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    DXPMSAMPLE *STDMETHODCALLTYPE UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    void STDMETHODCALLTYPE UnpackRect(const DXPACKEDRECTDESC *pDesc);

    //
    //  Virtual function derived class MUST override
    //
    virtual void FillSamples(const DXPtrFillInfo & FillInfo) = 0;

    //
    //  Virtual functions derived class MAY want to override (but you will need to call the base class too)
    //
    virtual HRESULT InitFromLock(const RECT & rect, ULONG ulTimeOut, DWORD dwLockFlags, REFIID riid, void ** ppv);
};

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[2]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 2, cat, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_AUTHORING_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[3]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            cat[2] = CATID_DXAuthoringTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 3, cat, 0, NULL, bRegister); \
        } 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxtguid.c ===
//
//  This .CPP file should be included once in your project.  It defines all GUIDs
//  used by DXTransforms as well as the Pixel formats for DX Surfaces
//

#define DX_DECLARE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
//
//  Pixel format definitions
//
// {e436eb78-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F3-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB2, 
0xbbf7d3f3, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb79-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {e436eb7a-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F6-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB332, 
0xbbf7d3f6, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D3F7-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB4444, 
0xbbf7d3f7, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7b-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F9-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR565, 
0xbbf7d3f9, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7c-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FB-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB1555, 
0xbbf7d3fb, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7d-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FD-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR24, 
0xbbf7d3fd, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7e-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FF-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR32, 
0xbbf7d3ff, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D401-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ABGR32, 
0xbbf7d401, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {773c9ac0-3274-11d0-B724-00aa006c1A01}
DX_DECLARE_GUID(DDPF_ARGB32, 
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 );
// {BBF7D403-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_PMARGB32, 
0xbbf7d403, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94E-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A1, 
0x7846f94e, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94F-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A2, 
0x7846f94f, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F950-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A4, 
0x7846f950, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F951-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A8, 
0x7846f951, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F952-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z8, 
0x7846f952, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F953-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z16, 
0x7846f953, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F954-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z24, 
0x7846f954, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F955-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z32, 
0x7846f955, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
//
//  Component categories
//
// {C501EDBE-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXImageTransform, 
0xc501edbe, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {C501EDBF-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DX3DTransform, 
0xc501edbf, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {ACAC94FC-E5CF-11d1-9066-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXAuthoringTransform,
0xacac94fc, 0xe5cf, 0x11d1, 0x90, 0x66, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {52BA7097-B52C-11d1-81CB-0000F87557DB}
DX_DECLARE_GUID(CATID_DXSurface, 
0x52ba7097, 0xb52c, 0x11d1, 0x81, 0xcb, 0x0, 0x0, 0xf8, 0x75, 0x57, 0xdb);

//
//  Service IDs.  
//
//  NOTE:  The service ID for direct draw is == IID_IDirectDraw3 for compatibility
//         with trident service ID's.  This should be the service ID for DirectDraw
//         no matter what version.
//
DX_DECLARE_GUID(SID_SDirectDraw,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
//
//  The service ID for Direct 3D Retain Mode is the same as IID_IDirect3DRM
//  
DX_DECLARE_GUID(SID_SDirect3DRM,
0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

//
//  The service ID for DirectDraw3 is the same as IID_IDirectDraw3
//  
DX_DECLARE_GUID(SID_SDirectDraw3,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxtdbg.h ===
/*******************************************************************************
* DXTDbg.h *
*----------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTDbg_h
#define DXTDbg_h

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#define DXTDBG_FUNC_TRACE   1
#define DXTDBG_INFO         2

class CDXTDbgFlags
{
  public:
    DWORD m_F;
    CDXTDbgFlags()
    {
        m_F = 0;
        HKEY hkResult;
        DWORD dwDisposition;
        if( RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("DXTDbgFlags"), 0, NULL, 0,
                            KEY_ALL_ACCESS, NULL, &hkResult, &dwDisposition )
                            == ERROR_SUCCESS )
        {
            if( dwDisposition == REG_CREATED_NEW_KEY )
            {
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&m_F, sizeof( m_F ) );
            }
            else
            {
                DWORD BuffSize = sizeof( m_F );
                RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, (PBYTE)&m_F, &BuffSize );
            }
            RegCloseKey( hkResult );
        }
    }
};

class CDXTDbgScope
{
  public:
    static CDXTDbgFlags m_DebugFlags; 
    PCHAR  m_pFuncName;
    CDXTDbgScope( PCHAR pFuncName )
    {
        m_pFuncName = pFuncName;
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
        }
    }
    ~CDXTDbgScope()
    {
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
        }
    }
};

//=== User macros ==============================================================
#ifdef _DEBUG
#define DXTDBG_FUNC( name ) CDXTDbgScope DXTDbgScope( name ); 
#define DXTDBG_MSG0( reportType, format ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF0( reportType, format );
#define DXTDBG_MSG1( reportType, format, arg1 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF4( reportType, format, arg1, arg2, arg3, arg4 )
#else
#define DXTDBG_FUNC( name )
#define DXTDBG_MSG0( reportType, format )
#define DXTDBG_MSG1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 )
#endif

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxtmpl.h ===
/*****************************************************************************
* DXTmpl.h *
*-----------*
*       This is the header file contains the DX collection class templates. It
*   has been derived from the MFC collection templates for compatibility.
*-----------------------------------------------------------------------------
*   Created by: Ed Connell                     Date: 05/17/95
*
*****************************************************************************/
#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        if (p == NULL)
            return NULL;
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // oh well, it's better than crashing
        if (pNewData == NULL)
            return;

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];

            // oh well, it's better than crashing
            if (pNewData == NULL)
                return;

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];

        // oh well, it's better than crashing
        if (m_pHashTable == NULL)
            return;

        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxhelper.h ===
/*******************************************************************************
* DXHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/11/95
*  Copyright (C) 1995 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXHelper_h
#define DXHelper_h

#include <DXTError.h>
#include <DXBounds.h>
#include <DXTrans.h>

#include <limits.h>
#include <crtdbg.h>
#include <malloc.h>
#include <math.h>

//=== Constants ==============================================================

#define DX_MMX_COUNT_CUTOFF 16

//=== Class, Enum, Struct and Union Declarations =============================

/*** DXLIMAPINFO
*   This structure is used by the array linear interpolation and image
*   filtering routines.
*/
typedef struct DXLIMAPINFO
{
    float   IndexFrac;
    USHORT  Index;
    BYTE    Weight;
} DXLIMAPINFO;

//
//  Declare this class as a global to use for determining when to call MMX optimized
//  code.  You can use MinMMXOverCount to determine if MMX instructions are present.
//  Typically, you would only want to use MMX instructions when you have a reasonably
//  large number of pixels to work on.  In this case your code can always be coded like
//  this:
//
//  if (CountOfPixelsToDo >= g_MMXInfo.MinMMXOverCount())
//  {
//      Do MMX Stuff
//  } else {
//      Do integer / float based stuff
//  }    
//  
//  If you code your MMX sequences like this, you will not have to use a special test
//  for the presence of MMX since the MinMMXOverCount will be set to 0xFFFFFFFF if there
//  is no MMX present on the processor.
//
//  You do not need to use this unless your module needs to conditionally execute MMX vs
//  non-MMX code.  If you only call the helper functions provided by DXTrans.Dll, such as
//  DXOverArrayMMX, you do NOT need this test.  You can always call these functions and they
//  will use the MMX code path only when MMX instructions are present.
//
class CDXMMXInfo
{
    ULONG m_MinMMXOver;
public:
    CDXMMXInfo()
    {
#ifndef _X86_
        m_MinMMXOver = 0xFFFFFFFF;
#else
        m_MinMMXOver = DX_MMX_COUNT_CUTOFF;
        __try
        {
            __asm
            {
                //--- Try the MMX exit multi-media state instruction
                EMMS;
            }
        }
        __except( GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION )
        {
            //--- MMX instructions not available
            m_MinMMXOver = 0xFFFFFFFF;
        }
#endif
    }
    inline ULONG MinMMXOverCount() { return m_MinMMXOver; }
};



//=== Function Prototypes ==========================================
_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray( const DXBASESAMPLE* pSamps, DXLIMAPINFO* pMapInfo,
                              DXBASESAMPLE* pResults, DWORD dwResultCount );
_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray( const DXBASESAMPLE* pSamps, PUSHORT pIndexes,
                              PBYTE pWeights, DXBASESAMPLE* pResults,
                              DWORD dwResultCount );

//
//  DXOverArray
//
//  Composits an array of source samples over the samples in the pDest buffer.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArray(DXPMSAMPLE* pDest, const DXPMSAMPLE* pSrc, ULONG nCount);

//
//  DXOverArrayMMX
//
//  Identical to DXOverArray except that the MMX instruction set will be used for
//  large arrays of samples.  If the CPU does not support MMX, you may still call
//  this function, which will perform the same operation without the use of the MMX
//  unit.
//
//  Note that it is LESS EFFICIENT to use this function if the majority of the pixels
//  in the pSrc buffer are either clear (alpha 0) or opaque (alpha 0xFF).  This is 
//  because the MMX code must process every pixel and can not special case clear or
//  opaque pixels.  If there are a large number of translucent pixels then this function
//  is much more efficent than DXOverArray.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArrayMMX(DXPMSAMPLE* pDest, const DXPMSAMPLE* pSrc, ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the color (val)
//            over the pDest samples.
//  val     - The premultiplied color value to composit over the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstOverArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the samples
//            in the buffer over the color (val).
//  val     - The premultiplied color value to composit under the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstUnderArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//===================================================================================
//
//  Dithering Helpers
//
//  Image transforms are sometimes asked to dither their output.  This helper function
//  should be used by all image transforms to enusure a consistant dither pattern.
//
//  DXDitherArray is used to dither pixels prior to writing them to a DXSurface.
//  The caller must fill in the DXDITHERDESC structure, setting X and Y to the
//  output surface X,Y coordinates that the pixels will be placed in.  The samples
//  will be modified in place.
//
//  Once the samples have been dithered, they should be written to or composited with
//  the destination surface.
//
#define DX_DITHER_HEIGHT    4       // The dither pattern is 4x4 pixels
#define DX_DITHER_WIDTH     4

typedef struct DXDITHERDESC
{
    DXBASESAMPLE *      pSamples;       // Pointer to the 32-bit samples to dither
    ULONG               cSamples;       // Count of number of samples in pSamples buffer
    ULONG               x;              // X coordinate of the output surface
    ULONG               y;              // Y coordinate of the output surface
    DXSAMPLEFORMATENUM  DestSurfaceFmt; // Pixel format of the output surface
} DXDITHERDESC;

_DXTRANS_IMPL_EXT void WINAPI
    DXDitherArray(const DXDITHERDESC *pDitherDesc);

//=== Enumerated Set Definitions =============================================


//=== Function Type Definitions ==============================================


//=== Class, Struct and Union Definitions ====================================


//=== Inline Functions =======================================================

//===================================================================================
//
//  Memory allocation helpers.
//
//  These macros are used to allocate arrays of samples from the stack (using _alloca)
//  and cast them to the appropriate type.  The ulNumSamples parameter is the count
//  of samples required.
//
#define DXBASESAMPLE_Alloca( ulNumSamples ) \
    (DXBASESAMPLE *)_alloca( (ulNumSamples) * sizeof( DXBASESAMPLE ) )

#define DXSAMPLE_Alloca( ulNumSamples ) \
    (DXSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXSAMPLE ) )

#define DXPMSAMPLE_Alloca( ulNumSamples ) \
    (DXPMSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXPMSAMPLE ) )

//===================================================================================
//
//  Critical section helpers.
//
//  These C++ classes, CDXAutoObjectLock and CDXAutoCritSecLock are used within functions
//  to automatically claim critical sections upon constuction, and the critical section
//  will be released when the object is destroyed (goes out of scope).
//
//  The macros DXAUTO_OBJ_LOCK and DX_AUTO_SEC_LOCK(s) are normally used at the beginning
//  of a function that requires a critical section.  Any exit from the scope in which the
//  auto-lock was taken will automatically release the lock.
//

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used
class CDXAutoObjectLock
{
  protected:
    CComObjectRootEx<CComMultiThreadModel>* m_pObject;

  public:
    CDXAutoObjectLock(CComObjectRootEx<CComMultiThreadModel> * const pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CDXAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define DXAUTO_OBJ_LOCK CDXAutoObjectLock lck(this);
#define DXAUTO_OBJ_LOCK_( t ) CDXAutoObjectLock lck(t);

class CDXAutoCritSecLock
{
  protected:
    CComAutoCriticalSection* m_pSec;

  public:
    CDXAutoCritSecLock(CComAutoCriticalSection* pSec)
    {
        m_pSec = pSec;
        m_pSec->Lock();
    };

    ~CDXAutoCritSecLock()
    {
        m_pSec->Unlock();
    };
};

#define DXAUTO_SEC_LOCK( s ) CDXAutoCritSecLock lck(s);
#endif  // __ATLCOM_H__

//--- This function is used to compute the coefficient for a gaussian filter coordinate
inline float DXGaussCoeff( double x, double y, double Sigma )
{
    double TwoSigmaSq = 2 * ( Sigma * Sigma );
    return (float)(exp( ( -(x*x + y*y) / TwoSigmaSq  ) ) /
                        ( 3.1415927 * TwoSigmaSq ));
}

//--- This function is used to initialize a gaussian convolution filter
inline void DXInitGaussianFilter( float* pFilter, ULONG Width, ULONG Height, double Sigma )
{
    int i, NumCoeff = Width * Height;
    float  val, CoeffAdjust, FilterSum = 0.;
    double x, y;
    double LeftX   = -(double)(Width / 2);
    double RightX  =   Width - LeftX;
    double TopY    = -(double)(Height / 2);
    double BottomY =   Height - TopY;

    for( y = -TopY; y <= BottomY; y += 1. )
    {
        for( x = -LeftX; x <= RightX; x += 1. )
        {
            val = DXGaussCoeff( x, y, Sigma );
            pFilter[i++] = val;
        }
    }

    //--- Normalize filter (make it sum to 1.0)
    for( i = 0; i < NumCoeff; ++i ) FilterSum += pFilter[i];

    if( FilterSum < 1. )
    {
        CoeffAdjust = 1.f / FilterSum;
        for( i = 0; i < NumCoeff; ++i )
        {
            pFilter[i] *= CoeffAdjust;
        }
    }

} /* DXInitGaussianFilter*/

//
//  DXConvertToGray
//
//  Translates a color sample to a gray scale sample
//
//  Sample  - The sample to convert to gray scale.
//  Return value is the gray scale sample.
//
inline DXBASESAMPLE DXConvertToGray( DXBASESAMPLE Sample )
{
    DWORD v = Sample;
    DWORD r = (BYTE)(v >> 16);
    DWORD g = (BYTE)(v >> 8);
    DWORD b = (BYTE)(v);
    DWORD sat = (r*306 + g*601 + b*117) / 1024;
    v &= 0xFF000000;
    v |= (sat << 16) | (sat << 8) | sat;
    return v;
} /* DXConvertToGray */

//--- This returns into the destination the value of the source
//  sample scaled by its own alpha (producing a premultiplied alpha sample)
//
inline DXPMSAMPLE DXPreMultSample(const DXSAMPLE & Src)
{
    if(Src.Alpha == 255 )
    {
        return (DWORD)Src;
    }
    else if(Src.Alpha == 0 )
    {
        return 0;
    }
    else
    {
        unsigned t1, t2;
        t1 = (Src & 0x00ff00ff) * Src.Alpha + 0x00800080;
        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

        t2 = (((Src >> 8) & 0x000000ff) | 0x01000000) * Src.Alpha + 0x00800080;
        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        return (t1 | t2);
    }
} /* DXPreMultSample */

inline DXPMSAMPLE * DXPreMultArray(DXSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF)
        {
            if (SrcAlpha == 0)
            {
                pBuffer[i] = 0;
            }
            else
            {
                DWORD S = pBuffer[i];
                DWORD t1 = (S & 0x00ff00ff) * SrcAlpha + 0x00800080;
                t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                DWORD t2 = (((S >> 8) & 0x000000ff) | 0x01000000) * SrcAlpha + 0x00800080;
                t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

                pBuffer[i] = (t1 | t2);
            }
        }
    }
    return (DXPMSAMPLE *)pBuffer;
}


inline DXSAMPLE DXUnPreMultSample(const DXPMSAMPLE & Src)
{
    if(Src.Alpha == 255 || Src.Alpha == 0)
    {
        return (DWORD)Src;
    }
    else
    {
        DXSAMPLE Dst;
        Dst.Blue  = (BYTE)((Src.Blue  * 255) / Src.Alpha);
        Dst.Green = (BYTE)((Src.Green * 255) / Src.Alpha);
        Dst.Red   = (BYTE)((Src.Red   * 255) / Src.Alpha);
        Dst.Alpha = Src.Alpha;
        return Dst;
    }
} /* DXUnPreMultSample */

inline DXSAMPLE * DXUnPreMultArray(DXPMSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF && SrcAlpha != 0)
        {
            pBuffer[i].Blue  = (BYTE)((pBuffer[i].Blue  * 255) / SrcAlpha);
            pBuffer[i].Green = (BYTE)((pBuffer[i].Green * 255) / SrcAlpha);
            pBuffer[i].Red   = (BYTE)((pBuffer[i].Red   * 255) / SrcAlpha);
        }
    }
    return (DXSAMPLE *)pBuffer;
}


//
//  This returns the result of 255-Alpha which is computed by doing a NOT
//
inline BYTE DXInvertAlpha( BYTE Alpha ) { return (BYTE)~Alpha; }

inline DWORD DXScaleSample( DWORD Src, ULONG beta )
{
    ULONG t1, t2;

    t1 = (Src & 0x00ff00ff) * beta + 0x00800080;
    t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2 = ((Src >> 8) & 0x00ff00ff) * beta + 0x00800080;
    t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (DWORD)(t1 | t2);
}


inline DWORD DXScaleSamplePercent( DWORD Src, float Percent )
{
    if (Percent > (254.0f / 255.0f)) {
        return Src;
    }
    else
    {
        return DXScaleSample(Src, (BYTE)(Percent * 255));
    }
}

inline void DXCompositeOver(DXPMSAMPLE & Dst, const DXPMSAMPLE & Src)
{
    if (Src.Alpha)
    {
        ULONG Beta = DXInvertAlpha(Src.Alpha);
        if (Beta)
        {
            Dst = Src + DXScaleSample(Dst, Beta);
        }
        else
        {
            Dst = Src;
        }
    }
}


inline DXPMSAMPLE DXCompositeUnder(DXPMSAMPLE Dst, DXPMSAMPLE Src )
{
    return Dst + DXScaleSample(Src, DXInvertAlpha(Dst.Alpha));
}


inline DXBASESAMPLE DXApplyLookupTable(const DXBASESAMPLE Src, const BYTE * pTable)
{
    DXBASESAMPLE Dest;
    Dest.Blue   = pTable[Src.Blue];
    Dest.Green  = pTable[Src.Green];
    Dest.Red    = pTable[Src.Red];
    Dest.Alpha  = pTable[Src.Alpha];
    return Dest;
}

inline DXBASESAMPLE * DXApplyLookupTableArray(DXBASESAMPLE *pBuffer, ULONG cSamples, const BYTE * pTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        DWORD v = pBuffer[i];
        DWORD a = pTable[v >> 24];
        DWORD r = pTable[(BYTE)(v >> 16)];
        DWORD g = pTable[(BYTE)(v >> 8)];
        DWORD b = pTable[(BYTE)v];
        pBuffer[i] = (a << 24) | (r << 16) | (g << 8) | b;
    }
    return pBuffer;
}

inline DXBASESAMPLE * DXApplyColorChannelLookupArray(DXBASESAMPLE *pBuffer,
                                                     ULONG cSamples,
                                                     const BYTE * pAlphaTable,
                                                     const BYTE * pRedTable,
                                                     const BYTE * pGreenTable,
                                                     const BYTE * pBlueTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        pBuffer[i].Blue   = pBlueTable[pBuffer[i].Blue];
        pBuffer[i].Green  = pGreenTable[pBuffer[i].Green];
        pBuffer[i].Red    = pRedTable[pBuffer[i].Red];
        pBuffer[i].Alpha  = pAlphaTable[pBuffer[i].Alpha];
    }
    return pBuffer;
}


//
//  CDXScale helper class
//
//  This class uses a pre-computed lookup table to scale samples.  For scaling large
//  arrays of samples to a constant scale, this is much faster than using even MMX
//  instructions.  This class is usually declared as a member of another class and
//  is most often used to apply a global opacity to a set of samples.
//
//  When using this class, you must always check for the two special cases of clear
//  and opaque before calling any of the scaling member functions.  Do this by using
//  the ScaleType() inline function.  Your code should look somthing like this:
//
//  if (ScaleType() == DXRUNTYPE_CLEAR)
//      Do whatever you do for a 0 alpha set of samples -- usually just ignore them
//  else if (ScaleType() == DXRUNTYPE_OPAQUE)
//      Do whatever you would do for a non-scaled set of samples
//  else
//      Scale the samples by using ScaleSample or one of the ScaleArray members
//
//  If you call any of the scaling members when the ScaleType() is either clear or
//  opaque, you will GP fault becuase the lookup table will not be allocated.
//
//  The scale can be set using either a floating point number between 0 and 1 using:
//      CDXScale::SetScale / CDXScale::GetScale
//  or you can use a byte integer value by using:
//      CDXScale::SetScaleAlphaValue / CDXScale::GetScaleAlphaValue
//
class CDXScale
{
private:
    float       m_Scale;
    BYTE        m_AlphaScale;
    BYTE        *m_pTable;

HRESULT InternalSetScale(BYTE Scale)
{
    if (m_AlphaScale == Scale) return S_OK;
    if (Scale == 0 || Scale == 255) 
    {
        delete m_pTable;
        m_pTable = NULL;
    }
    else
    {
        if(!m_pTable)
        {
            m_pTable = new BYTE[256];
            if(!m_pTable )
            {
                return E_OUTOFMEMORY;
            }
        }
        for (int i = 0; i < 256; ++i )
        {
            m_pTable[i] = (BYTE)((i * Scale) / 255);
        }
    }
    m_AlphaScale = Scale;
    return S_OK;
}
public:
    CDXScale() : 
      m_Scale(1.0f),
      m_AlphaScale(0xFF),
      m_pTable(NULL)
      {}
    ~CDXScale()
    {
        delete m_pTable;
    }
    DXRUNTYPE ScaleType() 
    {
        if (m_AlphaScale == 0) return DXRUNTYPE_CLEAR;
        if (m_AlphaScale == 0xFF) return DXRUNTYPE_OPAQUE;
        return DXRUNTYPE_TRANS;
    }
    HRESULT SetScaleAlphaValue(BYTE Alpha)
    {
        HRESULT hr = InternalSetScale(Alpha);
        if (SUCCEEDED(hr))
        {
            m_Scale = ((float)Alpha) / 255.0f;
        }
        return hr;
    }
    BYTE GetScaleAlphaValue(void)
    {
        return m_AlphaScale;
    }
    HRESULT SetScale(float Scale)
    {
        HRESULT hr = S_OK;
        if(( Scale < 0.0f ) || ( Scale > 1.0f ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            ULONG IntScale = (ULONG)(Scale * 256.0f);     // Round up alpha (.9999 = 255 = Solid)
            if (IntScale > 255) 
            {
                IntScale = 255;
            }
            hr = SetScaleAlphaValue((BYTE)IntScale);
            if (SUCCEEDED(hr))
            {
                m_Scale = Scale;
            }
        }
        return hr;
    }
    float GetScale() const
    {
        return m_Scale;
    }
    DXRUNTYPE ScaleType() const
    {
        return (m_pTable ? DXRUNTYPE_TRANS : (m_AlphaScale ? DXRUNTYPE_OPAQUE : DXRUNTYPE_CLEAR));
    }
    DWORD ScaleSample(const DWORD s) const
    {
        return DXApplyLookupTable((DXBASESAMPLE)s, m_pTable);
    }
    DXBASESAMPLE * ScaleBaseArray(DXBASESAMPLE * pBuffer, ULONG cSamples) const
    {
        return DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXPMSAMPLE * ScalePremultArray(DXPMSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXPMSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArray(DXSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArrayAlphaOnly(DXSAMPLE *pBuffer, ULONG cSamples) const
    {
        const BYTE *pTable = m_pTable;
        for (ULONG i = 0; i < cSamples; i++)
        {
            pBuffer[i].Alpha  = pTable[pBuffer[i].Alpha];
        }
        return pBuffer;
    }
};

inline DWORD DXWeightedAverage( DXBASESAMPLE S1, DXBASESAMPLE S2, ULONG Wgt )
{
    _ASSERT( Wgt < 256 );
    ULONG t1, t2;
    ULONG InvWgt = Wgt ^ 0xFF;

    t1  = (((S1 & 0x00ff00ff) * Wgt) + ((S2 & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t1  = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2  = ((((S1 >> 8) & 0x00ff00ff) * Wgt) + (((S2 >> 8) & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t2  = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (t1 | t2);
} /* DXWeightedAverage */

inline void DXWeightedAverageArray( DXBASESAMPLE* pS1, DXBASESAMPLE* pS2, ULONG Wgt,
                                    DXBASESAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    for( DWORD i = 0; i < dwCount; ++i )
    {
        pResults[i] = DXWeightedAverage( pS1[i], pS2[i], Wgt );
    }
} /* DXWeightedAverageArray */

inline void DXWeightedAverageArrayOver( DXPMSAMPLE* pS1, DXPMSAMPLE* pS2, ULONG Wgt,
                                        DXPMSAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    DWORD i;

    if( Wgt == 255 )
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXCompositeOver( pResults[i], pS1[i] );
        }
    }
    else
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXPMSAMPLE Avg = DXWeightedAverage( (DXBASESAMPLE)pS1[i],
                                                (DXBASESAMPLE)pS2[i], Wgt );
            DXCompositeOver( pResults[i], Avg );
        }
    }

} /* DXWeightedAverageArrayOver */

inline void DXScalePremultArray(DXPMSAMPLE *pBuffer, ULONG cSamples, BYTE Weight)
{
    for (DXPMSAMPLE *pBuffLimit = pBuffer + cSamples; pBuffer < pBuffLimit; pBuffer++)
    {
        *pBuffer = DXScaleSample(*pBuffer, Weight);
    }
}



//
//
inline HRESULT DXClipToOutputWithPlacement(CDXDBnds & LogicalOutBnds, const CDXDBnds * pClipBnds, CDXDBnds & PhysicalOutBnds, const CDXDVec *pPlacement)
{
    if(pClipBnds && (!LogicalOutBnds.IntersectBounds(*pClipBnds)))
    {
        return S_FALSE;    // no intersect, we're done
    }
    else
    {
        CDXDVec vClipPos(false);
        LogicalOutBnds.GetMinVector( vClipPos );
        if (pPlacement)
        {
            vClipPos -= *pPlacement;
        }
        PhysicalOutBnds += vClipPos;
        if (!LogicalOutBnds.IntersectBounds(PhysicalOutBnds))
        {
            return S_FALSE;
        }
        PhysicalOutBnds = LogicalOutBnds;
        PhysicalOutBnds -= vClipPos;
    }
    return S_OK;
}



//
//  Helper for converting a color ref to a DXSAMPLE
//
inline DWORD DXSampleFromColorRef(COLORREF cr)
{
    DXSAMPLE Samp(0xFF, GetRValue(cr), GetGValue(cr), GetBValue(cr));
    return Samp;
}

//
//  Fill an entire surface with a color
//
inline HRESULT DXFillSurface( IDXSurface *pSurface, DXPMSAMPLE Color,
                              BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( NULL, ulTimeOut, DXLOCKF_READWRITE, 
                                        IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurface */

//
//  Fill a specified sub-rectangle of a surface with a color.
//
inline HRESULT DXFillSurfaceRect( IDXSurface *pSurface, RECT & rect, DXPMSAMPLE Color,
                                  BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    CDXDBnds bnds(rect);
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( &bnds, ulTimeOut, DXLOCKF_READWRITE, 
                                         IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurfaceRect */



//
//  The DestBnds height and width must be greater than or equal to the source bounds.
//
//  The dwFlags parameter uses the flags defined by IDXSurfaceFactory::BitBlt:
// 
//    DXBOF_DO_OVER
//    DXBOF_DITHER
//
inline HRESULT DXBitBlt(IDXSurface * pDest, const CDXDBnds & DestBnds, 
                        IDXSurface * pSrc, const CDXDBnds & SrcBnds, 
                        DWORD dwFlags, ULONG ulTimeout)
{
    IDXARGBReadPtr * pIn;
    HRESULT hr;
    hr = pSrc->LockSurface( &SrcBnds, INFINITE,
                            (dwFlags & DXBOF_DO_OVER) ? (DXLOCKF_READ | DXLOCKF_WANTRUNINFO) : DXLOCKF_READ,
                            IID_IDXARGBReadPtr, (void**)&pIn, NULL);
    if(SUCCEEDED(hr))
    {
        IDXARGBReadWritePtr * pOut;
        hr = pDest->LockSurface( &DestBnds, INFINITE, DXLOCKF_READWRITE,
                                 IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
        if (SUCCEEDED(hr))
        {
            DXSAMPLEFORMATENUM InNativeType = pIn->GetNativeType(NULL);
            DXSAMPLEFORMATENUM OutNativeType = pOut->GetNativeType(NULL);
            BOOL bSrcIsOpaque = !(InNativeType & (DXPF_TRANSLUCENCY | DXPF_TRANSPARENCY));
            const ULONG Width = SrcBnds.Width();
            DXPMSAMPLE *pSrcBuff = NULL;
            if( InNativeType != DXPF_PMARGB32 )
            {
                pSrcBuff = DXPMSAMPLE_Alloca(Width);
            }
            //
            //  Don't dither unless the dest has a greater error term than the source.
            //
            if ((dwFlags & DXBOF_DITHER) && 
                ((OutNativeType & DXPF_ERRORMASK) <= (InNativeType & DXPF_ERRORMASK)))
            {
                dwFlags &= (~DXBOF_DITHER);
            }
            if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
            {
                //--- Allocate a working output buffer if necessary
                DXPMSAMPLE *pDestBuff = NULL;
                if( OutNativeType != DXPF_PMARGB32 )
                {
                    pDestBuff = DXPMSAMPLE_Alloca(Width);
                }
                //--- Process each output row
                //    Note: Output coordinates are relative to the lock region
                const ULONG Height = SrcBnds.Height();
                if (dwFlags & DXBOF_DITHER)
                {
                    DXPMSAMPLE * pSrcDitherBuff = pSrcBuff;
                    if (pSrcDitherBuff == NULL)
                    {
                        pSrcDitherBuff = DXPMSAMPLE_Alloca(Width);
                    }
                    const BOOL bCopy = ((dwFlags & DXBOF_DO_OVER) == 0);
                    //
                    //  Set up the dither descriptor (some things are constant)
                    //
                    DXDITHERDESC dd;
                    dd.pSamples = pSrcDitherBuff;
                    dd.DestSurfaceFmt = OutNativeType;
                    for(ULONG Y = 0; Y < Height; ++Y )
                    {
                        dd.x = DestBnds.Left();
                        dd.y = DestBnds.Top() + Y;
                        const DXRUNINFO *pRunInfo;
                        ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                        pOut->MoveToRow( Y );
                        do
                        {
                            ULONG ulRunLen = pRunInfo->Count;
                            if (pRunInfo->Type == DXRUNTYPE_CLEAR)
                            {
                                pIn->Move(ulRunLen);
                                if (bCopy)
                                {
                                    //
                                    //  The only way to avoid calling a constructor function to create
                                    //  a pmsample from 0 is to declare a variable and then assign it!
                                    //
                                    DXPMSAMPLE NullColor;
                                    NullColor = 0;
                                    pOut->FillAndMove(pSrcDitherBuff, NullColor, ulRunLen, FALSE);
                                }
                                else
                                {
                                    pOut->Move(ulRunLen);
                                }
                                dd.x += ulRunLen;
                            }
                            else
                            {
                                pIn->UnpackPremult(pSrcDitherBuff, ulRunLen, TRUE);
                                dd.cSamples = ulRunLen;
                                DXDitherArray(&dd);
                                dd.x += ulRunLen;
                                if (bCopy || pRunInfo->Type == DXRUNTYPE_OPAQUE)
                                {
                                    pOut->PackPremultAndMove(pSrcDitherBuff, ulRunLen);
                                }
                                else
                                {
                                    pOut->OverArrayAndMove(pDestBuff, pSrcDitherBuff, ulRunLen);
                                }
                            }
                            pRunInfo++;
                            cRuns--;
                        } while (cRuns);
                    }
                }
                else
                {
                    for(ULONG Y = 0; Y < Height; ++Y )
                    {
                        const DXRUNINFO *pRunInfo;
                        ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                        pOut->MoveToRow( Y );
                        do
                        {
                            ULONG ulRunLen = pRunInfo->Count;
                            switch (pRunInfo->Type)
                            {
                              case DXRUNTYPE_CLEAR:
                                pIn->Move(ulRunLen);
                                pOut->Move(ulRunLen);
                                break;
                              case DXRUNTYPE_OPAQUE:
                                pOut->CopyAndMoveBoth(pDestBuff, pIn, ulRunLen, TRUE);
                                break;
                              case DXRUNTYPE_TRANS:
                              {
                                DXPMSAMPLE *pSrc = pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE);
                                DXPMSAMPLE *pDest = pOut->UnpackPremult(pDestBuff, ulRunLen, FALSE);                 
                                DXOverArrayMMX(pDest, pSrc, ulRunLen);
                                pOut->PackPremultAndMove(pDestBuff, ulRunLen);
                                break;
                              }

                              case DXRUNTYPE_UNKNOWN:
                              {
                                pOut->OverArrayAndMove(pDestBuff,
                                                       pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE),
                                                       ulRunLen);
                                break;
                              }
                            }
                            pRunInfo++;
                            cRuns--;
                        } while (cRuns);
                    }
                }
            }
            else // if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
            {
                // This code is run if:
                //
                // !(dwFlags & DXBOF_DITHER) 
                // && !((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque == 0)
                //
                // In English:
                //
                // This code is run if 1) dithering is not required
                // and 2) blending with output is not required because it was
                // not requested or because it's not needed because the source
                // pixels are all opaque.

                // hrDD is initialized to failure so that in the event that the
                // pixel formats don't match or the pixel format supports
                // transparency, the CopyRect will still run.

                HRESULT             hrDD        = E_FAIL;
                DXSAMPLEFORMATENUM  formatIn    = pIn->GetNativeType(NULL);

                // If the pixel formats match and do not support transparency
                // (because it's not supported by ddraw yet) try to use a 
                // ddraw blit instead of CopyRect.

                if ((formatIn == pOut->GetNativeType(NULL))
                    && !(formatIn & DXPF_TRANSPARENCY))
                {
                    CComPtr<IDirectDrawSurface> cpDDSrc;

                    // Get source ddraw surface pointer.

                    hrDD = pSrc->QueryInterface(IID_IDirectDrawSurface, 
                                                (void **)&cpDDSrc);

                    if (SUCCEEDED(hrDD))
                    {
                        CComPtr<IDirectDrawSurface> cpDDDest;

                        // Get destination ddraw surface pointer.

                        hrDD = pDest->QueryInterface(IID_IDirectDrawSurface, 
                                                     (void **)&cpDDDest);

                        if (SUCCEEDED(hrDD))
                        {
                            RECT rcSrc;
                            RECT rcDest;

                            SrcBnds.GetXYRect(rcSrc);
                            DestBnds.GetXYRect(rcDest);

                            // Attempt the ddraw blit.

                            hrDD = cpDDDest->Blt(&rcDest, cpDDSrc, &rcSrc, 
                                                 0, NULL);
                        }
                    }
                }

                // If hrDD has failed at this point, it means a direct draw blit
                // was not possible and a CopyRect is needed to perform the 
                // copy.

                if (FAILED(hrDD))
                {
                    pOut->CopyRect(pSrcBuff, NULL, pIn, NULL, bSrcIsOpaque);
                }
            }
            pOut->Release();
        }
        pIn->Release();
    }
    return hr;
}

inline HRESULT DXSrcCopy(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, 
                         IDXSurface *pSrcSurface, int nXSrc, int nYSrc)
{
    IDXDCLock *pDCLock;
    HRESULT hr = pSrcSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READ, &pDCLock);
    if (SUCCEEDED(hr))
    {
        ::BitBlt(hdcDest, nXDest, nYDest, nWidth, nHeight, pDCLock->GetDC(), nXSrc, nYSrc, SRCCOPY);
        pDCLock->Release();
    }
    return hr;
}
//
//=== Pointer validation functions
//
inline BOOL DXIsBadReadPtr( const void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadReadPtr( pMem, Size );
#endif
}

inline BOOL DXIsBadWritePtr( void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadWritePtr( pMem, Size );
#endif
}


inline BOOL DXIsBadInterfacePtr( const IUnknown* pUnknown )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ( ::IsBadReadPtr( pUnknown, sizeof( *pUnknown ) ) ||
             ::IsBadCodePtr( (FARPROC)((void **)pUnknown)[0] ))?
            (true):(false);
#endif
}

#define DX_IS_BAD_OPTIONAL_WRITE_PTR(p) ((p) && DXIsBadWritePtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_READ_PTR(p) ((p) && DXIsBadReadPtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_INTERFACE_PTR(p) ((p) && DXIsBadInterfacePtr(p))


#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\dxterror.h ===
/*******************************************************************************
* DXTError.h *
*------------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTError_h
#define DXTError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

//=== New codes ===============================================================
#define FACILITY_DXTRANS    0x87A

/*** DXTERR_UNINITIALIZED
*   The object (transform, surface, etc.) has not been properly initialized
*/
#define DXTERR_UNINITIALIZED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 1)

/*** DXTERR_ALREADY_INITIALIZED
*   The object (surface) has already been properly initialized
*/
#define DXTERR_ALREADY_INITIALIZED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 2)

/*** DXTERR_UNSUPPORTED_FORMAT
*   The caller has specified an unsupported format
*/
#define DXTERR_UNSUPPORTED_FORMAT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 3)

/*** DXTERR_COPYRIGHT_IS_INVALID
*   The caller has specified an unsupported format
*/
#define DXTERR_COPYRIGHT_IS_INVALID   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 4)

/*** DXTERR_INVALID_BOUNDS
*   The caller has specified invalid bounds for this operation
*/
#define DXTERR_INVALID_BOUNDS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 5)

/*** DXTERR_INVALID_FLAGS
*   The caller has specified invalid flags for this operation
*/
#define DXTERR_INVALID_FLAGS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 6)

/*** DXTERR_OUTOFSTACK
*   There was not enough available stack space to complete the operation 
*/
#define DXTERR_OUTOFSTACK   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 7)

/*** DXTERR_REQ_IE_DLLNOTFOUND
*   Unable to load a required Internet Explorer DLL  
*/
#define DXTERR_REQ_IE_DLLNOTFOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 8)

/*** DXT_S_HITOUTPUT
*   The specified point intersects the generated output
*/
#define DXT_S_HITOUTPUT   MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DXTRANS, 1)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\gaunt.h ===
#define IEVER_PRODUCTBUILD	2512
#define IEVER_PRODUCTBUILD_QFE	0001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\exdispid.h ===
#ifndef EXDISPID_H_
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: exdispid.h
//
//--------------------------------------------------------------------------


//
// Dispatch IDS for IExplorer Dispatch Events.
//
#define DISPID_BEFORENAVIGATE     100   // this is sent before navigation to give a chance to abort
#define DISPID_NAVIGATECOMPLETE   101   // in async, this is sent when we have enough to show
#define DISPID_STATUSTEXTCHANGE   102
#define DISPID_QUIT               103
#define DISPID_DOWNLOADCOMPLETE   104
#define DISPID_COMMANDSTATECHANGE 105
#define DISPID_DOWNLOADBEGIN      106
#define DISPID_NEWWINDOW          107   // sent when a new window should be created
#define DISPID_PROGRESSCHANGE     108   // sent when download progress is updated
#define DISPID_WINDOWMOVE         109   // sent when main window has been moved
#define DISPID_WINDOWRESIZE       110   // sent when main window has been sized
#define DISPID_WINDOWACTIVATE     111   // sent when main window has been activated
#define DISPID_PROPERTYCHANGE     112   // sent when the PutProperty method is called
#define DISPID_TITLECHANGE        113   // sent when the document title changes
#define DISPID_TITLEICONCHANGE    114   // sent when the top level window icon may have changed.

#define DISPID_FRAMEBEFORENAVIGATE    200
#define DISPID_FRAMENAVIGATECOMPLETE  201
#define DISPID_FRAMENEWWINDOW         204

#define DISPID_BEFORENAVIGATE2      250   // hyperlink clicked on
#define DISPID_NEWWINDOW2           251
#define DISPID_NAVIGATECOMPLETE2    252   // UIActivate new document
#define DISPID_ONQUIT               253
#define DISPID_ONVISIBLE            254   // sent when the window goes visible/hidden
#define DISPID_ONTOOLBAR            255   // sent when the toolbar should be shown/hidden
#define DISPID_ONMENUBAR            256   // sent when the menubar should be shown/hidden
#define DISPID_ONSTATUSBAR          257   // sent when the statusbar should be shown/hidden
#define DISPID_ONFULLSCREEN         258   // sent when kiosk mode should be on/off
#define DISPID_DOCUMENTCOMPLETE     259   // new document goes ReadyState_Complete
#define DISPID_ONTHEATERMODE        260   // sent when theater mode should be on/off
#define DISPID_ONADDRESSBAR         261   // sent when the address bar should be shown/hidden
#define DISPID_WINDOWSETRESIZABLE   262   // sent to set the style of the host window frame
#define DISPID_WINDOWCLOSING        263   // sent before script window.close closes the window 
#define DISPID_WINDOWSETLEFT        264   // sent when the put_left method is called on the WebOC
#define DISPID_WINDOWSETTOP         265   // sent when the put_top method is called on the WebOC
#define DISPID_WINDOWSETWIDTH       266   // sent when the put_width method is called on the WebOC
#define DISPID_WINDOWSETHEIGHT      267   // sent when the put_height method is called on the WebOC 
#define DISPID_CLIENTTOHOSTWINDOW   268   // sent during window.open to request conversion of dimensions
#define DISPID_SETSECURELOCKICON    269   // sent to suggest the appropriate security icon to show
#define DISPID_FILEDOWNLOAD         270   // Fired to indicate the File Download dialog is opening
#define DISPID_NAVIGATEERROR        271   // Fired to indicate the a binding error has occured
#define DISPID_PRIVACYIMPACTEDSTATECHANGE   272  // Fired when the user's browsing experience is impacted

// Printing events
#define DISPID_PRINTTEMPLATEINSTANTIATION   225   // Fired to indicate that a print template is instantiated
#define DISPID_PRINTTEMPLATETEARDOWN        226   // Fired to indicate that a print templete is completely gone 
#define DISPID_UPDATEPAGESTATUS             227   // Fired to indicate that the spooling status has changed

// define the events for the shell wiwndow list
#define DISPID_WINDOWREGISTERED     200     // Window registered
#define DISPID_WINDOWREVOKED        201     // Window Revoked

#define DISPID_RESETFIRSTBOOTMODE       1
#define DISPID_RESETSAFEMODE            2
#define DISPID_REFRESHOFFLINEDESKTOP    3
#define DISPID_ADDFAVORITE              4
#define DISPID_ADDCHANNEL               5
#define DISPID_ADDDESKTOPCOMPONENT      6
#define DISPID_ISSUBSCRIBED             7
#define DISPID_NAVIGATEANDFIND          8
#define DISPID_IMPORTEXPORTFAVORITES    9
#define DISPID_AUTOCOMPLETESAVEFORM     10
#define DISPID_AUTOSCAN                 11
#define DISPID_AUTOCOMPLETEATTACH       12
#define DISPID_SHOWBROWSERUI            13
#define DISPID_SHELLUIHELPERLAST        13

#define DISPID_ADVANCEERROR             10
#define DISPID_RETREATERROR             11
#define DISPID_CANADVANCEERROR          12
#define DISPID_CANRETREATERROR          13
#define DISPID_GETERRORLINE             14
#define DISPID_GETERRORCHAR             15
#define DISPID_GETERRORCODE             16
#define DISPID_GETERRORMSG              17
#define DISPID_GETERRORURL              18
#define DISPID_GETDETAILSSTATE          19
#define DISPID_SETDETAILSSTATE          20
#define DISPID_GETPERERRSTATE           21
#define DISPID_SETPERERRSTATE           22
#define DISPID_GETALWAYSSHOWLOCKSTATE   23

// Dispatch IDS for ShellFavoritesNameSpace Dispatch Events.
//
#define DISPID_FAVSELECTIONCHANGE       1
#define DISPID_SELECTIONCHANGE          2
#define DISPID_DOUBLECLICK              3
#define DISPID_INITIALIZED              4

#define DISPID_MOVESELECTIONUP          1
#define DISPID_MOVESELECTIONDOWN        2
#define DISPID_RESETSORT                3
#define DISPID_NEWFOLDER                4
#define DISPID_SYNCHRONIZE              5
#define DISPID_IMPORT                   6
#define DISPID_EXPORT                   7
#define DISPID_INVOKECONTEXTMENU        8
#define DISPID_MOVESELECTIONTO          9
#define DISPID_SUBSCRIPTIONSENABLED     10
#define DISPID_CREATESUBSCRIPTION       11
#define DISPID_DELETESUBSCRIPTION       12
#define DISPID_SETROOT                  13
#define DISPID_ENUMOPTIONS              14
#define DISPID_SELECTEDITEM             15
#define DISPID_ROOT                     16
#define DISPID_DEPTH                    17
#define DISPID_MODE                     18
#define DISPID_FLAGS                    19
#define DISPID_TVFLAGS                  20
#define DISPID_NSCOLUMNS                21
#define DISPID_COUNTVIEWTYPES           22
#define DISPID_SETVIEWTYPE              23
#define DISPID_SELECTEDITEMS            24
#define DISPID_EXPAND                   25
#define DISPID_UNSELECTALL              26

#define EXDISPID_H_
#endif // EXDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\idispids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE                             (-525)
#define DISPID_READYSTATECHANGE                       (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY               (-728)
#define DISPID_AMBIENT_OFFLINEIFNOTCONNECTED          (-5501)
#define DISPID_AMBIENT_SILENT                         (-5502)

// Until these appear in OLECTL.H
#ifndef DISPID_AMBIENT_CODEPAGE
#define DISPID_AMBIENT_CODEPAGE         (-725)
#define DISPID_AMBIENT_CHARSET          (-727)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\hlguids.h ===
/****************************************************************************
    hlguids.h

    Copyright (c) 1995-1998 Microsoft Corporation

    This file defines or declares (according to standard DEFINE_GUID protocol)
    the GUIDs used to interact with hyperlinks.

    NOTE: This header file is used by non-Office as well as Office parties to
    access functionality provided by hlink dll and hlinkprx dll.
****************************************************************************/

#ifndef HLGUIDS_H
#define HLGUIDS_H

/****************************************************************************
    hlink GUIDs
****************************************************************************/

// On Windows, we get these from uuid3.lib
#if MAC

/* 79eac9c0-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IBinding,
    0x79eac9c0,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c1-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IBindStatusCallback,
    0x79eac9c1,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c9-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IPersistMoniker,
    0x79eac9c9,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

#endif /* MAC */

/* 79eac9c2-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkSite,
    0x79eac9c2,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c3-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlink,
    0x79eac9c3,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c4-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkTarget,
    0x79eac9c4,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c5-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkFrame,
    0x79eac9c5,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c6-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IEnumHLITEM,
    0x79eac9c6,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9c7-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IHlinkBrowseContext,
    0x79eac9c7,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9cb-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(IID_IExtensionServices,
    0x79eac9cb,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9d0-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(CLSID_StdHlink,
    0x79eac9d0,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* 79eac9d1-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(CLSID_StdHlinkBrowseContext,
    0x79eac9d1,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

/* The GUID of the service SID_SHlinkFrame is the same as IID_IHlinkFrame */
/* 79eac9c5-baf9-11ce-8c82-00aa004ba90b */
#ifndef SID_SHlinkFrame                   /* Usually #defined in hlink.h */
DEFINE_GUID(SID_SHlinkFrame,
    0x79eac9c5,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);
#endif /* ! SID_SHlinkFrame */

/* The GUID of the service SID_SContainer */
/* 79eac9c4-baf9-11ce-8c82-00aa004ba90b */
DEFINE_GUID(SID_SContainer,
    0x79eac9c4,
    0xbaf9, 0x11ce,
    0x8c, 0x82,
    0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);
#endif // HLGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\icwcfg.h ===
/********************************************************************

  ICWCFG.H

  Copyright(c) Microsoft Corporation, 1996-1998

  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
  *
  * This header file is not intended for distribution outside Microsoft.
  *
  ***********************************************************

  Header file for Internet Connection Wizard external configuration
  routines found in INETCFG.DLL.

  Routines:

  CheckConnectionWizard - Checks which parts of ICW are installed
		and if it has been run before.  It optionally will start
		either the full or manual path of ICW if it is insalled
		but has not been run before.

  History:	10/22/96	Created
		10/24/96	Added defines and typedefs
		2/25/97		Added CreateDirectoryService -- jmazner
		4/24/97		Removed InetCreate*, these are now owned
					by the Account Manager -- jmazner

  Support:	This header file (and INETCFG.DLL) is supported by the
			Internet Connection Wizard team (alias icwcore).  Please
			do not modify this directly.

*********************************************************************/

#ifndef _ICWCFG_H_

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS	"Software\\Microsoft\\Internet Connection Wizard"
#define ICW_REGKEYCOMPLETED	"Completed"

// Maximum field lengths
#define ICW_MAX_ACCTNAME	256
#define ICW_MAX_PASSWORD	256	// PWLEN
#define ICW_MAX_LOGONNAME	256	// UNLEN
#define ICW_MAX_SERVERNAME	64
#define ICW_MAX_RASNAME		256	// RAS_MaxEntryName
#define ICW_MAX_EMAILNAME	64
#define ICW_MAX_EMAILADDR	128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS		0x0001

#define ICW_LAUNCHFULL		0x0100
#define ICW_LAUNCHMANUAL	0x0200
#define ICW_USE_SHELLNEXT	0x0400
#define ICW_FULL_SMARTSTART	0x0800

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT		0x0001
#define ICW_MANUALPRESENT	0x0002
#define ICW_ALREADYRUN		0x0004

#define ICW_LAUNCHEDFULL	0x0100
#define ICW_LAUNCHEDMANUAL	0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS		0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// external function typedefs
//
typedef DWORD	(WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef DWORD	(WINAPI *PFNSETSHELLNEXT) (CHAR *);

//
// external function declarations
//
DWORD	WINAPI CheckConnectionWizard(DWORD, LPDWORD);
DWORD	WINAPI SetShellNext(CHAR *);


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _ICWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\hlinkez.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: hlinkez.h
//
//--------------------------------------------------------------------------

struct IBindStatusCallback;

HRESULT HlinkSimpleNavigateToString(
    /* [in] */ LPCWSTR szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szAdditionalParams,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

HRESULT HlinkSimpleNavigateToMoniker(
    /* [in] */ IMoniker *pmkTarget,   // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szAddParams,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

HRESULT HlinkGoBack(IUnknown *pUnk);
HRESULT HlinkGoForward(IUnknown *pUnk);
HRESULT HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);
HRESULT HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\iehelpid.h ===
//+-------------------------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//
//  Contents:   Helpids for iexplore.hlp.  iexplore.hlp only contains help for the binaries
//  distributed with a browser-only install of IE, such as:
//
//      shdocvw.dll
//      browseui.dll
//      inetcpl.cpl
//
//  Pure shell components, such as shell32.dll, use other .hlp files, such as shell.hlp,
//  and have their help ids defined in other headers (see shellids.h and help.h).
//+-------------------------------------------------------------------------------------------

#define IDH_IE_RUN_COMMAND              50000 // was 0x3000

// For Add To Favorites
#define IDH_BROWSELIST                  50001 // was 0x3001
#define IDH_NEWFOLDER                   50002 // was 0x3002
#define IDH_CREATEIN                    50003 // was 0x3003
#define IDH_NAMEEDIT                    50004 // was 0x3004

// For Open dialog
#define IDH_RUNBROWSE                   50005 // was 0x3005

// For Organize Favorites
#define IDH_ORG_FAVORITES_MOVE          50006 // was 0x3050
#define IDH_ORG_FAVORITES_RENAME        50007 // was 0x3051
#define IDH_ORG_FAVORITES_DELETE        50008 // was 0x3052
#define IDH_ORG_FAVORITES_OPEN          50009 // was 0x3053
#define IDH_ORG_FAVORITES_CLOSE         50010 // was 0x3054

//For Volvo QFE
#define IDH_AUTOCONFIG_BUTTON           50011 // was 0x3055
#define IDH_AUTOCONFIG_TEXT             50012 // was 0x3056
#define IDH_OPTS_CONNX_AUTOCNCT_REFRESH 50013 // was 0x3070

//Trident print features
#define IDH_PRINT_SCREEN                50014 // was 0x3057
#define IDH_PRINT_SEL_FRAME             50015 // was 0x3058
#define IDH_PRINT_ALL_FRAME             50016 // was 0x3059
#define IDH_PRINT_LINKS                 50017 // was 0x3060
#define IDH_PRINT_SHORTCUTS             50020 // was 5002



//Find Text dialog box
#define IDH_FIND_WHOLEA                  50022 // was 0x3063
#define IDH_FIND_CASEA                   50023 // was 0x3064
#define IDH_FIND_UPA                     50024 // was 0x3065
#define IDH_FIND_DOWNA                   50025 // was 0x3066
#define IDH_FIND_NEXTA                   50026 // was 0x3067
#define IDH_FIND_WHATA                   50027 // was 0x3068


//General Tab, Language button
#define IDH_OPTS_GEN_LANG_BUT           50028 // was 0x3071

//Language Preferences dialog box
#define IDH_LANG_PREFS_LIST             50029 // was 0x3075 //Language label and list box
#define IDH_LANG_PREFS_UP               50030 // was 0x3076 //Move up button
#define IDH_LANG_PREFS_DOWN             50031 // was 0x3077 //Move Down button
#define IDH_LANG_PREFS_REMOVE           50032 // was 0x3078 //Remove button
#define IDH_LANG_PREFS_ADD              50033 // was 0x3070 //Add button




//Content tab, Personal Information: Personal Profile and Microsoft Wallet
#define IDH_EDIT_PROFILE_BTN            50198 // Edit Profiles button

#define IDH_ADD_LANGUAGE_LANGUAGE_LIST  50037 // was 0x3102 //in Add Languages dialog box, Language list
#define IDH_ADD_LANGUAGE_USER_DEFINED   50038 // was 0x3103  //in Add Languages dialog box, User Defined label and text box

//Client Authentication dialog box
#define  IDH_CLIENT_AUTHENTICATION_LIST 50039 // was 0x3100         //Identification label, text, and list area
#define IDH_CLIENT_AUTHENTICATION_CERT_PROPS    50040  // was 0x3101 //View button

#define IDH_GROUPBOX                    50041 // was 1

///////////////////******************       Advanced tab, Advanced list


//Advanced Tab, Advanced List
//Multimedia
#define IDH_MM_PIC                      50042 // was 3 //Show Pictures
#define IDH_MM_ANIM                     50176 //Play animations
#define IDH_MM_SOUND                    50043 // was 4 //Play Sounds
#define IDH_MM_VIDEO                    50044 // was 5 //play videos
#define IDH_APPEAR_COLOR                50045 // was 6
#define IDH_SMART_DITH                  50177 //Smart dithering
#define IDH_MB_NO_ONLINE_CONTENT        50194 // MediaBar: Don't display online media content in the media bar 
//Browsing
#define IDH_DOWNLOAD_COMP                 50492 //Notify when downloads complete
#define IDH_AUTOCOMP                    50180 //Use AutoComplete
#define IDH_ADD_URL                     50111 // was 79//show friendly urls
#define IDH_ADD_SMOOTH                  50107 // was 75//use smooth scrolling
#define IDH_ADD_LINK                    50112 // was 80//highlight links
#define IDH_NEW_PROCESS                 50178 //Browse in a new process
#define IDH_CHANNELLOG                  50179 //Enable page hit counting
#define IDH_ENABLE_SUB_UPDATES          50181 //Enable scheduled subscription updates
#define IDH_UPDATE_SUB_NEW_PROC         50182 //Update subscriptions in a new process
//Security
#define IDH_PCT_ALLOW                   50130 // was 99//pct 1.0
#define IDH_SSL2_ALLOW                  50128 // was 97//ssl 3.0
#define IDH_SSL3_ALLOW                  50129 // was 98// ssl 3.0
#define IDH_CRYPT_NOSAVE_SSL            50127 // was 96//do not save pages to disk
#define IDH_PRIV_VIEW                   50089 // was 54//warn if changing between secure and unsecure
#define IDH_CHK_CERT_REVOC              50184 // Check for publisher'scertificate revocation
#define IDH_PRIV_INVALID                50119 // was 87//Warn about invalid site certs
#define IDH_TAKE_COOKIES_ALWAYS         50189 //Always accept cookies// Now: Allow cookies that are stored on your computer
#define IDH_PRIV_COOKIE                 50090 // was 55// prompt before accepting cookies //Now: Allow per-session cookies (not stored)
#define IDH_DISABLE_COOKIES             50190 //Disable all cookies// obsolete

//Java VM
#define IDH_ADD_JAVA_COMP               50110 // was 78//JAVA JIT complier enabled
#define IDH_ADD_JAVA_LOG                50109 // was 77//java logging enabled

//Printing
#define IDH_PRINT_BKGRND                50191 //Print background colors and images

//Searching
#define IDH_AUTOSCAN                    50192 //Autoscan common root domains
#define IDH_SEARCH_URL_FAILS            50193 //Search when URL fails; never, always, always

//Toolbar
#define IDH_TOOL_STD                    50048 // was 9 //small icons




#define IDH_RESTORE_DEFS            50196 //Restore Defaults button at bottom of advanced tab

////////////////******       End of Advanced tab **********////////////////////////////

#define IDH_APPEAR_OPTION               50046 // was 7
#define IDH_APPEAR_LINK                 50047 // was 8
#define IDH_FONT_INT                    50055 // was 16
#define IDH_FONT_MIME                   50056 // was 17
#define IDH_OPTS_GEN_FONTS_FONTSIZE     50057 // was 5003
#define IDH_CHAR_SET                    50058 // was 18
#define IDH_INTL_DEFAULT                50059 // was 19
#define IDH_INTL_FONT_PROP              50060 // was 21
#define IDH_INTL_FONT_FIXED             50061 // was 22
#define IDH_DIAL_CON                    50062 // was 24
#define IDH_DIAL_USE                    50063 // connection tab, checkbox: dial the default connection when needed
#define IDH_DIAL_PROP                   50064 // dialup server properties, properties button
#define IDH_DIAL_DIS                    50065 // was 27
#define IDH_DIAL_ADD                    50066 // Add button in connections tab
#define IDH_DIAL_SYS                    50067 // was 29
#define IDH_PROX_SERV                   50068 // proxy server group box, Manual Proxy Server option
#define IDH_PROX_SETTINGS               50069 // LAN Settings button
#define IDH_SERV_INFO                   50070 // was 34
#define IDH_SERV_SAME                   50071 // was 35
#define IDH_EXCEPT_PROX                 50072 // was 37
#define IDH_EXCEPT_LOCAL                50073 // was 38
#define IDH_CUST_ADDRESS                50076 // was 41
#define IDH_CUST_DEF                    50077 // was 42
#define IDH_CUST_CURR                   50078 // was 43
#define IDH_HIST_NUM                    50079 // was 44
#define IDH_HIST_CLEAR                  50080 // was 45
#define IDH_MAIL                        50082 // was 47
#define IDH_NEWS                        50083 // was 48
#define IDH_IE_DEF                      50085 // was 50

#define IDH_CERT_PERS                   50091 // was 56
#define IDH_CERT_SITE                   50092 // was 57
#define IDH_CERT_PUB                    50093 // was 58
#define IDH_ACT_CONTENT                 50097 // was 62
#define IDH_SAFE_EXPERT                 50099 // was 67
#define IDH_SAFE_NORM                   50100 // was 68
#define IDH_SAFE_NONE                   50101 // was 69
#define IDH_RATE_TOGGLE                 50102 // was 70
#define IDH_RATE_PROP                   50103 // was 71
#define IDH_TIF_VIEW                    50104 // was 72
#define IDH_TIF_SETTINGS                50105 // was 73


//Settings dialog
#define IDH_TEMP_EVERY                  50113 // was 81
#define IDH_TEMP_START                  50114 // was 82
#define IDH_TEMP_NEVER                  50115 // was 83
#define IDH_TEMP_AMOUNT                 50116 // was 84
#define IDH_TEMP_EMPTY                  50117 // was 85
#define IDH_TEMP_MOVE                   50118 // was 86
#define IDH_TEMP_AUTO           50491 // New for ie5

#define IDH_VIEW_CERT                   50124 // was 93
#define IDH_DEL_CERT                    50125 // was 94
#define IDH_LIST_CERT                   50126 // was 95



#define IDH_PAGESETUP_HEADER_LEFT       50136 // was      4129       // Page Setup dialog box, header and footer
#define IDH_CPL_GEN_USEBLANK            50137 // was    5100// Use Blank button
#define IDH_CPL_SEC_ZONE_DROPLIST       50138 // was    5110// Zone dropdown list
#define IDH_CPL_SEC_ADDSITES            50139 // was    5115// Add Sites button
#define IDH_CPL_SEC_CUSTOM_LEVEL        50140 // was    5140// Custom for expert users
#define IDH_CPL_SEC_SETTINGS            50141 // was    5135// Settings button
#define IDH_CPL_WEB_SITES_LIST          50142 // was    5145// Trusted Web sites list
#define IDH_CPL_WEB_SITES_REMOVE        50143 // was    5150// Web sites in- Remove button
#define IDH_CPL_REQ_VERIFICATION_CHKBOX 50144 // was    5155// Require server verification for all sites in this zone
#define IDH_CPL_WEB_SITES_ADD_THIS_TXT  50145 // was    5160// Add this web site text box
#define IDH_CPL_WEB_SITES_ADD_BUTTON    50146 // was    5165// Add button
#define IDH_CPL_SEC_SETTINGS_CURRENT    50147 // was    5170// Security: Current settings list box
#define IDH_CPL_SEC_SETTINGS_RESET      50148 // was    5175// Security: Reset to: text box

#define IDH_CPL_CNX_WIZARD              50149 // was    5230// Wizard button in Connection tab/Connection groupbox
#define IDH_CPL_CNX_SETTINGS            50150 // was    5235// Connection settings button
#define IDH_CPL_CNX_ACCESSBYLAN         50151 // was    5240// Access the Internet via a local area network
#define IDH_CPL_CNX_PROXY_ADDR_PORT     50152 // was    5180// Proxy server address and port
#define IDH_CPL_DUN_ATTEMPT_X_TIMES     50153 // was    5200// Dial-Up Settings: Attempt to connect x times
#define IDH_CPL_DUN_WAIT_X_SECS         50154 // was    5205// DUN: Wait x seconds between each attempt
#define IDH_CPL_DUN_SEND_MY_LOGIN       50155 // Do not allow Internet applications to use this connection
#define IDH_CPL_DUN_USERNAME            50156 // was    5215// DUN: User
#define IDH_CPL_DUN_PASSWORD            50157 // was    5220// DUN: Password
#define IDH_CPL_DUN_DOMAIN              50158 // was    5225// DUN: Domain
#define IDH_CPL_PROGRAMS_CAL            50159 // was    5250// Programs: Calendar
#define IDH_CPL_PROGRAMS_CONTACTS       50160 // was    5255// Programs: Contact List
#define IDH_CPL_PROGRAMS_INTERNET_CALL  50161 // was    5260// Programs: Internet Call
#define IDH_CPL_ADV_COLORS              50162 // was    5270// Colors button
#define IDH_CPL_ADV_ACCESSIBILITY       50163 // was    5275// Accessibility button
#define IDH_CPL_ACCESS_USE_MY_COLORS    50164 // was    5290// Accessibility: Always use my color settings
#define IDH_CPL_ACCESS_USE_MY_F_STYLE   50165 // was    5295// Accessibility: Always use my font style settings
#define IDH_CPL_ACCESS_USE_MY_F_SIZE    50166 // was    5300// Accessibility: Always use my font size settings
#define IDH_CPL_ACCESS_USE_MY_STYLESHEETS 50167 // was  5305// Accessibility: User Stylesheet check box and text box

//Security dialog box help
#define IDH_SEC_ENTER_SSL               50168 //Entering a secure site
#define IDH_SEC_ENTER_SSL_W_INVALIDCERT 50169 //Entering a secure site with an invalid certificate
#define IDH_SEC_SEND_N_REC_COOKIES      50171 //Sending and Receiving Information About Your Browsing
#define IDH_SEC_SIGNED_N_INVALID        50173 //Signed and Invalid ActiveX/Java Download
#define IDH_SEC_MIXED_DOWNLOAD_FROM_SSL 50175 //Insecure content download from a secure Web site
#define IDH_SEC_ENTER_NON_SECURE_SITE   50226 //Entering non-secure Web site without a cert, from a secure web site



//CERTIFICATE PROPERTIES DIALOG BOX
#define IDH_CERTVWPROP_GEN_FINEPRINT          50228
#define IDH_CERTVWPROP_DET_ISSUER_CERT        50229
#define IDH_CERTVWPROP_DET_FRIENDLY           50230
#define IDH_CERTVWPROP_DET_STATUS             50231
#define IDH_CERTVWPROP_TRUST_PURPOSE          50232
#define IDH_CERTVWPROP_TRUST_HIERAR           50233
#define IDH_CERTVWPROP_TRUST_VIEWCERT         50234
#define IDH_CERTVWPROP_TRUST_INHERIT          50235
#define IDH_CERTVWPROP_TRUST_EXPLICIT_TRUST   50236
#define IDH_CERTVWPROP_TRUST_EXPLICIT_DISTRUST 50237
#define IDH_CERTVWPROP_ADV_FIELD              50238
#define IDH_CERTVWPROP_ADV_DETAILS            50239

#define IDH_HOVERCOLOR                        50240//color dialog box
#define IDH_JAVA_PERMISSIONS                  50241//security tab, custom settings list

#define IDH_ENABLE_TRANSITIONS                50242//Advanced tab, inetcpl
#define IDH_UNDERLINE_LINKS                   50243//advanced tab, inetcpl
#define IDH_SECURITY_RESET_ZONE_DEFAULTS      50244//security tab, zones
#define IDH_SECURITY_RESET_LEVEL_DEFAULTS     50245//security tab, security settings, Reset custom settings

//Profile Assistant confirmation dialog box
#define IDH_PA_OPS_REQUEST                    50246//name and url of site making request
#define IDH_PA_OPS_LIST                       50247//Profile information requested--label and listbox
#define IDH_PA_USAGE_STRING                   50248//Usage label and text area
#define IDH_PA_VIEW_CERT                      50249//View Certificate button
#define IDH_PA_CONNECTION_SECURITY            50250//Connection Security label and text
#define IDH_PA_ALWAYS_SHARE                   50251//Always share text box

#define IDH_DISABLE_SCRIPT_DEBUG              50252//Advanced tab, intecpl

#define IDH_TEMP_INTERNET_VIEW_OBJECTS_BTN  50254 //Temporary Internet Files settings dialog, View Objects button

//download objects folder properties
#define IDH_DLOAD_TYPE                    50255
#define IDH_DLOAD_CREATED                 50256
#define IDH_DLOAD_LASTACC                 50257
#define IDH_DLOAD_TOTALSIZE               50258
#define IDH_DLOAD_ID                      50259
#define IDH_DLOAD_STATUS                  50260
#define IDH_DLOAD_CODEBASE                50261
#define IDH_DLOAD_FILE_DEP                50262
#define IDH_DLOAD_JAVAPKG_DEP             50263
#define IDH_DLOAD_VERSION                 50264
#define IDH_DLOAD_DESC                    50265
#define IDH_DLOAD_COMPANY                 50266
#define IDH_DLOAD_LANG                    50267
#define IDH_DLOAD_COPYRIGHT               50268

//Local Internet sites
#define IDH_ADD_SITES_ADVANCED_BTN                      50269
#define IDH_LOCAL_INTRA_INCLUDE_ALL_NOT_LISTED          50270
#define IDH_LOCAL_INTRA_INCLUDE_ALL_THAT_BYPASS_PROXY   50271
#define IDH_LOCAL_INTRA_INCLUDE_ALL_UNCS                50272

#define IDH_SITE_CERTS_ISSUER_TYPE        50273  //Site Certificates dialog box, Issuer Type drop down

#define IDH_JAVA_CUST_SETTINGS_BTN        50274  //security custom settings, Java Custom Settings button

//Add
#define IDH_SUBSCR_TO                     50021 //Favorites full subscription
#define IDH_SUBSCR_TO_CHANNEL             50275 //channel full subscription
#define IDH_SUBSCR_ADDTO_FAVS             50276 //Favorites no subscription
#define IDH_SUBSCR_PARTIAL                50278 //Favorites partial subscription
#define IDH_CHANNEL_ADDTO_CHANNELS        50279 //channels not subscription
#define IDH_CHANNEL_PARTIAL               50280 //channels partial subscription
#define IDH_CHANNEL_SUBSCR_CUST_BUTTON    50281 //Customization button

#define IDH_SOFTWARE_CHANNEL_PERMISSIONS  50282

#define IDH_USER_AUTHENTICATION           50283

#define IDH_DLOAD_OBJNAME                 50284

#define IDH_RESET_SHARING_OPS             50285 //Content tab
#define IDH_ADV_PROFILE_ASSISTANT         50286 //Advanced tab

#define IDH_ALWAYS_LAUNCH_FULL_SCREEN     50287 //Advanced tab, Browser, Always launch fullscreen browser
#define IDH_WARN_IF_FORMS_REDIRECTED      50288 //Advanced tab, Security, Warn if forms submit is being redirected
#define IDH_SHOW_FONT_BUTTON              50289 //Advanced tab, Toolbar, Show font button


//fixes for IE 4.01, New context-sensitive help topics for advanced tab and client authentication personal certificates import and export buttons
#define IDH_SHOW_IE_ON_DESKTOP   50290
#define IDH_SHOW_WELCOME_EACH_LOGON      50291
#define IDH_LAUNCH_CHANNELSIN_FULL             50292
#define IDH_DELETE_HISTORY_WHEN_CLOSING    50293
#define IDH_CLIENTAUTH_IMPORT                          50294
#define IDH_CLIENTAUTH_EXPORT                       50295
#define IDH_USEHTTP11_THRU_PROXY              50296
#define IDH_USEHTTP11                                     50297
#define IDH_ALWAYS_EXPAND_ALT_TEXT    50298
#define IDH_MOVE_SYSTEM_CARET                 50299
#define IDH_CHANNEL_ON_WITHOUT_ACT_DTP     50300
#define IDH_ENABLE_JAVA_CONSOLE             50301

//50302 to 50399 reserved for IEUNIX

#define IDH_MATCH_DIACRITIC 50401 //find dialog box
#define IDH_MATCH_KASHIDA 50402 //find dialog box
#define IDH_MATCH_ALEF_HAMZA 50403 //find dialog box



#define IDH_SUBPROPS_SCHEDTAB_CUSTOM_SCHEDULE 50412
#define IDH_SUBPROPS_SCHEDTAB_MANUAL_SCHEDULE 50414
#define IDH_SUBPROPS_SCHEDTAB_SCHEDDESC 50415
#define IDH_SUBPROPS_SCHED_DONTUPDATE 50417
#define IDH_SUBPROPS_RECTAB_ADVANCED 50420
#define IDH_SUBPROPS_RECTAB_EMAIL_NOTIFICATION 50421
#define IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_ADDRESS 50423
#define IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_SERVER 50424
#define IDH_SUBPROPS_RECTAB_CHANNEL_LOGIN 50425
#define IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID 50426
#define IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD 50427
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP 50428
#define IDH_SUBPROPS_RECTAB_ADVOPTS_FOLLOW_LINKS  50429
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_IMAGES 50430
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_SOUND 50431
#define IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_ACTIVEX 50432
#define IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD 50433


#define IDH_CONNECTION_TAB_CONNECTOID_LIST  50434 //Dial-up connection list in connection tab
#define IDH_CONNECTION_TAB_REMOVE_CONNECTOID  50435 //Remove button in connection tab
#define IDH_BYPASS_AUTOCFG  50436
#define IDH_DISCONNECT_ON_IEEXIT  50437 //advanced dialup dialog box, checkbox: disconnect when all internet applications exit
#define IDH_USE_THIS_CNX_FOR_INTRANETS  50438
#define IDH_USETHIS_CNX_4_INTERNET  50439
#define IDH_FORTEZZA_ALLOW  50440

#define IDH_EDIT_OFFLINE_SCHED  50441
#define IDH_MAKE_AVAIL_OFFLINE  50442
#define IDH_NEWSCHED_EVERY_AT_TIME  50443
#define IDH_NEWSCHED_NAME   50444
#define IDH_NEW_OFFLINE_SCHED   50445
#define IDH_REMOVE_OFFLINE_SCHED    50446

#define IDH_CHANNEL_DOWNLOAD_ALL    50447
#define IDH_CHANNEL_DOWNLOAD_COVER_N_TOC    50448
#define IDH_SUBPROPS_SUBTAB_SUBSCRIBED_NAME 50449
#define IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL  50450
#define IDH_WEBDOC_HOTKEY   50451
#define IDH_WEBDOC_VISITS   50452
#define IDH_SUBPROPS_SUBTAB_LAST    50453
#define IDH_SUBPROPS_DLSIZE 50454
#define IDH_SUBPROPS_SUBTAB_RESULT  50455

//#define IDH_JIT_COMPONENT 50456
#define IDH_JIT_SIZE    50457
#define IDH_JIT_DOWNLOAD_TIME   50458
#define IDH_JIT_NEVER_DOWNLOAD_THESE_COMPONENTS 50459
//#define IDH_JIT_PROGRESS_INDICATOR    50460
#define IDH_JIT_DOWNLOAD_BUTTON 50461
#define IDH_JIT_CANCEL_BUTTON   50462
#define IDH_JIT_VRML    50463
#define IDH_JIT_JAVAVMJIT   50464
#define IDH_JIT_IELPKJA 50465
#define IDH_JIT_IELPKKO 50466
#define IDH_JIT_IELPKPE 50467
#define IDH_JIT_IELPKZHT    50468
#define IDH_JIT_IELPKZHC    50469
#define IDH_JIT_IELPKTH 50470
#define IDH_JIT_IELPKIW 50471
#define IDH_JIT_IELPKVI 50472
#define IDH_JIT_IELPKAR 50473
#define IDH_JIT_IELPKAD 50474
#define IDH_JIT_MEDIAPLAYER 50475
#define IDH_JIT_MEDIAFILTER 50476
#define IDH_JIT_ACTIVEPAYMENT   50477
#define IDH_JIT_AOLSUPP 50478
#define IDH_JIT_MOBILEPK    50479
#define IDH_JIT_ICW 50480
#define IDH_JIT_USP10   50481

//organize favorites new UI
#define IDH_ORGFAVS_UP  50482
#define IDH_ORGFAVS_DOWN    50483
#define IDH_ORGFAVS_NEW_FOLDER  50484
#define IDH_ORGFAVS_SORT    50485
#define IDH_ORGFAVS_SYNCHRO 50486
#define IDH_ORGFAVS_IMPORT  50487
#define IDH_ORGFAVS_EXPORT  50488
#define IDH_ORGFAVS_PROPERTIES  50489
#define IDH_ORGFAVS_LIST    50490
#define IDH_SAVEAS_TYPE 50493 //FileSave, Save As Type
#define IDH_CHAR_SET_SAVE_AS    50494//FileSave, Language

#define IDH_AUTH_SAVE_PASSWORD     50495 //client authentication login
#define IDH_AUTH_REALM     50496 //client authentication login
#define IDH_AUTH_DOMAIN     50497 //client authentication login
#define IDH_AUTH_SERVER_FIREWALL     50498 //client authentication login
#define IDH_CPL_SEC_SETTINGS_CURRENT_ADMINAPPROVED     50499 //Active X security settings
#define IDH_SUBPROPS_RECTAB_ADVOPTS_ONLY_HTML_LINKS   50500 // Advanced tab,
#define IDH_ADV_NOTIFY_DWNLD_COMPLETE     50501//Advanced tab: Notify when downloads complete
#define IDH_ADV_DISABLE_JIT     50502//Advanced tab: Enable Install on demand
#define IDH_ADV_DISABLE_CZECH_4NEWER_IE     50503//Advanced tab: Automatically check for Internet Explorer updates

//New JIT topics:
#define IDH_JIT_DIRECTANIMATION   50504
#define IDH_JIT_DIRECTOR   50505
#define IDH_JIT_HELPCONT   50506
#define IDH_JIT_MSN_AUTH   50507
#define IDH_JIT_TRIDATA   50508
#define IDH_JIT_EXTRAPACK   50509
#define IDH_JIT_OK_BUTTON   50510

#define IDH_TLS_PROTOCOL   50511 //Advanced tab, Transport Layer Security protocol checkbox

//New language ids, Yutakan
#define IDH_COMBO_UILANG   50512 // The dropdown listbox on the Menus and Dialogs dialog.
#define IDH_LANG_ADDSPK    50513 // Add satellite pack button: This button leads to the satellite pack downloading web site.
#define IDH_LANG_UI_PREF   50514 //the Change button on the Language Preference dialog, which invokes the Menus and Dialogs dialog.

//New Security tab ids, Lorenk
#define IDH_SEC_LVL_SLIDER 50515 //hook up to the description bullets text also
#define IDH_SEC_ZONE_LIST 50516  //the list of icons at the top of the security tab.

//Content tab,
#define IDH_OPTS_PROG_AUTOSUGGEST_BUT 50517 //Autosuggest button
#define IDH_INTELLIFORM 50524 //Autosuggest forms option//See 50180 for autosuggest address options
#define IDH_CLEAR_INTELLIFORM  50525 //Autosuggest forms clear history button

#define IDH_OPTS_PROG_WALLET_BUT 50518  //Wallet button

//Proxy server settings
#define IDH_PROX_SERV_AUTO  50519 //In proxy server group box (dialup settings) or Lan settings proxy server dialog box: Automatic discovery of proxy server
#define IDH_PROX_SERV_NONE  50520 //In proxy server group box (dialup settings) or Lan settings proxy server dialog box: No proxy server
#define IDH_PROX_SETTINGS_ADV 50521 ////In proxy server group box (dialup settings) or Lan settings proxy server dialog box: Advanced button
#define IDH_DIAL_PROP_ADV  50522 //In dial-up settings group box, Advanced button (for connection attempts and disconnecting settings

//Connections tab

#define IDH_DIAL_DEFAULT  50523 //Set Default button, makes selected connection your default


//advanced tab
#define IDH_ADV_ENABLE_SCRIPTERROR_NOTIFICATION 50526
#define IDH_ADV_ENABLE_SYNC_OF_OFFLINEITEMS_PER_SCHED 50527
#define IDH_ADV_CLOSE_UNUSED_FOLDERS 50528
#define IDH_AUTODISC_DET_ONCE 50529
#define IDH_AUTODISC_DET_DISABLE 50530
#define IDH_AUTODISC_DET_AFTER_NET_CHG 50531
#define IDH_AUTODISC_DET_FOR_ANY_SETTINGS_CHGS 50532

//web folders
#define IDH_WEB_FOLDERS_CKBOX   50533  //in FileOpen dialog box

//Programs tab
#define IDH_HTML_EDITOR 50534 //HTML Editor default

#define IDH_SENDURLS_AS_UTF8 50535 //Send URLS as UTF-8, Advanced tab

#define IDH_SHOW_GO_IN_ADDRESSBAR  50536

#define IDH_SHOW_FRIENDLY_HTTP_ERROR_MESSAGES  50537
#define IDH_INLINE_AUTOCOMP_WEB_ADDRESSES 50538
#define IDH_INLINE_AUTOCOMP_PATHS_N_SHARES 50539
#define IDH_INTELLIFORM_PW 50540
#define IDH_CLEAR_INTELLIFORM_PW 50541
#define IDH_CONNECT_TAB_PERFORM_SECUR_CHECKB4_DIALING 50542

#define IDH_ADD_COMP_RADIO 50543
#define IDH_REPAIR_CURRENT_INSTALLATION 50544
#define IDH_RESTORE_PREVIOUS_IE 50545
#define IDH_MAINT_ADV_BUT 50546
#define IDH_RESTORE_COMPONENT_LIST 50547
#define IDH_DELETE_BACKUP 50548
#define IDH_REMOVE_IE6_SETUP_FILES 50549

#define IDH_CHK_SITE_CERT_REVOC 50550 //Check for server certificate revocation

#define IDH_BROWSEUI_TB_TEXTOPTNS                           50551
#define IDH_BROWSEUI_TB_ICONOPTNS                           50552

#define IDH_JIT_FLASH     50553
#define IDH_JIT_WEBFLDRS     50554
#define IDH_JIT_MESSNGR    50555
#define IDH_JIT_VBSCRIPT    50556
#define IDH_JIT_VML     50557
#define IDH_JIT_WAB    50558

#define IDH_SHOW_PLACEHOLDERS     50559
#define IDH_WEBFTP_ON    50560
#define IDH_CNX_CURRENT_DEFAULT_LBL_N_DISP   50561

#define IDH_INTELLIFORM_PW_PROMPT   50562

//Outlook Express Fonts dialog box
#define IDH_INTL_DEFAULT_OE   50563
#define IDH_CHAR_SET_OE   50564
#define IDH_INTL_FONT_PROP_OE   50565
#define IDH_INTL_FONT_FIXED_OE   50566
#define IDH_FONT_MIME_OE   50567

//New connection radio buttons
#define IDH_NEVERDIAL   50568
#define IDH_DIALIF_NETCNX_GONE   50569

//New Autosearch options in advanced tab
#define IDH_ADDBAR_SRCH_GOTOBEST   50570
#define IDH_ADDBAR_SRCH_RESULTS_ONLY   50571
#define IDH_ADDBAR_DONT_SRCH   50572
#define IDH_ADDBAR_DISP_RESULTS_WHERE   50573

#define IDH_RESET_WEBSTGS_BUTTON 50574

//More Search Settings dialog box
#define IDH_MORESRCH_AVAIL_PROVIDERS  50575 // Available providers list
#define IDH_MORESRCH_PREFERREDPROVIDERS  50576 //Preferred providers list
#define IDH_MORESRCH_ADD_PROVID  50577 //Add button
#define IDH_MORESRCH_REMOVE_PROVID  50578 //Remove button
#define IDH_MORESRCH_PREFRD_MOVEUP  50579  //Move up button
#define IDH_MORESRCH_PREFRD_MOVEDN  50580//Move down button
#define IDH_MORESRCH_RESET  50581 //Reset button

//New IE5.01 Reuse Windows for launching shortcuts option and
//enable personalized favorites menu

#define IDH_REUSE_WINDOWS_FOR_SHORTCUTS 50582
#define IDH_ENABLE_PERSONALIZED_FAVORITES_MENU 50583

#define IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD_CONFIRM 50584 //Displaycpl, Web tab, My current Home page properties, Download tab, Login dialog box, password confirmation text box
#define IDH_SUBPROPS_NEW_SCHEDULE_AUTOCONNECT 50585 //Displaycpl, Web tab, My current home page properties, Schedule tab, Add, If my computer is not connected...checkbox
#define IDH_CONNECTION_SHARING 50586 //inetcpl, Connection tab, Sharing button for Internet Connection manager
#define IDH_RADIO_TOOLBAR_OPTION  50587  //inetcpl, Advanced tab, option to always display the internet radio toolbar.

#define IDH_DEL_COOKIE_THIRD_PARTY     50591 
#define IDH_COOKIE_THIRD_PARTY  50593
#define IDH_COOKIE_FIRST_PARTY  50594

//New help for INETCPL -> Privacy tab
#define IDH_PRIVACY_SLIDER 50601  //Privacy settings slider
#define IDH_PRIVACY_IMPORT 50602  //Import button
#define IDH_PRIVACY_RESET_DEFAULTS 50603  //Reset Defaults button
#define IDH_PRIVACY_ADVANCED 50612 //Advanced button

//New help for INETCPL ->Priv tab -> Adv
#define IDH_PRIVADV_OVERRIDE 50607 //check box
#define IDH_PRIVACYADV_ALLOW_SESSION 50608 //check box
#define IDH_PRIVADV_FIRST_PARTY 50609 //first-party settings radio buttons
#define IDH_PRIVACYADV_THIRD_PARTY 50610 //third-party settings radio buttons
#define IDH_PRIVACYADV_EDIT 50611 //edit button

//New help for INETCPL ->Priv tab -> Adv -> Edit
#define IDH_PRIVADV_ALLOW 50613 //Allow button
#define IDH_PRIVADV_REJECT 50614 //Reject button
#define IDH_PRIVADV_REMOVE 50615 //Remove button
#define IDH_PRIVADV_ADDRESS 50616 //Web site text box
#define IDH_PRIVADV_WEBSITES 50617 //Web site list
#define IDH_PRIVADV_REMOVE_ALL 50619 // Remove all button

//New help for INETCPL ->Content
#define IDH_ADV_CLEAR_SSL_CACHE 50623 //Clear SSL State button
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\iimgctx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: iimgctx.h
//
//--------------------------------------------------------------------------

#ifndef _IImgCtxObjects_H_
#define _IImgCtxObjects_H_

#ifdef __cplusplus
extern "C" {
#endif
typedef void (CALLBACK *PFNIMGCTXCALLBACK)(void *, void *);
#ifdef __cplusplus
}
#endif

#define IMGCHG_SIZE         0x0001
#define IMGCHG_VIEW         0x0002
#define IMGCHG_COMPLETE     0x0004
#define IMGCHG_ANIMATE      0x0008
#define IMGCHG_MASK         0x000F

#define IMGLOAD_NOTLOADED   0x00100000  // Image has not yet been loaded
#define IMGLOAD_LOADING     0x00200000  // Image in the process of being loaded
#define IMGLOAD_STOPPED     0x00400000  // Imaged aborted
#define IMGLOAD_ERROR       0x00800000  // Error loading image
#define IMGLOAD_COMPLETE    0x01000000  // Image loaded
#define IMGLOAD_MASK        0x01F00000

#define IMGBITS_NONE        0x02000000
#define IMGBITS_PARTIAL     0x04000000
#define IMGBITS_TOTAL       0x08000000
#define IMGBITS_MASK        0x0E000000

#define IMGANIM_ANIMATED    0x10000000
#define IMGANIM_MASK        0x10000000

#define IMGTRANS_OPAQUE     0x20000000
#define IMGTRANS_MASK       0x20000000

#define DWN_COLORMODE       0x0000003F  // Explicit color mode requested
#define DWN_DOWNLOADONLY    0x00000040  // Download data only, don't decode
#define DWN_FORCEDITHER     0x00000080  // Override automatic dithering
#define DWN_RAWIMAGE        0x00000100  // Disable dithering
#define DWN_MIRRORIMAGE     0x00000200  // Mirror the image

/* Definition of interface: IImgCtx */
#undef INTERFACE
#define INTERFACE IImgCtx

// {3050f3d7-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_IImgCtx, 0x3050f3d7, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DECLARE_INTERFACE_(IImgCtx, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IImgCtx methods */

    /* Initialization/Download methods */
    STDMETHOD(Load)(THIS_ LPCWSTR pszUrl, DWORD dwFlags) PURE;
    STDMETHOD(SelectChanges)(THIS_ ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal) PURE;
    STDMETHOD(SetCallback)(THIS_ PFNIMGCTXCALLBACK pfn, void * pvPrivateData) PURE;
    STDMETHOD(Disconnect)(THIS) PURE;

        /* Query methods */
    STDMETHOD(GetUpdateRects)(THIS_ struct tagRECT FAR* prc, struct tagRECT FAR* prcImg, long FAR* pcrc) PURE;
    STDMETHOD(GetStateInfo)(THIS_ ULONG FAR* pulState, struct tagSIZE FAR* psize, BOOL fClearChanges) PURE;
    STDMETHOD(GetPalette)(THIS_ HPALETTE FAR* phpal) PURE;

    /* Rendering methods */
    STDMETHOD(Draw)(THIS_ HDC hdc, struct tagRECT FAR* prcBounds) PURE;
    STDMETHOD(Tile)(THIS_ HDC hdc, struct tagPOINT FAR* pptBackOrg, struct tagRECT FAR* prcClip, struct tagSIZE FAR* psize) PURE;
    STDMETHOD(StretchBlt)(THIS_ HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP) PURE;
};

#ifdef COBJMACROS


#define IImgCtx_QueryInterface(This,riid,ppvObject)     \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImgCtx_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IImgCtx_Release(This)   \
    (This)->lpVtbl -> Release(This)

#define IImgCtx_Load(This, pszUrl, dwFlags)     \
        (This)->lpVtbl -> Load(This, pszUrl, dwFlags)

#define IImgCtx_Draw(This, hdc, prcBounds)              \
        (This)->lpVtbl -> Draw(This, hdc, prcBounds)

#define IImgCtx_Tile(This, hdc, pptBackOrg, prcClip, psize)             \
        (This)->lpVtbl -> Tile(This, hdc, pptBackOrg, prcClip, psize)

#define IImgCtx_GetUpdateRects(This, prc, prcImg, pcrc) \
        (This)->lpVtbl -> GetUpdateRects(This, prc, prcImg, pcrc)

#define IImgCtx_GetStateInfo(This, pulState, psize, fClearChanges)      \
        (This)->lpVtbl -> GetStateInfo(This, pulState, psize, fClearChanges)

#define IImgCtx_GetPalette(This, phpal) \
        (This)->lpVtbl -> GetPalette(This, phpal)
        
#define IImgCtx_SelectChanges(This, ulChgOn, ulChgOff, fSignal) \
        (This)->lpVtbl -> SelectChanges(This, ulChgOn, ulChgOff, fSignal)

#define IImgCtx_SetCallback(This, pfnCallback, pvPrivateData)   \
        (This)->lpVtbl -> SetCallback(This, pfnCallback, pvPrivateData)

#define IImgCtx_Disconnect(This) \
    (This)->lpVtbl -> Disconnect(This)

#define IImgCtx_StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)   \
    (This)->lpVtbl -> StretchBlt(This, hdc, dstX, dstY, dstXE, dstYE, srcX, srcY, srcXE, srcYE, dwROP)

#endif /* COBJMACROS */


// {3050f3d6-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(CLSID_IImgCtx, 0x3050f3d6, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\iert.h ===
// iert.h - Definitions, and Prototypes for the Internet Explorer 
//          implementation of the c-runtime library.
//
// History:
//     Created on 16-May-1997 by Vince Roggero (vincentr)
//

#ifdef __cplusplus
extern "C" 
{
#endif

/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char* __cdecl StrTokEx (char ** pstring, const char * control);


/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/
double __cdecl StrToDbl(const char *strIn, char **strStop);

#ifdef __cplusplus
}   // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\inethelp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

//
// HELP.H - IDHs for the Internet Control Panel
//

//
// GLOBALS... ie... used to give the same info on every page
//

#include <iehelpid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\inetreg.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1998               **
//*********************************************************************

//
//      INETREG.H - String literals for HKEYs in registry
//

#ifndef _INETREGSTRS_H_
#define _INETREGSTRS_H_


//
// HKEY: HKEY_CURRENT_USER
//

//
// Top level defines
//
#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZIEPATH        TSZMICROSOFTPATH TEXT("\\Internet Explorer")
#define TSZWINCURVERPATH TSZMICROSOFTPATH TEXT("\\windows\\CurrentVersion")
#define TSZWININETPATH   TSZWINCURVERPATH TEXT("\\Internet Settings")

// Windows : HKLM
#define REGSTR_PATH_RUNONCE_KEY TSZWINCURVERPATH TEXT("\\RunOnce")

// INETCPL : HKLM
#define REGSTR_PATH_INETCPL_PS_EXTENTIONS TSZWINCURVERPATH TEXT("\\Controls Folder\\Internet")

//
// Explorer : HKCU
//
#define REGSTR_PATH_IEXPLORER           TSZIEPATH

// Main
#define SZ_IE_MAIN                      "Main"
#define REGSTR_PATH_MAIN                TSZIEPATH TEXT( "\\") TEXT(SZ_IE_MAIN)
#define REGSTR_KEY_MAIN                 TEXT(SZ_IE_MAIN)

#define REGSTR_VAL_SMOOTHSCROLL         TEXT("SmoothScroll")
#define REGSTR_VAL_SMOOTHSCROLL_DEF     TRUE

#define REGSTR_VAL_SHOWTOOLBAR          TEXT("Show_ToolBar")
#define REGSTR_VAL_SHOWADDRESSBAR       TEXT("Show_URLToolBar")
#define REGSTR_VAL_STARTPAGE            TEXT("Start Page")
#define REGSTRA_VAL_STARTPAGE           "Start Page"
#define REGSTR_VAL_SEARCHPAGE           TEXT("Search Page")
#define REGSTR_VAL_LOCALPAGE            TEXT("Local Page")

#define REGSTR_VAL_USESTYLESHEETS       TEXT("Use Stylesheets")
#define REGSTR_VAL_USESTYLESHEETS_TYPE  REG_SZ  // "yes" or "no"
#define REGSTR_VAL_USESTYLESHEETS_DEF   TEXT("yes")

#define REGSTR_VAL_USEICM               TEXT("UseICM")
#define REGSTR_VAL_USEICM_DEF           FALSE

#define REGSTR_VAL_SHOWFOCUS            TEXT("Tabstop - MouseDown")
#define REGSTR_VAL_SHOWFOCUS_TYPE       REG_SZ  // "yes" or "no"
#define REGSTR_VAL_SHOWFOCUS_DEF        TEXT("no")

#define REGSTR_VAL_LOADIMAGES           TEXT("Display Inline Images")
#define REGSTR_VAL_PLAYSOUNDS           TEXT("Play_Background_Sounds")
#define REGSTR_VAL_PLAYVIDEOS           TEXT("Display Inline Videos")
#define REGSTR_VAL_ANCHORUNDERLINE      TEXT("Anchor Underline")
#define REGSTR_VAL_USEDLGCOLORS         TEXT("Use_DlgBox_Colors")
#define REGSTR_VAL_CHECKASSOC           TEXT("Check_Associations")
#define REGSTR_VAL_SHOWFULLURLS         TEXT("Show_FullURL")
#define REGSTR_VAL_AUTOSEARCH           TEXT("Do404Search")
#define REGSTR_VAL_AUTONAVIGATE         TEXT("SearchForExtensions")
#define REGSTR_VAL_HTTP_ERRORS          TEXT("Friendly http errors")

#define REGSTR_VAL_PAGETRANSITIONS      TEXT("Page_Transitions")
#define REGSTR_VAL_PAGETRANSITIONS_DEF  TRUE

#define REGSTR_VAL_USEIBAR              TEXT("UseBar")

// Settings
#define SZ_IE_SETTINGS  "Settings"
#define REGSTR_PATH_IE_SETTINGS         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SETTINGS)
#define REGSTR_KEY_IE_SETTINGS          TEXT(SZ_IE_SETTINGS)

#define REGSTR_VAL_IE_CUSTOMCOLORS      TEXT("Custom Colors")
#define REGSTR_VAL_IE_CUSTOMCOLORS_TYPE REG_BINARY

#define REGSTR_VAL_ANCHORCOLOR          TEXT("Anchor Color")
#define REGSTR_VAL_ANCHORCOLORVISITED   TEXT("Anchor Color Visited")
#define REGSTR_VAL_BACKGROUNDCOLOR      TEXT("Background Color")
#define REGSTR_VAL_TEXTCOLOR            TEXT("Text Color")
#define REGSTR_VAL_ANCHORCOLORHOVER     TEXT("Anchor Color Hover")
#define REGSTR_VAL_USEHOVERCOLOR        TEXT("Use Anchor Hover Color")

// Security
#define SZ_IE_SECURITY  "Security"
#define REGSTR_PATH_IE_SECURITY         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SECURITY)
#define REGSTR_KEY_IE_SECURITY          TEXT(SZ_IE_SECURITY)

#define REGSTR_VAL_SAFETYWARNINGLEVEL   TEXT("Safety Warning Level")

// HTML Editing
#define SZ_IE_DEFAULT_HTML_EDITOR       "Default HTML Editor"
#define REGSTR_PATH_DEFAULT_HTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_HTML_EDITOR)
#define REGSTR_KEY_DEFAULT_HTML_EDITOR  TEXT(SZ_IE_DEFAULT_HTML_EDITOR)

// Autocomplete
#define REGSTR_PATH_AUTOCOMPLETE        TSZWINCURVERPATH TEXT("\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

// Old IE4 autocomplete key
#define REGSTR_VAL_USEAUTOCOMPLETE      TEXT("Use AutoComplete")

// iBar
#define SZ_IE_IBAR                      "Bar"
#define TSZIBARPATH                     TSZIEPATH TEXT( "\\") TEXT(SZ_IE_IBAR)
#define REGSTR_PATH_IBAR                TSZIBARPATH
#define REGSTR_KEY_IBAR                 TEXT(SZ_IE_IBAR)

#define SZ_IE_IBAR_BANDS                "Bands"
#define REGSTR_PATH_IBAR_BANDS          TSZIBARPATH TEXT("\\") TEXT(SZ_IE_IBAR_BANDS)
#define REGSTR_KEY_IBAR_BANDS           TEXT(SZ_IE_IBAR_BANDS)


//
// Internet : HKCU
//
// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNETSETTINGS    TSZWININETPATH
#define REGSTR_PATH_INTERNET_SETTINGS   REGSTR_PATH_INTERNETSETTINGS

#define REGSTR_VAL_USERAGENT            TEXT("User Agent")

// path to lan-specific settings
#define REGSTR_PATH_INTERNET_LAN_SETTINGS REGSTR_PATH_INTERNETSETTINGS TEXT("\\LAN")

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETENTRY        TEXT("InternetProfile")
#define REGSTR_VAL_INTERNETPROFILE      REGSTR_VAL_INTERNETENTRY

#define REGSTR_VAL_INTERNETENTRYBKUP    TEXT("BackupInternetProfile")

#define REGSTR_VAL_CODEDOWNLOAD         TEXT("Code Download")
#define REGSTR_VAL_CODEDOWNLOAD_DEF     TEXT("yes")
#define REGSTR_VAL_CODEDOWNLOAD_TYPE    REG_SZ // "yes" or "no"

// policy key for inetcpl restrictions

#define REGSTR_PATH_INETCPL_RESTRICTIONS  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")

// reg valuenames to restrict whether a tab should be shown or not;
// a value of non-zero means don't show that tab.
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_GENERALTAB     TEXT("GeneralTab")
#define REGSTR_VAL_INETCPL_SECURITYTAB    TEXT("SecurityTab")
#define REGSTR_VAL_INETCPL_CONTENTTAB     TEXT("ContentTab")
#define REGSTR_VAL_INETCPL_CONNECTIONSTAB TEXT("ConnectionsTab")
#define REGSTR_VAL_INETCPL_PROGRAMSTAB    TEXT("ProgramsTab")
#define REGSTR_VAL_INETCPL_ADVANCEDTAB    TEXT("AdvancedTab")
#define REGSTR_VAL_INETCPL_PRIVACYTAB     TEXT("PrivacyTab")

// setting to indicate whether or not IEAK launched this instance of inetcpl so extra
// info can be exposed
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_IEAK           TEXT("IEAKContext")

//
//  Cache
//
#define REGSTR_PATH_CACHE  \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Cache")

#define REGSTR_PATH_CACHE_PATHS \
    REGSTR_PATH_CACHE TEXT("\\Paths")

#define REGSTR_PATH_EXTENSIBLE_CACHE \
    REGSTR_PATH_CACHE TEXT("\\Extensible Cache")

#define REGSTR_PATH_TRACKING \
    REGSTR_PATH_EXTENSIBLE_CACHE TEXT("\\Log")

#define REGSTR_PATH_CACHE_SPECIAL_PATHS \
    REGSTR_PATH_CACHE TEXT("Special Paths")

#define REGSTR_VAL_DIRECTORY           TEXT("Directory")
#define REGSTR_VAL_DIRECTORY_TYPE            REG_EXPAND_SZ

#define REGSTR_VAL_NEWDIRECTORY         TEXT("NewDirectory")
#define REGSTR_VAL_NEWDIRECTORY_TYPE    REG_EXPAND_SZ

#define REGSTR_VAL_CACHEPREFIX              TEXT("CachePrefix")
#define REGSTR_VAL_CACHEPREFIX_TYPE     REG_SZ

#define REGSTR_PATH_URLHISTORY \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Url History")

#define REGSTR_PATH_SUBSCRIPTION \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Subscription Folder")

//
// Search Format Strings
//
#define SZ_IE_SEARCHSTRINGS             "UrlTemplate"
#define REGSTR_PATH_SEARCHSTRINGS       REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_SEARCHSTRINGS)
#define REGSTR_KEY_SEARCHSTRINGS        TEXT(SZ_IE_SEARCHSTRINGS)

#define MAX_SEARCH_FORMAT_STRING        255

//
// Server error page dispaly/don't display length thresholds.
//
#define SZ_IE_THRESHOLDS                "ErrorThresholds"
#define REGSTR_PATH_THRESHOLDS          REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_THRESHOLDS)


//
// Access Medium
//
#define REGSTR_VAL_ACCESSMEDIUM         TEXT("AccessMedium")
// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE           TEXT("AccessType")

//
// AutoDial
//
// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME      TEXT("AutodialDllName")
#define REGSTR_VAL_AUTODIALFCNNAME      TEXT("AutodialFcnName")
// class name for window to receive Winsock activity messages
#define REGSTR_VAL_AUTODIAL_MONITORCLASSNAME    TEXT("MS_AutodialMonitor")
#define REGSTR_VAL_AUTODIAL_TRYONLYONCE         TEXT("TryAutodialOnce")

//
// Remote Access
//
// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS        TEXT("RemoteAccess")
#define REGSTR_PATH_REMOTEACESS         REGSTR_PATH_REMOTEACCESS
// this is under HKLM... we are using this to determine if RNA is installed
// or not. We can't rely on finding the DLL since removing this component
// with the control panel's "Add/Remove Software" does not remove the RNAdll.
#define REGSTR_PATH_RNACOMPONENT    TSZWINCURVERPATH    TEXT("\\Setup\\OptionalComponents\\RNA")
#define REGSTR_VAL_RNAINSTALLED     TEXT("Installed")

// values under HKCU\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
// If ForceAutodial is true, will always dial similar to IE4 behavior.
// If it's false, will only dial if network is not available.
#define REGSTR_VAL_ENABLEAUTODIAL               TEXT("EnableAutodial")
#define REGSTR_VAL_ENABLEUNATTENDED             TEXT("EnableUnattended")
#define REGSTR_VAL_NONETAUTODIAL                TEXT("NoNetAutodial")

#define REGSTR_VAL_REDIALATTEMPTS               TEXT("RedialAttempts")
#define REGSTR_VAL_REDIALINTERVAL               TEXT("RedialWait")

#define REGSTR_VAL_ENABLEAUTODIALDISCONNECT     TEXT("EnableAutodisconnect")
#define REGSTR_VAL_ENABLEAUTODISCONNECT         REGSTR_VAL_ENABLEAUTODIALDISCONNECT
#define REGSTR_VAL_ENABLEEXITDISCONNECT         TEXT("EnableExitDisconnect")

#define REGSTR_VAL_ENABLESECURITYCHECK          TEXT("EnableSecurityCheck")

#define REGSTR_VAL_COVEREXCLUDE                 TEXT("CoverExclude")
// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME   TEXT("DisconnectIdleTime")

//
// MOS
//
#define REGSTR_PATH_MOSDISCONNECT       TSZMICROSOFTPATH TEXT("\\MOS\\Preferences")
#define REGSTR_VAL_MOSDISCONNECT        TEXT("DisconnectTimeout")

//
// Proxy : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_PROXYENABLE          TEXT("ProxyEnable")
#define REGSTR_VAL_PROXYSERVER          TEXT("ProxyServer")
#define REGSTR_VAL_PROXYOVERRIDE        TEXT("ProxyOverride")
#define REGSTR_VAL_BYPASSAUTOCONFIG     TEXT("BypassAutoconfig")



//
// Security : HKCU\\WININETPATH
//
#define SZTRUSTWARNLEVEL                    "Trust Warning Level"
#define REGSTR_KEY_TRUSTWARNINGLEVEL        TSZWININETPATH  TEXT(SZTRUSTWARNLEVEL)
#define REGSTR_VAL_TRUSTWARNINGLEVEL        TEXT(SZTRUSTWARNLEVEL) //"none" will turn off WinVerifyTrust warnings.
#define REGSTR_VAL_TRUSTWARNINGLEVEL_TYPE   REG_SZ
#define REGSTR_VAL_TRUSTWARNINGLEVEL_HIGH   TEXT("High")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_MED    TEXT("Medium")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_LOW    TEXT("No Security")
// default depends on MSHTML's prefs nSafetyWarningLevel

#define REGSTR_VAL_SECURITYWARNONSEND       TEXT("WarnOnPost")
#define REGSTR_VAL_SECURITYWARNONSEND_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONSEND_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONSENDALWAYS         TEXT("WarnAlwaysOnPost")
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_TYPE    REG_BINARY // FALSE-Only if... TRUE-Always
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONVIEW       TEXT("WarnOnView")
#define REGSTR_VAL_SECURITYWARNONVIEW_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONVIEW_DEF   TRUE

#define REGSTR_VAL_SECURITYALLOWCOOKIES         TEXT("AllowCookies")
#define REGSTR_VAL_SECURITYALLOWCOOKIES_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYALLOWCOOKIES_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONZONECROSSING       TEXT("WarnOnZoneCrossing")
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING         TEXT("WarnOnBadCertRecving")
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING         TEXT("WarnOnBadCertSending")
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_DEF     TRUE

#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES       TEXT("DisableCachingOfSSLPages")
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_TYPE  REG_DWORD
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_DEF   FALSE


//
// Run/Show ActiveX / Java : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_SECURITYACTIVEX              TEXT("Security_RunActiveXControls")
#define REGSTR_VAL_SECURITYACTIVEX_TYPE         REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTIVEX_DEF          TRUE

#define REGSTR_VAL_SECURITYACTICEXSCRIPTS       TEXT("Security_RunScripts")
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_TYPE  REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_DEF   TRUE

#define REGSTR_VAL_SECURITYJAVA                 TEXT("Security_RunJavaApplets")
#define REGSTR_VAL_SECURITYJAVA_TYPE            REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYJAVA_DEF             TRUE

//
// Java VM exclusively : HKCU
//
#define SZJAVAVMPATH                            "\\Java VM"
#define REGSTR_PATH_JAVAVM                      TSZMICROSOFTPATH TEXT(SZJAVAVMPATH)

#define REGSTR_VAL_JAVAJIT                      TEXT("EnableJIT")
#define REGSTR_VAL_JAVAJIT_TYPE                 REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVAJIT_DEF                  FALSE

#define REGSTR_VAL_JAVALOGGING                   TEXT("EnableLogging")
#define REGSTR_VAL_JAVALOGGING_TYPE              REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVALOGGING_DEF               FALSE


//
// QuickLinks
//
// this is where custom quicklinks are stored
#define SZTOOLBAR               "\\Toolbar"
#define TSZTOOLBAR              TEXT(SZTOOLBAR)
#define REGSTR_PATH_TOOLBAR     TSZIEPATH TEXT(SZTOOLBAR)
#define REGSTR_KEY_QUICKLINKS   TSZIEPATH TSZTOOLBAR TEXT("\\Links")
#define REGSTR_VAL_DAYSTOKEEP   TEXT("DaysToKeep")

#define SZNOTEXT                "NoText"
#define REGSTR_VAL_NOTEXT       TEXT(SZNOTEXT)
#define REGSTR_KEY_NOTEXT       TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZNOTEXT)
#define SZVISIBLE               "VisibleBands"
#define REGSTR_VAL_VISIBLE      TEXT(SZVISIBLE)
#define REGSTR_KEY_VISIBLE      TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZVISIBLE)


#define REGSTR_VAL_VISIBLEBANDS         TEXT("VisibleBands")
#define REGSTR_VAL_VISIBLEBANDS_TYPE    REG_DWORD   // 3 bits (see below)
#define REGSTR_VAL_VISIBLEBANDS_DEF     0x7         // all three bands
#define TOOLSBAND                       0x1
#define ADDRESSBAND                     0x2
#define LINKSBAND                       0x4

#define SZBACKBITMAP          "BackBitmap"
#define REGSTR_VAL_BACKBITMAP       TEXT("BackBitmap")
#define REGSTR_VAL_BACKBITMAP_TYPE  REG_SZ
// "" = no bitmap or fillin with valid path, delete for default

#define REGSTR_KEY_BACKBITMAP   TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZBACKBITMAP)

//
// Schannel Settings: HKLM
//

#define TSZSCHANNELPATH             TEXT("SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define TSZSCHANNELPROTOCOLSPATH    TSZSCHANNELPATH TEXT("\\Protocols")

#define REGSTR_PATH_PCT1            TSZSCHANNELPROTOCOLSPATH TEXT("\\PCT 1.0\\Client")
#define REGSTR_PATH_SSL2            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 2.0\\Client")
#define REGSTR_PATH_SSL3            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 3.0\\Client")
#define REGSTR_PATH_UNIHELLO        TSZSCHANNELPROTOCOLSPATH TEXT("\\Multi-Protocol Unified Hello\\Client")

#define REGSTR_VAL_SCHANNELENABLEPROTOCOL         TEXT("Enabled")
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_TYPE    REG_DWORD
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_DEF     TRUE


//
// Mail and News: HKLM
//
#ifdef UNIX

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Microsoft\\Internet Explorer\\Unix")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\MailCommand")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\NewsCommand")
#define REGSTR_PATH_VSOURCECLIENTS  TSZINTERNETCLIENTSPATH  TEXT("\\VSourceCommand")
#define REGSTR_PATH_EDITORS         TSZINTERNETCLIENTSPATH  TEXT("\\Editors")
#define REGSTR_PATH_DEFAULT         TEXT("default")
#define REGSTR_PATH_CURRENT         TEXT("current")

#else

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Clients")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Mail")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\News")
#define REGSTR_PATH_CALENDARCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Calendar")
#define REGSTR_PATH_CONTACTCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Contacts")
#define REGSTR_PATH_CALLCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Internet Call")

#endif // !UNIX

#ifdef UNIX
// Registry item containing the exe name to check for disabling OE
#define IE_USE_OE_PRESENT_HKEY HKEY_LOCAL_MACHINE
#define IE_USE_OE_PRESENT_KEY  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\app.paths\\msimn.exe")
#define IE_USE_OE_PRESENT_VALUE NULL

// locations for new OE control variables for unix
#define IE_USE_OE_MAIL_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_MAIL_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Mail")
#define IE_USE_OE_MAIL_VALUE TEXT("Use Outlook Express")

#define IE_USE_OE_NEWS_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_NEWS_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\News")
#define IE_USE_OE_NEWS_VALUE TEXT("Use Outlook Express")
#endif // UNIX

// this is under the mail and news paths
#define TSZPROTOCOLSPATH            TEXT("Protocols\\")
// and one these is under the protocols path
#define TSZMAILTOPROTOCOL           TEXT("mailto")
#define TSZNEWSPROTOCOL             TEXT("news")
#define TSZCALLTOPROTOCOL           TEXT("callto")
#define TSZLDAPPROTOCOL             TEXT("ldap")
#define TSZCALENDARPROTOCOL         TEXT("unk")

#ifdef UNIX
#define TSZVSOURCEPROTOCOL          TEXT("view source")
#endif

//
// International and Fonts: HKCU\\TSZIEPATH
//
#define REGSTR_PATH_INTERNATIONAL   TSZIEPATH   TEXT("\\International")

#define REGSTR_PATH_INTERNATIONAL_SCRIPTS  TSZIEPATH   TEXT("\\International\\Scripts")

#define REGSTR_VAL_DEFAULT_CODEPAGE         TEXT("Default_CodePage")
#define REGSTR_VAL_DEFAULT_CODEPAGE_TYPE    REG_SZ  // code page
                   // will grab default from system if not found

#define REGSTR_VAL_DEFAULT_SCRIPT         TEXT("Default_Script")
#define REGSTR_VAL_DEFAULT_SCRIPT_TYPE    REG_SZ  
                   // will grab default from system if not found


#define REGSTR_VAL_ACCEPT_LANGUAGE          TEXT("AcceptLanguage")
#define REGSTR_VAL_ACCETP_LANGUAGE_TYPE     REG_SZ


// each CHARSET has a unique key under REGSTR_PATH_INTERNATIONAL
// which has the following values defined
#define REGSTR_VAL_FONT_SCRIPTS          TEXT("Scripts")
#define REGSTR_VAL_FONT_SCRIPT           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_TYPE      REG_SZ  // friendly name of font if other than system
                                                 // no default

#define REGSTR_VAL_FONT_SCRIPT_NAME           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_NAME_TYPE      REG_SZ                                                        


#define REGSTR_VAL_DEF_ENCODING         TEXT("Default_Encoding")
#define REGSTR_VAL_DEF_ENCODING_TYPE    REG_SZ  // internal MIME table name
                                                // no default

#define REGSTR_VAL_DEF_INETENCODING         TEXT("Default_InternetEncoding")
#define REGSTR_VAL_DEF_INETENCODING_TYPE    REG_DWORD
                                                // no default

#define REGSTR_VAL_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_SCRIPT_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_SCRIPT_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_FONT_SIZE        TEXT("IEFontSize")
#define REGSTR_VAL_FONT_SIZE_TYPE   REG_BINARY
#define REGSTR_VAL_FONT_SIZE_DEF    2       // default size : Medium

#define REGSTR_VAL_AUTODETECT         TEXT("AutoDetect")
#define REGSTR_VAL_AUTODETECT_TYPE    REG_SZ

// MIME database charset extension
#define REGSTR_PATH_MIME_DATABASE           TEXT("MIME\\Database")
#define REGSTR_KEY_MIME_DATABASE_CHARSET    REGSTR_PATH_MIME_DATABASE TEXT("\\Charset")
#define REGSTR_KEY_MIME_DATABASE_CODEPAGE   REGSTR_PATH_MIME_DATABASE TEXT("\\CodePage")
#define REGSTR_KEY_MIME_DATABASE_RFC1766    REGSTR_PATH_MIME_DATABASE TEXT("\\Rfc1766")

#define REGSTR_VAL_CODEPAGE                 TEXT("CodePage")
#define REGSTR_VAL_CODEPAGE_TYPE            REG_DWORD

#define REGSTR_VAL_INETENCODING             TEXT("InternetEncoding")
#define REGSTR_VAL_INETENCODING_TYPE        REG_DWORD

#define REGSTR_VAL_FAMILY                   TEXT("Family")
#define REGSTR_VAL_FAMILY_TYPE              REG_DWORD

#define REGSTR_VAL_LEVEL                    TEXT("Level")
#define REGSTR_VAL_LEVEL_TYPE               REG_DWORD

#define REGSTR_VAL_ALIASTO                  TEXT("AliasForCharset")
#define REGSTR_VAL_ALIASTO_TYPE             REG_SZ

#define REGSTR_VAL_ENCODENAME               TEXT("EncodingName")
#define REGSTR_VAL_ENCODENAME_TYPE          REG_SZ

#define REGSTR_VAL_DESCRIPTION              TEXT("Description")
#define REGSTR_VAL_DESCRIPTION_TYPE         REG_SZ

#define REGSTR_VAL_WEBCHARSET               TEXT("WebCharset")
#define REGSTR_VAL_WEBCHARSET_TYPE          REG_SZ

#define REGSTR_VAL_BODYCHARSET              TEXT("BodyCharset")
#define REGSTR_VAL_BODYCHARSET_TYPE         REG_SZ

#define REGSTR_VAL_HEADERCHARSET            TEXT("HeaderCharset")
#define REGSTR_VAL_HEADERCHARSET_TYPE       REG_SZ

#define REGSTR_VAL_FIXEDWIDTHFONT           TEXT("FixedWidthFont")
#define REGSTR_VAL_FIXEDWIDTHFONT_TYPE      REG_SZ

#define REGSTR_VAL_PROPORTIONALFONT         TEXT("ProportionalFont")
#define REGSTR_VAL_PROPOPRTIONALFONT_TYPE   REG_SZ

#define REGSTR_VAL_PRIVCONVERTER            TEXT("PrivConverter")
#define REGSTR_VAL_PRIVCONVERTER_TYPE       REG_SZ

#endif // _INETREGSTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\mimedisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

#ifndef __MIMEDISP_H__
#define __MIMEDISP_H__

#define DISPID_IMIMEEDIT_BASE       100

#define DISPID_IMIMEEDIT_SRC        (DISPID_IMIMEEDIT_BASE + 1)
#define DISPID_IMIMEEDIT_STYLE      (DISPID_IMIMEEDIT_BASE + 2)
#define DISPID_IMIMEEDIT_EDITMODE   (DISPID_IMIMEEDIT_BASE + 3)
#define DISPID_IMIMEEDIT_MSGSRC     (DISPID_IMIMEEDIT_BASE + 4)
#define DISPID_IMIMEEDIT_TEXT       (DISPID_IMIMEEDIT_BASE + 5)
#define DISPID_IMIMEEDIT_HTML       (DISPID_IMIMEEDIT_BASE + 6)
#define DISPID_IMIMEEDIT_CLEAR      (DISPID_IMIMEEDIT_BASE + 7)
#define DISPID_IMIMEEDIT_DOCUMENT   (DISPID_IMIMEEDIT_BASE + 8)


#endif //__MIMEDISP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\jobexec.h ===
//=--------------------------------------------------------------------------=
// jobexec.h
//=--------------------------------------------------------------------------=
// Copyright 1996-1998 Microsoft Corporation.  All Rights Reserved.
//
//
// interface declaration for the JobExecuter object.
//
#ifndef _JOBEXEC_H_

#ifdef __cplusplus
extern "C"{
#endif

typedef struct
{
   DWORD cbSize;
   DWORD dwKBReqWinDrive;
   DWORD dwKBAvailWinDrive;
   DWORD dwKBReqInstallDrive;
   DWORD dwKBAvailInstallDrive;
   DWORD dwKBReqDownloadDrive;
   DWORD dwKBAvailDownloadDrive;
} CHECKDISKSPACE;

// {7279B780-2867-11d0-A066-00AA00B6015C}
DEFINE_GUID(CLSID_JobExecuter, 0x7279b780, 0x2867, 0x11d0, 0xa0, 0x66, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

// {7279B781-2867-11d0-A066-00AA00B6015C}
DEFINE_GUID(IID_IJobExecuter, 0x7279b782, 0x2867, 0x11d0, 0xa0, 0x66, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IJobExecuter

#define E_PARTIAL                   _HRESULT_TYPEDEF_(0x80100001L)
#define E_ABORTPARTIAL              _HRESULT_TYPEDEF_(0x80100002L)


DECLARE_INTERFACE_(IJobExecuter, IUnknown)
{
   // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(InitializeJob)(THIS_ LPCSTR pszJobName, char chMode) PURE;
   STDMETHOD(SetDownloadDir)(THIS_ LPCSTR pszDownloadDir) PURE;
   STDMETHOD(SetBaseUrls)(THIS_ LPCSTR pszBaseUrl) PURE;
   STDMETHOD(SetInstallDrive)(THIS_ CHAR chDrive) PURE;
   STDMETHOD(SetInstallMode)(THIS_ CHAR chMode) PURE;
   STDMETHOD(SetInstallOptions)(THIS_ DWORD dwInsFlag) PURE;
   STDMETHOD(CheckFreeSpace)(THIS_  CHECKDISKSPACE *pcds) PURE;

   STDMETHOD(DownloadJob)(THIS_ DWORD dwFlags, LPSTR *ppszSuccessStr, LPSTR *ppszErrorStr) PURE;
   STDMETHOD(InstallJob)(THIS_ DWORD dwFlags, DWORD *dwStatus,
                               LPSTR *ppszSuccessStr, LPSTR *ppszErrorStr) PURE;



   STDMETHOD(SetHWND)(THIS_ HWND hForUI) PURE;
   STDMETHOD(SetIStream)(THIS_ IStream *pstm) PURE;
};

// The job key, off of HKCU
#define KEY_JOB  "Software\\Microsoft\\Active Setup\\Jobs"

#define VALUE_BASEURL      "BaseUrl"
#define VALUE_CIFNAME      "InstallList"
#define VALUE_CABNAME      "CabName"
#define VALUE_MODELIST     "InstallModes"
#define VALUE_DEFAULTMODE  "DefaultMode"
#define VALUE_QUIETMODE    "QuietMode"
#define VALUE_LOCALURL     "LocalUrl"

// for support of suspend,resume,abort from outside jobexec.dll
#define VALUE_STATUS      "Status"
#define DATA_SUSPEND       1
#define DATA_RESUME        2
#define DATA_ABORT         3

#ifdef __cplusplus
}
#endif

#define _JOBEXEC_H_
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\inseng.h ===
//=--------------------------------------------------------------------------=
// inseng.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
//
// interface declaration for the InstallEngine control.
//
#ifndef _INSENG_H_

#ifdef __cplusplus
extern "C"{
#endif

#define MAX_ID_LENGTH            48
#define MAX_DISPLAYNAME_LENGTH  128


#define ICI_NOTINSTALLED          0
#define ICI_INSTALLED             1
#define ICI_NEWVERSIONAVAILABLE   2
#define ICI_UNKNOWN               3
#define ICI_OLDVERSIONAVAILABLE   4
#define ICI_NOTINITIALIZED        0xffffffff

#define ABORTINSTALL_NORMAL       0
#define ABORTINSTALL_IMMEADIATE   1


#define ENGINESTATUS_NOTREADY     0
#define ENGINESTATUS_LOADING      1
#define ENGINESTATUS_INSTALLING   2
#define ENGINESTATUS_READY        3

#define CDINSTALL                     1
#define WEBINSTALL                    2
#define WEBINSTALL_DIFFERENTMACHINE   3
#define NETWORKINSTALL                4
#define LOCALINSTALL                  5

#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'


#define SETACTION_NONE            0x00000000
#define SETACTION_INSTALL         0x00000001

#define INSTALLOPTIONS_NOCACHE             0x00000001
#define INSTALLOPTIONS_DOWNLOAD            0x00000002
#define INSTALLOPTIONS_INSTALL             0x00000004
#define INSTALLOPTIONS_DONTALLOWXPLATFORM  0x00000008
#define INSTALLOPTIONS_FORCEDEPENDENCIES    0x00000010

#define EXECUTEJOB_SILENT              0x00000001
#define EXECUTEJOB_DELETE_JOB          0x00000002

#define EXECUTEJOB_VERIFYFILES         0x00000008
#define EXECUTEJOB_IGNORETRUST         0x00000010
#define EXECUTEJOB_IGNOREDOWNLOADERROR 0x00000020
#define EXECUTEJOB_DONTALLOWCANCEL     0x00000040


#define E_FILESMISSING             _HRESULT_TYPEDEF_(0x80100003L)



HRESULT WINAPI CheckTrust(LPCSTR pszFilename, HWND hwndForUI, BOOL bShowBadUI);
HRESULT WINAPI CheckTrustEx(LPCSTR szURL, LPCSTR szFilename, HWND hwndForUI, BOOL bShowBadUI, DWORD dwReserved);
HRESULT WINAPI PurgeDownloadDir(LPCSTR pszDir);
HRESULT WINAPI CheckForVersionConflict();


typedef struct
{
   DWORD cbSize;
   DWORD dwInstallSize;
   DWORD dwWinDriveSize;
   DWORD dwDownloadSize;
   DWORD dwDependancySize;
   DWORD dwInstallDriveReq;
   DWORD dwWinDriveReq;
   DWORD dwDownloadDriveReq;
   CHAR  chWinDrive;
   CHAR  chInstallDrive;
   CHAR  chDownloadDrive;
   DWORD dwTotalDownloadSize;
} COMPONENT_SIZES;

typedef struct
{
   DWORD cbSize;
   DWORD dwDownloadKBRemaining;
   DWORD dwInstallKBRemaining;
   DWORD dwDownloadSecsRemaining;
   DWORD dwInstallSecsRemaining;
} INSTALLPROGRESS;


enum InstallStatus
{
   INSTALLSTATUS_INITIALIZING,
   INSTALLSTATUS_DEPENDENCY,
   INSTALLSTATUS_DOWNLOADING,
   INSTALLSTATUS_COPYING,
   INSTALLSTATUS_RETRYING,
   INSTALLSTATUS_CHECKINGTRUST,
   INSTALLSTATUS_EXTRACTING,
   INSTALLSTATUS_RUNNING,
   INSTALLSTATUS_FINISHED,
   INSTALLSTATUS_DOWNLOADFINISHED
};

// defines for engine problems  (OnEngineProblem)
#define ENGINEPROBLEM_DOWNLOADFAIL   0x00000001


// Actions particular to ENGINEPROBLEM_DOWNLOAD
#define DOWNLOADFAIL_RETRY   0x00000001


#define STOPINSTALL_REBOOTNEEDED   0x00000001
#define STOPINSTALL_REBOOTREFUSED  0x00000002


DEFINE_GUID(IID_IInstallEngineCallback,0x6E449685L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngineCallback

DECLARE_INTERFACE_(IInstallEngineCallback, IUnknown)
{
   // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;


   STDMETHOD(OnEngineStatusChange)(THIS_ DWORD dwEngineStatus, DWORD substatus) PURE;
   STDMETHOD(OnStartInstall)(THIS_ DWORD dwDLSize, DWORD dwInstallSize) PURE;
   STDMETHOD(OnStartComponent)(THIS_ LPCSTR pszID, DWORD dwDLSize, DWORD dwInstallSize, LPCSTR pszString) PURE;
   STDMETHOD(OnComponentProgress)(THIS_ LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax) PURE;
   STDMETHOD(OnStopComponent)(THIS_ LPCSTR pszID, HRESULT hError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus) PURE;
   STDMETHOD(OnStopInstall)(THIS_ HRESULT hrError, LPCSTR szError, DWORD dwStatus) PURE;
   STDMETHOD(OnEngineProblem)(THIS_ DWORD dwEngineProblem, LPDWORD dwAction) PURE;
};



DEFINE_GUID(IID_IInstallEngine,0x6E449684L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngine

DECLARE_INTERFACE_(IInstallEngine , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   // Methods to set engine up for install
   STDMETHOD(GetEngineStatus)(THIS_ DWORD *theenginestatus) PURE;
   STDMETHOD(SetCifFile)(THIS_ LPCSTR pszCabName, LPCSTR pszCifName) PURE;
   STDMETHOD(DownloadComponents)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(InstallComponents)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(EnumInstallIDs)(THIS_ UINT uIndex, LPSTR *ppszID) PURE;
   STDMETHOD(EnumDownloadIDs)(THIS_ UINT uIndex, LPSTR *ppszID) PURE;
   STDMETHOD(IsComponentInstalled)(THIS_ LPCSTR pszID, DWORD *pdwStatus) PURE;
   STDMETHOD(RegisterInstallEngineCallback)(THIS_ IInstallEngineCallback *pcb) PURE;
   STDMETHOD(UnregisterInstallEngineCallback)(THIS) PURE;
   STDMETHOD(SetAction)(THIS_ LPCSTR pszID, DWORD dwAction, DWORD dwPriority) PURE;
   STDMETHOD(GetSizes)(THIS_ LPCSTR pszID, COMPONENT_SIZES *pSizes) PURE;
   STDMETHOD(LaunchExtraCommand)(THIS_ LPCSTR pszInfName, LPCSTR pszSection) PURE;
   STDMETHOD(GetDisplayName)(THIS_ LPCSTR pszID, LPSTR *ppszName) PURE;

   // Info about the install (should be structure to fill in
   //   like GetBindInfo (GetInstallInfo)
   STDMETHOD(SetBaseUrl)(THIS_ LPCSTR pszBaseName) PURE;
   STDMETHOD(SetDownloadDir)(THIS_ LPCSTR pszDownloadDir) PURE;
   STDMETHOD(SetInstallDrive)(THIS_ CHAR chDrive) PURE;
   STDMETHOD(SetInstallOptions)(THIS_ DWORD dwInsFlag) PURE;
   STDMETHOD(SetHWND)(THIS_ HWND hForUI) PURE;
   STDMETHOD(SetIStream)(THIS_ IStream *pstm) PURE;


   // Engine control during installation (seperate interface?)
   STDMETHOD(Abort)(THIS_ DWORD dwFlags) PURE;
   STDMETHOD(Suspend)(THIS) PURE;
   STDMETHOD(Resume)(THIS) PURE;

};

DEFINE_GUID(IID_IInstallEngineTiming,0x6E449687L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngineTiming

DECLARE_INTERFACE_(IInstallEngineTiming , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(GetRates)(THIS_ DWORD *pdwDownload, DWORD *pdwInstall) PURE;
   STDMETHOD(GetInstallProgress)(THIS_ INSTALLPROGRESS *pinsprog) PURE;
};


DEFINE_GUID(CLSID_InstallEngine,0x6E449686L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);


//  The site manager interface

typedef struct
{
   UINT cbSize;
   LPSTR pszLang;
   LPSTR pszRegion;
} SITEQUERYPARAMS;

typedef struct
{
   UINT cbSize;
   LPSTR pszUrl;
   LPSTR pszFriendlyName;
   LPSTR pszLang;
   LPSTR pszRegion;
} DOWNLOADSITE;


// {BFC880F3-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(IID_IDownloadSite,
0xbfc880f3, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IDownloadSite

DECLARE_INTERFACE_(IDownloadSite , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(GetData)(THIS_ DOWNLOADSITE **pds) PURE;
};

// {BFC880F0-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(IID_IDownloadSiteMgr,
0xbfc880f0, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);

#undef INTERFACE
#define INTERFACE IDownloadSiteMgr

DECLARE_INTERFACE_(IDownloadSiteMgr , IUnknown)
{
     // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   STDMETHOD(Initialize)(THIS_ LPCSTR pszUrl, SITEQUERYPARAMS *pqp) PURE;
   STDMETHOD(EnumSites)(THIS_ DWORD dwIndex, IDownloadSite **pds) PURE;
};

// {BFC880F1-7484-11d0-8309-00AA00B6015C}
DEFINE_GUID(CLSID_DownloadSiteMgr,
0xbfc880f1, 0x7484, 0x11d0, 0x83, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x5c);


// defines for dwUrlFlags
#define URLF_DEFAULT                0x00000000
#define URLF_EXTRACT                0x00000001
#define URLF_RELATIVEURL            0x00000002
#define URLF_DELETE_AFTER_EXTRACT   0x00000004

// types of dependancies
#define DEP_NEVER_INSTALL   'N'
#define DEP_INSTALL         'I'

// platform defines
#define PLATFORM_WIN95              0x00000001
#define PLATFORM_WIN98              0x00000002
#define PLATFORM_NT4                0x00000004
#define PLATFORM_NT5                0x00000008
#define PLATFORM_NT4ALPHA           0x00000010
#define PLATFORM_NT5ALPHA           0x00000020
#define PLATFORM_MILLEN		    0x00000040
#define PLATFORM_ALL     PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN
               

// The action to be taken on this component ((Get)SetInstallQueueStatus, SetAction
enum ComponentAction { ActionNone, ActionInstall, ActionUninstall };

// Type for commands
                     //   0            1           2           3             4
enum CommandType     { InfCommand, WExtractExe, Win32Exe, InfExCommand, HRESULTWin32Exe };



#undef INTERFACE
#define INTERFACE ICifComponent

DECLARE_INTERFACE(ICifComponent)
{
   // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize)PURE;
   STDMETHOD(GetGUID)(THIS_ LPSTR pszGUID, DWORD dwSize)PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize)PURE;
   STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize) PURE;
   STDMETHOD(GetUrl)(THIS_ UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)  PURE;
   STDMETHOD(GetFileExtractList)(THIS_ UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)  PURE;
   STDMETHOD(GetUrlCheckRange)(THIS_ UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)  PURE;
   STDMETHOD(GetCommand)(THIS_ UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
                         DWORD dwSwitchSize, LPDWORD pdwType)  PURE;
   STDMETHOD(GetVersion)(THIS_ LPDWORD pdwVersion, LPDWORD pdwBuild)  PURE;
   STDMETHOD(GetLocale)(THIS_ LPSTR pszLocale, DWORD dwSize)  PURE;
   STDMETHOD(GetUninstallKey)(THIS_ LPSTR pszKey, DWORD dwSize)  PURE;
   STDMETHOD(GetInstalledSize)(THIS_ LPDWORD pdwWin, LPDWORD pdwApp)  PURE;
   STDMETHOD_(DWORD, GetDownloadSize)(THIS)  PURE;
   STDMETHOD_(DWORD, GetExtractSize)(THIS)  PURE;
   STDMETHOD(GetSuccessKey)(THIS_ LPSTR pszKey, DWORD dwSize)  PURE;
   STDMETHOD(GetProgressKeys)(THIS_ LPSTR pszProgress, DWORD dwProgSize, 
                              LPSTR pszCancel, DWORD dwCancelSize)  PURE;
   STDMETHOD(IsActiveSetupAware)(THIS)  PURE;
   STDMETHOD(IsRebootRequired)(THIS)  PURE;
   STDMETHOD(RequiresAdminRights)(THIS) PURE;
   STDMETHOD_(DWORD, GetPriority)(THIS)  PURE;
   STDMETHOD(GetDependency)(THIS_ UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)  PURE;
   STDMETHOD_(DWORD, GetPlatform)(THIS)  PURE;
   STDMETHOD(GetMode)(THIS_ UINT uModeNum, LPSTR pszMode, DWORD dwSize)  PURE;
   STDMETHOD(GetGroup)(THIS_ LPSTR pszID, DWORD dwSize)  PURE;
   STDMETHOD(IsUIVisible)(THIS)  PURE;
   STDMETHOD(GetPatchID)(THIS_ LPSTR pszID, DWORD dwSize)  PURE;
   STDMETHOD(GetDetVersion)(THIS_ LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize) PURE;
   STDMETHOD(GetTreatAsOneComponents)(THIS_ UINT uNum, LPSTR pszID, DWORD dwBuf) PURE;
   STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize) PURE;

   // access to state
   STDMETHOD_(DWORD, IsComponentInstalled)(THIS)  PURE;
   STDMETHOD(IsComponentDownloaded)(THIS)  PURE;
   STDMETHOD_(DWORD, IsThisVersionInstalled)(THIS_ DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild) PURE;
   STDMETHOD_(DWORD, GetInstallQueueState)(THIS)  PURE;
   STDMETHOD(SetInstallQueueState)(THIS_ DWORD dwState)  PURE;
   STDMETHOD_(DWORD, GetActualDownloadSize)(THIS)  PURE;
   STDMETHOD_(DWORD, GetCurrentPriority)(THIS) PURE;
   STDMETHOD(SetCurrentPriority)(THIS_ DWORD dwPriority) PURE;
};

DECLARE_INTERFACE_(ICifRWComponent, ICifComponent)
{
   STDMETHOD(SetGUID)(THIS_ LPCSTR pszGUID)PURE;
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc)PURE;
   STDMETHOD(SetUrl)(THIS_ UINT uUrlNum, LPCSTR pszUrl, DWORD dwUrlFlags)  PURE;
   STDMETHOD(SetCommand)(THIS_ UINT uCmdNum, LPCSTR pszCmd, LPCSTR pszSwitches, DWORD dwType)  PURE;
   STDMETHOD(SetVersion)(THIS_ LPCSTR pszVersion)  PURE;
   STDMETHOD(SetUninstallKey)(THIS_ LPCSTR pszKey)  PURE;
   STDMETHOD(SetInstalledSize)(THIS_ DWORD dwWin, DWORD dwApp)  PURE;
   STDMETHOD(SetDownloadSize)(THIS_ DWORD)  PURE;
   STDMETHOD(SetExtractSize)(THIS_ DWORD)  PURE;
   STDMETHOD(DeleteDependency)(THIS_ LPCSTR pszID, char chType)  PURE;
   STDMETHOD(AddDependency)(THIS_ LPCSTR pszID, char chType)  PURE;
   STDMETHOD(SetUIVisible)(THIS_ BOOL)  PURE;
   STDMETHOD(SetGroup)(THIS_ LPCSTR pszID)  PURE;
   STDMETHOD(SetPlatform)(THIS_ DWORD)  PURE;
   STDMETHOD(SetPriority)(THIS_ DWORD)  PURE;
   STDMETHOD(SetReboot)(THIS_ BOOL)  PURE;
   
   STDMETHOD(DeleteFromModes)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(AddToMode)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(SetModes)(THIS_ LPCSTR pszMode)  PURE;
   STDMETHOD(CopyComponent)(THIS_ LPCSTR pszCifFile)  PURE;
   STDMETHOD(AddToTreatAsOne)(THIS_ LPCSTR pszCompID)  PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDesc) PURE;
};

DECLARE_INTERFACE_(IEnumCifComponents, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifComponent **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DECLARE_INTERFACE(ICifGroup)
{
  // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize) PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
  
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD_(DWORD, GetCurrentPriority)(THIS) PURE;

};

DECLARE_INTERFACE_(ICifRWGroup, ICifGroup)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;
   STDMETHOD(SetPriority)(THIS_ DWORD) PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails) PURE;
};

DECLARE_INTERFACE_(IEnumCifGroups, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifGroup **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DECLARE_INTERFACE(ICifMode)
{
  // for properties
   STDMETHOD(GetID)(THIS_ LPSTR pszID, DWORD dwSize) PURE;
   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD(GetDetails)(THIS_ LPSTR pszDetails, DWORD dwSize) PURE;
  
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
};

DECLARE_INTERFACE_(ICifRWMode, ICifMode)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;
   STDMETHOD(SetDetails)(THIS_ LPCSTR pszDetails) PURE;
};

DECLARE_INTERFACE_(IEnumCifModes, IUnknown)
{
  // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
   
  // enum methods
   STDMETHOD(Next)(THIS_ ICifMode **) PURE;
   STDMETHOD(Reset)(THIS) PURE;
};

DEFINE_GUID(IID_ICifFile,0x6E449688L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

DECLARE_INTERFACE_(ICifFile, IUnknown)
{
 // *** IUnknown methods ***
   STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;
 
   STDMETHOD(EnumComponents)(THIS_ IEnumCifComponents **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindComponent)(THIS_ LPCSTR pszID, ICifComponent **p) PURE;

   STDMETHOD(EnumGroups)(THIS_ IEnumCifGroups **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindGroup)(THIS_ LPCSTR pszID, ICifGroup **p) PURE;

   STDMETHOD(EnumModes)(THIS_ IEnumCifModes **, DWORD dwFilter, LPVOID pv) PURE;
   STDMETHOD(FindMode)(THIS_ LPCSTR pszID, ICifMode **p) PURE;

   STDMETHOD(GetDescription)(THIS_ LPSTR pszDesc, DWORD dwSize) PURE;
   STDMETHOD(GetDetDlls)(THIS_ LPSTR pszDlls, DWORD dwSize) PURE;

};

DECLARE_INTERFACE_(ICifRWFile, ICifFile)
{
   STDMETHOD(SetDescription)(THIS_ LPCSTR pszDesc) PURE;    
   STDMETHOD(CreateComponent)(THIS_ LPCSTR pszID, ICifRWComponent **p) PURE;
   STDMETHOD(CreateGroup)(THIS_ LPCSTR pszID, ICifRWGroup **p) PURE;
   STDMETHOD(CreateMode)(THIS_ LPCSTR pszID, ICifRWMode **p) PURE;
   STDMETHOD(DeleteComponent)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(DeleteGroup)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(DeleteMode)(THIS_ LPCSTR pszID) PURE;
   STDMETHOD(Flush)(THIS) PURE;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Detection DLL 

// Returns from DetectVersion
#define DET_NOTINSTALLED          0
#define DET_INSTALLED             1
#define DET_NEWVERSIONINSTALLED   2
#define DET_OLDVERSIONINSTALLED   3


   
// Function prototype
typedef struct
{
   DWORD          dwSize;
   LPDWORD        pdwInstalledVer;
   LPDWORD        pdwInstalledBuild;
   LPSTR          pszGUID;
   LPSTR          pszLocale;
   DWORD          dwAskVer;
   DWORD          dwAskBuild;
   ICifFile      *pCifFile; 
   ICifComponent *pCifComp; 
} DETECTION_STRUCT;


typedef DWORD (WINAPI *DETECTVERSION)(DETECTION_STRUCT *pDetectionStruct);

///////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_GUID(IID_IInstallEngine2,0x6E449689L,0xC509,0x11CF,0xAA,0xFA,0x00,0xAA,0x00,0xB6,0x01,0x5C);

#undef INTERFACE
#define INTERFACE IInstallEngine2

DECLARE_INTERFACE_(IInstallEngine2 , IInstallEngine)
{
   STDMETHOD(SetLocalCif)(THIS_ LPCSTR pszCif) PURE;
   STDMETHOD(GetICifFile)(THIS_ ICifFile **picif) PURE;
};

HRESULT WINAPI GetICifFileFromFile(ICifFile **, LPCSTR pszFile);

HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **, LPCSTR pszFile);

#ifdef __cplusplus
}
#endif

#define _INSENG_H_
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\lendian.hpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       lendian.hpp
//
//  Contents:   Templatized data types for access to unaligned scalar values.
//
//----------------------------------------------------------------------------

// Implementation of LENDIAN data values.  This works for simple scalar values.
// This file is heavily macro-based.  The intent is to do this work with arithmetic.
// The functionality may be expressed much more consisely with memcpy, but I need an
// implementation faster than that.

// To create an LENDIAN type, use the MAKE_LENDIAN_TYPE macro.  For example, if
// you need an int_LENDIAN, say
//
//        MAKE_LENDIAN_TYPE( int, 4 );
//
// Note that you need to specifiy the size of the base type.  This is because the
// amount of work to be done needs to be known by the preprocessor, where sizeof()
// doesn't work.

// To use: The intent is that replace occurances of "type LENDIAN" in your code
// with "type_LENDIAN".  It's simply a lexical change.  You could automate this
// change in order to easily convert code.  More importantly, the reverse
// transformation may also be easily automated, making it easier to merge with code
// that doesn't use these types.

// LENDIAN64: The unaligned 64 types are an optimization.  They should only be used
// for values over four bytes in size (e.g. __int64, double).  They assume that the
// pointers are aligned to 4-bytes, so that access may be done with two 32-bit
// references, instead of 8 8-bit references.

#ifndef __lendian_h__
#define __lendian_h__

#if defined(_MSC_VER) && !defined(BIG_ENDIAN)

#define MAKE_LENDIAN_UNALIGNED_TYPE(base,size)    typedef base UNALIGNED   base##_LENDIAN_UNALIGNED
#define MAKE_LENDIAN_TYPE(base,size)              typedef base             base##_LENDIAN_UNALIGNED; \
                                                  typedef base   base##_LENDIAN \

//
// Use MAKE_UNALIGNED64_TYPE for QWORD data that may only be DWORD aligned on 64-bit 
// machines.  Only 64-bit architectures pay the penalty for accessing such data.
//   
#if defined(ALPHA)
#  define MAKE_LENDIAN64_UNALIGNED_TYPE(base,size)  typedef base UNALIGNED base##_LENDIAN64_UNALIGNED
#else
#  define MAKE_LENDIAN64_UNALIGNED_TYPE(base,size)  typedef base base##_LENDIAN64_UNALIGNED
#endif
#define MAKE_LENDIAN64_TYPE(base,size)  typedef base base##_LENDIAN64

#define MAKE_LENDIANPTR_UNALIGNED_TYPE(base)      typedef base UNALIGNED *base##_LENDIANPTR_UNALIGNED
#define MAKE_LENDIANPTR_TYPE(base)                typedef base *base##_LENDIANPTR

#else // _MSC_VER

#define SET2(val,data)                          \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET2(data)                          \
    ( ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET4(val,data)                          \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET4(data)                              \
    ( ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET8(val,data)                          \
    data[7] = (val) >> 56,                      \
    data[6] = (val) >> 48,                      \
    data[5] = (val) >> 40,                      \
    data[4] = (val) >> 32,                      \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET8(data)                              \
    ( ( data[7] << 56 ) |                       \
      ( data[6] << 48 ) |                       \
      ( data[5] << 40 ) |                       \
      ( data[4] << 32 ) |                       \
      ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#if defined( ux10 )
#define SET02(x,y)  SET2(x,y)
#define GET02(x)    GET2(x)
#define SET04(x,y)  SET4(x,y)
#define GET04(x)    GET4(x)
#define SET08(x,y)  SET8(x,y)
#define GET08(x)    GET8(x)
#endif

#define SET648(val,data)                        \
    data[1] = (val) >> 32,                      \
    data[0] = (val)

#define GET648(data)                            \
    ( ( data[1] << 32 ) |                       \
      ( data[0] ) )

#define GROUP(type,size,get,set,sfx)                                                            \
    LEndian##sfx##size( type v ) { set##size( v, data ); }                                      \
    type operator = ( type v )   { set##size( v, data ); return v; }                            \
    operator type()              { return get##size( data ); }                                  \
    type operator += (const type v) { set##size( get##size(data) + v, data); return *this; }    \
    type operator -= (const type v) { set##size( get##size(data) - v, data); return *this; }    \
    type operator <<= (const type v) { set##size( get##size(data) << v, data); return *this; }  \
    type operator <= (const type v) { set##size( get##size(data) < v, data); return *this; }    \
    type operator >= (const type v) { set##size( get##size(data) > v, data); return *this; }    \
    type operator *= (const type v) { set##size( get##size(data) * v, data); return *this; }    \
    type operator /= (const type v) { set##size( get##size(data) / v, data); return *this; }    \
    type operator %= (const type v) { set##size( get##size(data) % v, data); return *this; }    \
    type operator >>= (const type v) { set##size( get##size(data) >> v, data); return *this; }  \
    type operator ^= (const type v) { set##size( get##size(data) ^ v, data); return *this; }    \
    type operator &= (const type v) { set##size( get##size(data) & v, data); return *this; }    \
    type operator |= (const type v) { set##size( get##size(data) | v, data); return *this; }


#define MAKE_TEMPLATE(size,type,sfx)                            \
template<class BASE>                                            \
class LEndian##sfx##size                                        \
{                                                               \
  protected:                                                    \
    type data[ size / sizeof(type) ];                           \
                                                                \
  public:                                                       \
                                                                \
    GROUP( signed char,      size, GET##sfx, SET##sfx, sfx )    \
    GROUP( short,            size, GET##sfx, SET##sfx, sfx )    \
    GROUP( int,              size, GET##sfx, SET##sfx, sfx )    \
    GROUP( wchar_t,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( long,             size, GET##sfx, SET##sfx, sfx )    \
    GROUP( __int64,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned char,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned short,   size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned int,     size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned long,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned __int64, size, GET##sfx, SET##sfx, sfx )    \
}


#if defined( ux10 )
MAKE_TEMPLATE( 2, unsigned char, 0);
MAKE_TEMPLATE( 4, unsigned char, 0);
MAKE_TEMPLATE( 8, unsigned char, 0);
#else
MAKE_TEMPLATE( 2, unsigned char, );
MAKE_TEMPLATE( 4, unsigned char, );
MAKE_TEMPLATE( 8, unsigned char, );
#endif
MAKE_TEMPLATE( 8, unsigned int, 64 );

#if defined( ux10 )
template<class BASE>
class LEndianPtr : LEndian04<BASE> {
public:
	LEndianPtr(const void * v) : LEndian04<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#else

template<class BASE>
class LEndianPtr : LEndian4<BASE> {
public:
	LEndianPtr(const void * v) : LEndian4<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#endif


#undef SET2
#undef SET4
#undef SET8
#undef SET648
#undef GROUP
#undef MAKE_TEMPLATE

#if defined( ux10 )
#define MAKE_LENDIAN_TYPE(base,size)            \
   typedef LEndian0##size<base>   base##_LENDIAN; \
   typedef LEndian0##size<base>   base##_LENDIAN_UNALIGNED
#else
#define MAKE_LENDIAN_TYPE(base,size)            \
   typedef LEndian##size<base>   base##_LENDIAN; \
   typedef LEndian##size<base>   base##_LENDIAN_UNALIGNED
#endif

#define MAKE_LENDIAN64_TYPE(base,size)                          \
  typedef LEndian64##size<base> base##_LENDIAN64;                \
  typedef LEndian64##size<base> base##_LENDIAN64_UNALIGNED

#define MAKE_LENDIANPTR_TYPE(base)                              \
  typedef LEndianPtr<base>      base##_LENDIANPTR;               \
  typedef LEndianPtr<base>      base##_LENDIANPTR_UNALIGNED

#endif  // _MSC_VER

// Predefine some of the basic types.

MAKE_LENDIAN_TYPE( short, 2 );
MAKE_LENDIAN_TYPE( int, 4 );
MAKE_LENDIAN_TYPE( long, 4 );
MAKE_LENDIAN_TYPE( WORD, 2 );
MAKE_LENDIAN_TYPE( DWORD, 4 );
MAKE_LENDIAN_TYPE( USHORT, 4 );
MAKE_LENDIAN_TYPE( SHORT, 4 );
MAKE_LENDIAN_TYPE( __int64, 8 );
MAKE_LENDIAN64_TYPE( __int64, 8 );

#endif // __lendian_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\httprequestid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows HTTP Services (WinHTTP)
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


#ifndef __HTTPREQUESTID_H__
#define __HTTPREQUESTID_H__

#define DISPID_HTTPREQUEST_BASE                     0x00000001


#define DISPID_HTTPREQUEST_OPEN                     (DISPID_HTTPREQUEST_BASE)
#define DISPID_HTTPREQUEST_SETREQUESTHEADER         (DISPID_HTTPREQUEST_BASE + 1)
#define DISPID_HTTPREQUEST_GETRESPONSEHEADER        (DISPID_HTTPREQUEST_BASE + 2)
#define DISPID_HTTPREQUEST_GETALLRESPONSEHEADERS    (DISPID_HTTPREQUEST_BASE + 3)
#define DISPID_HTTPREQUEST_SEND                     (DISPID_HTTPREQUEST_BASE + 4)
#define DISPID_HTTPREQUEST_OPTION                   (DISPID_HTTPREQUEST_BASE + 5)
#define DISPID_HTTPREQUEST_STATUS                   (DISPID_HTTPREQUEST_BASE + 6)
#define DISPID_HTTPREQUEST_STATUSTEXT               (DISPID_HTTPREQUEST_BASE + 7)
#define DISPID_HTTPREQUEST_RESPONSETEXT             (DISPID_HTTPREQUEST_BASE + 8)
#define DISPID_HTTPREQUEST_RESPONSEBODY             (DISPID_HTTPREQUEST_BASE + 9)
#define DISPID_HTTPREQUEST_RESPONSESTREAM           (DISPID_HTTPREQUEST_BASE + 10)
#define DISPID_HTTPREQUEST_ABORT                    (DISPID_HTTPREQUEST_BASE + 11)
#define DISPID_HTTPREQUEST_SETPROXY                 (DISPID_HTTPREQUEST_BASE + 12)
#define DISPID_HTTPREQUEST_SETCREDENTIALS           (DISPID_HTTPREQUEST_BASE + 13)
#define DISPID_HTTPREQUEST_WAITFORRESPONSE          (DISPID_HTTPREQUEST_BASE + 14)
#define DISPID_HTTPREQUEST_SETTIMEOUTS              (DISPID_HTTPREQUEST_BASE + 15)
#define DISPID_HTTPREQUEST_SETCLIENTCERTIFICATE     (DISPID_HTTPREQUEST_BASE + 16)
#define DISPID_HTTPREQUEST_SETAUTOLOGONPOLICY       (DISPID_HTTPREQUEST_BASE + 17)

#endif // __HTTPREQUESTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\mshtmlp.c ===
#define HDC_UserSize HWND_UserSize
#define HDC_UserMarshal HWND_UserMarshal
#define HDC_UserUnmarshal HWND_UserUnmarshal
#define HDC_UserFree HWND_UserFree
 
#pragma warning(disable:4028)
#include "mshtml_p.c"
#pragma warning(default:4028)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\marqinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Thu Mar 28 23:04:03 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __marqinfo_h__
#define __marqinfo_h__

#ifdef __cplusplus
extern "C"{
#endif

extern const DECLSPEC_SELECTANY IID IID_IMarqueeInfo = {0x0bdc6ae0,0x6d11,0x11cf,{0xbe,0x62,0x00,0x80,0xc7,0x2e,0xdd,0x2d}};
/* Forward Declarations */

#ifndef __IMarqueeInfo_FWD_DEFINED__
#define __IMarqueeInfo_FWD_DEFINED__
typedef interface IMarqueeInfo IMarqueeInfo;
#endif 	/* __IMarqueeInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Mar 28 23:04:03 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */


			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMarqueeInfo_INTERFACE_DEFINED__
#define __IMarqueeInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMarqueeInfo
 * at Thu Mar 28 23:04:03 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */


#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IMarqueeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetDocCoords(
            /* [out] */ LPRECT prcView,
            /* [in] */ BOOL bGetOnlyIfFullyLoaded,
            /* [out] */ BOOL __RPC_FAR *pfFullyLoaded,
            /* [in] */ int WidthToFormatPageTo) = 0;

    };

#else 	/* C style interface */

    typedef struct IMarqueeInfoVtbl
    {

        HRESULT ( __stdcall __RPC_FAR *QueryInterface )(
            IMarqueeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( __stdcall __RPC_FAR *AddRef )(
            IMarqueeInfo __RPC_FAR * This);

        ULONG ( __stdcall __RPC_FAR *Release )(
            IMarqueeInfo __RPC_FAR * This);

        HRESULT ( __stdcall __RPC_FAR *GetDocCoords )(
            IMarqueeInfo __RPC_FAR * This,
            /* [out] */ LPRECT prcView,
            /* [in] */ BOOL bGetOnlyIfFullyLoaded,
            /* [out] */ BOOL __RPC_FAR *pfFullyLoaded,
            /* [in] */ int WidthToFormatPageTo);

    } IMarqueeInfoVtbl;

    interface IMarqueeInfo
    {
        CONST_VTBL struct IMarqueeInfoVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMarqueeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarqueeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarqueeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarqueeInfo_GetDocCoords(This,prcView,bGetOnlyIfFullyLoaded,pfFullyLoaded,WidthToFormatPageTo)	\
    (This)->lpVtbl -> GetDocCoords(This,prcView,bGetOnlyIfFullyLoaded,pfFullyLoaded,WidthToFormatPageTo)

#endif /* COBJMACROS */


#endif 	/* C style interface */

#endif 	/* __IMarqueeInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\makefile.inc ===
#
#
#  R E A D   T H I S
#
#  See the inference rules below (the section marked "Inference rules") to
#  see if any of them cover the rule that you want performed for your file.
#  The inference rules should cover most of the cases.  If they don't, try
#  to add a new inference rule rather than adding a special-case rule for
#  your file.
#

#
# Special rules for splitting out .w files
#

# wininet.h and wininetp.h

$(O)\wininet.x $(O)\wininetp.x: wininet.w
    hsplit -e -o $(O)\wininet.x $(O)\wininetp.x $?

$(O)\wininet.h: $(O)\wininet.x
    wcshdr < $? > $@

$(O)\wininetp.h: $(O)\wininetp.x
    wcshdr < $? > $@


$(O)\winhttp.h $(O)\winhttpi.h: winhttp.w
    hsplit -o $(O)\winhttp.h $(O)\winhttpi.h $?


#
# Non-obvious Dependencies
#


#
# Inference rules.  These help build whatever is in the NTTARGETFILES and
# NTTARGETFILE0 lists.  Most of these simply copy files.
#

.SUFFIXES:.h .w .hpp .tlb .dlg .c .cpp


{}.w{$O}.h:
    hsplit -e -o $(O)\$(?R).x $(O)\$(?R)p.x $?
    wcshdr < $(O)\$(?R).x > $*.h

{}.w{}.h:
    hsplit -e -o $(O)\$(?R).x $(O)\$(?R)p.x $?
    wcshdr < $(O)\$(?R).x > $(O)\$*.h

#
#   mshtml.h has special funkiness:
#
#       mshtml.idl -> obj\mshtml.h -[copy]-> sdk\inc\mshtmlc.h
#                     obj\mshtml.h -[sed]--> sdk\inc\mshtml.h
#
#   obj\mshtml.h is generated by MIDL and contains both C and C++ support.
#   splthdr.sed removes the C support; the result goes to sdk\inc\mshtml.h.
#   The C version goes to sdk\inc\mshtmlc.h.

$(O)\mshtmlcpp.h: $(O)\mshtml.h
    type << > $@
#if !defined(__cplusplus) || defined(CINTERFACE)
// Include the full header file that works for C
#include "mshtmlc.h"
#else
<<
    perl splthdr.pl < $? >> $@
    type << >> $@
#endif /* !defined(__cplusplus) || defined(CINTERFACE) */
<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\mshtmcid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

#ifndef __mshtmcid_h__
#define __mshtmcid_h__

//----------------------------------------------------------------------------
//
// MSHTML Command IDs
//
//----------------------------------------------------------------------------

#define IDM_UNKNOWN                 0
#define IDM_ALIGNBOTTOM             1
#define IDM_ALIGNHORIZONTALCENTERS  2
#define IDM_ALIGNLEFT               3
#define IDM_ALIGNRIGHT              4
#define IDM_ALIGNTOGRID             5
#define IDM_ALIGNTOP                6
#define IDM_ALIGNVERTICALCENTERS    7
#define IDM_ARRANGEBOTTOM           8
#define IDM_ARRANGERIGHT            9
#define IDM_BRINGFORWARD            10
#define IDM_BRINGTOFRONT            11
#define IDM_CENTERHORIZONTALLY      12
#define IDM_CENTERVERTICALLY        13
#define IDM_CODE                    14
#define IDM_DELETE                  17
#define IDM_FONTNAME                18
#define IDM_FONTSIZE                19
#define IDM_GROUP                   20
#define IDM_HORIZSPACECONCATENATE   21
#define IDM_HORIZSPACEDECREASE      22
#define IDM_HORIZSPACEINCREASE      23
#define IDM_HORIZSPACEMAKEEQUAL     24
#define IDM_INSERTOBJECT            25
#define IDM_MULTILEVELREDO          30
#define IDM_SENDBACKWARD            32
#define IDM_SENDTOBACK              33
#define IDM_SHOWTABLE               34
#define IDM_SIZETOCONTROL           35
#define IDM_SIZETOCONTROLHEIGHT     36
#define IDM_SIZETOCONTROLWIDTH      37
#define IDM_SIZETOFIT               38
#define IDM_SIZETOGRID              39
#define IDM_SNAPTOGRID              40
#define IDM_TABORDER                41
#define IDM_TOOLBOX                 42
#define IDM_MULTILEVELUNDO          44
#define IDM_UNGROUP                 45
#define IDM_VERTSPACECONCATENATE    46
#define IDM_VERTSPACEDECREASE       47
#define IDM_VERTSPACEINCREASE       48
#define IDM_VERTSPACEMAKEEQUAL      49
#define IDM_JUSTIFYFULL             50
#define IDM_BACKCOLOR               51
#define IDM_BOLD                    52
#define IDM_BORDERCOLOR             53
#define IDM_FLAT                    54
#define IDM_FORECOLOR               55
#define IDM_ITALIC                  56
#define IDM_JUSTIFYCENTER           57
#define IDM_JUSTIFYGENERAL          58
#define IDM_JUSTIFYLEFT             59
#define IDM_JUSTIFYRIGHT            60
#define IDM_RAISED                  61
#define IDM_SUNKEN                  62
#define IDM_UNDERLINE               63
#define IDM_CHISELED                64
#define IDM_ETCHED                  65
#define IDM_SHADOWED                66
#define IDM_FIND                    67
#define IDM_SHOWGRID                69
#define IDM_OBJECTVERBLIST0         72
#define IDM_OBJECTVERBLIST1         73
#define IDM_OBJECTVERBLIST2         74
#define IDM_OBJECTVERBLIST3         75
#define IDM_OBJECTVERBLIST4         76
#define IDM_OBJECTVERBLIST5         77
#define IDM_OBJECTVERBLIST6         78
#define IDM_OBJECTVERBLIST7         79
#define IDM_OBJECTVERBLIST8         80
#define IDM_OBJECTVERBLIST9         81
#define IDM_OBJECTVERBLISTLAST IDM_OBJECTVERBLIST9
#define IDM_CONVERTOBJECT           82
#define IDM_CUSTOMCONTROL           83
#define IDM_CUSTOMIZEITEM           84
#define IDM_RENAME                  85
#define IDM_IMPORT                  86
#define IDM_NEWPAGE                 87
#define IDM_MOVE                    88
#define IDM_CANCEL                  89
#define IDM_FONT                    90
#define IDM_STRIKETHROUGH           91
#define IDM_DELETEWORD              92
#define IDM_EXECPRINT               93
#define IDM_JUSTIFYNONE             94
#define IDM_TRISTATEBOLD            95
#define IDM_TRISTATEITALIC          96
#define IDM_TRISTATEUNDERLINE       97

#define IDM_FOLLOW_ANCHOR           2008

#define IDM_INSINPUTIMAGE           2114
#define IDM_INSINPUTBUTTON          2115
#define IDM_INSINPUTRESET           2116
#define IDM_INSINPUTSUBMIT          2117
#define IDM_INSINPUTUPLOAD          2118
#define IDM_INSFIELDSET             2119

#define IDM_PASTEINSERT             2120
#define IDM_REPLACE                 2121
#define IDM_EDITSOURCE              2122
#define IDM_BOOKMARK                2123
#define IDM_HYPERLINK               2124
#define IDM_UNLINK                  2125
#define IDM_BROWSEMODE              2126
#define IDM_EDITMODE                2127
#define IDM_UNBOOKMARK              2128

#define IDM_TOOLBARS                2130
#define IDM_STATUSBAR               2131
#define IDM_FORMATMARK              2132
#define IDM_TEXTONLY                2133
#define IDM_OPTIONS                 2135
#define IDM_FOLLOWLINKC             2136
#define IDM_FOLLOWLINKN             2137
#define IDM_VIEWSOURCE              2139
#define IDM_ZOOMPOPUP               2140

// IDM_BASELINEFONT1, IDM_BASELINEFONT2, IDM_BASELINEFONT3, IDM_BASELINEFONT4,
// and IDM_BASELINEFONT5 should be consecutive integers;
//
#define IDM_BASELINEFONT1           2141
#define IDM_BASELINEFONT2           2142
#define IDM_BASELINEFONT3           2143
#define IDM_BASELINEFONT4           2144
#define IDM_BASELINEFONT5           2145

#define IDM_HORIZONTALLINE          2150
#define IDM_LINEBREAKNORMAL         2151
#define IDM_LINEBREAKLEFT           2152
#define IDM_LINEBREAKRIGHT          2153
#define IDM_LINEBREAKBOTH           2154
#define IDM_NONBREAK                2155
#define IDM_SPECIALCHAR             2156
#define IDM_HTMLSOURCE              2157
#define IDM_IFRAME                  2158
#define IDM_HTMLCONTAIN             2159
#define IDM_TEXTBOX                 2161
#define IDM_TEXTAREA                2162
#define IDM_CHECKBOX                2163
#define IDM_RADIOBUTTON             2164
#define IDM_DROPDOWNBOX             2165
#define IDM_LISTBOX                 2166
#define IDM_BUTTON                  2167
#define IDM_IMAGE                   2168
#define IDM_OBJECT                  2169
#define IDM_1D                      2170
#define IDM_IMAGEMAP                2171
#define IDM_FILE                    2172
#define IDM_COMMENT                 2173
#define IDM_SCRIPT                  2174
#define IDM_JAVAAPPLET              2175
#define IDM_PLUGIN                  2176
#define IDM_PAGEBREAK               2177
#define IDM_HTMLAREA                2178

#define IDM_PARAGRAPH               2180
#define IDM_FORM                    2181
#define IDM_MARQUEE                 2182
#define IDM_LIST                    2183
#define IDM_ORDERLIST               2184
#define IDM_UNORDERLIST             2185
#define IDM_INDENT                  2186
#define IDM_OUTDENT                 2187
#define IDM_PREFORMATTED            2188
#define IDM_ADDRESS                 2189
#define IDM_BLINK                   2190
#define IDM_DIV                     2191

#define IDM_TABLEINSERT             2200
#define IDM_RCINSERT                2201
#define IDM_CELLINSERT              2202
#define IDM_CAPTIONINSERT           2203
#define IDM_CELLMERGE               2204
#define IDM_CELLSPLIT               2205
#define IDM_CELLSELECT              2206
#define IDM_ROWSELECT               2207
#define IDM_COLUMNSELECT            2208
#define IDM_TABLESELECT             2209
#define IDM_TABLEPROPERTIES         2210
#define IDM_CELLPROPERTIES          2211
#define IDM_ROWINSERT               2212
#define IDM_COLUMNINSERT            2213

#define IDM_HELP_CONTENT            2220
#define IDM_HELP_ABOUT              2221
#define IDM_HELP_README             2222

#define IDM_REMOVEFORMAT            2230
#define IDM_PAGEINFO                2231
#define IDM_TELETYPE                2232
#define IDM_GETBLOCKFMTS            2233
#define IDM_BLOCKFMT                2234
#define IDM_SHOWHIDE_CODE           2235
#define IDM_TABLE                   2236

#define IDM_COPYFORMAT              2237
#define IDM_PASTEFORMAT             2238
#define IDM_GOTO                    2239

#define IDM_CHANGEFONT              2240
#define IDM_CHANGEFONTSIZE          2241
#define IDM_CHANGECASE              2246
#define IDM_SHOWSPECIALCHAR         2249

#define IDM_SUBSCRIPT               2247
#define IDM_SUPERSCRIPT             2248

#define IDM_CENTERALIGNPARA         2250
#define IDM_LEFTALIGNPARA           2251
#define IDM_RIGHTALIGNPARA          2252
#define IDM_REMOVEPARAFORMAT        2253
#define IDM_APPLYNORMAL             2254
#define IDM_APPLYHEADING1           2255
#define IDM_APPLYHEADING2           2256
#define IDM_APPLYHEADING3           2257

#define IDM_DOCPROPERTIES           2260
#define IDM_ADDFAVORITES            2261
#define IDM_COPYSHORTCUT            2262
#define IDM_SAVEBACKGROUND          2263
#define IDM_SETWALLPAPER            2264
#define IDM_COPYBACKGROUND          2265
#define IDM_CREATESHORTCUT          2266
#define IDM_PAGE                    2267
#define IDM_SAVETARGET              2268
#define IDM_SHOWPICTURE             2269
#define IDM_SAVEPICTURE             2270
#define IDM_DYNSRCPLAY              2271
#define IDM_DYNSRCSTOP              2272
#define IDM_PRINTTARGET             2273
#define IDM_IMGARTPLAY              2274
#define IDM_IMGARTSTOP              2275
#define IDM_IMGARTREWIND            2276
#define IDM_PRINTQUERYJOBSPENDING   2277
#define IDM_SETDESKTOPITEM          2278

#define IDM_CONTEXTMENU             2280
#define IDM_GOBACKWARD              2282
#define IDM_GOFORWARD               2283
#define IDM_PRESTOP                 2284

#define IDM_MP_MYPICS               2287
#define IDM_MP_EMAILPICTURE         2288
#define IDM_MP_PRINTPICTURE         2289

#define IDM_CREATELINK              2290
#define IDM_COPYCONTENT             2291

#define IDM_LANGUAGE                2292
 
#define IDM_GETPRINTTEMPLATE        2295
#define IDM_SETPRINTTEMPLATE        2296
#define IDM_TEMPLATE_PAGESETUP      2298

#define IDM_REFRESH                 2300
#define IDM_STOPDOWNLOAD            2301

#define IDM_ENABLE_INTERACTION      2302

#define IDM_LAUNCHDEBUGGER          2310
#define IDM_BREAKATNEXT             2311

#define IDM_INSINPUTHIDDEN          2312
#define IDM_INSINPUTPASSWORD        2313

#define IDM_OVERWRITE               2314

#define IDM_PARSECOMPLETE           2315

#define IDM_HTMLEDITMODE            2316

#define IDM_REGISTRYREFRESH         2317
#define IDM_COMPOSESETTINGS         2318

#define IDM_SHOWALLTAGS             2327
#define IDM_SHOWALIGNEDSITETAGS     2321
#define IDM_SHOWSCRIPTTAGS          2322
#define IDM_SHOWSTYLETAGS           2323
#define IDM_SHOWCOMMENTTAGS         2324
#define IDM_SHOWAREATAGS            2325
#define IDM_SHOWUNKNOWNTAGS         2326
#define IDM_SHOWMISCTAGS            2320
#define IDM_SHOWZEROBORDERATDESIGNTIME         2328

#define IDM_AUTODETECT              2329

#define IDM_SCRIPTDEBUGGER          2330

#define IDM_GETBYTESDOWNLOADED      2331

#define IDM_NOACTIVATENORMALOLECONTROLS        2332
#define IDM_NOACTIVATEDESIGNTIMECONTROLS       2333
#define IDM_NOACTIVATEJAVAAPPLETS              2334
#define IDM_NOFIXUPURLSONPASTE                 2335

#define IDM_EMPTYGLYPHTABLE         2336
#define IDM_ADDTOGLYPHTABLE         2337
#define IDM_REMOVEFROMGLYPHTABLE    2338
#define IDM_REPLACEGLYPHCONTENTS    2339

#define IDM_SHOWWBRTAGS             2340

#define IDM_PERSISTSTREAMSYNC       2341
#define IDM_SETDIRTY                2342

#define IDM_RUNURLSCRIPT            2343

#ifdef IE5_ZOOM
#define IDM_ZOOMRATIO               2344
#define IDM_GETZOOMNUMERATOR        2345
#define IDM_GETZOOMDENOMINATOR      2346
#endif  // IE5_ZOOM

// COMMANDS FOR COMPLEX TEXT
#define IDM_DIRLTR                  2350
#define IDM_DIRRTL                  2351
#define IDM_BLOCKDIRLTR             2352
#define IDM_BLOCKDIRRTL             2353
#define IDM_INLINEDIRLTR            2354
#define IDM_INLINEDIRRTL            2355

// SHDOCVW
#define IDM_ISTRUSTEDDLG            2356

// MSHTMLED
#define IDM_INSERTSPAN              2357
#define IDM_LOCALIZEEDITOR          2358

// XML MIMEVIEWER
#define IDM_SAVEPRETRANSFORMSOURCE  2370
#define IDM_VIEWPRETRANSFORMSOURCE  2371

// Scrollbar context menu
#define IDM_SCROLL_HERE             2380
#define IDM_SCROLL_TOP              2381
#define IDM_SCROLL_BOTTOM           2382
#define IDM_SCROLL_PAGEUP           2383
#define IDM_SCROLL_PAGEDOWN         2384
#define IDM_SCROLL_UP               2385
#define IDM_SCROLL_DOWN             2386
#define IDM_SCROLL_LEFTEDGE         2387
#define IDM_SCROLL_RIGHTEDGE        2388
#define IDM_SCROLL_PAGELEFT         2389
#define IDM_SCROLL_PAGERIGHT        2390
#define IDM_SCROLL_LEFT             2391
#define IDM_SCROLL_RIGHT            2392

// IE 6 Form Editing Commands
#define IDM_MULTIPLESELECTION       2393
#define IDM_2D_POSITION             2394
#define IDM_2D_ELEMENT              2395
#define IDM_1D_ELEMENT              2396
#define IDM_ABSOLUTE_POSITION       2397
#define IDM_LIVERESIZE              2398
#define IDM_ATOMICSELECTION			2399

// Auto URL detection mode
#define IDM_AUTOURLDETECT_MODE      2400

// Legacy IE50 compatible paste
#define IDM_IE50_PASTE              2401

// ie50 paste mode
#define IDM_IE50_PASTE_MODE         2402

//;begin_internal
#define IDM_GETIPRINT               2403
//;end_internal

// for disabling selection handles
#define IDM_DISABLE_EDITFOCUS_UI    2404

// for visibility/display in design
#define IDM_RESPECTVISIBILITY_INDESIGN  2405

// set css mode
#define IDM_CSSEDITING_LEVEL            2406

// New outdent
#define IDM_UI_OUTDENT                  2407

// Printing Status
#define IDM_UPDATEPAGESTATUS            2408

// IME Reconversion 
#define IDM_IME_ENABLE_RECONVERSION		2409

#define	IDM_KEEPSELECTION				2410

#define IDM_UNLOADDOCUMENT              2411

#define IDM_OVERRIDE_CURSOR             2420

#define IDM_PEERHITTESTSAMEINEDIT       2423

#define IDM_TRUSTAPPCACHE               2425

#define IDM_BACKGROUNDIMAGECACHE        2430

#define IDM_DEFAULTBLOCK                6046

#define IDM_MIMECSET__FIRST__           3609
#define IDM_MIMECSET__LAST__            3699

#define IDM_MENUEXT_FIRST__       3700
#define IDM_MENUEXT_LAST__        3732
#define IDM_MENUEXT_COUNT         3733

// Commands mapped from the standard set.  We should
// consider deleting them from public header files.

#define IDM_OPEN                    2000
#define IDM_NEW                     2001
#define IDM_SAVE                    70
#define IDM_SAVEAS                  71
#define IDM_SAVECOPYAS              2002
#define IDM_PRINTPREVIEW            2003
#define IDM_SHOWPRINT               2010
#define IDM_SHOWPAGESETUP           2011
#define IDM_PRINT                   27
#define IDM_PAGESETUP               2004
#define IDM_SPELL                   2005
#define IDM_PASTESPECIAL            2006
#define IDM_CLEARSELECTION          2007
#define IDM_PROPERTIES              28
#define IDM_REDO                    29
#define IDM_UNDO                    43
#define IDM_SELECTALL               31
#define IDM_ZOOMPERCENT             50
#define IDM_GETZOOM                 68
#define IDM_STOP                    2138
#define IDM_COPY                    15
#define IDM_CUT                     16
#define IDM_PASTE                   26

// Defines for IDM_ZOOMPERCENT
#define CMD_ZOOM_PAGEWIDTH -1
#define CMD_ZOOM_ONEPAGE -2
#define CMD_ZOOM_TWOPAGES -3
#define CMD_ZOOM_SELECTION -4
#define CMD_ZOOM_FIT -5

// IDMs for CGID_EditStateCommands group 
#define IDM_CONTEXT                 1 
#define IDM_HWND                    2

// Shdocvw Execs on CGID_DocHostCommandHandler
#define IDM_NEW_TOPLEVELWINDOW      7050

//
// Undo persistence comands
//
#define IDM_PRESERVEUNDOALWAYS      6049
#define IDM_PERSISTDEFAULTVALUES    7100
#define IDM_PROTECTMETATAGS         7101

#define IDM_GETFRAMEZONE            6037

//;begin_internal
// <New in IE6>
#define IDM_FIRE_PRINTTEMPLATEUP        15000
#define IDM_FIRE_PRINTTEMPLATEDOWN      15001
#define IDM_SETPRINTHANDLES             15002
#define IDM_CLEARAUTHENTICATIONCACHE	15003
//;end_internal


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\mshtmlrc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident/MSHTML
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mshtmlrc.h
//
//  Contents:   Resource identifiers
//
//----------------------------------------------------------------------------


#ifndef I_MSHTMLRC_H_
#define I_MSHTMLRC_H_
#pragma INCMSG("--- Beg 'mshtmlrc.h'")


#define IDC_SELBAR                      2008    // Text select cursor for text site

#define IDC_NOSCROLLVH                  2025


#define IDC_HYPERLINK                   9801
#define IDC_HYPERLINK_OFFLINE           9802
#define IDC_HIBEAM                      9803
#define IDC_RESIZEROW2				    9804 
#define IDC_RESIZECOL2				    9805

#define IDR_DRAG_CONTEXT_MENU       24645  //0x6045  // bad id - not in core range

// HTML Form
#define IDR_HTMLFORM_MENUDESIGN     907
#define IDR_HTMLFORM_MENURUN        908
#define IDR_HTMLFORM_DOCDIR         909
#define IDS_HTMLFORM_USERTYPESHORT  181
#define IDS_HTMLFORM_USERTYPEFULL   180

// Form
#define IDR_ACCELS_SITE_DESIGN          41
#define IDR_ACCELS_SITE_RUN             40
#define IDR_ACCELS_FRAMESET_DESIGN      47
#define IDR_ACCELS_FRAMESET_RUN         46
#define IDR_ACCELS_INPUTTXT_DESIGN      43
#define IDR_ACCELS_INPUTTXT_RUN         42
#define IDR_ACCELS_TCELL_DESIGN         45
#define IDR_ACCELS_TCELL_RUN            44
#define IDR_ACCELS_BODY_RUN             48
#define IDR_ACCELS_BODY_DESIGN          49
#define IDR_ACCELS_TXTSITE_RUN          50
#define IDR_ACCELS_TXTSITE_DESIGN       51


//+------------------------------------------------------------------------
//
//  Error strings
//
//-------------------------------------------------------------------------
#define IDS_USERTYPEAPP                 2212    // Microsoft Forms 2.0
#define IDS_MESSAGE_BOX_TITLE           2213    // Microsoft Forms
#define IDS_ERROR_SOLUTION              2214    // Solution:\n<0s>
#define IDS_EA_SETTING_PROPERTY         2216    // Could not set property ...
#define IDS_EA_GETTING_PROPERTY         2217    // Could not get property ...
#define IDS_EA_CALLING_METHOD           2326    // Could not call method ...
#define IDS_EE_INVALID_PROPERTY_VALUE   2218    // The value entered is not valid ..
#define IDS_ES_ENTER_VALUE_IN_RANGE     2220    // Enter a value between..
#define IDS_ES_ENTER_VALUE_GT_ZERO      2221    // Enter a value greater than
#define IDS_ES_ENTER_VALUE_GE_ZERO      2222    // Enter a value greater than
#define IDS_EE_SETNOTSUPPORTEDATRUNTIME 2321    // Set property is not support at runtime.
#define IDS_EE_METHODNOTAPPLICABLE      2324
#define IDS_ES_ENTER_PROPER_VALUE       2325    // Enter a proper value
#define IDS_EE_INVALIDPICTURETYPE       2227    // CTL_E_INVALIDPICTURETYPE mouse icon must be a mouse icon
#define IDS_EE_CANTMOVEFOCUSTOCTRL      2322    // can't move focus to control because...
#define IDS_EE_INVALIDPICTURE           2331    // CTL_E_INVALIDPICTURE
#define IDS_EE_FAIL                     2330    // E_FAIL
#define IDS_EE_UNEXPECTED               2329    // E_UNEXPECTED
#define IDS_EE_INVALIDARG               2336    // E_INVALIDARG
#define IDS_EE_INVALIDPROPERTYARRAYINDEX 2332   // CTL_E_INVALIDPROPERTYARRAYINDEX
#define IDS_EE_INVALIDPROPERTYVALUE     2333    // CTL_E_INVALIDPROPERTYVALUE
#define IDS_EE_OVERFLOW                 2334    // CTL_E_OVERFLOW
#define IDS_EE_PERMISSIONDENIED         2335    // CTL_E_PERMISSIONDENIED
#define IDS_MSG_SAVE_MODIFIED_OBJECT    2223    // Save modified object?

#define IDS_CTRLPROPERTIES              2229
#define IDS_NAMEDCTRLPROPERTIES         2230
#define IDS_EA_PASTE_CONTROL            2235
#define IDS_EA_INSERT_CONTROL           2236

#define IDS_UNKNOWN_ERROR               2215    // Unknown error <0x>
#define IDS_EE_CONTROLNEEDSFOCUS        2327    // The control needs to have the focus
#define IDS_EE_NOTLICENSED              2337    // CLASS_E_NOTLICENSED
#define IDS_EE_INVALIDPASTETARGET       2338    // CTL_E_INVALIDPASTETARGET
#define IDS_EE_INVALIDPASTESOURCE       2339    // CTL_E_INVALIDPASTESOURCE

#define IDS_UNKNOWN                     2340

#define IDS_EE_INTERNET_INVALID_URL         2341
#define IDS_EE_INTERNET_NAME_NOT_RESOLVED   2342
#define IDS_EE_MISMATCHEDTAG                2345    // CTL_E_MISMATCHEDTAG
#define IDS_EE_INCOMPATIBLEPOINTERS         2346    // CTL_E_INCOMPATIBLEPOINTERS
#define IDS_EE_UNPOSITIONEDPOINTER          2347    // CTL_E_UNPOSITIONEDPOINTER
#define IDS_EE_UNPOSITIONEDELEMENT          2348    // CTL_E_UNPOSITIONEDELEMENT

#define IDS_EDITVERB                    2210
#define IDS_PROPVERB                    2211

//----------------------------------------------------------------------------
//
// Generic property page (52xx)
//
//----------------------------------------------------------------------------

#define IDS_PPG_GENERIC             5211
#define IDS_PPG_INLINE_STYLE        5212
#define IDC_PROPNAME                5204
#define IDE_PROPVALUE               5208

//----------------------------------------------------------------------------
//
// Misc strings
//
//----------------------------------------------------------------------------

//  The following IDS's must be kept in order, such that the
//    string for a given unit has the id IDS_UNITS_BASE + units
//    Otherwise, the StringToHimetric and HimetricToString functions
//    in himetric.cxx will break.  (chrisz)

#define IDS_UNITS_BASE                  2240
#define IDS_UNITS_INCH                  (IDS_UNITS_BASE+0)
#define IDS_UNITS_CM                    (IDS_UNITS_BASE+1)
#define IDS_UNITS_POINT                 (IDS_UNITS_BASE+2)


//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_UNDO                        (IDS_UNITS_POINT + 1)
#define IDS_REDO                        (IDS_UNDO + 1)
#define IDS_CANTUNDO                    (IDS_UNDO + 2)
#define IDS_CANTREDO                    (IDS_UNDO + 3)
#define IDS_UNDONEWCTRL                 (IDS_UNDO + 4)
#define IDS_UNDODELETE                  (IDS_UNDO + 5)
#define IDS_UNDOPROPCHANGE              (IDS_UNDO + 6)
#define IDS_UNDOMOVE                    (IDS_UNDO + 7)
#define IDS_UNDODRAGDROP                (IDS_UNDO + 9)
#define IDS_UNDOPASTE                   (IDS_UNDO + 15)
#define IDS_UNDOTYPING                  (IDS_UNDO + 16)
#define IDS_UNDOGENERICTEXT             (IDS_UNDO + 19)

#define IDS_E_CMDNOTSUPPORTED           2206


#define IDS_SITE_BASE      7999
#define IDS_HTMLDEFAULTFONT          (IDS_SITE_BASE + 19)
#define IDS_RUNAWAYSCRIPT            (IDS_SITE_BASE + 29)
#define IDS_PROTECTEDFROMUNSAFEOCX   (IDS_SITE_BASE + 31)
#define IDS_PROTECTEDFROMOCXINIT     (IDS_SITE_BASE + 32)
#define IDS_REPOSTFORMDATA           (IDS_SITE_BASE + 33)
#define IDS_OCXDISABLED              (IDS_SITE_BASE + 34)
#define IDS_MISMATCHEDXML            (IDS_SITE_BASE + 35)
#define IDS_DEBUGCONTINUE            (IDS_SITE_BASE + 36)
#define IDS_FMTDEBUGCONTINUE         (IDS_SITE_BASE + 37)

#define IDS_ERR_SAVEPICTUREAS        (IDS_SITE_BASE + 26)
#define IDS_ERR_SETWALLPAPER         (IDS_SITE_BASE + 27)
#define IDS_ERR_SETDESKTOPITEM       (IDS_SITE_BASE + 38)


//+----------------------------------------------------------------------------
//
// string used by script window
//
//----------------------------------------------------------------------------

#define IDS_OMWINDOW_FIRST             8300
#define IDS_VAR2STR_VTERROR             (IDS_OMWINDOW_FIRST + 0)
#define IDS_VAR2STR_VTNULL              (IDS_OMWINDOW_FIRST + 1)
#define IDS_VAR2STR_VTBOOL_TRUE         (IDS_OMWINDOW_FIRST + 2)
#define IDS_VAR2STR_VTBOOL_FALSE        (IDS_OMWINDOW_FIRST + 3)

//+----------------------------------------------------------------------------
//
// string used in conversion GetIDsOfNames
//
//----------------------------------------------------------------------------

#define IDS_DISPID_FIRST                8200                       // matches:
#define IDS_DISPID_FONTNAME             (IDS_DISPID_FIRST +  1)    // DISPID_CommonCtrl_FONTNAME
#define IDS_DISPID_FONTSIZE             (IDS_DISPID_FIRST +  2)    // DISPID_CommonCtrl_FONTSIZE
#define IDS_DISPID_FONTBOLD             (IDS_DISPID_FIRST +  3)    // DISPID_CommonCtrl_FONTBOLD
#define IDS_DISPID_FONTITAL             (IDS_DISPID_FIRST +  4)    // DISPID_CommonCtrl_FONTITAL
#define IDS_DISPID_FONTUNDER            (IDS_DISPID_FIRST +  5)    // DISPID_CommonCtrl_FONTUNDER
#define IDS_DISPID_BACKCOLOR            (IDS_DISPID_FIRST +  7)    // DISPID_BACKCOLOR
#define IDS_DISPID_BORDERCOLOR          (IDS_DISPID_FIRST +  9)    // DISPID_BORDERCOLOR
#define IDS_DISPID_BORDERSTYLE          (IDS_DISPID_FIRST + 10)    // DISPID_BORDERSTYLE
#define IDS_DISPID_TEXTALIGN            (IDS_DISPID_FIRST + 11)    // DISPID_CommonCtrl_TextAlign
#define IDS_DISPID_SPECIALEFFECT        (IDS_DISPID_FIRST + 12)    // DISPID_CommonCtrl_SpecialEffect
#define IDS_DISPID_FONTSUPERSCRIPT      (IDS_DISPID_FIRST + 13)    // DISPID_CommonCtrl_FONTSUPERSCRIPT
#define IDS_DISPID_FONTSUBSCRIPT        (IDS_DISPID_FIRST + 14)    // DISPID_CommonCtrl_FONTSUBSCRIPT

//+----------------------------------------------------------------------------
//
//  Button caption constants
//
//----------------------------------------------------------------------------

#define IDS_BUTTONCAPTION_RESET         8500
#define IDS_BUTTONCAPTION_SUBMIT        8501
#define IDS_BUTTONCAPTION_UPLOAD        8502

//+----------------------------------------------------------------------------
//
//  Printing constants
//
//----------------------------------------------------------------------------

#define IDS_PRINT_URLTITLE              8400
#define IDS_PRINT_URLCOL1HEAD           8401
#define IDS_PRINT_URLCOL2HEAD           8402
#define IDS_DEFAULTHEADER               8403
#define IDS_DEFAULTFOOTER               8404
#define IDS_DEFAULTMARGINTOP            8405
#define IDS_DEFAULTMARGINBOTTOM         8406
#define IDS_DEFAULTMARGINLEFT           8407
#define IDS_DEFAULTMARGINRIGHT          8408

//+----------------------------------------------------------------------------
//
// Progress status text strings
//
//-----------------------------------------------------------------------------

#define IDS_BINDSTATUS_DOWNLOADING                  8154
#define IDS_BINDSTATUS_DOWNLOADINGDATA_PICTURE      8155
#define IDS_BINDSTATUS_GENERATINGDATA_TEXT          8156
#define IDS_BINDSTATUS_DOWNLOADINGDATA_TEXT         8157
#define IDS_BINDSTATUS_INSTALLINGCOMPONENTS         8160
#define IDS_BINDSTATUS_DOWNLOADINGDATA_BITS         8167

#define IDS_DONE                                    8169

#define IDS_LOADINGTABLE                            8170
#define IDS_DATABINDING                             8171

#define IDS_FRIENDLYURL_SHORTCUTTO                  8172
#define IDS_FRIENDLYURL_AT                          8173
#define IDS_FRIENDLYURL_SENDSMAILTO                 8174
#define IDS_FRIENDLYURL_LOCAL                       8175
#define IDS_FRIENDLYURL_GOPHER                      8176
#define IDS_FRIENDLYURL_FTP                         8177
#define IDS_FRIENDLYURL_SECUREWEBSITE               8178

#define IDS_CANNOTLOAD                              8193
#define IDS_ONBEFOREUNLOAD_PREAMBLE                 8194
#define IDS_ONBEFOREUNLOAD_POSTAMBLE                8197

#define IDS_DEFAULT_ISINDEX_PROMPT                  8196


#define IDS_UNKNOWNPROTOCOL             2511    
#define IDS_SECURECONNECTIONINFO        2512
#define IDS_SECURE_LOW                  2513
#define IDS_SECURE_MEDIUM               2514
#define IDS_SECURE_HIGH                 2515
#define IDS_SECURESOURCE                2516

// Jave Script prompt() dialog
#define IDD_PROMPT_MSHTML                   8131
#define IDC_PROMPT_PROMPT                   8132
#define IDC_PROMPT_EDIT                     8133

// Plugin/ActiveX Viewer Not Installed dialog
#define IDD_PLUGIN_UPGRADE                  8134
#define IDC_PLUGIN_UPGRADE_CHECK            8135
#define IDC_PLUGIN_UPGRADE_EXTENSION        8136
#define IDC_PLUGIN_UPGRADE_MIME_TYPE        8137

#define IDS_PROPERTYOPENPICTURE     5010
#define IDS_PROPERTYOPENMOUSEICON   5011

#define IDS_HTMLFORM_SAVE                   8114

#define IDS_SAVEPICTUREAS_GIF               8116
#define IDS_SAVEPICTUREAS_JPG               8117
#define IDS_SAVEPICTUREAS_BMP               8118
#define IDS_SAVEPICTUREAS_XBM               8119
#define IDS_SAVEPICTUREAS_ART               8120
#define IDS_SAVEPICTUREAS_WMF               8121
#define IDS_SAVEPICTUREAS_EMF               8122
#define IDS_SAVEPICTUREAS_AVI               8123
#define IDS_SAVEPICTUREAS_MPG               8124
#define IDS_SAVEPICTUREAS_MOV               8125
#define IDS_SAVEPICTUREAS_ORIGINAL          8126
#define IDS_UNTITLED_BITMAP                 8127
#define IDS_UNTITLED_MSHTML                 8128
#define IDS_WALLPAPER_BMP                   8129
#define IDS_SAVEPICTUREAS_PNG               8138
#define IDS_UPLOADFILE              5444

#ifdef UNIX
#  define IDS_PRINT_ERROR             5445
#  define IDS_PRINT_ERROR_MSG         5446
#endif


#define IDS_DLAY_ERROR_BASE      8999
#define IDS_MSG_DB_CANTSAVE         (IDS_DLAY_ERROR_BASE + 1)
#define IDS_EE_DB_COERCE            (IDS_DLAY_ERROR_BASE + 2)
#define IDS_EE_DB_DELROW            (IDS_DLAY_ERROR_BASE + 3)
#define IDS_EE_DB_READ              (IDS_DLAY_ERROR_BASE + 4)
#define IDS_EE_DB_SCHEMA            (IDS_DLAY_ERROR_BASE + 5)
#define IDS_EE_DB_CANCELED          (IDS_DLAY_ERROR_BASE + 6)
#define IDS_EE_DB_OTHER_STATUS      (IDS_DLAY_ERROR_BASE + 7)

#define IDS_MENUHELP(idm) (10000 + (idm))
#define IDS_TOOLTIP(idm)  (20000 + (idm))

//+----------------------------------------------------------------------------
//
// HTML Block Format String
//
//-----------------------------------------------------------------------------

#define IDS_BLOCKFMT_NORMAL    1000
#define IDS_BLOCKFMT_PRE       1001
#define IDS_BLOCKFMT_ADDRESS   1002
#define IDS_BLOCKFMT_H1        1003
#define IDS_BLOCKFMT_H2        1004
#define IDS_BLOCKFMT_H3        1005
#define IDS_BLOCKFMT_H4        1006
#define IDS_BLOCKFMT_H5        1007
#define IDS_BLOCKFMT_H6        1008
#define IDS_BLOCKFMT_OL        1009
#define IDS_BLOCKFMT_UL        1010
#define IDS_BLOCKFMT_DIR       1011
#define IDS_BLOCKFMT_MENU      1012
#define IDS_BLOCKFMT_DT        1013
#define IDS_BLOCKFMT_DD        1014
#define IDS_BLOCKFMT_P         1016

#define IDS_HELPABOUT_STRING   1017

//+----------------------------------------------------------------------------
//
// default title caption for untitled HTML documents
//
//-----------------------------------------------------------------------------

#define IDS_NULL_TITLE         1020

// default document security property
#define IDS_DEFAULT_DOC_SECURITY_PROP       8130

//+----------------------------------------------------------------------------
//
//   MailTo constants
//
//----------------------------------------------------------------------------
#define IDS_MAILTO_DEFAULTSUBJECT       8600
#define IDS_MAILTO_MAILCLIENTNOTFOUND   8601
#define IDS_MAILTO_SUBMITALERT          8602

// New Encoding Menu
#define RES_STRING_ENCODING_MORE            4700

#if DBG == 1

#define IDS_COLOR_BLACK             5430
#define IDS_COLOR_NAVY              5431
#define IDS_COLOR_BLUE              5432
#define IDS_COLOR_CYAN              5433
#define IDS_COLOR_RED               5434
#define IDS_COLOR_LIME              5435
#define IDS_COLOR_GRAY              5436
#define IDS_COLOR_GREEN             5437
#define IDS_COLOR_YELLOW            5438
#define IDS_COLOR_PINK              5439
#define IDS_COLOR_VIOLET            5440
#define IDS_COLOR_WHITE             5441
// 5442 and 5443 replaced by html dialogs

#endif // DBG == 1

//----------------------------------------------------------------------------
//
// HTML dialog (53xx)
//
//----------------------------------------------------------------------------

#define IDS_WEBPAGEDIALOG           5301
#define IDS_CODEPAGE                5302

//----------------------------------------------------------------------------
//
// Icons
//
//----------------------------------------------------------------------------

#define RES_ICO_FRAME                   2660
#define RES_ICO_HTML                    2661
#define IDI_APPEARANCE                  2662
#define IDI_ADVANCED                    2663
#define IDI_GOTOURL                     2664
#define IDI_HOMEPAGE_MSHTML             2665
#define IDI_FINDTEXT                    2666
#define IDI_UNKNOWN_FILETYPE            2667
#define RES_ICO_GIF                     2668
#define RES_ICO_JPEG                    2669
#define RES_ICON_FOLDER_OPEN            2670
#define RES_ICON_FOLDER_CLOSED          2671
#define RES_ICON_URL_FILE               2672
#define RES_ICO_NOICON                  2673
#define RES_ICO_FINDING                 2674
#define RES_ICO_CONNECTING              2675
#define RES_ICO_ACCESSING               2676
#define RES_ICO_RECEIVING               2677
#define IDI_INTERNET                    2678
#define IDI_SECURITY                    2679
#define IDI_NEWS                        2680
#define IDI_VRML                        2681

#define IDB_DITHER                      2502
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching
#define IDB_NOTLOADED                   2030
#define IDB_MISSING                     2031

//----------------------------------------------------------------------------
//
// Tab order dialog (3250 - 3260)
//
//----------------------------------------------------------------------------
#define IDR_TABORDERLBL             3250
#define IDR_TABORDERLSTBOX          3251
#define IDR_BTNMOVEUP               3252
#define IDR_BTNMOVEDOWN             3253
//#define IDR_BTNAUTOORDER            3254
#define IDR_TABORDERDLG             3255
//#define IDR_TABORDERMOVELBL         3256

// Menu index
#define MENU_INDEX_EDIT             1
#define MENU_INDEX_VIEW             2
#define MENU_INDEX_INSERT           3
#define MENU_INDEX_FORMAT           4


//

// unfortunately, these macros can't be used in defining
//  the symbols below: the resource compiler doesn't like them.
#define IDS_USERTYPEFULL(base)  ((base)/5)
#define IDS_USERTYPESHORT(base) ((base)/5 + 1)

#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range

#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2

#define RT_FILE                         2110



// siterc.h

// Add controls to the save as dialog.
#define IDC_SAVE_CHARSET_MSHTML    8194
#define IDR_BASE_HTMLFORM           900

#ifndef NO_HTML_DIALOG
// find resources are now located in shdocvw (peterlee)
//#define IDR_FINDDIALOG              _T("find.dlg")
//#define IDR_BIDIFINDDIALOG          _T("bidifind.dlg")
#define IDR_REPLACEDIALOG           _T("replace.dlg")
#define IDR_FORPARDIALOG            _T("forpar.dlg")
#define IDR_FORCHARDIALOG           _T("forchar.dlg")
#define IDR_GOBOOKDIALOG            _T("gobook.dlg")
#define IDR_INSIMAGEDIALOG          _T("insimage.dlg")
#define IDR_EDLINKDIALOG            _T("edlink.dlg")
#define IDR_EDBOOKDIALOG            _T("edbook.dlg")
#endif // NO_HTML_DIALOG


// otherrc.h
#define IDD_GENERICPAGE             5202
#define IDB_APPLY                   5209
#define IDB_OPENDLG                 5210

// window.close dialog string ID.
//
// BUGBUG (scotrobe): This same ID exists in
// resource.h in shdocvw. Don't change one 
// without the other.
//
#define IDS_CONFIRM_SCRIPT_CLOSE_TEXT 0x3035

#pragma INCMSG("--- End 'mshtmlrc.h'")
#else
#pragma INCMSG("*** Dup 'mshtmlrc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\msiehost.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  File:       msiehost.idl
//
//  Contents:   Definitions for Web Browser OC host (not automatable)
//
//----------------------------------------------------------------------------
//=--------------------------------------------------------------------------=
// msiehost.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

//---------------------------------------------------------------------------=
// Definitions for IOleCommandTarget IDs


#ifndef _MSIEHOST_H
#define _MSIEHOST_H

EXTERN_C const GUID CGID_InternetExplorer;

// CGID_InternetExplorer CMDID definitions
#define IECMDID_CLEAR_AUTOCOMPLETE_FOR_FORMS        0
#define IECMDID_SETID_AUTOCOMPLETE_FOR_FORMS        1

#define IECMDID_BEFORENAVIGATE_GETSHELLBROWSE     2
#define IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE   3
#define IECMDID_BEFORENAVIGATE_GETIDLIST          4

//  Takes a VARIANT of type VT_BOOL for pvarargIn
//  to set it.
#define IECMDID_SET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW    5

//  Sets a VARIANT of type VT_BOOL for pvarargOut
#define IECMDID_GET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW    6

// Values for first parameter of IEID_CLEAR_AUTOCOMPLETE_FOR_FORMS
#define IECMDID_ARG_CLEAR_FORMS_ALL                 0
#define IECMDID_ARG_CLEAR_FORMS_ALL_BUT_PASSWORDS   1
#define IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY      2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\mshtmdid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __COREDISP_H__
#define __COREDISP_H__
//;end_internal

//;begin_internal
//
// The following dispid must be the smallest possible dispid so that it
// always ends up first in our attr array.
// It does not need to be exposed to the outside world
#define DISPID_AAHEADER                 MINLONG             // DISPID is 0x80000000
#define DISPID_RECALC_INFO              MINLONG+1
//;end_internal


#define DISPID_XOBJ_MIN                 0x80010000
#define DISPID_XOBJ_MAX                 0x8001FFFF
#define DISPID_XOBJ_BASE                DISPID_XOBJ_MIN
#define DISPID_HTMLOBJECT               (DISPID_XOBJ_BASE   + 500)
#define DISPID_ELEMENT                  (DISPID_HTMLOBJECT  + 500)
#define DISPID_SITE                     (DISPID_ELEMENT     + 1000)
#define DISPID_OBJECT                   (DISPID_SITE        + 1000)
#define DISPID_STYLE                    (DISPID_OBJECT      + 1000)
#define DISPID_ATTRS                    (DISPID_STYLE       + 1000)
#define DISPID_EVENTS                   (DISPID_ATTRS       + 1000)
#define DISPID_XOBJ_EXPANDO             (DISPID_EVENTS      + 1000)
#define DISPID_XOBJ_ORDINAL             (DISPID_XOBJ_EXPANDO+ 1000)

//;begin_internal
// Expandos for ActiveX controls, note these are very limited compared to
// normal expandos on an element.

#define DISPID_ACTIVEX_EXPANDO_BASE      DISPID_XOBJ_EXPANDO
#define DISPID_ACTIVEX_EXPANDO_MAX       (DISPID_ACTIVEX_EXPANDO_BASE + 999)

#define DISPID_OBJECT_ORDINAL_BASE       DISPID_XOBJ_ORDINAL
#define DISPID_OBJECT_ORDINAL_MAX       (DISPID_OBJECT_ORDINAL_BASE + 999)

#define DISPID_COLLECTION_MIN           1000000
#define DISPID_COLLECTION_MAX           2999999

// Divide collection dispid space into "named member" half and "ordinal access" half
// for stylesheets collection.
#define DISPID_STYLESHEETSCOLLECTION_NAMED_BASE        (DISPID_COLLECTION_MIN)
#define DISPID_STYLESHEETSCOLLECTION_NAMED_MAX         (DISPID_COLLECTION_MIN+((DISPID_COLLECTION_MAX-DISPID_COLLECTION_MIN)/2))
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE      (DISPID_STYLESHEETSCOLLECTION_NAMED_MAX+1)
#define DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX       (DISPID_COLLECTION_MAX)

// DISPID range for expandos not associated with an ActiveX control
#define DISPID_EXPANDO_BASE             3000000
#define DISPID_EXPANDO_MAX              3999999

#define IsStandardDispid(dispid)        (dispid <= 0)
#define IsExpandoDispid(dispid)         (DISPID_EXPANDO_BASE <= dispid && dispid <= DISPID_EXPANDO_MAX)

#define DISPID_EVENTHOOK_SENSITIVE_BASE   4000000
#define DISPID_EVENTHOOK_SENSITIVE_MAX    4499999
#define DISPID_EVENTHOOK_INSENSITIVE_BASE 4500000
#define DISPID_EVENTHOOK_INSENSITIVE_MAX  4999999

#define DISPID_PEER_HOLDER_BASE         5000000

#define IsPeerDispid(dispid)            (DISPID_PEER_HOLDER_BASE <= dispid)

//;end_internal

//;begin_internal
//
// IE 4 dispids that no longer exist
//
//;end_internal
#define DISPID_HTMLOPTIONBUTTONELEMENTEVENTS_ONCHANGE       DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONCHANGE

//;begin_internal
//
// Standard control properties
//
//;end_internal

//;begin_internal
//;QUESTION: rgardner - why do we use these names ???
//;end_internal
#define DISPID_CommonCtrl_FONTNAME        1
#define DISPID_CommonCtrl_FONTSIZE        2
#define DISPID_CommonCtrl_FONTBOLD        3
#define DISPID_CommonCtrl_FONTITAL        4
#define DISPID_CommonCtrl_FONTUNDER       5
#define DISPID_CommonCtrl_FONTSTRIKE      6
#define DISPID_CommonCtrl_FONTWEIGHT      7
#define DISPID_CommonCtrl_FONTCHARSET     8
#define DISPID_CommonCtrl_FONTSUPERSCRIPT 9
#define DISPID_CommonCtrl_FONTSUBSCRIPT   10

// Data Binding DISPID's
#define DISPID_MSDATASRCINTERFACE       (-3900)
#define DISPID_ADVISEDATASRCCHANGEEVENT (-3901)


//;begin_internal
// DISPID values for HTML Dialogs files per interface
//;end_internal

#define DISPID_HTMLDLG                          25000
#define DISPID_HTMLDLGMODEL                     26000

//;begin_internal
// DISPID values for HTML Popup files per interface
//;end_internal

#define DISPID_HTMLPOPUP                        27000

//;begin_internal
// DISPID values for HTML Application files per interface
//;end_internal

#define DISPID_HTMLAPP                          5000

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These values match those used by VB and are for the benefit of controls
//  with hard coded knowledge of VB.
//
//----------------------------------------------------------------------------
//;end_internal

#define STDPROPID_XOBJ_NAME                 (DISPID_XOBJ_BASE + 0x0)
#define STDPROPID_XOBJ_INDEX                (DISPID_XOBJ_BASE + 0x1)
//;begin_internal
// for IE3 compatibility

#define STDPROPID_IE3XOBJ_OBJECTALIGN     (DISPID_XOBJ_BASE + 0x1) 

// STDPROPID_XOBJ_BASEHREF is a constant used by IE3
//;end_internal
#define STDPROPID_XOBJ_BASEHREF             (DISPID_XOBJ_BASE + 0x2) 
#define STDPROPID_XOBJ_LEFT                 (DISPID_XOBJ_BASE + 0x3)
#define STDPROPID_XOBJ_TOP                  (DISPID_XOBJ_BASE + 0x4)
#define STDPROPID_XOBJ_WIDTH                (DISPID_XOBJ_BASE + 0x5)
#define STDPROPID_XOBJ_HEIGHT               (DISPID_XOBJ_BASE + 0x6)
#define STDPROPID_XOBJ_VISIBLE              (DISPID_XOBJ_BASE + 0x7)
#define STDPROPID_XOBJ_PARENT               (DISPID_XOBJ_BASE + 0x8)
#define STDPROPID_XOBJ_DRAGMODE             (DISPID_XOBJ_BASE + 0x9)
#define STDPROPID_XOBJ_DRAGICON             (DISPID_XOBJ_BASE + 0xA)
#define STDPROPID_XOBJ_TAG                  (DISPID_XOBJ_BASE + 0xB)
#define STDPROPID_XOBJ_TABSTOP              (DISPID_XOBJ_BASE + 0xE)
#define STDPROPID_XOBJ_TABINDEX             (DISPID_XOBJ_BASE + 0xF)
#define STDPROPID_XOBJ_HELPCONTEXTID        (DISPID_XOBJ_BASE + 0x32)
#define STDPROPID_XOBJ_DEFAULT              (DISPID_XOBJ_BASE + 0x37)
#define STDPROPID_XOBJ_CANCEL               (DISPID_XOBJ_BASE + 0x38)
#define STDPROPID_XOBJ_LEFTNORUN            (DISPID_XOBJ_BASE + 0x39)
#define STDPROPID_XOBJ_TOPNORUN             (DISPID_XOBJ_BASE + 0x3A)
#define STDPROPID_XOBJ_ALIGNPERSIST         (DISPID_XOBJ_BASE + 0x3C)
#define STDPROPID_XOBJ_LINKTIMEOUT          (DISPID_XOBJ_BASE + 0x3D)
#define STDPROPID_XOBJ_LINKTOPIC            (DISPID_XOBJ_BASE + 0x3E)
#define STDPROPID_XOBJ_LINKITEM             (DISPID_XOBJ_BASE + 0x3F)
#define STDPROPID_XOBJ_LINKMODE             (DISPID_XOBJ_BASE + 0x40)
#define STDPROPID_XOBJ_DATACHANGED          (DISPID_XOBJ_BASE + 0x41)
#define STDPROPID_XOBJ_DATAFIELD            (DISPID_XOBJ_BASE + 0x42)
#define STDPROPID_XOBJ_DATASOURCE           (DISPID_XOBJ_BASE + 0x43)
#define STDPROPID_XOBJ_WHATSTHISHELPID      (DISPID_XOBJ_BASE + 0x44)
#define STDPROPID_XOBJ_CONTROLTIPTEXT       (DISPID_XOBJ_BASE + 0x45)
#define STDPROPID_XOBJ_STATUSBARTEXT        (DISPID_XOBJ_BASE + 0x46)
#define STDPROPID_XOBJ_APPLICATION          (DISPID_XOBJ_BASE + 0x47)
#define STDPROPID_XOBJ_BLOCKALIGN           (DISPID_XOBJ_BASE + 0x48)
#define STDPROPID_XOBJ_CONTROLALIGN         (DISPID_XOBJ_BASE + 0x49)
#define STDPROPID_XOBJ_STYLE                (DISPID_XOBJ_BASE + 0x4A)
#define STDPROPID_XOBJ_COUNT                (DISPID_XOBJ_BASE + 0x4B)
#define STDPROPID_XOBJ_DISABLED             (DISPID_XOBJ_BASE + 0x4C)
#define STDPROPID_XOBJ_RIGHT                (DISPID_XOBJ_BASE + 0x4D)
#define STDPROPID_XOBJ_BOTTOM               (DISPID_XOBJ_BASE + 0x4E)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Semi-standard x-object properties.
//
//  These are events that are fired for all sites
//----------------------------------------------------------------------------
//;end_internal

#define STDDISPID_XOBJ_ONBLUR                           (DISPID_XOBJ_BASE)
#define STDDISPID_XOBJ_ONFOCUS                          (DISPID_XOBJ_BASE + 1)
#define STDDISPID_XOBJ_BEFOREUPDATE                     (DISPID_XOBJ_BASE + 4)
#define STDDISPID_XOBJ_AFTERUPDATE                      (DISPID_XOBJ_BASE + 5)
#define STDDISPID_XOBJ_ONROWEXIT                        (DISPID_XOBJ_BASE + 6)
#define STDDISPID_XOBJ_ONROWENTER                       (DISPID_XOBJ_BASE + 7)
#define STDDISPID_XOBJ_ONMOUSEOVER                      (DISPID_XOBJ_BASE + 8)
#define STDDISPID_XOBJ_ONMOUSEOUT                       (DISPID_XOBJ_BASE + 9)
#define STDDISPID_XOBJ_ONHELP                           (DISPID_XOBJ_BASE + 10)
#define STDDISPID_XOBJ_ONDRAGSTART                      (DISPID_XOBJ_BASE + 11)
#define STDDISPID_XOBJ_ONSELECTSTART                    (DISPID_XOBJ_BASE + 12)
#define STDDISPID_XOBJ_ERRORUPDATE                      (DISPID_XOBJ_BASE + 13)
#define STDDISPID_XOBJ_ONDATASETCHANGED                 (DISPID_XOBJ_BASE + 14)
#define STDDISPID_XOBJ_ONDATAAVAILABLE                  (DISPID_XOBJ_BASE + 15)
#define STDDISPID_XOBJ_ONDATASETCOMPLETE                (DISPID_XOBJ_BASE + 16)
#define STDDISPID_XOBJ_ONFILTER                         (DISPID_XOBJ_BASE + 17)
#define STDDISPID_XOBJ_ONLOSECAPTURE                    (DISPID_XOBJ_BASE + 18)
#define STDDISPID_XOBJ_ONPROPERTYCHANGE                 (DISPID_XOBJ_BASE + 19)
#define STDDISPID_XOBJ_ONDRAG                           (DISPID_XOBJ_BASE + 20)
#define STDDISPID_XOBJ_ONDRAGEND                        (DISPID_XOBJ_BASE + 21)
#define STDDISPID_XOBJ_ONDRAGENTER                      (DISPID_XOBJ_BASE + 22)
#define STDDISPID_XOBJ_ONDRAGOVER                       (DISPID_XOBJ_BASE + 23)
#define STDDISPID_XOBJ_ONDRAGLEAVE                      (DISPID_XOBJ_BASE + 24)
#define STDDISPID_XOBJ_ONDROP                           (DISPID_XOBJ_BASE + 25)
#define STDDISPID_XOBJ_ONCUT                            (DISPID_XOBJ_BASE + 26)
#define STDDISPID_XOBJ_ONCOPY                           (DISPID_XOBJ_BASE + 27)
#define STDDISPID_XOBJ_ONPASTE                          (DISPID_XOBJ_BASE + 28)
#define STDDISPID_XOBJ_ONBEFORECUT                      (DISPID_XOBJ_BASE + 29)
#define STDDISPID_XOBJ_ONBEFORECOPY                     (DISPID_XOBJ_BASE + 30)
#define STDDISPID_XOBJ_ONBEFOREPASTE                    (DISPID_XOBJ_BASE + 31)
#define STDDISPID_XOBJ_ONROWSDELETE                     (DISPID_XOBJ_BASE + 32)
#define STDDISPID_XOBJ_ONROWSINSERTED                   (DISPID_XOBJ_BASE + 33)
#define STDDISPID_XOBJ_ONCELLCHANGE                     (DISPID_XOBJ_BASE + 34)

//;begin_internal
//----------------------------------------------------------------------------
//
//  Base DISPIDs for each class.
//
//  Object and its base classes must use ids in the reserved x-object range.
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_NORMAL_FIRST                     1000
#define DISPID_ANCHOR                           DISPID_NORMAL_FIRST
#define DISPID_BLOCK                            DISPID_NORMAL_FIRST
#define DISPID_BODY                             (DISPID_TEXTSITE + 1000)
#define DISPID_BR                               DISPID_NORMAL_FIRST
#define DISPID_BGSOUND                          DISPID_NORMAL_FIRST
#define DISPID_DD                               DISPID_NORMAL_FIRST
#define DISPID_DIR                              DISPID_NORMAL_FIRST
#define DISPID_DIV                              DISPID_NORMAL_FIRST
#define DISPID_DL                               DISPID_NORMAL_FIRST
#define DISPID_DT                               DISPID_NORMAL_FIRST
#define DISPID_EFONT                            DISPID_NORMAL_FIRST
#define DISPID_FORM                             DISPID_NORMAL_FIRST
#define DISPID_HEADER                           DISPID_NORMAL_FIRST
#define DISPID_HEDELEMS                         DISPID_NORMAL_FIRST
#define DISPID_HR                               DISPID_NORMAL_FIRST
#define DISPID_LABEL                            DISPID_NORMAL_FIRST
#define DISPID_LI                               DISPID_NORMAL_FIRST
#define DISPID_IMGBASE                          DISPID_NORMAL_FIRST
#define DISPID_IMG                              (DISPID_IMGBASE + 1000)
#define DISPID_INPUTIMAGE                       (DISPID_IMGBASE + 1000)
#define DISPID_INPUT                            (DISPID_TEXTSITE + 1000)
#define DISPID_INPUTTEXTBASE                    (DISPID_INPUT+1000)
#define DISPID_INPUTTEXT                        (DISPID_INPUTTEXTBASE+1000)
#define DISPID_MENU                             DISPID_NORMAL_FIRST
#define DISPID_OL                               DISPID_NORMAL_FIRST
#define DISPID_PARA                             DISPID_NORMAL_FIRST
#define DISPID_SELECT                           DISPID_NORMAL_FIRST
#define DISPID_SELECTOBJ                        DISPID_NORMAL_FIRST
#define DISPID_TABLE                            DISPID_NORMAL_FIRST
#define DISPID_TEXTSITE                         DISPID_NORMAL_FIRST
#define DISPID_TEXTAREA                         (DISPID_INPUTTEXT + 1000)
#define DISPID_MARQUEE                          (DISPID_TEXTAREA + 1000)
#define DISPID_RICHTEXT                         (DISPID_MARQUEE + 1000)
#define DISPID_BUTTON                           (DISPID_RICHTEXT + 1000)
#define DISPID_UL                               DISPID_NORMAL_FIRST
#define DISPID_PHRASE                           DISPID_NORMAL_FIRST
#define DISPID_UNKNOWNPDL                       DISPID_NORMAL_FIRST
#define DISPID_COMMENTPDL                       DISPID_NORMAL_FIRST
#define DISPID_TABLECELL                        (DISPID_TEXTSITE + 1000)
#define DISPID_RANGE                            DISPID_NORMAL_FIRST
#define DISPID_SELECTION                        DISPID_NORMAL_FIRST
#define DISPID_OPTION                           DISPID_NORMAL_FIRST
#define DISPID_1D                               (DISPID_TEXTSITE + 1000)
#define DISPID_MAP                              DISPID_NORMAL_FIRST
#define DISPID_AREA                             DISPID_NORMAL_FIRST
#define DISPID_PARAM                            DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_TABLEROW                         DISPID_NORMAL_FIRST
#define DISPID_TABLECOL                         DISPID_NORMAL_FIRST
#define DISPID_SCRIPT                           DISPID_NORMAL_FIRST
#define DISPID_STYLESHEET                       DISPID_NORMAL_FIRST
#define DISPID_STYLERULE                        DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGE                        DISPID_NORMAL_FIRST
#define DISPID_STYLESHEETS_COL                  DISPID_NORMAL_FIRST
#define DISPID_STYLERULES_COL                   DISPID_NORMAL_FIRST
#define DISPID_STYLEPAGES_COL                   DISPID_NORMAL_FIRST
#define DISPID_MIMETYPES_COL                    DISPID_NORMAL_FIRST
#define DISPID_PLUGINS_COL                      DISPID_NORMAL_FIRST
#define DISPID_2D                               DISPID_NORMAL_FIRST
#define DISPID_OMWINDOW                         DISPID_NORMAL_FIRST
#define DISPID_EVENTOBJ                         DISPID_NORMAL_FIRST
#define DISPID_PERSISTDATA                      DISPID_NORMAL_FIRST
#define DISPID_OLESITE                          DISPID_NORMAL_FIRST
#define DISPID_FRAMESET                         DISPID_NORMAL_FIRST
#define DISPID_LINK                             DISPID_NORMAL_FIRST
#define DISPID_STYLEELEMENT                     DISPID_NORMAL_FIRST
#define DISPID_FILTERS                          DISPID_NORMAL_FIRST
#define DISPID_TABLESECTION                     DISPID_NORMAL_FIRST
#define DISPID_OMRECT                           DISPID_NORMAL_FIRST
#define DISPID_DOMATTRIBUTE                     DISPID_NORMAL_FIRST
#define DISPID_DOMTEXTNODE                      DISPID_NORMAL_FIRST
#define DISPID_GENERIC                          DISPID_NORMAL_FIRST
#define DISPID_URN_COLL                         DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE_COLLECTION             DISPID_NORMAL_FIRST
#define DISPID_NAMESPACE                        DISPID_NORMAL_FIRST
#define DISPID_TAGNAMES_COLLECTION              DISPID_NORMAL_FIRST

#define DISPID_HTMLDOCUMENT                     DISPID_NORMAL_FIRST
#define DISPID_OMDOCUMENT                       DISPID_NORMAL_FIRST
#define DISPID_DATATRANSFER                     DISPID_NORMAL_FIRST
#define DISPID_XMLDECL                          DISPID_NORMAL_FIRST
#define DISPID_DOCFRAG                          DISPID_NORMAL_FIRST
#define DISPID_ILINEINFO                        DISPID_NORMAL_FIRST
#define DISPID_IHTMLCOMPUTEDSTYLE               DISPID_NORMAL_FIRST
//;begin_internal
    // Special case for compatability with IE4 -> therefore the 1:
//;end_internal
#define DISPID_WINDOW                           1
#define DISPID_SCREEN                           DISPID_NORMAL_FIRST
#define DISPID_FRAMESCOLLECTION                 DISPID_NORMAL_FIRST
#define DISPID_HISTORY                          1
#define DISPID_LOCATION                         1
#define DISPID_NAVIGATOR                        1
#define DISPID_COLLECTION                       (DISPID_NORMAL_FIRST+500)
#define DISPID_OPTIONS_COL                      (DISPID_NORMAL_FIRST+500)

#define DISPID_CHECKBOX                         DISPID_NORMAL_FIRST
#define DISPID_RADIO                            (DISPID_CHECKBOX + 1000)

#define DISPID_FRAMESITE                        (DISPID_SITE        + 1000)
#define DISPID_FRAME                            (DISPID_FRAMESITE   + 1000)
#define DISPID_IFRAME                           (DISPID_FRAMESITE   + 1000)

#define WEBOC_DISPIDBASE                        (DISPID_FRAMESITE   + 2000)
#define WEBOC_DISPIDMAX                         (WEBOC_DISPIDBASE   +  100)

#define DISPID_PROTECTEDELEMENT                 DISPID_NORMAL_FIRST
#define DISPID_DEFAULTS                         DISPID_NORMAL_FIRST
#define DISPID_MARKUP                           DISPID_NORMAL_FIRST
#define DISPID_DOMIMPLEMENTATION                DISPID_NORMAL_FIRST

//;begin_internal
//----------------------------------------------------------------------------
//
//  Reserved negative DISPIDs
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_WINDOWOBJECT                     (-5500)
#define DISPID_LOCATIONOBJECT                   (-5506)
#define DISPID_HISTORYOBJECT                    (-5507)
#define DISPID_NAVIGATOROBJECT                  (-5508)
#define DISPID_SECURITYCTX                      (-5511)
#define DISPID_AMBIENT_DLCONTROL                (-5512)
#define DISPID_AMBIENT_USERAGENT                (-5513)
#define DISPID_SECURITYDOMAIN                   (-5514)
//;begin_internal
#define DISPID_DEBUG_ISSECUREPROXY              (-5515)
#define DISPID_DEBUG_TRUSTEDPROXY               (-5516)
#define DISPID_DEBUG_INTERNALWINDOW             (-5517)
#define DISPID_DEBUG_ENABLESECUREPROXYASSERTS   (-5518)
//;end_internal
#define DLCTL_DLIMAGES                          0x00000010
#define DLCTL_VIDEOS                            0x00000020
#define DLCTL_BGSOUNDS                          0x00000040
#define DLCTL_NO_SCRIPTS                        0x00000080
#define DLCTL_NO_JAVA                           0x00000100
#define DLCTL_NO_RUNACTIVEXCTLS                 0x00000200
#define DLCTL_NO_DLACTIVEXCTLS                  0x00000400
#define DLCTL_DOWNLOADONLY                      0x00000800
#define DLCTL_NO_FRAMEDOWNLOAD                  0x00001000
#define DLCTL_RESYNCHRONIZE                     0x00002000
#define DLCTL_PRAGMA_NO_CACHE                   0x00004000
#define DLCTL_NO_BEHAVIORS                      0x00008000
#define DLCTL_NO_METACHARSET                    0x00010000
#define DLCTL_URL_ENCODING_DISABLE_UTF8         0x00020000
#define DLCTL_URL_ENCODING_ENABLE_UTF8          0x00040000
#define DLCTL_NOFRAMES                          0x00080000
#define DLCTL_FORCEOFFLINE                      0x10000000
#define DLCTL_NO_CLIENTPULL                     0x20000000
#define DLCTL_SILENT                            0x40000000
#define DLCTL_OFFLINEIFNOTCONNECTED             0x80000000
#define DLCTL_OFFLINE                           DLCTL_OFFLINEIFNOTCONNECTED

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each non xobject event
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_ONABORT                          (DISPID_NORMAL_FIRST)
#define DISPID_ONCHANGE                         (DISPID_NORMAL_FIRST + 1)
#define DISPID_ONERROR                          (DISPID_NORMAL_FIRST + 2)
#define DISPID_ONLOAD                           (DISPID_NORMAL_FIRST + 3)
#define DISPID_ONSELECT                         (DISPID_NORMAL_FIRST + 6)
#define DISPID_ONSUBMIT                         (DISPID_NORMAL_FIRST + 7)
#define DISPID_ONUNLOAD                         (DISPID_NORMAL_FIRST + 8)
#define DISPID_ONBOUNCE                         (DISPID_NORMAL_FIRST + 9)
#define DISPID_ONFINISH                         (DISPID_NORMAL_FIRST + 10)
#define DISPID_ONSTART                          (DISPID_NORMAL_FIRST + 11)
#define DISPID_ONLAYOUT                         (DISPID_NORMAL_FIRST + 13)
#define DISPID_ONSCROLL                         (DISPID_NORMAL_FIRST + 14)
#define DISPID_ONRESET                          (DISPID_NORMAL_FIRST + 15)
#define DISPID_ONRESIZE                         (DISPID_NORMAL_FIRST + 16)
#define DISPID_ONBEFOREUNLOAD                   (DISPID_NORMAL_FIRST + 17)
#define DISPID_ONCHANGEFOCUS                    (DISPID_NORMAL_FIRST + 18)
#define DISPID_ONCHANGEBLUR                     (DISPID_NORMAL_FIRST + 19)
#define DISPID_ONPERSIST                        (DISPID_NORMAL_FIRST + 20)
#define DISPID_ONPERSISTSAVE                    (DISPID_NORMAL_FIRST + 21)
#define DISPID_ONPERSISTLOAD                    (DISPID_NORMAL_FIRST + 22)
#define DISPID_ONCONTEXTMENU                    (DISPID_NORMAL_FIRST + 23)
#define DISPID_ONBEFOREPRINT                    (DISPID_NORMAL_FIRST + 24)
#define DISPID_ONAFTERPRINT                     (DISPID_NORMAL_FIRST + 25)
#define DISPID_ONSTOP                           (DISPID_NORMAL_FIRST + 26)
#define DISPID_ONBEFOREEDITFOCUS                (DISPID_NORMAL_FIRST + 27)
#define DISPID_ONMOUSEHOVER                     (DISPID_NORMAL_FIRST + 28)
#define DISPID_ONCONTENTREADY                   (DISPID_NORMAL_FIRST + 29)
#define DISPID_ONLAYOUTCOMPLETE                 (DISPID_NORMAL_FIRST + 30)
#define DISPID_ONPAGE                           (DISPID_NORMAL_FIRST + 31)
#define DISPID_ONLINKEDOVERFLOW                 (DISPID_NORMAL_FIRST + 32)
#define DISPID_ONMOUSEWHEEL                     (DISPID_NORMAL_FIRST + 33)
#define DISPID_ONBEFOREDEACTIVATE               (DISPID_NORMAL_FIRST + 34)
#define DISPID_ONMOVE                           (DISPID_NORMAL_FIRST + 35)
#define DISPID_ONCONTROLSELECT                  (DISPID_NORMAL_FIRST + 36)
#define DISPID_ONSELECTIONCHANGE                (DISPID_NORMAL_FIRST + 37)
#define DISPID_ONMOVESTART                      (DISPID_NORMAL_FIRST + 38)
#define DISPID_ONMOVEEND                        (DISPID_NORMAL_FIRST + 39)
#define DISPID_ONRESIZESTART                    (DISPID_NORMAL_FIRST + 40)
#define DISPID_ONRESIZEEND                      (DISPID_NORMAL_FIRST + 41)
#define DISPID_ONMOUSEENTER                     (DISPID_NORMAL_FIRST + 42)
#define DISPID_ONMOUSELEAVE                     (DISPID_NORMAL_FIRST + 43)
#define DISPID_ONACTIVATE                       (DISPID_NORMAL_FIRST + 44)
#define DISPID_ONDEACTIVATE                     (DISPID_NORMAL_FIRST + 45)
#define DISPID_ONMULTILAYOUTCLEANUP             (DISPID_NORMAL_FIRST + 46)
#define DISPID_ONBEFOREACTIVATE                 (DISPID_NORMAL_FIRST + 47)
#define DISPID_ONFOCUSIN                        (DISPID_NORMAL_FIRST + 48)
#define DISPID_ONFOCUSOUT                       (DISPID_NORMAL_FIRST + 49)

//;begin_internal
//----------------------------------------------------------------------------
//
//  DISPID for each unique HtmlAttribute/CssAttribute
//
//----------------------------------------------------------------------------
//;end_internal

#define DISPID_A_FIRST                          DISPID_ATTRS
#define DISPID_A_MIN                            DISPID_ATTRS
#define DISPID_A_MAX                            (DISPID_ATTRS+999)

#define DISPID_A_BACKGROUNDIMAGE                (DISPID_A_FIRST+1)
#define DISPID_A_COLOR                          (DISPID_A_FIRST+2)
#define DISPID_A_TEXTTRANSFORM                  (DISPID_A_FIRST+4)
#define DISPID_A_NOWRAP                         (DISPID_A_FIRST+5)
#define DISPID_A_LINEHEIGHT                     (DISPID_A_FIRST+6)
#define DISPID_A_TEXTINDENT                     (DISPID_A_FIRST+7)
#define DISPID_A_LETTERSPACING                  (DISPID_A_FIRST+8)
#define DISPID_A_LANG                           (DISPID_A_FIRST+9)
#define DISPID_A_OVERFLOW                       (DISPID_A_FIRST+10)

#define DISPID_A_PADDING                        (DISPID_A_FIRST+11)
#define DISPID_A_PADDINGTOP                     (DISPID_A_FIRST+12)
#define DISPID_A_PADDINGRIGHT                   (DISPID_A_FIRST+13)
#define DISPID_A_PADDINGBOTTOM                  (DISPID_A_FIRST+14)
#define DISPID_A_PADDINGLEFT                    (DISPID_A_FIRST+15)

#define DISPID_A_CLEAR                          (DISPID_A_FIRST+16)
#define DISPID_A_LISTTYPE                       (DISPID_A_FIRST+17)
#define DISPID_A_FONTFACE                       (DISPID_A_FIRST+18)
#define DISPID_A_FONTSIZE                       (DISPID_A_FIRST+19)

#define DISPID_A_TEXTDECORATIONLINETHROUGH      (DISPID_A_FIRST+20)
#define DISPID_A_TEXTDECORATIONUNDERLINE        (DISPID_A_FIRST+21)
#define DISPID_A_TEXTDECORATIONBLINK            (DISPID_A_FIRST+22)
#define DISPID_A_TEXTDECORATIONNONE             (DISPID_A_FIRST+23)


#define DISPID_A_FONTSTYLE                      (DISPID_A_FIRST+24)
#define DISPID_A_FONTVARIANT                    (DISPID_A_FIRST+25)
#define DISPID_A_BASEFONT                       (DISPID_A_FIRST+26)
#define DISPID_A_FONTWEIGHT                     (DISPID_A_FIRST+27)

#define DISPID_A_TABLEBORDERCOLOR               (DISPID_A_FIRST+28)
#define DISPID_A_TABLEBORDERCOLORLIGHT          (DISPID_A_FIRST+29)
#define DISPID_A_TABLEBORDERCOLORDARK           (DISPID_A_FIRST+30)
#define DISPID_A_TABLEVALIGN                    (DISPID_A_FIRST+31)

#define DISPID_A_BACKGROUND                     (DISPID_A_FIRST+32)
#define DISPID_A_BACKGROUNDPOSX                 (DISPID_A_FIRST+33)
#define DISPID_A_BACKGROUNDPOSY                 (DISPID_A_FIRST+34)

#define DISPID_A_TEXTDECORATION                 (DISPID_A_FIRST+35)

#define DISPID_A_MARGIN                         (DISPID_A_FIRST+36)
#define DISPID_A_MARGINTOP                      (DISPID_A_FIRST+37)
#define DISPID_A_MARGINRIGHT                    (DISPID_A_FIRST+38)
#define DISPID_A_MARGINBOTTOM                   (DISPID_A_FIRST+39)
#define DISPID_A_MARGINLEFT                     (DISPID_A_FIRST+40)

#define DISPID_A_FONT                           (DISPID_A_FIRST+41)
#define DISPID_A_FONTSIZEKEYWORD                (DISPID_A_FIRST+42)
#define DISPID_A_FONTSIZECOMBINE                (DISPID_A_FIRST+43)

#define DISPID_A_BACKGROUNDREPEAT               (DISPID_A_FIRST+44)
#define DISPID_A_BACKGROUNDATTACHMENT           (DISPID_A_FIRST+45)
#define DISPID_A_BACKGROUNDPOSITION             (DISPID_A_FIRST+46)
#define DISPID_A_WORDSPACING                    (DISPID_A_FIRST+47)
#define DISPID_A_VERTICALALIGN                  (DISPID_A_FIRST+48)
#define DISPID_A_BORDER                         (DISPID_A_FIRST+49)
#define DISPID_A_BORDERTOP                      (DISPID_A_FIRST+50)
#define DISPID_A_BORDERRIGHT                    (DISPID_A_FIRST+51)
#define DISPID_A_BORDERBOTTOM                   (DISPID_A_FIRST+52)
#define DISPID_A_BORDERLEFT                     (DISPID_A_FIRST+53)
#define DISPID_A_BORDERCOLOR                    (DISPID_A_FIRST+54)
#define DISPID_A_BORDERTOPCOLOR                 (DISPID_A_FIRST+55)
#define DISPID_A_BORDERRIGHTCOLOR               (DISPID_A_FIRST+56)
#define DISPID_A_BORDERBOTTOMCOLOR              (DISPID_A_FIRST+57)
#define DISPID_A_BORDERLEFTCOLOR                (DISPID_A_FIRST+58)
#define DISPID_A_BORDERWIDTH                    (DISPID_A_FIRST+59)
#define DISPID_A_BORDERTOPWIDTH                 (DISPID_A_FIRST+60)
#define DISPID_A_BORDERRIGHTWIDTH               (DISPID_A_FIRST+61)
#define DISPID_A_BORDERBOTTOMWIDTH              (DISPID_A_FIRST+62)
#define DISPID_A_BORDERLEFTWIDTH                (DISPID_A_FIRST+63)
#define DISPID_A_BORDERSTYLE                    (DISPID_A_FIRST+64)
#define DISPID_A_BORDERTOPSTYLE                 (DISPID_A_FIRST+65)
#define DISPID_A_BORDERRIGHTSTYLE               (DISPID_A_FIRST+66)
#define DISPID_A_BORDERBOTTOMSTYLE              (DISPID_A_FIRST+67)
#define DISPID_A_BORDERLEFTSTYLE                (DISPID_A_FIRST+68)
#define DISPID_A_TEXTDECORATIONOVERLINE         (DISPID_A_FIRST+69)
#define DISPID_A_FLOAT                          (DISPID_A_FIRST+70)
#define DISPID_A_DISPLAY                        (DISPID_A_FIRST+71)
#define DISPID_A_LISTSTYLETYPE                  (DISPID_A_FIRST+72)
#define DISPID_A_LISTSTYLEPOSITION              (DISPID_A_FIRST+73)
#define DISPID_A_LISTSTYLEIMAGE                 (DISPID_A_FIRST+74)
#define DISPID_A_LISTSTYLE                      (DISPID_A_FIRST+75)
#define DISPID_A_WHITESPACE                     (DISPID_A_FIRST+76)
#define DISPID_A_PAGEBREAKBEFORE                (DISPID_A_FIRST+77)
#define DISPID_A_PAGEBREAKAFTER                 (DISPID_A_FIRST+78)
#define DISPID_A_SCROLL                         (DISPID_A_FIRST+79)
#define DISPID_A_VISIBILITY                     (DISPID_A_FIRST+80)
//;begin_internal
// This dispid is available
#define DISPID_A_HIDDEN                         (DISPID_A_FIRST+81)
//;end_internal
#define DISPID_A_FILTER                         (DISPID_A_FIRST+82)

#define DISPID_DEFAULTVALUE                     (DISPID_A_FIRST+83)

#define DISPID_A_BORDERCOLLAPSE                 (DISPID_A_FIRST+84)

#define DISPID_A_POSITION                       (DISPID_A_FIRST+90)
#define DISPID_A_ZINDEX                         (DISPID_A_FIRST+91)
#define DISPID_A_CLIP                           (DISPID_A_FIRST+92)
#define DISPID_A_CLIPRECTTOP                    (DISPID_A_FIRST+93)
#define DISPID_A_CLIPRECTRIGHT                  (DISPID_A_FIRST+94)
#define DISPID_A_CLIPRECTBOTTOM                 (DISPID_A_FIRST+95)
#define DISPID_A_CLIPRECTLEFT                   (DISPID_A_FIRST+96)

#define DISPID_A_FONTFACESRC                    (DISPID_A_FIRST+97)
#define DISPID_A_TABLELAYOUT                    (DISPID_A_FIRST+98)

//;begin_internal
// The style as a text string
//;end_internal
#define DISPID_A_STYLETEXT                      (DISPID_A_FIRST+99)

//;begin_internal
// Known attributes that have special meaning
//;end_internal
#define DISPID_A_LANGUAGE                       (DISPID_A_FIRST+100)

#define DISPID_A_VALUE                          (DISPID_A_FIRST+101)
#define DISPID_A_CURSOR                         (DISPID_A_FIRST+102)


//;begin_internal
//+-----------------------------------------------------------------------
//  A couple of dispids that are used internally for firing
//  events and prop notifies.
// Keep all the internal dispid's together, otherwise we'll trip up 

#define DISPID_A_EVENTSINK                      (DISPID_A_FIRST+103)
#define DISPID_A_PROPNOTIFYSINK                 (DISPID_A_FIRST+104)
#define DISPID_A_ROWSETNOTIFYSINK               (DISPID_A_FIRST+105)
#define DISPID_INTERNAL_INLINESTYLEAA           (DISPID_A_FIRST+106) // In line style Attr Array
#define DISPID_INTERNAL_CSTYLEPTRCACHE          (DISPID_A_FIRST+107) // Cached CStyle Ptr
#define DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE   (DISPID_A_FIRST+108) // runtime style ptr obj
#define DISPID_INTERNAL_INVOKECONTEXT           (DISPID_A_FIRST+109) // Cached Invoke context

#define DISPID_A_BGURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+110)
#define DISPID_A_LIURLIMGCTXCACHEINDEX          (DISPID_A_FIRST+111)
#define DISPID_A_ROWSETASYNCHNOTIFYSINK         (DISPID_A_FIRST+112)
#define DISPID_INTERNAL_FILTERPTRCACHE          (DISPID_A_FIRST+113) // FilterCollection in AttrArray
#define DISPID_A_ROWPOSITIONCHANGESINK          (DISPID_A_FIRST+114)
//;end_internal

#define DISPID_A_BEHAVIOR                       (DISPID_A_FIRST+115) // xtags
#define DISPID_A_READYSTATE                     (DISPID_A_FIRST+116) // ready state

#define DISPID_A_DIR                            (DISPID_A_FIRST+117) // Complex Text support for bidi
#define DISPID_A_UNICODEBIDI                    (DISPID_A_FIRST+118) // Complex Text support for CSS2 unicode-bidi
#define DISPID_A_DIRECTION                      (DISPID_A_FIRST+119) // Complex Text support for CSS2 direction

#define DISPID_A_IMEMODE                        (DISPID_A_FIRST+120) 

#define DISPID_A_RUBYALIGN                      (DISPID_A_FIRST+121)
#define DISPID_A_RUBYPOSITION                   (DISPID_A_FIRST+122)
#define DISPID_A_RUBYOVERHANG                   (DISPID_A_FIRST+123)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY  (DISPID_A_FIRST+124)
#define DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY (DISPID_A_FIRST+125)
#define DISPID_INTERNAL_CDOMCHILDRENPTRCACHE     (DISPID_A_FIRST+126)
//;end_internal

#define DISPID_A_LAYOUTGRIDCHAR                 (DISPID_A_FIRST+127)
#define DISPID_A_LAYOUTGRIDLINE                 (DISPID_A_FIRST+128)
#define DISPID_A_LAYOUTGRIDMODE                 (DISPID_A_FIRST+129)
#define DISPID_A_LAYOUTGRIDTYPE                 (DISPID_A_FIRST+130)
#define DISPID_A_LAYOUTGRID                     (DISPID_A_FIRST+131)

#define DISPID_A_TEXTAUTOSPACE                  (DISPID_A_FIRST+132)

#define DISPID_A_LINEBREAK                      (DISPID_A_FIRST+133)
#define DISPID_A_WORDBREAK                      (DISPID_A_FIRST+134)

#define DISPID_A_TEXTJUSTIFY                    (DISPID_A_FIRST+135)
#define DISPID_A_TEXTJUSTIFYTRIM                (DISPID_A_FIRST+136)
#define DISPID_A_TEXTKASHIDA                    (DISPID_A_FIRST+137)

#define DISPID_A_OVERFLOWX                      (DISPID_A_FIRST+139)
#define DISPID_A_OVERFLOWY                      (DISPID_A_FIRST+140)

#define DISPID_A_HTCDISPATCHITEM_VALUE          (DISPID_A_FIRST+141)
#define DISPID_A_DOCFRAGMENT                    (DISPID_A_FIRST+142)

#define DISPID_A_HTCDD_ELEMENT                  (DISPID_A_FIRST+143)
#define DISPID_A_HTCDD_CREATEEVENTOBJECT        (DISPID_A_FIRST+144)

#define DISPID_A_URNATOM                        (DISPID_A_FIRST+145)
#define DISPID_A_UNIQUEPEERNUMBER               (DISPID_A_FIRST+146)

#define DISPID_A_ACCELERATOR                    (DISPID_A_FIRST+147)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE       (DISPID_A_FIRST+148)
#define DISPID_INTERNAL_RUNTIMESTYLEAA              (DISPID_A_FIRST+149)
#define DISPID_A_HTCDISPATCHITEM_VALUE_SCRIPTSONLY  (DISPID_A_FIRST+150)
//;end_internal

#define DISPID_A_EXTENDEDTAGDESC                (DISPID_A_FIRST+151)

#define DISPID_A_ROTATE                         (DISPID_A_FIRST+152)
#define DISPID_A_ZOOM                           (DISPID_A_FIRST+153)

#define DISPID_A_HTCDD_PROTECTEDELEMENT         (DISPID_A_FIRST+154)
#define DISPID_A_LAYOUTFLOW                     (DISPID_A_FIRST+155)
// DISPID_A_FIRST+156 unused -- removing 'rectangular'
// #define DISPID_A_RECTANGULAR                    (DISPID_A_FIRST+156)

#define DISPID_A_HTCDD_ISMARKUPSHARED           (DISPID_A_FIRST+157)
#define DISPID_A_WORDWRAP                       (DISPID_A_FIRST+158)
#define DISPID_A_TEXTUNDERLINEPOSITION          (DISPID_A_FIRST+159)
#define DISPID_A_HASLAYOUT                      (DISPID_A_FIRST+160)
#define DISPID_A_MEDIA                          (DISPID_A_FIRST+161)
#define DISPID_A_EDITABLE                       (DISPID_A_FIRST+162)
#define DISPID_A_HIDEFOCUS                      (DISPID_A_FIRST+163)

//;begin_internal
#define DISPID_INTERNAL_LAYOUTRECTREGISTRYPTRCACHE  (DISPID_A_FIRST+164)
//;end_internal

#define DISPID_A_HTCDD_DEFAULTS                 (DISPID_A_FIRST+165)

#define DISPID_A_TEXTLINETHROUGHSTYLE           (DISPID_A_FIRST+166)
#define DISPID_A_TEXTUNDERLINESTYLE             (DISPID_A_FIRST+167)
#define DISPID_A_TEXTEFFECT                     (DISPID_A_FIRST+168)
#define DISPID_A_TEXTBACKGROUNDCOLOR            (DISPID_A_FIRST+169)
#define DISPID_A_RENDERINGPRIORITY              (DISPID_A_FIRST+170)

//;begin_internal
#define DISPID_INTERNAL_DWNPOSTPTRCACHE             (DISPID_A_FIRST+171)
#define DISPID_INTERNAL_CODEPAGESETTINGSPTRCACHE    (DISPID_A_FIRST+172)
#define DISPID_INTERNAL_DWNDOCPTRCACHE              (DISPID_A_FIRST+173)
#define DISPID_INTERNAL_DATABINDTASKPTRCACHE        (DISPID_A_FIRST+174)
#define DISPID_INTERNAL_URLLOCATIONCACHE            (DISPID_A_FIRST+175)
#define DISPID_INTERNAL_ARYELEMENTRELEASENOTIFYPTRCACHE (DISPID_A_FIRST+176)
#define DISPID_INTERNAL_PEERFACTORYURLMAPPTRCACHE   (DISPID_A_FIRST+177)
#define DISPID_INTERNAL_STMDIRTYPTRCACHE            (DISPID_A_FIRST+178)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_COMPUTEFORMATSTATECACHE     (DISPID_A_FIRST+179)
//;end_internal

//
#define DISPID_A_SCROLLBARBASECOLOR             (DISPID_A_FIRST+180)
#define DISPID_A_SCROLLBARFACECOLOR             (DISPID_A_FIRST+181)
#define DISPID_A_SCROLLBAR3DLIGHTCOLOR          (DISPID_A_FIRST+182)
#define DISPID_A_SCROLLBARSHADOWCOLOR           (DISPID_A_FIRST+183)
#define DISPID_A_SCROLLBARHIGHLIGHTCOLOR        (DISPID_A_FIRST+184)
#define DISPID_A_SCROLLBARDARKSHADOWCOLOR       (DISPID_A_FIRST+185)
#define DISPID_A_SCROLLBARARROWCOLOR            (DISPID_A_FIRST+186)

//;begin_internal
#define DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE  (DISPID_A_FIRST+187)
//;end_internal

#define DISPID_A_DEFAULTTEXTSELECTION           (DISPID_A_FIRST+188)
#define DISPID_A_TEXTDECORATIONCOLOR            (DISPID_A_FIRST+189)
#define DISPID_A_TEXTCOLOR                      (DISPID_A_FIRST+190)
#define DISPID_A_STYLETEXTDECORATION            (DISPID_A_FIRST+191)

#define DISPID_A_WRITINGMODE                    (DISPID_A_FIRST+192)

//;begin_internal
#define DISPID_INTERNAL_MEDIA_REFERENCE         (DISPID_A_FIRST+193)
#define DISPID_INTERNAL_GENERICCOMPLUSREF       (DISPID_A_FIRST+194)
//;end_internal

//;begin_internal
#define DISPID_INTERNAL_FOCUSITEMS              (DISPID_A_FIRST+195)
//;end_internal

#define DISPID_A_SCROLLBARTRACKCOLOR            (DISPID_A_FIRST+196)

//;begin_internal
#define DISPID_INTERNAL_DWNHEADERCACHE          (DISPID_A_FIRST+197)
//;end_internal

#define DISPID_A_FROZEN                         (DISPID_A_FIRST+198)
#define DISPID_A_VIEWINHERITSTYLE               (DISPID_A_FIRST+199)

//;begin_internal
#define DISPID_INTERNAL_FRAMESCOLLECTION        (DISPID_A_FIRST+200)
//;end_internal

//;begin_internal
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE    (DISPID_A_FIRST+201)
#define DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER  (DISPID_A_FIRST+202)
//;end_internal

#define DISPID_A_TEXTALIGNLAST                  (DISPID_A_FIRST+203)
#define DISPID_A_TEXTKASHIDASPACE               (DISPID_A_FIRST+204)

//;begin_internal
#define DISPID_INTERNAL_FONTHISTORYINDEX        (DISPID_A_FIRST+205)
//;end_internal

#define DISPID_A_ALLOWTRANSPARENCY              (DISPID_A_FIRST+206)

#define DISPID_INTERNAL_URLSEARCHCACHE          (DISPID_A_FIRST+207)

#define DISPID_A_ISBLOCK                        (DISPID_A_FIRST+208)

#define DISPID_A_TEXTOVERFLOW                   (DISPID_A_FIRST+209)

//;begin_internal
#define DISPID_INTERNAL_CATTRIBUTECOLLPTRCACHE  (DISPID_A_FIRST+210)
//;end_internal

#define DISPID_A_MINHEIGHT                      (DISPID_A_FIRST+211)

//;begin_internal
#define DISPID_INTERNAL_INVOKECONTEXTDOCUMENT   (DISPID_A_FIRST+212)
//;end_internal

//;begin_internal
//------------------------------------------------------------------------
//
//  Event property and method dispids
//
//------------------------------------------------------------------------
//;end_internal

#define DISPID_EVPROP_ONMOUSEOVER           (DISPID_EVENTS +  0)
#define DISPID_EVMETH_ONMOUSEOVER            STDDISPID_XOBJ_ONMOUSEOVER
#define DISPID_EVPROP_ONMOUSEOUT            (DISPID_EVENTS +  1)
#define DISPID_EVMETH_ONMOUSEOUT             STDDISPID_XOBJ_ONMOUSEOUT
#define DISPID_EVPROP_ONMOUSEDOWN           (DISPID_EVENTS +  2)
#define DISPID_EVMETH_ONMOUSEDOWN            DISPID_MOUSEDOWN
#define DISPID_EVPROP_ONMOUSEUP             (DISPID_EVENTS +  3)
#define DISPID_EVMETH_ONMOUSEUP              DISPID_MOUSEUP
#define DISPID_EVPROP_ONMOUSEMOVE           (DISPID_EVENTS +  4)
#define DISPID_EVMETH_ONMOUSEMOVE            DISPID_MOUSEMOVE
#define DISPID_EVPROP_ONKEYDOWN             (DISPID_EVENTS +  5)
#define DISPID_EVMETH_ONKEYDOWN              DISPID_KEYDOWN
#define DISPID_EVPROP_ONKEYUP               (DISPID_EVENTS +  6)
#define DISPID_EVMETH_ONKEYUP                DISPID_KEYUP
#define DISPID_EVPROP_ONKEYPRESS            (DISPID_EVENTS +  7)
#define DISPID_EVMETH_ONKEYPRESS             DISPID_KEYPRESS
#define DISPID_EVPROP_ONCLICK               (DISPID_EVENTS +  8)
#define DISPID_EVMETH_ONCLICK                DISPID_CLICK
#define DISPID_EVPROP_ONDBLCLICK            (DISPID_EVENTS +  9)
#define DISPID_EVMETH_ONDBLCLICK             DISPID_DBLCLICK
#define DISPID_EVPROP_ONSELECT              (DISPID_EVENTS + 10)
#define DISPID_EVMETH_ONSELECT               DISPID_ONSELECT
#define DISPID_EVPROP_ONSUBMIT              (DISPID_EVENTS + 11)
#define DISPID_EVMETH_ONSUBMIT               DISPID_ONSUBMIT
#define DISPID_EVPROP_ONRESET               (DISPID_EVENTS + 12)
#define DISPID_EVMETH_ONRESET                DISPID_ONRESET
#define DISPID_EVPROP_ONHELP                (DISPID_EVENTS + 13)
#define DISPID_EVMETH_ONHELP                 STDDISPID_XOBJ_ONHELP
#define DISPID_EVPROP_ONFOCUS               (DISPID_EVENTS + 14)
#define DISPID_EVMETH_ONFOCUS                STDDISPID_XOBJ_ONFOCUS
#define DISPID_EVPROP_ONBLUR                (DISPID_EVENTS + 15)
#define DISPID_EVMETH_ONBLUR                 STDDISPID_XOBJ_ONBLUR
#define DISPID_EVPROP_ONROWEXIT             (DISPID_EVENTS + 18)
#define DISPID_EVMETH_ONROWEXIT              STDDISPID_XOBJ_ONROWEXIT
#define DISPID_EVPROP_ONROWENTER            (DISPID_EVENTS + 19)
#define DISPID_EVMETH_ONROWENTER             STDDISPID_XOBJ_ONROWENTER
#define DISPID_EVPROP_ONBOUNCE              (DISPID_EVENTS + 20)
#define DISPID_EVMETH_ONBOUNCE               DISPID_ONBOUNCE
#define DISPID_EVPROP_ONBEFOREUPDATE        (DISPID_EVENTS + 21)
#define DISPID_EVMETH_ONBEFOREUPDATE         STDDISPID_XOBJ_BEFOREUPDATE
#define DISPID_EVPROP_ONAFTERUPDATE         (DISPID_EVENTS + 22)
#define DISPID_EVMETH_ONAFTERUPDATE          STDDISPID_XOBJ_AFTERUPDATE
#define DISPID_EVPROP_ONBEFOREDRAGOVER      (DISPID_EVENTS + 23)
#define DISPID_EVMETH_ONBEFOREDRAGOVER       EVENTID_CommonCtrlEvent_BeforeDragOver
#define DISPID_EVPROP_ONBEFOREDROPORPASTE   (DISPID_EVENTS + 24)
#define DISPID_EVMETH_ONBEFOREDROPORPASTE    EVENTID_CommonCtrlEvent_BeforeDropOrPaste
#define DISPID_EVPROP_ONREADYSTATECHANGE    (DISPID_EVENTS + 25)
#define DISPID_EVMETH_ONREADYSTATECHANGE     DISPID_READYSTATECHANGE
#define DISPID_EVPROP_ONFINISH              (DISPID_EVENTS + 26)
#define DISPID_EVMETH_ONFINISH               DISPID_ONFINISH
#define DISPID_EVPROP_ONSTART               (DISPID_EVENTS + 27)
#define DISPID_EVMETH_ONSTART                DISPID_ONSTART
#define DISPID_EVPROP_ONABORT               (DISPID_EVENTS + 28)
#define DISPID_EVMETH_ONABORT                DISPID_ONABORT
#define DISPID_EVPROP_ONERROR               (DISPID_EVENTS + 29)
#define DISPID_EVMETH_ONERROR                DISPID_ONERROR
#define DISPID_EVPROP_ONCHANGE              (DISPID_EVENTS + 30)
#define DISPID_EVMETH_ONCHANGE               DISPID_ONCHANGE
#define DISPID_EVPROP_ONSCROLL              (DISPID_EVENTS + 31)
#define DISPID_EVMETH_ONSCROLL               DISPID_ONSCROLL
#define DISPID_EVPROP_ONLOAD                (DISPID_EVENTS + 32)
#define DISPID_EVMETH_ONLOAD                 DISPID_ONLOAD
#define DISPID_EVPROP_ONUNLOAD              (DISPID_EVENTS + 33)
#define DISPID_EVMETH_ONUNLOAD               DISPID_ONUNLOAD
#define DISPID_EVPROP_ONLAYOUT              (DISPID_EVENTS + 34)
#define DISPID_EVMETH_ONLAYOUT               DISPID_ONLAYOUT
#define DISPID_EVPROP_ONDRAGSTART           (DISPID_EVENTS + 35)
#define DISPID_EVMETH_ONDRAGSTART            STDDISPID_XOBJ_ONDRAGSTART
#define DISPID_EVPROP_ONRESIZE              (DISPID_EVENTS + 36)
#define DISPID_EVMETH_ONRESIZE               DISPID_ONRESIZE
#define DISPID_EVPROP_ONSELECTSTART         (DISPID_EVENTS + 37)
#define DISPID_EVMETH_ONSELECTSTART          STDDISPID_XOBJ_ONSELECTSTART
#define DISPID_EVPROP_ONERRORUPDATE         (DISPID_EVENTS + 38)
#define DISPID_EVMETH_ONERRORUPDATE          STDDISPID_XOBJ_ERRORUPDATE
#define DISPID_EVPROP_ONBEFOREUNLOAD        (DISPID_EVENTS + 39)
#define DISPID_EVMETH_ONBEFOREUNLOAD         DISPID_ONBEFOREUNLOAD
#define DISPID_EVPROP_ONDATASETCHANGED      (DISPID_EVENTS + 40)
#define DISPID_EVMETH_ONDATASETCHANGED       STDDISPID_XOBJ_ONDATASETCHANGED
#define DISPID_EVPROP_ONDATAAVAILABLE       (DISPID_EVENTS + 41)
#define DISPID_EVMETH_ONDATAAVAILABLE        STDDISPID_XOBJ_ONDATAAVAILABLE
#define DISPID_EVPROP_ONDATASETCOMPLETE     (DISPID_EVENTS + 42)
#define DISPID_EVMETH_ONDATASETCOMPLETE      STDDISPID_XOBJ_ONDATASETCOMPLETE
#define DISPID_EVPROP_ONFILTER              (DISPID_EVENTS + 43)
#define DISPID_EVMETH_ONFILTER               STDDISPID_XOBJ_ONFILTER
#define DISPID_EVPROP_ONCHANGEFOCUS         (DISPID_EVENTS + 44)
#define DISPID_EVMETH_ONCHANGEFOCUS          DISPID_ONCHANGEFOCUS
#define DISPID_EVPROP_ONCHANGEBLUR          (DISPID_EVENTS + 45)
#define DISPID_EVMETH_ONCHANGEBLUR           DISPID_ONCHANGEBLUR
#define DISPID_EVPROP_ONLOSECAPTURE         (DISPID_EVENTS + 46)
#define DISPID_EVMETH_ONLOSECAPTURE          STDDISPID_XOBJ_ONLOSECAPTURE
#define DISPID_EVPROP_ONPROPERTYCHANGE      (DISPID_EVENTS + 47)
#define DISPID_EVMETH_ONPROPERTYCHANGE       STDDISPID_XOBJ_ONPROPERTYCHANGE
#define DISPID_EVPROP_ONPERSISTSAVE         (DISPID_EVENTS + 48)
#define DISPID_EVMETH_ONPERSISTSAVE          DISPID_ONPERSISTSAVE
#define DISPID_EVPROP_ONDRAG                (DISPID_EVENTS + 49)
#define DISPID_EVMETH_ONDRAG                 STDDISPID_XOBJ_ONDRAG
#define DISPID_EVPROP_ONDRAGEND             (DISPID_EVENTS + 50)
#define DISPID_EVMETH_ONDRAGEND              STDDISPID_XOBJ_ONDRAGEND
#define DISPID_EVPROP_ONDRAGENTER           (DISPID_EVENTS + 51)
#define DISPID_EVMETH_ONDRAGENTER            STDDISPID_XOBJ_ONDRAGENTER
#define DISPID_EVPROP_ONDRAGOVER            (DISPID_EVENTS + 52)
#define DISPID_EVMETH_ONDRAGOVER             STDDISPID_XOBJ_ONDRAGOVER
#define DISPID_EVPROP_ONDRAGLEAVE           (DISPID_EVENTS + 53)
#define DISPID_EVMETH_ONDRAGLEAVE            STDDISPID_XOBJ_ONDRAGLEAVE
#define DISPID_EVPROP_ONDROP                (DISPID_EVENTS + 54)
#define DISPID_EVMETH_ONDROP                 STDDISPID_XOBJ_ONDROP
#define DISPID_EVPROP_ONCUT                 (DISPID_EVENTS + 55)
#define DISPID_EVMETH_ONCUT                  STDDISPID_XOBJ_ONCUT
#define DISPID_EVPROP_ONCOPY                (DISPID_EVENTS + 56)
#define DISPID_EVMETH_ONCOPY                 STDDISPID_XOBJ_ONCOPY
#define DISPID_EVPROP_ONPASTE               (DISPID_EVENTS + 57)
#define DISPID_EVMETH_ONPASTE                STDDISPID_XOBJ_ONPASTE
#define DISPID_EVPROP_ONBEFORECUT           (DISPID_EVENTS + 58)
#define DISPID_EVMETH_ONBEFORECUT            STDDISPID_XOBJ_ONBEFORECUT
#define DISPID_EVPROP_ONBEFORECOPY          (DISPID_EVENTS + 59)
#define DISPID_EVMETH_ONBEFORECOPY           STDDISPID_XOBJ_ONBEFORECOPY
#define DISPID_EVPROP_ONBEFOREPASTE         (DISPID_EVENTS + 60)
#define DISPID_EVMETH_ONBEFOREPASTE          STDDISPID_XOBJ_ONBEFOREPASTE
#define DISPID_EVPROP_ONPERSISTLOAD         (DISPID_EVENTS + 61)
#define DISPID_EVMETH_ONPERSISTLOAD          DISPID_ONPERSISTLOAD
#define DISPID_EVPROP_ONROWSDELETE          (DISPID_EVENTS + 62)
#define DISPID_EVMETH_ONROWSDELETE           STDDISPID_XOBJ_ONROWSDELETE
#define DISPID_EVPROP_ONROWSINSERTED        (DISPID_EVENTS + 63)
#define DISPID_EVMETH_ONROWSINSERTED         STDDISPID_XOBJ_ONROWSINSERTED
#define DISPID_EVPROP_ONCELLCHANGE          (DISPID_EVENTS + 64)
#define DISPID_EVMETH_ONCELLCHANGE           STDDISPID_XOBJ_ONCELLCHANGE
#define DISPID_EVPROP_ONCONTEXTMENU         (DISPID_EVENTS + 65)
#define DISPID_EVMETH_ONCONTEXTMENU          DISPID_ONCONTEXTMENU
#define DISPID_EVPROP_ONBEFOREPRINT         (DISPID_EVENTS + 66)
#define DISPID_EVMETH_ONBEFOREPRINT          DISPID_ONBEFOREPRINT
#define DISPID_EVPROP_ONAFTERPRINT          (DISPID_EVENTS + 67)
#define DISPID_EVMETH_ONAFTERPRINT           DISPID_ONAFTERPRINT
#define DISPID_EVPROP_ONSTOP                (DISPID_EVENTS + 68)
#define DISPID_EVMETH_ONSTOP                DISPID_ONSTOP
#define DISPID_EVPROP_ONBEFOREEDITFOCUS     (DISPID_EVENTS + 69)
#define DISPID_EVMETH_ONBEFOREEDITFOCUS      DISPID_ONBEFOREEDITFOCUS
#define DISPID_EVPROP_ONATTACHEVENT         (DISPID_EVENTS + 70)
#define DISPID_EVPROP_ONMOUSEHOVER          (DISPID_EVENTS + 71)
#define DISPID_EVMETH_ONMOUSEHOVER           DISPID_ONMOUSEHOVER
#define DISPID_EVPROP_ONCONTENTREADY        (DISPID_EVENTS + 72)
#define DISPID_EVMETH_ONCONTENTREADY         DISPID_ONCONTENTREADY
#define DISPID_EVPROP_ONLAYOUTCOMPLETE      (DISPID_EVENTS + 73)
#define DISPID_EVMETH_ONLAYOUTCOMPLETE       DISPID_ONLAYOUTCOMPLETE
#define DISPID_EVPROP_ONPAGE                (DISPID_EVENTS + 74)
#define DISPID_EVMETH_ONPAGE                 DISPID_ONPAGE
#define DISPID_EVPROP_ONLINKEDOVERFLOW      (DISPID_EVENTS + 75)
#define DISPID_EVMETH_ONLINKEDOVERFLOW       DISPID_ONLINKEDOVERFLOW
#define DISPID_EVPROP_ONMOUSEWHEEL          (DISPID_EVENTS + 76)
#define DISPID_EVMETH_ONMOUSEWHEEL           DISPID_ONMOUSEWHEEL
#define DISPID_EVPROP_ONBEFOREDEACTIVATE    (DISPID_EVENTS + 77)
#define DISPID_EVMETH_ONBEFOREDEACTIVATE     DISPID_ONBEFOREDEACTIVATE
#define DISPID_EVPROP_ONMOVE                (DISPID_EVENTS + 78)
#define DISPID_EVMETH_ONMOVE                 DISPID_ONMOVE
#define DISPID_EVPROP_ONCONTROLSELECT       (DISPID_EVENTS + 79)
#define DISPID_EVMETH_ONCONTROLSELECT        DISPID_ONCONTROLSELECT
#define DISPID_EVPROP_ONSELECTIONCHANGE     (DISPID_EVENTS + 80)
#define DISPID_EVMETH_ONSELECTIONCHANGE      DISPID_ONSELECTIONCHANGE
#define DISPID_EVPROP_ONMOVESTART           (DISPID_EVENTS + 81)
#define DISPID_EVMETH_ONMOVESTART            DISPID_ONMOVESTART
#define DISPID_EVPROP_ONMOVEEND             (DISPID_EVENTS + 82)
#define DISPID_EVMETH_ONMOVEEND              DISPID_ONMOVEEND
#define DISPID_EVPROP_ONRESIZESTART         (DISPID_EVENTS + 83)
#define DISPID_EVMETH_ONRESIZESTART          DISPID_ONRESIZESTART
#define DISPID_EVPROP_ONRESIZEEND           (DISPID_EVENTS + 84)
#define DISPID_EVMETH_ONRESIZEEND            DISPID_ONRESIZEEND
#define DISPID_EVPROP_ONMOUSEENTER          (DISPID_EVENTS + 85)
#define DISPID_EVMETH_ONMOUSEENTER           DISPID_ONMOUSEENTER
#define DISPID_EVPROP_ONMOUSELEAVE          (DISPID_EVENTS + 86)
#define DISPID_EVMETH_ONMOUSELEAVE           DISPID_ONMOUSELEAVE
#define DISPID_EVPROP_ONACTIVATE            (DISPID_EVENTS + 87)
#define DISPID_EVMETH_ONACTIVATE             DISPID_ONACTIVATE
#define DISPID_EVPROP_ONDEACTIVATE          (DISPID_EVENTS + 88)
#define DISPID_EVMETH_ONDEACTIVATE           DISPID_ONDEACTIVATE
#define DISPID_EVPROP_ONMULTILAYOUTCLEANUP  (DISPID_EVENTS + 89)
#define DISPID_EVMETH_ONMULTILAYOUTCLEANUP   DISPID_ONMULTILAYOUTCLEANUP
#define DISPID_EVPROP_ONBEFOREACTIVATE      (DISPID_EVENTS + 90)
#define DISPID_EVMETH_ONBEFOREACTIVATE       DISPID_ONBEFOREACTIVATE
#define DISPID_EVPROP_ONFOCUSIN             (DISPID_EVENTS + 91)
#define DISPID_EVMETH_ONFOCUSIN              DISPID_ONFOCUSIN
#define DISPID_EVPROP_ONFOCUSOUT            (DISPID_EVENTS + 92)
#define DISPID_EVMETH_ONFOCUSOUT             DISPID_ONFOCUSOUT
#define DISPID_EVPROPS_COUNT                (                93)


//;begin_internal
#endif // __COREDISP_H__
//;end_internal

//    DISPIDs for interface IHTMLFiltersCollection

#define DISPID_IHTMLFILTERSCOLLECTION_LENGTH                      DISPID_FILTERS+1
#define DISPID_IHTMLFILTERSCOLLECTION__NEWENUM                    DISPID_NEWENUM
#define DISPID_IHTMLFILTERSCOLLECTION_ITEM                        DISPID_VALUE

//    DISPIDs for interface IDispatchEx

#define DISPID_IDISPATCHEX_GETDISPID                              
#define DISPID_IDISPATCHEX_INVOKEEX                               
#define DISPID_IDISPATCHEX_DELETEMEMBERBYNAME                     
#define DISPID_IDISPATCHEX_DELETEMEMBERBYDISPID                   
#define DISPID_IDISPATCHEX_GETMEMBERPROPERTIES                    
#define DISPID_IDISPATCHEX_GETMEMBERNAME                          
#define DISPID_IDISPATCHEX_GETNEXTDISPID                          
#define DISPID_IDISPATCHEX_GETNAMESPACEPARENT                     

//    DISPIDs for interface IObjectIdentity

#define DISPID_IOBJECTIDENTITY_ISEQUALOBJECT                      

//    DISPIDs for interface IPerPropertyBrowsing

#define DISPID_IPERPROPERTYBROWSING_GETDISPLAYSTRING              
#define DISPID_IPERPROPERTYBROWSING_MAPPROPERTYTOPAGE             
#define DISPID_IPERPROPERTYBROWSING_GETPREDEFINEDSTRINGS          
#define DISPID_IPERPROPERTYBROWSING_GETPREDEFINEDVALUE            

//    DISPIDs for interface IHTMLStyle

#define DISPID_IHTMLSTYLE_FONTFAMILY                              DISPID_A_FONTFACE
#define DISPID_IHTMLSTYLE_FONTSTYLE                               DISPID_A_FONTSTYLE
#define DISPID_IHTMLSTYLE_FONTVARIANT                             DISPID_A_FONTVARIANT
#define DISPID_IHTMLSTYLE_FONTWEIGHT                              DISPID_A_FONTWEIGHT
#define DISPID_IHTMLSTYLE_FONTSIZE                                DISPID_A_FONTSIZE
#define DISPID_IHTMLSTYLE_FONT                                    DISPID_A_FONT
#define DISPID_IHTMLSTYLE_COLOR                                   DISPID_A_COLOR
#define DISPID_IHTMLSTYLE_BACKGROUND                              DISPID_A_BACKGROUND
#define DISPID_IHTMLSTYLE_BACKGROUNDCOLOR                         DISPID_BACKCOLOR
#define DISPID_IHTMLSTYLE_BACKGROUNDIMAGE                         DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLSTYLE_BACKGROUNDREPEAT                        DISPID_A_BACKGROUNDREPEAT
#define DISPID_IHTMLSTYLE_BACKGROUNDATTACHMENT                    DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLSTYLE_BACKGROUNDPOSITION                      DISPID_A_BACKGROUNDPOSITION
#define DISPID_IHTMLSTYLE_BACKGROUNDPOSITIONX                     DISPID_A_BACKGROUNDPOSX
#define DISPID_IHTMLSTYLE_BACKGROUNDPOSITIONY                     DISPID_A_BACKGROUNDPOSY
#define DISPID_IHTMLSTYLE_WORDSPACING                             DISPID_A_WORDSPACING
#define DISPID_IHTMLSTYLE_LETTERSPACING                           DISPID_A_LETTERSPACING
#define DISPID_IHTMLSTYLE_TEXTDECORATION                          DISPID_A_TEXTDECORATION
#define DISPID_IHTMLSTYLE_TEXTDECORATIONNONE                      DISPID_A_TEXTDECORATIONNONE
#define DISPID_IHTMLSTYLE_TEXTDECORATIONUNDERLINE                 DISPID_A_TEXTDECORATIONUNDERLINE
#define DISPID_IHTMLSTYLE_TEXTDECORATIONOVERLINE                  DISPID_A_TEXTDECORATIONOVERLINE
#define DISPID_IHTMLSTYLE_TEXTDECORATIONLINETHROUGH               DISPID_A_TEXTDECORATIONLINETHROUGH
#define DISPID_IHTMLSTYLE_TEXTDECORATIONBLINK                     DISPID_A_TEXTDECORATIONBLINK
#define DISPID_IHTMLSTYLE_VERTICALALIGN                           DISPID_A_VERTICALALIGN
#define DISPID_IHTMLSTYLE_TEXTTRANSFORM                           DISPID_A_TEXTTRANSFORM
#define DISPID_IHTMLSTYLE_TEXTALIGN                               STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLSTYLE_TEXTINDENT                              DISPID_A_TEXTINDENT
#define DISPID_IHTMLSTYLE_LINEHEIGHT                              DISPID_A_LINEHEIGHT
#define DISPID_IHTMLSTYLE_MARGINTOP                               DISPID_A_MARGINTOP
#define DISPID_IHTMLSTYLE_MARGINRIGHT                             DISPID_A_MARGINRIGHT
#define DISPID_IHTMLSTYLE_MARGINBOTTOM                            DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLSTYLE_MARGINLEFT                              DISPID_A_MARGINLEFT
#define DISPID_IHTMLSTYLE_MARGIN                                  DISPID_A_MARGIN
#define DISPID_IHTMLSTYLE_PADDINGTOP                              DISPID_A_PADDINGTOP
#define DISPID_IHTMLSTYLE_PADDINGRIGHT                            DISPID_A_PADDINGRIGHT
#define DISPID_IHTMLSTYLE_PADDINGBOTTOM                           DISPID_A_PADDINGBOTTOM
#define DISPID_IHTMLSTYLE_PADDINGLEFT                             DISPID_A_PADDINGLEFT
#define DISPID_IHTMLSTYLE_PADDING                                 DISPID_A_PADDING
#define DISPID_IHTMLSTYLE_BORDER                                  DISPID_A_BORDER
#define DISPID_IHTMLSTYLE_BORDERTOP                               DISPID_A_BORDERTOP
#define DISPID_IHTMLSTYLE_BORDERRIGHT                             DISPID_A_BORDERRIGHT
#define DISPID_IHTMLSTYLE_BORDERBOTTOM                            DISPID_A_BORDERBOTTOM
#define DISPID_IHTMLSTYLE_BORDERLEFT                              DISPID_A_BORDERLEFT
#define DISPID_IHTMLSTYLE_BORDERCOLOR                             DISPID_A_BORDERCOLOR
#define DISPID_IHTMLSTYLE_BORDERTOPCOLOR                          DISPID_A_BORDERTOPCOLOR
#define DISPID_IHTMLSTYLE_BORDERRIGHTCOLOR                        DISPID_A_BORDERRIGHTCOLOR
#define DISPID_IHTMLSTYLE_BORDERBOTTOMCOLOR                       DISPID_A_BORDERBOTTOMCOLOR
#define DISPID_IHTMLSTYLE_BORDERLEFTCOLOR                         DISPID_A_BORDERLEFTCOLOR
#define DISPID_IHTMLSTYLE_BORDERWIDTH                             DISPID_A_BORDERWIDTH
#define DISPID_IHTMLSTYLE_BORDERTOPWIDTH                          DISPID_A_BORDERTOPWIDTH
#define DISPID_IHTMLSTYLE_BORDERRIGHTWIDTH                        DISPID_A_BORDERRIGHTWIDTH
#define DISPID_IHTMLSTYLE_BORDERBOTTOMWIDTH                       DISPID_A_BORDERBOTTOMWIDTH
#define DISPID_IHTMLSTYLE_BORDERLEFTWIDTH                         DISPID_A_BORDERLEFTWIDTH
#define DISPID_IHTMLSTYLE_BORDERSTYLE                             DISPID_A_BORDERSTYLE
#define DISPID_IHTMLSTYLE_BORDERTOPSTYLE                          DISPID_A_BORDERTOPSTYLE
#define DISPID_IHTMLSTYLE_BORDERRIGHTSTYLE                        DISPID_A_BORDERRIGHTSTYLE
#define DISPID_IHTMLSTYLE_BORDERBOTTOMSTYLE                       DISPID_A_BORDERBOTTOMSTYLE
#define DISPID_IHTMLSTYLE_BORDERLEFTSTYLE                         DISPID_A_BORDERLEFTSTYLE
#define DISPID_IHTMLSTYLE_WIDTH                                   STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLSTYLE_HEIGHT                                  STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLSTYLE_STYLEFLOAT                              DISPID_A_FLOAT
#define DISPID_IHTMLSTYLE_CLEAR                                   DISPID_A_CLEAR
#define DISPID_IHTMLSTYLE_DISPLAY                                 DISPID_A_DISPLAY
#define DISPID_IHTMLSTYLE_VISIBILITY                              DISPID_A_VISIBILITY
#define DISPID_IHTMLSTYLE_LISTSTYLETYPE                           DISPID_A_LISTSTYLETYPE
#define DISPID_IHTMLSTYLE_LISTSTYLEPOSITION                       DISPID_A_LISTSTYLEPOSITION
#define DISPID_IHTMLSTYLE_LISTSTYLEIMAGE                          DISPID_A_LISTSTYLEIMAGE
#define DISPID_IHTMLSTYLE_LISTSTYLE                               DISPID_A_LISTSTYLE
#define DISPID_IHTMLSTYLE_WHITESPACE                              DISPID_A_WHITESPACE
#define DISPID_IHTMLSTYLE_TOP                                     STDPROPID_XOBJ_TOP
#define DISPID_IHTMLSTYLE_LEFT                                    STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLSTYLE_POSITION                                DISPID_A_POSITION
#define DISPID_IHTMLSTYLE_ZINDEX                                  DISPID_A_ZINDEX
#define DISPID_IHTMLSTYLE_OVERFLOW                                DISPID_A_OVERFLOW
#define DISPID_IHTMLSTYLE_PAGEBREAKBEFORE                         DISPID_A_PAGEBREAKBEFORE
#define DISPID_IHTMLSTYLE_PAGEBREAKAFTER                          DISPID_A_PAGEBREAKAFTER
#define DISPID_IHTMLSTYLE_CSSTEXT                                 DISPID_A_STYLETEXT
#define DISPID_IHTMLSTYLE_PIXELTOP                                DISPID_STYLE+0
#define DISPID_IHTMLSTYLE_PIXELLEFT                               DISPID_STYLE+1
#define DISPID_IHTMLSTYLE_PIXELWIDTH                              DISPID_STYLE+2
#define DISPID_IHTMLSTYLE_PIXELHEIGHT                             DISPID_STYLE+3
#define DISPID_IHTMLSTYLE_POSTOP                                  DISPID_STYLE+4
#define DISPID_IHTMLSTYLE_POSLEFT                                 DISPID_STYLE+5
#define DISPID_IHTMLSTYLE_POSWIDTH                                DISPID_STYLE+6
#define DISPID_IHTMLSTYLE_POSHEIGHT                               DISPID_STYLE+7
#define DISPID_IHTMLSTYLE_CURSOR                                  DISPID_A_CURSOR
#define DISPID_IHTMLSTYLE_CLIP                                    DISPID_A_CLIP
#define DISPID_IHTMLSTYLE_FILTER                                  DISPID_A_FILTER
#define DISPID_IHTMLSTYLE_SETATTRIBUTE                            DISPID_HTMLOBJECT+1
#define DISPID_IHTMLSTYLE_GETATTRIBUTE                            DISPID_HTMLOBJECT+2
#define DISPID_IHTMLSTYLE_REMOVEATTRIBUTE                         DISPID_HTMLOBJECT+3
#define DISPID_IHTMLSTYLE_TOSTRING                                DISPID_STYLE+8

//    DISPIDs for interface IHTMLStyle2

#define DISPID_IHTMLSTYLE2_TABLELAYOUT                            DISPID_A_TABLELAYOUT
#define DISPID_IHTMLSTYLE2_BORDERCOLLAPSE                         DISPID_A_BORDERCOLLAPSE
#define DISPID_IHTMLSTYLE2_DIRECTION                              DISPID_A_DIRECTION
#define DISPID_IHTMLSTYLE2_BEHAVIOR                               DISPID_A_BEHAVIOR
#define DISPID_IHTMLSTYLE2_SETEXPRESSION                          DISPID_HTMLOBJECT+4
#define DISPID_IHTMLSTYLE2_GETEXPRESSION                          DISPID_HTMLOBJECT+5
#define DISPID_IHTMLSTYLE2_REMOVEEXPRESSION                       DISPID_HTMLOBJECT+6
#define DISPID_IHTMLSTYLE2_POSITION                               DISPID_A_POSITION
#define DISPID_IHTMLSTYLE2_UNICODEBIDI                            DISPID_A_UNICODEBIDI
#define DISPID_IHTMLSTYLE2_BOTTOM                                 STDPROPID_XOBJ_BOTTOM
#define DISPID_IHTMLSTYLE2_RIGHT                                  STDPROPID_XOBJ_RIGHT
#define DISPID_IHTMLSTYLE2_PIXELBOTTOM                            DISPID_STYLE+9
#define DISPID_IHTMLSTYLE2_PIXELRIGHT                             DISPID_STYLE+10
#define DISPID_IHTMLSTYLE2_POSBOTTOM                              DISPID_STYLE+11
#define DISPID_IHTMLSTYLE2_POSRIGHT                               DISPID_STYLE+12
#define DISPID_IHTMLSTYLE2_IMEMODE                                DISPID_A_IMEMODE
#define DISPID_IHTMLSTYLE2_RUBYALIGN                              DISPID_A_RUBYALIGN
#define DISPID_IHTMLSTYLE2_RUBYPOSITION                           DISPID_A_RUBYPOSITION
#define DISPID_IHTMLSTYLE2_RUBYOVERHANG                           DISPID_A_RUBYOVERHANG
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDCHAR                         DISPID_A_LAYOUTGRIDCHAR
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDLINE                         DISPID_A_LAYOUTGRIDLINE
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDMODE                         DISPID_A_LAYOUTGRIDMODE
#define DISPID_IHTMLSTYLE2_LAYOUTGRIDTYPE                         DISPID_A_LAYOUTGRIDTYPE
#define DISPID_IHTMLSTYLE2_LAYOUTGRID                             DISPID_A_LAYOUTGRID
#define DISPID_IHTMLSTYLE2_WORDBREAK                              DISPID_A_WORDBREAK
#define DISPID_IHTMLSTYLE2_LINEBREAK                              DISPID_A_LINEBREAK
#define DISPID_IHTMLSTYLE2_TEXTJUSTIFY                            DISPID_A_TEXTJUSTIFY
#define DISPID_IHTMLSTYLE2_TEXTJUSTIFYTRIM                        DISPID_A_TEXTJUSTIFYTRIM
#define DISPID_IHTMLSTYLE2_TEXTKASHIDA                            DISPID_A_TEXTKASHIDA
#define DISPID_IHTMLSTYLE2_TEXTAUTOSPACE                          DISPID_A_TEXTAUTOSPACE
#define DISPID_IHTMLSTYLE2_OVERFLOWX                              DISPID_A_OVERFLOWX
#define DISPID_IHTMLSTYLE2_OVERFLOWY                              DISPID_A_OVERFLOWY
#define DISPID_IHTMLSTYLE2_ACCELERATOR                            DISPID_A_ACCELERATOR

//    DISPIDs for interface IHTMLStyle3

#define DISPID_IHTMLSTYLE3_LAYOUTFLOW                             DISPID_A_LAYOUTFLOW
#define DISPID_IHTMLSTYLE3_ZOOM                                   DISPID_A_ZOOM
#define DISPID_IHTMLSTYLE3_WORDWRAP                               DISPID_A_WORDWRAP
#define DISPID_IHTMLSTYLE3_TEXTUNDERLINEPOSITION                  DISPID_A_TEXTUNDERLINEPOSITION
#define DISPID_IHTMLSTYLE3_SCROLLBARBASECOLOR                     DISPID_A_SCROLLBARBASECOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARFACECOLOR                     DISPID_A_SCROLLBARFACECOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBAR3DLIGHTCOLOR                  DISPID_A_SCROLLBAR3DLIGHTCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARSHADOWCOLOR                   DISPID_A_SCROLLBARSHADOWCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARHIGHLIGHTCOLOR                DISPID_A_SCROLLBARHIGHLIGHTCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARDARKSHADOWCOLOR               DISPID_A_SCROLLBARDARKSHADOWCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARARROWCOLOR                    DISPID_A_SCROLLBARARROWCOLOR
#define DISPID_IHTMLSTYLE3_SCROLLBARTRACKCOLOR                    DISPID_A_SCROLLBARTRACKCOLOR
#define DISPID_IHTMLSTYLE3_WRITINGMODE                            DISPID_A_WRITINGMODE
#define DISPID_IHTMLSTYLE3_TEXTALIGNLAST                          DISPID_A_TEXTALIGNLAST
#define DISPID_IHTMLSTYLE3_TEXTKASHIDASPACE                       DISPID_A_TEXTKASHIDASPACE

//    DISPIDs for interface IHTMLStyle4

#define DISPID_IHTMLSTYLE4_TEXTOVERFLOW                           DISPID_A_TEXTOVERFLOW
#define DISPID_IHTMLSTYLE4_MINHEIGHT                              DISPID_A_MINHEIGHT

//    DISPIDs for interface IHTMLRuleStyle

#define DISPID_IHTMLRULESTYLE_FONTFAMILY                          DISPID_A_FONTFACE
#define DISPID_IHTMLRULESTYLE_FONTSTYLE                           DISPID_A_FONTSTYLE
#define DISPID_IHTMLRULESTYLE_FONTVARIANT                         DISPID_A_FONTVARIANT
#define DISPID_IHTMLRULESTYLE_FONTWEIGHT                          DISPID_A_FONTWEIGHT
#define DISPID_IHTMLRULESTYLE_FONTSIZE                            DISPID_A_FONTSIZE
#define DISPID_IHTMLRULESTYLE_FONT                                DISPID_A_FONT
#define DISPID_IHTMLRULESTYLE_COLOR                               DISPID_A_COLOR
#define DISPID_IHTMLRULESTYLE_BACKGROUND                          DISPID_A_BACKGROUND
#define DISPID_IHTMLRULESTYLE_BACKGROUNDCOLOR                     DISPID_BACKCOLOR
#define DISPID_IHTMLRULESTYLE_BACKGROUNDIMAGE                     DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLRULESTYLE_BACKGROUNDREPEAT                    DISPID_A_BACKGROUNDREPEAT
#define DISPID_IHTMLRULESTYLE_BACKGROUNDATTACHMENT                DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLRULESTYLE_BACKGROUNDPOSITION                  DISPID_A_BACKGROUNDPOSITION
#define DISPID_IHTMLRULESTYLE_BACKGROUNDPOSITIONX                 DISPID_A_BACKGROUNDPOSX
#define DISPID_IHTMLRULESTYLE_BACKGROUNDPOSITIONY                 DISPID_A_BACKGROUNDPOSY
#define DISPID_IHTMLRULESTYLE_WORDSPACING                         DISPID_A_WORDSPACING
#define DISPID_IHTMLRULESTYLE_LETTERSPACING                       DISPID_A_LETTERSPACING
#define DISPID_IHTMLRULESTYLE_TEXTDECORATION                      DISPID_A_TEXTDECORATION
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONNONE                  DISPID_A_TEXTDECORATIONNONE
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONUNDERLINE             DISPID_A_TEXTDECORATIONUNDERLINE
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONOVERLINE              DISPID_A_TEXTDECORATIONOVERLINE
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONLINETHROUGH           DISPID_A_TEXTDECORATIONLINETHROUGH
#define DISPID_IHTMLRULESTYLE_TEXTDECORATIONBLINK                 DISPID_A_TEXTDECORATIONBLINK
#define DISPID_IHTMLRULESTYLE_VERTICALALIGN                       DISPID_A_VERTICALALIGN
#define DISPID_IHTMLRULESTYLE_TEXTTRANSFORM                       DISPID_A_TEXTTRANSFORM
#define DISPID_IHTMLRULESTYLE_TEXTALIGN                           STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLRULESTYLE_TEXTINDENT                          DISPID_A_TEXTINDENT
#define DISPID_IHTMLRULESTYLE_LINEHEIGHT                          DISPID_A_LINEHEIGHT
#define DISPID_IHTMLRULESTYLE_MARGINTOP                           DISPID_A_MARGINTOP
#define DISPID_IHTMLRULESTYLE_MARGINRIGHT                         DISPID_A_MARGINRIGHT
#define DISPID_IHTMLRULESTYLE_MARGINBOTTOM                        DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLRULESTYLE_MARGINLEFT                          DISPID_A_MARGINLEFT
#define DISPID_IHTMLRULESTYLE_MARGIN                              DISPID_A_MARGIN
#define DISPID_IHTMLRULESTYLE_PADDINGTOP                          DISPID_A_PADDINGTOP
#define DISPID_IHTMLRULESTYLE_PADDINGRIGHT                        DISPID_A_PADDINGRIGHT
#define DISPID_IHTMLRULESTYLE_PADDINGBOTTOM                       DISPID_A_PADDINGBOTTOM
#define DISPID_IHTMLRULESTYLE_PADDINGLEFT                         DISPID_A_PADDINGLEFT
#define DISPID_IHTMLRULESTYLE_PADDING                             DISPID_A_PADDING
#define DISPID_IHTMLRULESTYLE_BORDER                              DISPID_A_BORDER
#define DISPID_IHTMLRULESTYLE_BORDERTOP                           DISPID_A_BORDERTOP
#define DISPID_IHTMLRULESTYLE_BORDERRIGHT                         DISPID_A_BORDERRIGHT
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOM                        DISPID_A_BORDERBOTTOM
#define DISPID_IHTMLRULESTYLE_BORDERLEFT                          DISPID_A_BORDERLEFT
#define DISPID_IHTMLRULESTYLE_BORDERCOLOR                         DISPID_A_BORDERCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERTOPCOLOR                      DISPID_A_BORDERTOPCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERRIGHTCOLOR                    DISPID_A_BORDERRIGHTCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOMCOLOR                   DISPID_A_BORDERBOTTOMCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERLEFTCOLOR                     DISPID_A_BORDERLEFTCOLOR
#define DISPID_IHTMLRULESTYLE_BORDERWIDTH                         DISPID_A_BORDERWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERTOPWIDTH                      DISPID_A_BORDERTOPWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERRIGHTWIDTH                    DISPID_A_BORDERRIGHTWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOMWIDTH                   DISPID_A_BORDERBOTTOMWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERLEFTWIDTH                     DISPID_A_BORDERLEFTWIDTH
#define DISPID_IHTMLRULESTYLE_BORDERSTYLE                         DISPID_A_BORDERSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERTOPSTYLE                      DISPID_A_BORDERTOPSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERRIGHTSTYLE                    DISPID_A_BORDERRIGHTSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERBOTTOMSTYLE                   DISPID_A_BORDERBOTTOMSTYLE
#define DISPID_IHTMLRULESTYLE_BORDERLEFTSTYLE                     DISPID_A_BORDERLEFTSTYLE
#define DISPID_IHTMLRULESTYLE_WIDTH                               STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLRULESTYLE_HEIGHT                              STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLRULESTYLE_STYLEFLOAT                          DISPID_A_FLOAT
#define DISPID_IHTMLRULESTYLE_CLEAR                               DISPID_A_CLEAR
#define DISPID_IHTMLRULESTYLE_DISPLAY                             DISPID_A_DISPLAY
#define DISPID_IHTMLRULESTYLE_VISIBILITY                          DISPID_A_VISIBILITY
#define DISPID_IHTMLRULESTYLE_LISTSTYLETYPE                       DISPID_A_LISTSTYLETYPE
#define DISPID_IHTMLRULESTYLE_LISTSTYLEPOSITION                   DISPID_A_LISTSTYLEPOSITION
#define DISPID_IHTMLRULESTYLE_LISTSTYLEIMAGE                      DISPID_A_LISTSTYLEIMAGE
#define DISPID_IHTMLRULESTYLE_LISTSTYLE                           DISPID_A_LISTSTYLE
#define DISPID_IHTMLRULESTYLE_WHITESPACE                          DISPID_A_WHITESPACE
#define DISPID_IHTMLRULESTYLE_TOP                                 STDPROPID_XOBJ_TOP
#define DISPID_IHTMLRULESTYLE_LEFT                                STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLRULESTYLE_POSITION                            DISPID_A_POSITION
#define DISPID_IHTMLRULESTYLE_ZINDEX                              DISPID_A_ZINDEX
#define DISPID_IHTMLRULESTYLE_OVERFLOW                            DISPID_A_OVERFLOW
#define DISPID_IHTMLRULESTYLE_PAGEBREAKBEFORE                     DISPID_A_PAGEBREAKBEFORE
#define DISPID_IHTMLRULESTYLE_PAGEBREAKAFTER                      DISPID_A_PAGEBREAKAFTER
#define DISPID_IHTMLRULESTYLE_CSSTEXT                             DISPID_A_STYLETEXT
#define DISPID_IHTMLRULESTYLE_CURSOR                              DISPID_A_CURSOR
#define DISPID_IHTMLRULESTYLE_CLIP                                DISPID_A_CLIP
#define DISPID_IHTMLRULESTYLE_FILTER                              DISPID_A_FILTER
#define DISPID_IHTMLRULESTYLE_SETATTRIBUTE                        DISPID_HTMLOBJECT+1
#define DISPID_IHTMLRULESTYLE_GETATTRIBUTE                        DISPID_HTMLOBJECT+2
#define DISPID_IHTMLRULESTYLE_REMOVEATTRIBUTE                     DISPID_HTMLOBJECT+3

//    DISPIDs for interface IHTMLRuleStyle2

#define DISPID_IHTMLRULESTYLE2_TABLELAYOUT                        DISPID_A_TABLELAYOUT
#define DISPID_IHTMLRULESTYLE2_BORDERCOLLAPSE                     DISPID_A_BORDERCOLLAPSE
#define DISPID_IHTMLRULESTYLE2_DIRECTION                          DISPID_A_DIRECTION
#define DISPID_IHTMLRULESTYLE2_BEHAVIOR                           DISPID_A_BEHAVIOR
#define DISPID_IHTMLRULESTYLE2_POSITION                           DISPID_A_POSITION
#define DISPID_IHTMLRULESTYLE2_UNICODEBIDI                        DISPID_A_UNICODEBIDI
#define DISPID_IHTMLRULESTYLE2_BOTTOM                             STDPROPID_XOBJ_BOTTOM
#define DISPID_IHTMLRULESTYLE2_RIGHT                              STDPROPID_XOBJ_RIGHT
#define DISPID_IHTMLRULESTYLE2_PIXELBOTTOM                        DISPID_STYLE+9
#define DISPID_IHTMLRULESTYLE2_PIXELRIGHT                         DISPID_STYLE+10
#define DISPID_IHTMLRULESTYLE2_POSBOTTOM                          DISPID_STYLE+11
#define DISPID_IHTMLRULESTYLE2_POSRIGHT                           DISPID_STYLE+12
#define DISPID_IHTMLRULESTYLE2_IMEMODE                            DISPID_A_IMEMODE
#define DISPID_IHTMLRULESTYLE2_RUBYALIGN                          DISPID_A_RUBYALIGN
#define DISPID_IHTMLRULESTYLE2_RUBYPOSITION                       DISPID_A_RUBYPOSITION
#define DISPID_IHTMLRULESTYLE2_RUBYOVERHANG                       DISPID_A_RUBYOVERHANG
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDCHAR                     DISPID_A_LAYOUTGRIDCHAR
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDLINE                     DISPID_A_LAYOUTGRIDLINE
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDMODE                     DISPID_A_LAYOUTGRIDMODE
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRIDTYPE                     DISPID_A_LAYOUTGRIDTYPE
#define DISPID_IHTMLRULESTYLE2_LAYOUTGRID                         DISPID_A_LAYOUTGRID
#define DISPID_IHTMLRULESTYLE2_TEXTAUTOSPACE                      DISPID_A_TEXTAUTOSPACE
#define DISPID_IHTMLRULESTYLE2_WORDBREAK                          DISPID_A_WORDBREAK
#define DISPID_IHTMLRULESTYLE2_LINEBREAK                          DISPID_A_LINEBREAK
#define DISPID_IHTMLRULESTYLE2_TEXTJUSTIFY                        DISPID_A_TEXTJUSTIFY
#define DISPID_IHTMLRULESTYLE2_TEXTJUSTIFYTRIM                    DISPID_A_TEXTJUSTIFYTRIM
#define DISPID_IHTMLRULESTYLE2_TEXTKASHIDA                        DISPID_A_TEXTKASHIDA
#define DISPID_IHTMLRULESTYLE2_OVERFLOWX                          DISPID_A_OVERFLOWX
#define DISPID_IHTMLRULESTYLE2_OVERFLOWY                          DISPID_A_OVERFLOWY
#define DISPID_IHTMLRULESTYLE2_ACCELERATOR                        DISPID_A_ACCELERATOR

//    DISPIDs for interface IHTMLRuleStyle3

#define DISPID_IHTMLRULESTYLE3_LAYOUTFLOW                         DISPID_A_LAYOUTFLOW
#define DISPID_IHTMLRULESTYLE3_ZOOM                               DISPID_A_ZOOM
#define DISPID_IHTMLRULESTYLE3_WORDWRAP                           DISPID_A_WORDWRAP
#define DISPID_IHTMLRULESTYLE3_TEXTUNDERLINEPOSITION              DISPID_A_TEXTUNDERLINEPOSITION
#define DISPID_IHTMLRULESTYLE3_SCROLLBARBASECOLOR                 DISPID_A_SCROLLBARBASECOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARFACECOLOR                 DISPID_A_SCROLLBARFACECOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBAR3DLIGHTCOLOR              DISPID_A_SCROLLBAR3DLIGHTCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARSHADOWCOLOR               DISPID_A_SCROLLBARSHADOWCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARHIGHLIGHTCOLOR            DISPID_A_SCROLLBARHIGHLIGHTCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARDARKSHADOWCOLOR           DISPID_A_SCROLLBARDARKSHADOWCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARARROWCOLOR                DISPID_A_SCROLLBARARROWCOLOR
#define DISPID_IHTMLRULESTYLE3_SCROLLBARTRACKCOLOR                DISPID_A_SCROLLBARTRACKCOLOR
#define DISPID_IHTMLRULESTYLE3_WRITINGMODE                        DISPID_A_WRITINGMODE
#define DISPID_IHTMLRULESTYLE3_TEXTALIGNLAST                      DISPID_A_TEXTALIGNLAST
#define DISPID_IHTMLRULESTYLE3_TEXTKASHIDASPACE                   DISPID_A_TEXTKASHIDASPACE

//    DISPIDs for interface IHTMLRuleStyle4

#define DISPID_IHTMLRULESTYLE4_TEXTOVERFLOW                       DISPID_A_TEXTOVERFLOW
#define DISPID_IHTMLRULESTYLE4_MINHEIGHT                          DISPID_A_MINHEIGHT

//    DISPIDs for interface IHTMLRenderStyle

#define DISPID_IHTMLRENDERSTYLE_TEXTLINETHROUGHSTYLE              DISPID_A_TEXTLINETHROUGHSTYLE
#define DISPID_IHTMLRENDERSTYLE_TEXTUNDERLINESTYLE                DISPID_A_TEXTUNDERLINESTYLE
#define DISPID_IHTMLRENDERSTYLE_TEXTEFFECT                        DISPID_A_TEXTEFFECT
#define DISPID_IHTMLRENDERSTYLE_TEXTCOLOR                         DISPID_A_TEXTCOLOR
#define DISPID_IHTMLRENDERSTYLE_TEXTBACKGROUNDCOLOR               DISPID_A_TEXTBACKGROUNDCOLOR
#define DISPID_IHTMLRENDERSTYLE_TEXTDECORATIONCOLOR               DISPID_A_TEXTDECORATIONCOLOR
#define DISPID_IHTMLRENDERSTYLE_RENDERINGPRIORITY                 DISPID_A_RENDERINGPRIORITY
#define DISPID_IHTMLRENDERSTYLE_DEFAULTTEXTSELECTION              DISPID_A_DEFAULTTEXTSELECTION
#define DISPID_IHTMLRENDERSTYLE_TEXTDECORATION                    DISPID_A_STYLETEXTDECORATION

//    DISPIDs for interface IHTMLCurrentStyle

#define DISPID_IHTMLCURRENTSTYLE_POSITION                         DISPID_A_POSITION
#define DISPID_IHTMLCURRENTSTYLE_STYLEFLOAT                       DISPID_A_FLOAT
#define DISPID_IHTMLCURRENTSTYLE_COLOR                            DISPID_A_COLOR
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDCOLOR                  DISPID_BACKCOLOR
#define DISPID_IHTMLCURRENTSTYLE_FONTFAMILY                       DISPID_A_FONTFACE
#define DISPID_IHTMLCURRENTSTYLE_FONTSTYLE                        DISPID_A_FONTSTYLE
#define DISPID_IHTMLCURRENTSTYLE_FONTVARIANT                      DISPID_A_FONTVARIANT
#define DISPID_IHTMLCURRENTSTYLE_FONTWEIGHT                       DISPID_A_FONTWEIGHT
#define DISPID_IHTMLCURRENTSTYLE_FONTSIZE                         DISPID_A_FONTSIZE
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDIMAGE                  DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDPOSITIONX              DISPID_A_BACKGROUNDPOSX
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDPOSITIONY              DISPID_A_BACKGROUNDPOSY
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDREPEAT                 DISPID_A_BACKGROUNDREPEAT
#define DISPID_IHTMLCURRENTSTYLE_BORDERLEFTCOLOR                  DISPID_A_BORDERLEFTCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERTOPCOLOR                   DISPID_A_BORDERTOPCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERRIGHTCOLOR                 DISPID_A_BORDERRIGHTCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERBOTTOMCOLOR                DISPID_A_BORDERBOTTOMCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERTOPSTYLE                   DISPID_A_BORDERTOPSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERRIGHTSTYLE                 DISPID_A_BORDERRIGHTSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERBOTTOMSTYLE                DISPID_A_BORDERBOTTOMSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERLEFTSTYLE                  DISPID_A_BORDERLEFTSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERTOPWIDTH                   DISPID_A_BORDERTOPWIDTH
#define DISPID_IHTMLCURRENTSTYLE_BORDERRIGHTWIDTH                 DISPID_A_BORDERRIGHTWIDTH
#define DISPID_IHTMLCURRENTSTYLE_BORDERBOTTOMWIDTH                DISPID_A_BORDERBOTTOMWIDTH
#define DISPID_IHTMLCURRENTSTYLE_BORDERLEFTWIDTH                  DISPID_A_BORDERLEFTWIDTH
#define DISPID_IHTMLCURRENTSTYLE_LEFT                             STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLCURRENTSTYLE_TOP                              STDPROPID_XOBJ_TOP
#define DISPID_IHTMLCURRENTSTYLE_WIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLCURRENTSTYLE_HEIGHT                           STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLCURRENTSTYLE_PADDINGLEFT                      DISPID_A_PADDINGLEFT
#define DISPID_IHTMLCURRENTSTYLE_PADDINGTOP                       DISPID_A_PADDINGTOP
#define DISPID_IHTMLCURRENTSTYLE_PADDINGRIGHT                     DISPID_A_PADDINGRIGHT
#define DISPID_IHTMLCURRENTSTYLE_PADDINGBOTTOM                    DISPID_A_PADDINGBOTTOM
#define DISPID_IHTMLCURRENTSTYLE_TEXTALIGN                        STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLCURRENTSTYLE_TEXTDECORATION                   DISPID_A_TEXTDECORATION
#define DISPID_IHTMLCURRENTSTYLE_DISPLAY                          DISPID_A_DISPLAY
#define DISPID_IHTMLCURRENTSTYLE_VISIBILITY                       DISPID_A_VISIBILITY
#define DISPID_IHTMLCURRENTSTYLE_ZINDEX                           DISPID_A_ZINDEX
#define DISPID_IHTMLCURRENTSTYLE_LETTERSPACING                    DISPID_A_LETTERSPACING
#define DISPID_IHTMLCURRENTSTYLE_LINEHEIGHT                       DISPID_A_LINEHEIGHT
#define DISPID_IHTMLCURRENTSTYLE_TEXTINDENT                       DISPID_A_TEXTINDENT
#define DISPID_IHTMLCURRENTSTYLE_VERTICALALIGN                    DISPID_A_VERTICALALIGN
#define DISPID_IHTMLCURRENTSTYLE_BACKGROUNDATTACHMENT             DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLCURRENTSTYLE_MARGINTOP                        DISPID_A_MARGINTOP
#define DISPID_IHTMLCURRENTSTYLE_MARGINRIGHT                      DISPID_A_MARGINRIGHT
#define DISPID_IHTMLCURRENTSTYLE_MARGINBOTTOM                     DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLCURRENTSTYLE_MARGINLEFT                       DISPID_A_MARGINLEFT
#define DISPID_IHTMLCURRENTSTYLE_CLEAR                            DISPID_A_CLEAR
#define DISPID_IHTMLCURRENTSTYLE_LISTSTYLETYPE                    DISPID_A_LISTSTYLETYPE
#define DISPID_IHTMLCURRENTSTYLE_LISTSTYLEPOSITION                DISPID_A_LISTSTYLEPOSITION
#define DISPID_IHTMLCURRENTSTYLE_LISTSTYLEIMAGE                   DISPID_A_LISTSTYLEIMAGE
#define DISPID_IHTMLCURRENTSTYLE_CLIPTOP                          DISPID_A_CLIPRECTTOP
#define DISPID_IHTMLCURRENTSTYLE_CLIPRIGHT                        DISPID_A_CLIPRECTRIGHT
#define DISPID_IHTMLCURRENTSTYLE_CLIPBOTTOM                       DISPID_A_CLIPRECTBOTTOM
#define DISPID_IHTMLCURRENTSTYLE_CLIPLEFT                         DISPID_A_CLIPRECTLEFT
#define DISPID_IHTMLCURRENTSTYLE_OVERFLOW                         DISPID_A_OVERFLOW
#define DISPID_IHTMLCURRENTSTYLE_PAGEBREAKBEFORE                  DISPID_A_PAGEBREAKBEFORE
#define DISPID_IHTMLCURRENTSTYLE_PAGEBREAKAFTER                   DISPID_A_PAGEBREAKAFTER
#define DISPID_IHTMLCURRENTSTYLE_CURSOR                           DISPID_A_CURSOR
#define DISPID_IHTMLCURRENTSTYLE_TABLELAYOUT                      DISPID_A_TABLELAYOUT
#define DISPID_IHTMLCURRENTSTYLE_BORDERCOLLAPSE                   DISPID_A_BORDERCOLLAPSE
#define DISPID_IHTMLCURRENTSTYLE_DIRECTION                        DISPID_A_DIRECTION
#define DISPID_IHTMLCURRENTSTYLE_BEHAVIOR                         DISPID_A_BEHAVIOR
#define DISPID_IHTMLCURRENTSTYLE_GETATTRIBUTE                     DISPID_HTMLOBJECT+2
#define DISPID_IHTMLCURRENTSTYLE_UNICODEBIDI                      DISPID_A_UNICODEBIDI
#define DISPID_IHTMLCURRENTSTYLE_RIGHT                            STDPROPID_XOBJ_RIGHT
#define DISPID_IHTMLCURRENTSTYLE_BOTTOM                           STDPROPID_XOBJ_BOTTOM
#define DISPID_IHTMLCURRENTSTYLE_IMEMODE                          DISPID_A_IMEMODE
#define DISPID_IHTMLCURRENTSTYLE_RUBYALIGN                        DISPID_A_RUBYALIGN
#define DISPID_IHTMLCURRENTSTYLE_RUBYPOSITION                     DISPID_A_RUBYPOSITION
#define DISPID_IHTMLCURRENTSTYLE_RUBYOVERHANG                     DISPID_A_RUBYOVERHANG
#define DISPID_IHTMLCURRENTSTYLE_TEXTAUTOSPACE                    DISPID_A_TEXTAUTOSPACE
#define DISPID_IHTMLCURRENTSTYLE_LINEBREAK                        DISPID_A_LINEBREAK
#define DISPID_IHTMLCURRENTSTYLE_WORDBREAK                        DISPID_A_WORDBREAK
#define DISPID_IHTMLCURRENTSTYLE_TEXTJUSTIFY                      DISPID_A_TEXTJUSTIFY
#define DISPID_IHTMLCURRENTSTYLE_TEXTJUSTIFYTRIM                  DISPID_A_TEXTJUSTIFYTRIM
#define DISPID_IHTMLCURRENTSTYLE_TEXTKASHIDA                      DISPID_A_TEXTKASHIDA
#define DISPID_IHTMLCURRENTSTYLE_BLOCKDIRECTION                   DISPID_A_DIR
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDCHAR                   DISPID_A_LAYOUTGRIDCHAR
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDLINE                   DISPID_A_LAYOUTGRIDLINE
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDMODE                   DISPID_A_LAYOUTGRIDMODE
#define DISPID_IHTMLCURRENTSTYLE_LAYOUTGRIDTYPE                   DISPID_A_LAYOUTGRIDTYPE
#define DISPID_IHTMLCURRENTSTYLE_BORDERSTYLE                      DISPID_A_BORDERSTYLE
#define DISPID_IHTMLCURRENTSTYLE_BORDERCOLOR                      DISPID_A_BORDERCOLOR
#define DISPID_IHTMLCURRENTSTYLE_BORDERWIDTH                      DISPID_A_BORDERWIDTH
#define DISPID_IHTMLCURRENTSTYLE_PADDING                          DISPID_A_PADDING
#define DISPID_IHTMLCURRENTSTYLE_MARGIN                           DISPID_A_MARGIN
#define DISPID_IHTMLCURRENTSTYLE_ACCELERATOR                      DISPID_A_ACCELERATOR
#define DISPID_IHTMLCURRENTSTYLE_OVERFLOWX                        DISPID_A_OVERFLOWX
#define DISPID_IHTMLCURRENTSTYLE_OVERFLOWY                        DISPID_A_OVERFLOWY
#define DISPID_IHTMLCURRENTSTYLE_TEXTTRANSFORM                    DISPID_A_TEXTTRANSFORM

//    DISPIDs for interface IHTMLCurrentStyle2

#define DISPID_IHTMLCURRENTSTYLE2_LAYOUTFLOW                      DISPID_A_LAYOUTFLOW
#define DISPID_IHTMLCURRENTSTYLE2_WORDWRAP                        DISPID_A_WORDWRAP
#define DISPID_IHTMLCURRENTSTYLE2_TEXTUNDERLINEPOSITION           DISPID_A_TEXTUNDERLINEPOSITION
#define DISPID_IHTMLCURRENTSTYLE2_HASLAYOUT                       DISPID_A_HASLAYOUT
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARBASECOLOR              DISPID_A_SCROLLBARBASECOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARFACECOLOR              DISPID_A_SCROLLBARFACECOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBAR3DLIGHTCOLOR           DISPID_A_SCROLLBAR3DLIGHTCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARSHADOWCOLOR            DISPID_A_SCROLLBARSHADOWCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARHIGHLIGHTCOLOR         DISPID_A_SCROLLBARHIGHLIGHTCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARDARKSHADOWCOLOR        DISPID_A_SCROLLBARDARKSHADOWCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARARROWCOLOR             DISPID_A_SCROLLBARARROWCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_SCROLLBARTRACKCOLOR             DISPID_A_SCROLLBARTRACKCOLOR
#define DISPID_IHTMLCURRENTSTYLE2_WRITINGMODE                     DISPID_A_WRITINGMODE
#define DISPID_IHTMLCURRENTSTYLE2_ZOOM                            DISPID_A_ZOOM
#define DISPID_IHTMLCURRENTSTYLE2_FILTER                          DISPID_A_FILTER
#define DISPID_IHTMLCURRENTSTYLE2_TEXTALIGNLAST                   DISPID_A_TEXTALIGNLAST
#define DISPID_IHTMLCURRENTSTYLE2_TEXTKASHIDASPACE                DISPID_A_TEXTKASHIDASPACE
#define DISPID_IHTMLCURRENTSTYLE2_ISBLOCK                         DISPID_A_ISBLOCK

//    DISPIDs for interface IHTMLCurrentStyle3

#define DISPID_IHTMLCURRENTSTYLE3_TEXTOVERFLOW                    DISPID_A_TEXTOVERFLOW
#define DISPID_IHTMLCURRENTSTYLE3_MINHEIGHT                       DISPID_A_MINHEIGHT
#define DISPID_IHTMLCURRENTSTYLE3_WORDSPACING                     DISPID_A_WORDSPACING
#define DISPID_IHTMLCURRENTSTYLE3_WHITESPACE                      DISPID_A_WHITESPACE

//    DISPIDs for interface IHTMLRect

#define DISPID_IHTMLRECT_LEFT                                     DISPID_OMRECT+1
#define DISPID_IHTMLRECT_TOP                                      DISPID_OMRECT+2
#define DISPID_IHTMLRECT_RIGHT                                    DISPID_OMRECT+3
#define DISPID_IHTMLRECT_BOTTOM                                   DISPID_OMRECT+4

//    DISPIDs for interface IHTMLRectCollection

#define DISPID_IHTMLRECTCOLLECTION_LENGTH                         DISPID_COLLECTION
#define DISPID_IHTMLRECTCOLLECTION__NEWENUM                       DISPID_NEWENUM
#define DISPID_IHTMLRECTCOLLECTION_ITEM                           DISPID_VALUE

//    DISPIDs for interface IHTMLDOMNode

#define DISPID_IHTMLDOMNODE_NODETYPE                              DISPID_ELEMENT+46
#define DISPID_IHTMLDOMNODE_PARENTNODE                            DISPID_ELEMENT+47
#define DISPID_IHTMLDOMNODE_HASCHILDNODES                         DISPID_ELEMENT+48
#define DISPID_IHTMLDOMNODE_CHILDNODES                            DISPID_ELEMENT+49
#define DISPID_IHTMLDOMNODE_ATTRIBUTES                            DISPID_ELEMENT+50
#define DISPID_IHTMLDOMNODE_INSERTBEFORE                          DISPID_ELEMENT+51
#define DISPID_IHTMLDOMNODE_REMOVECHILD                           DISPID_ELEMENT+52
#define DISPID_IHTMLDOMNODE_REPLACECHILD                          DISPID_ELEMENT+53
#define DISPID_IHTMLDOMNODE_CLONENODE                             DISPID_ELEMENT+61
#define DISPID_IHTMLDOMNODE_REMOVENODE                            DISPID_ELEMENT+66
#define DISPID_IHTMLDOMNODE_SWAPNODE                              DISPID_ELEMENT+68
#define DISPID_IHTMLDOMNODE_REPLACENODE                           DISPID_ELEMENT+67
#define DISPID_IHTMLDOMNODE_APPENDCHILD                           DISPID_ELEMENT+73
#define DISPID_IHTMLDOMNODE_NODENAME                              DISPID_ELEMENT+74
#define DISPID_IHTMLDOMNODE_NODEVALUE                             DISPID_ELEMENT+75
#define DISPID_IHTMLDOMNODE_FIRSTCHILD                            DISPID_ELEMENT+76
#define DISPID_IHTMLDOMNODE_LASTCHILD                             DISPID_ELEMENT+77
#define DISPID_IHTMLDOMNODE_PREVIOUSSIBLING                       DISPID_ELEMENT+78
#define DISPID_IHTMLDOMNODE_NEXTSIBLING                           DISPID_ELEMENT+79

//    DISPIDs for interface IHTMLDOMNode2

#define DISPID_IHTMLDOMNODE2_OWNERDOCUMENT                        DISPID_ELEMENT+113

//    DISPIDs for interface IHTMLDOMAttribute

#define DISPID_IHTMLDOMATTRIBUTE_NODENAME                         DISPID_DOMATTRIBUTE
#define DISPID_IHTMLDOMATTRIBUTE_NODEVALUE                        DISPID_DOMATTRIBUTE+2
#define DISPID_IHTMLDOMATTRIBUTE_SPECIFIED                        DISPID_DOMATTRIBUTE+1

//    DISPIDs for interface IHTMLDOMAttribute2

#define DISPID_IHTMLDOMATTRIBUTE2_NAME                            DISPID_DOMATTRIBUTE+3
#define DISPID_IHTMLDOMATTRIBUTE2_VALUE                           DISPID_DOMATTRIBUTE+4
#define DISPID_IHTMLDOMATTRIBUTE2_EXPANDO                         DISPID_DOMATTRIBUTE+5
#define DISPID_IHTMLDOMATTRIBUTE2_NODETYPE                        DISPID_DOMATTRIBUTE+6
#define DISPID_IHTMLDOMATTRIBUTE2_PARENTNODE                      DISPID_DOMATTRIBUTE+7
#define DISPID_IHTMLDOMATTRIBUTE2_CHILDNODES                      DISPID_DOMATTRIBUTE+8
#define DISPID_IHTMLDOMATTRIBUTE2_FIRSTCHILD                      DISPID_DOMATTRIBUTE+9
#define DISPID_IHTMLDOMATTRIBUTE2_LASTCHILD                       DISPID_DOMATTRIBUTE+10
#define DISPID_IHTMLDOMATTRIBUTE2_PREVIOUSSIBLING                 DISPID_DOMATTRIBUTE+11
#define DISPID_IHTMLDOMATTRIBUTE2_NEXTSIBLING                     DISPID_DOMATTRIBUTE+12
#define DISPID_IHTMLDOMATTRIBUTE2_ATTRIBUTES                      DISPID_DOMATTRIBUTE+13
#define DISPID_IHTMLDOMATTRIBUTE2_OWNERDOCUMENT                   DISPID_DOMATTRIBUTE+14
#define DISPID_IHTMLDOMATTRIBUTE2_INSERTBEFORE                    DISPID_DOMATTRIBUTE+15
#define DISPID_IHTMLDOMATTRIBUTE2_REPLACECHILD                    DISPID_DOMATTRIBUTE+16
#define DISPID_IHTMLDOMATTRIBUTE2_REMOVECHILD                     DISPID_DOMATTRIBUTE+17
#define DISPID_IHTMLDOMATTRIBUTE2_APPENDCHILD                     DISPID_DOMATTRIBUTE+18
#define DISPID_IHTMLDOMATTRIBUTE2_HASCHILDNODES                   DISPID_DOMATTRIBUTE+19
#define DISPID_IHTMLDOMATTRIBUTE2_CLONENODE                       DISPID_DOMATTRIBUTE+20

//    DISPIDs for interface IHTMLDOMTextNode

#define DISPID_IHTMLDOMTEXTNODE_DATA                              DISPID_DOMTEXTNODE
#define DISPID_IHTMLDOMTEXTNODE_TOSTRING                          DISPID_DOMTEXTNODE+1
#define DISPID_IHTMLDOMTEXTNODE_LENGTH                            DISPID_DOMTEXTNODE+2
#define DISPID_IHTMLDOMTEXTNODE_SPLITTEXT                         DISPID_DOMTEXTNODE+3

//    DISPIDs for interface IHTMLDOMTextNode2

#define DISPID_IHTMLDOMTEXTNODE2_SUBSTRINGDATA                    DISPID_DOMTEXTNODE+4
#define DISPID_IHTMLDOMTEXTNODE2_APPENDDATA                       DISPID_DOMTEXTNODE+5
#define DISPID_IHTMLDOMTEXTNODE2_INSERTDATA                       DISPID_DOMTEXTNODE+6
#define DISPID_IHTMLDOMTEXTNODE2_DELETEDATA                       DISPID_DOMTEXTNODE+7
#define DISPID_IHTMLDOMTEXTNODE2_REPLACEDATA                      DISPID_DOMTEXTNODE+8

//    DISPIDs for interface IHTMLDOMImplementation

#define DISPID_IHTMLDOMIMPLEMENTATION_HASFEATURE                  DISPID_DOMIMPLEMENTATION

//    DISPIDs for interface IHTMLAttributeCollection

#define DISPID_IHTMLATTRIBUTECOLLECTION_LENGTH                    DISPID_COLLECTION
#define DISPID_IHTMLATTRIBUTECOLLECTION__NEWENUM                  DISPID_NEWENUM
#define DISPID_IHTMLATTRIBUTECOLLECTION_ITEM                      DISPID_VALUE

//    DISPIDs for interface IHTMLAttributeCollection2

#define DISPID_IHTMLATTRIBUTECOLLECTION2_GETNAMEDITEM             DISPID_COLLECTION+1
#define DISPID_IHTMLATTRIBUTECOLLECTION2_SETNAMEDITEM             DISPID_COLLECTION+2
#define DISPID_IHTMLATTRIBUTECOLLECTION2_REMOVENAMEDITEM          DISPID_COLLECTION+3

//    DISPIDs for interface IHTMLDOMChildrenCollection

#define DISPID_IHTMLDOMCHILDRENCOLLECTION_LENGTH                  DISPID_COLLECTION
#define DISPID_IHTMLDOMCHILDRENCOLLECTION__NEWENUM                DISPID_NEWENUM
#define DISPID_IHTMLDOMCHILDRENCOLLECTION_ITEM                    DISPID_VALUE

//    DISPIDs for interface IHTMLElement

#define DISPID_IHTMLELEMENT_SETATTRIBUTE                          DISPID_HTMLOBJECT+1
#define DISPID_IHTMLELEMENT_GETATTRIBUTE                          DISPID_HTMLOBJECT+2
#define DISPID_IHTMLELEMENT_REMOVEATTRIBUTE                       DISPID_HTMLOBJECT+3
#define DISPID_IHTMLELEMENT_CLASSNAME                             DISPID_ELEMENT+1
#define DISPID_IHTMLELEMENT_ID                                    DISPID_ELEMENT+2
#define DISPID_IHTMLELEMENT_TAGNAME                               DISPID_ELEMENT+4
#define DISPID_IHTMLELEMENT_PARENTELEMENT                         STDPROPID_XOBJ_PARENT
#define DISPID_IHTMLELEMENT_STYLE                                 STDPROPID_XOBJ_STYLE
#define DISPID_IHTMLELEMENT_ONHELP                                DISPID_EVPROP_ONHELP
#define DISPID_IHTMLELEMENT_ONCLICK                               DISPID_EVPROP_ONCLICK
#define DISPID_IHTMLELEMENT_ONDBLCLICK                            DISPID_EVPROP_ONDBLCLICK
#define DISPID_IHTMLELEMENT_ONKEYDOWN                             DISPID_EVPROP_ONKEYDOWN
#define DISPID_IHTMLELEMENT_ONKEYUP                               DISPID_EVPROP_ONKEYUP
#define DISPID_IHTMLELEMENT_ONKEYPRESS                            DISPID_EVPROP_ONKEYPRESS
#define DISPID_IHTMLELEMENT_ONMOUSEOUT                            DISPID_EVPROP_ONMOUSEOUT
#define DISPID_IHTMLELEMENT_ONMOUSEOVER                           DISPID_EVPROP_ONMOUSEOVER
#define DISPID_IHTMLELEMENT_ONMOUSEMOVE                           DISPID_EVPROP_ONMOUSEMOVE
#define DISPID_IHTMLELEMENT_ONMOUSEDOWN                           DISPID_EVPROP_ONMOUSEDOWN
#define DISPID_IHTMLELEMENT_ONMOUSEUP                             DISPID_EVPROP_ONMOUSEUP
#define DISPID_IHTMLELEMENT_DOCUMENT                              DISPID_ELEMENT+18
#define DISPID_IHTMLELEMENT_TITLE                                 STDPROPID_XOBJ_CONTROLTIPTEXT
#define DISPID_IHTMLELEMENT_LANGUAGE                              DISPID_A_LANGUAGE
#define DISPID_IHTMLELEMENT_ONSELECTSTART                         DISPID_EVPROP_ONSELECTSTART
#define DISPID_IHTMLELEMENT_SCROLLINTOVIEW                        DISPID_ELEMENT+19
#define DISPID_IHTMLELEMENT_CONTAINS                              DISPID_ELEMENT+20
#define DISPID_IHTMLELEMENT_SOURCEINDEX                           DISPID_ELEMENT+24
#define DISPID_IHTMLELEMENT_RECORDNUMBER                          DISPID_ELEMENT+25
#define DISPID_IHTMLELEMENT_LANG                                  DISPID_A_LANG
#define DISPID_IHTMLELEMENT_OFFSETLEFT                            DISPID_ELEMENT+8
#define DISPID_IHTMLELEMENT_OFFSETTOP                             DISPID_ELEMENT+9
#define DISPID_IHTMLELEMENT_OFFSETWIDTH                           DISPID_ELEMENT+10
#define DISPID_IHTMLELEMENT_OFFSETHEIGHT                          DISPID_ELEMENT+11
#define DISPID_IHTMLELEMENT_OFFSETPARENT                          DISPID_ELEMENT+12
#define DISPID_IHTMLELEMENT_INNERHTML                             DISPID_ELEMENT+26
#define DISPID_IHTMLELEMENT_INNERTEXT                             DISPID_ELEMENT+27
#define DISPID_IHTMLELEMENT_OUTERHTML                             DISPID_ELEMENT+28
#define DISPID_IHTMLELEMENT_OUTERTEXT                             DISPID_ELEMENT+29
#define DISPID_IHTMLELEMENT_INSERTADJACENTHTML                    DISPID_ELEMENT+30
#define DISPID_IHTMLELEMENT_INSERTADJACENTTEXT                    DISPID_ELEMENT+31
#define DISPID_IHTMLELEMENT_PARENTTEXTEDIT                        DISPID_ELEMENT+32
#define DISPID_IHTMLELEMENT_ISTEXTEDIT                            DISPID_ELEMENT+34
#define DISPID_IHTMLELEMENT_CLICK                                 DISPID_ELEMENT+33
#define DISPID_IHTMLELEMENT_FILTERS                               DISPID_ELEMENT+35
#define DISPID_IHTMLELEMENT_ONDRAGSTART                           DISPID_EVPROP_ONDRAGSTART
#define DISPID_IHTMLELEMENT_TOSTRING                              DISPID_ELEMENT+36
#define DISPID_IHTMLELEMENT_ONBEFOREUPDATE                        DISPID_EVPROP_ONBEFOREUPDATE
#define DISPID_IHTMLELEMENT_ONAFTERUPDATE                         DISPID_EVPROP_ONAFTERUPDATE
#define DISPID_IHTMLELEMENT_ONERRORUPDATE                         DISPID_EVPROP_ONERRORUPDATE
#define DISPID_IHTMLELEMENT_ONROWEXIT                             DISPID_EVPROP_ONROWEXIT
#define DISPID_IHTMLELEMENT_ONROWENTER                            DISPID_EVPROP_ONROWENTER
#define DISPID_IHTMLELEMENT_ONDATASETCHANGED                      DISPID_EVPROP_ONDATASETCHANGED
#define DISPID_IHTMLELEMENT_ONDATAAVAILABLE                       DISPID_EVPROP_ONDATAAVAILABLE
#define DISPID_IHTMLELEMENT_ONDATASETCOMPLETE                     DISPID_EVPROP_ONDATASETCOMPLETE
#define DISPID_IHTMLELEMENT_ONFILTERCHANGE                        DISPID_EVPROP_ONFILTER
#define DISPID_IHTMLELEMENT_CHILDREN                              DISPID_ELEMENT+37
#define DISPID_IHTMLELEMENT_ALL                                   DISPID_ELEMENT+38

//    DISPIDs for interface IHTMLElement2

#define DISPID_IHTMLELEMENT2_SCOPENAME                            DISPID_ELEMENT+39
#define DISPID_IHTMLELEMENT2_SETCAPTURE                           DISPID_ELEMENT+40
#define DISPID_IHTMLELEMENT2_RELEASECAPTURE                       DISPID_ELEMENT+41
#define DISPID_IHTMLELEMENT2_ONLOSECAPTURE                        DISPID_EVPROP_ONLOSECAPTURE
#define DISPID_IHTMLELEMENT2_COMPONENTFROMPOINT                   DISPID_ELEMENT+42
#define DISPID_IHTMLELEMENT2_DOSCROLL                             DISPID_ELEMENT+43
#define DISPID_IHTMLELEMENT2_ONSCROLL                             DISPID_EVPROP_ONSCROLL
#define DISPID_IHTMLELEMENT2_ONDRAG                               DISPID_EVPROP_ONDRAG
#define DISPID_IHTMLELEMENT2_ONDRAGEND                            DISPID_EVPROP_ONDRAGEND
#define DISPID_IHTMLELEMENT2_ONDRAGENTER                          DISPID_EVPROP_ONDRAGENTER
#define DISPID_IHTMLELEMENT2_ONDRAGOVER                           DISPID_EVPROP_ONDRAGOVER
#define DISPID_IHTMLELEMENT2_ONDRAGLEAVE                          DISPID_EVPROP_ONDRAGLEAVE
#define DISPID_IHTMLELEMENT2_ONDROP                               DISPID_EVPROP_ONDROP
#define DISPID_IHTMLELEMENT2_ONBEFORECUT                          DISPID_EVPROP_ONBEFORECUT
#define DISPID_IHTMLELEMENT2_ONCUT                                DISPID_EVPROP_ONCUT
#define DISPID_IHTMLELEMENT2_ONBEFORECOPY                         DISPID_EVPROP_ONBEFORECOPY
#define DISPID_IHTMLELEMENT2_ONCOPY                               DISPID_EVPROP_ONCOPY
#define DISPID_IHTMLELEMENT2_ONBEFOREPASTE                        DISPID_EVPROP_ONBEFOREPASTE
#define DISPID_IHTMLELEMENT2_ONPASTE                              DISPID_EVPROP_ONPASTE
#define DISPID_IHTMLELEMENT2_CURRENTSTYLE                         DISPID_ELEMENT+7
#define DISPID_IHTMLELEMENT2_ONPROPERTYCHANGE                     DISPID_EVPROP_ONPROPERTYCHANGE
#define DISPID_IHTMLELEMENT2_GETCLIENTRECTS                       DISPID_ELEMENT+44
#define DISPID_IHTMLELEMENT2_GETBOUNDINGCLIENTRECT                DISPID_ELEMENT+45
#define DISPID_IHTMLELEMENT2_SETEXPRESSION                        DISPID_HTMLOBJECT+4
#define DISPID_IHTMLELEMENT2_GETEXPRESSION                        DISPID_HTMLOBJECT+5
#define DISPID_IHTMLELEMENT2_REMOVEEXPRESSION                     DISPID_HTMLOBJECT+6
#define DISPID_IHTMLELEMENT2_TABINDEX                             STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLELEMENT2_FOCUS                                DISPID_SITE+0
#define DISPID_IHTMLELEMENT2_ACCESSKEY                            DISPID_SITE+5
#define DISPID_IHTMLELEMENT2_ONBLUR                               DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLELEMENT2_ONFOCUS                              DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLELEMENT2_ONRESIZE                             DISPID_EVPROP_ONRESIZE
#define DISPID_IHTMLELEMENT2_BLUR                                 DISPID_SITE+2
#define DISPID_IHTMLELEMENT2_ADDFILTER                            DISPID_SITE+17
#define DISPID_IHTMLELEMENT2_REMOVEFILTER                         DISPID_SITE+18
#define DISPID_IHTMLELEMENT2_CLIENTHEIGHT                         DISPID_SITE+19
#define DISPID_IHTMLELEMENT2_CLIENTWIDTH                          DISPID_SITE+20
#define DISPID_IHTMLELEMENT2_CLIENTTOP                            DISPID_SITE+21
#define DISPID_IHTMLELEMENT2_CLIENTLEFT                           DISPID_SITE+22
#define DISPID_IHTMLELEMENT2_ATTACHEVENT                          DISPID_HTMLOBJECT+7
#define DISPID_IHTMLELEMENT2_DETACHEVENT                          DISPID_HTMLOBJECT+8
#define DISPID_IHTMLELEMENT2_READYSTATE                           DISPID_A_READYSTATE
#define DISPID_IHTMLELEMENT2_ONREADYSTATECHANGE                   DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLELEMENT2_ONROWSDELETE                         DISPID_EVPROP_ONROWSDELETE
#define DISPID_IHTMLELEMENT2_ONROWSINSERTED                       DISPID_EVPROP_ONROWSINSERTED
#define DISPID_IHTMLELEMENT2_ONCELLCHANGE                         DISPID_EVPROP_ONCELLCHANGE
#define DISPID_IHTMLELEMENT2_DIR                                  DISPID_A_DIR
#define DISPID_IHTMLELEMENT2_CREATECONTROLRANGE                   DISPID_ELEMENT+56
#define DISPID_IHTMLELEMENT2_SCROLLHEIGHT                         DISPID_ELEMENT+57
#define DISPID_IHTMLELEMENT2_SCROLLWIDTH                          DISPID_ELEMENT+58
#define DISPID_IHTMLELEMENT2_SCROLLTOP                            DISPID_ELEMENT+59
#define DISPID_IHTMLELEMENT2_SCROLLLEFT                           DISPID_ELEMENT+60
#define DISPID_IHTMLELEMENT2_CLEARATTRIBUTES                      DISPID_ELEMENT+62
#define DISPID_IHTMLELEMENT2_MERGEATTRIBUTES                      DISPID_ELEMENT+63
#define DISPID_IHTMLELEMENT2_ONCONTEXTMENU                        DISPID_EVPROP_ONCONTEXTMENU
#define DISPID_IHTMLELEMENT2_INSERTADJACENTELEMENT                DISPID_ELEMENT+69
#define DISPID_IHTMLELEMENT2_APPLYELEMENT                         DISPID_ELEMENT+65
#define DISPID_IHTMLELEMENT2_GETADJACENTTEXT                      DISPID_ELEMENT+70
#define DISPID_IHTMLELEMENT2_REPLACEADJACENTTEXT                  DISPID_ELEMENT+71
#define DISPID_IHTMLELEMENT2_CANHAVECHILDREN                      DISPID_ELEMENT+72
#define DISPID_IHTMLELEMENT2_ADDBEHAVIOR                          DISPID_ELEMENT+80
#define DISPID_IHTMLELEMENT2_REMOVEBEHAVIOR                       DISPID_ELEMENT+81
#define DISPID_IHTMLELEMENT2_RUNTIMESTYLE                         DISPID_ELEMENT+64
#define DISPID_IHTMLELEMENT2_BEHAVIORURNS                         DISPID_ELEMENT+82
#define DISPID_IHTMLELEMENT2_TAGURN                               DISPID_ELEMENT+83
#define DISPID_IHTMLELEMENT2_ONBEFOREEDITFOCUS                    DISPID_EVPROP_ONBEFOREEDITFOCUS
#define DISPID_IHTMLELEMENT2_READYSTATEVALUE                      DISPID_ELEMENT+84
#define DISPID_IHTMLELEMENT2_GETELEMENTSBYTAGNAME                 DISPID_ELEMENT+85

//    DISPIDs for interface IHTMLElement3

#define DISPID_IHTMLELEMENT3_MERGEATTRIBUTES                      DISPID_ELEMENT+96
#define DISPID_IHTMLELEMENT3_ISMULTILINE                          DISPID_ELEMENT+97
#define DISPID_IHTMLELEMENT3_CANHAVEHTML                          DISPID_ELEMENT+98
#define DISPID_IHTMLELEMENT3_ONLAYOUTCOMPLETE                     DISPID_EVPROP_ONLAYOUTCOMPLETE
#define DISPID_IHTMLELEMENT3_ONPAGE                               DISPID_EVPROP_ONPAGE
#define DISPID_IHTMLELEMENT3_INFLATEBLOCK                         DISPID_ELEMENT+100
#define DISPID_IHTMLELEMENT3_ONBEFOREDEACTIVATE                   DISPID_EVPROP_ONBEFOREDEACTIVATE
#define DISPID_IHTMLELEMENT3_SETACTIVE                            DISPID_ELEMENT+101
#define DISPID_IHTMLELEMENT3_CONTENTEDITABLE                      DISPID_A_EDITABLE
#define DISPID_IHTMLELEMENT3_ISCONTENTEDITABLE                    DISPID_ELEMENT+102
#define DISPID_IHTMLELEMENT3_HIDEFOCUS                            DISPID_A_HIDEFOCUS
#define DISPID_IHTMLELEMENT3_DISABLED                             STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLELEMENT3_ISDISABLED                           DISPID_ELEMENT+105
#define DISPID_IHTMLELEMENT3_ONMOVE                               DISPID_EVPROP_ONMOVE
#define DISPID_IHTMLELEMENT3_ONCONTROLSELECT                      DISPID_EVPROP_ONCONTROLSELECT
#define DISPID_IHTMLELEMENT3_FIREEVENT                            DISPID_ELEMENT+106
#define DISPID_IHTMLELEMENT3_ONRESIZESTART                        DISPID_EVPROP_ONRESIZESTART
#define DISPID_IHTMLELEMENT3_ONRESIZEEND                          DISPID_EVPROP_ONRESIZEEND
#define DISPID_IHTMLELEMENT3_ONMOVESTART                          DISPID_EVPROP_ONMOVESTART
#define DISPID_IHTMLELEMENT3_ONMOVEEND                            DISPID_EVPROP_ONMOVEEND
#define DISPID_IHTMLELEMENT3_ONMOUSEENTER                         DISPID_EVPROP_ONMOUSEENTER
#define DISPID_IHTMLELEMENT3_ONMOUSELEAVE                         DISPID_EVPROP_ONMOUSELEAVE
#define DISPID_IHTMLELEMENT3_ONACTIVATE                           DISPID_EVPROP_ONACTIVATE
#define DISPID_IHTMLELEMENT3_ONDEACTIVATE                         DISPID_EVPROP_ONDEACTIVATE
#define DISPID_IHTMLELEMENT3_DRAGDROP                             DISPID_ELEMENT+107
#define DISPID_IHTMLELEMENT3_GLYPHMODE                            DISPID_ELEMENT+108

//    DISPIDs for interface IHTMLElement4

#define DISPID_IHTMLELEMENT4_ONMOUSEWHEEL                         DISPID_EVPROP_ONMOUSEWHEEL
#define DISPID_IHTMLELEMENT4_NORMALIZE                            DISPID_ELEMENT+112
#define DISPID_IHTMLELEMENT4_GETATTRIBUTENODE                     DISPID_ELEMENT+109
#define DISPID_IHTMLELEMENT4_SETATTRIBUTENODE                     DISPID_ELEMENT+110
#define DISPID_IHTMLELEMENT4_REMOVEATTRIBUTENODE                  DISPID_ELEMENT+111
#define DISPID_IHTMLELEMENT4_ONBEFOREACTIVATE                     DISPID_EVPROP_ONBEFOREACTIVATE
#define DISPID_IHTMLELEMENT4_ONFOCUSIN                            DISPID_EVPROP_ONFOCUSIN
#define DISPID_IHTMLELEMENT4_ONFOCUSOUT                           DISPID_EVPROP_ONFOCUSOUT

//    DISPIDs for interface IHTMLElementRender

#define DISPID_IHTMLELEMENTRENDER_DRAWTODC                        
#define DISPID_IHTMLELEMENTRENDER_SETDOCUMENTPRINTER              

//    DISPIDs for interface IHTMLUniqueName

#define DISPID_IHTMLUNIQUENAME_UNIQUENUMBER                       DISPID_ELEMENT+54
#define DISPID_IHTMLUNIQUENAME_UNIQUEID                           DISPID_ELEMENT+55

//    DISPIDs for interface IHTMLDatabinding

#define DISPID_IHTMLDATABINDING_DATAFLD                           DISPID_ELEMENT+21
#define DISPID_IHTMLDATABINDING_DATASRC                           DISPID_ELEMENT+22
#define DISPID_IHTMLDATABINDING_DATAFORMATAS                      DISPID_ELEMENT+23

//    DISPIDs for event set HTMLElementEvents2

#define DISPID_HTMLELEMENTEVENTS2_ONHELP                          DISPID_EVMETH_ONHELP
#define DISPID_HTMLELEMENTEVENTS2_ONCLICK                         DISPID_EVMETH_ONCLICK
#define DISPID_HTMLELEMENTEVENTS2_ONDBLCLICK                      DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLELEMENTEVENTS2_ONKEYPRESS                      DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLELEMENTEVENTS2_ONKEYDOWN                       DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLELEMENTEVENTS2_ONKEYUP                         DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEOUT                      DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEOVER                     DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEMOVE                     DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEDOWN                     DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEUP                       DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLELEMENTEVENTS2_ONSELECTSTART                   DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLELEMENTEVENTS2_ONFILTERCHANGE                  DISPID_EVMETH_ONFILTER
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGSTART                     DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREUPDATE                  DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLELEMENTEVENTS2_ONAFTERUPDATE                   DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLELEMENTEVENTS2_ONERRORUPDATE                   DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLELEMENTEVENTS2_ONROWEXIT                       DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLELEMENTEVENTS2_ONROWENTER                      DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLELEMENTEVENTS2_ONDATASETCHANGED                DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLELEMENTEVENTS2_ONDATAAVAILABLE                 DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLELEMENTEVENTS2_ONDATASETCOMPLETE               DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLELEMENTEVENTS2_ONLOSECAPTURE                   DISPID_EVMETH_ONLOSECAPTURE
#define DISPID_HTMLELEMENTEVENTS2_ONPROPERTYCHANGE                DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLELEMENTEVENTS2_ONSCROLL                        DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLELEMENTEVENTS2_ONFOCUS                         DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLELEMENTEVENTS2_ONBLUR                          DISPID_EVMETH_ONBLUR
#define DISPID_HTMLELEMENTEVENTS2_ONRESIZE                        DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLELEMENTEVENTS2_ONDRAG                          DISPID_EVMETH_ONDRAG
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGEND                       DISPID_EVMETH_ONDRAGEND
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGENTER                     DISPID_EVMETH_ONDRAGENTER
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGOVER                      DISPID_EVMETH_ONDRAGOVER
#define DISPID_HTMLELEMENTEVENTS2_ONDRAGLEAVE                     DISPID_EVMETH_ONDRAGLEAVE
#define DISPID_HTMLELEMENTEVENTS2_ONDROP                          DISPID_EVMETH_ONDROP
#define DISPID_HTMLELEMENTEVENTS2_ONBEFORECUT                     DISPID_EVMETH_ONBEFORECUT
#define DISPID_HTMLELEMENTEVENTS2_ONCUT                           DISPID_EVMETH_ONCUT
#define DISPID_HTMLELEMENTEVENTS2_ONBEFORECOPY                    DISPID_EVMETH_ONBEFORECOPY
#define DISPID_HTMLELEMENTEVENTS2_ONCOPY                          DISPID_EVMETH_ONCOPY
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREPASTE                   DISPID_EVMETH_ONBEFOREPASTE
#define DISPID_HTMLELEMENTEVENTS2_ONPASTE                         DISPID_EVMETH_ONPASTE
#define DISPID_HTMLELEMENTEVENTS2_ONCONTEXTMENU                   DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLELEMENTEVENTS2_ONROWSDELETE                    DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLELEMENTEVENTS2_ONROWSINSERTED                  DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLELEMENTEVENTS2_ONCELLCHANGE                    DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLELEMENTEVENTS2_ONREADYSTATECHANGE              DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLELEMENTEVENTS2_ONLAYOUTCOMPLETE                DISPID_EVMETH_ONLAYOUTCOMPLETE
#define DISPID_HTMLELEMENTEVENTS2_ONPAGE                          DISPID_EVMETH_ONPAGE
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEENTER                    DISPID_EVMETH_ONMOUSEENTER
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSELEAVE                    DISPID_EVMETH_ONMOUSELEAVE
#define DISPID_HTMLELEMENTEVENTS2_ONACTIVATE                      DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONDEACTIVATE                    DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREDEACTIVATE              DISPID_EVMETH_ONBEFOREDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONBEFOREACTIVATE                DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLELEMENTEVENTS2_ONFOCUSIN                       DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLELEMENTEVENTS2_ONFOCUSOUT                      DISPID_EVMETH_ONFOCUSOUT
#define DISPID_HTMLELEMENTEVENTS2_ONMOVE                          DISPID_EVMETH_ONMOVE
#define DISPID_HTMLELEMENTEVENTS2_ONCONTROLSELECT                 DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLELEMENTEVENTS2_ONMOVESTART                     DISPID_EVMETH_ONMOVESTART
#define DISPID_HTMLELEMENTEVENTS2_ONMOVEEND                       DISPID_EVMETH_ONMOVEEND
#define DISPID_HTMLELEMENTEVENTS2_ONRESIZESTART                   DISPID_EVMETH_ONRESIZESTART
#define DISPID_HTMLELEMENTEVENTS2_ONRESIZEEND                     DISPID_EVMETH_ONRESIZEEND
#define DISPID_HTMLELEMENTEVENTS2_ONMOUSEWHEEL                    DISPID_EVMETH_ONMOUSEWHEEL

//    DISPIDs for event set HTMLElementEvents

#define DISPID_HTMLELEMENTEVENTS_ONHELP                           DISPID_EVMETH_ONHELP
#define DISPID_HTMLELEMENTEVENTS_ONCLICK                          DISPID_EVMETH_ONCLICK
#define DISPID_HTMLELEMENTEVENTS_ONDBLCLICK                       DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLELEMENTEVENTS_ONKEYPRESS                       DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLELEMENTEVENTS_ONKEYDOWN                        DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLELEMENTEVENTS_ONKEYUP                          DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT                       DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER                      DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEMOVE                      DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN                      DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEUP                        DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLELEMENTEVENTS_ONSELECTSTART                    DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLELEMENTEVENTS_ONFILTERCHANGE                   DISPID_EVMETH_ONFILTER
#define DISPID_HTMLELEMENTEVENTS_ONDRAGSTART                      DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREUPDATE                   DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLELEMENTEVENTS_ONAFTERUPDATE                    DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLELEMENTEVENTS_ONERRORUPDATE                    DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLELEMENTEVENTS_ONROWEXIT                        DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLELEMENTEVENTS_ONROWENTER                       DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLELEMENTEVENTS_ONDATASETCHANGED                 DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLELEMENTEVENTS_ONDATAAVAILABLE                  DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLELEMENTEVENTS_ONDATASETCOMPLETE                DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLELEMENTEVENTS_ONLOSECAPTURE                    DISPID_EVMETH_ONLOSECAPTURE
#define DISPID_HTMLELEMENTEVENTS_ONPROPERTYCHANGE                 DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLELEMENTEVENTS_ONSCROLL                         DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLELEMENTEVENTS_ONFOCUS                          DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLELEMENTEVENTS_ONBLUR                           DISPID_EVMETH_ONBLUR
#define DISPID_HTMLELEMENTEVENTS_ONRESIZE                         DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLELEMENTEVENTS_ONDRAG                           DISPID_EVMETH_ONDRAG
#define DISPID_HTMLELEMENTEVENTS_ONDRAGEND                        DISPID_EVMETH_ONDRAGEND
#define DISPID_HTMLELEMENTEVENTS_ONDRAGENTER                      DISPID_EVMETH_ONDRAGENTER
#define DISPID_HTMLELEMENTEVENTS_ONDRAGOVER                       DISPID_EVMETH_ONDRAGOVER
#define DISPID_HTMLELEMENTEVENTS_ONDRAGLEAVE                      DISPID_EVMETH_ONDRAGLEAVE
#define DISPID_HTMLELEMENTEVENTS_ONDROP                           DISPID_EVMETH_ONDROP
#define DISPID_HTMLELEMENTEVENTS_ONBEFORECUT                      DISPID_EVMETH_ONBEFORECUT
#define DISPID_HTMLELEMENTEVENTS_ONCUT                            DISPID_EVMETH_ONCUT
#define DISPID_HTMLELEMENTEVENTS_ONBEFORECOPY                     DISPID_EVMETH_ONBEFORECOPY
#define DISPID_HTMLELEMENTEVENTS_ONCOPY                           DISPID_EVMETH_ONCOPY
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREPASTE                    DISPID_EVMETH_ONBEFOREPASTE
#define DISPID_HTMLELEMENTEVENTS_ONPASTE                          DISPID_EVMETH_ONPASTE
#define DISPID_HTMLELEMENTEVENTS_ONCONTEXTMENU                    DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLELEMENTEVENTS_ONROWSDELETE                     DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLELEMENTEVENTS_ONROWSINSERTED                   DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLELEMENTEVENTS_ONCELLCHANGE                     DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLELEMENTEVENTS_ONREADYSTATECHANGE               DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREEDITFOCUS                DISPID_EVMETH_ONBEFOREEDITFOCUS
#define DISPID_HTMLELEMENTEVENTS_ONLAYOUTCOMPLETE                 DISPID_EVMETH_ONLAYOUTCOMPLETE
#define DISPID_HTMLELEMENTEVENTS_ONPAGE                           DISPID_EVMETH_ONPAGE
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREDEACTIVATE               DISPID_EVMETH_ONBEFOREDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONBEFOREACTIVATE                 DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONMOVE                           DISPID_EVMETH_ONMOVE
#define DISPID_HTMLELEMENTEVENTS_ONCONTROLSELECT                  DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLELEMENTEVENTS_ONMOVESTART                      DISPID_EVMETH_ONMOVESTART
#define DISPID_HTMLELEMENTEVENTS_ONMOVEEND                        DISPID_EVMETH_ONMOVEEND
#define DISPID_HTMLELEMENTEVENTS_ONRESIZESTART                    DISPID_EVMETH_ONRESIZESTART
#define DISPID_HTMLELEMENTEVENTS_ONRESIZEEND                      DISPID_EVMETH_ONRESIZEEND
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEENTER                     DISPID_EVMETH_ONMOUSEENTER
#define DISPID_HTMLELEMENTEVENTS_ONMOUSELEAVE                     DISPID_EVMETH_ONMOUSELEAVE
#define DISPID_HTMLELEMENTEVENTS_ONMOUSEWHEEL                     DISPID_EVMETH_ONMOUSEWHEEL
#define DISPID_HTMLELEMENTEVENTS_ONACTIVATE                       DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONDEACTIVATE                     DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLELEMENTEVENTS_ONFOCUSIN                        DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLELEMENTEVENTS_ONFOCUSOUT                       DISPID_EVMETH_ONFOCUSOUT

//    DISPIDs for interface IHTMLElementDefaults

#define DISPID_IHTMLELEMENTDEFAULTS_STYLE                         DISPID_DEFAULTS+1
#define DISPID_IHTMLELEMENTDEFAULTS_TABSTOP                       DISPID_DEFAULTS+2
#define DISPID_IHTMLELEMENTDEFAULTS_VIEWINHERITSTYLE              DISPID_A_VIEWINHERITSTYLE
#define DISPID_IHTMLELEMENTDEFAULTS_VIEWMASTERTAB                 DISPID_DEFAULTS+6
#define DISPID_IHTMLELEMENTDEFAULTS_SCROLLSEGMENTX                DISPID_DEFAULTS+3
#define DISPID_IHTMLELEMENTDEFAULTS_SCROLLSEGMENTY                DISPID_DEFAULTS+4
#define DISPID_IHTMLELEMENTDEFAULTS_ISMULTILINE                   DISPID_DEFAULTS+8
#define DISPID_IHTMLELEMENTDEFAULTS_CONTENTEDITABLE               DISPID_A_EDITABLE
#define DISPID_IHTMLELEMENTDEFAULTS_CANHAVEHTML                   DISPID_DEFAULTS+9
#define DISPID_IHTMLELEMENTDEFAULTS_VIEWLINK                      DISPID_DEFAULTS+11
#define DISPID_IHTMLELEMENTDEFAULTS_FROZEN                        DISPID_A_FROZEN

//    DISPIDs for interface IHTCDefaultDispatch

#define DISPID_IHTCDEFAULTDISPATCH_ELEMENT                        DISPID_A_HTCDD_ELEMENT
#define DISPID_IHTCDEFAULTDISPATCH_CREATEEVENTOBJECT              DISPID_A_HTCDD_CREATEEVENTOBJECT
#define DISPID_IHTCDEFAULTDISPATCH_DEFAULTS                       DISPID_A_HTCDD_DEFAULTS
#define DISPID_IHTCDEFAULTDISPATCH_DOCUMENT                       DISPID_A_DOCFRAGMENT

//    DISPIDs for interface IHTCPropertyBehavior

#define DISPID_IHTCPROPERTYBEHAVIOR_FIRECHANGE                    DISPID_HTMLOBJECT+0
#define DISPID_IHTCPROPERTYBEHAVIOR_VALUE                         DISPID_A_HTCDISPATCHITEM_VALUE

//    DISPIDs for interface IHTCEventBehavior

#define DISPID_IHTCEVENTBEHAVIOR_FIRE                             DISPID_HTMLOBJECT+0

//    DISPIDs for interface IHTCAttachBehavior

#define DISPID_IHTCATTACHBEHAVIOR_FIREEVENT                       DISPID_VALUE
#define DISPID_IHTCATTACHBEHAVIOR_DETACHEVENT                     DISPID_HTMLOBJECT+0

//    DISPIDs for interface IHTCAttachBehavior2

#define DISPID_IHTCATTACHBEHAVIOR2_FIREEVENT                      DISPID_VALUE

//    DISPIDs for interface IHTCDescBehavior

#define DISPID_IHTCDESCBEHAVIOR_URN                               DISPID_HTMLOBJECT+0
#define DISPID_IHTCDESCBEHAVIOR_NAME                              DISPID_HTMLOBJECT+1

//    DISPIDs for interface IHTMLUrnCollection

#define DISPID_IHTMLURNCOLLECTION_LENGTH                          DISPID_URN_COLL+1
#define DISPID_IHTMLURNCOLLECTION_ITEM                            DISPID_VALUE

//    DISPIDs for interface IHTMLGenericElement

#define DISPID_IHTMLGENERICELEMENT_RECORDSET                      DISPID_GENERIC+1
#define DISPID_IHTMLGENERICELEMENT_NAMEDRECORDSET                 DISPID_GENERIC+2

//    DISPIDs for interface IHTMLStyleSheetRule

#define DISPID_IHTMLSTYLESHEETRULE_SELECTORTEXT                   DISPID_STYLERULE+1
#define DISPID_IHTMLSTYLESHEETRULE_STYLE                          STDPROPID_XOBJ_STYLE
#define DISPID_IHTMLSTYLESHEETRULE_READONLY                       DISPID_STYLERULE+2

//    DISPIDs for interface IHTMLStyleSheetRulesCollection

#define DISPID_IHTMLSTYLESHEETRULESCOLLECTION_LENGTH              DISPID_STYLERULES_COL+1
#define DISPID_IHTMLSTYLESHEETRULESCOLLECTION_ITEM                DISPID_VALUE

//    DISPIDs for interface IHTMLStyleSheetPage

#define DISPID_IHTMLSTYLESHEETPAGE_SELECTOR                       DISPID_STYLEPAGE+1
#define DISPID_IHTMLSTYLESHEETPAGE_PSEUDOCLASS                    DISPID_STYLEPAGE+2

//    DISPIDs for interface IHTMLStyleSheetPagesCollection

#define DISPID_IHTMLSTYLESHEETPAGESCOLLECTION_LENGTH              DISPID_STYLEPAGES_COL+1
#define DISPID_IHTMLSTYLESHEETPAGESCOLLECTION_ITEM                DISPID_VALUE

//    DISPIDs for interface IHTMLStyleSheet

#define DISPID_IHTMLSTYLESHEET_TITLE                              DISPID_STYLESHEET+1
#define DISPID_IHTMLSTYLESHEET_PARENTSTYLESHEET                   DISPID_STYLESHEET+2
#define DISPID_IHTMLSTYLESHEET_OWNINGELEMENT                      DISPID_STYLESHEET+3
#define DISPID_IHTMLSTYLESHEET_DISABLED                           STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLSTYLESHEET_READONLY                           DISPID_STYLESHEET+4
#define DISPID_IHTMLSTYLESHEET_IMPORTS                            DISPID_STYLESHEET+5
#define DISPID_IHTMLSTYLESHEET_HREF                               DISPID_STYLESHEET+6
#define DISPID_IHTMLSTYLESHEET_TYPE                               DISPID_STYLESHEET+7
#define DISPID_IHTMLSTYLESHEET_ID                                 DISPID_STYLESHEET+8
#define DISPID_IHTMLSTYLESHEET_ADDIMPORT                          DISPID_STYLESHEET+9
#define DISPID_IHTMLSTYLESHEET_ADDRULE                            DISPID_STYLESHEET+10
#define DISPID_IHTMLSTYLESHEET_REMOVEIMPORT                       DISPID_STYLESHEET+11
#define DISPID_IHTMLSTYLESHEET_REMOVERULE                         DISPID_STYLESHEET+12
#define DISPID_IHTMLSTYLESHEET_MEDIA                              DISPID_STYLESHEET+13
#define DISPID_IHTMLSTYLESHEET_CSSTEXT                            DISPID_STYLESHEET+14
#define DISPID_IHTMLSTYLESHEET_RULES                              DISPID_STYLESHEET+15

//    DISPIDs for interface IHTMLStyleSheet2

#define DISPID_IHTMLSTYLESHEET2_PAGES                             DISPID_STYLESHEET+16
#define DISPID_IHTMLSTYLESHEET2_ADDPAGERULE                       DISPID_STYLESHEET+17

//    DISPIDs for interface IHTMLStyleSheetsCollection

#define DISPID_IHTMLSTYLESHEETSCOLLECTION_LENGTH                  DISPID_STYLESHEETS_COL+1
#define DISPID_IHTMLSTYLESHEETSCOLLECTION__NEWENUM                DISPID_NEWENUM
#define DISPID_IHTMLSTYLESHEETSCOLLECTION_ITEM                    DISPID_VALUE

//    DISPIDs for interface IHTMLLinkElement

#define DISPID_IHTMLLINKELEMENT_HREF                              DISPID_HEDELEMS+5
#define DISPID_IHTMLLINKELEMENT_REL                               DISPID_HEDELEMS+6
#define DISPID_IHTMLLINKELEMENT_REV                               DISPID_HEDELEMS+7
#define DISPID_IHTMLLINKELEMENT_TYPE                              DISPID_HEDELEMS+8
#define DISPID_IHTMLLINKELEMENT_READYSTATE                        DISPID_A_READYSTATE
#define DISPID_IHTMLLINKELEMENT_ONREADYSTATECHANGE                DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLLINKELEMENT_ONLOAD                            DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLLINKELEMENT_ONERROR                           DISPID_EVPROP_ONERROR
#define DISPID_IHTMLLINKELEMENT_STYLESHEET                        DISPID_HEDELEMS+14
#define DISPID_IHTMLLINKELEMENT_DISABLED                          STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLLINKELEMENT_MEDIA                             DISPID_HEDELEMS+16

//    DISPIDs for interface IHTMLLinkElement2

#define DISPID_IHTMLLINKELEMENT2_TARGET                           DISPID_HEDELEMS+17

//    DISPIDs for interface IHTMLLinkElement3

#define DISPID_IHTMLLINKELEMENT3_CHARSET                          DISPID_HEDELEMS+18
#define DISPID_IHTMLLINKELEMENT3_HREFLANG                         DISPID_HEDELEMS+19

//    DISPIDs for event set HTMLLinkElementEvents2

#define DISPID_HTMLLINKELEMENTEVENTS2_ONLOAD                      DISPID_EVMETH_ONLOAD
#define DISPID_HTMLLINKELEMENTEVENTS2_ONERROR                     DISPID_EVMETH_ONERROR

//    DISPIDs for event set HTMLLinkElementEvents

#define DISPID_HTMLLINKELEMENTEVENTS_ONLOAD                       DISPID_EVMETH_ONLOAD
#define DISPID_HTMLLINKELEMENTEVENTS_ONERROR                      DISPID_EVMETH_ONERROR

//    DISPIDs for interface IHTMLTxtRange

#define DISPID_IHTMLTXTRANGE_HTMLTEXT                             DISPID_RANGE+3
#define DISPID_IHTMLTXTRANGE_TEXT                                 DISPID_RANGE+4
#define DISPID_IHTMLTXTRANGE_PARENTELEMENT                        DISPID_RANGE+6
#define DISPID_IHTMLTXTRANGE_DUPLICATE                            DISPID_RANGE+8
#define DISPID_IHTMLTXTRANGE_INRANGE                              DISPID_RANGE+10
#define DISPID_IHTMLTXTRANGE_ISEQUAL                              DISPID_RANGE+11
#define DISPID_IHTMLTXTRANGE_SCROLLINTOVIEW                       DISPID_RANGE+12
#define DISPID_IHTMLTXTRANGE_COLLAPSE                             DISPID_RANGE+13
#define DISPID_IHTMLTXTRANGE_EXPAND                               DISPID_RANGE+14
#define DISPID_IHTMLTXTRANGE_MOVE                                 DISPID_RANGE+15
#define DISPID_IHTMLTXTRANGE_MOVESTART                            DISPID_RANGE+16
#define DISPID_IHTMLTXTRANGE_MOVEEND                              DISPID_RANGE+17
#define DISPID_IHTMLTXTRANGE_SELECT                               DISPID_RANGE+24
#define DISPID_IHTMLTXTRANGE_PASTEHTML                            DISPID_RANGE+26
#define DISPID_IHTMLTXTRANGE_MOVETOELEMENTTEXT                    DISPID_RANGE+1
#define DISPID_IHTMLTXTRANGE_SETENDPOINT                          DISPID_RANGE+25
#define DISPID_IHTMLTXTRANGE_COMPAREENDPOINTS                     DISPID_RANGE+18
#define DISPID_IHTMLTXTRANGE_FINDTEXT                             DISPID_RANGE+19
#define DISPID_IHTMLTXTRANGE_MOVETOPOINT                          DISPID_RANGE+20
#define DISPID_IHTMLTXTRANGE_GETBOOKMARK                          DISPID_RANGE+21
#define DISPID_IHTMLTXTRANGE_MOVETOBOOKMARK                       DISPID_RANGE+9
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDSUPPORTED                DISPID_RANGE+27
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDENABLED                  DISPID_RANGE+28
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDSTATE                    DISPID_RANGE+29
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDINDETERM                 DISPID_RANGE+30
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDTEXT                     DISPID_RANGE+31
#define DISPID_IHTMLTXTRANGE_QUERYCOMMANDVALUE                    DISPID_RANGE+32
#define DISPID_IHTMLTXTRANGE_EXECCOMMAND                          DISPID_RANGE+33
#define DISPID_IHTMLTXTRANGE_EXECCOMMANDSHOWHELP                  DISPID_RANGE+34

//    DISPIDs for interface IHTMLTextRangeMetrics

#define DISPID_IHTMLTEXTRANGEMETRICS_OFFSETTOP                    DISPID_RANGE+35
#define DISPID_IHTMLTEXTRANGEMETRICS_OFFSETLEFT                   DISPID_RANGE+36
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGTOP                  DISPID_RANGE+37
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGLEFT                 DISPID_RANGE+38
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGWIDTH                DISPID_RANGE+39
#define DISPID_IHTMLTEXTRANGEMETRICS_BOUNDINGHEIGHT               DISPID_RANGE+40

//    DISPIDs for interface IHTMLTextRangeMetrics2

#define DISPID_IHTMLTEXTRANGEMETRICS2_GETCLIENTRECTS              DISPID_RANGE+41
#define DISPID_IHTMLTEXTRANGEMETRICS2_GETBOUNDINGCLIENTRECT       DISPID_RANGE+42

//    DISPIDs for interface IHTMLTxtRangeCollection

#define DISPID_IHTMLTXTRANGECOLLECTION_LENGTH                     DISPID_COLLECTION
#define DISPID_IHTMLTXTRANGECOLLECTION__NEWENUM                   DISPID_NEWENUM
#define DISPID_IHTMLTXTRANGECOLLECTION_ITEM                       DISPID_VALUE

//    DISPIDs for interface IHTMLFormElement

#define DISPID_IHTMLFORMELEMENT_ACTION                            DISPID_FORM+1
#define DISPID_IHTMLFORMELEMENT_DIR                               DISPID_A_DIR
#define DISPID_IHTMLFORMELEMENT_ENCODING                          DISPID_FORM+3
#define DISPID_IHTMLFORMELEMENT_METHOD                            DISPID_FORM+4
#define DISPID_IHTMLFORMELEMENT_ELEMENTS                          DISPID_FORM+5
#define DISPID_IHTMLFORMELEMENT_TARGET                            DISPID_FORM+6
#define DISPID_IHTMLFORMELEMENT_NAME                              STDPROPID_XOBJ_NAME
#define DISPID_IHTMLFORMELEMENT_ONSUBMIT                          DISPID_EVPROP_ONSUBMIT
#define DISPID_IHTMLFORMELEMENT_ONRESET                           DISPID_EVPROP_ONRESET
#define DISPID_IHTMLFORMELEMENT_SUBMIT                            DISPID_FORM+9
#define DISPID_IHTMLFORMELEMENT_RESET                             DISPID_FORM+10
#define DISPID_IHTMLFORMELEMENT_LENGTH                            DISPID_COLLECTION
#define DISPID_IHTMLFORMELEMENT__NEWENUM                          DISPID_NEWENUM
#define DISPID_IHTMLFORMELEMENT_ITEM                              DISPID_VALUE
#define DISPID_IHTMLFORMELEMENT_TAGS                              DISPID_COLLECTION+2

//    DISPIDs for interface IHTMLFormElement2

#define DISPID_IHTMLFORMELEMENT2_ACCEPTCHARSET                    DISPID_FORM+11
#define DISPID_IHTMLFORMELEMENT2_URNS                             DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLFormElement3

#define DISPID_IHTMLFORMELEMENT3_NAMEDITEM                        DISPID_COLLECTION+6

//    DISPIDs for interface IHTMLSubmitData

#define DISPID_IHTMLSUBMITDATA_APPENDNAMEVALUEPAIR                DISPID_FORM+12
#define DISPID_IHTMLSUBMITDATA_APPENDNAMEFILEPAIR                 DISPID_FORM+13
#define DISPID_IHTMLSUBMITDATA_APPENDITEMSEPARATOR                DISPID_FORM+14

//    DISPIDs for event set HTMLFormElementEvents2

#define DISPID_HTMLFORMELEMENTEVENTS2_ONSUBMIT                    DISPID_EVMETH_ONSUBMIT
#define DISPID_HTMLFORMELEMENTEVENTS2_ONRESET                     DISPID_EVMETH_ONRESET

//    DISPIDs for event set HTMLFormElementEvents

#define DISPID_HTMLFORMELEMENTEVENTS_ONSUBMIT                     DISPID_EVMETH_ONSUBMIT
#define DISPID_HTMLFORMELEMENTEVENTS_ONRESET                      DISPID_EVMETH_ONRESET

//    DISPIDs for interface IHTMLControlElement

#define DISPID_IHTMLCONTROLELEMENT_TABINDEX                       STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLCONTROLELEMENT_FOCUS                          DISPID_SITE+0
#define DISPID_IHTMLCONTROLELEMENT_ACCESSKEY                      DISPID_SITE+5
#define DISPID_IHTMLCONTROLELEMENT_ONBLUR                         DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLCONTROLELEMENT_ONFOCUS                        DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLCONTROLELEMENT_ONRESIZE                       DISPID_EVPROP_ONRESIZE
#define DISPID_IHTMLCONTROLELEMENT_BLUR                           DISPID_SITE+2
#define DISPID_IHTMLCONTROLELEMENT_ADDFILTER                      DISPID_SITE+17
#define DISPID_IHTMLCONTROLELEMENT_REMOVEFILTER                   DISPID_SITE+18
#define DISPID_IHTMLCONTROLELEMENT_CLIENTHEIGHT                   DISPID_SITE+19
#define DISPID_IHTMLCONTROLELEMENT_CLIENTWIDTH                    DISPID_SITE+20
#define DISPID_IHTMLCONTROLELEMENT_CLIENTTOP                      DISPID_SITE+21
#define DISPID_IHTMLCONTROLELEMENT_CLIENTLEFT                     DISPID_SITE+22

//    DISPIDs for interface IHTMLTextContainer

#define DISPID_IHTMLTEXTCONTAINER_CREATECONTROLRANGE              DISPID_TEXTSITE+1
#define DISPID_IHTMLTEXTCONTAINER_SCROLLHEIGHT                    DISPID_TEXTSITE+2
#define DISPID_IHTMLTEXTCONTAINER_SCROLLWIDTH                     DISPID_TEXTSITE+3
#define DISPID_IHTMLTEXTCONTAINER_SCROLLTOP                       DISPID_TEXTSITE+4
#define DISPID_IHTMLTEXTCONTAINER_SCROLLLEFT                      DISPID_TEXTSITE+5
#define DISPID_IHTMLTEXTCONTAINER_ONSCROLL                        DISPID_EVPROP_ONSCROLL

//    DISPIDs for event set HTMLTextContainerEvents2

#define DISPID_HTMLTEXTCONTAINEREVENTS2_ONCHANGE                  DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLTEXTCONTAINEREVENTS2_ONSELECT                  DISPID_EVMETH_ONSELECT

//    DISPIDs for event set HTMLTextContainerEvents

#define DISPID_HTMLTEXTCONTAINEREVENTS_ONCHANGE                   DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLTEXTCONTAINEREVENTS_ONSELECT                   DISPID_EVMETH_ONSELECT

//    DISPIDs for interface IHTMLControlRange

#define DISPID_IHTMLCONTROLRANGE_SELECT                           DISPID_RANGE+2
#define DISPID_IHTMLCONTROLRANGE_ADD                              DISPID_RANGE+3
#define DISPID_IHTMLCONTROLRANGE_REMOVE                           DISPID_RANGE+4
#define DISPID_IHTMLCONTROLRANGE_ITEM                             DISPID_VALUE
#define DISPID_IHTMLCONTROLRANGE_SCROLLINTOVIEW                   DISPID_RANGE+6
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDSUPPORTED            DISPID_RANGE+7
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDENABLED              DISPID_RANGE+8
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDSTATE                DISPID_RANGE+9
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDINDETERM             DISPID_RANGE+10
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDTEXT                 DISPID_RANGE+11
#define DISPID_IHTMLCONTROLRANGE_QUERYCOMMANDVALUE                DISPID_RANGE+12
#define DISPID_IHTMLCONTROLRANGE_EXECCOMMAND                      DISPID_RANGE+13
#define DISPID_IHTMLCONTROLRANGE_EXECCOMMANDSHOWHELP              DISPID_RANGE+14
#define DISPID_IHTMLCONTROLRANGE_COMMONPARENTELEMENT              DISPID_RANGE+15
#define DISPID_IHTMLCONTROLRANGE_LENGTH                           DISPID_RANGE+5

//    DISPIDs for interface IHTMLControlRange2

#define DISPID_IHTMLCONTROLRANGE2_ADDELEMENT                      DISPID_RANGE+16

//    DISPIDs for interface IHTMLImgElement

#define DISPID_IHTMLIMGELEMENT_ISMAP                              DISPID_IMG+2
#define DISPID_IHTMLIMGELEMENT_USEMAP                             DISPID_IMG+8
#define DISPID_IHTMLIMGELEMENT_MIMETYPE                           DISPID_IMG+10
#define DISPID_IHTMLIMGELEMENT_FILESIZE                           DISPID_IMG+11
#define DISPID_IHTMLIMGELEMENT_FILECREATEDDATE                    DISPID_IMG+12
#define DISPID_IHTMLIMGELEMENT_FILEMODIFIEDDATE                   DISPID_IMG+13
#define DISPID_IHTMLIMGELEMENT_FILEUPDATEDDATE                    DISPID_IMG+14
#define DISPID_IHTMLIMGELEMENT_PROTOCOL                           DISPID_IMG+15
#define DISPID_IHTMLIMGELEMENT_HREF                               DISPID_IMG+16
#define DISPID_IHTMLIMGELEMENT_NAMEPROP                           DISPID_IMG+17
#define DISPID_IHTMLIMGELEMENT_BORDER                             DISPID_IMGBASE+4
#define DISPID_IHTMLIMGELEMENT_VSPACE                             DISPID_IMGBASE+5
#define DISPID_IHTMLIMGELEMENT_HSPACE                             DISPID_IMGBASE+6
#define DISPID_IHTMLIMGELEMENT_ALT                                DISPID_IMGBASE+2
#define DISPID_IHTMLIMGELEMENT_SRC                                DISPID_IMGBASE+3
#define DISPID_IHTMLIMGELEMENT_LOWSRC                             DISPID_IMGBASE+7
#define DISPID_IHTMLIMGELEMENT_VRML                               DISPID_IMGBASE+8
#define DISPID_IHTMLIMGELEMENT_DYNSRC                             DISPID_IMGBASE+9
#define DISPID_IHTMLIMGELEMENT_READYSTATE                         DISPID_A_READYSTATE
#define DISPID_IHTMLIMGELEMENT_COMPLETE                           DISPID_IMGBASE+10
#define DISPID_IHTMLIMGELEMENT_LOOP                               DISPID_IMGBASE+11
#define DISPID_IHTMLIMGELEMENT_ALIGN                              STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLIMGELEMENT_ONLOAD                             DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLIMGELEMENT_ONERROR                            DISPID_EVPROP_ONERROR
#define DISPID_IHTMLIMGELEMENT_ONABORT                            DISPID_EVPROP_ONABORT
#define DISPID_IHTMLIMGELEMENT_NAME                               STDPROPID_XOBJ_NAME
#define DISPID_IHTMLIMGELEMENT_WIDTH                              STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLIMGELEMENT_HEIGHT                             STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLIMGELEMENT_START                              DISPID_IMGBASE+13

//    DISPIDs for interface IHTMLImgElement2

#define DISPID_IHTMLIMGELEMENT2_LONGDESC                          DISPID_IMG+19

//    DISPIDs for interface IHTMLImageElementFactory

#define DISPID_IHTMLIMAGEELEMENTFACTORY_CREATE                    DISPID_VALUE

//    DISPIDs for event set HTMLImgEvents2

#define DISPID_HTMLIMGEVENTS2_ONLOAD                              DISPID_EVMETH_ONLOAD
#define DISPID_HTMLIMGEVENTS2_ONERROR                             DISPID_EVMETH_ONERROR
#define DISPID_HTMLIMGEVENTS2_ONABORT                             DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLImgEvents

#define DISPID_HTMLIMGEVENTS_ONLOAD                               DISPID_EVMETH_ONLOAD
#define DISPID_HTMLIMGEVENTS_ONERROR                              DISPID_EVMETH_ONERROR
#define DISPID_HTMLIMGEVENTS_ONABORT                              DISPID_EVMETH_ONABORT

//    DISPIDs for interface IHTMLBodyElement

#define DISPID_IHTMLBODYELEMENT_BACKGROUND                        DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLBODYELEMENT_BGPROPERTIES                      DISPID_A_BACKGROUNDATTACHMENT
#define DISPID_IHTMLBODYELEMENT_LEFTMARGIN                        DISPID_A_MARGINLEFT
#define DISPID_IHTMLBODYELEMENT_TOPMARGIN                         DISPID_A_MARGINTOP
#define DISPID_IHTMLBODYELEMENT_RIGHTMARGIN                       DISPID_A_MARGINRIGHT
#define DISPID_IHTMLBODYELEMENT_BOTTOMMARGIN                      DISPID_A_MARGINBOTTOM
#define DISPID_IHTMLBODYELEMENT_NOWRAP                            DISPID_A_NOWRAP
#define DISPID_IHTMLBODYELEMENT_BGCOLOR                           DISPID_BACKCOLOR
#define DISPID_IHTMLBODYELEMENT_TEXT                              DISPID_A_COLOR
#define DISPID_IHTMLBODYELEMENT_LINK                              DISPID_BODY+10
#define DISPID_IHTMLBODYELEMENT_VLINK                             DISPID_BODY+12
#define DISPID_IHTMLBODYELEMENT_ALINK                             DISPID_BODY+11
#define DISPID_IHTMLBODYELEMENT_ONLOAD                            DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLBODYELEMENT_ONUNLOAD                          DISPID_EVPROP_ONUNLOAD
#define DISPID_IHTMLBODYELEMENT_SCROLL                            DISPID_A_SCROLL
#define DISPID_IHTMLBODYELEMENT_ONSELECT                          DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLBODYELEMENT_ONBEFOREUNLOAD                    DISPID_EVPROP_ONBEFOREUNLOAD
#define DISPID_IHTMLBODYELEMENT_CREATETEXTRANGE                   DISPID_BODY+13

//    DISPIDs for interface IHTMLBodyElement2

#define DISPID_IHTMLBODYELEMENT2_ONBEFOREPRINT                    DISPID_EVPROP_ONBEFOREPRINT
#define DISPID_IHTMLBODYELEMENT2_ONAFTERPRINT                     DISPID_EVPROP_ONAFTERPRINT

//    DISPIDs for interface IHTMLFontElement

#define DISPID_IHTMLFONTELEMENT_COLOR                             DISPID_A_COLOR
#define DISPID_IHTMLFONTELEMENT_FACE                              DISPID_A_FONTFACE
#define DISPID_IHTMLFONTELEMENT_SIZE                              DISPID_A_FONTSIZE

//    DISPIDs for interface IHTMLAnchorElement

#define DISPID_IHTMLANCHORELEMENT_HREF                            DISPID_VALUE
#define DISPID_IHTMLANCHORELEMENT_TARGET                          DISPID_ANCHOR+3
#define DISPID_IHTMLANCHORELEMENT_REL                             DISPID_ANCHOR+5
#define DISPID_IHTMLANCHORELEMENT_REV                             DISPID_ANCHOR+6
#define DISPID_IHTMLANCHORELEMENT_URN                             DISPID_ANCHOR+7
#define DISPID_IHTMLANCHORELEMENT_METHODS                         DISPID_ANCHOR+8
#define DISPID_IHTMLANCHORELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLANCHORELEMENT_HOST                            DISPID_ANCHOR+12
#define DISPID_IHTMLANCHORELEMENT_HOSTNAME                        DISPID_ANCHOR+13
#define DISPID_IHTMLANCHORELEMENT_PATHNAME                        DISPID_ANCHOR+14
#define DISPID_IHTMLANCHORELEMENT_PORT                            DISPID_ANCHOR+15
#define DISPID_IHTMLANCHORELEMENT_PROTOCOL                        DISPID_ANCHOR+16
#define DISPID_IHTMLANCHORELEMENT_SEARCH                          DISPID_ANCHOR+17
#define DISPID_IHTMLANCHORELEMENT_HASH                            DISPID_ANCHOR+18
#define DISPID_IHTMLANCHORELEMENT_ONBLUR                          DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLANCHORELEMENT_ONFOCUS                         DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLANCHORELEMENT_ACCESSKEY                       DISPID_SITE+5
#define DISPID_IHTMLANCHORELEMENT_PROTOCOLLONG                    DISPID_ANCHOR+31
#define DISPID_IHTMLANCHORELEMENT_MIMETYPE                        DISPID_ANCHOR+30
#define DISPID_IHTMLANCHORELEMENT_NAMEPROP                        DISPID_ANCHOR+32
#define DISPID_IHTMLANCHORELEMENT_TABINDEX                        STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLANCHORELEMENT_FOCUS                           DISPID_SITE+0
#define DISPID_IHTMLANCHORELEMENT_BLUR                            DISPID_SITE+2

//    DISPIDs for interface IHTMLAnchorElement2

#define DISPID_IHTMLANCHORELEMENT2_CHARSET                        DISPID_ANCHOR+23
#define DISPID_IHTMLANCHORELEMENT2_COORDS                         DISPID_ANCHOR+24
#define DISPID_IHTMLANCHORELEMENT2_HREFLANG                       DISPID_ANCHOR+25
#define DISPID_IHTMLANCHORELEMENT2_SHAPE                          DISPID_ANCHOR+26
#define DISPID_IHTMLANCHORELEMENT2_TYPE                           DISPID_ANCHOR+27

//    DISPIDs for interface IHTMLLabelElement

#define DISPID_IHTMLLABELELEMENT_HTMLFOR                          DISPID_LABEL
#define DISPID_IHTMLLABELELEMENT_ACCESSKEY                        DISPID_SITE+5

//    DISPIDs for interface IHTMLLabelElement2

#define DISPID_IHTMLLABELELEMENT2_FORM                            DISPID_LABEL+2

//    DISPIDs for interface IHTMLListElement2

#define DISPID_IHTMLLISTELEMENT2_COMPACT                          DISPID_DIR+1

//    DISPIDs for interface IHTMLUListElement

#define DISPID_IHTMLULISTELEMENT_COMPACT                          DISPID_DIR+1
#define DISPID_IHTMLULISTELEMENT_TYPE                             DISPID_A_LISTTYPE

//    DISPIDs for interface IHTMLOListElement

#define DISPID_IHTMLOLISTELEMENT_COMPACT                          DISPID_DIR+1
#define DISPID_IHTMLOLISTELEMENT_START                            DISPID_OL+3
#define DISPID_IHTMLOLISTELEMENT_TYPE                             DISPID_A_LISTTYPE

//    DISPIDs for interface IHTMLLIElement

#define DISPID_IHTMLLIELEMENT_TYPE                                DISPID_A_LISTTYPE
#define DISPID_IHTMLLIELEMENT_VALUE                               DISPID_LI+1

//    DISPIDs for interface IHTMLBlockElement

#define DISPID_IHTMLBLOCKELEMENT_CLEAR                            DISPID_A_CLEAR

//    DISPIDs for interface IHTMLBlockElement2

#define DISPID_IHTMLBLOCKELEMENT2_CITE                            DISPID_BLOCK+1
#define DISPID_IHTMLBLOCKELEMENT2_WIDTH                           DISPID_BLOCK+2

//    DISPIDs for interface IHTMLDivElement

#define DISPID_IHTMLDIVELEMENT_ALIGN                              STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLDIVELEMENT_NOWRAP                             DISPID_A_NOWRAP

//    DISPIDs for interface IHTMLDDElement

#define DISPID_IHTMLDDELEMENT_NOWRAP                              DISPID_A_NOWRAP

//    DISPIDs for interface IHTMLDTElement

#define DISPID_IHTMLDTELEMENT_NOWRAP                              DISPID_A_NOWRAP

//    DISPIDs for interface IHTMLBRElement

#define DISPID_IHTMLBRELEMENT_CLEAR                               DISPID_A_CLEAR

//    DISPIDs for interface IHTMLDListElement

#define DISPID_IHTMLDLISTELEMENT_COMPACT                          DISPID_DIR+1

//    DISPIDs for interface IHTMLHRElement

#define DISPID_IHTMLHRELEMENT_ALIGN                               STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLHRELEMENT_COLOR                               DISPID_A_COLOR
#define DISPID_IHTMLHRELEMENT_NOSHADE                             DISPID_HR+1
#define DISPID_IHTMLHRELEMENT_WIDTH                               STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLHRELEMENT_SIZE                                STDPROPID_XOBJ_HEIGHT

//    DISPIDs for interface IHTMLParaElement

#define DISPID_IHTMLPARAELEMENT_ALIGN                             STDPROPID_XOBJ_BLOCKALIGN

//    DISPIDs for interface IHTMLElementCollection

#define DISPID_IHTMLELEMENTCOLLECTION_TOSTRING                    DISPID_COLLECTION+1
#define DISPID_IHTMLELEMENTCOLLECTION_LENGTH                      DISPID_COLLECTION
#define DISPID_IHTMLELEMENTCOLLECTION__NEWENUM                    DISPID_NEWENUM
#define DISPID_IHTMLELEMENTCOLLECTION_ITEM                        DISPID_VALUE
#define DISPID_IHTMLELEMENTCOLLECTION_TAGS                        DISPID_COLLECTION+2

//    DISPIDs for interface IHTMLElementCollection2

#define DISPID_IHTMLELEMENTCOLLECTION2_URNS                       DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLElementCollection3

#define DISPID_IHTMLELEMENTCOLLECTION3_NAMEDITEM                  DISPID_COLLECTION+6

//    DISPIDs for interface IHTMLHeaderElement

#define DISPID_IHTMLHEADERELEMENT_ALIGN                           STDPROPID_XOBJ_BLOCKALIGN

//    DISPIDs for interface IHTMLSelectElement

#define DISPID_IHTMLSELECTELEMENT_SIZE                            DISPID_SELECT+2
#define DISPID_IHTMLSELECTELEMENT_MULTIPLE                        DISPID_SELECT+3
#define DISPID_IHTMLSELECTELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLSELECTELEMENT_OPTIONS                         DISPID_SELECT+5
#define DISPID_IHTMLSELECTELEMENT_ONCHANGE                        DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLSELECTELEMENT_SELECTEDINDEX                   DISPID_SELECT+10
#define DISPID_IHTMLSELECTELEMENT_TYPE                            DISPID_SELECT+12
#define DISPID_IHTMLSELECTELEMENT_VALUE                           DISPID_SELECT+11
#define DISPID_IHTMLSELECTELEMENT_DISABLED                        STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLSELECTELEMENT_FORM                            DISPID_SITE+4
#define DISPID_IHTMLSELECTELEMENT_ADD                             DISPID_COLLECTION+3
#define DISPID_IHTMLSELECTELEMENT_REMOVE                          DISPID_COLLECTION+4
#define DISPID_IHTMLSELECTELEMENT_LENGTH                          DISPID_COLLECTION
#define DISPID_IHTMLSELECTELEMENT__NEWENUM                        DISPID_NEWENUM
#define DISPID_IHTMLSELECTELEMENT_ITEM                            DISPID_VALUE
#define DISPID_IHTMLSELECTELEMENT_TAGS                            DISPID_COLLECTION+2

//    DISPIDs for interface IHTMLSelectElement2

#define DISPID_IHTMLSELECTELEMENT2_URNS                           DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLSelectElement4

#define DISPID_IHTMLSELECTELEMENT4_NAMEDITEM                      DISPID_COLLECTION+6

//    DISPIDs for event set HTMLSelectElementEvents2

#define DISPID_HTMLSELECTELEMENTEVENTS2_ONCHANGE                  DISPID_EVMETH_ONCHANGE

//    DISPIDs for event set HTMLSelectElementEvents

#define DISPID_HTMLSELECTELEMENTEVENTS_ONCHANGE                   DISPID_EVMETH_ONCHANGE

//    DISPIDs for interface IHTMLSelectionObject

#define DISPID_IHTMLSELECTIONOBJECT_CREATERANGE                   DISPID_SELECTOBJ+1
#define DISPID_IHTMLSELECTIONOBJECT_EMPTY                         DISPID_SELECTOBJ+2
#define DISPID_IHTMLSELECTIONOBJECT_CLEAR                         DISPID_SELECTOBJ+3
#define DISPID_IHTMLSELECTIONOBJECT_TYPE                          DISPID_SELECTOBJ+4

//    DISPIDs for interface IHTMLSelectionObject2

#define DISPID_IHTMLSELECTIONOBJECT2_CREATERANGECOLLECTION        DISPID_SELECTOBJ+5
#define DISPID_IHTMLSELECTIONOBJECT2_TYPEDETAIL                   DISPID_SELECTOBJ+6

//    DISPIDs for interface IHTMLOptionElement

#define DISPID_IHTMLOPTIONELEMENT_SELECTED                        DISPID_OPTION+1
#define DISPID_IHTMLOPTIONELEMENT_VALUE                           DISPID_OPTION+2
#define DISPID_IHTMLOPTIONELEMENT_DEFAULTSELECTED                 DISPID_OPTION+3
#define DISPID_IHTMLOPTIONELEMENT_INDEX                           DISPID_OPTION+5
#define DISPID_IHTMLOPTIONELEMENT_TEXT                            DISPID_OPTION+4
#define DISPID_IHTMLOPTIONELEMENT_FORM                            DISPID_OPTION+6

//    DISPIDs for interface IHTMLOptionElement3

#define DISPID_IHTMLOPTIONELEMENT3_LABEL                          DISPID_OPTION+7

//    DISPIDs for interface IHTMLOptionElementFactory

#define DISPID_IHTMLOPTIONELEMENTFACTORY_CREATE                   DISPID_VALUE

//    DISPIDs for interface IHTMLInputElement

#define DISPID_IHTMLINPUTELEMENT_TYPE                             DISPID_INPUT
#define DISPID_IHTMLINPUTELEMENT_VALUE                            DISPID_A_VALUE
#define DISPID_IHTMLINPUTELEMENT_NAME                             STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTELEMENT_STATUS                           DISPID_INPUT+1
#define DISPID_IHTMLINPUTELEMENT_DISABLED                         STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTELEMENT_FORM                             DISPID_SITE+4
#define DISPID_IHTMLINPUTELEMENT_SIZE                             DISPID_INPUT+2
#define DISPID_IHTMLINPUTELEMENT_MAXLENGTH                        DISPID_INPUT+3
#define DISPID_IHTMLINPUTELEMENT_SELECT                           DISPID_INPUT+4
#define DISPID_IHTMLINPUTELEMENT_ONCHANGE                         DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLINPUTELEMENT_ONSELECT                         DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLINPUTELEMENT_DEFAULTVALUE                     DISPID_DEFAULTVALUE
#define DISPID_IHTMLINPUTELEMENT_READONLY                         DISPID_INPUT+5
#define DISPID_IHTMLINPUTELEMENT_CREATETEXTRANGE                  DISPID_INPUT+6
#define DISPID_IHTMLINPUTELEMENT_INDETERMINATE                    DISPID_INPUT+7
#define DISPID_IHTMLINPUTELEMENT_DEFAULTCHECKED                   DISPID_INPUT+8
#define DISPID_IHTMLINPUTELEMENT_CHECKED                          DISPID_INPUT+9
#define DISPID_IHTMLINPUTELEMENT_BORDER                           DISPID_INPUT+12
#define DISPID_IHTMLINPUTELEMENT_VSPACE                           DISPID_INPUT+13
#define DISPID_IHTMLINPUTELEMENT_HSPACE                           DISPID_INPUT+14
#define DISPID_IHTMLINPUTELEMENT_ALT                              DISPID_INPUT+10
#define DISPID_IHTMLINPUTELEMENT_SRC                              DISPID_INPUT+11
#define DISPID_IHTMLINPUTELEMENT_LOWSRC                           DISPID_INPUT+15
#define DISPID_IHTMLINPUTELEMENT_VRML                             DISPID_INPUT+16
#define DISPID_IHTMLINPUTELEMENT_DYNSRC                           DISPID_INPUT+17
#define DISPID_IHTMLINPUTELEMENT_READYSTATE                       DISPID_A_READYSTATE
#define DISPID_IHTMLINPUTELEMENT_COMPLETE                         DISPID_INPUT+18
#define DISPID_IHTMLINPUTELEMENT_LOOP                             DISPID_INPUT+19
#define DISPID_IHTMLINPUTELEMENT_ALIGN                            STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLINPUTELEMENT_ONLOAD                           DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLINPUTELEMENT_ONERROR                          DISPID_EVPROP_ONERROR
#define DISPID_IHTMLINPUTELEMENT_ONABORT                          DISPID_EVPROP_ONABORT
#define DISPID_IHTMLINPUTELEMENT_WIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLINPUTELEMENT_HEIGHT                           STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLINPUTELEMENT_START                            DISPID_INPUT+20

//    DISPIDs for interface IHTMLInputElement2

#define DISPID_IHTMLINPUTELEMENT2_ACCEPT                          DISPID_INPUT+22
#define DISPID_IHTMLINPUTELEMENT2_USEMAP                          DISPID_INPUT+23

//    DISPIDs for interface IHTMLInputButtonElement

#define DISPID_IHTMLINPUTBUTTONELEMENT_TYPE                       DISPID_INPUT
#define DISPID_IHTMLINPUTBUTTONELEMENT_VALUE                      DISPID_A_VALUE
#define DISPID_IHTMLINPUTBUTTONELEMENT_NAME                       STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTBUTTONELEMENT_STATUS                     DISPID_INPUT+21
#define DISPID_IHTMLINPUTBUTTONELEMENT_DISABLED                   STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTBUTTONELEMENT_FORM                       DISPID_SITE+4
#define DISPID_IHTMLINPUTBUTTONELEMENT_CREATETEXTRANGE            DISPID_INPUT+6

//    DISPIDs for interface IHTMLInputHiddenElement

#define DISPID_IHTMLINPUTHIDDENELEMENT_TYPE                       DISPID_INPUT
#define DISPID_IHTMLINPUTHIDDENELEMENT_VALUE                      DISPID_A_VALUE
#define DISPID_IHTMLINPUTHIDDENELEMENT_NAME                       STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTHIDDENELEMENT_STATUS                     DISPID_INPUT+21
#define DISPID_IHTMLINPUTHIDDENELEMENT_DISABLED                   STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTHIDDENELEMENT_FORM                       DISPID_SITE+4
#define DISPID_IHTMLINPUTHIDDENELEMENT_CREATETEXTRANGE            DISPID_INPUT+6

//    DISPIDs for interface IHTMLInputTextElement

#define DISPID_IHTMLINPUTTEXTELEMENT_TYPE                         DISPID_INPUT
#define DISPID_IHTMLINPUTTEXTELEMENT_VALUE                        DISPID_A_VALUE
#define DISPID_IHTMLINPUTTEXTELEMENT_NAME                         STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTTEXTELEMENT_STATUS                       DISPID_INPUT+21
#define DISPID_IHTMLINPUTTEXTELEMENT_DISABLED                     STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTTEXTELEMENT_FORM                         DISPID_SITE+4
#define DISPID_IHTMLINPUTTEXTELEMENT_DEFAULTVALUE                 DISPID_DEFAULTVALUE
#define DISPID_IHTMLINPUTTEXTELEMENT_SIZE                         DISPID_INPUT+2
#define DISPID_IHTMLINPUTTEXTELEMENT_MAXLENGTH                    DISPID_INPUT+3
#define DISPID_IHTMLINPUTTEXTELEMENT_SELECT                       DISPID_INPUT+4
#define DISPID_IHTMLINPUTTEXTELEMENT_ONCHANGE                     DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLINPUTTEXTELEMENT_ONSELECT                     DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLINPUTTEXTELEMENT_READONLY                     DISPID_INPUT+5
#define DISPID_IHTMLINPUTTEXTELEMENT_CREATETEXTRANGE              DISPID_INPUT+6

//    DISPIDs for interface IHTMLInputFileElement

#define DISPID_IHTMLINPUTFILEELEMENT_TYPE                         DISPID_INPUT
#define DISPID_IHTMLINPUTFILEELEMENT_NAME                         STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTFILEELEMENT_STATUS                       DISPID_INPUT+21
#define DISPID_IHTMLINPUTFILEELEMENT_DISABLED                     STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTFILEELEMENT_FORM                         DISPID_SITE+4
#define DISPID_IHTMLINPUTFILEELEMENT_SIZE                         DISPID_INPUT+2
#define DISPID_IHTMLINPUTFILEELEMENT_MAXLENGTH                    DISPID_INPUT+3
#define DISPID_IHTMLINPUTFILEELEMENT_SELECT                       DISPID_INPUT+4
#define DISPID_IHTMLINPUTFILEELEMENT_ONCHANGE                     DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLINPUTFILEELEMENT_ONSELECT                     DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLINPUTFILEELEMENT_VALUE                        DISPID_A_VALUE

//    DISPIDs for interface IHTMLOptionButtonElement

#define DISPID_IHTMLOPTIONBUTTONELEMENT_VALUE                     DISPID_A_VALUE
#define DISPID_IHTMLOPTIONBUTTONELEMENT_TYPE                      DISPID_INPUT
#define DISPID_IHTMLOPTIONBUTTONELEMENT_NAME                      STDPROPID_XOBJ_NAME
#define DISPID_IHTMLOPTIONBUTTONELEMENT_CHECKED                   DISPID_INPUT+9
#define DISPID_IHTMLOPTIONBUTTONELEMENT_DEFAULTCHECKED            DISPID_INPUT+8
#define DISPID_IHTMLOPTIONBUTTONELEMENT_ONCHANGE                  DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLOPTIONBUTTONELEMENT_DISABLED                  STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLOPTIONBUTTONELEMENT_STATUS                    DISPID_INPUT+1
#define DISPID_IHTMLOPTIONBUTTONELEMENT_INDETERMINATE             DISPID_INPUT+7
#define DISPID_IHTMLOPTIONBUTTONELEMENT_FORM                      DISPID_SITE+4

//    DISPIDs for interface IHTMLInputImage

#define DISPID_IHTMLINPUTIMAGE_TYPE                               DISPID_INPUT
#define DISPID_IHTMLINPUTIMAGE_DISABLED                           STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLINPUTIMAGE_BORDER                             DISPID_INPUT+12
#define DISPID_IHTMLINPUTIMAGE_VSPACE                             DISPID_INPUT+13
#define DISPID_IHTMLINPUTIMAGE_HSPACE                             DISPID_INPUT+14
#define DISPID_IHTMLINPUTIMAGE_ALT                                DISPID_INPUT+10
#define DISPID_IHTMLINPUTIMAGE_SRC                                DISPID_INPUT+11
#define DISPID_IHTMLINPUTIMAGE_LOWSRC                             DISPID_INPUT+15
#define DISPID_IHTMLINPUTIMAGE_VRML                               DISPID_INPUT+16
#define DISPID_IHTMLINPUTIMAGE_DYNSRC                             DISPID_INPUT+17
#define DISPID_IHTMLINPUTIMAGE_READYSTATE                         DISPID_A_READYSTATE
#define DISPID_IHTMLINPUTIMAGE_COMPLETE                           DISPID_INPUT+18
#define DISPID_IHTMLINPUTIMAGE_LOOP                               DISPID_INPUT+19
#define DISPID_IHTMLINPUTIMAGE_ALIGN                              STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLINPUTIMAGE_ONLOAD                             DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLINPUTIMAGE_ONERROR                            DISPID_EVPROP_ONERROR
#define DISPID_IHTMLINPUTIMAGE_ONABORT                            DISPID_EVPROP_ONABORT
#define DISPID_IHTMLINPUTIMAGE_NAME                               STDPROPID_XOBJ_NAME
#define DISPID_IHTMLINPUTIMAGE_WIDTH                              STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLINPUTIMAGE_HEIGHT                             STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLINPUTIMAGE_START                              DISPID_INPUT+20

//    DISPIDs for event set HTMLInputTextElementEvents2

#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONCHANGE               DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONSELECT               DISPID_EVMETH_ONSELECT
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONLOAD                 DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONERROR                DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS2_ONABORT                DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLInputImageEvents2

#define DISPID_HTMLINPUTIMAGEEVENTS2_ONLOAD                       DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTIMAGEEVENTS2_ONERROR                      DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTIMAGEEVENTS2_ONABORT                      DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLInputTextElementEvents

#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONCHANGE                DISPID_EVMETH_ONCHANGE
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONSELECT                DISPID_EVMETH_ONSELECT
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONLOAD                  DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONERROR                 DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTTEXTELEMENTEVENTS_ONABORT                 DISPID_EVMETH_ONABORT

//    DISPIDs for event set HTMLInputImageEvents

#define DISPID_HTMLINPUTIMAGEEVENTS_ONLOAD                        DISPID_EVMETH_ONLOAD
#define DISPID_HTMLINPUTIMAGEEVENTS_ONERROR                       DISPID_EVMETH_ONERROR
#define DISPID_HTMLINPUTIMAGEEVENTS_ONABORT                       DISPID_EVMETH_ONABORT

//    DISPIDs for interface IHTMLTextAreaElement

#define DISPID_IHTMLTEXTAREAELEMENT_TYPE                          DISPID_INPUT
#define DISPID_IHTMLTEXTAREAELEMENT_VALUE                         DISPID_A_VALUE
#define DISPID_IHTMLTEXTAREAELEMENT_NAME                          STDPROPID_XOBJ_NAME
#define DISPID_IHTMLTEXTAREAELEMENT_STATUS                        DISPID_INPUT+1
#define DISPID_IHTMLTEXTAREAELEMENT_DISABLED                      STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLTEXTAREAELEMENT_FORM                          DISPID_SITE+4
#define DISPID_IHTMLTEXTAREAELEMENT_DEFAULTVALUE                  DISPID_DEFAULTVALUE
#define DISPID_IHTMLTEXTAREAELEMENT_SELECT                        DISPID_RICHTEXT+5
#define DISPID_IHTMLTEXTAREAELEMENT_ONCHANGE                      DISPID_EVPROP_ONCHANGE
#define DISPID_IHTMLTEXTAREAELEMENT_ONSELECT                      DISPID_EVPROP_ONSELECT
#define DISPID_IHTMLTEXTAREAELEMENT_READONLY                      DISPID_RICHTEXT+4
#define DISPID_IHTMLTEXTAREAELEMENT_ROWS                          DISPID_RICHTEXT+1
#define DISPID_IHTMLTEXTAREAELEMENT_COLS                          DISPID_RICHTEXT+2
#define DISPID_IHTMLTEXTAREAELEMENT_WRAP                          DISPID_RICHTEXT+3
#define DISPID_IHTMLTEXTAREAELEMENT_CREATETEXTRANGE               DISPID_RICHTEXT+6

//    DISPIDs for interface IHTMLButtonElement

#define DISPID_IHTMLBUTTONELEMENT_TYPE                            DISPID_INPUT
#define DISPID_IHTMLBUTTONELEMENT_VALUE                           DISPID_A_VALUE
#define DISPID_IHTMLBUTTONELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLBUTTONELEMENT_STATUS                          DISPID_BUTTON+1
#define DISPID_IHTMLBUTTONELEMENT_DISABLED                        STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLBUTTONELEMENT_FORM                            DISPID_SITE+4
#define DISPID_IHTMLBUTTONELEMENT_CREATETEXTRANGE                 DISPID_BUTTON+2

//    DISPIDs for interface IHTMLMarqueeElement

#define DISPID_IHTMLMARQUEEELEMENT_BGCOLOR                        DISPID_BACKCOLOR
#define DISPID_IHTMLMARQUEEELEMENT_SCROLLDELAY                    DISPID_MARQUEE
#define DISPID_IHTMLMARQUEEELEMENT_DIRECTION                      DISPID_MARQUEE+1
#define DISPID_IHTMLMARQUEEELEMENT_BEHAVIOR                       DISPID_MARQUEE+2
#define DISPID_IHTMLMARQUEEELEMENT_SCROLLAMOUNT                   DISPID_MARQUEE+3
#define DISPID_IHTMLMARQUEEELEMENT_LOOP                           DISPID_MARQUEE+4
#define DISPID_IHTMLMARQUEEELEMENT_VSPACE                         DISPID_MARQUEE+5
#define DISPID_IHTMLMARQUEEELEMENT_HSPACE                         DISPID_MARQUEE+6
#define DISPID_IHTMLMARQUEEELEMENT_ONFINISH                       DISPID_EVPROP_ONFINISH
#define DISPID_IHTMLMARQUEEELEMENT_ONSTART                        DISPID_EVPROP_ONSTART
#define DISPID_IHTMLMARQUEEELEMENT_ONBOUNCE                       DISPID_EVPROP_ONBOUNCE
#define DISPID_IHTMLMARQUEEELEMENT_WIDTH                          STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLMARQUEEELEMENT_HEIGHT                         STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLMARQUEEELEMENT_TRUESPEED                      DISPID_MARQUEE+7
#define DISPID_IHTMLMARQUEEELEMENT_START                          DISPID_MARQUEE+10
#define DISPID_IHTMLMARQUEEELEMENT_STOP                           DISPID_MARQUEE+11

//    DISPIDs for event set HTMLMarqueeElementEvents2

#define DISPID_HTMLMARQUEEELEMENTEVENTS2_ONBOUNCE                 DISPID_EVMETH_ONBOUNCE
#define DISPID_HTMLMARQUEEELEMENTEVENTS2_ONFINISH                 DISPID_EVMETH_ONFINISH
#define DISPID_HTMLMARQUEEELEMENTEVENTS2_ONSTART                  DISPID_EVMETH_ONSTART

//    DISPIDs for event set HTMLMarqueeElementEvents

#define DISPID_HTMLMARQUEEELEMENTEVENTS_ONBOUNCE                  DISPID_EVMETH_ONBOUNCE
#define DISPID_HTMLMARQUEEELEMENTEVENTS_ONFINISH                  DISPID_EVMETH_ONFINISH
#define DISPID_HTMLMARQUEEELEMENTEVENTS_ONSTART                   DISPID_EVMETH_ONSTART

//    DISPIDs for interface IHTMLHtmlElement

#define DISPID_IHTMLHTMLELEMENT_VERSION                           DISPID_HEDELEMS+1

//    DISPIDs for interface IHTMLHeadElement

#define DISPID_IHTMLHEADELEMENT_PROFILE                           DISPID_HEDELEMS+1

//    DISPIDs for interface IHTMLTitleElement

#define DISPID_IHTMLTITLEELEMENT_TEXT                             DISPID_A_VALUE

//    DISPIDs for interface IHTMLMetaElement

#define DISPID_IHTMLMETAELEMENT_HTTPEQUIV                         DISPID_HEDELEMS+1
#define DISPID_IHTMLMETAELEMENT_CONTENT                           DISPID_HEDELEMS+2
#define DISPID_IHTMLMETAELEMENT_NAME                              STDPROPID_XOBJ_NAME
#define DISPID_IHTMLMETAELEMENT_URL                               DISPID_HEDELEMS+3
#define DISPID_IHTMLMETAELEMENT_CHARSET                           DISPID_HEDELEMS+13

//    DISPIDs for interface IHTMLMetaElement2

#define DISPID_IHTMLMETAELEMENT2_SCHEME                           DISPID_HEDELEMS+20

//    DISPIDs for interface IHTMLBaseElement

#define DISPID_IHTMLBASEELEMENT_HREF                              DISPID_HEDELEMS+3
#define DISPID_IHTMLBASEELEMENT_TARGET                            DISPID_HEDELEMS+4

//    DISPIDs for interface IHTMLIsIndexElement

#define DISPID_IHTMLISINDEXELEMENT_PROMPT                         DISPID_HEDELEMS+10
#define DISPID_IHTMLISINDEXELEMENT_ACTION                         DISPID_HEDELEMS+11

//    DISPIDs for interface IHTMLIsIndexElement2

#define DISPID_IHTMLISINDEXELEMENT2_FORM                          DISPID_HEDELEMS+12

//    DISPIDs for interface IHTMLNextIdElement

#define DISPID_IHTMLNEXTIDELEMENT_N                               DISPID_HEDELEMS+12

//    DISPIDs for interface IHTMLBaseFontElement

#define DISPID_IHTMLBASEFONTELEMENT_COLOR                         DISPID_A_COLOR
#define DISPID_IHTMLBASEFONTELEMENT_FACE                          DISPID_A_FONTFACE
#define DISPID_IHTMLBASEFONTELEMENT_SIZE                          DISPID_A_BASEFONT

//    DISPIDs for interface IOmHistory

#define DISPID_IOMHISTORY_LENGTH                                  DISPID_HISTORY
#define DISPID_IOMHISTORY_BACK                                    DISPID_HISTORY+1
#define DISPID_IOMHISTORY_FORWARD                                 DISPID_HISTORY+2
#define DISPID_IOMHISTORY_GO                                      DISPID_HISTORY+3

//    DISPIDs for interface IHTMLMimeTypesCollection

#define DISPID_IHTMLMIMETYPESCOLLECTION_LENGTH                    1

//    DISPIDs for interface IHTMLPluginsCollection

#define DISPID_IHTMLPLUGINSCOLLECTION_LENGTH                      1
#define DISPID_IHTMLPLUGINSCOLLECTION_REFRESH                     2

//    DISPIDs for interface IHTMLOpsProfile

#define DISPID_IHTMLOPSPROFILE_ADDREQUEST                         1
#define DISPID_IHTMLOPSPROFILE_CLEARREQUEST                       2
#define DISPID_IHTMLOPSPROFILE_DOREQUEST                          3
#define DISPID_IHTMLOPSPROFILE_GETATTRIBUTE                       4
#define DISPID_IHTMLOPSPROFILE_SETATTRIBUTE                       5
#define DISPID_IHTMLOPSPROFILE_COMMITCHANGES                      6
#define DISPID_IHTMLOPSPROFILE_ADDREADREQUEST                     7
#define DISPID_IHTMLOPSPROFILE_DOREADREQUEST                      8
#define DISPID_IHTMLOPSPROFILE_DOWRITEREQUEST                     9

//    DISPIDs for interface IOmNavigator

#define DISPID_IOMNAVIGATOR_APPCODENAME                           DISPID_NAVIGATOR
#define DISPID_IOMNAVIGATOR_APPNAME                               DISPID_NAVIGATOR+1
#define DISPID_IOMNAVIGATOR_APPVERSION                            DISPID_NAVIGATOR+2
#define DISPID_IOMNAVIGATOR_USERAGENT                             DISPID_NAVIGATOR+3
#define DISPID_IOMNAVIGATOR_JAVAENABLED                           DISPID_NAVIGATOR+4
#define DISPID_IOMNAVIGATOR_TAINTENABLED                          DISPID_NAVIGATOR+5
#define DISPID_IOMNAVIGATOR_MIMETYPES                             DISPID_NAVIGATOR+6
#define DISPID_IOMNAVIGATOR_PLUGINS                               DISPID_NAVIGATOR+7
#define DISPID_IOMNAVIGATOR_COOKIEENABLED                         DISPID_NAVIGATOR+8
#define DISPID_IOMNAVIGATOR_OPSPROFILE                            DISPID_NAVIGATOR+9
#define DISPID_IOMNAVIGATOR_TOSTRING                              DISPID_NAVIGATOR+10
#define DISPID_IOMNAVIGATOR_CPUCLASS                              DISPID_NAVIGATOR+11
#define DISPID_IOMNAVIGATOR_SYSTEMLANGUAGE                        DISPID_NAVIGATOR+12
#define DISPID_IOMNAVIGATOR_BROWSERLANGUAGE                       DISPID_NAVIGATOR+13
#define DISPID_IOMNAVIGATOR_USERLANGUAGE                          DISPID_NAVIGATOR+14
#define DISPID_IOMNAVIGATOR_PLATFORM                              DISPID_NAVIGATOR+15
#define DISPID_IOMNAVIGATOR_APPMINORVERSION                       DISPID_NAVIGATOR+16
#define DISPID_IOMNAVIGATOR_CONNECTIONSPEED                       DISPID_NAVIGATOR+17
#define DISPID_IOMNAVIGATOR_ONLINE                                DISPID_NAVIGATOR+18
#define DISPID_IOMNAVIGATOR_USERPROFILE                           DISPID_NAVIGATOR+19

//    DISPIDs for interface IHTMLLocation

#define DISPID_IHTMLLOCATION_HREF                                 DISPID_VALUE
#define DISPID_IHTMLLOCATION_PROTOCOL                             DISPID_LOCATION
#define DISPID_IHTMLLOCATION_HOST                                 DISPID_LOCATION+1
#define DISPID_IHTMLLOCATION_HOSTNAME                             DISPID_LOCATION+2
#define DISPID_IHTMLLOCATION_PORT                                 DISPID_LOCATION+3
#define DISPID_IHTMLLOCATION_PATHNAME                             DISPID_LOCATION+4
#define DISPID_IHTMLLOCATION_SEARCH                               DISPID_LOCATION+5
#define DISPID_IHTMLLOCATION_HASH                                 DISPID_LOCATION+6
#define DISPID_IHTMLLOCATION_RELOAD                               DISPID_LOCATION+7
#define DISPID_IHTMLLOCATION_REPLACE                              DISPID_LOCATION+8
#define DISPID_IHTMLLOCATION_ASSIGN                               DISPID_LOCATION+9
#define DISPID_IHTMLLOCATION_TOSTRING                             DISPID_LOCATION+10

//    DISPIDs for interface IHTMLBookmarkCollection

#define DISPID_IHTMLBOOKMARKCOLLECTION_LENGTH                     DISPID_OPTIONS_COL+1
#define DISPID_IHTMLBOOKMARKCOLLECTION__NEWENUM                   DISPID_NEWENUM
#define DISPID_IHTMLBOOKMARKCOLLECTION_ITEM                       DISPID_VALUE

//    DISPIDs for interface IHTMLDataTransfer

#define DISPID_IHTMLDATATRANSFER_SETDATA                          DISPID_DATATRANSFER+1
#define DISPID_IHTMLDATATRANSFER_GETDATA                          DISPID_DATATRANSFER+2
#define DISPID_IHTMLDATATRANSFER_CLEARDATA                        DISPID_DATATRANSFER+3
#define DISPID_IHTMLDATATRANSFER_DROPEFFECT                       DISPID_DATATRANSFER+4
#define DISPID_IHTMLDATATRANSFER_EFFECTALLOWED                    DISPID_DATATRANSFER+5

//    DISPIDs for interface IHTMLEventObj

#define DISPID_IHTMLEVENTOBJ_SRCELEMENT                           DISPID_EVENTOBJ+1
#define DISPID_IHTMLEVENTOBJ_ALTKEY                               DISPID_EVENTOBJ+2
#define DISPID_IHTMLEVENTOBJ_CTRLKEY                              DISPID_EVENTOBJ+3
#define DISPID_IHTMLEVENTOBJ_SHIFTKEY                             DISPID_EVENTOBJ+4
#define DISPID_IHTMLEVENTOBJ_RETURNVALUE                          DISPID_EVENTOBJ+7
#define DISPID_IHTMLEVENTOBJ_CANCELBUBBLE                         DISPID_EVENTOBJ+8
#define DISPID_IHTMLEVENTOBJ_FROMELEMENT                          DISPID_EVENTOBJ+9
#define DISPID_IHTMLEVENTOBJ_TOELEMENT                            DISPID_EVENTOBJ+10
#define DISPID_IHTMLEVENTOBJ_KEYCODE                              DISPID_EVENTOBJ+11
#define DISPID_IHTMLEVENTOBJ_BUTTON                               DISPID_EVENTOBJ+12
#define DISPID_IHTMLEVENTOBJ_TYPE                                 DISPID_EVENTOBJ+13
#define DISPID_IHTMLEVENTOBJ_QUALIFIER                            DISPID_EVENTOBJ+14
#define DISPID_IHTMLEVENTOBJ_REASON                               DISPID_EVENTOBJ+15
#define DISPID_IHTMLEVENTOBJ_X                                    DISPID_EVENTOBJ+5
#define DISPID_IHTMLEVENTOBJ_Y                                    DISPID_EVENTOBJ+6
#define DISPID_IHTMLEVENTOBJ_CLIENTX                              DISPID_EVENTOBJ+20
#define DISPID_IHTMLEVENTOBJ_CLIENTY                              DISPID_EVENTOBJ+21
#define DISPID_IHTMLEVENTOBJ_OFFSETX                              DISPID_EVENTOBJ+22
#define DISPID_IHTMLEVENTOBJ_OFFSETY                              DISPID_EVENTOBJ+23
#define DISPID_IHTMLEVENTOBJ_SCREENX                              DISPID_EVENTOBJ+24
#define DISPID_IHTMLEVENTOBJ_SCREENY                              DISPID_EVENTOBJ+25
#define DISPID_IHTMLEVENTOBJ_SRCFILTER                            DISPID_EVENTOBJ+26

//    DISPIDs for interface IHTMLEventObj2

#define DISPID_IHTMLEVENTOBJ2_SETATTRIBUTE                        DISPID_HTMLOBJECT+1
#define DISPID_IHTMLEVENTOBJ2_GETATTRIBUTE                        DISPID_HTMLOBJECT+2
#define DISPID_IHTMLEVENTOBJ2_REMOVEATTRIBUTE                     DISPID_HTMLOBJECT+3
#define DISPID_IHTMLEVENTOBJ2_PROPERTYNAME                        DISPID_EVENTOBJ+27
#define DISPID_IHTMLEVENTOBJ2_BOOKMARKS                           DISPID_EVENTOBJ+31
#define DISPID_IHTMLEVENTOBJ2_RECORDSET                           DISPID_EVENTOBJ+32
#define DISPID_IHTMLEVENTOBJ2_DATAFLD                             DISPID_EVENTOBJ+33
#define DISPID_IHTMLEVENTOBJ2_BOUNDELEMENTS                       DISPID_EVENTOBJ+34
#define DISPID_IHTMLEVENTOBJ2_REPEAT                              DISPID_EVENTOBJ+35
#define DISPID_IHTMLEVENTOBJ2_SRCURN                              DISPID_EVENTOBJ+36
#define DISPID_IHTMLEVENTOBJ2_SRCELEMENT                          DISPID_EVENTOBJ+1
#define DISPID_IHTMLEVENTOBJ2_ALTKEY                              DISPID_EVENTOBJ+2
#define DISPID_IHTMLEVENTOBJ2_CTRLKEY                             DISPID_EVENTOBJ+3
#define DISPID_IHTMLEVENTOBJ2_SHIFTKEY                            DISPID_EVENTOBJ+4
#define DISPID_IHTMLEVENTOBJ2_FROMELEMENT                         DISPID_EVENTOBJ+9
#define DISPID_IHTMLEVENTOBJ2_TOELEMENT                           DISPID_EVENTOBJ+10
#define DISPID_IHTMLEVENTOBJ2_BUTTON                              DISPID_EVENTOBJ+12
#define DISPID_IHTMLEVENTOBJ2_TYPE                                DISPID_EVENTOBJ+13
#define DISPID_IHTMLEVENTOBJ2_QUALIFIER                           DISPID_EVENTOBJ+14
#define DISPID_IHTMLEVENTOBJ2_REASON                              DISPID_EVENTOBJ+15
#define DISPID_IHTMLEVENTOBJ2_X                                   DISPID_EVENTOBJ+5
#define DISPID_IHTMLEVENTOBJ2_Y                                   DISPID_EVENTOBJ+6
#define DISPID_IHTMLEVENTOBJ2_CLIENTX                             DISPID_EVENTOBJ+20
#define DISPID_IHTMLEVENTOBJ2_CLIENTY                             DISPID_EVENTOBJ+21
#define DISPID_IHTMLEVENTOBJ2_OFFSETX                             DISPID_EVENTOBJ+22
#define DISPID_IHTMLEVENTOBJ2_OFFSETY                             DISPID_EVENTOBJ+23
#define DISPID_IHTMLEVENTOBJ2_SCREENX                             DISPID_EVENTOBJ+24
#define DISPID_IHTMLEVENTOBJ2_SCREENY                             DISPID_EVENTOBJ+25
#define DISPID_IHTMLEVENTOBJ2_SRCFILTER                           DISPID_EVENTOBJ+26
#define DISPID_IHTMLEVENTOBJ2_DATATRANSFER                        DISPID_EVENTOBJ+37

//    DISPIDs for interface IHTMLEventObj3

#define DISPID_IHTMLEVENTOBJ3_CONTENTOVERFLOW                     DISPID_EVENTOBJ+38
#define DISPID_IHTMLEVENTOBJ3_SHIFTLEFT                           DISPID_EVENTOBJ+39
#define DISPID_IHTMLEVENTOBJ3_ALTLEFT                             DISPID_EVENTOBJ+40
#define DISPID_IHTMLEVENTOBJ3_CTRLLEFT                            DISPID_EVENTOBJ+41
#define DISPID_IHTMLEVENTOBJ3_IMECOMPOSITIONCHANGE                DISPID_EVENTOBJ+42
#define DISPID_IHTMLEVENTOBJ3_IMENOTIFYCOMMAND                    DISPID_EVENTOBJ+43
#define DISPID_IHTMLEVENTOBJ3_IMENOTIFYDATA                       DISPID_EVENTOBJ+44
#define DISPID_IHTMLEVENTOBJ3_IMEREQUEST                          DISPID_EVENTOBJ+46
#define DISPID_IHTMLEVENTOBJ3_IMEREQUESTDATA                      DISPID_EVENTOBJ+47
#define DISPID_IHTMLEVENTOBJ3_KEYBOARDLAYOUT                      DISPID_EVENTOBJ+45
#define DISPID_IHTMLEVENTOBJ3_BEHAVIORCOOKIE                      DISPID_EVENTOBJ+48
#define DISPID_IHTMLEVENTOBJ3_BEHAVIORPART                        DISPID_EVENTOBJ+49
#define DISPID_IHTMLEVENTOBJ3_NEXTPAGE                            DISPID_EVENTOBJ+50

//    DISPIDs for interface IHTMLEventObj4

#define DISPID_IHTMLEVENTOBJ4_WHEELDELTA                          DISPID_EVENTOBJ+51

//    DISPIDs for interface IHTMLFramesCollection2

#define DISPID_IHTMLFRAMESCOLLECTION2_ITEM                        0
#define DISPID_IHTMLFRAMESCOLLECTION2_LENGTH                      1001

//    DISPIDs for interface IHTMLScreen

#define DISPID_IHTMLSCREEN_COLORDEPTH                             DISPID_SCREEN+1
#define DISPID_IHTMLSCREEN_BUFFERDEPTH                            DISPID_SCREEN+2
#define DISPID_IHTMLSCREEN_WIDTH                                  DISPID_SCREEN+3
#define DISPID_IHTMLSCREEN_HEIGHT                                 DISPID_SCREEN+4
#define DISPID_IHTMLSCREEN_UPDATEINTERVAL                         DISPID_SCREEN+5
#define DISPID_IHTMLSCREEN_AVAILHEIGHT                            DISPID_SCREEN+6
#define DISPID_IHTMLSCREEN_AVAILWIDTH                             DISPID_SCREEN+7
#define DISPID_IHTMLSCREEN_FONTSMOOTHINGENABLED                   DISPID_SCREEN+8

//    DISPIDs for interface IHTMLScreen2

#define DISPID_IHTMLSCREEN2_LOGICALXDPI                           DISPID_SCREEN+9
#define DISPID_IHTMLSCREEN2_LOGICALYDPI                           DISPID_SCREEN+10
#define DISPID_IHTMLSCREEN2_DEVICEXDPI                            DISPID_SCREEN+11
#define DISPID_IHTMLSCREEN2_DEVICEYDPI                            DISPID_SCREEN+12

//    DISPIDs for interface IHTMLWindow2

#define DISPID_IHTMLWINDOW2_FRAMES                                1100
#define DISPID_IHTMLWINDOW2_DEFAULTSTATUS                         1101
#define DISPID_IHTMLWINDOW2_STATUS                                1102
#define DISPID_IHTMLWINDOW2_SETTIMEOUT                            1172
#define DISPID_IHTMLWINDOW2_CLEARTIMEOUT                          1104
#define DISPID_IHTMLWINDOW2_ALERT                                 1105
#define DISPID_IHTMLWINDOW2_CONFIRM                               1110
#define DISPID_IHTMLWINDOW2_PROMPT                                1111
#define DISPID_IHTMLWINDOW2_IMAGE                                 1125
#define DISPID_IHTMLWINDOW2_LOCATION                              14
#define DISPID_IHTMLWINDOW2_HISTORY                               2
#define DISPID_IHTMLWINDOW2_CLOSE                                 3
#define DISPID_IHTMLWINDOW2_OPENER                                4
#define DISPID_IHTMLWINDOW2_NAVIGATOR                             5
#define DISPID_IHTMLWINDOW2_NAME                                  11
#define DISPID_IHTMLWINDOW2_PARENT                                12
#define DISPID_IHTMLWINDOW2_OPEN                                  13
#define DISPID_IHTMLWINDOW2_SELF                                  20
#define DISPID_IHTMLWINDOW2_TOP                                   21
#define DISPID_IHTMLWINDOW2_WINDOW                                22
#define DISPID_IHTMLWINDOW2_NAVIGATE                              25
#define DISPID_IHTMLWINDOW2_ONFOCUS                               DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLWINDOW2_ONBLUR                                DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLWINDOW2_ONLOAD                                DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLWINDOW2_ONBEFOREUNLOAD                        DISPID_EVPROP_ONBEFOREUNLOAD
#define DISPID_IHTMLWINDOW2_ONUNLOAD                              DISPID_EVPROP_ONUNLOAD
#define DISPID_IHTMLWINDOW2_ONHELP                                DISPID_EVPROP_ONHELP
#define DISPID_IHTMLWINDOW2_ONERROR                               DISPID_EVPROP_ONERROR
#define DISPID_IHTMLWINDOW2_ONRESIZE                              DISPID_EVPROP_ONRESIZE
#define DISPID_IHTMLWINDOW2_ONSCROLL                              DISPID_EVPROP_ONSCROLL
#define DISPID_IHTMLWINDOW2_DOCUMENT                              1151
#define DISPID_IHTMLWINDOW2_EVENT                                 1152
#define DISPID_IHTMLWINDOW2__NEWENUM                              1153
#define DISPID_IHTMLWINDOW2_SHOWMODALDIALOG                       1154
#define DISPID_IHTMLWINDOW2_SHOWHELP                              1155
#define DISPID_IHTMLWINDOW2_SCREEN                                1156
#define DISPID_IHTMLWINDOW2_OPTION                                1157
#define DISPID_IHTMLWINDOW2_FOCUS                                 1158
#define DISPID_IHTMLWINDOW2_CLOSED                                23
#define DISPID_IHTMLWINDOW2_BLUR                                  1159
#define DISPID_IHTMLWINDOW2_SCROLL                                1160
#define DISPID_IHTMLWINDOW2_CLIENTINFORMATION                     1161
#define DISPID_IHTMLWINDOW2_SETINTERVAL                           1173
#define DISPID_IHTMLWINDOW2_CLEARINTERVAL                         1163
#define DISPID_IHTMLWINDOW2_OFFSCREENBUFFERING                    1164
#define DISPID_IHTMLWINDOW2_EXECSCRIPT                            1165
#define DISPID_IHTMLWINDOW2_TOSTRING                              1166
#define DISPID_IHTMLWINDOW2_SCROLLBY                              1167
#define DISPID_IHTMLWINDOW2_SCROLLTO                              1168
#define DISPID_IHTMLWINDOW2_MOVETO                                6
#define DISPID_IHTMLWINDOW2_MOVEBY                                7
#define DISPID_IHTMLWINDOW2_RESIZETO                              9
#define DISPID_IHTMLWINDOW2_RESIZEBY                              8
#define DISPID_IHTMLWINDOW2_EXTERNAL                              1169

//    DISPIDs for interface IHTMLWindow3

#define DISPID_IHTMLWINDOW3_SCREENLEFT                            1170
#define DISPID_IHTMLWINDOW3_SCREENTOP                             1171
#define DISPID_IHTMLWINDOW3_ATTACHEVENT                           DISPID_HTMLOBJECT+7
#define DISPID_IHTMLWINDOW3_DETACHEVENT                           DISPID_HTMLOBJECT+8
#define DISPID_IHTMLWINDOW3_SETTIMEOUT                            1103
#define DISPID_IHTMLWINDOW3_SETINTERVAL                           1162
#define DISPID_IHTMLWINDOW3_PRINT                                 1174
#define DISPID_IHTMLWINDOW3_ONBEFOREPRINT                         DISPID_EVPROP_ONBEFOREPRINT
#define DISPID_IHTMLWINDOW3_ONAFTERPRINT                          DISPID_EVPROP_ONAFTERPRINT
#define DISPID_IHTMLWINDOW3_CLIPBOARDDATA                         1175
#define DISPID_IHTMLWINDOW3_SHOWMODELESSDIALOG                    1176

//    DISPIDs for interface IHTMLWindow4

#define DISPID_IHTMLWINDOW4_CREATEPOPUP                           1180
#define DISPID_IHTMLWINDOW4_FRAMEELEMENT                          1181

//    DISPIDs for event set HTMLWindowEvents2

#define DISPID_HTMLWINDOWEVENTS2_ONLOAD                           DISPID_EVMETH_ONLOAD
#define DISPID_HTMLWINDOWEVENTS2_ONUNLOAD                         DISPID_EVMETH_ONUNLOAD
#define DISPID_HTMLWINDOWEVENTS2_ONHELP                           DISPID_EVMETH_ONHELP
#define DISPID_HTMLWINDOWEVENTS2_ONFOCUS                          DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLWINDOWEVENTS2_ONBLUR                           DISPID_EVMETH_ONBLUR
#define DISPID_HTMLWINDOWEVENTS2_ONERROR                          DISPID_EVMETH_ONERROR
#define DISPID_HTMLWINDOWEVENTS2_ONRESIZE                         DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLWINDOWEVENTS2_ONSCROLL                         DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLWINDOWEVENTS2_ONBEFOREUNLOAD                   DISPID_EVMETH_ONBEFOREUNLOAD
#define DISPID_HTMLWINDOWEVENTS2_ONBEFOREPRINT                    DISPID_EVMETH_ONBEFOREPRINT
#define DISPID_HTMLWINDOWEVENTS2_ONAFTERPRINT                     DISPID_EVMETH_ONAFTERPRINT

//    DISPIDs for event set HTMLWindowEvents

#define DISPID_HTMLWINDOWEVENTS_ONLOAD                            DISPID_EVMETH_ONLOAD
#define DISPID_HTMLWINDOWEVENTS_ONUNLOAD                          DISPID_EVMETH_ONUNLOAD
#define DISPID_HTMLWINDOWEVENTS_ONHELP                            DISPID_EVMETH_ONHELP
#define DISPID_HTMLWINDOWEVENTS_ONFOCUS                           DISPID_EVMETH_ONFOCUS
#define DISPID_HTMLWINDOWEVENTS_ONBLUR                            DISPID_EVMETH_ONBLUR
#define DISPID_HTMLWINDOWEVENTS_ONERROR                           DISPID_EVMETH_ONERROR
#define DISPID_HTMLWINDOWEVENTS_ONRESIZE                          DISPID_EVMETH_ONRESIZE
#define DISPID_HTMLWINDOWEVENTS_ONSCROLL                          DISPID_EVMETH_ONSCROLL
#define DISPID_HTMLWINDOWEVENTS_ONBEFOREUNLOAD                    DISPID_EVMETH_ONBEFOREUNLOAD
#define DISPID_HTMLWINDOWEVENTS_ONBEFOREPRINT                     DISPID_EVMETH_ONBEFOREPRINT
#define DISPID_HTMLWINDOWEVENTS_ONAFTERPRINT                      DISPID_EVMETH_ONAFTERPRINT

//    DISPIDs for interface IHTMLDocument

#define DISPID_IHTMLDOCUMENT_SCRIPT                               DISPID_OMDOCUMENT+1

//    DISPIDs for interface IHTMLDocument2

#define DISPID_IHTMLDOCUMENT2_ALL                                 DISPID_OMDOCUMENT+3
#define DISPID_IHTMLDOCUMENT2_BODY                                DISPID_OMDOCUMENT+4
#define DISPID_IHTMLDOCUMENT2_ACTIVEELEMENT                       DISPID_OMDOCUMENT+5
#define DISPID_IHTMLDOCUMENT2_IMAGES                              DISPID_OMDOCUMENT+11
#define DISPID_IHTMLDOCUMENT2_APPLETS                             DISPID_OMDOCUMENT+8
#define DISPID_IHTMLDOCUMENT2_LINKS                               DISPID_OMDOCUMENT+9
#define DISPID_IHTMLDOCUMENT2_FORMS                               DISPID_OMDOCUMENT+10
#define DISPID_IHTMLDOCUMENT2_ANCHORS                             DISPID_OMDOCUMENT+7
#define DISPID_IHTMLDOCUMENT2_TITLE                               DISPID_OMDOCUMENT+12
#define DISPID_IHTMLDOCUMENT2_SCRIPTS                             DISPID_OMDOCUMENT+13
#define DISPID_IHTMLDOCUMENT2_DESIGNMODE                          DISPID_OMDOCUMENT+14
#define DISPID_IHTMLDOCUMENT2_SELECTION                           DISPID_OMDOCUMENT+17
#define DISPID_IHTMLDOCUMENT2_READYSTATE                          DISPID_OMDOCUMENT+18
#define DISPID_IHTMLDOCUMENT2_FRAMES                              DISPID_OMDOCUMENT+19
#define DISPID_IHTMLDOCUMENT2_EMBEDS                              DISPID_OMDOCUMENT+15
#define DISPID_IHTMLDOCUMENT2_PLUGINS                             DISPID_OMDOCUMENT+21
#define DISPID_IHTMLDOCUMENT2_ALINKCOLOR                          DISPID_OMDOCUMENT+22
#define DISPID_IHTMLDOCUMENT2_BGCOLOR                             DISPID_BACKCOLOR
#define DISPID_IHTMLDOCUMENT2_FGCOLOR                             DISPID_A_COLOR
#define DISPID_IHTMLDOCUMENT2_LINKCOLOR                           DISPID_OMDOCUMENT+24
#define DISPID_IHTMLDOCUMENT2_VLINKCOLOR                          DISPID_OMDOCUMENT+23
#define DISPID_IHTMLDOCUMENT2_REFERRER                            DISPID_OMDOCUMENT+27
#define DISPID_IHTMLDOCUMENT2_LOCATION                            DISPID_OMDOCUMENT+26
#define DISPID_IHTMLDOCUMENT2_LASTMODIFIED                        DISPID_OMDOCUMENT+28
#define DISPID_IHTMLDOCUMENT2_URL                                 DISPID_OMDOCUMENT+25
#define DISPID_IHTMLDOCUMENT2_DOMAIN                              DISPID_OMDOCUMENT+29
#define DISPID_IHTMLDOCUMENT2_COOKIE                              DISPID_OMDOCUMENT+30
#define DISPID_IHTMLDOCUMENT2_EXPANDO                             DISPID_OMDOCUMENT+31
#define DISPID_IHTMLDOCUMENT2_CHARSET                             DISPID_OMDOCUMENT+32
#define DISPID_IHTMLDOCUMENT2_DEFAULTCHARSET                      DISPID_OMDOCUMENT+33
#define DISPID_IHTMLDOCUMENT2_MIMETYPE                            DISPID_OMDOCUMENT+41
#define DISPID_IHTMLDOCUMENT2_FILESIZE                            DISPID_OMDOCUMENT+42
#define DISPID_IHTMLDOCUMENT2_FILECREATEDDATE                     DISPID_OMDOCUMENT+43
#define DISPID_IHTMLDOCUMENT2_FILEMODIFIEDDATE                    DISPID_OMDOCUMENT+44
#define DISPID_IHTMLDOCUMENT2_FILEUPDATEDDATE                     DISPID_OMDOCUMENT+45
#define DISPID_IHTMLDOCUMENT2_SECURITY                            DISPID_OMDOCUMENT+46
#define DISPID_IHTMLDOCUMENT2_PROTOCOL                            DISPID_OMDOCUMENT+47
#define DISPID_IHTMLDOCUMENT2_NAMEPROP                            DISPID_OMDOCUMENT+48
#define DISPID_IHTMLDOCUMENT2_WRITE                               DISPID_OMDOCUMENT+54
#define DISPID_IHTMLDOCUMENT2_WRITELN                             DISPID_OMDOCUMENT+55
#define DISPID_IHTMLDOCUMENT2_OPEN                                DISPID_OMDOCUMENT+56
#define DISPID_IHTMLDOCUMENT2_CLOSE                               DISPID_OMDOCUMENT+57
#define DISPID_IHTMLDOCUMENT2_CLEAR                               DISPID_OMDOCUMENT+58
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDSUPPORTED               DISPID_OMDOCUMENT+59
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDENABLED                 DISPID_OMDOCUMENT+60
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDSTATE                   DISPID_OMDOCUMENT+61
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDINDETERM                DISPID_OMDOCUMENT+62
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDTEXT                    DISPID_OMDOCUMENT+63
#define DISPID_IHTMLDOCUMENT2_QUERYCOMMANDVALUE                   DISPID_OMDOCUMENT+64
#define DISPID_IHTMLDOCUMENT2_EXECCOMMAND                         DISPID_OMDOCUMENT+65
#define DISPID_IHTMLDOCUMENT2_EXECCOMMANDSHOWHELP                 DISPID_OMDOCUMENT+66
#define DISPID_IHTMLDOCUMENT2_CREATEELEMENT                       DISPID_OMDOCUMENT+67
#define DISPID_IHTMLDOCUMENT2_ONHELP                              DISPID_EVPROP_ONHELP
#define DISPID_IHTMLDOCUMENT2_ONCLICK                             DISPID_EVPROP_ONCLICK
#define DISPID_IHTMLDOCUMENT2_ONDBLCLICK                          DISPID_EVPROP_ONDBLCLICK
#define DISPID_IHTMLDOCUMENT2_ONKEYUP                             DISPID_EVPROP_ONKEYUP
#define DISPID_IHTMLDOCUMENT2_ONKEYDOWN                           DISPID_EVPROP_ONKEYDOWN
#define DISPID_IHTMLDOCUMENT2_ONKEYPRESS                          DISPID_EVPROP_ONKEYPRESS
#define DISPID_IHTMLDOCUMENT2_ONMOUSEUP                           DISPID_EVPROP_ONMOUSEUP
#define DISPID_IHTMLDOCUMENT2_ONMOUSEDOWN                         DISPID_EVPROP_ONMOUSEDOWN
#define DISPID_IHTMLDOCUMENT2_ONMOUSEMOVE                         DISPID_EVPROP_ONMOUSEMOVE
#define DISPID_IHTMLDOCUMENT2_ONMOUSEOUT                          DISPID_EVPROP_ONMOUSEOUT
#define DISPID_IHTMLDOCUMENT2_ONMOUSEOVER                         DISPID_EVPROP_ONMOUSEOVER
#define DISPID_IHTMLDOCUMENT2_ONREADYSTATECHANGE                  DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLDOCUMENT2_ONAFTERUPDATE                       DISPID_EVPROP_ONAFTERUPDATE
#define DISPID_IHTMLDOCUMENT2_ONROWEXIT                           DISPID_EVPROP_ONROWEXIT
#define DISPID_IHTMLDOCUMENT2_ONROWENTER                          DISPID_EVPROP_ONROWENTER
#define DISPID_IHTMLDOCUMENT2_ONDRAGSTART                         DISPID_EVPROP_ONDRAGSTART
#define DISPID_IHTMLDOCUMENT2_ONSELECTSTART                       DISPID_EVPROP_ONSELECTSTART
#define DISPID_IHTMLDOCUMENT2_ELEMENTFROMPOINT                    DISPID_OMDOCUMENT+68
#define DISPID_IHTMLDOCUMENT2_PARENTWINDOW                        DISPID_OMDOCUMENT+34
#define DISPID_IHTMLDOCUMENT2_STYLESHEETS                         DISPID_OMDOCUMENT+69
#define DISPID_IHTMLDOCUMENT2_ONBEFOREUPDATE                      DISPID_EVPROP_ONBEFOREUPDATE
#define DISPID_IHTMLDOCUMENT2_ONERRORUPDATE                       DISPID_EVPROP_ONERRORUPDATE
#define DISPID_IHTMLDOCUMENT2_TOSTRING                            DISPID_OMDOCUMENT+70
#define DISPID_IHTMLDOCUMENT2_CREATESTYLESHEET                    DISPID_OMDOCUMENT+71

//    DISPIDs for interface IHTMLDocument3

#define DISPID_IHTMLDOCUMENT3_RELEASECAPTURE                      DISPID_OMDOCUMENT+72
#define DISPID_IHTMLDOCUMENT3_RECALC                              DISPID_OMDOCUMENT+73
#define DISPID_IHTMLDOCUMENT3_CREATETEXTNODE                      DISPID_OMDOCUMENT+74
#define DISPID_IHTMLDOCUMENT3_DOCUMENTELEMENT                     DISPID_OMDOCUMENT+75
#define DISPID_IHTMLDOCUMENT3_UNIQUEID                            DISPID_OMDOCUMENT+77
#define DISPID_IHTMLDOCUMENT3_ATTACHEVENT                         DISPID_HTMLOBJECT+7
#define DISPID_IHTMLDOCUMENT3_DETACHEVENT                         DISPID_HTMLOBJECT+8
#define DISPID_IHTMLDOCUMENT3_ONROWSDELETE                        DISPID_EVPROP_ONROWSDELETE
#define DISPID_IHTMLDOCUMENT3_ONROWSINSERTED                      DISPID_EVPROP_ONROWSINSERTED
#define DISPID_IHTMLDOCUMENT3_ONCELLCHANGE                        DISPID_EVPROP_ONCELLCHANGE
#define DISPID_IHTMLDOCUMENT3_ONDATASETCHANGED                    DISPID_EVPROP_ONDATASETCHANGED
#define DISPID_IHTMLDOCUMENT3_ONDATAAVAILABLE                     DISPID_EVPROP_ONDATAAVAILABLE
#define DISPID_IHTMLDOCUMENT3_ONDATASETCOMPLETE                   DISPID_EVPROP_ONDATASETCOMPLETE
#define DISPID_IHTMLDOCUMENT3_ONPROPERTYCHANGE                    DISPID_EVPROP_ONPROPERTYCHANGE
#define DISPID_IHTMLDOCUMENT3_DIR                                 DISPID_A_DIR
#define DISPID_IHTMLDOCUMENT3_ONCONTEXTMENU                       DISPID_EVPROP_ONCONTEXTMENU
#define DISPID_IHTMLDOCUMENT3_ONSTOP                              DISPID_EVPROP_ONSTOP
#define DISPID_IHTMLDOCUMENT3_CREATEDOCUMENTFRAGMENT              DISPID_OMDOCUMENT+76
#define DISPID_IHTMLDOCUMENT3_PARENTDOCUMENT                      DISPID_OMDOCUMENT+78
#define DISPID_IHTMLDOCUMENT3_ENABLEDOWNLOAD                      DISPID_OMDOCUMENT+79
#define DISPID_IHTMLDOCUMENT3_BASEURL                             DISPID_OMDOCUMENT+80
#define DISPID_IHTMLDOCUMENT3_CHILDNODES                          DISPID_ELEMENT+49
#define DISPID_IHTMLDOCUMENT3_INHERITSTYLESHEETS                  DISPID_OMDOCUMENT+82
#define DISPID_IHTMLDOCUMENT3_ONBEFOREEDITFOCUS                   DISPID_EVPROP_ONBEFOREEDITFOCUS
#define DISPID_IHTMLDOCUMENT3_GETELEMENTSBYNAME                   DISPID_OMDOCUMENT+86
#define DISPID_IHTMLDOCUMENT3_GETELEMENTBYID                      DISPID_OMDOCUMENT+88
#define DISPID_IHTMLDOCUMENT3_GETELEMENTSBYTAGNAME                DISPID_OMDOCUMENT+87

//    DISPIDs for interface IHTMLDocument4

#define DISPID_IHTMLDOCUMENT4_FOCUS                               DISPID_OMDOCUMENT+89
#define DISPID_IHTMLDOCUMENT4_HASFOCUS                            DISPID_OMDOCUMENT+90
#define DISPID_IHTMLDOCUMENT4_ONSELECTIONCHANGE                   DISPID_EVPROP_ONSELECTIONCHANGE
#define DISPID_IHTMLDOCUMENT4_NAMESPACES                          DISPID_OMDOCUMENT+91
#define DISPID_IHTMLDOCUMENT4_CREATEDOCUMENTFROMURL               DISPID_OMDOCUMENT+92
#define DISPID_IHTMLDOCUMENT4_MEDIA                               DISPID_OMDOCUMENT+93
#define DISPID_IHTMLDOCUMENT4_CREATEEVENTOBJECT                   DISPID_OMDOCUMENT+94
#define DISPID_IHTMLDOCUMENT4_FIREEVENT                           DISPID_OMDOCUMENT+95
#define DISPID_IHTMLDOCUMENT4_CREATERENDERSTYLE                   DISPID_OMDOCUMENT+96
#define DISPID_IHTMLDOCUMENT4_ONCONTROLSELECT                     DISPID_EVPROP_ONCONTROLSELECT
#define DISPID_IHTMLDOCUMENT4_URLUNENCODED                        DISPID_OMDOCUMENT+97

//    DISPIDs for interface IHTMLDocument5

#define DISPID_IHTMLDOCUMENT5_ONMOUSEWHEEL                        DISPID_EVPROP_ONMOUSEWHEEL
#define DISPID_IHTMLDOCUMENT5_DOCTYPE                             DISPID_OMDOCUMENT+98
#define DISPID_IHTMLDOCUMENT5_IMPLEMENTATION                      DISPID_OMDOCUMENT+99
#define DISPID_IHTMLDOCUMENT5_CREATEATTRIBUTE                     DISPID_OMDOCUMENT+100
#define DISPID_IHTMLDOCUMENT5_CREATECOMMENT                       DISPID_OMDOCUMENT+101
#define DISPID_IHTMLDOCUMENT5_ONFOCUSIN                           DISPID_EVPROP_ONFOCUSIN
#define DISPID_IHTMLDOCUMENT5_ONFOCUSOUT                          DISPID_EVPROP_ONFOCUSOUT
#define DISPID_IHTMLDOCUMENT5_ONACTIVATE                          DISPID_EVPROP_ONACTIVATE
#define DISPID_IHTMLDOCUMENT5_ONDEACTIVATE                        DISPID_EVPROP_ONDEACTIVATE
#define DISPID_IHTMLDOCUMENT5_ONBEFOREACTIVATE                    DISPID_EVPROP_ONBEFOREACTIVATE
#define DISPID_IHTMLDOCUMENT5_ONBEFOREDEACTIVATE                  DISPID_EVPROP_ONBEFOREDEACTIVATE
#define DISPID_IHTMLDOCUMENT5_COMPATMODE                          DISPID_OMDOCUMENT+102

//    DISPIDs for event set HTMLDocumentEvents2

#define DISPID_HTMLDOCUMENTEVENTS2_ONHELP                         DISPID_EVMETH_ONHELP
#define DISPID_HTMLDOCUMENTEVENTS2_ONCLICK                        DISPID_EVMETH_ONCLICK
#define DISPID_HTMLDOCUMENTEVENTS2_ONDBLCLICK                     DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLDOCUMENTEVENTS2_ONKEYDOWN                      DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLDOCUMENTEVENTS2_ONKEYUP                        DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLDOCUMENTEVENTS2_ONKEYPRESS                     DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEDOWN                    DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEMOVE                    DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEUP                      DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEOUT                     DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEOVER                    DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLDOCUMENTEVENTS2_ONREADYSTATECHANGE             DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREUPDATE                 DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONAFTERUPDATE                  DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWEXIT                      DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWENTER                     DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLDOCUMENTEVENTS2_ONDRAGSTART                    DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLDOCUMENTEVENTS2_ONSELECTSTART                  DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLDOCUMENTEVENTS2_ONERRORUPDATE                  DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONCONTEXTMENU                  DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLDOCUMENTEVENTS2_ONSTOP                         DISPID_EVMETH_ONSTOP
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWSDELETE                   DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLDOCUMENTEVENTS2_ONROWSINSERTED                 DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLDOCUMENTEVENTS2_ONCELLCHANGE                   DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONPROPERTYCHANGE               DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONDATASETCHANGED               DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLDOCUMENTEVENTS2_ONDATAAVAILABLE                DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLDOCUMENTEVENTS2_ONDATASETCOMPLETE              DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREEDITFOCUS              DISPID_EVMETH_ONBEFOREEDITFOCUS
#define DISPID_HTMLDOCUMENTEVENTS2_ONSELECTIONCHANGE              DISPID_EVMETH_ONSELECTIONCHANGE
#define DISPID_HTMLDOCUMENTEVENTS2_ONCONTROLSELECT                DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLDOCUMENTEVENTS2_ONMOUSEWHEEL                   DISPID_EVMETH_ONMOUSEWHEEL
#define DISPID_HTMLDOCUMENTEVENTS2_ONFOCUSIN                      DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLDOCUMENTEVENTS2_ONFOCUSOUT                     DISPID_EVMETH_ONFOCUSOUT
#define DISPID_HTMLDOCUMENTEVENTS2_ONACTIVATE                     DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONDEACTIVATE                   DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREACTIVATE               DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS2_ONBEFOREDEACTIVATE             DISPID_EVMETH_ONBEFOREDEACTIVATE

//    DISPIDs for event set HTMLDocumentEvents

#define DISPID_HTMLDOCUMENTEVENTS_ONHELP                          DISPID_EVMETH_ONHELP
#define DISPID_HTMLDOCUMENTEVENTS_ONCLICK                         DISPID_EVMETH_ONCLICK
#define DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK                      DISPID_EVMETH_ONDBLCLICK
#define DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN                       DISPID_EVMETH_ONKEYDOWN
#define DISPID_HTMLDOCUMENTEVENTS_ONKEYUP                         DISPID_EVMETH_ONKEYUP
#define DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS                      DISPID_EVMETH_ONKEYPRESS
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN                     DISPID_EVMETH_ONMOUSEDOWN
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE                     DISPID_EVMETH_ONMOUSEMOVE
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP                       DISPID_EVMETH_ONMOUSEUP
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOUT                      DISPID_EVMETH_ONMOUSEOUT
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOVER                     DISPID_EVMETH_ONMOUSEOVER
#define DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE              DISPID_EVMETH_ONREADYSTATECHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREUPDATE                  DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLDOCUMENTEVENTS_ONAFTERUPDATE                   DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLDOCUMENTEVENTS_ONROWEXIT                       DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLDOCUMENTEVENTS_ONROWENTER                      DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLDOCUMENTEVENTS_ONDRAGSTART                     DISPID_EVMETH_ONDRAGSTART
#define DISPID_HTMLDOCUMENTEVENTS_ONSELECTSTART                   DISPID_EVMETH_ONSELECTSTART
#define DISPID_HTMLDOCUMENTEVENTS_ONERRORUPDATE                   DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLDOCUMENTEVENTS_ONCONTEXTMENU                   DISPID_EVMETH_ONCONTEXTMENU
#define DISPID_HTMLDOCUMENTEVENTS_ONSTOP                          DISPID_EVMETH_ONSTOP
#define DISPID_HTMLDOCUMENTEVENTS_ONROWSDELETE                    DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLDOCUMENTEVENTS_ONROWSINSERTED                  DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLDOCUMENTEVENTS_ONCELLCHANGE                    DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONPROPERTYCHANGE                DISPID_EVMETH_ONPROPERTYCHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONDATASETCHANGED                DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLDOCUMENTEVENTS_ONDATAAVAILABLE                 DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLDOCUMENTEVENTS_ONDATASETCOMPLETE               DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREEDITFOCUS               DISPID_EVMETH_ONBEFOREEDITFOCUS
#define DISPID_HTMLDOCUMENTEVENTS_ONSELECTIONCHANGE               DISPID_EVMETH_ONSELECTIONCHANGE
#define DISPID_HTMLDOCUMENTEVENTS_ONCONTROLSELECT                 DISPID_EVMETH_ONCONTROLSELECT
#define DISPID_HTMLDOCUMENTEVENTS_ONMOUSEWHEEL                    DISPID_EVMETH_ONMOUSEWHEEL
#define DISPID_HTMLDOCUMENTEVENTS_ONFOCUSIN                       DISPID_EVMETH_ONFOCUSIN
#define DISPID_HTMLDOCUMENTEVENTS_ONFOCUSOUT                      DISPID_EVMETH_ONFOCUSOUT
#define DISPID_HTMLDOCUMENTEVENTS_ONACTIVATE                      DISPID_EVMETH_ONACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS_ONDEACTIVATE                    DISPID_EVMETH_ONDEACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREACTIVATE                DISPID_EVMETH_ONBEFOREACTIVATE
#define DISPID_HTMLDOCUMENTEVENTS_ONBEFOREDEACTIVATE              DISPID_EVMETH_ONBEFOREDEACTIVATE

//    DISPIDs for interface IWebBridge

#define DISPID_IWEBBRIDGE_URL                                     1
#define DISPID_IWEBBRIDGE_SCROLLBAR                               2
#define DISPID_IWEBBRIDGE_EMBED                                   3
#define DISPID_IWEBBRIDGE_EVENT                                   DISPID_IHTMLWINDOW2_EVENT
#define DISPID_IWEBBRIDGE_READYSTATE                              DISPID_READYSTATE
#define DISPID_IWEBBRIDGE_ABOUTBOX                                DISPID_ABOUTBOX

//    DISPIDs for interface IWBScriptControl

#define DISPID_IWBSCRIPTCONTROL_RAISEEVENT                        1
#define DISPID_IWBSCRIPTCONTROL_BUBBLEEVENT                       2
#define DISPID_IWBSCRIPTCONTROL_SETCONTEXTMENU                    3
#define DISPID_IWBSCRIPTCONTROL_SELECTABLECONTENT                 4
#define DISPID_IWBSCRIPTCONTROL_FROZEN                            5
#define DISPID_IWBSCRIPTCONTROL_SCROLLBAR                         7
#define DISPID_IWBSCRIPTCONTROL_VERSION                           8
#define DISPID_IWBSCRIPTCONTROL_VISIBILITY                        9
#define DISPID_IWBSCRIPTCONTROL_ONVISIBILITYCHANGE                10

//    DISPIDs for event set DWebBridgeEvents

#define DISPID_DWEBBRIDGEEVENTS_ONSCRIPTLETEVENT                  1
#define DISPID_DWEBBRIDGEEVENTS_ONREADYSTATECHANGE                DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE
#define DISPID_DWEBBRIDGEEVENTS_ONCLICK                           DISPID_HTMLDOCUMENTEVENTS_ONCLICK
#define DISPID_DWEBBRIDGEEVENTS_ONDBLCLICK                        DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK
#define DISPID_DWEBBRIDGEEVENTS_ONKEYDOWN                         DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN
#define DISPID_DWEBBRIDGEEVENTS_ONKEYUP                           DISPID_HTMLDOCUMENTEVENTS_ONKEYUP
#define DISPID_DWEBBRIDGEEVENTS_ONKEYPRESS                        DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS
#define DISPID_DWEBBRIDGEEVENTS_ONMOUSEDOWN                       DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN
#define DISPID_DWEBBRIDGEEVENTS_ONMOUSEMOVE                       DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE
#define DISPID_DWEBBRIDGEEVENTS_ONMOUSEUP                         DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP

//    DISPIDs for interface IHTMLEmbedElement

#define DISPID_IHTMLEMBEDELEMENT_HIDDEN                           DISPID_OBJECT+10
#define DISPID_IHTMLEMBEDELEMENT_PALETTE                          DISPID_OBJECT+4
#define DISPID_IHTMLEMBEDELEMENT_PLUGINSPAGE                      DISPID_OBJECT+5
#define DISPID_IHTMLEMBEDELEMENT_SRC                              DISPID_OBJECT+6
#define DISPID_IHTMLEMBEDELEMENT_UNITS                            DISPID_OBJECT+8
#define DISPID_IHTMLEMBEDELEMENT_NAME                             STDPROPID_XOBJ_NAME
#define DISPID_IHTMLEMBEDELEMENT_WIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLEMBEDELEMENT_HEIGHT                           STDPROPID_XOBJ_HEIGHT

//    DISPIDs for interface IHTMLAreasCollection

#define DISPID_IHTMLAREASCOLLECTION_LENGTH                        DISPID_COLLECTION
#define DISPID_IHTMLAREASCOLLECTION__NEWENUM                      DISPID_NEWENUM
#define DISPID_IHTMLAREASCOLLECTION_ITEM                          DISPID_VALUE
#define DISPID_IHTMLAREASCOLLECTION_TAGS                          DISPID_COLLECTION+2
#define DISPID_IHTMLAREASCOLLECTION_ADD                           DISPID_COLLECTION+3
#define DISPID_IHTMLAREASCOLLECTION_REMOVE                        DISPID_COLLECTION+4

//    DISPIDs for interface IHTMLAreasCollection2

#define DISPID_IHTMLAREASCOLLECTION2_URNS                         DISPID_COLLECTION+5

//    DISPIDs for interface IHTMLAreasCollection3

#define DISPID_IHTMLAREASCOLLECTION3_NAMEDITEM                    DISPID_COLLECTION+6

//    DISPIDs for interface IHTMLMapElement

#define DISPID_IHTMLMAPELEMENT_AREAS                              DISPID_MAP+2
#define DISPID_IHTMLMAPELEMENT_NAME                               STDPROPID_XOBJ_NAME

//    DISPIDs for interface IHTMLAreaElement

#define DISPID_IHTMLAREAELEMENT_SHAPE                             DISPID_AREA+1
#define DISPID_IHTMLAREAELEMENT_COORDS                            DISPID_AREA+2
#define DISPID_IHTMLAREAELEMENT_HREF                              DISPID_VALUE
#define DISPID_IHTMLAREAELEMENT_TARGET                            DISPID_AREA+4
#define DISPID_IHTMLAREAELEMENT_ALT                               DISPID_AREA+5
#define DISPID_IHTMLAREAELEMENT_NOHREF                            DISPID_AREA+6
#define DISPID_IHTMLAREAELEMENT_HOST                              DISPID_AREA+7
#define DISPID_IHTMLAREAELEMENT_HOSTNAME                          DISPID_AREA+8
#define DISPID_IHTMLAREAELEMENT_PATHNAME                          DISPID_AREA+9
#define DISPID_IHTMLAREAELEMENT_PORT                              DISPID_AREA+10
#define DISPID_IHTMLAREAELEMENT_PROTOCOL                          DISPID_AREA+11
#define DISPID_IHTMLAREAELEMENT_SEARCH                            DISPID_AREA+12
#define DISPID_IHTMLAREAELEMENT_HASH                              DISPID_AREA+13
#define DISPID_IHTMLAREAELEMENT_ONBLUR                            DISPID_EVPROP_ONBLUR
#define DISPID_IHTMLAREAELEMENT_ONFOCUS                           DISPID_EVPROP_ONFOCUS
#define DISPID_IHTMLAREAELEMENT_TABINDEX                          STDPROPID_XOBJ_TABINDEX
#define DISPID_IHTMLAREAELEMENT_FOCUS                             DISPID_SITE+0
#define DISPID_IHTMLAREAELEMENT_BLUR                              DISPID_SITE+2

//    DISPIDs for interface IHTMLTableCaption

#define DISPID_IHTMLTABLECAPTION_ALIGN                            STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLECAPTION_VALIGN                           DISPID_A_TABLEVALIGN

//    DISPIDs for interface IHTMLCommentElement

#define DISPID_IHTMLCOMMENTELEMENT_TEXT                           DISPID_COMMENTPDL+1
#define DISPID_IHTMLCOMMENTELEMENT_ATOMIC                         DISPID_COMMENTPDL+2

//    DISPIDs for interface IHTMLCommentElement2

#define DISPID_IHTMLCOMMENTELEMENT2_DATA                          DISPID_COMMENTPDL+3
#define DISPID_IHTMLCOMMENTELEMENT2_LENGTH                        DISPID_COMMENTPDL+4
#define DISPID_IHTMLCOMMENTELEMENT2_SUBSTRINGDATA                 DISPID_COMMENTPDL+5
#define DISPID_IHTMLCOMMENTELEMENT2_APPENDDATA                    DISPID_COMMENTPDL+6
#define DISPID_IHTMLCOMMENTELEMENT2_INSERTDATA                    DISPID_COMMENTPDL+7
#define DISPID_IHTMLCOMMENTELEMENT2_DELETEDATA                    DISPID_COMMENTPDL+8
#define DISPID_IHTMLCOMMENTELEMENT2_REPLACEDATA                   DISPID_COMMENTPDL+9

//    DISPIDs for interface IHTMLPhraseElement2

#define DISPID_IHTMLPHRASEELEMENT2_CITE                           DISPID_PHRASE+1
#define DISPID_IHTMLPHRASEELEMENT2_DATETIME                       DISPID_PHRASE+2

//    DISPIDs for interface IHTMLTable

#define DISPID_IHTMLTABLE_COLS                                    DISPID_TABLE+1
#define DISPID_IHTMLTABLE_BORDER                                  DISPID_TABLE+2
#define DISPID_IHTMLTABLE_FRAME                                   DISPID_TABLE+4
#define DISPID_IHTMLTABLE_RULES                                   DISPID_TABLE+3
#define DISPID_IHTMLTABLE_CELLSPACING                             DISPID_TABLE+5
#define DISPID_IHTMLTABLE_CELLPADDING                             DISPID_TABLE+6
#define DISPID_IHTMLTABLE_BACKGROUND                              DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLTABLE_BGCOLOR                                 DISPID_BACKCOLOR
#define DISPID_IHTMLTABLE_BORDERCOLOR                             DISPID_A_TABLEBORDERCOLOR
#define DISPID_IHTMLTABLE_BORDERCOLORLIGHT                        DISPID_A_TABLEBORDERCOLORLIGHT
#define DISPID_IHTMLTABLE_BORDERCOLORDARK                         DISPID_A_TABLEBORDERCOLORDARK
#define DISPID_IHTMLTABLE_ALIGN                                   STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLTABLE_REFRESH                                 DISPID_TABLE+15
#define DISPID_IHTMLTABLE_ROWS                                    DISPID_TABLE+16
#define DISPID_IHTMLTABLE_WIDTH                                   STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLTABLE_HEIGHT                                  STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLTABLE_DATAPAGESIZE                            DISPID_TABLE+17
#define DISPID_IHTMLTABLE_NEXTPAGE                                DISPID_TABLE+18
#define DISPID_IHTMLTABLE_PREVIOUSPAGE                            DISPID_TABLE+19
#define DISPID_IHTMLTABLE_THEAD                                   DISPID_TABLE+20
#define DISPID_IHTMLTABLE_TFOOT                                   DISPID_TABLE+21
#define DISPID_IHTMLTABLE_TBODIES                                 DISPID_TABLE+24
#define DISPID_IHTMLTABLE_CAPTION                                 DISPID_TABLE+25
#define DISPID_IHTMLTABLE_CREATETHEAD                             DISPID_TABLE+26
#define DISPID_IHTMLTABLE_DELETETHEAD                             DISPID_TABLE+27
#define DISPID_IHTMLTABLE_CREATETFOOT                             DISPID_TABLE+28
#define DISPID_IHTMLTABLE_DELETETFOOT                             DISPID_TABLE+29
#define DISPID_IHTMLTABLE_CREATECAPTION                           DISPID_TABLE+30
#define DISPID_IHTMLTABLE_DELETECAPTION                           DISPID_TABLE+31
#define DISPID_IHTMLTABLE_INSERTROW                               DISPID_TABLE+32
#define DISPID_IHTMLTABLE_DELETEROW                               DISPID_TABLE+33
#define DISPID_IHTMLTABLE_READYSTATE                              DISPID_A_READYSTATE
#define DISPID_IHTMLTABLE_ONREADYSTATECHANGE                      DISPID_EVPROP_ONREADYSTATECHANGE

//    DISPIDs for interface IHTMLTable2

#define DISPID_IHTMLTABLE2_FIRSTPAGE                              DISPID_TABLE+35
#define DISPID_IHTMLTABLE2_LASTPAGE                               DISPID_TABLE+36
#define DISPID_IHTMLTABLE2_CELLS                                  DISPID_TABLE+37
#define DISPID_IHTMLTABLE2_MOVEROW                                DISPID_TABLE+38

//    DISPIDs for interface IHTMLTable3

#define DISPID_IHTMLTABLE3_SUMMARY                                DISPID_TABLE+39

//    DISPIDs for interface IHTMLTableCol

#define DISPID_IHTMLTABLECOL_SPAN                                 DISPID_TABLECOL+1
#define DISPID_IHTMLTABLECOL_WIDTH                                STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLTABLECOL_ALIGN                                STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLECOL_VALIGN                               DISPID_A_TABLEVALIGN

//    DISPIDs for interface IHTMLTableCol2

#define DISPID_IHTMLTABLECOL2_CH                                  DISPID_TABLECOL+2
#define DISPID_IHTMLTABLECOL2_CHOFF                               DISPID_TABLECOL+3

//    DISPIDs for interface IHTMLTableSection

#define DISPID_IHTMLTABLESECTION_ALIGN                            STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLESECTION_VALIGN                           DISPID_A_TABLEVALIGN
#define DISPID_IHTMLTABLESECTION_BGCOLOR                          DISPID_BACKCOLOR
#define DISPID_IHTMLTABLESECTION_ROWS                             DISPID_TABLESECTION
#define DISPID_IHTMLTABLESECTION_INSERTROW                        DISPID_TABLESECTION+1
#define DISPID_IHTMLTABLESECTION_DELETEROW                        DISPID_TABLESECTION+2

//    DISPIDs for interface IHTMLTableSection2

#define DISPID_IHTMLTABLESECTION2_MOVEROW                         DISPID_TABLESECTION+3

//    DISPIDs for interface IHTMLTableSection3

#define DISPID_IHTMLTABLESECTION3_CH                              DISPID_TABLESECTION+4
#define DISPID_IHTMLTABLESECTION3_CHOFF                           DISPID_TABLESECTION+5

//    DISPIDs for interface IHTMLTableRow

#define DISPID_IHTMLTABLEROW_ALIGN                                STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLEROW_VALIGN                               DISPID_A_TABLEVALIGN
#define DISPID_IHTMLTABLEROW_BGCOLOR                              DISPID_BACKCOLOR
#define DISPID_IHTMLTABLEROW_BORDERCOLOR                          DISPID_A_TABLEBORDERCOLOR
#define DISPID_IHTMLTABLEROW_BORDERCOLORLIGHT                     DISPID_A_TABLEBORDERCOLORLIGHT
#define DISPID_IHTMLTABLEROW_BORDERCOLORDARK                      DISPID_A_TABLEBORDERCOLORDARK
#define DISPID_IHTMLTABLEROW_ROWINDEX                             DISPID_TABLEROW
#define DISPID_IHTMLTABLEROW_SECTIONROWINDEX                      DISPID_TABLEROW+1
#define DISPID_IHTMLTABLEROW_CELLS                                DISPID_TABLEROW+2
#define DISPID_IHTMLTABLEROW_INSERTCELL                           DISPID_TABLEROW+3
#define DISPID_IHTMLTABLEROW_DELETECELL                           DISPID_TABLEROW+4

//    DISPIDs for interface IHTMLTableRow2

#define DISPID_IHTMLTABLEROW2_HEIGHT                              STDPROPID_XOBJ_HEIGHT

//    DISPIDs for interface IHTMLTableRow3

#define DISPID_IHTMLTABLEROW3_CH                                  DISPID_TABLEROW+9
#define DISPID_IHTMLTABLEROW3_CHOFF                               DISPID_TABLEROW+10

//    DISPIDs for interface IHTMLTableRowMetrics

#define DISPID_IHTMLTABLEROWMETRICS_CLIENTHEIGHT                  DISPID_SITE+19
#define DISPID_IHTMLTABLEROWMETRICS_CLIENTWIDTH                   DISPID_SITE+20
#define DISPID_IHTMLTABLEROWMETRICS_CLIENTTOP                     DISPID_SITE+21
#define DISPID_IHTMLTABLEROWMETRICS_CLIENTLEFT                    DISPID_SITE+22

//    DISPIDs for interface IHTMLTableCell

#define DISPID_IHTMLTABLECELL_ROWSPAN                             DISPID_TABLECELL+1
#define DISPID_IHTMLTABLECELL_COLSPAN                             DISPID_TABLECELL+2
#define DISPID_IHTMLTABLECELL_ALIGN                               STDPROPID_XOBJ_BLOCKALIGN
#define DISPID_IHTMLTABLECELL_VALIGN                              DISPID_A_TABLEVALIGN
#define DISPID_IHTMLTABLECELL_BGCOLOR                             DISPID_BACKCOLOR
#define DISPID_IHTMLTABLECELL_NOWRAP                              DISPID_A_NOWRAP
#define DISPID_IHTMLTABLECELL_BACKGROUND                          DISPID_A_BACKGROUNDIMAGE
#define DISPID_IHTMLTABLECELL_BORDERCOLOR                         DISPID_A_TABLEBORDERCOLOR
#define DISPID_IHTMLTABLECELL_BORDERCOLORLIGHT                    DISPID_A_TABLEBORDERCOLORLIGHT
#define DISPID_IHTMLTABLECELL_BORDERCOLORDARK                     DISPID_A_TABLEBORDERCOLORDARK
#define DISPID_IHTMLTABLECELL_WIDTH                               STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLTABLECELL_HEIGHT                              STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLTABLECELL_CELLINDEX                           DISPID_TABLECELL+3

//    DISPIDs for interface IHTMLTableCell2

#define DISPID_IHTMLTABLECELL2_ABBR                               DISPID_TABLECELL+4
#define DISPID_IHTMLTABLECELL2_AXIS                               DISPID_TABLECELL+5
#define DISPID_IHTMLTABLECELL2_CH                                 DISPID_TABLECELL+6
#define DISPID_IHTMLTABLECELL2_CHOFF                              DISPID_TABLECELL+7
#define DISPID_IHTMLTABLECELL2_HEADERS                            DISPID_TABLECELL+8
#define DISPID_IHTMLTABLECELL2_SCOPE                              DISPID_TABLECELL+9

//    DISPIDs for interface IHTMLScriptElement

#define DISPID_IHTMLSCRIPTELEMENT_SRC                             DISPID_SCRIPT+1
#define DISPID_IHTMLSCRIPTELEMENT_HTMLFOR                         DISPID_SCRIPT+4
#define DISPID_IHTMLSCRIPTELEMENT_EVENT                           DISPID_SCRIPT+5
#define DISPID_IHTMLSCRIPTELEMENT_TEXT                            DISPID_SCRIPT+6
#define DISPID_IHTMLSCRIPTELEMENT_DEFER                           DISPID_SCRIPT+7
#define DISPID_IHTMLSCRIPTELEMENT_READYSTATE                      DISPID_A_READYSTATE
#define DISPID_IHTMLSCRIPTELEMENT_ONERROR                         DISPID_EVPROP_ONERROR
#define DISPID_IHTMLSCRIPTELEMENT_TYPE                            DISPID_SCRIPT+9

//    DISPIDs for interface IHTMLScriptElement2

#define DISPID_IHTMLSCRIPTELEMENT2_CHARSET                        DISPID_SCRIPT+10

//    DISPIDs for event set HTMLScriptEvents2

#define DISPID_HTMLSCRIPTEVENTS2_ONERROR                          DISPID_EVMETH_ONERROR

//    DISPIDs for event set HTMLScriptEvents

#define DISPID_HTMLSCRIPTEVENTS_ONERROR                           DISPID_EVMETH_ONERROR

//    DISPIDs for interface IHTMLObjectElement

#define DISPID_IHTMLOBJECTELEMENT_OBJECT                          DISPID_OBJECT+1
#define DISPID_IHTMLOBJECTELEMENT_CLASSID                         DISPID_OBJECT+2
#define DISPID_IHTMLOBJECTELEMENT_DATA                            DISPID_OBJECT+3
#define DISPID_IHTMLOBJECTELEMENT_RECORDSET                       DISPID_OBJECT+5
#define DISPID_IHTMLOBJECTELEMENT_ALIGN                           STDPROPID_XOBJ_CONTROLALIGN
#define DISPID_IHTMLOBJECTELEMENT_NAME                            STDPROPID_XOBJ_NAME
#define DISPID_IHTMLOBJECTELEMENT_CODEBASE                        DISPID_OBJECT+6
#define DISPID_IHTMLOBJECTELEMENT_CODETYPE                        DISPID_OBJECT+7
#define DISPID_IHTMLOBJECTELEMENT_CODE                            DISPID_OBJECT+8
#define DISPID_IHTMLOBJECTELEMENT_BASEHREF                        STDPROPID_XOBJ_BASEHREF
#define DISPID_IHTMLOBJECTELEMENT_TYPE                            DISPID_OBJECT+9
#define DISPID_IHTMLOBJECTELEMENT_FORM                            DISPID_SITE+4
#define DISPID_IHTMLOBJECTELEMENT_WIDTH                           STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLOBJECTELEMENT_HEIGHT                          STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLOBJECTELEMENT_READYSTATE                      DISPID_OBJECT+10
#define DISPID_IHTMLOBJECTELEMENT_ONREADYSTATECHANGE              DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLOBJECTELEMENT_ONERROR                         DISPID_EVPROP_ONERROR
#define DISPID_IHTMLOBJECTELEMENT_ALTHTML                         DISPID_OBJECT+11
#define DISPID_IHTMLOBJECTELEMENT_VSPACE                          DISPID_OBJECT+12
#define DISPID_IHTMLOBJECTELEMENT_HSPACE                          DISPID_OBJECT+13

//    DISPIDs for interface IHTMLObjectElement2

#define DISPID_IHTMLOBJECTELEMENT2_NAMEDRECORDSET                 DISPID_OBJECT+14
#define DISPID_IHTMLOBJECTELEMENT2_CLASSID                        DISPID_OBJECT+2
#define DISPID_IHTMLOBJECTELEMENT2_DATA                           DISPID_OBJECT+3

//    DISPIDs for interface IHTMLObjectElement3

#define DISPID_IHTMLOBJECTELEMENT3_ARCHIVE                        DISPID_OBJECT+15
#define DISPID_IHTMLOBJECTELEMENT3_ALT                            DISPID_OBJECT+16
#define DISPID_IHTMLOBJECTELEMENT3_DECLARE                        DISPID_OBJECT+17
#define DISPID_IHTMLOBJECTELEMENT3_STANDBY                        DISPID_OBJECT+18
#define DISPID_IHTMLOBJECTELEMENT3_BORDER                         DISPID_OBJECT+19
#define DISPID_IHTMLOBJECTELEMENT3_USEMAP                         DISPID_OBJECT+20

//    DISPIDs for interface IHTMLParamElement

#define DISPID_IHTMLPARAMELEMENT_NAME                             DISPID_PARAM+1
#define DISPID_IHTMLPARAMELEMENT_VALUE                            DISPID_PARAM+2
#define DISPID_IHTMLPARAMELEMENT_TYPE                             DISPID_PARAM+3
#define DISPID_IHTMLPARAMELEMENT_VALUETYPE                        DISPID_PARAM+4

//    DISPIDs for event set HTMLObjectElementEvents2

#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONBEFOREUPDATE            DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONAFTERUPDATE             DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONERRORUPDATE             DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWEXIT                 DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWENTER                DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONDATASETCHANGED          DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONDATAAVAILABLE           DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONDATASETCOMPLETE         DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONERROR                   DISPID_XOBJ_BASE+19
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWSDELETE              DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONROWSINSERTED            DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONCELLCHANGE              DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLOBJECTELEMENTEVENTS2_ONREADYSTATECHANGE        DISPID_XOBJ_BASE+20

//    DISPIDs for event set HTMLObjectElementEvents

#define DISPID_HTMLOBJECTELEMENTEVENTS_ONBEFOREUPDATE             DISPID_EVMETH_ONBEFOREUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONAFTERUPDATE              DISPID_EVMETH_ONAFTERUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONERRORUPDATE              DISPID_EVMETH_ONERRORUPDATE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWEXIT                  DISPID_EVMETH_ONROWEXIT
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWENTER                 DISPID_EVMETH_ONROWENTER
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONDATASETCHANGED           DISPID_EVMETH_ONDATASETCHANGED
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONDATAAVAILABLE            DISPID_EVMETH_ONDATAAVAILABLE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONDATASETCOMPLETE          DISPID_EVMETH_ONDATASETCOMPLETE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONERROR                    DISPID_XOBJ_BASE+19
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWSDELETE               DISPID_EVMETH_ONROWSDELETE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONROWSINSERTED             DISPID_EVMETH_ONROWSINSERTED
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONCELLCHANGE               DISPID_EVMETH_ONCELLCHANGE
#define DISPID_HTMLOBJECTELEMENTEVENTS_ONREADYSTATECHANGE         DISPID_XOBJ_BASE+20

//    DISPIDs for interface IHTMLFrameBase

#define DISPID_IHTMLFRAMEBASE_SRC                                 DISPID_FRAMESITE+0
#define DISPID_IHTMLFRAMEBASE_NAME                                STDPROPID_XOBJ_NAME
#define DISPID_IHTMLFRAMEBASE_BORDER                              DISPID_FRAMESITE+2
#define DISPID_IHTMLFRAMEBASE_FRAMEBORDER                         DISPID_FRAMESITE+3
#define DISPID_IHTMLFRAMEBASE_FRAMESPACING                        DISPID_FRAMESITE+4
#define DISPID_IHTMLFRAMEBASE_MARGINWIDTH                         DISPID_FRAMESITE+5
#define DISPID_IHTMLFRAMEBASE_MARGINHEIGHT                        DISPID_FRAMESITE+6
#define DISPID_IHTMLFRAMEBASE_NORESIZE                            DISPID_FRAMESITE+7
#define DISPID_IHTMLFRAMEBASE_SCROLLING                           DISPID_FRAMESITE+8

//    DISPIDs for interface IHTMLFrameBase2

#define DISPID_IHTMLFRAMEBASE2_CONTENTWINDOW                      DISPID_FRAMESITE+9
#define DISPID_IHTMLFRAMEBASE2_ONLOAD                             DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLFRAMEBASE2_ONREADYSTATECHANGE                 DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLFRAMEBASE2_READYSTATE                         DISPID_A_READYSTATE
#define DISPID_IHTMLFRAMEBASE2_ALLOWTRANSPARENCY                  DISPID_A_ALLOWTRANSPARENCY

//    DISPIDs for interface IHTMLFrameBase3

#define DISPID_IHTMLFRAMEBASE3_LONGDESC                           DISPID_FRAMESITE+10

//    DISPIDs for event set HTMLFrameSiteEvents2

#define DISPID_HTMLFRAMESITEEVENTS2_ONLOAD                        DISPID_EVMETH_ONLOAD

//    DISPIDs for event set HTMLFrameSiteEvents

#define DISPID_HTMLFRAMESITEEVENTS_ONLOAD                         DISPID_EVMETH_ONLOAD

//    DISPIDs for interface IHTMLFrameElement

#define DISPID_IHTMLFRAMEELEMENT_BORDERCOLOR                      DISPID_FRAME+1

//    DISPIDs for interface IHTMLFrameElement2

#define DISPID_IHTMLFRAMEELEMENT2_HEIGHT                          STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLFRAMEELEMENT2_WIDTH                           STDPROPID_XOBJ_WIDTH

//    DISPIDs for interface IHTMLIFrameElement

#define DISPID_IHTMLIFRAMEELEMENT_VSPACE                          DISPID_IFRAME+1
#define DISPID_IHTMLIFRAMEELEMENT_HSPACE                          DISPID_IFRAME+2
#define DISPID_IHTMLIFRAMEELEMENT_ALIGN                           STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLIFrameElement2

#define DISPID_IHTMLIFRAMEELEMENT2_HEIGHT                         STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLIFRAMEELEMENT2_WIDTH                          STDPROPID_XOBJ_WIDTH

//    DISPIDs for interface IHTMLDivPosition

#define DISPID_IHTMLDIVPOSITION_ALIGN                             STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLFieldSetElement

#define DISPID_IHTMLFIELDSETELEMENT_ALIGN                         STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLFieldSetElement2

#define DISPID_IHTMLFIELDSETELEMENT2_FORM                         DISPID_SITE+4

//    DISPIDs for interface IHTMLLegendElement

#define DISPID_IHTMLLEGENDELEMENT_ALIGN                           STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLLegendElement2

#define DISPID_IHTMLLEGENDELEMENT2_FORM                           DISPID_SITE+4

//    DISPIDs for interface IHTMLSpanFlow

#define DISPID_IHTMLSPANFLOW_ALIGN                                STDPROPID_XOBJ_CONTROLALIGN

//    DISPIDs for interface IHTMLFrameSetElement

#define DISPID_IHTMLFRAMESETELEMENT_ROWS                          DISPID_FRAMESET
#define DISPID_IHTMLFRAMESETELEMENT_COLS                          DISPID_FRAMESET+1
#define DISPID_IHTMLFRAMESETELEMENT_BORDER                        DISPID_FRAMESET+2
#define DISPID_IHTMLFRAMESETELEMENT_BORDERCOLOR                   DISPID_FRAMESET+3
#define DISPID_IHTMLFRAMESETELEMENT_FRAMEBORDER                   DISPID_FRAMESET+4
#define DISPID_IHTMLFRAMESETELEMENT_FRAMESPACING                  DISPID_FRAMESET+5
#define DISPID_IHTMLFRAMESETELEMENT_NAME                          STDPROPID_XOBJ_NAME
#define DISPID_IHTMLFRAMESETELEMENT_ONLOAD                        DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLFRAMESETELEMENT_ONUNLOAD                      DISPID_EVPROP_ONUNLOAD
#define DISPID_IHTMLFRAMESETELEMENT_ONBEFOREUNLOAD                DISPID_EVPROP_ONBEFOREUNLOAD

//    DISPIDs for interface IHTMLFrameSetElement2

#define DISPID_IHTMLFRAMESETELEMENT2_ONBEFOREPRINT                DISPID_EVPROP_ONBEFOREPRINT
#define DISPID_IHTMLFRAMESETELEMENT2_ONAFTERPRINT                 DISPID_EVPROP_ONAFTERPRINT

//    DISPIDs for interface IHTMLBGsound

#define DISPID_IHTMLBGSOUND_SRC                                   DISPID_BGSOUND+1
#define DISPID_IHTMLBGSOUND_LOOP                                  DISPID_BGSOUND+2
#define DISPID_IHTMLBGSOUND_VOLUME                                DISPID_BGSOUND+3
#define DISPID_IHTMLBGSOUND_BALANCE                               DISPID_BGSOUND+4

//    DISPIDs for interface IHTMLFontNamesCollection

#define DISPID_IHTMLFONTNAMESCOLLECTION_LENGTH                    DISPID_OPTIONS_COL+1
#define DISPID_IHTMLFONTNAMESCOLLECTION__NEWENUM                  DISPID_NEWENUM
#define DISPID_IHTMLFONTNAMESCOLLECTION_ITEM                      DISPID_VALUE

//    DISPIDs for interface IHTMLFontSizesCollection

#define DISPID_IHTMLFONTSIZESCOLLECTION_LENGTH                    DISPID_OPTIONS_COL+2
#define DISPID_IHTMLFONTSIZESCOLLECTION__NEWENUM                  DISPID_NEWENUM
#define DISPID_IHTMLFONTSIZESCOLLECTION_FORFONT                   DISPID_OPTIONS_COL+3
#define DISPID_IHTMLFONTSIZESCOLLECTION_ITEM                      DISPID_VALUE

//    DISPIDs for interface IHTMLOptionsHolder

#define DISPID_IHTMLOPTIONSHOLDER_DOCUMENT                        DISPID_OPTIONS_COL+3
#define DISPID_IHTMLOPTIONSHOLDER_FONTS                           DISPID_OPTIONS_COL+4
#define DISPID_IHTMLOPTIONSHOLDER_EXECARG                         DISPID_OPTIONS_COL+5
#define DISPID_IHTMLOPTIONSHOLDER_ERRORLINE                       DISPID_OPTIONS_COL+6
#define DISPID_IHTMLOPTIONSHOLDER_ERRORCHARACTER                  DISPID_OPTIONS_COL+7
#define DISPID_IHTMLOPTIONSHOLDER_ERRORCODE                       DISPID_OPTIONS_COL+8
#define DISPID_IHTMLOPTIONSHOLDER_ERRORMESSAGE                    DISPID_OPTIONS_COL+9
#define DISPID_IHTMLOPTIONSHOLDER_ERRORDEBUG                      DISPID_OPTIONS_COL+10
#define DISPID_IHTMLOPTIONSHOLDER_UNSECUREDWINDOWOFDOCUMENT       DISPID_OPTIONS_COL+11
#define DISPID_IHTMLOPTIONSHOLDER_FINDTEXT                        DISPID_OPTIONS_COL+12
#define DISPID_IHTMLOPTIONSHOLDER_ANYTHINGAFTERFRAMESET           DISPID_OPTIONS_COL+13
#define DISPID_IHTMLOPTIONSHOLDER_SIZES                           DISPID_OPTIONS_COL+14
#define DISPID_IHTMLOPTIONSHOLDER_OPENFILEDLG                     DISPID_OPTIONS_COL+15
#define DISPID_IHTMLOPTIONSHOLDER_SAVEFILEDLG                     DISPID_OPTIONS_COL+16
#define DISPID_IHTMLOPTIONSHOLDER_CHOOSECOLORDLG                  DISPID_OPTIONS_COL+17
#define DISPID_IHTMLOPTIONSHOLDER_SHOWSECURITYINFO                DISPID_OPTIONS_COL+18
#define DISPID_IHTMLOPTIONSHOLDER_ISAPARTMENTMODEL                DISPID_OPTIONS_COL+19
#define DISPID_IHTMLOPTIONSHOLDER_GETCHARSET                      DISPID_OPTIONS_COL+20
#define DISPID_IHTMLOPTIONSHOLDER_SECURECONNECTIONINFO            DISPID_OPTIONS_COL+21

//    DISPIDs for interface IHTMLStyleElement

#define DISPID_IHTMLSTYLEELEMENT_TYPE                             DISPID_STYLEELEMENT+2
#define DISPID_IHTMLSTYLEELEMENT_READYSTATE                       DISPID_A_READYSTATE
#define DISPID_IHTMLSTYLEELEMENT_ONREADYSTATECHANGE               DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLSTYLEELEMENT_ONLOAD                           DISPID_EVPROP_ONLOAD
#define DISPID_IHTMLSTYLEELEMENT_ONERROR                          DISPID_EVPROP_ONERROR
#define DISPID_IHTMLSTYLEELEMENT_STYLESHEET                       DISPID_STYLEELEMENT+4
#define DISPID_IHTMLSTYLEELEMENT_DISABLED                         STDPROPID_XOBJ_DISABLED
#define DISPID_IHTMLSTYLEELEMENT_MEDIA                            DISPID_STYLEELEMENT+6

//    DISPIDs for event set HTMLStyleElementEvents2

#define DISPID_HTMLSTYLEELEMENTEVENTS2_ONLOAD                     DISPID_EVMETH_ONLOAD
#define DISPID_HTMLSTYLEELEMENTEVENTS2_ONERROR                    DISPID_EVMETH_ONERROR

//    DISPIDs for event set HTMLStyleElementEvents

#define DISPID_HTMLSTYLEELEMENTEVENTS_ONLOAD                      DISPID_EVMETH_ONLOAD
#define DISPID_HTMLSTYLEELEMENTEVENTS_ONERROR                     DISPID_EVMETH_ONERROR

//    DISPIDs for interface IHTMLStyleFontFace

#define DISPID_IHTMLSTYLEFONTFACE_FONTSRC                         DISPID_A_FONTFACESRC

//    DISPIDs for interface ICSSFilterSite

#define DISPID_ICSSFILTERSITE_GETELEMENT                          
#define DISPID_ICSSFILTERSITE_FIREONFILTERCHANGEEVENT             

//    DISPIDs for interface ICSSFilter

#define DISPID_ICSSFILTER_SETSITE                                 
#define DISPID_ICSSFILTER_ONAMBIENTPROPERTYCHANGE                 

//    DISPIDs for interface ISecureUrlHost

#define DISPID_ISECUREURLHOST_VALIDATESECUREURL                   

//    DISPIDs for interface IMarkupServices

#define DISPID_IMARKUPSERVICES_CREATEMARKUPPOINTER                
#define DISPID_IMARKUPSERVICES_CREATEMARKUPCONTAINER              
#define DISPID_IMARKUPSERVICES_CREATEELEMENT                      
#define DISPID_IMARKUPSERVICES_CLONEELEMENT                       
#define DISPID_IMARKUPSERVICES_INSERTELEMENT                      
#define DISPID_IMARKUPSERVICES_REMOVEELEMENT                      
#define DISPID_IMARKUPSERVICES_REMOVE                             
#define DISPID_IMARKUPSERVICES_COPY                               
#define DISPID_IMARKUPSERVICES_MOVE                               
#define DISPID_IMARKUPSERVICES_INSERTTEXT                         
#define DISPID_IMARKUPSERVICES_PARSESTRING                        
#define DISPID_IMARKUPSERVICES_PARSEGLOBAL                        
#define DISPID_IMARKUPSERVICES_ISSCOPEDELEMENT                    
#define DISPID_IMARKUPSERVICES_GETELEMENTTAGID                    
#define DISPID_IMARKUPSERVICES_GETTAGIDFORNAME                    
#define DISPID_IMARKUPSERVICES_GETNAMEFORTAGID                    
#define DISPID_IMARKUPSERVICES_MOVEPOINTERSTORANGE                
#define DISPID_IMARKUPSERVICES_MOVERANGETOPOINTERS                
#define DISPID_IMARKUPSERVICES_BEGINUNDOUNIT                      
#define DISPID_IMARKUPSERVICES_ENDUNDOUNIT                        

//    DISPIDs for interface IMarkupServices2

#define DISPID_IMARKUPSERVICES2_PARSEGLOBALEX                     
#define DISPID_IMARKUPSERVICES2_VALIDATEELEMENTS                  
#define DISPID_IMARKUPSERVICES2_SAVESEGMENTSTOCLIPBOARD           

//    DISPIDs for interface IMarkupContainer

#define DISPID_IMARKUPCONTAINER_OWNINGDOC                         

//    DISPIDs for interface IMarkupContainer2

#define DISPID_IMARKUPCONTAINER2_CREATECHANGELOG                  
#define DISPID_IMARKUPCONTAINER2_REGISTERFORDIRTYRANGE            
#define DISPID_IMARKUPCONTAINER2_UNREGISTERFORDIRTYRANGE          
#define DISPID_IMARKUPCONTAINER2_GETANDCLEARDIRTYRANGE            
#define DISPID_IMARKUPCONTAINER2_GETVERSIONNUMBER                 
#define DISPID_IMARKUPCONTAINER2_GETMASTERELEMENT                 

//    DISPIDs for interface IHTMLChangePlayback

#define DISPID_IHTMLCHANGEPLAYBACK_EXECCHANGE                     

//    DISPIDs for interface IMarkupPointer

#define DISPID_IMARKUPPOINTER_OWNINGDOC                           
#define DISPID_IMARKUPPOINTER_GRAVITY                             
#define DISPID_IMARKUPPOINTER_SETGRAVITY                          
#define DISPID_IMARKUPPOINTER_CLING                               
#define DISPID_IMARKUPPOINTER_SETCLING                            
#define DISPID_IMARKUPPOINTER_UNPOSITION                          
#define DISPID_IMARKUPPOINTER_ISPOSITIONED                        
#define DISPID_IMARKUPPOINTER_GETCONTAINER                        
#define DISPID_IMARKUPPOINTER_MOVEADJACENTTOELEMENT               
#define DISPID_IMARKUPPOINTER_MOVETOPOINTER                       
#define DISPID_IMARKUPPOINTER_MOVETOCONTAINER                     
#define DISPID_IMARKUPPOINTER_LEFT                                
#define DISPID_IMARKUPPOINTER_RIGHT                               
#define DISPID_IMARKUPPOINTER_CURRENTSCOPE                        
#define DISPID_IMARKUPPOINTER_ISLEFTOF                            
#define DISPID_IMARKUPPOINTER_ISLEFTOFOREQUALTO                   
#define DISPID_IMARKUPPOINTER_ISRIGHTOF                           
#define DISPID_IMARKUPPOINTER_ISRIGHTOFOREQUALTO                  
#define DISPID_IMARKUPPOINTER_ISEQUALTO                           
#define DISPID_IMARKUPPOINTER_MOVEUNIT                            
#define DISPID_IMARKUPPOINTER_FINDTEXT                            

//    DISPIDs for interface IMarkupPointer2

#define DISPID_IMARKUPPOINTER2_ISATWORDBREAK                      
#define DISPID_IMARKUPPOINTER2_GETMARKUPPOSITION                  
#define DISPID_IMARKUPPOINTER2_MOVETOMARKUPPOSITION               
#define DISPID_IMARKUPPOINTER2_MOVEUNITBOUNDED                    
#define DISPID_IMARKUPPOINTER2_ISINSIDEURL                        
#define DISPID_IMARKUPPOINTER2_MOVETOCONTENT                      

//    DISPIDs for interface IMarkupTextFrags

#define DISPID_IMARKUPTEXTFRAGS_GETTEXTFRAGCOUNT                  
#define DISPID_IMARKUPTEXTFRAGS_GETTEXTFRAG                       
#define DISPID_IMARKUPTEXTFRAGS_REMOVETEXTFRAG                    
#define DISPID_IMARKUPTEXTFRAGS_INSERTTEXTFRAG                    
#define DISPID_IMARKUPTEXTFRAGS_FINDTEXTFRAGFROMMARKUPPOINTER     

//    DISPIDs for interface IHTMLChangeLog

#define DISPID_IHTMLCHANGELOG_GETNEXTCHANGE                       

//    DISPIDs for interface IHTMLChangeSink

#define DISPID_IHTMLCHANGESINK_NOTIFY                             

//    DISPIDs for interface IXMLGenericParse

#define DISPID_IXMLGENERICPARSE_SETGENERICPARSE                   

//    DISPIDs for interface IHTMLEditHost

#define DISPID_IHTMLEDITHOST_SNAPRECT                             

//    DISPIDs for interface IHTMLEditHost2

#define DISPID_IHTMLEDITHOST2_PREDRAG                             

//    DISPIDs for interface ISegment

#define DISPID_ISEGMENT_GETPOINTERS                               

//    DISPIDs for interface ISegmentListIterator

#define DISPID_ISEGMENTLISTITERATOR_CURRENT                       
#define DISPID_ISEGMENTLISTITERATOR_FIRST                         
#define DISPID_ISEGMENTLISTITERATOR_ISDONE                        
#define DISPID_ISEGMENTLISTITERATOR_ADVANCE                       

//    DISPIDs for interface ISegmentList

#define DISPID_ISEGMENTLIST_CREATEITERATOR                        
#define DISPID_ISEGMENTLIST_GETTYPE                               
#define DISPID_ISEGMENTLIST_ISEMPTY                               

//    DISPIDs for interface ISequenceNumber

#define DISPID_ISEQUENCENUMBER_GETSEQUENCENUMBER                  

//    DISPIDs for interface IIMEServices

#define DISPID_IIMESERVICES_GETACTIVEIMM                          

//    DISPIDs for interface IHTMLCaret

#define DISPID_IHTMLCARET_MOVECARETTOPOINTER                      
#define DISPID_IHTMLCARET_MOVECARETTOPOINTEREX                    
#define DISPID_IHTMLCARET_MOVEMARKUPPOINTERTOCARET                
#define DISPID_IHTMLCARET_MOVEDISPLAYPOINTERTOCARET               
#define DISPID_IHTMLCARET_ISVISIBLE                               
#define DISPID_IHTMLCARET_SHOW                                    
#define DISPID_IHTMLCARET_HIDE                                    
#define DISPID_IHTMLCARET_INSERTTEXT                              
#define DISPID_IHTMLCARET_SCROLLINTOVIEW                          
#define DISPID_IHTMLCARET_GETLOCATION                             
#define DISPID_IHTMLCARET_GETCARETDIRECTION                       
#define DISPID_IHTMLCARET_SETCARETDIRECTION                       

//    DISPIDs for interface IHighlightRenderingServices

#define DISPID_IHIGHLIGHTRENDERINGSERVICES_ADDSEGMENT             
#define DISPID_IHIGHLIGHTRENDERINGSERVICES_MOVESEGMENTTOPOINTERS  
#define DISPID_IHIGHLIGHTRENDERINGSERVICES_REMOVESEGMENT          

//    DISPIDs for interface ISelectionServicesListener

#define DISPID_ISELECTIONSERVICESLISTENER_BEGINSELECTIONUNDO      
#define DISPID_ISELECTIONSERVICESLISTENER_ENDSELECTIONUNDO        
#define DISPID_ISELECTIONSERVICESLISTENER_ONSELECTEDELEMENTEXIT   
#define DISPID_ISELECTIONSERVICESLISTENER_ONCHANGETYPE            
#define DISPID_ISELECTIONSERVICESLISTENER_GETTYPEDETAIL           

//    DISPIDs for interface ISelectionServices

#define DISPID_ISELECTIONSERVICES_SETSELECTIONTYPE                
#define DISPID_ISELECTIONSERVICES_GETMARKUPCONTAINER              
#define DISPID_ISELECTIONSERVICES_ADDSEGMENT                      
#define DISPID_ISELECTIONSERVICES_ADDELEMENTSEGMENT               
#define DISPID_ISELECTIONSERVICES_REMOVESEGMENT                   
#define DISPID_ISELECTIONSERVICES_GETSELECTIONSERVICESLISTENER    

//    DISPIDs for interface IElementSegment

#define DISPID_IELEMENTSEGMENT_GETELEMENT                         
#define DISPID_IELEMENTSEGMENT_SETPRIMARY                         
#define DISPID_IELEMENTSEGMENT_ISPRIMARY                          

//    DISPIDs for interface IHTMLEditDesigner

#define DISPID_IHTMLEDITDESIGNER_PREHANDLEEVENT                   
#define DISPID_IHTMLEDITDESIGNER_POSTHANDLEEVENT                  
#define DISPID_IHTMLEDITDESIGNER_TRANSLATEACCELERATOR             
#define DISPID_IHTMLEDITDESIGNER_POSTEDITOREVENTNOTIFY            

//    DISPIDs for interface IHTMLEditServices

#define DISPID_IHTMLEDITSERVICES_ADDDESIGNER                      
#define DISPID_IHTMLEDITSERVICES_REMOVEDESIGNER                   
#define DISPID_IHTMLEDITSERVICES_GETSELECTIONSERVICES             
#define DISPID_IHTMLEDITSERVICES_MOVETOSELECTIONANCHOR            
#define DISPID_IHTMLEDITSERVICES_MOVETOSELECTIONEND               
#define DISPID_IHTMLEDITSERVICES_SELECTRANGE                      

//    DISPIDs for interface IHTMLEditServices2

#define DISPID_IHTMLEDITSERVICES2_MOVETOSELECTIONANCHOREX         
#define DISPID_IHTMLEDITSERVICES2_MOVETOSELECTIONENDEX            
#define DISPID_IHTMLEDITSERVICES2_FREEZEVIRTUALCARETPOS           
#define DISPID_IHTMLEDITSERVICES2_UNFREEZEVIRTUALCARETPOS         

//    DISPIDs for interface ILineInfo

#define DISPID_ILINEINFO_X                                        DISPID_ILINEINFO+1
#define DISPID_ILINEINFO_BASELINE                                 DISPID_ILINEINFO+2
#define DISPID_ILINEINFO_TEXTDESCENT                              DISPID_ILINEINFO+3
#define DISPID_ILINEINFO_TEXTHEIGHT                               DISPID_ILINEINFO+4
#define DISPID_ILINEINFO_LINEDIRECTION                            DISPID_ILINEINFO+5

//    DISPIDs for interface IHTMLComputedStyle

#define DISPID_IHTMLCOMPUTEDSTYLE_BOLD                            DISPID_IHTMLCOMPUTEDSTYLE+1
#define DISPID_IHTMLCOMPUTEDSTYLE_ITALIC                          DISPID_IHTMLCOMPUTEDSTYLE+2
#define DISPID_IHTMLCOMPUTEDSTYLE_UNDERLINE                       DISPID_IHTMLCOMPUTEDSTYLE+3
#define DISPID_IHTMLCOMPUTEDSTYLE_OVERLINE                        DISPID_IHTMLCOMPUTEDSTYLE+4
#define DISPID_IHTMLCOMPUTEDSTYLE_STRIKEOUT                       DISPID_IHTMLCOMPUTEDSTYLE+5
#define DISPID_IHTMLCOMPUTEDSTYLE_SUBSCRIPT                       DISPID_IHTMLCOMPUTEDSTYLE+6
#define DISPID_IHTMLCOMPUTEDSTYLE_SUPERSCRIPT                     DISPID_IHTMLCOMPUTEDSTYLE+7
#define DISPID_IHTMLCOMPUTEDSTYLE_EXPLICITFACE                    DISPID_IHTMLCOMPUTEDSTYLE+8
#define DISPID_IHTMLCOMPUTEDSTYLE_FONTWEIGHT                      DISPID_IHTMLCOMPUTEDSTYLE+9
#define DISPID_IHTMLCOMPUTEDSTYLE_FONTSIZE                        DISPID_IHTMLCOMPUTEDSTYLE+10
#define DISPID_IHTMLCOMPUTEDSTYLE_FONTNAME                        DISPID_IHTMLCOMPUTEDSTYLE+11
#define DISPID_IHTMLCOMPUTEDSTYLE_HASBGCOLOR                      DISPID_IHTMLCOMPUTEDSTYLE+12
#define DISPID_IHTMLCOMPUTEDSTYLE_TEXTCOLOR                       DISPID_IHTMLCOMPUTEDSTYLE+13
#define DISPID_IHTMLCOMPUTEDSTYLE_BACKGROUNDCOLOR                 DISPID_IHTMLCOMPUTEDSTYLE+14
#define DISPID_IHTMLCOMPUTEDSTYLE_PREFORMATTED                    DISPID_IHTMLCOMPUTEDSTYLE+15
#define DISPID_IHTMLCOMPUTEDSTYLE_DIRECTION                       DISPID_IHTMLCOMPUTEDSTYLE+16
#define DISPID_IHTMLCOMPUTEDSTYLE_BLOCKDIRECTION                  DISPID_IHTMLCOMPUTEDSTYLE+17
#define DISPID_IHTMLCOMPUTEDSTYLE_OL                              DISPID_IHTMLCOMPUTEDSTYLE+18
#define DISPID_IHTMLCOMPUTEDSTYLE_ISEQUAL                         

//    DISPIDs for interface IDisplayPointer

#define DISPID_IDISPLAYPOINTER_MOVETOPOINT                        
#define DISPID_IDISPLAYPOINTER_MOVEUNIT                           
#define DISPID_IDISPLAYPOINTER_POSITIONMARKUPPOINTER              
#define DISPID_IDISPLAYPOINTER_MOVETOPOINTER                      
#define DISPID_IDISPLAYPOINTER_SETPOINTERGRAVITY                  
#define DISPID_IDISPLAYPOINTER_GETPOINTERGRAVITY                  
#define DISPID_IDISPLAYPOINTER_SETDISPLAYGRAVITY                  
#define DISPID_IDISPLAYPOINTER_GETDISPLAYGRAVITY                  
#define DISPID_IDISPLAYPOINTER_ISPOSITIONED                       
#define DISPID_IDISPLAYPOINTER_UNPOSITION                         
#define DISPID_IDISPLAYPOINTER_ISEQUALTO                          
#define DISPID_IDISPLAYPOINTER_ISLEFTOF                           
#define DISPID_IDISPLAYPOINTER_ISRIGHTOF                          
#define DISPID_IDISPLAYPOINTER_ISATBOL                            
#define DISPID_IDISPLAYPOINTER_MOVETOMARKUPPOINTER                
#define DISPID_IDISPLAYPOINTER_SCROLLINTOVIEW                     
#define DISPID_IDISPLAYPOINTER_GETLINEINFO                        
#define DISPID_IDISPLAYPOINTER_GETFLOWELEMENT                     
#define DISPID_IDISPLAYPOINTER_QUERYBREAKS                        

//    DISPIDs for interface IDisplayServices

#define DISPID_IDISPLAYSERVICES_CREATEDISPLAYPOINTER              
#define DISPID_IDISPLAYSERVICES_TRANSFORMRECT                     
#define DISPID_IDISPLAYSERVICES_TRANSFORMPOINT                    
#define DISPID_IDISPLAYSERVICES_GETCARET                          
#define DISPID_IDISPLAYSERVICES_GETCOMPUTEDSTYLE                  
#define DISPID_IDISPLAYSERVICES_SCROLLRECTINTOVIEW                
#define DISPID_IDISPLAYSERVICES_HASFLOWLAYOUT                     

//    DISPIDs for interface IHtmlDlgSafeHelper

#define DISPID_IHTMLDLGSAFEHELPER_CHOOSECOLORDLG                  1
#define DISPID_IHTMLDLGSAFEHELPER_GETCHARSET                      2
#define DISPID_IHTMLDLGSAFEHELPER_FONTS                           3
#define DISPID_IHTMLDLGSAFEHELPER_BLOCKFORMATS                    4

//    DISPIDs for interface IBlockFormats

#define DISPID_IBLOCKFORMATS__NEWENUM                             DISPID_NEWENUM
#define DISPID_IBLOCKFORMATS_COUNT                                1
#define DISPID_IBLOCKFORMATS_ITEM                                 DISPID_VALUE

//    DISPIDs for interface IFontNames

#define DISPID_IFONTNAMES__NEWENUM                                DISPID_NEWENUM
#define DISPID_IFONTNAMES_COUNT                                   1
#define DISPID_IFONTNAMES_ITEM                                    DISPID_VALUE

//    DISPIDs for interface IHTMLNamespace

#define DISPID_IHTMLNAMESPACE_NAME                                DISPID_NAMESPACE+0
#define DISPID_IHTMLNAMESPACE_URN                                 DISPID_NAMESPACE+1
#define DISPID_IHTMLNAMESPACE_TAGNAMES                            DISPID_NAMESPACE+2
#define DISPID_IHTMLNAMESPACE_READYSTATE                          DISPID_A_READYSTATE
#define DISPID_IHTMLNAMESPACE_ONREADYSTATECHANGE                  DISPID_EVPROP_ONREADYSTATECHANGE
#define DISPID_IHTMLNAMESPACE_DOIMPORT                            DISPID_NAMESPACE+3
#define DISPID_IHTMLNAMESPACE_ATTACHEVENT                         DISPID_HTMLOBJECT+7
#define DISPID_IHTMLNAMESPACE_DETACHEVENT                         DISPID_HTMLOBJECT+8

//    DISPIDs for interface IHTMLNamespaceCollection

#define DISPID_IHTMLNAMESPACECOLLECTION_LENGTH                    DISPID_NAMESPACE_COLLECTION+0
#define DISPID_IHTMLNAMESPACECOLLECTION_ITEM                      DISPID_VALUE
#define DISPID_IHTMLNAMESPACECOLLECTION_ADD                       DISPID_NAMESPACE_COLLECTION+1

//    DISPIDs for event set HTMLNamespaceEvents

#define DISPID_HTMLNAMESPACEEVENTS_ONREADYSTATECHANGE             DISPID_EVMETH_ONREADYSTATECHANGE

//    DISPIDs for interface IHTMLPainter

#define DISPID_IHTMLPAINTER_DRAW                                  
#define DISPID_IHTMLPAINTER_ONRESIZE                              
#define DISPID_IHTMLPAINTER_GETPAINTERINFO                        
#define DISPID_IHTMLPAINTER_HITTESTPOINT                          

//    DISPIDs for interface IHTMLPainterEventInfo

#define DISPID_IHTMLPAINTEREVENTINFO_GETEVENTINFOFLAGS            
#define DISPID_IHTMLPAINTEREVENTINFO_GETEVENTTARGET               
#define DISPID_IHTMLPAINTEREVENTINFO_SETCURSOR                    
#define DISPID_IHTMLPAINTEREVENTINFO_STRINGFROMPARTID             

//    DISPIDs for interface IHTMLPainterOverlay

#define DISPID_IHTMLPAINTEROVERLAY_ONMOVE                         

//    DISPIDs for interface IHTMLPaintSite

#define DISPID_IHTMLPAINTSITE_INVALIDATEPAINTERINFO               
#define DISPID_IHTMLPAINTSITE_INVALIDATERECT                      
#define DISPID_IHTMLPAINTSITE_INVALIDATEREGION                    
#define DISPID_IHTMLPAINTSITE_GETDRAWINFO                         
#define DISPID_IHTMLPAINTSITE_TRANSFORMGLOBALTOLOCAL              
#define DISPID_IHTMLPAINTSITE_TRANSFORMLOCALTOGLOBAL              
#define DISPID_IHTMLPAINTSITE_GETHITTESTCOOKIE                    

//    DISPIDs for interface IHTMLIPrintCollection

#define DISPID_IHTMLIPRINTCOLLECTION_LENGTH                       DISPID_OPTIONS_COL+1
#define DISPID_IHTMLIPRINTCOLLECTION__NEWENUM                     DISPID_NEWENUM
#define DISPID_IHTMLIPRINTCOLLECTION_ITEM                         DISPID_VALUE

//    DISPIDs for interface IEnumPrivacyRecords

#define DISPID_IENUMPRIVACYRECORDS_RESET                          
#define DISPID_IENUMPRIVACYRECORDS_GETSIZE                        
#define DISPID_IENUMPRIVACYRECORDS_GETPRIVACYIMPACTED             
#define DISPID_IENUMPRIVACYRECORDS_NEXT                           

//    DISPIDs for interface IHTMLDialog

#define DISPID_IHTMLDIALOG_DIALOGTOP                              STDPROPID_XOBJ_TOP
#define DISPID_IHTMLDIALOG_DIALOGLEFT                             STDPROPID_XOBJ_LEFT
#define DISPID_IHTMLDIALOG_DIALOGWIDTH                            STDPROPID_XOBJ_WIDTH
#define DISPID_IHTMLDIALOG_DIALOGHEIGHT                           STDPROPID_XOBJ_HEIGHT
#define DISPID_IHTMLDIALOG_DIALOGARGUMENTS                        DISPID_HTMLDLG+0
#define DISPID_IHTMLDIALOG_MENUARGUMENTS                          DISPID_HTMLDLG+13
#define DISPID_IHTMLDIALOG_RETURNVALUE                            DISPID_HTMLDLG+1
#define DISPID_IHTMLDIALOG_CLOSE                                  DISPID_HTMLDLG+11
#define DISPID_IHTMLDIALOG_TOSTRING                               DISPID_HTMLDLG+12

//    DISPIDs for interface IHTMLDialog2

#define DISPID_IHTMLDIALOG2_STATUS                                DISPID_HTMLDLG+14
#define DISPID_IHTMLDIALOG2_RESIZABLE                             DISPID_HTMLDLG+15

//    DISPIDs for interface IHTMLDialog3

#define DISPID_IHTMLDIALOG3_UNADORNED                             DISPID_HTMLDLG+16
#define DISPID_IHTMLDIALOG3_DIALOGHIDE                            DISPID_HTMLDLG+7

//    DISPIDs for interface IHTMLModelessInit

#define DISPID_IHTMLMODELESSINIT_PARAMETERS                       DISPID_HTMLDLG+0
#define DISPID_IHTMLMODELESSINIT_OPTIONSTRING                     DISPID_HTMLDLG+1
#define DISPID_IHTMLMODELESSINIT_MONIKER                          DISPID_HTMLDLG+6
#define DISPID_IHTMLMODELESSINIT_DOCUMENT                         DISPID_HTMLDLG+7

//    DISPIDs for interface IHTMLPopup

#define DISPID_IHTMLPOPUP_SHOW                                    DISPID_HTMLPOPUP+1
#define DISPID_IHTMLPOPUP_HIDE                                    DISPID_HTMLPOPUP+2
#define DISPID_IHTMLPOPUP_DOCUMENT                                DISPID_HTMLPOPUP+3
#define DISPID_IHTMLPOPUP_ISOPEN                                  DISPID_HTMLPOPUP+4

//    DISPIDs for interface IHTMLAppBehavior

#define DISPID_IHTMLAPPBEHAVIOR_APPLICATIONNAME                   DISPID_HTMLAPP+0
#define DISPID_IHTMLAPPBEHAVIOR_VERSION                           DISPID_HTMLAPP+1
#define DISPID_IHTMLAPPBEHAVIOR_ICON                              DISPID_HTMLAPP+2
#define DISPID_IHTMLAPPBEHAVIOR_SINGLEINSTANCE                    DISPID_HTMLAPP+3
#define DISPID_IHTMLAPPBEHAVIOR_MINIMIZEBUTTON                    DISPID_HTMLAPP+5
#define DISPID_IHTMLAPPBEHAVIOR_MAXIMIZEBUTTON                    DISPID_HTMLAPP+6
#define DISPID_IHTMLAPPBEHAVIOR_BORDER                            DISPID_HTMLAPP+7
#define DISPID_IHTMLAPPBEHAVIOR_BORDERSTYLE                       DISPID_HTMLAPP+8
#define DISPID_IHTMLAPPBEHAVIOR_SYSMENU                           DISPID_HTMLAPP+9
#define DISPID_IHTMLAPPBEHAVIOR_CAPTION                           DISPID_HTMLAPP+10
#define DISPID_IHTMLAPPBEHAVIOR_WINDOWSTATE                       DISPID_HTMLAPP+11
#define DISPID_IHTMLAPPBEHAVIOR_SHOWINTASKBAR                     DISPID_HTMLAPP+12
#define DISPID_IHTMLAPPBEHAVIOR_COMMANDLINE                       DISPID_HTMLAPP+13

//    DISPIDs for interface IHTMLAppBehavior2

#define DISPID_IHTMLAPPBEHAVIOR2_CONTEXTMENU                      DISPID_HTMLAPP+14
#define DISPID_IHTMLAPPBEHAVIOR2_INNERBORDER                      DISPID_HTMLAPP+15
#define DISPID_IHTMLAPPBEHAVIOR2_SCROLL                           DISPID_HTMLAPP+16
#define DISPID_IHTMLAPPBEHAVIOR2_SCROLLFLAT                       DISPID_HTMLAPP+17
#define DISPID_IHTMLAPPBEHAVIOR2_SELECTION                        DISPID_HTMLAPP+18

//    DISPIDs for interface IHTMLAppBehavior3

#define DISPID_IHTMLAPPBEHAVIOR3_NAVIGABLE                        DISPID_HTMLAPP+19

//    DISPIDs for interface IHTMLPrivateWindow

#define DISPID_IHTMLPRIVATEWINDOW_SUPERNAVIGATE                   
#define DISPID_IHTMLPRIVATEWINDOW_GETPENDINGURL                   
#define DISPID_IHTMLPRIVATEWINDOW_SETPICSTARGET                   
#define DISPID_IHTMLPRIVATEWINDOW_PICSCOMPLETE                    
#define DISPID_IHTMLPRIVATEWINDOW_FINDWINDOWBYNAME                
#define DISPID_IHTMLPRIVATEWINDOW_GETADDRESSBARURL                

//    DISPIDs for interface IHTMLPrivateWindow2

#define DISPID_IHTMLPRIVATEWINDOW2_NAVIGATEEX                     
#define DISPID_IHTMLPRIVATEWINDOW2_GETINNERWINDOWUNKNOWN          

//    DISPIDs for interface IHTMLPrivateWindow3

#define DISPID_IHTMLPRIVATEWINDOW3_OPENEX                         

//    DISPIDs for interface ISubDivisionProvider

#define DISPID_ISUBDIVISIONPROVIDER_GETSUBDIVISIONCOUNT           
#define DISPID_ISUBDIVISIONPROVIDER_GETSUBDIVISIONTABS            
#define DISPID_ISUBDIVISIONPROVIDER_SUBDIVISIONFROMPT             

//    DISPIDs for interface IElementBehaviorUI

#define DISPID_IELEMENTBEHAVIORUI_ONRECEIVEFOCUS                  
#define DISPID_IELEMENTBEHAVIORUI_GETSUBDIVISIONPROVIDER          
#define DISPID_IELEMENTBEHAVIORUI_CANTAKEFOCUS                    

//    DISPIDs for interface IElementAdorner

#define DISPID_IELEMENTADORNER_DRAW                               
#define DISPID_IELEMENTADORNER_HITTESTPOINT                       
#define DISPID_IELEMENTADORNER_GETSIZE                            
#define DISPID_IELEMENTADORNER_GETPOSITION                        
#define DISPID_IELEMENTADORNER_ONPOSITIONSET                      

//    DISPIDs for interface IHTMLEditor

#define DISPID_IHTMLEDITOR_PREHANDLEEVENT                         
#define DISPID_IHTMLEDITOR_POSTHANDLEEVENT                        
#define DISPID_IHTMLEDITOR_TRANSLATEACCELERATOR                   
#define DISPID_IHTMLEDITOR_INITIALIZE                             
#define DISPID_IHTMLEDITOR_NOTIFY                                 
#define DISPID_IHTMLEDITOR_GETCOMMANDTARGET                       
#define DISPID_IHTMLEDITOR_GETELEMENTTOTABFROM                    
#define DISPID_IHTMLEDITOR_ISEDITCONTEXTUIACTIVE                  
#define DISPID_IHTMLEDITOR_TERMINATEIMECOMPOSITION                
#define DISPID_IHTMLEDITOR_ENABLEMODELESS                         

//    DISPIDs for interface IHTMLEditingServices

#define DISPID_IHTMLEDITINGSERVICES_DELETE                        
#define DISPID_IHTMLEDITINGSERVICES_PASTE                         
#define DISPID_IHTMLEDITINGSERVICES_PASTEFROMCLIPBOARD            
#define DISPID_IHTMLEDITINGSERVICES_LAUNDERSPACES                 
#define DISPID_IHTMLEDITINGSERVICES_INSERTSANITIZEDTEXT           
#define DISPID_IHTMLEDITINGSERVICES_URLAUTODETECTCURRENTWORD      
#define DISPID_IHTMLEDITINGSERVICES_URLAUTODETECTRANGE            
#define DISPID_IHTMLEDITINGSERVICES_SHOULDUPDATEANCHORTEXT        
#define DISPID_IHTMLEDITINGSERVICES_ADJUSTPOINTERFORINSERT        
#define DISPID_IHTMLEDITINGSERVICES_FINDSITESELECTABLEELEMENT     
#define DISPID_IHTMLEDITINGSERVICES_ISELEMENTSITESELECTABLE       
#define DISPID_IHTMLEDITINGSERVICES_ISELEMENTUIACTIVATABLE        
#define DISPID_IHTMLEDITINGSERVICES_ISELEMENTATOMIC               
#define DISPID_IHTMLEDITINGSERVICES_POSITIONPOINTERSINMASTER      

//    DISPIDs for interface ISelectionObject2

#define DISPID_ISELECTIONOBJECT2_SELECT                           
#define DISPID_ISELECTIONOBJECT2_ISPOINTERINSELECTION             
#define DISPID_ISELECTIONOBJECT2_EMPTYSELECTION                   
#define DISPID_ISELECTIONOBJECT2_DESTROYSELECTION                 
#define DISPID_ISELECTIONOBJECT2_DESTROYALLSELECTION              

//    DISPIDs for interface IEditDebugServices

#define DISPID_IEDITDEBUGSERVICES_GETCP                           
#define DISPID_IEDITDEBUGSERVICES_SETDEBUGNAME                    
#define DISPID_IEDITDEBUGSERVICES_SETDISPLAYPOINTERDEBUGNAME      
#define DISPID_IEDITDEBUGSERVICES_DUMPTREE                        
#define DISPID_IEDITDEBUGSERVICES_LINESINELEMENT                  
#define DISPID_IEDITDEBUGSERVICES_FONTSONLINE                     
#define DISPID_IEDITDEBUGSERVICES_GETPIXEL                        
#define DISPID_IEDITDEBUGSERVICES_ISUSINGBCKGRNRECALC             
#define DISPID_IEDITDEBUGSERVICES_ISENCODINGAUTOSELECT            
#define DISPID_IEDITDEBUGSERVICES_ENABLEENCODINGAUTOSELECT        
#define DISPID_IEDITDEBUGSERVICES_ISUSINGTABLEINCRECALC           

//    DISPIDs for interface IPrivacyServices

#define DISPID_IPRIVACYSERVICES_ADDPRIVACYINFOTOLIST              

//    DISPIDs for interface IHTMLOMWindowServices

#define DISPID_IHTMLOMWINDOWSERVICES_MOVETO                       
#define DISPID_IHTMLOMWINDOWSERVICES_MOVEBY                       
#define DISPID_IHTMLOMWINDOWSERVICES_RESIZETO                     
#define DISPID_IHTMLOMWINDOWSERVICES_RESIZEBY                     

//    DISPIDs for interface IHTMLFilterPainter

#define DISPID_IHTMLFILTERPAINTER_INVALIDATERECTUNFILTERED        
#define DISPID_IHTMLFILTERPAINTER_INVALIDATERGNUNFILTERED         
#define DISPID_IHTMLFILTERPAINTER_CHANGEELEMENTVISIBILITY         

//    DISPIDs for interface IHTMLFilterPaintSite

#define DISPID_IHTMLFILTERPAINTSITE_DRAWUNFILTERED                
#define DISPID_IHTMLFILTERPAINTSITE_HITTESTPOINTUNFILTERED        
#define DISPID_IHTMLFILTERPAINTSITE_INVALIDATERECTFILTERED        
#define DISPID_IHTMLFILTERPAINTSITE_INVALIDATERGNFILTERED         
#define DISPID_IHTMLFILTERPAINTSITE_CHANGEFILTERVISIBILITY        
#define DISPID_IHTMLFILTERPAINTSITE_ENSUREVIEWFORFILTERSITE       
#define DISPID_IHTMLFILTERPAINTSITE_GETDIRECTDRAW                 
#define DISPID_IHTMLFILTERPAINTSITE_GETFILTERFLAGS                

//    DISPIDs for interface IElementNamespacePrivate

#define DISPID_IELEMENTNAMESPACEPRIVATE_ADDTAGPRIVATE             

//    DISPIDs for interface IElementBehaviorFactory

#define DISPID_IELEMENTBEHAVIORFACTORY_FINDBEHAVIOR               

//    DISPIDs for interface IElementNamespace

#define DISPID_IELEMENTNAMESPACE_ADDTAG                           

//    DISPIDs for interface IElementNamespaceTable

#define DISPID_IELEMENTNAMESPACETABLE_ADDNAMESPACE                

//    DISPIDs for interface IElementNamespaceFactory

#define DISPID_IELEMENTNAMESPACEFACTORY_CREATE                    

//    DISPIDs for interface IElementNamespaceFactory2

#define DISPID_IELEMENTNAMESPACEFACTORY2_CREATEWITHIMPLEMENTATION 

//    DISPIDs for interface IElementNamespaceFactoryCallback

#define DISPID_IELEMENTNAMESPACEFACTORYCALLBACK_RESOLVE           

//    DISPIDs for interface IElementBehavior

#define DISPID_IELEMENTBEHAVIOR_INIT                              
#define DISPID_IELEMENTBEHAVIOR_NOTIFY                            
#define DISPID_IELEMENTBEHAVIOR_DETACH                            

//    DISPIDs for interface IElementBehaviorSite

#define DISPID_IELEMENTBEHAVIORSITE_GETELEMENT                    
#define DISPID_IELEMENTBEHAVIORSITE_REGISTERNOTIFICATION          

//    DISPIDs for interface IElementBehaviorSiteOM

#define DISPID_IELEMENTBEHAVIORSITEOM_REGISTEREVENT               
#define DISPID_IELEMENTBEHAVIORSITEOM_GETEVENTCOOKIE              
#define DISPID_IELEMENTBEHAVIORSITEOM_FIREEVENT                   
#define DISPID_IELEMENTBEHAVIORSITEOM_CREATEEVENTOBJECT           
#define DISPID_IELEMENTBEHAVIORSITEOM_REGISTERNAME                
#define DISPID_IELEMENTBEHAVIORSITEOM_REGISTERURN                 

//    DISPIDs for interface IElementBehaviorSiteOM2

#define DISPID_IELEMENTBEHAVIORSITEOM2_GETDEFAULTS                

//    DISPIDs for interface IElementBehaviorRender

#define DISPID_IELEMENTBEHAVIORRENDER_DRAW                        
#define DISPID_IELEMENTBEHAVIORRENDER_GETRENDERINFO               
#define DISPID_IELEMENTBEHAVIORRENDER_HITTESTPOINT                

//    DISPIDs for interface IElementBehaviorSiteRender

#define DISPID_IELEMENTBEHAVIORSITERENDER_INVALIDATE              
#define DISPID_IELEMENTBEHAVIORSITERENDER_INVALIDATERENDERINFO    
#define DISPID_IELEMENTBEHAVIORSITERENDER_INVALIDATESTYLE         

//    DISPIDs for interface IElementBehaviorCategory

#define DISPID_IELEMENTBEHAVIORCATEGORY_GETCATEGORY               

//    DISPIDs for interface IElementBehaviorSiteCategory

#define DISPID_IELEMENTBEHAVIORSITECATEGORY_GETRELATEDBEHAVIORS   

//    DISPIDs for interface IElementBehaviorSubmit

#define DISPID_IELEMENTBEHAVIORSUBMIT_GETSUBMITINFO               
#define DISPID_IELEMENTBEHAVIORSUBMIT_RESET                       

//    DISPIDs for interface IElementBehaviorFocus

#define DISPID_IELEMENTBEHAVIORFOCUS_GETFOCUSRECT                 

//    DISPIDs for interface IElementBehaviorLayout

#define DISPID_IELEMENTBEHAVIORLAYOUT_GETSIZE                     
#define DISPID_IELEMENTBEHAVIORLAYOUT_GETLAYOUTINFO               
#define DISPID_IELEMENTBEHAVIORLAYOUT_GETPOSITION                 
#define DISPID_IELEMENTBEHAVIORLAYOUT_MAPSIZE                     

//    DISPIDs for interface IElementBehaviorLayout2

#define DISPID_IELEMENTBEHAVIORLAYOUT2_GETTEXTDESCENT             

//    DISPIDs for interface IElementBehaviorSiteLayout

#define DISPID_IELEMENTBEHAVIORSITELAYOUT_INVALIDATELAYOUTINFO    
#define DISPID_IELEMENTBEHAVIORSITELAYOUT_INVALIDATESIZE          
#define DISPID_IELEMENTBEHAVIORSITELAYOUT_GETMEDIARESOLUTION      

//    DISPIDs for interface IElementBehaviorSiteLayout2

#define DISPID_IELEMENTBEHAVIORSITELAYOUT2_GETFONTINFO            

//    DISPIDs for interface IHostBehaviorInit

#define DISPID_IHOSTBEHAVIORINIT_POPULATENAMESPACETABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\mshtmdbg.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       mshtmdbg.h
//
//  Contents:   External include file for mshtmdbg.dll
//
// ----------------------------------------------------------------------------

#ifndef _MSHTMDBG_H_
#define _MSHTMDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MSHTMDBG_API_VERSION    (7)     // Increment whenever API changes

struct IUnknown;

typedef INT     TRACETAG;
typedef INT_PTR PERFTAG;
typedef INT_PTR PERFMETERTAG;

DWORD       WINAPI  DbgExGetVersion();
BOOL        WINAPI  DbgExIsFullDebug();
void        WINAPI  DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

void        WINAPI  DbgExDoTracePointsDialog(BOOL fWait);
void        WINAPI  DbgExRestoreDefaultDebugState();

BOOL        WINAPI  DbgExEnableTag(TRACETAG tag, BOOL fEnable);
BOOL        WINAPI  DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk);
BOOL        WINAPI  DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak);
BOOL        WINAPI  DbgExIsTagEnabled(TRACETAG tag);
TRACETAG    WINAPI  DbgExFindTag(char * szTagDesc);

TRACETAG    WINAPI  DbgExTagError();
TRACETAG    WINAPI  DbgExTagWarning();
TRACETAG    WINAPI  DbgExTagThread();
TRACETAG    WINAPI  DbgExTagAssertExit();
TRACETAG    WINAPI  DbgExTagAssertStacks();
TRACETAG    WINAPI  DbgExTagMemoryStrict();
TRACETAG    WINAPI  DbgExTagCoMemoryStrict();
TRACETAG    WINAPI  DbgExTagMemoryStrictTail();
TRACETAG    WINAPI  DbgExTagMemoryStrictAlign();
TRACETAG    WINAPI  DbgExTagOLEWatch();
TRACETAG    WINAPI  DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagPerf();

BOOL        __cdecl DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...);
BOOL        __cdecl DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...);
BOOL        WINAPI  DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
void        WINAPI  DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal);

BOOL        WINAPI  DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage);
void        WINAPI  DbgExAssertThreadDisable(BOOL fDisable);
HRESULT     __cdecl DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...);
HRESULT     WINAPI  DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker);

size_t      WINAPI  DbgExPreAlloc(size_t cbRequest);
void *      WINAPI  DbgExPostAlloc(void *pv);
void *      WINAPI  DbgExPreFree(void *pv);
void        WINAPI  DbgExPostFree();
size_t      WINAPI  DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv);
void *      WINAPI  DbgExPostRealloc(void *pv);
void *      WINAPI  DbgExPreGetSize(void *pvRequest);
size_t      WINAPI  DbgExPostGetSize(size_t cb);
void *      WINAPI  DbgExPreDidAlloc(void *pvRequest);
BOOL        WINAPI  DbgExPostDidAlloc(void *pvRequest, BOOL fActual);

void        WINAPI  DbgExMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExCoMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExMemoryBlockTrackDisable(void * pv);
void        WINAPI  DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt);
void *      WINAPI  DbgExGetMallocSpy();
void        WINAPI  DbgExTraceMemoryLeaks();
BOOL        WINAPI  DbgExValidateInternalHeap();

LONG_PTR    WINAPI  DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
LONG_PTR    WINAPI  DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite);
void        WINAPI  DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExSetSimFailCounts(int firstFailure, int cInterval);
void        WINAPI  DbgExShowSimFailDlg();
BOOL        WINAPI  DbgExFFail();
int         WINAPI  DbgExGetFailCount();
void        WINAPI  DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv);

void        WINAPI  DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize);
void        WINAPI  DbgExOpenMemoryMonitor();
void        WINAPI  DbgExOpenLogFile(LPCSTR szFName);

void *      __cdecl DbgExMemSetName(void *pvRequest, char * szFmt, ...);
void *      WINAPI  DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker);
char *      WINAPI  DbgExMemGetName(void *pvRequest);

HRESULT     WINAPI  DbgExWsClear(HANDLE hProcess);
HRESULT     WINAPI  DbgExWsTakeSnapshot(HANDLE hProcess);
BSTR        WINAPI  DbgExWsGetModule(long row);
BSTR        WINAPI  DbgExWsGetSection(long row);
long        WINAPI  DbgExWsSize(long row);
long        WINAPI  DbgExWsCount();
long        WINAPI  DbgExWsTotal();
HRESULT     WINAPI  DbgExWsStartDelta(HANDLE hProcess);
long        WINAPI  DbgExWsEndDelta(HANDLE hProcess);

void        WINAPI  DbgExDumpProcessHeaps();

PERFTAG     WINAPI  DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip);
void        __cdecl DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...);
void        WINAPI  DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker);
void        WINAPI  DbgExPerfDump();
void        WINAPI  DbgExPerfClear();
void        WINAPI  DbgExPerfTags();
void        WINAPI  DbgExPerfEnable(BOOL fEnable);

char *      WINAPI  DbgExDecodeMessage(UINT msg);

PERFMETERTAG WINAPI  DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip);
void        WINAPI  DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
void        WINAPI  DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
char *      WINAPI  DbgExMtGetName(PERFMETERTAG mt);
char *      WINAPI  DbgExMtGetDesc(PERFMETERTAG mt);
BOOL        WINAPI  DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue);
void        WINAPI  DbgExMtOpenMonitor();
void        WINAPI  DbgExMtLogDump(LPSTR pchFile);
PERFMETERTAG WINAPI  DbgExMtLookupMeter(char * szTag);
long        WINAPI  DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive);
long        WINAPI  DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive);

void        WINAPI  DbgExSetTopUrl(LPWSTR pstrUrl);
void        WINAPI  DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf);

BOOL        WINAPI  DbgExGetChkStkFill(DWORD * pdwFill);
int         WINAPI  DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol);

#ifdef __cplusplus
}
#endif

// Performance Logging --------------------------------------------------------

#ifdef PERFTAGS

#define     IsPerfEnabled(tag) (*(BOOL *)tag)
#define     PerfTag(tag, szOwner, szDescrip) PERFTAG tag(DbgExPerfRegister(#tag, szOwner, szDescrip));
#define     PerfExtern(tag) extern PERFTAG tag;
#define     PerfLog(tag,pv,f) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f) : 0
#define     PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1) : 0
#define     PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2) : 0
#define     PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0
#define     PerfDump()  DbgExPerfDump()
#define     PerfClear() DbgExPerfClear()
#define     PerfTags()  DbgExPerfTags()
#define     PerfEnable(fEnable) DbgExPerfEnable(fEnable)

#else

#define     IsPerfEnabled(tag) (FALSE)
#define     PerfTag(tag, szOwner, szDescrip)
#define     PerfExtern(tag)
#define     PerfLog(tag,pv,f)
#define     PerfLog1(tag,pv,f,a1)
#define     PerfLog2(tag,pv,f,a1,a2)
#define     PerfLog3(tag,pv,f,a1,a2,a3)
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define     PerfDump()
#define     PerfClear()
#define     PerfTags()
#define     PerfEnable(fEnable)

#endif

// Performance Metering -------------------------------------------------------

#ifdef PERFMETER

#define     Mt(x)                               g_mt##x
#define     MtExtern(tag)                       extern PERFMETERTAG g_mt##tag;
#define     MtDefine(tag, tagOwner, szDescrip)  PERFMETERTAG g_mt##tag(DbgExMtRegister("mt" #tag, "mt" #tagOwner, szDescrip));
#define     MtAdd(mt, lCnt, lVal)               DbgExMtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)               DbgExMtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewVal)  DbgExMtSimulateOutOfMemory(mt, lNewVal)
#define     MtOpenMonitor()                     DbgExMtOpenMonitor()

#else

#define     Mt(x)                               ((PERFMETERTAG)0)
#define     MtExtern(tag)
#define     MtDefine(tag, szOwner, szDescrip)
#define     MtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewValue)
#define     MtOpenMonitor()

#endif

// MSHTML perf control --------------------------------------------------------

#define HTMPERFCTL_NAME     "#MSHTML#PERF#"

enum
{
    HTMPF_CALLBACK_ONLOAD   = 0x00000001,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: strURL)
    HTMPF_ENABLE_PROFILE    = 0x00000002,   // enable profiling
    HTMPF_ENABLE_MEMWATCH   = 0x00000004,   // enable memwatch sampling
    HTMPF_DISABLE_PADEVENTS = 0x00000008,   // disable firing of events from mshtmpad.exe
    HTMPF_DISABLE_IMGCACHE  = 0x00000010,   // disable image cache in mshtml
    HTMPF_DISABLE_OFFSCREEN = 0x00000020,   // disable offscreen buffering
    HTMPF_DISABLE_ALERTS    = 0x00000040,   // disable alert() and confirm() methods
    HTMPF_SYNC_DATABIND     = 0x00000080,   // grab all records at once for databinding
    HTMPF_CALLBACK_ONLOAD2  = 0x00000100,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWQ  = 0x00000200,   // callback when ensure view is queued (dwArg1: HTMPF_CALLBACK_ONVIEWQ, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWD  = 0x00000400,   // callback when ensure view is dequeued (dwArg1: HTMPF_CALLBACK_ONVIEWD, dwArg2: CDoc IUnk)
#ifndef NO_ETW_TRACING
    HTMPF_CALLBACK_ONEVENT  = 0x00000800    // callback when event tracing for windows is enabled
                                            // (dwArg1: UCHAR EVENT-TYPE, dwArg2: WCHAR* URL)
                                            // See shlwapi.w for event types.
#endif
};

typedef void (WINAPI *HTMPFCBFN)(DWORD dwArg1, void * pvArg2);

typedef struct HTMPERFCTL
{
    DWORD       dwSize;     // set to sizeof(MSHTMLPERF)
    DWORD       dwFlags;    // see HTMPF_*
    HTMPFCBFN   pfnCall;    // Callback function
    void *      pvHost;     // Private data for host
} HTMPERFCTL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\mstimeid.h ===
// Copyright (C) Microsoft Corporation, 1999
//
// IDs for HTML+TIME
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __TIMEDISPID_H__
#define __TIMEDISPID_H__

// Base offset:

//
// need to reposition our IDs low for DHTML Behaviors
//

#define DISPID_BASE                                             0x00000000

// Interface offsets:
#define TIMEELEMENT_OFFSET                                      0x0100
#define TIMEBODYELEMENT_OFFSET                                  0x0200
#define TIMEANIMATIONELEMENT_OFFSET                             0x0300
#define TIMEMEDIAELEMENT_OFFSET                                 0x0400
#define TIMEFACTORY_OFFSET                                      0x0500
#define TIMECOLLECTION_OFFSET                                   0x0600
#define TIMECOLLECTION_RESERVED_OFFSET                          0x0700
#define TIMEMEDIAPLAYER_OFFSET                                  0x0800
#define TIMEMEDIAPLAYERAUDIO_OFFSET                             0x0900
#define TIMEEVENTELEMENT_OFFSET                                 0x0A00
#define TIMEPLAYLIST_OFFSET                                     0x0B00
#define TIMEPLAYITEM_OFFSET                                     0x0C00
#define TIMEDVDPLAYEROBJECT_OFFSET                              0x0D00
#define SMILANIMATIONCOMPSITE_OFFSET                            0x0E00
#define SMILANIMATIONFRAGMENT_OFFSET                            0x0F00
#define TIMESTATE_OFFSET                                        0x1000
#define TIMEDMPLAYEROBJECT_OFFSET                               0x1100
#define TIMEMEDIAPLAYERSITE_OFFSET                              0x1200
#define TIMEMEDIAPLAYERCONTROL_OFFSET                           0x1300
#define TIMEMEDIAELEMENT2_OFFSET                                0x1400
#define TIMETRANSITIONELEMENT_OFFSET                            0x1500
#define TIMEMEDIAPLAYERNETWORK_OFFSET                           0x1600

#define DISPID_TIME_MIN                                         0x0001
#define DISPID_TIME_MAX                                         0x270F

// Interface bases:
#define DISPID_TIMEELEMENT_BASE                                 (DISPID_BASE + TIMEELEMENT_OFFSET)
#define DISPID_TIMEBODYELEMENT_BASE                             (DISPID_BASE + TIMEBODYELEMENT_OFFSET)
#define DISPID_TIMEMEDIAELEMENT_BASE                            (DISPID_BASE + TIMEMEDIAELEMENT_OFFSET)
#define DISPID_TIMEEVENTELEMENT_BASE                            (DISPID_BASE + TIMEEVENTELEMENT_OFFSET)
#define DISPID_TIMEFACTORY_BASE                                 (DISPID_BASE + TIMEFACTORY_OFFSET)
#define DISPID_TIMECOLLECTION_BASE                              (DISPID_BASE + TIMECOLLECTION_OFFSET)
#define DISPID_TIMECOLLECTION_RESERVED_BASE                     (DISPID_BASE + TIMECOLLECTION_RESERVED_OFFSET)
#define DISPID_TIMEMEDIAPLAYER_BASE                             (DISPID_BASE + TIMEMEDIAPLAYER_OFFSET)
#define DISPID_TIMEMEDIAPLAYERAUDIO_BASE                        (DISPID_BASE + TIMEMEDIAPLAYERAUDIO_OFFSET)
#define DISPID_TIMEPLAYLIST_BASE                                (DISPID_BASE + TIMEPLAYLIST_OFFSET)
#define DISPID_TIMEPLAYITEM_BASE                                (DISPID_BASE + TIMEPLAYITEM_OFFSET)
#define DISPID_TIMEDVDPLAYEROBJECT_BASE                         (DISPID_BASE + TIMEDVDPLAYEROBJECT_OFFSET)
#define DISPID_TIMEANIMATIONELEMENT_BASE                        (DISPID_BASE + TIMEANIMATIONELEMENT_OFFSET)
#define DISPID_SMILANIMATIONCOMPSITE_BASE                       (DISPID_BASE + SMILANIMATIONCOMPSITE_OFFSET)
#define DISPID_SMILANIMATIONFRAGMENT_BASE                       (DISPID_BASE + SMILANIMATIONFRAGMENT_OFFSET)
#define DISPID_TIMESTATE_BASE                                   (DISPID_BASE + TIMESTATE_OFFSET)
#define DISPID_TIMEDMPLAYEROBJECT_BASE                          (DISPID_BASE + TIMEDMPLAYEROBJECT_OFFSET)
#define DISPID_TIMEMEDIAPLAYERSITE_BASE                         (DISPID_BASE + TIMEMEDIAPLAYERSITE_OFFSET)
#define DISPID_TIMEMEDIAPLAYERCONTROL_BASE                      (DISPID_BASE + TIMEMEDIAPLAYERCONTROL_OFFSET)
#define DISPID_TIMEMEDIAELEMENT2_BASE                           (DISPID_BASE + TIMEMEDIAELEMENT2_OFFSET)
#define DISPID_TIMETRANSITIONELEMENT_BASE                       (DISPID_BASE + TIMETRANSITIONELEMENT_OFFSET)
#define DISPID_TIMEMEDIAPLAYERNETWORK_BASE                      (DISPID_BASE + TIMEMEDIAPLAYERNETWORK_OFFSET)

// Collection Reserve (for expando's and ordinal's)
#define DISPID_COLLECTION_RESERVED_MIN                          DISPID_TIMECOLLECTION_RESERVED_BASE
#define DISPID_COLLECTION_RESERVED_MAX                          0x0000007FF

// =============================================
// ITIMEElement DISPIDs:
// =============================================

// XML Attributes
#define DISPID_TIMEELEMENT_ACCELERATE                           (DISPID_TIMEELEMENT_BASE + 0x01)
#define DISPID_TIMEELEMENT_ACCELERATEFROM                       (DISPID_TIMEELEMENT_BASE + 0x02)
#define DISPID_TIMEELEMENT_AUTOREVERSE                          (DISPID_TIMEELEMENT_BASE + 0x03)
#define DISPID_TIMEELEMENT_BEGIN                                (DISPID_TIMEELEMENT_BASE + 0x04)
#define DISPID_TIMEELEMENT_DECELERATE                           (DISPID_TIMEELEMENT_BASE + 0x05)
#define DISPID_TIMEELEMENT_DECELERATETO                         (DISPID_TIMEELEMENT_BASE + 0x06)
#define DISPID_TIMEELEMENT_DUR                                  (DISPID_TIMEELEMENT_BASE + 0x07)
#define DISPID_TIMEELEMENT_END                                  (DISPID_TIMEELEMENT_BASE + 0x08)
#define DISPID_TIMEELEMENT_FILL                                 (DISPID_TIMEELEMENT_BASE + 0x0a)
#define DISPID_TIMEELEMENT_MUTE                                 (DISPID_TIMEELEMENT_BASE + 0x0b)
#define DISPID_TIMEELEMENT_REPEATCOUNT                          (DISPID_TIMEELEMENT_BASE + 0x0c)
#define DISPID_TIMEELEMENT_REPEATDUR                            (DISPID_TIMEELEMENT_BASE + 0x0d)
#define DISPID_TIMEELEMENT_RESTART                              (DISPID_TIMEELEMENT_BASE + 0x0e)
#define DISPID_TIMEELEMENT_SPEED                                (DISPID_TIMEELEMENT_BASE + 0x0f)
#define DISPID_TIMEELEMENT_SYNCBEHAVIOR                         (DISPID_TIMEELEMENT_BASE + 0x10)
#define DISPID_TIMEELEMENT_SYNCMASTER                           (DISPID_TIMEELEMENT_BASE + 0x11)
#define DISPID_TIMEELEMENT_SYNCTOLERANCE                        (DISPID_TIMEELEMENT_BASE + 0x12)
#define DISPID_TIMEELEMENT_TIMEACTION                           (DISPID_TIMEELEMENT_BASE + 0x13)
#define DISPID_TIMEELEMENT_TIMECONTAINER                        (DISPID_TIMEELEMENT_BASE + 0x14)
#define DISPID_TIMEELEMENT_UPDATEMODE                           (DISPID_TIMEELEMENT_BASE + 0x15)
#define DISPID_TIMEELEMENT_VOLUME                               (DISPID_TIMEELEMENT_BASE + 0x16)

// Properties
#define DISPID_TIMEELEMENT_CURRTIMESTATE                        (DISPID_TIMEELEMENT_BASE + 0x20)
#define DISPID_TIMEELEMENT_TIMEALL                              (DISPID_TIMEELEMENT_BASE + 0x21)
#define DISPID_TIMEELEMENT_TIMECHILDREN                         (DISPID_TIMEELEMENT_BASE + 0x22)
#define DISPID_TIMEELEMENT_TIMEPARENT                           (DISPID_TIMEELEMENT_BASE + 0x23)
#define DISPID_TIMEELEMENT_ISPAUSED                             (DISPID_TIMEELEMENT_BASE + 0x24)

// Methods
#define DISPID_TIMEELEMENT_BEGINELEMENT                         (DISPID_TIMEELEMENT_BASE + 0x30)
#define DISPID_TIMEELEMENT_BEGINELEMENTAT                       (DISPID_TIMEELEMENT_BASE + 0x31)
#define DISPID_TIMEELEMENT_ENDELEMENT                           (DISPID_TIMEELEMENT_BASE + 0x32)
#define DISPID_TIMEELEMENT_ENDELEMENTAT                         (DISPID_TIMEELEMENT_BASE + 0x33)
#define DISPID_TIMEELEMENT_PAUSEELEMENT                         (DISPID_TIMEELEMENT_BASE + 0x34)
#define DISPID_TIMEELEMENT_RESET                                (DISPID_TIMEELEMENT_BASE + 0x35)
#define DISPID_TIMEELEMENT_RESUMEELEMENT                        (DISPID_TIMEELEMENT_BASE + 0x36)
#define DISPID_TIMEELEMENT_SEEKACTIVETIME                       (DISPID_TIMEELEMENT_BASE + 0x37)
#define DISPID_TIMEELEMENT_SEEKSEGMENTTIME                      (DISPID_TIMEELEMENT_BASE + 0x38)
#define DISPID_TIMEELEMENT_SEEKTO                               (DISPID_TIMEELEMENT_BASE + 0x39)
#define DISPID_TIMEELEMENT_UPDATE                               (DISPID_TIMEELEMENT_BASE + 0x3a)
#define DISPID_TIMEELEMENT_DOCUMENTTIMETOPARENTTIME             (DISPID_TIMEELEMENT_BASE + 0x3b)
#define DISPID_TIMEELEMENT_PARENTTIMETODOCUMENTTIME             (DISPID_TIMEELEMENT_BASE + 0x3c)
#define DISPID_TIMEELEMENT_PARENTTIMETOACTIVETIME               (DISPID_TIMEELEMENT_BASE + 0x3d)
#define DISPID_TIMEELEMENT_ACTIVETIMETOPARENTTIME               (DISPID_TIMEELEMENT_BASE + 0x3e)
#define DISPID_TIMEELEMENT_ACTIVETIMETOSEGMENTTIME              (DISPID_TIMEELEMENT_BASE + 0x3f)
#define DISPID_TIMEELEMENT_SEGMENTTIMETOACTIVETIME              (DISPID_TIMEELEMENT_BASE + 0x40)
#define DISPID_TIMEELEMENT_SEGMENTTIMETOSIMPLETIME              (DISPID_TIMEELEMENT_BASE + 0x41)
#define DISPID_TIMEELEMENT_SIMPLETIMETOSEGMENTTIME              (DISPID_TIMEELEMENT_BASE + 0x42)

// Container attributes
#define DISPID_TIMEELEMENT_ENDSYNC                              (DISPID_TIMEELEMENT_BASE + 0x50)

// Container Properties
#define DISPID_TIMEELEMENT_ACTIVEELEMENTS                       (DISPID_TIMEELEMENT_BASE + 0x60)
#define DISPID_TIMEELEMENT_HASMEDIA                             (DISPID_TIMEELEMENT_BASE + 0x61)

// Container Methods
#define DISPID_TIMEELEMENT_NEXTELEMENT                          (DISPID_TIMEELEMENT_BASE + 0x70)
#define DISPID_TIMEELEMENT_PREVELEMENT                          (DISPID_TIMEELEMENT_BASE + 0x71)

//
// ITIMEBodyElement DISPIDs:
//

// empty interface


// =============================================
// ITIMEMediaElement DISPIDs:
// =============================================

// XML Attributes
#define DISPID_TIMEMEDIAELEMENT_CLIPBEGIN                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x01)
#define DISPID_TIMEMEDIAELEMENT_CLIPEND                         (DISPID_TIMEMEDIAELEMENT_BASE + 0x02)
#define DISPID_TIMEMEDIAELEMENT_PLAYER                          (DISPID_TIMEMEDIAELEMENT_BASE + 0x03)
#define DISPID_TIMEMEDIAELEMENT_SRC                             (DISPID_TIMEMEDIAELEMENT_BASE + 0x04)
#define DISPID_TIMEMEDIAELEMENT_TYPE                            (DISPID_TIMEMEDIAELEMENT_BASE + 0x05)

// Properties
#define DISPID_TIMEMEDIAELEMENT_ABSTRACT                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x10)
#define DISPID_TIMEMEDIAELEMENT_AUTHOR                          (DISPID_TIMEMEDIAELEMENT_BASE + 0x11)
#define DISPID_TIMEMEDIAELEMENT_COPYRIGHT                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x12)
#define DISPID_TIMEMEDIAELEMENT_HASAUDIO                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x13)
#define DISPID_TIMEMEDIAELEMENT_HASVISUAL                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x14)
#define DISPID_TIMEMEDIAELEMENT_MEDIACAPS                       (DISPID_TIMEMEDIAELEMENT_BASE + 0x15)
#define DISPID_TIMEMEDIAELEMENT_MEDIADUR                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x16)
#define DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT                     (DISPID_TIMEMEDIAELEMENT_BASE + 0x17)
#define DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH                      (DISPID_TIMEMEDIAELEMENT_BASE + 0x18)
#define DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT                    (DISPID_TIMEMEDIAELEMENT_BASE + 0x19)
#define DISPID_TIMEMEDIAELEMENT_PLAYLIST                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x1a)
#define DISPID_TIMEMEDIAELEMENT_RATING                          (DISPID_TIMEMEDIAELEMENT_BASE + 0x1b)
#define DISPID_TIMEMEDIAELEMENT_TITLE                           (DISPID_TIMEMEDIAELEMENT_BASE + 0x1c)
#define DISPID_TIMEMEDIAELEMENT_HASPLAYLIST                     (DISPID_TIMEMEDIAELEMENT_BASE + 0x1d)


// Media Caps
#define DISPID_TIMEMEDIAELEMENT_CANPAUSE                        (DISPID_TIMEMEDIAELEMENT_BASE + 0x30)
#define DISPID_TIMEMEDIAELEMENT_CANSEEK                         (DISPID_TIMEMEDIAELEMENT_BASE + 0x32)

// Methods

// =============================================
// ITIMEAnimationElement DISPIDs
// =============================================

#define DISPID_TIMEANIMATIONELEMENT_ATTRIBUTENAME               (DISPID_TIMEANIMATIONELEMENT_BASE + 0x01)
#define DISPID_TIMEANIMATIONELEMENT_BY                          (DISPID_TIMEANIMATIONELEMENT_BASE + 0x02)
#define DISPID_TIMEANIMATIONELEMENT_CALCMODE                    (DISPID_TIMEANIMATIONELEMENT_BASE + 0x03)
#define DISPID_TIMEANIMATIONELEMENT_FROM                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x04)
#define DISPID_TIMEANIMATIONELEMENT_KEYSPLINES                  (DISPID_TIMEANIMATIONELEMENT_BASE + 0x05)
#define DISPID_TIMEANIMATIONELEMENT_KEYTIMES                    (DISPID_TIMEANIMATIONELEMENT_BASE + 0x06)
#define DISPID_TIMEANIMATIONELEMENT_TARGETELEMENT               (DISPID_TIMEANIMATIONELEMENT_BASE + 0x07)
#define DISPID_TIMEANIMATIONELEMENT_TO                          (DISPID_TIMEANIMATIONELEMENT_BASE + 0x08)
#define DISPID_TIMEANIMATIONELEMENT_VALUES                      (DISPID_TIMEANIMATIONELEMENT_BASE + 0x09)

#define DISPID_TIMEANIMATIONELEMENT_ORIGIN                      (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0a)
#define DISPID_TIMEANIMATIONELEMENT_PATH                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0b)

#define DISPID_TIMEANIMATIONELEMENT_ADDITIVE                    (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0c)
#define DISPID_TIMEANIMATIONELEMENT_ACCUMULATE                  (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0d)

#define DISPID_TIMEANIMATIONELEMENT_TYPE                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0e)
#define DISPID_TIMEANIMATIONELEMENT_SUBTYPE                     (DISPID_TIMEANIMATIONELEMENT_BASE + 0x0f)
#define DISPID_TIMEANIMATIONELEMENT_MODE                        (DISPID_TIMEANIMATIONELEMENT_BASE + 0x10)
#define DISPID_TIMEANIMATIONELEMENT_FADECOLOR                   (DISPID_TIMEANIMATIONELEMENT_BASE + 0x11)

// IAnimationComposerSite DISPIDs
#define DISPID_SMILANIMATIONCOMPSITE_ADDFRAGMENT                (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x01)
#define DISPID_SMILANIMATIONCOMPSITE_REMOVEFRAGMENT             (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x02)
#define DISPID_SMILANIMATIONCOMPSITE_INSERTFRAGMENT             (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x03)
#define DISPID_SMILANIMATIONCOMPSITE_ENUMERATEFRAGMENTS         (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x04)
#define DISPID_SMILANIMATIONCOMPSITE_REGISTERFACTORY            (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x05)
#define DISPID_SMILANIMATIONCOMPSITE_UNREGISTER_FACTORY         (DISPID_SMILANIMATIONCOMPSITE_BASE + 0x06)

// IAnimationFragment
#define DISPID_SMILANIMATIONFRAGMENT_ELEMENT                    (DISPID_SMILANIMATIONFRAGMENT_BASE + 0x01)
#define DISPID_SMILANIMATIONFRAGMENT_VALUE                      (DISPID_SMILANIMATIONFRAGMENT_BASE + 0x02)
#define DISPID_SMILANIMATIONFRAGMENT_DETACHFROMCOMPOSER         (DISPID_SMILANIMATIONFRAGMENT_BASE + 0x03)

// ITIMEEventElement DISPIDs:
#define DISPID_TIMEEVENTELEMENT_TYPE                            (DISPID_TIMEEVENTELEMENT_BASE + 0x01)
#define DISPID_TIMEEVENTELEMENT_ACTIVE                          (DISPID_TIMEEVENTELEMENT_BASE + 0x02)

// ITIMEFactory DISPIDs:
#define DISPID_TIMEFACTORY_CREATETIMEELEMENT                    (DISPID_TIMEFACTORY_BASE + 0x01)
#define DISPID_TIMEFACTORY_CREATETIMEELEMENTBODY                (DISPID_TIMEFACTORY_BASE + 0x02)
#define DISPID_TIMEFACTORY_CREATETIMEDAELEMENT                  (DISPID_TIMEFACTORY_BASE + 0x03)
#define DISPID_TIMEFACTORY_CREATETIMEMEDIAELEMENT               (DISPID_TIMEFACTORY_BASE + 0x04)

//
// ITIMEElementCollection
//
#define DISPID_TIMEELEMENTCOLLECTION_LENGTH                     (DISPID_TIMECOLLECTION_BASE + 0x01)
#define DISPID_TIMEELEMENTCOLLECTION__NEWENUM                   (DISPID_NEWENUM)
#define DISPID_TIMEELEMENTCOLLECTION_ITEM                       (DISPID_VALUE)
#define DISPID_TIMEELEMENTCOLLECTION_TAGS                       (DISPID_TIMECOLLECTION_BASE + 0x02)

//
// ITIMEMediaPlayerSite
//

#define DISPID_TIMEMEDIAPLAYERSITE_TIMEELEMENT                  (DISPID_TIMEMEDIAPLAYERSITE_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYERSITE_TIMESTATE                    (DISPID_TIMEMEDIAPLAYERSITE_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR                  (DISPID_TIMEMEDIAPLAYERSITE_BASE + 0x03)

//
// ITIMEMediaPlayer
//

#define DISPID_TIMEMEDIAPLAYER_INIT                             (DISPID_TIMEMEDIAPLAYER_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYER_DETACH                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x02)

#define DISPID_TIMEMEDIAPLAYER_BEGIN                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x10)
#define DISPID_TIMEMEDIAPLAYER_END                              (DISPID_TIMEMEDIAPLAYER_BASE + 0x11)
#define DISPID_TIMEMEDIAPLAYER_RESUME                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x12)
#define DISPID_TIMEMEDIAPLAYER_PAUSE                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x13)
#define DISPID_TIMEMEDIAPLAYER_REPEAT                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x14)
#define DISPID_TIMEMEDIAPLAYER_RESET                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x15)
#define DISPID_TIMEMEDIAPLAYER_SEEK                             (DISPID_TIMEMEDIAPLAYER_BASE + 0x16)

// Properties - w
#define DISPID_TIMEMEDIAPLAYER_SRC                              (DISPID_TIMEMEDIAPLAYER_BASE + 0x20)
#define DISPID_TIMEMEDIAPLAYER_CLIPBEGIN                        (DISPID_TIMEMEDIAPLAYER_BASE + 0x21)
#define DISPID_TIMEMEDIAPLAYER_CLIPEND                          (DISPID_TIMEMEDIAPLAYER_BASE + 0x22)

// Properties - r/o
#define DISPID_TIMEMEDIAPLAYER_ABSTRACT                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x30)
#define DISPID_TIMEMEDIAPLAYER_AUTHOR                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x31)
#define DISPID_TIMEMEDIAPLAYER_CANPAUSE                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x32)
#define DISPID_TIMEMEDIAPLAYER_CANSEEK                          (DISPID_TIMEMEDIAPLAYER_BASE + 0x34)
#define DISPID_TIMEMEDIAPLAYER_CLIPDUR                          (DISPID_TIMEMEDIAPLAYER_BASE + 0x35)
#define DISPID_TIMEMEDIAPLAYER_COPYRIGHT                        (DISPID_TIMEMEDIAPLAYER_BASE + 0x36)
#define DISPID_TIMEMEDIAPLAYER_CURRTIME                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x37)
#define DISPID_TIMEMEDIAPLAYER_CUSTOM_OBJECT                    (DISPID_TIMEMEDIAPLAYER_BASE + 0x38)
#define DISPID_TIMEMEDIAPLAYER_HASAUDIO                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x39)
#define DISPID_TIMEMEDIAPLAYER_HASVISUAL                        (DISPID_TIMEMEDIAPLAYER_BASE + 0x3A)
#define DISPID_TIMEMEDIAPLAYER_MEDIADUR                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x3B)
#define DISPID_TIMEMEDIAPLAYER_MEDIAHEIGHT                      (DISPID_TIMEMEDIAPLAYER_BASE + 0x3C)
#define DISPID_TIMEMEDIAPLAYER_MEDIAWIDTH                       (DISPID_TIMEMEDIAPLAYER_BASE + 0x3D)
#define DISPID_TIMEMEDIAPLAYER_PLAYLIST                         (DISPID_TIMEMEDIAPLAYER_BASE + 0x3E)
#define DISPID_TIMEMEDIAPLAYER_RATING                           (DISPID_TIMEMEDIAPLAYER_BASE + 0x3F)
#define DISPID_TIMEMEDIAPLAYER_STATE                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x40)
#define DISPID_TIMEMEDIAPLAYER_TITLE                            (DISPID_TIMEMEDIAPLAYER_BASE + 0x41)

//
// ITIMEMediaPlayerAudio
//
#define DISPID_TIMEMEDIAPLAYERAUDIO_VOLUME                      (DISPID_TIMEMEDIAPLAYERAUDIO_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYERAUDIO_MUTE                        (DISPID_TIMEMEDIAPLAYERAUDIO_BASE + 0x02)

//
// ITIMEMediaPlayerNetwork
//
#define DISPID_TIMEMEDIAPLAYERNETWORK_HASDOWNLOADPROGRESS       (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYERNETWORK_DOWNLOADPROGRESS          (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYERNETWORK_ISBUFFERED                (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x03)
#define DISPID_TIMEMEDIAPLAYERNETWORK_BUFFERINGPROGRESS         (DISPID_TIMEMEDIAPLAYERNETWORK_BASE + 0x04)

//
// ITIMEMediaPlayerControl
//

#define DISPID_TIMEMEDIAPLAYERCONTROL_GETCONTROL                (DISPID_TIMEMEDIAPLAYERCONTROL_BASE + 0x01)

// ITIMEActiveElementsCollection
#define DISPID_ACTIVEELMENTS_LENGTH                             (0x000005dc) //special dispid specific to collections
#define DISPID_ACTIVEELMENTS_NEWENUM                            (DISPID_NEWENUM)
#define DISPID_ACTIVEELMENTS_ITEM                               (0x00000000) //designates this as the default value for this collection.


// ITIMEPlayList collectoion
#define DISPID_TIMEPLAYLIST_ACTIVETRACK                         (DISPID_TIMEPLAYLIST_BASE + 0x01)
#define DISPID_TIMEPLAYLIST_DUR                                 (DISPID_TIMEPLAYLIST_BASE + 0x02)
#define DISPID_TIMEPLAYLIST_ITEM                                (0x00000000) //designates this as the default value for this collection.
#define DISPID_TIMEPLAYLIST_LENGTH                              (0x000005dc) //special dispid specific to collections
#define DISPID_TIMEPLAYLIST_NEWENUM                             (DISPID_NEWENUM)
#define DISPID_TIMEPLAYLIST_NEXTTRACK                           (DISPID_TIMEPLAYLIST_BASE + 0x03)
#define DISPID_TIMEPLAYLIST_PREVTRACK                           (DISPID_TIMEPLAYLIST_BASE + 0x04)

//ITIMEPlayItem interface
#define DISPID_TIMEPLAYITEM_ABSTRACT                            (DISPID_TIMEPLAYITEM_BASE + 0x01)
#define DISPID_TIMEPLAYITEM_AUTHOR                              (DISPID_TIMEPLAYITEM_BASE + 0x02)
#define DISPID_TIMEPLAYITEM_COPYRIGHT                           (DISPID_TIMEPLAYITEM_BASE + 0x03)
#define DISPID_TIMEPLAYITEM_DUR                                 (DISPID_TIMEPLAYITEM_BASE + 0x04)
#define DISPID_TIMEPLAYITEM_INDEX                               (DISPID_TIMEPLAYITEM_BASE + 0x05)
#define DISPID_TIMEPLAYITEM_RATING                              (DISPID_TIMEPLAYITEM_BASE + 0x06)
#define DISPID_TIMEPLAYITEM_SRC                                 (DISPID_TIMEPLAYITEM_BASE + 0x07)
#define DISPID_TIMEPLAYITEM_TITLE                               (DISPID_TIMEPLAYITEM_BASE + 0x08)
        
//Methods
#define DISPID_TIMEPLAYITEM_SETACTIVE                           (DISPID_TIMEPLAYITEM_BASE + 0x0a)

//ITIMEPlayItem2 interface continues ITIMEPlayItem interface
#define DISPID_TIMEPLAYITEM_BANNER                              (DISPID_TIMEPLAYITEM_BASE + 0x10)
#define DISPID_TIMEPLAYITEM_BANNERABSTRACT                      (DISPID_TIMEPLAYITEM_BASE + 0x11)
#define DISPID_TIMEPLAYITEM_BANNERMOREINFO                      (DISPID_TIMEPLAYITEM_BASE + 0x12)

#define DISPID_ITIMEDVDPLAYEROBJECT_UPPERBUTTONSEL              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x01)
#define DISPID_ITIMEDVDPLAYEROBJECT_LOWERBUTTONSEL              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x02)
#define DISPID_ITIMEDVDPLAYEROBJECT_LEFTBUTTONSEL               (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x03)
#define DISPID_ITIMEDVDPLAYEROBJECT_RIGHTBUTTONSEL              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x04)
#define DISPID_ITIMEDVDPLAYEROBJECT_BUTTONACTIVATE              (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x05)
#define DISPID_ITIMEDVDPLAYEROBJECT_GOTOMENU                    (DISPID_TIMEDVDPLAYEROBJECT_BASE +0x06)

// =============================================
// ITIMEState
// =============================================

#define DISPID_TIMESTATE_ACTIVEDUR                              (DISPID_TIMESTATE_BASE + 0x01)
#define DISPID_TIMESTATE_ACTIVETIME                             (DISPID_TIMESTATE_BASE + 0x02)
#define DISPID_TIMESTATE_ISACTIVE                               (DISPID_TIMESTATE_BASE + 0x03)
#define DISPID_TIMESTATE_ISON                                   (DISPID_TIMESTATE_BASE + 0x04)
#define DISPID_TIMESTATE_ISPAUSED                               (DISPID_TIMESTATE_BASE + 0x05)
#define DISPID_TIMESTATE_ISMUTED                                (DISPID_TIMESTATE_BASE + 0x06)
#define DISPID_TIMESTATE_PARENTTIMEBEGIN                        (DISPID_TIMESTATE_BASE + 0x07)
#define DISPID_TIMESTATE_PARENTTIMEEND                          (DISPID_TIMESTATE_BASE + 0x08)
#define DISPID_TIMESTATE_PROGRESS                               (DISPID_TIMESTATE_BASE + 0x09)
#define DISPID_TIMESTATE_REPEATCOUNT                            (DISPID_TIMESTATE_BASE + 0x0a)
#define DISPID_TIMESTATE_SEGMENTDUR                             (DISPID_TIMESTATE_BASE + 0x0b)
#define DISPID_TIMESTATE_SEGMENTTIME                            (DISPID_TIMESTATE_BASE + 0x0c)
#define DISPID_TIMESTATE_SIMPLEDUR                              (DISPID_TIMESTATE_BASE + 0x0d)
#define DISPID_TIMESTATE_SIMPLETIME                             (DISPID_TIMESTATE_BASE + 0x0e)
#define DISPID_TIMESTATE_SPEED                                  (DISPID_TIMESTATE_BASE + 0x0f)
#define DISPID_TIMESTATE_STATE                                  (DISPID_TIMESTATE_BASE + 0x10)
#define DISPID_TIMESTATE_STATESTRING                            (DISPID_TIMESTATE_BASE + 0x11)
#define DISPID_TIMESTATE_VOLUME                                 (DISPID_TIMESTATE_BASE + 0x12)

#define DISPID_ITIMEDMPLAYEROBJECT_HASDM                        (DISPID_TIMEDMPLAYEROBJECT_BASE +0x01)

// =============================================
// Transitions related stuff
// =============================================

#define DISPID_TIMEMEDIAELEMENT2_EARLIESTTIME                   (DISPID_TIMEMEDIAELEMENT2_BASE + 0x03)
#define DISPID_TIMEMEDIAELEMENT2_LATESTTTIME                    (DISPID_TIMEMEDIAELEMENT2_BASE + 0x04)
#define DISPID_TIMEMEDIAELEMENT2_MINBUFF                        (DISPID_TIMEMEDIAELEMENT2_BASE + 0x05)
#define DISPID_TIMEMEDIAELEMENT2_DLTOTAL                        (DISPID_TIMEMEDIAELEMENT2_BASE + 0x06)
#define DISPID_TIMEMEDIAELEMENT2_DLCURRENT                      (DISPID_TIMEMEDIAELEMENT2_BASE + 0x07)
#define DISPID_TIMEMEDIAELEMENT2_ISSTREAMED                     (DISPID_TIMEMEDIAELEMENT2_BASE + 0x08)
#define DISPID_TIMEMEDIAELEMENT2_BUFPROG                        (DISPID_TIMEMEDIAELEMENT2_BASE + 0x09)
#define DISPID_TIMEMEDIAELEMENT2_HASDLPROGRESS                  (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0a)
#define DISPID_TIMEMEDIAELEMENT2_MIMETYPE                       (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0b)
#define DISPID_TIMEMEDIAELEMENT2_SEEKTOFRAME                    (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0c)
#define DISPID_TIMEMEDIAELEMENT2_DECODEMIMETYPE                 (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0d)
#define DISPID_TIMEMEDIAELEMENT_CURRFRAME                       (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0e)
#define DISPID_TIMEMEDIAELEMENT2_DLPROG                         (DISPID_TIMEMEDIAELEMENT2_BASE + 0x0f)

#define DISPID_TIMETRANSITIONELEMENT_TYPE                       (DISPID_TIMETRANSITIONELEMENT_BASE + 0x01)
#define DISPID_TIMETRANSITIONELEMENT_SUBTYPE                    (DISPID_TIMETRANSITIONELEMENT_BASE + 0x02)
#define DISPID_TIMETRANSITIONELEMENT_DUR                        (DISPID_TIMETRANSITIONELEMENT_BASE + 0x03)
#define DISPID_TIMETRANSITIONELEMENT_STARTPROGRESS              (DISPID_TIMETRANSITIONELEMENT_BASE + 0x04)
#define DISPID_TIMETRANSITIONELEMENT_ENDPROGRESS                (DISPID_TIMETRANSITIONELEMENT_BASE + 0x05)
#define DISPID_TIMETRANSITIONELEMENT_DIRECTION                  (DISPID_TIMETRANSITIONELEMENT_BASE + 0x06)
#define DISPID_TIMETRANSITIONELEMENT_REPEATCOUNT                (DISPID_TIMETRANSITIONELEMENT_BASE + 0x07)
#define DISPID_TIMETRANSITIONELEMENT_BEGIN                      (DISPID_TIMETRANSITIONELEMENT_BASE + 0x08)
#define DISPID_TIMETRANSITIONELEMENT_END                        (DISPID_TIMETRANSITIONELEMENT_BASE + 0x09)

#endif  //__TIMEDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\msoav.h ===
#pragma once

#ifndef _MSOAV_H
#define _MSOAV_H

typedef struct _msoavinfo
{
int cbsize;			//size of this struct
struct {
	ULONG fPath:1;			//when true use pwzFullPath else use lpstg
	ULONG fReadOnlyRequest:1;	//user requests file to be opened read/only
	ULONG fInstalled:1;	//the file at pwzFullPath is an installed file
	ULONG fHttpDownload:1;	//the file at pwzFullPath is a temp file downloaded from http/ftp
	};
HWND hwnd;			//parent window of the Office9 app
union {
	WCHAR *pwzFullPath;	//full path to the file about to be opened
	LPSTORAGE lpstg;	//OLE Storage of the doc about to be opened
	}u;
WCHAR *pwzHostName;	 // Host Office 9 apps name
WCHAR *pwzOrigURL;	 		// URL of the origin of this downloaded file.
}MSOAVINFO;

 // {56FFCC30-D398-11d0-B2AE-00A0C908FA49}
DEFINE_GUID(IID_IOfficeAntiVirus,
0x56ffcc30, 0xd398, 0x11d0, 0xb2, 0xae, 0x0, 0xa0, 0xc9, 0x8, 0xfa, 0x49);

 // {56FFCC31-D398-11d0-B2AE-00A0C908FA49}
DEFINE_GUID(CATID_MSOfficeAntiVirus,
0x56ffcc30, 0xd398, 0x11d0, 0xb2, 0xae, 0x0, 0xa0, 0xc9, 0x8, 0xfa, 0x49);



#undef  INTERFACE
#define INTERFACE  IOfficeAntiVirus
DECLARE_INTERFACE_(IOfficeAntiVirus, IUnknown)
{
    BEGIN_INTERFACE

    // *** IUnknown methods ***

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    STDMETHOD_(ULONG, AddRef)(THIS) PURE;

    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IOfficeAntiVirus methods ***

	STDMETHOD_(HRESULT, Scan)(THIS_ MSOAVINFO *pmsoavinfo ) PURE;
};

#ifndef AVVENDOR
MSOAPI_(BOOL) MsoFAnyAntiVirus(HMSOINST hmsoinst);
MSOAPI_(BOOL) MsoFDoAntiVirusScan(HMSOINST hmsoinst, MSOAVINFO *msoavinfo);
MSOAPI_(void) MsoFreeMsoavStuff(HMSOINST hmsoinst);
MSOAPI_(BOOL) MsoFDoSecurityLevelDlg(HMSOINST hmsoinst,DWORD msorid, int *pSecurityLevel, 
	BOOL *pfTrustInstalled, HWND hwndParent, BOOL fShowVirusCheckers,
	WCHAR *wzHelpFile, DWORD dwHelpId);

//output of the Enable/disable macro (edm) dialog
#define msoedmEnable	1
#define	msoedmDisable	2
#define	msoedmDontOpen	3

MSOAPI_(int) MsoMsoedmDialog(HMSOINST hmsoinst, BOOL fAppIsActive, BOOL fHasVBMacros, 
	BOOL fHasXLMMacros, void *pvDigSigStore, void *pvMacro, int nAppID, HWND hwnd, 
	const WCHAR *pwtzPath, int iClient, int iSecurityLevel, int *pmsodsv, 
	WCHAR *wzHelpFile, DWORD dwHelpId, HANDLE hFileDLL, BOOL fUserControl);


//Security level
#define	msoslUndefined	0
#define msoslNone   1
#define	msoslMedium	2
#define msoslHigh	3

MSOAPI_(int) MsoMsoslGetSL(HMSOINST hmsoinst);
MSOAPI_(int) MsoMsoslSetSL(DWORD msorid, HMSOINST hmsoinst);

//output of the digital signature verification (dsv)
#define	msodsvNoMacros	0
#define msodsvUnsigned	1
// msodsvPassedTrusted is very unfortunately named because it has nothing to do with
// trust - it just means that the doc is signed and the signature matched. Too late 
// to change the name now so I'm adding a msodsvPassedTrustedCert to mean the doc was
// signed and cert was trusted.
#define	msodsvPassedTrusted	2
#define	msodsvFailed		3
#define	msodsvLowSecurityLevel 4
#define msodsvPassedTrustedCert 5

#endif //!AVVENDOR


#endif // _MSOAV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\perftags.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       perftags.h
//
//  Contents:   External include file for perftags.dll
//
//-------------------------------------------------------------------------

#ifdef PERFTAGS

typedef int  PERFTAG;
int          PerfRegister(char * szTag, char * szOwner, char * szDescrip);
void __cdecl PerfLogFn(int tag, void * pvObj, const char * pchFmt, ...);
void         PerfDump();
void         PerfClear();
void         PerfTags();
#define      IsPerfEnabled(tag) (*(BOOL *)tag)
#define      PerfTag(tag, szOwner, szDescrip) PERFTAG tag(PerfRegister(#tag, szOwner, szDescrip));
#define      PerfExtern(tag) extern PERFTAG tag;
#define      PerfLog(tag,pv,f) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f) : 0
#define      PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1) : 0
#define      PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2) : 0
#define      PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define      PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define      PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define      PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define      PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define      PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define      PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? PerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0

#else

#define      PerfTags()
#define      PerfTag(tag, szOwner, szDescrip)
#define      PerfExtern(tag)
#define      PerfDump()
#define      PerfClear()
#define      IsPerfEnabled(tag) FALSE
#define      PerfLog(tag,pv,f)
#define      PerfLog1(tag,pv,f,a1)
#define      PerfLog2(tag,pv,f,a1,a2)
#define      PerfLog3(tag,pv,f,a1,a2,a3)
#define      PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define      PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define      PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define      PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define      PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define      PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\pkgguid.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    pkgguid.h

--*/

#ifndef __PKGGUID_H__
#define __PKGGUID_H__

// {D2073C40-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICodeStoreDBEntry,
0xD2073C40, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {DF3D9C22-AB4E-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICodeStoreDB,
0xDF3D9C22, 0xAB4E, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {DF3D9C23-AB4E-11d0-A732-00A0C9082637}
DEFINE_GUID(CLSID_CodeStoreDB,
0xDF3D9C23, 0xAB4E, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C42-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumCodeStoreDBEntry,
0xD2073C42, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C43-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaPackageManager,
0xD2073C43, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C46-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaPackage,
0xD2073C46, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C48-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IJavaFile,
0xD2073C48, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C47-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_ICreateJavaPackageMgr,
0xD2073C47, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C44-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(CLSID_JavaPackageManager,
0xD2073C44, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C45-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumJavaPackage,
0xD2073C45, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

// {D2073C49-AB4F-11d0-A732-00A0C9082637}
DEFINE_GUID(IID_IEnumJavaFile,
0xD2073C49, 0xAB4F, 0x11d0, 0xA7, 0x32, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x37);

#endif // __PKGGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\newimp.h ===
#ifndef _INC_NEWIMP_H
#define _INC_NEWIMP_H


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// WARNING:  If you make changes to this header, you must also update  //
//           inetcore\published\inc\newimp.h !!!                       //
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#ifndef NO_IMPORT_ERROR

#define HR_IMP_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_IMP_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)
#define HR_IMP      0x3000

#define hrFolderOpenFail    HR_IMP_E(HR_IMP + 1)
#define hrFolderReadFail    HR_IMP_E(HR_IMP + 2)
#define hrMapiInitFail      HR_IMP_E(HR_IMP + 3)
#define hrNoProfilesFound   HR_IMP_E(HR_IMP + 4)
#define hrDiskFull          HR_IMP_E(HR_IMP + 5)
#define hrUserCancel        HR_IMP_E(HR_IMP + 6)

#endif // NO_IMPORT_ERROR

typedef enum tagIMPORTFOLDERTYPE
    {
    FOLDER_TYPE_NORMAL = 0,
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT,
    FOLDER_TYPE_DELETED,
    FOLDER_TYPE_DRAFT,
    CFOLDERTYPE
    } IMPORTFOLDERTYPE;

typedef struct IMSG IMSG;

typedef enum
    {
    MSG_TYPE_MAIL = 0,
    MSG_TYPE_NEWS
    } MSGTYPE;

#define MSG_STATE_UNREAD    0x0001
#define MSG_STATE_UNSENT    0x0002
#define MSG_STATE_SUBMITTED 0x0004
#define MSG_PRI_LOW         0x0010
#define MSG_PRI_NORMAL      0x0020
#define MSG_PRI_HIGH        0x0040
#define MSG_PRI_MASK        0x0070

// {E4499DE7-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IFolderImport, 0xE4499DE7L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IFolderImport IFolderImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IFolderImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMessageCount(ULONG cMsg) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(IMSG *pimsg) = 0;
    };
#else   /* C style interface */
typedef struct IFolderImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IFolderImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IFolderImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IFolderImport * This);

    HRESULT ( STDMETHODCALLTYPE *SetMessageCount )(
		IFolderImport * This,
		ULONG cMsg);
    HRESULT ( STDMETHODCALLTYPE *ImportMessageEx )(
		IFolderImport * This,
		MSGTYPE type, 
		DWORD dwState, 
		LPSTREAM pstm, 
		const TCHAR **rgszAttach, 
		DWORD cAttach);
    HRESULT ( STDMETHODCALLTYPE *ImportMessage )(
		IFolderImport * This,
		IMSG *pimsg);
    END_INTERFACE
} IFolderImportVtbl;

interface IFolderImport
{
    CONST_VTBL struct IFolderImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IFolderImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IFolderImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IFolderImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IFolderImport_SetMessageCount(This,cMsg)	\
	(This)->lpVtbl -> SetMessageCount(This,cMsg)
#define IFolderImport_ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)	\
	(This)->lpVtbl -> ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)
#define IFolderImport_ImportMessage(This,pimsg)	\
	(This)->lpVtbl -> ImportMessage(This,pimsg)
#endif /* COBJMACROS */

#endif  /* C style interface */



// {E4499DE8-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImporter, 0xE4499DE8L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IMailImporter IMailImporter;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImporter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie) = 0;
    };
#else   /* C style interface */
typedef struct IMailImporterVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImporter * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImporter * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImporter * This);

    HRESULT ( STDMETHODCALLTYPE *OpenFolder )(
		IMailImporter * This,
		DWORD_PTR dwCookie, 
		const TCHAR *szFolder, 
		IMPORTFOLDERTYPE type, 
		DWORD dwFlags, 
		IFolderImport **ppFldrImp, 
		DWORD_PTR *pdwCookie);
    END_INTERFACE
} IMailImporterVtbl;

interface IMailImporter
{
    CONST_VTBL struct IMailImporterVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImporter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImporter_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImporter_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImporter_OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)	\
   (This)->lpVtbl -> OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)

#endif /* COBJMACROS */

#endif  /* C style interface */

typedef struct tagIMPORTFOLDER
    {
    DWORD_PTR           dwCookie;
    TCHAR               szName[MAX_PATH];
    IMPORTFOLDERTYPE    type;
    // DWORD       cMsg;
    BOOL                fSubFolders;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    } IMPORTFOLDER;

// {E4499DE9-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IEnumFOLDERS, 0xE4499DE9L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IEnumFOLDERS IEnumFOLDERS;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IEnumFOLDERS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPORTFOLDER *pfldr) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };
#else   /* C style interface */
typedef struct IEnumFOLDERSVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IEnumFOLDERS * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IEnumFOLDERS * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IEnumFOLDERS * This);

    HRESULT ( STDMETHODCALLTYPE *Next )(
		IEnumFOLDERS * This,
        IMPORTFOLDER *pfldr);
    HRESULT ( STDMETHODCALLTYPE *Reset )(
		IEnumFOLDERS * This);
    END_INTERFACE
} IEnumFOLDERSVtbl;

interface IEnumFOLDERS
{
    CONST_VTBL struct IEnumFOLDERSVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IEnumFOLDERS_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IEnumFOLDERS_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IEnumFOLDERS_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IEnumFOLDERS_Next(This,pfldr)	\
   (This)->lpVtbl -> Next(This,pfldr);
#define IEnumFOLDERS_Reset(This)	\
   (This)->lpVtbl -> Reset(This);
#endif /* COBJMACROS */

#endif  /* C style interface */


#define COOKIE_ROOT     MAXULONG_PTR

// {E4499DEA-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImport, 0xE4499DEAL, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IMailImport IMailImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetDirectory(char *szDir, UINT cch) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDirectory(char *szDir) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport) = 0;
    };
#else   /* C style interface */
typedef struct IMailImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImport * This);

    HRESULT ( STDMETHODCALLTYPE *InitializeImport )(
		IMailImport * This,
        HWND hwnd);
    HRESULT ( STDMETHODCALLTYPE *GetDirectory )(
		IMailImport * This,
        char *szDir, 
        UINT cch);
    HRESULT ( STDMETHODCALLTYPE *SetDirectory )(
		IMailImport * This,
        char *szDir);
    HRESULT ( STDMETHODCALLTYPE *EnumerateFolders )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IEnumFOLDERS **ppEnum);
    HRESULT ( STDMETHODCALLTYPE *ImportFolder )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IFolderImport *pImport);

    END_INTERFACE
} IMailImportVtbl;

interface IMailImport
{
    CONST_VTBL struct IMailImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImport_InitializeImport(This,hwnd) \
    (This)->lpVtbl -> InitializeImport(This,hwnd)
#define IMailImport_GetDirectory(This,szDir,cch)    \
    (This)->lpVtbl -> GetDirectory(This,szDir,cch)
#define IMailImport_SetDirectory(This,szDir)    \
    (This)->lpVtbl -> SetDirectory(This,szDir)
#define IMailImport_EnumerateFolders(This,dwCookie,ppEnum)  \
    (This)->lpVtbl -> EnumerateFolders(This,dwCookie,ppEnum)
#define IMailImport_ImportFolder(This,dwCookie,pImport) \
    (This)->lpVtbl -> ImportFolder(This,dwCookie,pImport)

#endif /* COBJMACROS */

#endif  /* C style interface */

#define achPerformImport    "PerformImport"
void PerformImport(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef void (*PFNPERFORMIMPORT)(HWND, IMailImporter *, DWORD);

#define achPerformMigration "PerformMigration"
HRESULT PerformMigration(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef HRESULT (*PFNPERFORMMIGRATION)(HWND, IMailImporter *, DWORD);

#endif // _INC_NEWIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\pkgmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Jul 11 15:30:21 1997
 */
/* Compiler settings for pkgmgr.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __pkgmgr_h__
#define __pkgmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumCodeStoreDBEntry_FWD_DEFINED__
#define __IEnumCodeStoreDBEntry_FWD_DEFINED__
typedef interface IEnumCodeStoreDBEntry IEnumCodeStoreDBEntry;
#endif 	/* __IEnumCodeStoreDBEntry_FWD_DEFINED__ */


#ifndef __ICodeStoreDBEntry_FWD_DEFINED__
#define __ICodeStoreDBEntry_FWD_DEFINED__
typedef interface ICodeStoreDBEntry ICodeStoreDBEntry;
#endif 	/* __ICodeStoreDBEntry_FWD_DEFINED__ */


#ifndef __ICodeStoreDB_FWD_DEFINED__
#define __ICodeStoreDB_FWD_DEFINED__
typedef interface ICodeStoreDB ICodeStoreDB;
#endif 	/* __ICodeStoreDB_FWD_DEFINED__ */


#ifndef __IJavaPackageManager_FWD_DEFINED__
#define __IJavaPackageManager_FWD_DEFINED__
typedef interface IJavaPackageManager IJavaPackageManager;
#endif 	/* __IJavaPackageManager_FWD_DEFINED__ */


#ifndef __IJavaPackage_FWD_DEFINED__
#define __IJavaPackage_FWD_DEFINED__
typedef interface IJavaPackage IJavaPackage;
#endif 	/* __IJavaPackage_FWD_DEFINED__ */


#ifndef __ICreateJavaPackageMgr_FWD_DEFINED__
#define __ICreateJavaPackageMgr_FWD_DEFINED__
typedef interface ICreateJavaPackageMgr ICreateJavaPackageMgr;
#endif 	/* __ICreateJavaPackageMgr_FWD_DEFINED__ */


#ifndef __IJavaFile_FWD_DEFINED__
#define __IJavaFile_FWD_DEFINED__
typedef interface IJavaFile IJavaFile;
#endif 	/* __IJavaFile_FWD_DEFINED__ */


#ifndef __IEnumJavaPackage_FWD_DEFINED__
#define __IEnumJavaPackage_FWD_DEFINED__
typedef interface IEnumJavaPackage IEnumJavaPackage;
#endif 	/* __IEnumJavaPackage_FWD_DEFINED__ */


#ifndef __IEnumJavaFile_FWD_DEFINED__
#define __IEnumJavaFile_FWD_DEFINED__
typedef interface IEnumJavaFile IEnumJavaFile;
#endif 	/* __IEnumJavaFile_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 







typedef const BYTE __RPC_FAR *LPCBYTE;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0001
    {	JPMPII_SYSTEMCLASS	= 0,
	JPMPII_NONSYSTEMCLASS	= 1,
	JPMPII_NEEDSTRUSTEDSOURCE	= 2,
	ALL_JPMPII_FLAGS	= JPMPII_SYSTEMCLASS | JPMPII_NONSYSTEMCLASS | JPMPII_NEEDSTRUSTEDSOURCE
    }	JPMPII_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0002
    {	JPMINST_NOVERSIONCHECK	= 1,
	JPMINST_NOSIGNERCHECK	= 2,
	JPMINST_AUTODETECTPACKAGES	= 4,
	JPMINST_DELETEINPUTFILE	= 8,
	ALL_JPMINST_FLAGS	= JPMINST_NOVERSIONCHECK | JPMINST_NOSIGNERCHECK | JPMINST_AUTODETECTPACKAGES | JPMINST_DELETEINPUTFILE
    }	JPMINST_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0000_0003
    {	JPMINST_CAB	= 0,
	JPMINST_ZIP	= 1,
	JPMINST_JAR	= 2
    }	JPMINST_FILETYPES;

typedef struct  tagPACKAGEINSTALLINFO
    {
    DWORD cbStruct;
    LPCOLESTR pszPackageName;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwFlags;
    LPCOLESTR pszCodebaseURL;
    LPCOLESTR pszDistributionUnit;
    LPUNKNOWN pUnknown;
    HRESULT result;
    }	PACKAGEINSTALLINFO;

typedef /* [unique] */ PACKAGEINSTALLINFO __RPC_FAR *LPPACKAGEINSTALLINFO;

typedef /* [unique] */ const PACKAGEINSTALLINFO __RPC_FAR *LPCPACKAGEINSTALLINFO;

typedef struct  tagPACKAGESECURITYINFO
    {
    DWORD cbStruct;
    LPCBYTE pCapabilities;
    DWORD cbCapabilities;
    LPCBYTE pSigner;
    DWORD cbSigner;
    BOOL fAllPermissions;
    }	PACKAGESECURITYINFO;

typedef /* [unique] */ const PACKAGESECURITYINFO __RPC_FAR *LPCPACKAGESECURITYINFO;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;


#ifndef __JPKGMGR_LIBRARY_DEFINED__
#define __JPKGMGR_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: JPKGMGR
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public] */ 
enum __MIDL___MIDL__intf_0071_0001
    {	CRF_REMOVECHILDREN	= 1,
	CRF_REMOVEVALUESONLY	= 2,
	CRF_REMOVEEMPTYPARENTSALSO	= 4
    }	CSDB_REMOVE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0071_0002
    {	CGF_FULLYQUALIFIED	= 1
    }	CSDB_GETNAME_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0073_0001
    {	JPMFI_NEEDS_TRUSTED_SOURCE	= 0x1,
	JPMFI_IS_STREAM	= 0x2,
	JPMFI_IS_PE_NATIVE	= 0x8,
	JPMFI_FROM_PKG_DATABASE	= 0x10,
	JPMFI_FROM_CLASSPATH	= 0x20
    }	JPM_FILEINFO_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL__intf_0073_0002
    {	JPMGFN_SIMPLE	= 1,
	JPMGFN_FULLYQUALIFIED	= 2,
	JPMGFN_LOCALFILEPATH	= 3
    }	JPM_GETFILENAME_TYPE;


EXTERN_C const IID LIBID_JPKGMGR;

#ifndef __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__
#define __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCodeStoreDBEntry
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCodeStoreDBEntry __RPC_FAR *LPENUMCODESTOREDBENTRY;


EXTERN_C const IID IID_IEnumCodeStoreDBEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCodeStoreDBEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCodeStoreDBEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCodeStoreDBEntry __RPC_FAR * This,
            /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCodeStoreDBEntryVtbl;

    interface IEnumCodeStoreDBEntry
    {
        CONST_VTBL struct IEnumCodeStoreDBEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCodeStoreDBEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCodeStoreDBEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCodeStoreDBEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCodeStoreDBEntry_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCodeStoreDBEntry_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCodeStoreDBEntry_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCodeStoreDBEntry_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Next_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCodeStoreDBEntry_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Skip_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCodeStoreDBEntry_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Reset_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This);


void __RPC_STUB IEnumCodeStoreDBEntry_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodeStoreDBEntry_Clone_Proxy( 
    IEnumCodeStoreDBEntry __RPC_FAR * This,
    /* [out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCodeStoreDBEntry_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCodeStoreDBEntry_INTERFACE_DEFINED__ */


#ifndef __ICodeStoreDBEntry_INTERFACE_DEFINED__
#define __ICodeStoreDBEntry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeStoreDBEntry
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICodeStoreDBEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICodeStoreDBEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateChild( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveChild( 
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChild( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumChildren( 
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteProperty( 
            /* [in] */ LPCOLESTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDWORDPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDWORDPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPSTR pszVal,
            /* [in] */ DWORD cbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringPropertyA( 
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeStoreDBEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeStoreDBEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeStoreDBEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChild )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumChildren )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProperty )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDWORDPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ DWORD __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDWORDPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ DWORD dwVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [out] */ LPSTR pszVal,
            /* [in] */ DWORD cbVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStringPropertyA )( 
            ICodeStoreDBEntry __RPC_FAR * This,
            /* [in] */ LPCSTR pszName,
            /* [in] */ LPCSTR pszVal);
        
        END_INTERFACE
    } ICodeStoreDBEntryVtbl;

    interface ICodeStoreDBEntry
    {
        CONST_VTBL struct ICodeStoreDBEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeStoreDBEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeStoreDBEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeStoreDBEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeStoreDBEntry_GetName(This,dwFlags,pbstrName)	\
    (This)->lpVtbl -> GetName(This,dwFlags,pbstrName)

#define ICodeStoreDBEntry_CreateChild(This,pszName,ppEntry)	\
    (This)->lpVtbl -> CreateChild(This,pszName,ppEntry)

#define ICodeStoreDBEntry_RemoveChild(This,pszName,dwFlags)	\
    (This)->lpVtbl -> RemoveChild(This,pszName,dwFlags)

#define ICodeStoreDBEntry_GetChild(This,pszName,ppEntry)	\
    (This)->lpVtbl -> GetChild(This,pszName,ppEntry)

#define ICodeStoreDBEntry_EnumChildren(This,ppEntry)	\
    (This)->lpVtbl -> EnumChildren(This,ppEntry)

#define ICodeStoreDBEntry_GetParent(This,ppParent)	\
    (This)->lpVtbl -> GetParent(This,ppParent)

#define ICodeStoreDBEntry_GetProperty(This,pszName,pvarProperty)	\
    (This)->lpVtbl -> GetProperty(This,pszName,pvarProperty)

#define ICodeStoreDBEntry_SetProperty(This,pszName,pvarProperty)	\
    (This)->lpVtbl -> SetProperty(This,pszName,pvarProperty)

#define ICodeStoreDBEntry_DeleteProperty(This,pszName)	\
    (This)->lpVtbl -> DeleteProperty(This,pszName)

#define ICodeStoreDBEntry_GetDWORDPropertyA(This,pszName,pVal)	\
    (This)->lpVtbl -> GetDWORDPropertyA(This,pszName,pVal)

#define ICodeStoreDBEntry_SetDWORDPropertyA(This,pszName,dwVal)	\
    (This)->lpVtbl -> SetDWORDPropertyA(This,pszName,dwVal)

#define ICodeStoreDBEntry_GetStringPropertyA(This,pszName,pszVal,cbVal)	\
    (This)->lpVtbl -> GetStringPropertyA(This,pszName,pszVal,cbVal)

#define ICodeStoreDBEntry_SetStringPropertyA(This,pszName,pszVal)	\
    (This)->lpVtbl -> SetStringPropertyA(This,pszName,pszVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetName_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB ICodeStoreDBEntry_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_CreateChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_CreateChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_RemoveChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    DWORD dwFlags);


void __RPC_STUB ICodeStoreDBEntry_RemoveChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetChild_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_GetChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_EnumChildren_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDBEntry_EnumChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetParent_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB ICodeStoreDBEntry_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);


void __RPC_STUB ICodeStoreDBEntry_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);


void __RPC_STUB ICodeStoreDBEntry_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_DeleteProperty_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName);


void __RPC_STUB ICodeStoreDBEntry_DeleteProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetDWORDPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB ICodeStoreDBEntry_GetDWORDPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetDWORDPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ DWORD dwVal);


void __RPC_STUB ICodeStoreDBEntry_SetDWORDPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_GetStringPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [out] */ LPSTR pszVal,
    /* [in] */ DWORD cbVal);


void __RPC_STUB ICodeStoreDBEntry_GetStringPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDBEntry_SetStringPropertyA_Proxy( 
    ICodeStoreDBEntry __RPC_FAR * This,
    /* [in] */ LPCSTR pszName,
    /* [in] */ LPCSTR pszVal);


void __RPC_STUB ICodeStoreDBEntry_SetStringPropertyA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeStoreDBEntry_INTERFACE_DEFINED__ */


#ifndef __ICodeStoreDB_INTERFACE_DEFINED__
#define __ICodeStoreDB_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICodeStoreDB
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICodeStoreDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICodeStoreDB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntry( 
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntry( 
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRootEntries( 
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeStoreDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICodeStoreDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICodeStoreDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEntry )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRootEntries )( 
            ICodeStoreDB __RPC_FAR * This,
            /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        END_INTERFACE
    } ICodeStoreDBVtbl;

    interface ICodeStoreDB
    {
        CONST_VTBL struct ICodeStoreDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeStoreDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICodeStoreDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICodeStoreDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICodeStoreDB_CreateEntry(This,pszName,ppEntry)	\
    (This)->lpVtbl -> CreateEntry(This,pszName,ppEntry)

#define ICodeStoreDB_RemoveEntry(This,pszName,dwFlags)	\
    (This)->lpVtbl -> RemoveEntry(This,pszName,dwFlags)

#define ICodeStoreDB_GetEntry(This,pszName,ppEntry)	\
    (This)->lpVtbl -> GetEntry(This,pszName,ppEntry)

#define ICodeStoreDB_EnumRootEntries(This,ppEntry)	\
    (This)->lpVtbl -> EnumRootEntries(This,ppEntry)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICodeStoreDB_CreateEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_RemoveEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    DWORD dwFlags);


void __RPC_STUB ICodeStoreDB_RemoveEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_GetEntry_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [retval][out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_GetEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICodeStoreDB_EnumRootEntries_Proxy( 
    ICodeStoreDB __RPC_FAR * This,
    /* [retval][out] */ IEnumCodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB ICodeStoreDB_EnumRootEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICodeStoreDB_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CLSID_CodeStoreDB;

class CLSID_CodeStoreDB;
#endif

#ifndef __IJavaPackageManager_INTERFACE_DEFINED__
#define __IJavaPackageManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaPackageManager
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IJavaPackageManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaPackageManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFileType,
            /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
            /* [in] */ UINT cPackages,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UninstallPackage( 
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPackages( 
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPackage( 
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExplicitClassPath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExplicitClassPath( 
            /* [in] */ LPCOLESTR pszPath,
            /* [in] */ BOOL fAppend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentDirectory( 
            /* [in] */ LPCOLESTR pszDir) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaPackageManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaPackageManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaPackageManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFileType,
            /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
            /* [in] */ UINT cPackages,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UninstallPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumPackages )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackage )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPackageName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFile )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFileName,
            /* [in] */ LPCOLESTR pszNamespace,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExplicitClassPath )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExplicitClassPath )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPath,
            /* [in] */ BOOL fAppend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrentDirectory )( 
            IJavaPackageManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszDir);
        
        END_INTERFACE
    } IJavaPackageManagerVtbl;

    interface IJavaPackageManager
    {
        CONST_VTBL struct IJavaPackageManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaPackageManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaPackageManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaPackageManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaPackageManager_InstallPackage(This,pszFileName,pszNamespace,dwFileType,pPackageInfo,cPackages,dwFlags,pSecurityInfo)	\
    (This)->lpVtbl -> InstallPackage(This,pszFileName,pszNamespace,dwFileType,pPackageInfo,cPackages,dwFlags,pSecurityInfo)

#define IJavaPackageManager_UninstallPackage(This,pszPackageName,pszNamespace,dwFlags)	\
    (This)->lpVtbl -> UninstallPackage(This,pszPackageName,pszNamespace,dwFlags)

#define IJavaPackageManager_EnumPackages(This,pszNamespace,ppEnum)	\
    (This)->lpVtbl -> EnumPackages(This,pszNamespace,ppEnum)

#define IJavaPackageManager_GetPackage(This,pszPackageName,pszNamespace,ppPackage)	\
    (This)->lpVtbl -> GetPackage(This,pszPackageName,pszNamespace,ppPackage)

#define IJavaPackageManager_GetFile(This,pszFileName,pszNamespace,dwFlags,ppFile)	\
    (This)->lpVtbl -> GetFile(This,pszFileName,pszNamespace,dwFlags,ppFile)

#define IJavaPackageManager_GetExplicitClassPath(This,pbstrPath)	\
    (This)->lpVtbl -> GetExplicitClassPath(This,pbstrPath)

#define IJavaPackageManager_SetExplicitClassPath(This,pszPath,fAppend)	\
    (This)->lpVtbl -> SetExplicitClassPath(This,pszPath,fAppend)

#define IJavaPackageManager_SetCurrentDirectory(This,pszDir)	\
    (This)->lpVtbl -> SetCurrentDirectory(This,pszDir)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaPackageManager_InstallPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFileType,
    /* [out][in] */ LPPACKAGEINSTALLINFO pPackageInfo,
    /* [in] */ UINT cPackages,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCPACKAGESECURITYINFO pSecurityInfo);


void __RPC_STUB IJavaPackageManager_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_UninstallPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPackageName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IJavaPackageManager_UninstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_EnumPackages_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [retval][out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IJavaPackageManager_EnumPackages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetPackage_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPackageName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [retval][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *ppPackage);


void __RPC_STUB IJavaPackageManager_GetPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetFile_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFileName,
    /* [in] */ LPCOLESTR pszNamespace,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IJavaFile __RPC_FAR *__RPC_FAR *ppFile);


void __RPC_STUB IJavaPackageManager_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_GetExplicitClassPath_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaPackageManager_GetExplicitClassPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_SetExplicitClassPath_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszPath,
    /* [in] */ BOOL fAppend);


void __RPC_STUB IJavaPackageManager_SetExplicitClassPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackageManager_SetCurrentDirectory_Proxy( 
    IJavaPackageManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszDir);


void __RPC_STUB IJavaPackageManager_SetCurrentDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaPackageManager_INTERFACE_DEFINED__ */


#ifndef __IJavaPackage_INTERFACE_DEFINED__
#define __IJavaPackage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaPackage
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IJavaPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPackageName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
            /* [out] */ DWORD __RPC_FAR *pdwVersionLS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSystemClass( 
            /* [out] */ BOOL __RPC_FAR *pfIsSystemClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsTrustedSource( 
            /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
            /* [out] */ DWORD __RPC_FAR *pcbCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigner( 
            /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
            /* [out] */ DWORD __RPC_FAR *pcbSigner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDatabaseEntry( 
            /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFiles( 
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilePathA( 
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaPackage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaPackage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackageName )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
            /* [out] */ DWORD __RPC_FAR *pdwVersionLS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilePath )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSystemClass )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsSystemClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NeedsTrustedSource )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCapabilities )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
            /* [out] */ DWORD __RPC_FAR *pcbCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSigner )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
            /* [out] */ DWORD __RPC_FAR *pcbSigner);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDatabaseEntry )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFiles )( 
            IJavaPackage __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilePathA )( 
            IJavaPackage __RPC_FAR * This,
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath);
        
        END_INTERFACE
    } IJavaPackageVtbl;

    interface IJavaPackage
    {
        CONST_VTBL struct IJavaPackageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaPackage_GetPackageName(This,pbstrName)	\
    (This)->lpVtbl -> GetPackageName(This,pbstrName)

#define IJavaPackage_GetVersion(This,pdwVersionMS,pdwVersionLS)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionMS,pdwVersionLS)

#define IJavaPackage_GetFilePath(This,pbstrPath)	\
    (This)->lpVtbl -> GetFilePath(This,pbstrPath)

#define IJavaPackage_IsSystemClass(This,pfIsSystemClass)	\
    (This)->lpVtbl -> IsSystemClass(This,pfIsSystemClass)

#define IJavaPackage_NeedsTrustedSource(This,pfNeedsTrustedSource)	\
    (This)->lpVtbl -> NeedsTrustedSource(This,pfNeedsTrustedSource)

#define IJavaPackage_GetCapabilities(This,ppCapabilities,pcbCapabilities)	\
    (This)->lpVtbl -> GetCapabilities(This,ppCapabilities,pcbCapabilities)

#define IJavaPackage_GetSigner(This,ppSigner,pcbSigner)	\
    (This)->lpVtbl -> GetSigner(This,ppSigner,pcbSigner)

#define IJavaPackage_GetDatabaseEntry(This,ppEntry)	\
    (This)->lpVtbl -> GetDatabaseEntry(This,ppEntry)

#define IJavaPackage_EnumFiles(This,dwFlags,ppEnum)	\
    (This)->lpVtbl -> EnumFiles(This,dwFlags,ppEnum)

#define IJavaPackage_GetFilePathA(This,pszPath,cbPath)	\
    (This)->lpVtbl -> GetFilePathA(This,pszPath,cbPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaPackage_GetPackageName_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IJavaPackage_GetPackageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetVersion_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVersionMS,
    /* [out] */ DWORD __RPC_FAR *pdwVersionLS);


void __RPC_STUB IJavaPackage_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetFilePath_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaPackage_GetFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_IsSystemClass_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsSystemClass);


void __RPC_STUB IJavaPackage_IsSystemClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_NeedsTrustedSource_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfNeedsTrustedSource);


void __RPC_STUB IJavaPackage_NeedsTrustedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetCapabilities_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPCBYTE __RPC_FAR *ppCapabilities,
    /* [out] */ DWORD __RPC_FAR *pcbCapabilities);


void __RPC_STUB IJavaPackage_GetCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetSigner_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPCBYTE __RPC_FAR *ppSigner,
    /* [out] */ DWORD __RPC_FAR *pcbSigner);


void __RPC_STUB IJavaPackage_GetSigner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetDatabaseEntry_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ ICodeStoreDBEntry __RPC_FAR *__RPC_FAR *ppEntry);


void __RPC_STUB IJavaPackage_GetDatabaseEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_EnumFiles_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [retval][out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IJavaPackage_EnumFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaPackage_GetFilePathA_Proxy( 
    IJavaPackage __RPC_FAR * This,
    /* [out] */ LPSTR pszPath,
    /* [in] */ DWORD cbPath);


void __RPC_STUB IJavaPackage_GetFilePathA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaPackage_INTERFACE_DEFINED__ */


#ifndef __ICreateJavaPackageMgr_INTERFACE_DEFINED__
#define __ICreateJavaPackageMgr_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICreateJavaPackageMgr
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ICreateJavaPackageMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICreateJavaPackageMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPackageManager( 
            /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateJavaPackageMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateJavaPackageMgr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateJavaPackageMgr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateJavaPackageMgr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPackageManager )( 
            ICreateJavaPackageMgr __RPC_FAR * This,
            /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr);
        
        END_INTERFACE
    } ICreateJavaPackageMgrVtbl;

    interface ICreateJavaPackageMgr
    {
        CONST_VTBL struct ICreateJavaPackageMgrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateJavaPackageMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateJavaPackageMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateJavaPackageMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateJavaPackageMgr_GetPackageManager(This,ppPackageMgr)	\
    (This)->lpVtbl -> GetPackageManager(This,ppPackageMgr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateJavaPackageMgr_GetPackageManager_Proxy( 
    ICreateJavaPackageMgr __RPC_FAR * This,
    /* [out] */ IJavaPackageManager __RPC_FAR *__RPC_FAR *ppPackageMgr);


void __RPC_STUB ICreateJavaPackageMgr_GetPackageManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateJavaPackageMgr_INTERFACE_DEFINED__ */


#ifndef __IJavaFile_INTERFACE_DEFINED__
#define __IJavaFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaFile
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IJavaFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileStream( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPENativePath( 
            /* [out] */ BSTR __RPC_FAR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPENativePathA( 
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimestamp( 
            /* [out] */ DWORD __RPC_FAR *pdwTimestamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IJavaFile __RPC_FAR * This,
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileStream )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPENativePath )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPENativePathA )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ LPSTR pszPath,
            /* [in] */ DWORD cbPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimestamp )( 
            IJavaFile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwTimestamp);
        
        END_INTERFACE
    } IJavaFileVtbl;

    interface IJavaFile
    {
        CONST_VTBL struct IJavaFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaFile_GetName(This,dwType,pbstrName)	\
    (This)->lpVtbl -> GetName(This,dwType,pbstrName)

#define IJavaFile_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IJavaFile_GetFileStream(This,ppStream)	\
    (This)->lpVtbl -> GetFileStream(This,ppStream)

#define IJavaFile_GetPENativePath(This,pbstrPath)	\
    (This)->lpVtbl -> GetPENativePath(This,pbstrPath)

#define IJavaFile_GetPENativePathA(This,pszPath,cbPath)	\
    (This)->lpVtbl -> GetPENativePathA(This,pszPath,cbPath)

#define IJavaFile_GetTimestamp(This,pdwTimestamp)	\
    (This)->lpVtbl -> GetTimestamp(This,pdwTimestamp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaFile_GetName_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [in] */ DWORD dwType,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IJavaFile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IJavaFile_GetFlags_Proxy( 
    IJavaFile __RPC_FAR * This);


void __RPC_STUB IJavaFile_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetFileStream_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IJavaFile_GetFileStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetPENativePath_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrPath);


void __RPC_STUB IJavaFile_GetPENativePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetPENativePathA_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ LPSTR pszPath,
    /* [in] */ DWORD cbPath);


void __RPC_STUB IJavaFile_GetPENativePathA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaFile_GetTimestamp_Proxy( 
    IJavaFile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwTimestamp);


void __RPC_STUB IJavaFile_GetTimestamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaFile_INTERFACE_DEFINED__ */


#ifndef __IEnumJavaPackage_INTERFACE_DEFINED__
#define __IEnumJavaPackage_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumJavaPackage
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumJavaPackage __RPC_FAR *LPENUMJAVAPACKAGE;


EXTERN_C const IID IID_IEnumJavaPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumJavaPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumJavaPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumJavaPackage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumJavaPackage __RPC_FAR * This,
            /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumJavaPackageVtbl;

    interface IEnumJavaPackage
    {
        CONST_VTBL struct IEnumJavaPackageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumJavaPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumJavaPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumJavaPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumJavaPackage_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumJavaPackage_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumJavaPackage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumJavaPackage_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Next_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IJavaPackage __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumJavaPackage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Skip_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumJavaPackage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Reset_Proxy( 
    IEnumJavaPackage __RPC_FAR * This);


void __RPC_STUB IEnumJavaPackage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaPackage_Clone_Proxy( 
    IEnumJavaPackage __RPC_FAR * This,
    /* [out] */ IEnumJavaPackage __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumJavaPackage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumJavaPackage_INTERFACE_DEFINED__ */


#ifndef __IEnumJavaFile_INTERFACE_DEFINED__
#define __IEnumJavaFile_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumJavaFile
 * at Fri Jul 11 15:30:21 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumJavaFile __RPC_FAR *LPENUMJAVAFILE;


EXTERN_C const IID IID_IEnumJavaFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumJavaFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumJavaFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumJavaFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumJavaFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumJavaFile __RPC_FAR * This,
            /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumJavaFileVtbl;

    interface IEnumJavaFile
    {
        CONST_VTBL struct IEnumJavaFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumJavaFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumJavaFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumJavaFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumJavaFile_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumJavaFile_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumJavaFile_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumJavaFile_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumJavaFile_Next_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IJavaFile __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumJavaFile_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Skip_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumJavaFile_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Reset_Proxy( 
    IEnumJavaFile __RPC_FAR * This);


void __RPC_STUB IEnumJavaFile_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumJavaFile_Clone_Proxy( 
    IEnumJavaFile __RPC_FAR * This,
    /* [out] */ IEnumJavaFile __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumJavaFile_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumJavaFile_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CLSID_JavaPackageManager;

class CLSID_JavaPackageManager;
#endif
#endif /* __JPKGMGR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\platform.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       platform.h
//
//  Contents:   Macros for portable access to platform dependent values.
//
//
// This file contains macros for easy cross platform developing.
// There are macros for compiler differences and platform/layer differences.
//
//----------------------------------------------------------------------------


#ifndef __PLATFORM_H_
#define __PLATFORM_H_

#ifdef __cplusplus
   // +++ Unaligned memory access templates/macros
#  include <unaligned.hpp>
#endif

////////////////////////////////////////////////////////////////////
//
// Global defines (should be moved to NT public headers)
//

#define VER_PLATFORM_WIN32_UNIX 9

////////////////////////////////////////////////////////////////////
//
// Compiler differences
//

#if !defined(_MSC_VER) && !defined(__APOGEE__)
    // For compilers lacking VC++ extensions

#   define __cdecl
#   define INLINEOP      /* Inline operators not available IEUNIX */

#   ifdef UNIX
        // Unix specific compiler problems
#       define UNSIZED_ARRAY 1
#   else
#       define UNSIZED_ARRAY
#   endif // UNIX

#else // !_MSC_VER

    // VC++ compilers

#   define INLINEOP inline
#   define UNSIZED_ARRAY

#endif

#define EMPTY_SIZE UNSIZED_ARRAY

////////////////////////////////////////////////////////////////////
//
// Platform / Layer dependent sections.
//
// NOTE! #ifdefing based on WIN32 is invalid as some layers define
//       WIN32 for compatability.
//

#define ENDEXCEPT  __endexcept
#define ENDFINALLY __endfinally

#if !defined( UNIX )
#define __endexcept
#define __endfinally
#endif // UNIX

// +++ File Separators

#if defined( UNIX )
// UNIX

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '/'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'/'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "/"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"/"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ':'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L':'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ":"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L":"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\n"
#  endif

#else // UNIX

// Windows / MAC

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '\\'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'\\'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "\\"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"\\"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ';'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L';'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ";"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L";"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\r\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\r\n"
#  endif

#endif // Windows / MAC



#ifdef UNIX


#  define PLATFORM_ACCEL_KEY ALT
#  define PLATFORM_ACCEL_STR "Alt"  // --  Look in rc.sed files
#  define FACCELKEY FALT

#define VK_OEM_SLASH 0xBF

#else   /* UNIX  */

#define INTERFACE_PROLOGUE(a)
#define INTERFACE_EPILOGUE(a)
#define INTERFACE_PROLOGUE_(a,b)
#define INTERFACE_EPILOGUE_(a,b)


#  define PLATFORM_ACCEL_KEY CONTROL
#  define PLATFORM_ACCEL_STR "Ctrl"  // --  Look in rc.sed files
#  define FACCELKEY FCONTROL

#define VK_OEM_SLASH '/'

#endif  /* UNIX */

#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))

#ifdef BIG_ENDIAN
#define MAKE_LI(low,high) { high, low }
#define PALETTE_ENTRY( r, g, b, f )  { f, b, g, r }
#else
#define MAKE_LI(low,high) { low, high }
#define PALETTE_ENTRY( r, g, b, f )  { r, g, b, f }
#endif

#endif // __PLATFORM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wab.h ===
/*
 * WAB.H
 *
 * Top level public header for WAB API functions.
 *
 */

#include <wabdefs.h>
#include <wabcode.h>
#include <wabtags.h>
#include <wabutil.h>
#include <wabiab.h>
#include <wabapi.h>
#include <wabmem.h>
#include <wabnot.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\scrptids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1996-1998 Microsoft Corporation. All Rights Reserved.
//
//  File: scrptids.h
//
//--------------------------------------------------------------------------

// Invent DISPIDs for the things that don't have built-in dispid's
#define DISPID_LOAD		1
#define DISPID_UNLOAD	2
#define DISPID_SUBMIT	3
#define DISPID_FOCUS	4
#define DISPID_CHANGE	5
#define DISPID_BLUR		6
#define DISPID_SELECT	7
#define DISPID_MOUSEOVER 8
#define DISPID_PARSECOMPLETE 9
#define DISPID_ABORT	10
#define DISPID_ERROR	11
#define DISPID_MOUSEOUT 12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, LPCSTR pszUsername, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif


STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

//;BUGBUG Quick & dirty way to check if ratings are installed. We still need to calling
//;BUGBUG ratings dll to find out for sure but this allows us to delay load ratings.
_inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, &szSup, &cbSize) == ERROR_SUCCESS);
}

#define S_RATING_ALLOW        S_OK
#define S_RATING_DENY         S_FALSE
#define S_RATING_FOUND        0x00000002
#define E_RATING_NOT_FOUND    0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(ObtainRating) (THIS_ LPCSTR pszTargetUrl, HANDLE hAbortEvent,
                             IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

    STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE        0x80000000
#define RATING_ORDER_LOCALLIST        0xC0000000

#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\unixdef.h ===
#ifdef _WIN64
typedef __int64 DWORD_PTR, *PDWORD_PTR;
#else
typedef long DWORD_PTR, *PDWORD_PTR;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabmem.h ===
#if !defined(WABMEM_H)
#define WABMEM_H

#if !defined(MAPIX_H)
typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
	LPVOID			lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR	*LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR	*LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR 		*LPMAPIFREEBUFFER;

#endif  // MAPIX_H

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEBUFFER)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEMORE)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE WABFREEBUFFER)(
   LPWABOBJECT     lpWABObject,
	LPVOID			lpBuffer
);

typedef WABALLOCATEBUFFER FAR	*LPWABALLOCATEBUFFER;
typedef WABALLOCATEMORE FAR	*LPWABALLOCATEMORE;
typedef WABFREEBUFFER FAR 		*LPWABFREEBUFFER;
#endif  // WABMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\rowpos.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:20:43 1997
 */
/* Compiler settings for msdadc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rowpos_h__
#define __rowpos_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRowPosition_FWD_DEFINED__
#define __IRowPosition_FWD_DEFINED__
typedef interface IRowPosition IRowPosition;
#endif 	/* __IRowPosition_FWD_DEFINED__ */


#ifndef __IRowPositionChange_FWD_DEFINED__
#define __IRowPositionChange_FWD_DEFINED__
typedef interface IRowPositionChange IRowPositionChange;
#endif 	/* __IRowPositionChange_FWD_DEFINED__ */


#ifndef __RowPosition_FWD_DEFINED__
#define __RowPosition_FWD_DEFINED__

#ifdef __cplusplus
typedef class RowPosition RowPosition;
#else
typedef struct RowPosition RowPosition;
#endif /* __cplusplus */

#endif 	/* __RowPosition_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __IRowPosition_INTERFACE_DEFINED__
#define __IRowPosition_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPosition
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 


typedef DWORD DBPOSITIONFLAGS;


enum DBPOSITIONFLAGSENUM
    {	DBPOSITION_OK	= 0,
	DBPOSITION_NOROW	= DBPOSITION_OK + 1,
	DBPOSITION_BOF	= DBPOSITION_NOROW + 1,
	DBPOSITION_EOF	= DBPOSITION_BOF + 1
    };

EXTERN_C const IID IID_IRowPosition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a94-2a1c-11ce-ade5-00aa0044773d")
    IRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ClearRowPosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowPosition( 
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRowPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPosition __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRowPosition )( 
            IRowPosition __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [out] */ HCHAPTER __RPC_FAR *phChapter,
            /* [out] */ HROW __RPC_FAR *phRow,
            /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRowPosition )( 
            IRowPosition __RPC_FAR * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ HROW hRow,
            /* [in] */ DBPOSITIONFLAGS dwPositionFlags);
        
        END_INTERFACE
    } IRowPositionVtbl;

    interface IRowPosition
    {
        CONST_VTBL struct IRowPositionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPosition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPosition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPosition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPosition_ClearRowPosition(This)	\
    (This)->lpVtbl -> ClearRowPosition(This)

#define IRowPosition_GetRowPosition(This,phChapter,phRow,pdwPositionFlags)	\
    (This)->lpVtbl -> GetRowPosition(This,phChapter,phRow,pdwPositionFlags)

#define IRowPosition_GetRowset(This,riid,ppRowset)	\
    (This)->lpVtbl -> GetRowset(This,riid,ppRowset)

#define IRowPosition_Initialize(This,pRowset)	\
    (This)->lpVtbl -> Initialize(This,pRowset)

#define IRowPosition_SetRowPosition(This,hChapter,hRow,dwPositionFlags)	\
    (This)->lpVtbl -> SetRowPosition(This,hChapter,hRow,dwPositionFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPosition_ClearRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This);


void __RPC_STUB IRowPosition_ClearRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [out] */ HCHAPTER __RPC_FAR *phChapter,
    /* [out] */ HROW __RPC_FAR *phRow,
    /* [out] */ DBPOSITIONFLAGS __RPC_FAR *pdwPositionFlags);


void __RPC_STUB IRowPosition_GetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_GetRowset_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPUNKNOWN __RPC_FAR *ppRowset);


void __RPC_STUB IRowPosition_GetRowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_Initialize_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);


void __RPC_STUB IRowPosition_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowPosition_SetRowPosition_Proxy( 
    IRowPosition __RPC_FAR * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ HROW hRow,
    /* [in] */ DBPOSITIONFLAGS dwPositionFlags);


void __RPC_STUB IRowPosition_SetRowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPosition_INTERFACE_DEFINED__ */


#ifndef __IRowPositionChange_INTERFACE_DEFINED__
#define __IRowPositionChange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowPositionChange
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



enum DBREASONPOSITIONENUM
    {	DBREASON_ROWPOSITION_CHANGED	= DBREASON_ROWSET_CHANGED + 1,
	DBREASON_ROWPOSITION_CHAPTERCHANGED	= DBREASON_ROWPOSITION_CHANGED + 1,
	DBREASON_ROWPOSITION_CLEARED	= DBREASON_ROWPOSITION_CHAPTERCHANGED + 1
    };

EXTERN_C const IID IID_IRowPositionChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0997a571-126e-11d0-9f8a-00a0c9a0631e")
    IRowPositionChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnRowPositionChange( 
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowPositionChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowPositionChange __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowPositionChange __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnRowPositionChange )( 
            IRowPositionChange __RPC_FAR * This,
            /* [in] */ DBREASON eReason,
            /* [in] */ DBEVENTPHASE ePhase,
            /* [in] */ BOOL fCantDeny);
        
        END_INTERFACE
    } IRowPositionChangeVtbl;

    interface IRowPositionChange
    {
        CONST_VTBL struct IRowPositionChangeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowPositionChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRowPositionChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRowPositionChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRowPositionChange_OnRowPositionChange(This,eReason,ePhase,fCantDeny)	\
    (This)->lpVtbl -> OnRowPositionChange(This,eReason,ePhase,fCantDeny)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowPositionChange_OnRowPositionChange_Proxy( 
    IRowPositionChange __RPC_FAR * This,
    /* [in] */ DBREASON eReason,
    /* [in] */ DBEVENTPHASE ePhase,
    /* [in] */ BOOL fCantDeny);


void __RPC_STUB IRowPositionChange_OnRowPositionChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowPositionChange_INTERFACE_DEFINED__ */



#ifndef __MSDAUTILLib_LIBRARY_DEFINED__
#define __MSDAUTILLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MSDAUTILLib
 * at Thu May 22 17:20:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RowPosition;

class DECLSPEC_UUID("2048EEE6-7FA2-11D0-9E6A-00A0C9138C29")
RowPosition;

DEFINE_GUID(CLSID_RowPosition, 0x2048eee6, 0x7fa2, 0x11d0, 0x9e, 0x6a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x29);
DEFINE_GUID(IID_IRowPosition,  0x0c733a94, 0x2a1c, 0x11ce, 0xad, 0xe5, 0x0, 0xaa, 0x0, 0x44, 0x77, 0x3d);
DEFINE_GUID(IID_IRowPositionChange,  0x0997a571, 0x126e, 0x11d0, 0x9f, 0x8a, 0x0, 0xa0, 0xc9, 0xa0, 0x63, 0x1e);


#endif
#endif /* __MSDAUTILLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabnot.h ===
/*
 *	WABNOT.H
 *
 * Defines Notification structures.  These are also defined in mapispi.h.
 *
 * Copyright 1986-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPISPI_H) && !defined(WABSPI_H)
#define WABSPI_H
/* Include common MAPI header files if they haven't been already. */


#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Notification key structure for the MAPI notification engine */

typedef struct
{
	ULONG		cb;				/* How big the key is */
	BYTE		ab[MAPI_DIM];	/* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)		(offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)		(offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
	struct _NOTIFKEY_ ## _name \
{ \
	ULONG		cb; \
	BYTE		ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC				((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED			((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE	((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL			((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND		((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED		((ULONG) 0x00000004)
#define NOTIFY_CRITSEC			((ULONG) 0x00001000)
#define NOTIFY_NONCRIT			((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE	((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR	((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED	((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define	STATUSROW_UPDATE		((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET			((ULONG) 0x00000000)
#define STGSTRM_CURRENT			((ULONG) 0x10000000)
#define STGSTRM_MODIFY			((ULONG) 0x00000002)
#define STGSTRM_CREATE			((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO	((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ			((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\unaligned.hpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       unaligned.hpp
//
//  Contents:   Templatized data types for access to unaligned scalar values.
//
//----------------------------------------------------------------------------

// Implementation of UNALIGNED data values.  This works for simple scalar values.
// This file is heavily macro-based.  The intent is to do this work with arithmetic.
// The functionality may be expressed much more consisely with memcpy, but I need an
// implementation faster than that.

// To create an UNALIGNED type, use the MAKE_UNALIGNED_TYPE macro.  For example, if
// you need an int_UNALIGNED, say
//
//        MAKE_UNALIGNED_TYPE( int, 4 );
//
// Note that you need to specifiy the size of the base type.  This is because the
// amount of work to be done needs to be known by the preprocessor, where sizeof()
// doesn't work.

// To use: The intent is that replace occurances of "type UNALIGNED" in your code
// with "type_UNALIGNED".  It's simply a lexical change.  You could automate this
// change in order to easily convert code.  More importantly, the reverse
// transformation may also be easily automated, making it easier to merge with code
// that doesn't use these types.

// UNALIGNED64: The unaligned 64 types are an optimization.  They should only be used
// for values over four bytes in size (e.g. __int64, double).  They assume that the
// pointers are aligned to 4-bytes, so that access may be done with two 32-bit
// references, instead of 8 8-bit references.

#ifndef __unaligned_h__
#define __unaligned_h__

#if defined (_MSC_VER) || defined(__APOGEE__)

#define MAKE_UNALIGNED_TYPE(base,size)    typedef base UNALIGNED   base##_UNALIGNED

//
// Use MAKE_UNALIGNED64_TYPE for QWORD data that may only be DWORD aligned on 64-bit
// machines.  Only 64-bit architectures pay the penalty for accessing such data.
//

#ifdef SPARC
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base base##_UNALIGNED64
#else
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base UNALIGNED base##_UNALIGNED64
#endif // SPARC

#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef base UNALIGNED *base##_UNALIGNEDPTR

#else // defined (_MSC_VER) || defined(__APOGEE__)


#ifdef BIG_ENDIAN

#define SET2(val,data)                          \
    data[0] = (val) >> 8,                       \
    data[1] = (val)

#define GET2(data)                              \
    ( ( data[0] << 8 ) |                        \
      ( data[1] ) )

#define SET4(val,data)                          \
    data[0] = (val) >> 24,                      \
    data[1] = (val) >> 16,                      \
    data[2] = (val) >> 8,                       \
    data[3] = (val)

#define GET4(data)                              \
    ( ( data[0] << 24 ) |                       \
      ( data[1] << 16 ) |                       \
      ( data[2] << 8 ) |                        \
      ( data[3] ) )

#define SET8(val,data)                          \
    data[0] = (val) >> 56,                      \
    data[1] = (val) >> 48,                      \
    data[2] = (val) >> 40,                      \
    data[3] = (val) >> 32                       \
    data[4] = (val) >> 24,                      \
    data[5] = (val) >> 16,                      \
    data[6] = (val) >> 8,                       \
    data[7] = (val)

#define GET8(data)                              \
    ( ( data[0] << 56 ) |                       \
      ( data[1] << 48 ) |                       \
      ( data[2] << 40 ) |                       \
      ( data[3] << 32 ) |                       \
      ( data[4] << 24 ) |                       \
      ( data[5] << 16 ) |                       \
      ( data[6] << 8 ) |                        \
      ( data[7] ) )

#define SET648(val,data)                        \
    data[0] = (val) >> 32,                      \
    data[1] = (val)

#define GET648(data)                            \
    ( ( data[0] << 32 ) |                       \
      ( data[1] ) )

#else

#define SET2(val,data)                          \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET2(data)                              \
    ( ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET4(val,data)                          \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET4(data)                              \
    ( ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET8(val,data)                          \
    data[7] = (val) >> 56,                      \
    data[6] = (val) >> 48,                      \
    data[5] = (val) >> 40,                      \
    data[4] = (val) >> 32,                      \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET8(data)                              \
    ( ( data[7] << 56 ) |                       \
      ( data[6] << 48 ) |                       \
      ( data[5] << 40 ) |                       \
      ( data[4] << 32 ) |                       \
      ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET648(val,data)                        \
    data[1] = (val) >> 32,                      \
    data[0] = (val)

#define GET648(data)                            \
    ( ( data[1] << 32 ) |                       \
      ( data[0] ) )

#endif

#define GROUP(type,size,get,set,sfx)                                    \
    Unaligned##sfx##size( type v ) { set##size( v, data ); }            \
    type operator = ( type v )     { set##size( v, data ); return v; }  \
    operator type()           { return get##size( data ); }             \
    type operator += (const type v) { set##size( get##size(data) + v, data); return *this; } \
    type operator -= (const type v) { set##size( get##size(data) - v, data); return *this; } \
    type operator <<= (const type v) { set##size( get##size(data) << v, data); return *this; } \
    type operator *= (const type v) { set##size( get##size(data) * v, data); return *this; } \
    type operator /= (const type v) { set##size( get##size(data) / v, data); return *this; } \
    type operator %= (const type v) { set##size( get##size(data) % v, data); return *this; } \
    type operator >>= (const type v) { set##size( get##size(data) >> v, data); return *this; } \
    type operator ^= (const type v) { set##size( get##size(data) ^ v, data); return *this; } \
    type operator &= (const type v) { set##size( get##size(data) & v, data); return *this; } \
    type operator |= (const type v) { set##size( get##size(data) | v, data); return *this; } \


#define MAKE_TEMPLATE(size,type,sfx)                            \
template<class BASE>                                            \
class Unaligned##sfx##size<BASE>                                \
{                                                               \
  protected:                                                    \
    type data[ size / sizeof(type) ];                           \
                                                                \
  public:                                                       \
                                                                \
    GROUP( signed char,      size, GET##sfx, SET##sfx, sfx )    \
    GROUP( short,            size, GET##sfx, SET##sfx, sfx )    \
    GROUP( int,              size, GET##sfx, SET##sfx, sfx )    \
    GROUP( wchar_t,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( long,             size, GET##sfx, SET##sfx, sfx )    \
    GROUP( __int64,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned char,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned short,   size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned int,     size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned long,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned __int64, size, GET##sfx, SET##sfx, sfx )    \
}

MAKE_TEMPLATE( 2, unsigned char, );
MAKE_TEMPLATE( 4, unsigned char, );
MAKE_TEMPLATE( 8, unsigned char, );
MAKE_TEMPLATE( 8, unsigned int, 64 );

template<class BASE>
class UnalignedPtr<BASE> : Unaligned4<BASE> {
public:
	UnalignedPtr<BASE>(const void * v) : Unaligned4<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#undef SET2
#undef SET4
#undef SET8
#undef SET648
#undef GROUP
#undef MAKE_TEMPLATE

#define MAKE_UNALIGNED_TYPE(base,size)    typedef Unaligned##size<base>   base##_UNALIGNED
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef Unaligned64##size<base> base##_UNALIGNED64
#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef UnalignedPtr<base> *    base##_UNALIGNEDPTR

#endif  // _MSC_VER

// Predefine some of the basic types.

MAKE_UNALIGNED_TYPE( short, 2 );
MAKE_UNALIGNED_TYPE( int, 4 );
MAKE_UNALIGNED_TYPE( long, 4 );
MAKE_UNALIGNED_TYPE( WORD, 2 );
MAKE_UNALIGNED_TYPE( DWORD, 4 );
MAKE_UNALIGNED_TYPE( USHORT, 4 );
MAKE_UNALIGNED_TYPE( SHORT, 4 );
MAKE_UNALIGNED_TYPE( __int64, 8 );
MAKE_UNALIGNED64_TYPE( __int64, 8 );

#endif __unaligned_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabcode.h ===
/*
 *  WABCODE.H
 *
 *  Status Codes returned by WAB routines
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPICODE_H) && !defined(WABCODE_H)
#define WABCODE_H

/* Define S_OK and ITF_* */

#ifdef WIN32
#include <objerror.h>
#endif

/*
 *  WAB Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or objerror.h (Windows NT 3.5 and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *
 *   where
 *
 *      S - Severity - indicates success/fail
 *
 *          0 - Success
 *          1 - Fail (COERROR)
 *
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *
 *      Code - is the facility's status code
 *
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )  (MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn ) (MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one WAB object) */

#define MAPI_E_CALL_FAILED                              E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY                        E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER                        E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED                  E_NOINTERFACE
#define MAPI_E_NO_ACCESS                                E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT                               MAKE_MAPI_E( 0x102 )
#define MAPI_E_BAD_CHARWIDTH                            MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG                          MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS                            MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID                          MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT                           MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED                           MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED                           MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY                                     MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK                          MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES                     MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND                                MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION                                  MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED                             MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT                            MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL                              MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT                          MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR                            MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR                               MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX                              MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN                               MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR                           MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED                                 MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA                             MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED                             MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER                          MAKE_MAPI_E( 0x11D )

/* WAB base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION                           MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID                          MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN                  MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE                               MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE                                MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE                             MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT                          MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE                          MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG                                  MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY                             MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID                            MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED                          MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE                       MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT                                  MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY                              MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG                            MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK                         MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED                         MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT                             MAKE_MAPI_S( 0x482 )

#define MAPI_W_PARTIAL_COMPLETION						 MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP                          MAKE_MAPI_E( 0x700 )


/* Miscellaneous errors */
#define MAPI_E_COLLISION                                MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED                          MAKE_MAPI_E( 0x605 )
#define MAPI_E_FOLDER_CYCLE                             MAKE_MAPI_E( 0x60B )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)  ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#define HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif  /* WABCODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabdefs.h ===
/*
 *  WABDEFS.H
 *
 *  Definitions used by WAB clients
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif // GetLastError
#endif // WIN16

#if !defined(MAPIDEFS_H) && !defined(WABDEFS_H)
#define WABDEFS_H
#if defined (WIN32)

#if defined (NT) && !defined (_WINNT)
#pragma message ("\nWARNING!!\n NT defined but not _WINNT.\n    You must define _WINNT to ensure "\
    "successful compile of Windows NT code\n")
#define _WINNT
#endif /* defined NT and not defined _WINNT */
#endif /* WIN32 */

#if defined (WIN32) && !defined (MAC)   /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <objerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16) || defined (MAC)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM    1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (WIN32)
#define STDMAPIINITCALLTYPE     __cdecl
#else
#define STDMAPIINITCALLTYPE     STDMETHODCALLTYPE
#endif
#define STDINITMETHODIMP        HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type) type STDMAPIINITCALLTYPE
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* Simple data types */


#if !defined(UNIX) && !defined(WIN16)
typedef WORD                WCHAR;
#endif

#ifdef UNICODE
typedef WCHAR               TCHAR;
#else
typedef char                TCHAR;
#endif

typedef WCHAR FAR *         LPWSTR;
typedef const WCHAR FAR *   LPCWSTR;
typedef TCHAR FAR *         LPTSTR;
typedef const TCHAR FAR *   LPCTSTR;
typedef BYTE FAR *          LPBYTE;
typedef ULONG FAR *         LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef unsigned long   LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *  This flag is used in many different MAPI calls to signify that
 *  the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY             ((ULONG) 0x00000001)

/*
 *  The following flags are used to indicate to the client what access
 *  level is permissible in the object. They appear in PR_ACCESS in
 *  message and folder objects as well as in contents and associated
 *  contents tables
 */

#define MAPI_ACCESS_MODIFY                  ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ                    ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE                  ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY        ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS         ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED       ((ULONG) 0x00000020)

/*
 *  The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *  that strings passed through the interface are in Unicode (a 16-bit
 *  character set). The default is an 8-bit character set.
 *
 *  The value fMapiUnicode can be used as the 'normal' value for
 *  that bit, given the application's default character set.
 */

#define MAPI_UNICODE            ((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode            MAPI_UNICODE
#else
#define fMapiUnicode            0
#endif

/* successful HRESULT */
#define hrSuccess               0



/* Recipient types */
#ifndef MAPI_ORIG               /* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1     0x10000000  /* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4        recipient is a CMC authorizing user      */
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM          0x80
#define MAPI_NOTRECIP           0x40
#define MAPI_THISSESSION        0x20
#define MAPI_NOW                0x10
#define MAPI_NOTRESERVED        0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND           0x80

/* ENTRYID */
typedef struct
{
    BYTE    abFlags[4];
    BYTE    ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)       (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)          (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
    struct _ENTRYID_ ## _name \
{ \
    BYTE    abFlags[4]; \
    BYTE    ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
    BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)  (!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))


/* Object type */

#define MAPI_STORE      ((ULONG) 0x00000001)    /* Message Store */
#define MAPI_ADDRBOOK   ((ULONG) 0x00000002)    /* Address Book */
#define MAPI_FOLDER     ((ULONG) 0x00000003)    /* Folder */
#define MAPI_ABCONT     ((ULONG) 0x00000004)    /* Address Book Container */
#define MAPI_MESSAGE    ((ULONG) 0x00000005)    /* Message */
#define MAPI_MAILUSER   ((ULONG) 0x00000006)    /* Individual Recipient */
#define MAPI_ATTACH     ((ULONG) 0x00000007)    /* Attachment */
#define MAPI_DISTLIST   ((ULONG) 0x00000008)    /* Distribution List Recipient */
#define MAPI_PROFSECT   ((ULONG) 0x00000009)    /* Profile Section */
#define MAPI_STATUS     ((ULONG) 0x0000000A)    /* Status Object */
#define MAPI_SESSION    ((ULONG) 0x0000000B)    /* Session */
#define MAPI_FORMINFO   ((ULONG) 0x0000000C)    /* Form Information */


/*
 *  Maximum length of profile names and passwords, not including
 *  the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax   64
#define cchProfilePassMax   64
#endif


/* Property Types */

#define MV_FLAG         0x1000          /* Multi-value flag */

#define PT_UNSPECIFIED  ((ULONG)  0)    /* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_R4           ((ULONG)  4)    /* 4-byte floating point */
#define PT_DOUBLE       ((ULONG)  5)    /* Floating point double */
#define PT_CURRENCY     ((ULONG)  6)    /* Signed 64-bit int (decimal w/    4 digits right of decimal pt) */
#define PT_APPTIME      ((ULONG)  7)    /* Application time */
#define PT_ERROR        ((ULONG) 10)    /* 32-bit error value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_OBJECT       ((ULONG) 13)    /* Embedded object in a property */
#define PT_I8           ((ULONG) 20)    /* 8-byte signed integer */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_SYSTIME      ((ULONG) 64)    /* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

/*
 *  The type of a MAPI-defined string property is indirected, so
 *  that it defaults to Unicode string on a Unicode platform and to
 *  String8 on an ANSI or DBCS platform.
 *
 *  Macros are defined here both for the property type, and for the
 *  field of the property value structure which should be
 *  dereferenced to obtain the string pointer.
 */

#ifdef  UNICODE
#define PT_TSTRING          PT_UNICODE
#define PT_MV_TSTRING       (MV_FLAG|PT_UNICODE)
#define LPSZ                lpszW
#define LPPSZ               lppszW
#define MVSZ                MVszW
#else
#define PT_TSTRING          PT_STRING8
#define PT_MV_TSTRING       (MV_FLAG|PT_STRING8)
#define LPSZ                lpszA
#define LPPSZ               lppszA
#define MVSZ                MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROP_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL            0
#define PROP_ID_INVALID         0xFFFF
#define PR_NULL                 PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define PT_MV_I2        (MV_FLAG|PT_I2)
#define PT_MV_LONG      (MV_FLAG|PT_LONG)
#define PT_MV_R4        (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE    (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY  (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME   (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME   (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8   (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY    (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE   (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID     (MV_FLAG|PT_CLSID)
#define PT_MV_I8        (MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define PT_MV_SHORT     PT_MV_I2
#define PT_MV_I4        PT_MV_LONG
#define PT_MV_FLOAT     PT_MV_R4
#define PT_MV_R8        PT_MV_DOUBLE
#define PT_MV_LONGLONG  PT_MV_I8

/*
 *  Property type reserved bits
 *
 *  MV_INSTANCE is used as a flag in table operations to request
 *  that a multi-valued property be presented as a single-valued
 *  property appearing in multiple rows.
 */

#define MV_INSTANCE     0x2000
#define MVI_FLAG        (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)   ((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
    ULONG   cValues;
    ULONG   aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
    (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
    (offsetof(SPropTagArray,aulPropTag) + \
    (UINT)((_lparray)->cValues)*sizeof(ULONG))
/*  SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue  SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
            /* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
    ULONG       cb;
    LPBYTE      lpb;
} SBinary, FAR *LPSBinary;

typedef struct _SShortArray
{
    ULONG       cValues;
    short int   FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
    ULONG       cValues;
    GUID        FAR *lpguid;
} SGuidArray;

typedef struct _SRealArray
{
    ULONG       cValues;
    float       FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
    ULONG       cValues;
    LONG        FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
    ULONG       cValues;
    LARGE_INTEGER   FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
    ULONG       cValues;
    FILETIME    FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
    ULONG       cValues;
    double      FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
    ULONG       cValues;
    CURRENCY    FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
    ULONG       cValues;
    SBinary     FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
    ULONG       cValues;
    double      FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
    ULONG       cValues;
    LPWSTR      FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
    ULONG       cValues;
    LPSTR       FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG               ul;         /* alias for PT_LONG */
    float               flt;        /* case PT_R4 */
    double              dbl;        /* case PT_DOUBLE */
    unsigned short int  b;          /* case PT_BOOLEAN */
    CURRENCY            cur;        /* case PT_CURRENCY */
    double              at;         /* case PT_APPTIME */
    FILETIME            ft;         /* case PT_SYSTIME */
    LPSTR               lpszA;      /* case PT_STRING8 */
    SBinary             bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    LPGUID              lpguid;     /* case PT_CLSID */
    LARGE_INTEGER       li;         /* case PT_I8 */
    SShortArray         MVi;        /* case PT_MV_I2 */
    SLongArray          MVl;        /* case PT_MV_LONG */
    SRealArray          MVflt;      /* case PT_MV_R4 */
    SDoubleArray        MVdbl;      /* case PT_MV_DOUBLE */
    SCurrencyArray      MVcur;      /* case PT_MV_CURRENCY */
    SAppTimeArray       MVat;       /* case PT_MV_APPTIME */
    SDateTimeArray      MVft;       /* case PT_MV_SYSTIME */
    SBinaryArray        MVbin;      /* case PT_MV_BINARY */
    SLPSTRArray         MVszA;      /* case PT_MV_STRING8 */
    SWStringArray       MVszW;      /* case PT_MV_UNICODE */
    SGuidArray          MVguid;     /* case PT_MV_CLSID */
    SLargeIntegerArray  MVli;       /* case PT_MV_I8 */
    SCODE               err;        /* case PT_ERROR */
    LONG                x;          /* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
    ULONG       ulPropTag;
    ULONG       dwAlignPad;
    union _PV   Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
    ULONG   ulIndex;
    ULONG   ulPropTag;
    SCODE   scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
    ULONG           cProblem;
    SPropProblem    aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
    (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
    (offsetof(SPropProblemArray,aProblem) + \
    (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
    ULONG           cProblem; \
    SPropProblem    aProblem[_cprob]; \
} _name

/*
 *  ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *  FLATENTRYLIST
 *  MTSID
 *  FLATMTSIDLIST
 */

typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
    ULONG       cEntries;
    ULONG       cbEntries;
    BYTE        abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
    ULONG       cb;
    BYTE        ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
    ULONG       cMTSIDs;
    ULONG       cbMTSIDs;
    BYTE        abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)     (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)   (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)         (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)       (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
    ULONG           ulReserved1;    /* Never used */
    ULONG           cValues;
    LPSPropValue    rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
    ULONG           cEntries;
    ADRENTRY        aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
    (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
    (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
    ULONG           cEntries; \
    ADRENTRY        aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
    ULONG           ulAdrEntryPad;  /* Pad so SRow's can map to ADRENTRY's */
    ULONG           cValues;        /* Count of property values */
    LPSPropValue    lpProps;        /* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
    ULONG           cRows;          /* Count of rows */
    SRow            aRow[MAPI_DIM]; /* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)     (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)    (offsetof(SRowSet,aRow) + \
                                    (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
    ULONG           cRows; \
    SRow            aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID FAR *    lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
    LPVOID          lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *  LPALLOCATEMORE;
typedef FREEBUFFER FAR *    LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface;            \
        struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)              MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
        STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
        typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)                                    \
    MAPIMETHOD(QueryInterface)                                          \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;                 \
    MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;                            \
    MAPIMETHOD_(ULONG,Release) (THIS) IPURE;                            \

#undef  IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,       LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,     LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,        LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,         LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,       LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,    LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,       LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,       LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,     LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,      LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,       LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,       LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,  LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,   LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,  LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
    ULONG   ulVersion;
    LPTSTR  lpszError;
    LPTSTR  lpszComponent;
    ULONG   ulLowLevelError;
    ULONG   ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *  Notification event types. The event types can be combined in a bitmask
 *  for filtering. Each one has a parameter structure associated with it:
 *
 *      fnevCriticalError       ERROR_NOTIFICATION
 *      fnevNewMail             NEWMAIL_NOTIFICATION
 *      fnevObjectCreated       OBJECT_NOTIFICATION
 *      fnevObjectDeleted       OBJECT_NOTIFICATION
 *      fnevObjectModified      OBJECT_NOTIFICATION
 *      fnevObjectCopied        OBJECT_NOTIFICATION
 *      fnevSearchComplete      OBJECT_NOTIFICATION
 *      fnevTableModified       TABLE_NOTIFICATION
 *      fnevStatusObjectModified OBJECT_NOTIFICATION
 *
 *      fnevExtended            EXTENDED_NOTIFICATION
 */

#define fnevCriticalError           ((ULONG) 0x00000001)
#define fnevNewMail                 ((ULONG) 0x00000002)
#define fnevObjectCreated           ((ULONG) 0x00000004)
#define fnevObjectDeleted           ((ULONG) 0x00000008)
#define fnevObjectModified          ((ULONG) 0x00000010)
#define fnevObjectMoved             ((ULONG) 0x00000020)
#define fnevObjectCopied            ((ULONG) 0x00000040)
#define fnevSearchComplete          ((ULONG) 0x00000080)
#define fnevTableModified           ((ULONG) 0x00000100)
#define fnevStatusObjectModified    ((ULONG) 0x00000200)
#define fnevReservedForMapi         ((ULONG) 0x40000000)
#define fnevExtended                ((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED       1
#define TABLE_ERROR         2
#define TABLE_ROW_ADDED     3
#define TABLE_ROW_DELETED   4
#define TABLE_ROW_MODIFIED  5
#define TABLE_SORT_DONE     6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE   8
#define TABLE_RELOAD        9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;
    SCODE       scode;
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPMAPIERROR lpMAPIError;        /* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;          /* identifies the new message */
    ULONG       cbParentID;
    LPENTRYID   lpParentID;         /* identifies the folder it lives in */
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPTSTR      lpszMessageClass;   /* message class (UNICODE or string8) */
    ULONG       ulMessageFlags;     /* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
    ULONG               cbEntryID;
    LPENTRYID           lpEntryID;      /* EntryID of object */
    ULONG               ulObjType;      /* Type of object */
    ULONG               cbParentID;
    LPENTRYID           lpParentID;     /* EntryID of parent object */
    ULONG               cbOldID;
    LPENTRYID           lpOldID;        /* EntryID of old object */
    ULONG               cbOldParentID;
    LPENTRYID           lpOldParentID;  /* EntryID of old parent */
    LPSPropTagArray     lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
    ULONG               ulTableEvent;   /* Identifies WHICH table event */
    HRESULT             hResult;        /* Value for TABLE_ERROR */
    SPropValue          propIndex;      /* This row's "index property" */
    SPropValue          propPrior;      /* Preceding row's "index property" */
    SRow                row;            /* New data of added/modified row */
    ULONG               ulPad;          /* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
    ULONG       ulEvent;                    /* extended event code */
    ULONG       cb;                         /* size of event parameters */
    LPBYTE      pbEventParameters;          /* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
    ULONG           cbEntryID;
    LPENTRYID       lpEntryID;
    ULONG           cValues;
    LPSPropValue    lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
    ULONG   ulEventType;        /* notification type, i.e. fnevSomething */
    ULONG   ulAlignPad;         /* Force to 8-byte boundary */
    union
    {
        ERROR_NOTIFICATION          err;
        NEWMAIL_NOTIFICATION        newmail;
        OBJECT_NOTIFICATION         obj;
        TABLE_NOTIFICATION          tab;
        EXTENDED_NOTIFICATION       ext;
        STATUS_OBJECT_NOTIFICATION  statobj;
    } info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)                             \
    MAPIMETHOD_(ULONG, OnNotify)                                        \
        (THIS_  ULONG                       cNotif,                     \
                LPNOTIFICATION              lpNotifications) IPURE;     \

#undef       INTERFACE
#define      INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
    LPVOID          lpvContext,
    ULONG           cNotification,
    LPNOTIFICATION  lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *  Message name for the 16-bit MAPI notififcation engine.
 *  This can be used in 16-bit applications to force processing
 *  of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL      ((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)                               \
    MAPIMETHOD(Progress)                                                \
        (THIS_  ULONG                       ulValue,                    \
                ULONG                       ulCount,                    \
                ULONG                       ulTotal) IPURE;             \
    MAPIMETHOD(GetFlags)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(GetMax)                                                  \
        (THIS_  ULONG FAR *                 lpulMax) IPURE;             \
    MAPIMETHOD(GetMin)                                                  \
        (THIS_  ULONG FAR *                 lpulMin) IPURE;             \
    MAPIMETHOD(SetLimits)                                               \
        (THIS_  LPULONG                     lpulMin,                    \
                LPULONG                     lpulMax,                    \
                LPULONG                     lpulFlags) IPURE;           \

#undef      INTERFACE
#define     INTERFACE   IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION      0x00000000L

/* GetPropList */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY      ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE     ((ULONG) 0x00000002)
#define FORCE_SAVE              ((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_CREATE             ((ULONG) 0x00000002)
#define STREAM_APPEND           ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE               ((ULONG) 0x00000001)
#define MAPI_NOREPLACE          ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK         ((ULONG) 0x00000004)

#ifndef MAPI_DIALOG             /* also defined in mapi.h */
#define MAPI_DIALOG             ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT        /* also defined in mapi.h */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/****** MAPI_CREATE             ((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS         ((ULONG) 0x00000001)
#define MAPI_NO_IDS             ((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID                 0
#define MNID_STRING             1
typedef struct _MAPINAMEID
{
    LPGUID lpguid;
    ULONG ulKind;
    union {
        LONG lID;
        LPWSTR lpwstrName;
    } Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)                                   \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(SaveChanges)                                             \
        (THIS_ ULONG                        ulFlags) IPURE;             \
    MAPIMETHOD(GetProps)                                                \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppPropArray) IPURE;        \
    MAPIMETHOD(GetPropList)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTagArray) IPURE;     \
    MAPIMETHOD(OpenProperty)                                            \
        (THIS_  ULONG                       ulPropTag,                  \
                LPCIID                      lpiid,                      \
                ULONG                       ulInterfaceOptions,         \
                ULONG                       ulFlags,                    \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetProps)                                                \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpPropArray,                \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DeleteProps)                                             \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyTo)                                                  \
        (THIS_  ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyProps)                                               \
        (THIS_  LPSPropTagArray             lpIncludeProps,             \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(GetNamesFromIDs)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTags,                \
                LPGUID                      lpPropSetGuid,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcPropNames,               \
                LPMAPINAMEID FAR * FAR *    lpppPropNames) IPURE;       \
    MAPIMETHOD(GetIDsFromNames)                                         \
        (THIS_  ULONG                       cPropNames,                 \
                LPMAPINAMEID FAR *          lppPropNames,               \
                ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTags) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE            ((ULONG) 0)
#define TBLSTAT_QCHANGED            ((ULONG) 7)
#define TBLSTAT_SORTING             ((ULONG) 9)
#define TBLSTAT_SORT_ERROR          ((ULONG) 10)
#define TBLSTAT_SETTING_COLS        ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR        ((ULONG) 13)
#define TBLSTAT_RESTRICTING         ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR      ((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT            ((ULONG) 0)
#define TBLTYPE_KEYSET              ((ULONG) 1)
#define TBLTYPE_DYNAMIC             ((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND       ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND      ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE      ((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
    ULONG   ulPropTag;          /* Column to sort on */
    ULONG   ulOrder;            /* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
    ULONG           cSorts;     /* Number of sort columns in aSort below*/
    ULONG           cCategories;    /* 0 for non-categorized, up to cSorts */
    ULONG           cExpanded;      /* 0 if no categories start expanded, */
                                    /*      up to cExpanded */
    SSortOrder      aSort[MAPI_DIM];    /* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
    (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
    (offsetof(SSortOrderSet,aSort) + \
    (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
    ULONG           cSorts;         \
    ULONG           cCategories;    \
    ULONG           cExpanded;      \
    SSortOrder      aSort[_csort];  \
} _name

typedef ULONG       BOOKMARK;

#define BOOKMARK_BEGINNING  ((BOOKMARK) 0)      /* Before first row */
#define BOOKMARK_CURRENT    ((BOOKMARK) 1)      /* Before current row */
#define BOOKMARK_END        ((BOOKMARK) 2)      /* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING       ((ULONG) 0x00000000)
#define FL_SUBSTRING        ((ULONG) 0x00000001)
#define FL_PREFIX           ((ULONG) 0x00000002)

#define FL_IGNORECASE       ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE   ((ULONG) 0x00020000)
#define FL_LOOSE            ((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction    FAR * LPSRestriction;

/* Restriction types */

#define RES_AND             ((ULONG) 0x00000000)
#define RES_OR              ((ULONG) 0x00000001)
#define RES_NOT             ((ULONG) 0x00000002)
#define RES_CONTENT         ((ULONG) 0x00000003)
#define RES_PROPERTY        ((ULONG) 0x00000004)
#define RES_COMPAREPROPS    ((ULONG) 0x00000005)
#define RES_BITMASK         ((ULONG) 0x00000006)
#define RES_SIZE            ((ULONG) 0x00000007)
#define RES_EXIST           ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION  ((ULONG) 0x00000009)
#define RES_COMMENT         ((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT        ((ULONG) 0)     /* <  */
#define RELOP_LE        ((ULONG) 1)     /* <= */
#define RELOP_GT        ((ULONG) 2)     /* >  */
#define RELOP_GE        ((ULONG) 3)     /* >= */
#define RELOP_EQ        ((ULONG) 4)     /* == */
#define RELOP_NE        ((ULONG) 5)     /* != */
#define RELOP_RE        ((ULONG) 6)     /* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ     ((ULONG) 0)     /* ==0 */
#define BMR_NEZ     ((ULONG) 1)     /* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
    ULONG           ulReserved;
    LPSRestriction  lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
    ULONG           ulFuzzyLevel;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
    ULONG           relBMR;
    ULONG           ulPropTag;
    ULONG           ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
    ULONG           relop;
    ULONG           ulPropTag1;
    ULONG           ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    ULONG           cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
    ULONG           ulReserved1;
    ULONG           ulPropTag;
    ULONG           ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
    ULONG           ulSubObject;
    LPSRestriction  lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
    ULONG           cValues; /* # of properties in lpProp */
    LPSRestriction  lpRes;
    LPSPropValue    lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
    ULONG   rt;         /* Restriction type */
    union
    {
        SComparePropsRestriction    resCompareProps;    /* first */
        SAndRestriction             resAnd;
        SOrRestriction              resOr;
        SNotRestriction             resNot;
        SContentRestriction         resContent;
        SPropertyRestriction        resProperty;
        SBitMaskRestriction         resBitMask;
        SSizeRestriction            resSize;
        SExistRestriction           resExist;
        SSubRestriction             resSub;
        SCommentRestriction         resComment;
    } res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS     ((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW            ((ULONG) 1)
#define TBL_EMPTY_CATEGORY      ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY   ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY  ((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT          ((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC           ((ULONG) 0x00000001)
#define TBL_BATCH           ((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD        ((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE       ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(GetStatus)                                               \
        (THIS_  ULONG FAR *                 lpulTableStatus,            \
                ULONG FAR *                 lpulTableType) IPURE;       \
    MAPIMETHOD(SetColumns)                                              \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QueryColumns)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lpPropTagArray) IPURE;      \
    MAPIMETHOD(GetRowCount)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulCount) IPURE;           \
    MAPIMETHOD(SeekRow)                                                 \
        (THIS_  BOOKMARK                    bkOrigin,                   \
                LONG                        lRowCount,                  \
                LONG FAR *                  lplRowsSought) IPURE;       \
    MAPIMETHOD(SeekRowApprox)                                           \
        (THIS_  ULONG                       ulNumerator,                \
                ULONG                       ulDenominator) IPURE;       \
    MAPIMETHOD(QueryPosition)                                           \
        (THIS_  ULONG FAR *                 lpulRow,                    \
                ULONG FAR *                 lpulNumerator,              \
                ULONG FAR *                 lpulDenominator) IPURE;     \
    MAPIMETHOD(FindRow)                                                 \
        (THIS_  LPSRestriction              lpRestriction,              \
                BOOKMARK                    bkOrigin,                   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(Restrict)                                                \
        (THIS_  LPSRestriction              lpRestriction,              \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateBookmark)                                          \
        (THIS_  BOOKMARK FAR *              lpbkPosition) IPURE;        \
    MAPIMETHOD(FreeBookmark)                                            \
        (THIS_  BOOKMARK                    bkPosition) IPURE;          \
    MAPIMETHOD(SortTable)                                               \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QuerySortOrder)                                          \
        (THIS_  LPSSortOrderSet FAR *       lppSortCriteria) IPURE;     \
    MAPIMETHOD(QueryRows)                                               \
        (THIS_  LONG                        lRowCount,                  \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows) IPURE;             \
    MAPIMETHOD(Abort) (THIS) IPURE;                                     \
    MAPIMETHOD(ExpandRow)                                               \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulRowCount,                 \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows,                    \
                ULONG FAR *                 lpulMoreRows) IPURE;        \
    MAPIMETHOD(CollapseRow)                                             \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulRowCount) IPURE;        \
    MAPIMETHOD(WaitForCompletion)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulTimeout,                  \
                ULONG FAR *                 lpulTableStatus) IPURE;     \
    MAPIMETHOD(GetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbInstanceKey,              \
                LPBYTE                      lpbInstanceKey,             \
                ULONG FAR *                 lpcbCollapseState,          \
                LPBYTE FAR *                lppbCollapseState) IPURE;   \
    MAPIMETHOD(SetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbCollapseState,            \
                LPBYTE                      pbCollapseState,            \
                BOOKMARK FAR *              lpbkLocation) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{   0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
    0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER     ((ULONG) 33)    /* Message Store */
#define MAPI_AB                 ((ULONG) 34)    /* Address Book */
#define MAPI_AB_PROVIDER        ((ULONG) 35)    /* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)    /* Transport Provider */
#define MAPI_SPOOLER            ((ULONG) 37)    /* Message Spooler */
#define MAPI_PROFILE_PROVIDER   ((ULONG) 38)    /* Profile Provider */
#define MAPI_SUBSYSTEM          ((ULONG) 39)    /* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER      ((ULONG) 40)    /* Spooler Hook */

#define STATUS_VALIDATE_STATE   ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG  ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD  ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES     ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE    ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE     ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST   ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION     ((ULONG) 0x00000080)
#define STATUS_OWN_STORE        ((ULONG) 0x00000100)
/****** HOOK_INBOUND            ((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND           ((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE    ((ULONG) 0x00000800)
#define STATUS_PRIMARY_STORE    ((ULONG) 0x00001000)
#define STATUS_SECONDARY_STORE  ((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define STATUS_AVAILABLE        ((ULONG) 0x00000001)
#define STATUS_OFFLINE          ((ULONG) 0x00000002)
#define STATUS_FAILURE          ((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED  ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE   ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE  ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH   ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS    ((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI                 ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE     ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE     ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT            ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT         ((ULONG) 0x00080000)
#define CONFIG_CHANGED              ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION   ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI          ((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY     ((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD        ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD      ((ULONG) 0x00000004)
#define FLUSH_FORCE         ((ULONG) 0x00000008)
#define FLUSH_NO_UI         ((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK      ((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)                                 \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SettingsDialog)                                          \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangePassword)                                          \
        (THIS_  LPTSTR                      lpOldPass,                  \
                LPTSTR                      lpNewPass,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS        ((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */
#define WAB_LOCAL_CONTAINERS    0x00100000
#define WAB_PROFILE_CONTENTS    0x00200000

/* GetHierarchyTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH        ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define SEARCH_RUNNING          ((ULONG) 0x00000001)
#define SEARCH_REBUILD          ((ULONG) 0x00000002)
#define SEARCH_RECURSIVE        ((ULONG) 0x00000004)
#define SEARCH_FOREGROUND       ((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH             ((ULONG) 0x00000001)
#define RESTART_SEARCH          ((ULONG) 0x00000002)
#define RECURSIVE_SEARCH        ((ULONG) 0x00000004)
#define SHALLOW_SEARCH          ((ULONG) 0x00000008)
#define FOREGROUND_SEARCH       ((ULONG) 0x00000010)
#define BACKGROUND_SEARCH       ((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)                              \
    MAPIMETHOD(GetContentsTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(GetHierarchyTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetSearchCriteria)                                       \
        (THIS_  LPSRestriction              lpRestriction,              \
                LPENTRYLIST                 lpContainerList,            \
                ULONG                       ulSearchFlags) IPURE;       \
    MAPIMETHOD(GetSearchCriteria)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRestriction FAR *        lppRestriction,             \
                LPENTRYLIST FAR *           lppContainerList,           \
                ULONG FAR *                 lpulSearchState)IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *  IABContainer PR_CONTAINER_FLAGS values
 *  If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *  doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *  If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
    ULONG cFlags;
    ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS           ((ULONG) 0x00000001)
#define AB_SUBCONTAINERS        ((ULONG) 0x00000002)
#define AB_MODIFIABLE           ((ULONG) 0x00000004)
#define AB_UNMODIFIABLE         ((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN         ((ULONG) 0x00000010)
#define AB_NOT_DEFAULT          ((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT ((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE  ((ULONG) 0x00000002)
#define CREATE_REPLACE          ((ULONG) 0x00000004)
#define CREATE_MERGE            ((ULONG) 0x00000008)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define WAB_IGNORE_PROFILES     0x00800000

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED         ((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS          ((ULONG) 0x00000001)
#define MAPI_RESOLVED           ((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)                                \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAddrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
    passing in the following flag in the ulFlags parameter.  Setting this flag
    indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO      ((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)    ((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC                     MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED              MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS                 MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED                     MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED                     MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE             MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED              MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED                  MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG                  MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT            MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT             MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED           MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID                MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR           MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD         MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD         MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED          MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS               MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT            MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED         MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB            MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG                     MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG                     MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST             MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST           MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST         MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES              MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED           MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED         MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED              MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED             MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED                  MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED             MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT            MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD         MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE           MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN            MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED           MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED         MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED                      MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED                    MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED              MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING         MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED           MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN          MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED          MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB            MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR            MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE            MAPI_DIAG( 47 )


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)                                   \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT             ((ULONG) 0x00000000)
#define FOLDER_GENERIC          ((ULONG) 0x00000001)
#define FOLDER_SEARCH           ((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE            ((ULONG) 0x00000001)
#define MESSAGE_DIALOG          ((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS          ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES            ((ULONG) 0x00000001)
#define FOLDER_DIALOG           ((ULONG) 0x00000002)
#define DEL_FOLDERS             ((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED          ((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE             ((ULONG) 0x00000001)
/****** FOLDER_DIALOG           ((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS         ((ULONG) 0x00000010)
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT        ((ULONG) 0x00000001) below */
/****** MESSAGE_DIALOG          ((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG         ((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010)


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED        ((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED     ((ULONG) 0x00000008)

/* Bits for remote message status */

#define MSGSTATUS_REMOTE_DOWNLOAD   ((ULONG) 0x00001000)
#define MSGSTATUS_REMOTE_DELETE     ((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT          ((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED        ((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED     ((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)                                 \
    MAPIMETHOD(CreateMessage)                                           \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMESSAGE FAR *             lppMessage) IPURE;          \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMessages)                                          \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateFolder)                                            \
        (THIS_  ULONG                       ulFolderType,               \
                LPTSTR                      lpszFolderName,             \
                LPTSTR                      lpszFolderComment,          \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMAPIFOLDER FAR *          lppFolder) IPURE;           \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lpszNewFolderName,          \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteFolder)                                            \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlags)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulMessageStatus) IPURE;   \
    MAPIMETHOD(SetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulNewStatus,                \
                ULONG                       ulNewStatusMask,            \
                ULONG FAR *                 lpulOldStatus) IPURE;       \
    MAPIMETHOD(SaveContentsSort)                                        \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(EmptyFolder)                                             \
        (THIS_  ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE    ((ULONG) 0x00000001)
#define STORE_READONLY          ((ULONG) 0x00000002)
#define STORE_SEARCH_OK         ((ULONG) 0x00000004)
#define STORE_MODIFY_OK         ((ULONG) 0x00000008)
#define STORE_CREATE_OK         ((ULONG) 0x00000010)
#define STORE_ATTACH_OK         ((ULONG) 0x00000020)
#define STORE_OLE_OK            ((ULONG) 0x00000040)
#define STORE_SUBMIT_OK         ((ULONG) 0x00000080)
#define STORE_NOTIFY_OK         ((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK       ((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK     ((ULONG) 0x00000400)
#define STORE_RTF_OK            ((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK    ((ULONG) 0x00001000)
#define STORE_SORT_OK           ((ULONG) 0x00002000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES      ((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define LOGOFF_NO_WAIT          ((ULONG) 0x00000001)
#define LOGOFF_ORDERLY          ((ULONG) 0x00000002)
#define LOGOFF_PURGE            ((ULONG) 0x00000004)
#define LOGOFF_ABORT            ((ULONG) 0x00000008)
#define LOGOFF_QUIET            ((ULONG) 0x00000010)

#define LOGOFF_COMPLETE         ((ULONG) 0x00010000)
#define LOGOFF_INBOUND          ((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND         ((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE   ((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED              ((ULONG) 0x00000001)
#define MSG_UNLOCKED            ((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define FOLDER_IPM_SUBTREE_VALID        ((ULONG) 0x00000001)
#define FOLDER_IPM_INBOX_VALID          ((ULONG) 0x00000002)
#define FOLDER_IPM_OUTBOX_VALID         ((ULONG) 0x00000004)
#define FOLDER_IPM_WASTEBASKET_VALID    ((ULONG) 0x00000008)
#define FOLDER_IPM_SENTMAIL_VALID       ((ULONG) 0x00000010)
#define FOLDER_VIEWS_VALID              ((ULONG) 0x00000020)
#define FOLDER_COMMON_VIEWS_VALID       ((ULONG) 0x00000040)
#define FOLDER_FINDER_VALID             ((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)                                   \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID,                 \
                LPTSTR FAR *                lppszExplicitClass) IPURE;  \
    MAPIMETHOD(GetReceiveFolderTable)                                   \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(StoreLogoff)                                             \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(AbortSubmit)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetOutgoingQueue)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(SetLockState)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG                       ulLockState) IPURE;         \
    MAPIMETHOD(FinishedMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(NotifyNewMail)                                           \
        (THIS_  LPNOTIFICATION              lpNotification) IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT                ((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ            ((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED      ((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT          ((ULONG) 0x00000004)
#define MSGFLAG_UNSENT          ((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH       ((ULONG) 0x00000010)
#define MSGFLAG_FROMME          ((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED      ((ULONG) 0x00000040)
#define MSGFLAG_RESEND          ((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING		((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING		((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED       ((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS   ((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD            ((ULONG) 0x00000002)
#define MODRECIP_MODIFY         ((ULONG) 0x00000004)
#define MODRECIP_REMOVE         ((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT        ((ULONG) 0x00000001)
#define CLEAR_READ_FLAG         ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010) above */
#define GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010)
#define CLEAR_RN_PENDING		((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING		((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG           ((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED         ((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED      ((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT             ((long)  1)
#define PRIO_NORMAL             ((long)  0)
#define PRIO_NONURGENT          ((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE                    ((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL                ((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE                 ((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL    ((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW          ((long) 0)
#define IMPORTANCE_NORMAL       ((long) 1)
#define IMPORTANCE_HIGH         ((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)                                    \
    MAPIMETHOD(GetAttachmentTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenAttach)                                              \
        (THIS_  ULONG                       ulAttachmentNum,            \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(CreateAttach)                                            \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulAttachmentNum,          \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(DeleteAttach)                                            \
        (THIS_  ULONG                       ulAttachmentNum,            \
                ULONG                       ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetRecipientTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(ModifyRecipients)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPADRLIST                   lpMods) IPURE;              \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlag)                                             \
        (THIS_  ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT           ((ULONG) 0x00000000)
#define ATTACH_BY_VALUE         ((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE     ((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE   ((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY      ((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG     ((ULONG) 0x00000005)
#define ATTACH_OLE              ((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX        ((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL            ((ULONG) 0x00000001)
#define DIALOG_SDI              ((ULONG) 0x00000002)
#define DIALOG_OPTIONS          ((ULONG) 0x00000004)
#define ADDRESS_ONE             ((ULONG) 0x00000008)
#define AB_SELECTONLY           ((ULONG) 0x00000010)
#define AB_RESOLVE              ((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER         ((ULONG) 0x00000000)
#define DT_DISTLIST         ((ULONG) 0x00000001)
#define DT_FORUM            ((ULONG) 0x00000002)
#define DT_AGENT            ((ULONG) 0x00000003)
#define DT_ORGANIZATION     ((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST ((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER  ((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE       ((ULONG) 0x00010000)
#define DT_GLOBAL           ((ULONG) 0x00020000)
#define DT_LOCAL            ((ULONG) 0x00030000)
#define DT_WAN              ((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC     ((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER           ((ULONG) 0x01000000)
#define DT_FOLDER_LINK      ((ULONG) 0x02000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
                                                LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
                                                LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
    ULONG               ulUIParam,
    LPVOID              lpvContext,
    ULONG               cbEntryID,
    LPENTRYID           lpSelection,
    ULONG               ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
    ULONG           cbABContEntryID;
    LPENTRYID       lpABContEntryID;
    ULONG           ulFlags;

    LPVOID          lpReserved;
    ULONG           ulHelpContext;
    LPTSTR          lpszHelpFileName;

    LPFNABSDI       lpfnABSDI;
    LPFNDISMISS     lpfnDismiss;
    LPVOID          lpvDismissContext;
    LPTSTR          lpszCaption;
    LPTSTR          lpszNewEntryTitle;
    LPTSTR          lpszDestWellsTitle;
    ULONG           cDestFields;
    ULONG           nDestFieldFocus;
    LPTSTR FAR *    lppszDestTitles;
    ULONG FAR *     lpulDestComps;
    LPSRestriction  lpContRestriction;
    LPSRestriction  lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag set in MAPI one off entryids */
#define MAPI_ONE_OFF_NO_RICH_INFO	0x0001

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED         ((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG           ((ULONG) 0x00000001)
#define MDB_WRITE               ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */
#define MDB_TEMPORARY           ((ULONG) 0x00000020)
#define MDB_NO_MAIL             ((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG            ((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED       ((ULONG) 0x00000000)
#define  MAPI_DISABLED      ((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Activate)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulUIParam) IPURE;           \
    MAPIMETHOD(GetState)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulState) IPURE;           \

#undef       INTERFACE
#define      INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE        ((ULONG) 0x00000001)
#define DT_EDITABLE         ((ULONG) 0x00000002)
#define DT_REQUIRED         ((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE    ((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT    ((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS      ((ULONG) 0x00000020)
#define DT_SET_SELECTION    ((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL          ((ULONG) 0x00000000)
#define DTCT_EDIT           ((ULONG) 0x00000001)
#define DTCT_LBX            ((ULONG) 0x00000002)
#define DTCT_COMBOBOX       ((ULONG) 0x00000003)
#define DTCT_DDLBX          ((ULONG) 0x00000004)
#define DTCT_CHECKBOX       ((ULONG) 0x00000005)
#define DTCT_GROUPBOX       ((ULONG) 0x00000006)
#define DTCT_BUTTON         ((ULONG) 0x00000007)
#define DTCT_PAGE           ((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON    ((ULONG) 0x00000009)
#define DTCT_MVLISTBOX      ((ULONG) 0x0000000B)
#define DTCT_MVDDLBX        ((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
    ULONG ulbLpszLabelName;
    ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
    DTBLLABEL   dtbllabel; \
    TCHAR       lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
    DTBLEDIT    dtbledit; \
    TCHAR       lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR        ((ULONG) 0x00000001)
#define MAPI_NO_VBAR        ((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
    ULONG ulFlags;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPRPropertyName;
    ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
    DTBLCOMBOBOX    dtblcombobox; \
    TCHAR           lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
    ULONG ulFlags;
    ULONG ulPRDisplayProperty;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
    DTBLCHECKBOX    dtblcheckbox; \
    TCHAR       lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
    DTBLGROUPBOX    dtblgroupbox; \
    TCHAR           lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
    DTBLBUTTON  dtblbutton; \
    TCHAR       lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulbLpszComponent;
    ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
    DTBLPAGE    dtblpage; \
    TCHAR       lpszLabel[n]; \
    TCHAR       lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulcButtons;
    ULONG ulPropTag;
    long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
    DTBLRADIOBUTTON dtblradiobutton; \
    TCHAR           lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE                  0x00000002
#define SERVICE_UI_ALWAYS           0x00000002      /* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED          0x00000010
#define UI_CURRENT_PROVIDER_FIRST   0x00000004
/* MSG_SERVICE_UI_READ_ONLY         0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)                              \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProvider)                                          \
        (THIS_  LPTSTR                      lpszProvider,               \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps,                    \
                ULONG                       ulUIParam,                  \
                ULONG                       ulFlags,                    \
                MAPIUID FAR *               lpUID) IPURE;               \
    MAPIMETHOD(DeleteProvider)                                          \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \


#undef       INTERFACE
#define      INTERFACE  IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROVIDERADMIN_METHODS(PURE)
};

#ifndef WIN16

typedef HANDLE  HANDLE_16;
typedef WPARAM  WPARAM_16;

#define EXTERN_C_16
#define WINAPI_16
#define CALLBACK_16
#define EXPORT_16
#define LOADDS_16
#define HUGEP_16
#define APIENTRY_16    APIENTRY

#else   // ndef WIN16

typedef LPVOID HANDLE_16;
typedef DWORD  WPARAM_16;

#define EXTERN_C_16    EXTERN_C
#define WINAPI_16      WINAPI
#define CALLBACK_16    CALLBACK
#define EXPORT_16      __export
#define LOADDS_16      __loadds
#define HUGEP_16       HUGEP
#define APIENTRY_16    CALLBACK

#endif  // ndef WIN16

#ifndef WIN16

#define IF_WIN16(x)
#define IF_NOT_WIN16(x)     x
#define IF_WIN32(x)         x

#else   // ndef WIN16

#define IF_WIN16(x)         x
#define IF_NOT_WIN16(x) 
#define IF_WIN32(x)

#endif  // ndef WIN16

#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* WABDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabapi.h ===
#ifndef _WABAPI_H_
#define _WABAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif // GetLastError
#endif // WIN16

typedef struct _WABACTIONITEM * LPWABACTIONITEM;

/* IWABObject Interface ---------------------------------------------------- */

#define CBIWABOBJECT sizeof(IWABOBJECT)


#define WAB_IWABOBJECT_METHODS(IPURE)                       \
        MAPIMETHOD(GetLastError)                            \
            (THIS_  HRESULT hResult,                        \
                    ULONG   ulFlags,                        \
                    LPMAPIERROR FAR * lppMAPIError) IPURE;  \
        MAPIMETHOD(AllocateBuffer)                          \
            (THIS_  ULONG   cbSize,                         \
                    LPVOID FAR *    lppBuffer) IPURE;       \
        MAPIMETHOD(AllocateMore)                            \
            (THIS_  ULONG   cbSize,                         \
                    LPVOID  lpObject,                       \
                    LPVOID  FAR *   lppBuffer) IPURE;       \
        MAPIMETHOD(FreeBuffer)                              \
            (THIS_  LPVOID  lpBuffer) IPURE;                \
        MAPIMETHOD(Backup)                                  \
            (THIS_  LPSTR  lpFileName) IPURE;              \
        MAPIMETHOD(Import)                                  \
            (THIS_  LPSTR lpImportParam) IPURE;           \
        MAPIMETHOD(Find)                                    \
            (THIS_  LPADRBOOK lpIAB,                        \
                    HWND    hWnd) IPURE;                    \
        MAPIMETHOD(VCardDisplay)                            \
            (THIS_  LPADRBOOK lpIAB,                        \
                    HWND    hWnd,                           \
                    LPSTR  lpszFileName) IPURE;            \
        MAPIMETHOD(LDAPUrl)                                 \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    HWND        hWnd,                       \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszURL,                    \
                    LPMAILUSER *lppMailUser) IPURE;         \
        MAPIMETHOD(VCardCreate)                             \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszVCard,                  \
                    LPMAILUSER  lpMailUser) IPURE;          \
        MAPIMETHOD(VCardRetrieve)                           \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszVCard,                  \
                    LPMAILUSER *lppMailUser) IPURE;         \
        MAPIMETHOD(GetMe)                                   \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    DWORD *     lpdwAction,                 \
                    SBinary *   lpsbEID,                    \
                    ULONG       ulParam) IPURE;          \
        MAPIMETHOD(SetMe)                                   \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    SBinary     sbEID,                      \
                    ULONG       ulParam) IPURE;          \



#undef           INTERFACE
#define          INTERFACE      IWABObject
DECLARE_MAPI_INTERFACE_(IWABObject, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABOBJECT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABObject, LPWABOBJECT);


#undef  INTERFACE
#define INTERFACE       struct _IWABOBJECT

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWABOBJECT_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABOBJECT_)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(IMPL)
   WAB_IWABOBJECT_METHODS(IMPL)
};


/*** WABObject_LDAPUrl flags ***/

// If this flag is specified and the LDAPUrl returns a single
// query result, instructs the WAB to return the result in the
// form of a MailUser object instead of displaying Details on it
// If there are multiple results to the query, fail ..
#define WABOBJECT_LDAPURL_RETURN_MAILUSER   0x00000001

// WAB 5.0x and higher:
// If your application supports Unicode and wants to pass ina Unicode
//  URL to the WAB, you can cast the Unicode URL to an LPSTR and pass it
// to the LDAPUrl API, *also* setting ulFlags to MAPI_UNICODE to mark the URL
// as such. Casting is prefered to converting the string because 
// (a) Converting the string may result in loss of data (b) since this is an
// already published interface we can't modify the interface.
//      MAPI_UNICODE                        0x80000000



/*** WABObject_GetMe returned parameter ***/
// If the GetMe call results in the creation of a new 'Me' contact,
// the lpdwAction returned parameter will contain this value
// indicating to the caller that the object is freshly created and
// does not have any properties in it
#define WABOBJECT_ME_NEW                    0x00000001



/*** WABObject_GetMe flags ***/
// WABObject_GetMe will create a new ME object by default, if 
// none already exists. To force the call to not-create an object, if
// one doesn't already exist, specify the WABOBJECT_ME_NOCREATE flag.
// If no me is found, the call fails with MAPI_E_NOT_FOUND.
// Other flag for WABObject_GetMe is AB_NO_DIALOG defined in wabdefs.h
#define WABOBJECT_ME_NOCREATE               0x00000002



/*** IWABObject_VCard Create/Retrieve ***/
// Flags the WAB whether the lpszVCard parameter is a filename or if
// it is a NULL terminated string containing the compelte VCard contents
//
#define WAB_VCARD_FILE                      0x00000000
#define WAB_VCARD_STREAM                    0x00000001





#ifdef WIN16
BOOL WINAPI WABInitThread();
#endif


//
// Input information to pass to WABOpen
//
typedef struct _tagWAB_PARAM
{
    ULONG   cbSize;         // sizeof(WAB_PARAM).
    HWND    hwnd;           // hWnd of calling client Application. Can be NULL
    LPSTR   szFileName;     // WAB File name to open. if NULL, opens default.
    ULONG   ulFlags;        // See below
    GUID    guidPSExt;      // A GUID that identifies the calling application's Property Sheet extensions
                            // The GUID can be used to determine whether the extension prop sheets are displayed or not.
} WAB_PARAM, * LPWAB_PARAM;

//flags for WAB_PARAM
#define WAB_USE_OE_SENDMAIL     0x00000001  // Tells WAB to use Outlook Express for e-mail before checking for a 
                                            // default Simple MAPI client. Default behaviour is to check for the 
                                            // Simple MAPI client first

#define WAB_ENABLE_PROFILES     0x00400000  // Invokes WAB in a Identity-aware session using Identity-Manager 
                                            // based profiles


//
// Root public entry points for WAB API
//
STDMETHODIMP WABOpen(LPADRBOOK FAR * lppAdrBook, LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP, DWORD Reserved2);

typedef HRESULT (STDMETHODCALLTYPE WABOPEN)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved2
);
typedef WABOPEN FAR * LPWABOPEN;


STDMETHODIMP WABOpenEx(LPADRBOOK FAR * lppAdrBook,
  LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP,
  DWORD Reserved,
  ALLOCATEBUFFER * fnAllocateBuffer,
  ALLOCATEMORE * fnAllocateMore,
  FREEBUFFER * fnFreeBuffer);

typedef HRESULT (STDMETHODCALLTYPE WABOPENEX)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved,
    ALLOCATEBUFFER * fnAllocateBuffer,
    ALLOCATEMORE * fnAllocateMore,
    FREEBUFFER * fnFreeBuffer
);
typedef WABOPENEX FAR * LPWABOPENEX;

/* --------------------- */
typedef struct _WABIMPORTPARAM
{
    ULONG cbSize;       // sizeof(WABIMPORTPARAM)
    LPADRBOOK lpAdrBook;// ptr to the IAdrBook object (required)
    HWND hWnd;          // Parent HWND for any dialogs
    ULONG ulFlags;      // 0 or MAPI_DIALOG to show progress dialog and messages
    LPSTR lpszFileName; // FileName to import or NULL .. if NULL will show FileOpen dialog 
} WABIMPORTPARAM, FAR * LPWABIMPORTPARAM;



/* ---- WABEXTDISPLAY ----------------- */
/* WABEXTDISPLAY Structure used in extending the WAB Details Property Dialogs 
    and for doing WAB Context Menu verb extensions.
   The structure is passed into the IWABExtInit::Initialize method
    of the implementor */

// Flags
#define WAB_DISPLAY_LDAPURL 0x00000001  // The object being displayed is an LDAP URL
                                        // The URL can be found in the lpsz struct member

#define WAB_CONTEXT_ADRLIST 0x00000002  // THe lpv parameter contains a pointer to an
                                        // AdrList structure corresponding to selected items
                                        // on which to display a context menu

#define WAB_DISPLAY_ISNTDS  0x00000004  // Identifies that the entry being displayed originated
                                        // on the NT Directory Service, for clients that use ADSI and
                                        // retrieve additional information from the service.

//      MAPI_UNICODE        0x80000000  // Indicates that the WED.lpsz string is actually a UNICODE
                                        //  string and should be cast to a (LPWSTR) before using it
                                        // If this flag is not present then the WED.lpsz is a DBCS string
                                        //  and should be cast to an LPSTR before using.

// Struct
typedef struct _WABEXTDISPLAY
{
    ULONG cbSize;
    LPWABOBJECT lpWABObject;    // pointer to IWABObject
    LPADRBOOK lpAdrBook;        // pointer to IAdrBook object
    LPMAPIPROP lpPropObj;       // Object being displayed
    BOOL fReadOnly;             // Indicates if this is a ReadOnly mode
    BOOL fDataChanged;          // Set by extension sheet to signal data change
    ULONG ulFlags;              // See above
    LPVOID lpv;                 // Used for passing in specific data
    LPTSTR lpsz;               // Used for passing in specific data
} WABEXTDISPLAY, FAR * LPWABEXTDISPLAY;

/* --------------------- */

#define WAB_IWABEXTINIT_METHODS(IPURE)                          \
        MAPIMETHOD(Initialize)                                  \
            (THIS_  LPWABEXTDISPLAY lpWABExtDisplay)    IPURE;  \

#undef           INTERFACE
#define          INTERFACE      IWABExtInit
DECLARE_MAPI_INTERFACE_(IWABExtInit, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABEXTINIT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABExtInit, LPWABEXTINIT);

DEFINE_GUID(IID_IWABExtInit, 
0xea22ebf0, 0x87a4, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);


/* --------------------- */

#ifndef WIN16
#define WAB_DLL_NAME TEXT("WAB32.DLL")
#else
#define WAB_DLL_NAME "WAB16.DLL"
#endif

#define WAB_DLL_PATH_KEY TEXT("Software\\Microsoft\\WAB\\DLLPath")

#ifdef __cplusplus
}
#endif

#endif /* _WABAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabiab.h ===
/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */


#ifndef WABIAB_H
#define WABIAB_H

// These are WAB only flags for IAdrBook::ResolveName
//      MAPI_UNICODE                        ((ULONG) 0x80000000)
#define WAB_RESOLVE_LOCAL_ONLY              ((ULONG) 0x80000000) 
#define WAB_RESOLVE_ALL_EMAILS              ((ULONG) 0x40000000)
#define WAB_RESOLVE_NO_ONE_OFFS             ((ULONG) 0x20000000)
#define WAB_RESOLVE_NEED_CERT               ((ULONG) 0x10000000)
#define WAB_RESOLVE_NO_NOT_FOUND_UI         ((ULONG) 0x08000000)
#define WAB_RESOLVE_USE_CURRENT_PROFILE     ((ULONG) 0x04000000)
#define WAB_RESOLVE_FIRST_MATCH             ((ULONG) 0x02000000)
#define WAB_RESOLVE_UNICODE                 ((ULONG) 0x01000000)
//      MAPI_DIALOG                         ((ULONG) 0x00000008)

#ifndef MAPIX_H

#define MAPI_IADDRBOOK_METHODS(IPURE)									\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(ResolveName)												\
		(THIS_	ULONG_PTR						ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszNewEntryTitle,			\
				LPADRLIST					lpAdrList) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RecipOptions)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPADRENTRY					lpRecip) IPURE;				\
	MAPIMETHOD(QueryDefaultRecipOpt)									\
		(THIS_	LPTSTR						lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(GetPAB)													\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetPAB)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetDefaultDir)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetDefaultDir)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet FAR *				lppSearchPath) IPURE;		\
	MAPIMETHOD(SetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSearchPath) IPURE;		\
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);
#endif  // MAPIX_H
#endif  // WABIAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\xmldomdid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDOMDID_H__
#define __XMLDOMDID_H__
//;end_internal

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabtags.h ===
/*
 *  WABTAGS.H
 *
 *  Property tag definitions for standard properties of WAB
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  0E00    0FFF    MAPI_defined non-transmittable property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6000    65FF    User-defined non-transmittable property
 *  6600    67FF    Provider-defined internal non-transmittable property
 *  6800    7BFF    Message class-defined content property
 *  7C00    7FFF    Message class-defined non-transmittable
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPITAGS_H) && !defined(WABTAGS_H)
#define WABTAGS_H

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
    ((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
    (PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  non-transmittable range for messages. They start at the high
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID                                  PROP_TAG( PT_BINARY,    0x0FFF)
#define PR_OBJECT_TYPE                              PROP_TAG( PT_LONG,      0x0FFE)
#define PR_ICON                                     PROP_TAG( PT_BINARY,    0x0FFD)
#define PR_MINI_ICON                                PROP_TAG( PT_BINARY,    0x0FFC)
#define PR_STORE_ENTRYID                            PROP_TAG( PT_BINARY,    0x0FFB)
#define PR_STORE_RECORD_KEY                         PROP_TAG( PT_BINARY,    0x0FFA)
#define PR_RECORD_KEY                               PROP_TAG( PT_BINARY,    0x0FF9)
#define PR_MAPPING_SIGNATURE                        PROP_TAG( PT_BINARY,    0x0FF8)
#define PR_ACCESS_LEVEL                             PROP_TAG( PT_LONG,      0x0FF7)
#define PR_INSTANCE_KEY                             PROP_TAG( PT_BINARY,    0x0FF6)
#define PR_ROW_TYPE                                 PROP_TAG( PT_LONG,      0x0FF5)
#define PR_ACCESS                                   PROP_TAG( PT_LONG,      0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID                                    PROP_TAG( PT_LONG,      0x3000)
#define PR_DISPLAY_NAME                             PROP_TAG( PT_TSTRING,   0x3001)
#define PR_DISPLAY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3001)
#define PR_DISPLAY_NAME_A                           PROP_TAG( PT_STRING8,   0x3001)
#define PR_ADDRTYPE                                 PROP_TAG( PT_TSTRING,   0x3002)
#define PR_ADDRTYPE_W                               PROP_TAG( PT_UNICODE,   0x3002)
#define PR_ADDRTYPE_A                               PROP_TAG( PT_STRING8,   0x3002)
#define PR_EMAIL_ADDRESS                            PROP_TAG( PT_TSTRING,   0x3003)
#define PR_EMAIL_ADDRESS_W                          PROP_TAG( PT_UNICODE,   0x3003)
#define PR_EMAIL_ADDRESS_A                          PROP_TAG( PT_STRING8,   0x3003)
#define PR_COMMENT                                  PROP_TAG( PT_TSTRING,   0x3004)
#define PR_COMMENT_W                                PROP_TAG( PT_UNICODE,   0x3004)
#define PR_COMMENT_A                                PROP_TAG( PT_STRING8,   0x3004)
#define PR_DEPTH                                    PROP_TAG( PT_LONG,      0x3005)
#define PR_PROVIDER_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3006)
#define PR_PROVIDER_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3006)
#define PR_PROVIDER_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3006)
#define PR_CREATION_TIME                            PROP_TAG( PT_SYSTIME,   0x3007)
#define PR_LAST_MODIFICATION_TIME                   PROP_TAG( PT_SYSTIME,   0x3008)
#define PR_RESOURCE_FLAGS                           PROP_TAG( PT_LONG,      0x3009)
#define PR_PROVIDER_DLL_NAME                        PROP_TAG( PT_TSTRING,   0x300A)
#define PR_PROVIDER_DLL_NAME_W                      PROP_TAG( PT_UNICODE,   0x300A)
#define PR_PROVIDER_DLL_NAME_A                      PROP_TAG( PT_STRING8,   0x300A)
#define PR_SEARCH_KEY                               PROP_TAG( PT_BINARY,    0x300B)
#define PR_PROVIDER_UID                             PROP_TAG( PT_BINARY,    0x300C)
#define PR_PROVIDER_ORDINAL                         PROP_TAG( PT_LONG,      0x300D)


/* Proptags 35E8-35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS                          PROP_TAG( PT_LONG,      0x3600)
#define PR_FOLDER_TYPE                              PROP_TAG( PT_LONG,      0x3601)
#define PR_CONTENT_COUNT                            PROP_TAG( PT_LONG,      0x3602)
#define PR_CONTENT_UNREAD                           PROP_TAG( PT_LONG,      0x3603)
#define PR_CREATE_TEMPLATES                         PROP_TAG( PT_OBJECT,    0x3604)
#define PR_DETAILS_TABLE                            PROP_TAG( PT_OBJECT,    0x3605)
#define PR_SEARCH                                   PROP_TAG( PT_OBJECT,    0x3607)
#define PR_SELECTABLE                               PROP_TAG( PT_BOOLEAN,   0x3609)
#define PR_SUBFOLDERS                               PROP_TAG( PT_BOOLEAN,   0x360a)
#define PR_STATUS                                   PROP_TAG( PT_LONG,      0x360b)
#define PR_ANR                                      PROP_TAG( PT_TSTRING,   0x360c)
#define PR_ANR_W                                    PROP_TAG( PT_UNICODE,   0x360c)
#define PR_ANR_A                                    PROP_TAG( PT_STRING8,   0x360c)
#define PR_CONTENTS_SORT_ORDER                      PROP_TAG( PT_MV_LONG,   0x360d)
#define PR_CONTAINER_HIERARCHY                      PROP_TAG( PT_OBJECT,    0x360e)
#define PR_CONTAINER_CONTENTS                       PROP_TAG( PT_OBJECT,    0x360f)
#define PR_FOLDER_ASSOCIATED_CONTENTS               PROP_TAG( PT_OBJECT,    0x3610)
#define PR_DEF_CREATE_DL                            PROP_TAG( PT_BINARY,    0x3611)
#define PR_DEF_CREATE_MAILUSER                      PROP_TAG( PT_BINARY,    0x3612)
#define PR_CONTAINER_CLASS                          PROP_TAG( PT_TSTRING,   0x3613)
#define PR_CONTAINER_CLASS_W                        PROP_TAG( PT_UNICODE,   0x3613)
#define PR_CONTAINER_CLASS_A                        PROP_TAG( PT_STRING8,   0x3613)
#define PR_CONTAINER_MODIFY_VERSION                 PROP_TAG( PT_I8,        0x3614)
#define PR_AB_PROVIDER_ID                           PROP_TAG( PT_BINARY,    0x3615)
#define PR_DEFAULT_VIEW_ENTRYID                     PROP_TAG( PT_BINARY,    0x3616)
#define PR_ASSOC_CONTENT_COUNT                      PROP_TAG( PT_LONG,      0x3617)
/* Don't use 36FE and 36FF */


/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE                             PROP_TAG( PT_LONG,      0x3900)
#define PR_TEMPLATEID                               PROP_TAG( PT_BINARY,    0x3902)
#define PR_PRIMARY_CAPABILITY                       PROP_TAG( PT_BINARY,    0x3904)
#define PR_7BIT_DISPLAY_NAME                        PROP_TAG( PT_STRING8,   0x39FF)

/*
 *  Mail user properties
 */

#define PR_ACCOUNT                                  PROP_TAG( PT_TSTRING,   0x3A00)
#define PR_ACCOUNT_W                                PROP_TAG( PT_UNICODE,   0x3A00)
#define PR_ACCOUNT_A                                PROP_TAG( PT_STRING8,   0x3A00)
#define PR_ALTERNATE_RECIPIENT                      PROP_TAG( PT_BINARY,    0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A02)
#define PR_CONVERSION_PROHIBITED                    PROP_TAG( PT_BOOLEAN,   0x3A03)
#define PR_DISCLOSE_RECIPIENTS                      PROP_TAG( PT_BOOLEAN,   0x3A04)
#define PR_GENERATION                               PROP_TAG( PT_TSTRING,   0x3A05)
#define PR_GENERATION_W                             PROP_TAG( PT_UNICODE,   0x3A05)
#define PR_GENERATION_A                             PROP_TAG( PT_STRING8,   0x3A05)
#define PR_GIVEN_NAME                               PROP_TAG( PT_TSTRING,   0x3A06)
#define PR_GIVEN_NAME_W                             PROP_TAG( PT_UNICODE,   0x3A06)
#define PR_GIVEN_NAME_A                             PROP_TAG( PT_STRING8,   0x3A06)
#define PR_GOVERNMENT_ID_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER                  PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W                PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A                PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER                    PROP_TAG( PT_TSTRING,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W                  PROP_TAG( PT_UNICODE,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A                  PROP_TAG( PT_STRING8,   0x3A09)
#define PR_INITIALS                                 PROP_TAG( PT_TSTRING,   0x3A0A)
#define PR_INITIALS_W                               PROP_TAG( PT_UNICODE,   0x3A0A)
#define PR_INITIALS_A                               PROP_TAG( PT_STRING8,   0x3A0A)
#define PR_KEYWORD                                  PROP_TAG( PT_TSTRING,   0x3A0B)
#define PR_KEYWORD_W                                PROP_TAG( PT_UNICODE,   0x3A0B)
#define PR_KEYWORD_A                                PROP_TAG( PT_STRING8,   0x3A0B)
#define PR_LANGUAGE                                 PROP_TAG( PT_TSTRING,   0x3A0C)
#define PR_LANGUAGE_W                               PROP_TAG( PT_UNICODE,   0x3A0C)
#define PR_LANGUAGE_A                               PROP_TAG( PT_STRING8,   0x3A0C)
#define PR_LOCATION                                 PROP_TAG( PT_TSTRING,   0x3A0D)
#define PR_LOCATION_W                               PROP_TAG( PT_UNICODE,   0x3A0D)
#define PR_LOCATION_A                               PROP_TAG( PT_STRING8,   0x3A0D)
#define PR_MAIL_PERMISSION                          PROP_TAG( PT_BOOLEAN,   0x3A0E)
#define PR_MHS_COMMON_NAME                          PROP_TAG( PT_TSTRING,   0x3A0F)
#define PR_MHS_COMMON_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A0F)
#define PR_MHS_COMMON_NAME_A                        PROP_TAG( PT_STRING8,   0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A10)
#define PR_SURNAME                                  PROP_TAG( PT_TSTRING,   0x3A11)
#define PR_SURNAME_W                                PROP_TAG( PT_UNICODE,   0x3A11)
#define PR_SURNAME_A                                PROP_TAG( PT_STRING8,   0x3A11)
#define PR_ORIGINAL_ENTRYID                         PROP_TAG( PT_BINARY,    0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME                    PROP_TAG( PT_TSTRING,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A                  PROP_TAG( PT_STRING8,   0x3A13)
#define PR_ORIGINAL_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3A14)
#define PR_POSTAL_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A15)
#define PR_POSTAL_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A15)
#define PR_POSTAL_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A15)
#define PR_COMPANY_NAME                             PROP_TAG( PT_TSTRING,   0x3A16)
#define PR_COMPANY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A16)
#define PR_COMPANY_NAME_A                           PROP_TAG( PT_STRING8,   0x3A16)
#define PR_TITLE                                    PROP_TAG( PT_TSTRING,   0x3A17)
#define PR_TITLE_W                                  PROP_TAG( PT_UNICODE,   0x3A17)
#define PR_TITLE_A                                  PROP_TAG( PT_STRING8,   0x3A17)
#define PR_DEPARTMENT_NAME                          PROP_TAG( PT_TSTRING,   0x3A18)
#define PR_DEPARTMENT_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A18)
#define PR_DEPARTMENT_NAME_A                        PROP_TAG( PT_STRING8,   0x3A18)
#define PR_OFFICE_LOCATION                          PROP_TAG( PT_TSTRING,   0x3A19)
#define PR_OFFICE_LOCATION_W                        PROP_TAG( PT_UNICODE,   0x3A19)
#define PR_OFFICE_LOCATION_A                        PROP_TAG( PT_STRING8,   0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER                 PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W               PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A               PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER                  PROP_TAG( PT_TSTRING,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W                PROP_TAG( PT_UNICODE,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A                PROP_TAG( PT_STRING8,   0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER                PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W              PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A              PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME                PROP_TAG( PT_TSTRING,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W              PROP_TAG( PT_UNICODE,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A              PROP_TAG( PT_STRING8,   0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER                  PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W                PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A                PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE                         PROP_TAG( PT_BINARY,    0x3A22)
#define PR_PRIMARY_FAX_NUMBER                       PROP_TAG( PT_TSTRING,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W                     PROP_TAG( PT_UNICODE,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A                     PROP_TAG( PT_STRING8,   0x3A23)
#define PR_BUSINESS_FAX_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A24)
#define PR_HOME_FAX_NUMBER                          PROP_TAG( PT_TSTRING,   0x3A25)
#define PR_HOME_FAX_NUMBER_W                        PROP_TAG( PT_UNICODE,   0x3A25)
#define PR_HOME_FAX_NUMBER_A                        PROP_TAG( PT_STRING8,   0x3A25)
#define PR_COUNTRY                                  PROP_TAG( PT_TSTRING,   0x3A26)
#define PR_COUNTRY_W                                PROP_TAG( PT_UNICODE,   0x3A26)
#define PR_COUNTRY_A                                PROP_TAG( PT_STRING8,   0x3A26)
#define PR_LOCALITY                                 PROP_TAG( PT_TSTRING,   0x3A27)
#define PR_LOCALITY_W                               PROP_TAG( PT_UNICODE,   0x3A27)
#define PR_LOCALITY_A                               PROP_TAG( PT_STRING8,   0x3A27)
#define PR_STATE_OR_PROVINCE                        PROP_TAG( PT_TSTRING,   0x3A28)
#define PR_STATE_OR_PROVINCE_W                      PROP_TAG( PT_UNICODE,   0x3A28)
#define PR_STATE_OR_PROVINCE_A                      PROP_TAG( PT_STRING8,   0x3A28)
#define PR_STREET_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A29)
#define PR_STREET_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A29)
#define PR_STREET_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A29)
#define PR_POSTAL_CODE                              PROP_TAG( PT_TSTRING,   0x3A2A)
#define PR_POSTAL_CODE_W                            PROP_TAG( PT_UNICODE,   0x3A2A)
#define PR_POSTAL_CODE_A                            PROP_TAG( PT_STRING8,   0x3A2A)
#define PR_POST_OFFICE_BOX                          PROP_TAG( PT_TSTRING,   0x3A2B)
#define PR_POST_OFFICE_BOX_W                        PROP_TAG( PT_UNICODE,   0x3A2B)
#define PR_POST_OFFICE_BOX_A                        PROP_TAG( PT_STRING8,   0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX         PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W       PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A       PR_POST_OFFICE_BOX_A
#define PR_TELEX_NUMBER                             PROP_TAG( PT_TSTRING,   0x3A2C)
#define PR_TELEX_NUMBER_W                           PROP_TAG( PT_UNICODE,   0x3A2C)
#define PR_TELEX_NUMBER_A                           PROP_TAG( PT_STRING8,   0x3A2C)
#define PR_ISDN_NUMBER                              PROP_TAG( PT_TSTRING,   0x3A2D)
#define PR_ISDN_NUMBER_W                            PROP_TAG( PT_UNICODE,   0x3A2D)
#define PR_ISDN_NUMBER_A                            PROP_TAG( PT_STRING8,   0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A2F)
#define PR_ASSISTANT                                PROP_TAG( PT_TSTRING,   0x3A30)
#define PR_ASSISTANT_W                              PROP_TAG( PT_UNICODE,   0x3A30)
#define PR_ASSISTANT_A                              PROP_TAG( PT_STRING8,   0x3A30)
#define PR_SEND_RICH_INFO                           PROP_TAG( PT_BOOLEAN,   0x3A40)
#define PR_WEDDING_ANNIVERSARY                      PROP_TAG( PT_SYSTIME,   0x3A41)
#define PR_BIRTHDAY                                 PROP_TAG( PT_SYSTIME,   0x3A42)
#define PR_HOBBIES                                  PROP_TAG( PT_TSTRING,   0x3A43)
#define PR_HOBBIES_W                                PROP_TAG( PT_UNICODE,   0x3A43)
#define PR_HOBBIES_A                                PROP_TAG( PT_STRING8,   0x3A43)
#define PR_MIDDLE_NAME                              PROP_TAG( PT_TSTRING,   0x3A44)
#define PR_MIDDLE_NAME_W                            PROP_TAG( PT_UNICODE,   0x3A44)
#define PR_MIDDLE_NAME_A                            PROP_TAG( PT_STRING8,   0x3A44)
#define PR_DISPLAY_NAME_PREFIX                      PROP_TAG( PT_TSTRING,   0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W                    PROP_TAG( PT_UNICODE,   0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A                    PROP_TAG( PT_STRING8,   0x3A45)
#define PR_PROFESSION                               PROP_TAG( PT_TSTRING,   0x3A46)
#define PR_PROFESSION_W                             PROP_TAG( PT_UNICODE,   0x3A46)
#define PR_PROFESSION_A                             PROP_TAG( PT_STRING8,   0x3A46)
#define PR_PREFERRED_BY_NAME                        PROP_TAG( PT_TSTRING,   0x3A47)
#define PR_PREFERRED_BY_NAME_W                      PROP_TAG( PT_UNICODE,   0x3A47)
#define PR_PREFERRED_BY_NAME_A                      PROP_TAG( PT_STRING8,   0x3A47)
#define PR_SPOUSE_NAME                              PROP_TAG( PT_TSTRING,   0x3A48)
#define PR_SPOUSE_NAME_W                            PROP_TAG( PT_UNICODE,   0x3A48)
#define PR_SPOUSE_NAME_A                            PROP_TAG( PT_STRING8,   0x3A48)
#define PR_COMPUTER_NETWORK_NAME                    PROP_TAG( PT_TSTRING,   0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A                  PROP_TAG( PT_STRING8,   0x3A49)
#define PR_CUSTOMER_ID                              PROP_TAG( PT_TSTRING,   0x3A4A)
#define PR_CUSTOMER_ID_W                            PROP_TAG( PT_UNICODE,   0x3A4A)
#define PR_CUSTOMER_ID_A                            PROP_TAG( PT_STRING8,   0x3A4A)
#define PR_TTYTDD_PHONE_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A4B)
#define PR_FTP_SITE                                 PROP_TAG( PT_TSTRING,   0x3A4C)
#define PR_FTP_SITE_W                               PROP_TAG( PT_UNICODE,   0x3A4C)
#define PR_FTP_SITE_A                               PROP_TAG( PT_STRING8,   0x3A4C)
#define PR_GENDER                                   PROP_TAG( PT_SHORT,     0x3A4D)
#define PR_MANAGER_NAME                             PROP_TAG( PT_TSTRING,   0x3A4E)
#define PR_MANAGER_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A4E)
#define PR_MANAGER_NAME_A                           PROP_TAG( PT_STRING8,   0x3A4E)
#define PR_NICKNAME                                 PROP_TAG( PT_TSTRING,   0x3A4F)
#define PR_NICKNAME_W                               PROP_TAG( PT_UNICODE,   0x3A4F)
#define PR_NICKNAME_A                               PROP_TAG( PT_STRING8,   0x3A4F)
#define PR_PERSONAL_HOME_PAGE                       PROP_TAG( PT_TSTRING,   0x3A50)
#define PR_PERSONAL_HOME_PAGE_W                     PROP_TAG( PT_UNICODE,   0x3A50)
#define PR_PERSONAL_HOME_PAGE_A                     PROP_TAG( PT_STRING8,   0x3A50)
#define PR_BUSINESS_HOME_PAGE                       PROP_TAG( PT_TSTRING,   0x3A51)
#define PR_BUSINESS_HOME_PAGE_W                     PROP_TAG( PT_UNICODE,   0x3A51)
#define PR_BUSINESS_HOME_PAGE_A                     PROP_TAG( PT_STRING8,   0x3A51)
#define PR_CONTACT_VERSION                          PROP_TAG( PT_CLSID,     0x3A52)
#define PR_CONTACT_ENTRYIDS                         PROP_TAG( PT_MV_BINARY, 0x3A53)
#define PR_CONTACT_ADDRTYPES                        PROP_TAG( PT_MV_TSTRING, 0x3A54)
#define PR_CONTACT_ADDRTYPES_W                      PROP_TAG( PT_MV_UNICODE, 0x3A54)
#define PR_CONTACT_ADDRTYPES_A                      PROP_TAG( PT_MV_STRING8, 0x3A54)
#define PR_CONTACT_DEFAULT_ADDRESS_INDEX            PROP_TAG( PT_LONG,      0x3A55)
#define PR_CONTACT_EMAIL_ADDRESSES                  PROP_TAG( PT_MV_TSTRING, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W                PROP_TAG( PT_MV_UNICODE, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A                PROP_TAG( PT_MV_STRING8, 0x3A56)
#define PR_COMPANY_MAIN_PHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A57)
#define PR_CHILDRENS_NAMES                          PROP_TAG( PT_MV_TSTRING, 0x3A58)
#define PR_CHILDRENS_NAMES_W                        PROP_TAG( PT_MV_UNICODE, 0x3A58)
#define PR_CHILDRENS_NAMES_A                        PROP_TAG( PT_MV_STRING8, 0x3A58)
#define PR_HOME_ADDRESS_CITY                        PROP_TAG( PT_TSTRING,   0x3A59)
#define PR_HOME_ADDRESS_CITY_W                      PROP_TAG( PT_UNICODE,   0x3A59)
#define PR_HOME_ADDRESS_CITY_A                      PROP_TAG( PT_STRING8,   0x3A59)
#define PR_HOME_ADDRESS_COUNTRY                     PROP_TAG( PT_TSTRING,   0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W                   PROP_TAG( PT_UNICODE,   0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A                   PROP_TAG( PT_STRING8,   0x3A5A)
#define PR_HOME_ADDRESS_POSTAL_CODE                 PROP_TAG( PT_TSTRING,   0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W               PROP_TAG( PT_UNICODE,   0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A               PROP_TAG( PT_STRING8,   0x3A5B)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE           PROP_TAG( PT_TSTRING,   0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W         PROP_TAG( PT_UNICODE,   0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A         PROP_TAG( PT_STRING8,   0x3A5C)
#define PR_HOME_ADDRESS_STREET                      PROP_TAG( PT_TSTRING,   0x3A5D)
#define PR_HOME_ADDRESS_STREET_W                    PROP_TAG( PT_UNICODE,   0x3A5D)
#define PR_HOME_ADDRESS_STREET_A                    PROP_TAG( PT_STRING8,   0x3A5D)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX             PROP_TAG( PT_TSTRING,   0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W           PROP_TAG( PT_UNICODE,   0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A           PROP_TAG( PT_STRING8,   0x3A5E)
#define PR_OTHER_ADDRESS_CITY                       PROP_TAG( PT_TSTRING,   0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W                     PROP_TAG( PT_UNICODE,   0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A                     PROP_TAG( PT_STRING8,   0x3A5F)
#define PR_OTHER_ADDRESS_COUNTRY                    PROP_TAG( PT_TSTRING,   0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W                  PROP_TAG( PT_UNICODE,   0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A                  PROP_TAG( PT_STRING8,   0x3A60)
#define PR_OTHER_ADDRESS_POSTAL_CODE                PROP_TAG( PT_TSTRING,   0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W              PROP_TAG( PT_UNICODE,   0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A              PROP_TAG( PT_STRING8,   0x3A61)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE          PROP_TAG( PT_TSTRING,   0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W        PROP_TAG( PT_UNICODE,   0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A        PROP_TAG( PT_STRING8,   0x3A62)
#define PR_OTHER_ADDRESS_STREET                     PROP_TAG( PT_TSTRING,   0x3A63)
#define PR_OTHER_ADDRESS_STREET_W                   PROP_TAG( PT_UNICODE,   0x3A63)
#define PR_OTHER_ADDRESS_STREET_A                   PROP_TAG( PT_STRING8,   0x3A63)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX            PROP_TAG( PT_TSTRING,   0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W          PROP_TAG( PT_UNICODE,   0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A          PROP_TAG( PT_STRING8,   0x3A64)
#define PR_USER_X509_CERTIFICATE                    PROP_TAG( PT_MV_BINARY, 0x3A70)
#define PR_SEND_INTERNET_ENCODING                   PROP_TAG( PT_LONG,      0x3A71)



#define PR_BUSINESS_ADDRESS_CITY                    PR_LOCALITY
#define PR_BUSINESS_ADDRESS_COUNTRY                 PR_COUNTRY
#define PR_BUSINESS_ADDRESS_POSTAL_CODE             PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE       PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STREET                  PR_STREET_ADDRESS


/*
 *	Message recipient properties
 */

#define PR_RECIPIENT_TYPE                           PROP_TAG( PT_LONG,      0x0C15)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN                          0x67F0
#define PROP_ID_SECURE_MAX                          0x67FF


/* These are the bits that show up in PR_SEND_INTERNET_ENCODING */

/* whether or not an encoding preference is specified
 1 - pay attention to the rest of the bits for the encoding preferences
 0 - let the mail system choose what's best for it
*/
#define ENCODING_PREFERENCE                     ((ULONG) 0x00020000)

/*
 1 - message in MIME;
 0 - plain text/uuencode attachments
*/
#define ENCODING_TEXT                           ((ULONG) 0x00000000)
#define ENCODING_MIME                           ((ULONG) 0x00040000)


/* Specifies how the body of the message is encoded.
 00 - Body encoded as text
 01 - body encoded as HTML (only valid if message in MIME)
 10 - (actualy 1X) Text and HTML as multipart alternative (only valid if message in MIME)
*/
#define BODY_ENCODING_MASK                      ((ULONG) 0x00180000)
#define BODY_ENCODING_TEXT                      ((ULONG) 0x00000000) /* for completeness */
#define BODY_ENCODING_HTML                      ((ULONG) 0x00080000)
#define BODY_ENCODING_TEXT_AND_HTML             ((ULONG) 0x00100000)

/* Specifies how to handle Mac attachments
 00 - BinHex
 01 - UUENCODED (not valid if message in MIME - will be ignored, BinHex used instead)
 10 - Apple Single (only valid if message in MIME)
 11 - Apple Double (only valid if message in MIME)
*/
#define MAC_ATTACH_ENCODING_MASK                ((ULONG) 0x00600000)
#define MAC_ATTACH_ENCODING_BINHEX              ((ULONG) 0x00000000)
#define MAC_ATTACH_ENCODING_UUENCODE            ((ULONG) 0x00200000)
#define MAC_ATTACH_ENCODING_APPLESINGLE         ((ULONG) 0x00400000)
#define MAC_ATTACH_ENCODING_APPLEDOUBLE         ((ULONG) 0x00600000)


// Values for PR_GENDER property
enum Gender {
	genderUnspecified = 0,
	genderFemale,
	genderMale
};

#endif  /* WABTAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\published\inc\wabutil.h ===
/*
 *	WABUTIL.H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPI[xx].DLL.
 *
 *  Copyright 1986-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(_MAPIUTIL_H) && !defined(_WABUTIL_H)
#define _WABUTIL_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
	ULONG		ulCallerData,
	LPTABLEDATA	lpTblData,
	LPMAPITABLE	lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrGetView)												\
		(THIS_	LPSSortOrderSet				lpSSortOrderSet,			\
				CALLERRELEASE FAR *			lpfCallerRelease,			\
				ULONG						ulCallerData,				\
				LPMAPITABLE FAR *			lppMAPITable) IPURE;		\
	MAPIMETHOD(HrModifyRow)												\
		(THIS_	LPSRow) IPURE;											\
	MAPIMETHOD(HrDeleteRow)												\
		(THIS_	LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrQueryRow)												\
		(THIS_	LPSPropValue				lpsPropValue,				\
				LPSRow FAR *				lppSRow,					\
				ULONG FAR *					lpuliRow) IPURE;			\
	MAPIMETHOD(HrEnumRow)												\
		(THIS_	ULONG						ulRowNumber,				\
				LPSRow FAR *				lppSRow) IPURE;				\
	MAPIMETHOD(HrNotify)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrInsertRow)												\
		(THIS_	ULONG						uliRow,						\
				LPSRow						lpSRow) IPURE;				\
	MAPIMETHOD(HrModifyRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSRowSet) IPURE;			\
	MAPIMETHOD(HrDeleteRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lprowsetToDelete,			\
				ULONG FAR *					cRowsDeleted) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE	ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*	CreateTable()
 *		Creates the internal memory structures and object handle
 *		to bring a new table into existence.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPITableData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lpvReserved
 *		Reserved.  Should be NULL.
 *	ulTableType
 *		TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *		as part of the GetStatus return data on its views
 *	ulPropTagIndexColumn
 *		Index column for use when changing the data
 *	lpSPropTagArrayColumns
 *		Column proptags for the minimum set of columns in the table
 *	lppTableData
 *		Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 ULONG					ulTableType,
			 ULONG					ulPropTagIndexColumn,
			 LPSPropTagArray		lpSPropTagArrayColumns,
			 LPTABLEDATA FAR *		lppTableData );


/*	HrGetView()
 *		This function obtains a new view on the underlying data
 *		which supports the IMAPITable interface.  All rows and columns
 *		of the underlying table data are initially visible
 *	lpSSortOrderSet
 *		if specified, results in the view being sorted
 *	lpfCallerRelease
 *		pointer to a routine to be called when the view is released, or
 *		NULL.
 *	ulCallerData
 *		arbitrary data the caller wants saved with this view and returned in
 *		the Release callback.
 */

/*	HrModifyRows()
 *		Add or modify a set of rows in the table data
 *	ulFlags
 *		Must be zero
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrModifyRow()
 *		Add or modify one row in the table
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrDeleteRows()
 *		Delete a row in the table.
 *	ulFlags
 *		TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *					   lpSRowSet is ignored in this case.
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		deleted.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */
#define	TAD_ALL_ROWS	1

/*	HrDeleteRow()
 *		Delete a row in the table.
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 */

/*	HrQueryRow()
 *		Returns the values of a specified row in the table
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 *	lppSRow
 *		Address of where to return a pointer to an SRow
 *	lpuliRow
 *	  Address of where to return the row number. This can be NULL
 *	  if the row number is not required.
 *
 */

/*	HrEnumRow()
 *		Returns the values of a specific (numbered) row in the table
 *	ulRowNumber
 *		Indicates row number 0 to n-1
 *	lppSRow
 *		Address of where to return a pointer to a SRow
 */

/*	HrInsertRow()
 *		Inserts a row into the table.
 *	uliRow
 *		The row number before which this row will be inserted into the table.
 *		Row numbers can be from 0 to n where o to n-1 result in row insertion
 *	  a row number of n results in the row being appended to the table.
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrSetObjAccess)											\
		(THIS_	ULONG						ulAccess) IPURE;			\
	MAPIMETHOD(HrSetPropAccess)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG FAR *					rgulAccess) IPURE;			\
	MAPIMETHOD(HrGetPropAccess)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTagArray,			\
				ULONG FAR * FAR *			lprgulAccess) IPURE;		\
	MAPIMETHOD(HrAddObjProps)											\
		(THIS_	LPSPropTagArray				lppPropTagArray,			\
				LPSPropProblemArray FAR *	lprgulAccess) IPURE;


#undef		 INTERFACE
#define		 INTERFACE	IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*	CreateIProp()
 *		Creates the internal memory structures and object handle
 *		to bring a new property interface into existance.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lppPropData
 *		Address of the pointer which will receive the IPropData object
 *	lpvReserved
 *		Reserved.  Should be NULL.
 */

// If MAPI isn't included, use WABCreateIProp instead
#ifndef CreateIProp
STDAPI_(SCODE)
CreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );
#endif

STDAPI_(SCODE)
WABCreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );

/*
 *	Defines for prop/obj access
 */
#define IPROP_READONLY		((ULONG) 0x00000001)
#define IPROP_READWRITE		((ULONG) 0x00000002)
#define IPROP_CLEAN			((ULONG) 0x00010000)
#define IPROP_DIRTY			((ULONG) 0x00020000)

/*
 -	HrSetPropAccess
 -
 *	Sets access right attributes on a per-property basis.  By default,
 *	all properties are read/write.
 *
 */

/*
 -	HrSetObjAccess
 -
 *	Sets access rights for the object itself.  By default, the object has
 *	read/write access.
 *
 */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *	PRI
 *
 *	Priority of an idle task.
 *	The idle engine sorts tasks by priority, and the one with the higher
 *	value runs first. Within a priority level, the functions are called
 *	round-robin.
 */

#define PRILOWEST	-32768
#define PRIHIGHEST	32767
#define PRIUSER		0

/*
 *	IRO
 *
 *	Idle routine options.  This is a combined bit mask consisting of
 *	individual firo's.	Listed below are the possible bit flags.
 *
 *		FIROWAIT and FIROINTERVAL are mutually exclusive.
 *		If neither of the flags are specified, the default action
 *		is to ignore the time parameter of the idle function and
 *		call it as often as possible if firoPerBlock is not set;
 *		otherwise call it one time only during the idle block
 *		once the time constraint has been set. FIROINTERVAL
 *		is also incompatible with FIROPERBLOCK.
 *
 *		FIROWAIT		- time given is minimum idle time before calling
 *						  for the first time in the block of idle time,
 *						  afterwhich call as often as possible.
 *		FIROINTERVAL	- time given is minimum interval between each
 *						  successive call
 *		FIROPERBLOCK	- called only once per contiguous block of idle
 *						  time
 *		FIRODISABLED	- initially disabled when registered, the
 *						  default is to enable the function when registered.
 *		FIROONCEONLY	- called only one time by the scheduler and then
 *						  deregistered automatically.
 */

#define IRONULL			((USHORT) 0x0000)
#define FIROWAIT		((USHORT) 0x0001)
#define FIROINTERVAL	((USHORT) 0x0002)
#define FIROPERBLOCK	((USHORT) 0x0004)
#define FIRODISABLED	((USHORT) 0x0020)
#define FIROONCEONLY	((USHORT) 0x0040)

/*
 *	IRC
 *
 *	Idle routine change options. This is a combined bit mask consisting
 *	of individual firc's; each one identifies an aspect of the idle task
 *	that can be changed.
 *
 */

#define IRCNULL			((USHORT) 0x0000)
#define FIRCPFN			((USHORT) 0x0001)	/* change function pointer */
#define FIRCPV			((USHORT) 0x0002)	/* change parameter block  */
#define FIRCPRI			((USHORT) 0x0004)	/* change priority		   */
#define FIRCCSEC		((USHORT) 0x0008)	/* change time			   */
#define FIRCIRO			((USHORT) 0x0010)	/* change routine options  */

/*
 *	Type definition for idle functions.	 An idle function takes one
 *	parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE FAR *PFNIDLE;

/*
 *	FTG
 *
 *	Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void FAR *FTG;
typedef FTG  FAR *PFTG;
#define FTGNULL			((FTG) NULL)

/*
 -	MAPIInitIdle/MAPIDeinitIdle
 -
 *	Purpose:
 *		Initialises the idle engine
 *		If the initialisation succeded, returns 0, else returns -1
 *
 *	Arguments:
 *		lpvReserved		Reserved, must be NULL.
 */

STDAPI_(LONG)
MAPIInitIdle (LPVOID lpvReserved);

STDAPI_(VOID)
MAPIDeinitIdle (VOID);


/*
 *	FtgRegisterIdleRoutine
 *
 *		Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *		as an idle function.
 *
 *		The idle function will be called with the parameter pv by the
 *		idle engine. The function has initial priority priIdle,
 *		associated time csecIdle, and options iroIdle.
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *	DeregisterIdleRoutine
 *
 *		Removes the given routine from the list of idle routines.
 *		The routine will not be called again.  It is the responsibility
 *		of the caller to clean up any data structures pointed to by the
 *		pvIdleParam parameter; this routine does not free the block.
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *	EnableIdleRoutine
 *
 *		Enables or disables an idle routine.
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *	ChangeIdleRoutine
 *
 *		Changes some or all of the characteristics of the given idle
 *		function. The changes to make are indicated with flags in the
 *		ircIdle parameter.
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);


#endif	/* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);


/* StreamOnFile (SOF) */

/*
 *	Methods and #define's for implementing an OLE 2.0 storage stream
 *	(as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME	((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

#ifdef	_WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef	WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *	Copies a single SPropValue from Src to Dest.  Handles all the various
 *	types of properties and will link its allocations given the master
 *	allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue		lpSPropValueDest,
			  LPSPropValue		lpSPropValueSrc,
			  ALLOCATEMORE *	lpfAllocMore,
			  LPVOID			lpvObject );

/*
 *	Returns the size in bytes of structure at lpSPropValue, including the
 *	Value.
 */
STDAPI_(ULONG)
UlPropSize(	LPSPropValue	lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

STDAPI_(void)
GetInstance(LPSPropValue lpPropMv, LPSPropValue lpPropSv, ULONG uliInst);

extern unsigned char rgchCsds[];
extern unsigned char rgchCids[];
extern unsigned char rgchCsdi[];
extern unsigned char rgchCidi[];

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue	lpSPropValueDst,
				   LPSPropValue	lpSPropValueSrc,
				   ULONG		ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue	lpSPropValue1,
				  ULONG			ulRelOp,
				  LPSPropValue	lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue	lpSPropValueA,
				  LPSPropValue	lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer,
				void				(FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *	Function that creates an advise sink object given a notification
 *	callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
				   LPVOID lpvContext,
				   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *	Wraps an existing advise sink with another one which guarantees
 *	that the original advise sink will be called in the thread on
 *	which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
						LPMAPIADVISESINK FAR *lppAdviseSink);



/*
 *	Allows a client and/or provider to force notifications
 *	which are currently queued in the MAPI notification engine
 *	to be dispatched without doing a message dispatch.
 */

STDAPI HrDispatchNotifications (ULONG ulFlags);


/* Service Provider Utilities */

/*
 *	Structures and utility function for buil